# MONOLITHIC SCRIPT (Generated by mushroom recompose)
# ==================================================================================
#Requires -Version 7.0
param(


    [switch]$Debug,


    [switch]$SkipLogo


)
# Global script settings
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# --- START OF ORIGINAL FILE: modules\logger\logger.psm1 ---
# MODULE: logger.psm1

# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.

# This module is self-contained and manages its own state for logging configuration and in-memory log queues.

#



# ------------------------------------------------------------------------------

# Module-Scoped State Variables

# ------------------------------------------------------------------------------

$script:LogPath = $null

$script:LogLevel = "Info" # Default log level.

$script:LogQueue = [System.Collections.Generic.List[object]]::new()

$script:MaxLogSize = 5MB

$script:LogInitialized = $false

$script:CallDepth = 0

$script:TraceAllCalls = $false



# ------------------------------------------------------------------------------

# Private Helper Functions

# ------------------------------------------------------------------------------

function ConvertTo-SerializableObject {

param([object]$Object)

if ($null -eq $Object) { return $null }

$visited = New-Object 'System.Collections.Generic.HashSet[object]'

function Convert-Internal {

param([object]$InputObject, [int]$Depth)

if ($null -eq $InputObject -or $Depth -gt 5) { return $null }

if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }

if ($visited.Contains($InputObject)) { return '<CircularReference>' }

if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) { [void]$visited.Add($InputObject) }

switch ($InputObject.GetType().Name) {

'Hashtable' { $r = @{}; foreach ($k in $InputObject.Keys) { try { $r[$k] = Convert-Internal $InputObject[$k] ($Depth+1) } catch { $r[$k] = "<Err>" } }; return $r }

'PSCustomObject' { $r = @{}; foreach ($p in $InputObject.PSObject.Properties) { try { if ($p.MemberType -ne 'ScriptMethod') { $r[$p.Name] = Convert-Internal $p.Value ($Depth+1) } } catch { $r[$p.Name] = "<Err>" } }; return $r }

'Object[]' { $r = @(); for ($i=0; $i -lt [Math]::Min($InputObject.Count,10); $i++) { try { $r += Convert-Internal $InputObject[$i] ($Depth+1) } catch { $r += "<Err>" } }; if($InputObject.Count -gt 10) { $r += "<...>" }; return $r }

default { try { if ($InputObject -is [ValueType] -or $InputObject -is [string] -or $InputObject -is [datetime]) { return $InputObject } else { return $InputObject.ToString() } } catch { return "<Err>" } }

}

}

return Convert-Internal -InputObject $Object -Depth 0

}



# ------------------------------------------------------------------------------

# Public Functions

# ------------------------------------------------------------------------------

function Initialize-Logger {

[CmdletBinding()]

param(

[string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),

[string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),

[ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]

[string]$Level = "Debug"

)

if ([string]::IsNullOrWhiteSpace($LogDirectory) -or [string]::IsNullOrWhiteSpace($LogFileName)) { Write-Warning "Invalid logger parameters."; return }

try {

if (-not (Test-Path $LogDirectory)) { New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null }

$script:LogPath = Join-Path $LogDirectory $LogFileName

$script:LogLevel = $Level

$script:LogInitialized = $true

Write-Log -Level Info -Message "Logger initialized" -Data @{ LogPath = $script:LogPath; PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS; PID = $PID } -Force

} catch { Write-Warning "Failed to initialize logger: $_"; $script:LogInitialized = $false }

}



function Write-Log {

[CmdletBinding()]

param(

[ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")] [string]$Level = "Info",

[Parameter(Mandatory)] [string]$Message,

[object]$Data,

[switch]$Force

)

if (-not $script:LogInitialized -and -not $Force) { return }

$levelPriority = @{ Debug=0; Trace=0; Verbose=1; Info=2; Warning=3; Error=4; Fatal=5 }

if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }

try {

$caller = (Get-PSCallStack)[1]

$logContext = @{

Timestamp = (Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"); Level = $Level; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId

CallDepth = $script:CallDepth; Message = $Message; Caller = @{ Command = $caller.Command; Location = $caller.Location; ScriptName = $caller.ScriptName; LineNumber = $caller.ScriptLineNumber }

}

if ($PSBoundParameters.ContainsKey('Data')) { $logContext.UserData = if ($Data -is [Exception]) { @{ Type="Exception"; Message=$Data.Message; StackTrace=$Data.StackTrace; InnerException=$Data.InnerException.Message } } else { ConvertTo-SerializableObject -Object $Data } }

$indent = "  " * $script:CallDepth

$callerInfo = if ($caller.ScriptName) { "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)" } else { $caller.Command }

$logEntry = "$($logContext.Timestamp) [$($Level.PadRight(7))] $indent [$callerInfo] $Message"

if ($PSBoundParameters.ContainsKey('Data')) { $logEntry += if ($Data -is [Exception]) { "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)" } else { try { "`n${indent}  Data: $(ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue)" } catch { "`n${indent}  Data: $($Data.ToString())" } } }

$script:LogQueue.Add($logContext)

if ($script:LogQueue.Count -gt 2000) { $script:LogQueue.RemoveRange(0, 1000) }

if ($script:LogPath) {

try {

if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) { Move-Item $script:LogPath ($script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log") -Force }

Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force

} catch { Write-Host "LOG WRITE FAILED: $logEntry`nError: $_" -ForegroundColor Yellow }

}

if ($Level -in @('Error', 'Fatal', 'Warning')) { Write-Host $logEntry -ForegroundColor ($Level -in @('Error', 'Fatal') ? 'Red' : 'Yellow') }

} catch { try { $errorEntry = "$(Get-Date -Format 'o') [LOGGER ERROR] Failed to log: $_"; if ($script:LogPath) { Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8 }; Write-Host $errorEntry -ForegroundColor Red } catch { Write-Host "CRITICAL: Logger failed: $_" -ForegroundColor Red } }

}



function Trace-FunctionEntry { [CmdletBinding()] param([string]$FunctionName, [object]$Parameters); if (-not $script:TraceAllCalls) { return }; $script:CallDepth++; Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{ Parameters=$Parameters; Action="FunctionEntry" } }

function Trace-FunctionExit { [CmdletBinding()] param([string]$FunctionName, [object]$ReturnValue, [switch]$WithError); if (-not $script:TraceAllCalls) { return }; Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{ ReturnValue=$ReturnValue; Action=($WithError ? "FunctionExitWithError" : "FunctionExit"); HasError=$WithError.IsPresent }; $script:CallDepth = [Math]::Max(0, $script:CallDepth - 1) }

function Trace-Step { [CmdletBinding()] param([string]$StepName, [object]$StepData, [string]$Module); $caller = (Get-PSCallStack)[1]; $moduleInfo = $Module ?? ($caller.ScriptName ? [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) : "Unknown"); Write-Log -Level Debug -Message "STEP: $StepName" -Data @{ StepData=$StepData; Module=$moduleInfo; Action="Step" } }

function Trace-StateChange { [CmdletBinding()] param([string]$StateType, [object]$OldValue, [object]$NewValue, [string]$PropertyPath); Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{ StateType=$StateType; PropertyPath=$PropertyPath; OldValue=$OldValue; NewValue=$NewValue; Action="StateChange" } }

function Trace-ComponentLifecycle { [CmdletBinding()] param([string]$ComponentType, [string]$ComponentId, [ValidateSet('Create','Initialize','Render','Update','Destroy')] [string]$Phase, [object]$ComponentData); Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{ ComponentType=$ComponentType; ComponentId=$ComponentId; Phase=$Phase; ComponentData=$ComponentData; Action="ComponentLifecycle" } }

function Trace-ServiceCall { [CmdletBinding()] param([string]$ServiceName, [string]$MethodName, [object]$Parameters, [object]$Result, [switch]$IsError); Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{ ServiceName=$ServiceName; MethodName=$MethodName; Parameters=$Parameters; Result=$Result; Action=($IsError ? "ServiceCallError" : "ServiceCall"); IsError=$IsError.IsPresent } }



function Get-LogEntries {

[CmdletBinding()]

param([int]$Count = 100, [string]$Level, [string]$Module, [string]$Action)

try {

$entries = $script:LogQueue.ToArray()

if ($Level) { $entries = $entries | Where-Object { $_.Level -eq $Level } }

if ($Module) { $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") } }

if ($Action) { $entries = $entries | Where-Object { $_.UserData.Action -eq $Action } }

return $entries | Select-Object -Last $Count

} catch { Write-Warning "Error getting log entries: $_"; return @() }

}



function Get-CallTrace {

[CmdletBinding()]

param([int]$Depth = 10)

try {

$callStack = Get-PSCallStack; $trace = @()

for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { $call = $callStack[$i]; $trace += @{ Level=$i-1; Command=$call.Command; Location=$call.Location; ScriptName=$call.ScriptName; LineNumber=$call.ScriptLineNumber } }

return $trace

} catch { Write-Warning "Error getting call trace: $_"; return @() }

}



function Clear-LogQueue { try { $script:LogQueue.Clear(); Write-Log -Level Info -Message "In-memory log queue cleared" } catch { Write-Warning "Error clearing log queue: $_" } }

function Set-LogLevel { [CmdletBinding()] param([Parameter(Mandatory)] [ValidateSet("Debug","Verbose","Info","Warning","Error","Fatal","Trace")] [string]$Level); try { $oldLevel = $script:LogLevel; $script:LogLevel = $Level; Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force } catch { Write-Warning "Error setting log level to '$Level': $_" } }

function Enable-CallTracing { $script:TraceAllCalls = $true; Write-Log -Level Info -Message "Call tracing enabled" -Force }

function Disable-CallTracing { $script:TraceAllCalls = $false; Write-Log -Level Info -Message "Call tracing disabled" -Force }

function Get-LogPath { return $script:LogPath }



function Get-LogStatistics {

[CmdletBinding()]

param()

try {

$stats = [PSCustomObject]@{ TotalEntries=$script:LogQueue.Count; LogPath=$script:LogPath; LogLevel=$script:LogLevel; CallTracingEnabled=$script:TraceAllCalls; LogFileSize=($script:LogPath -and (Test-Path $script:LogPath) ? (Get-Item $script:LogPath).Length : 0); EntriesByLevel=@{}; EntriesByModule=@{}; EntriesByAction=@{} }

foreach ($entry in $script:LogQueue) {

$level = $entry.Level; if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level]=0 }; $stats.EntriesByLevel[$level]++

if ($entry.Caller.ScriptName) { $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName); if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module]=0 }; $stats.EntriesByModule[$module]++ }

if ($entry.UserData.Action) { $action = $entry.UserData.Action; if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action]=0 }; $stats.EntriesByAction[$action]++ }

}

return $stats

} catch { Write-Warning "Error getting log statistics: $_"; return [PSCustomObject]@{} }

}
# --- END OF ORIGINAL FILE: modules\logger\logger.psm1 ---

# --- START OF ORIGINAL FILE: modules\exceptions\exceptions.psm1 ---
# MODULE: exceptions.psm1

# PURPOSE: Provides custom exception types and a centralized error handling wrapper

#



# ------------------------------------------------------------------------------

# Module-Scoped State Variables

# ------------------------------------------------------------------------------



$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()

$script:MaxErrorHistory = 100



# ------------------------------------------------------------------------------

# Custom Exception Type Definition

# ------------------------------------------------------------------------------



try {

if (-not ('Helios.HeliosException' -as [type])) {

Add-Type -TypeDefinition @"

using System;

using System.Management.Automation;

using System.Collections;



namespace Helios {

public class HeliosException : System.Management.Automation.RuntimeException {

public Hashtable DetailedContext { get; set; }

public string Component { get; set; }

public DateTime Timestamp { get; set; }



public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)

: base(message, innerException) {

this.Component = component ?? "Unknown";

this.DetailedContext = detailedContext ?? new Hashtable();

this.Timestamp = DateTime.Now;

}

}



public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }

public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }

public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }

public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }

public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }

public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }

}

"@ -ErrorAction Stop

}

} catch {

Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."

}



# ------------------------------------------------------------------------------

# Error Handling Wrapper

# ------------------------------------------------------------------------------



function Invoke-WithErrorHandling {

[CmdletBinding()]

param(

[Parameter(Mandatory)]

[string]$Component,



[Parameter(Mandatory)]

[string]$Context,



[Parameter(Mandatory)]

[scriptblock]$ScriptBlock

)



try {

return & $ScriptBlock

}

catch {

Write-Log -Level Error -Message "$Context failed: $_" -Component $Component

throw

}

}



# ------------------------------------------------------------------------------

# Private Helper Functions

# ------------------------------------------------------------------------------



function _Identify-HeliosComponent {

param([System.Management.Automation.ErrorRecord]$ErrorRecord)

try {

$scriptName = $ErrorRecord.InvocationInfo.ScriptName ?? (Get-PSCallStack | Where-Object ScriptName | Select-Object -First 1).ScriptName

if (-not $scriptName) { return "Interactive/Unknown" }



$fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)



$componentMap = @{

'tui-engine' = 'TUI Engine'; 'navigation' = 'Navigation Service'; 'keybindings' = 'Keybinding Service'

'task-service' = 'Task Service'; 'helios-components' = 'Helios UI Components'; 'helios-panels' = 'Helios UI Panels'

'dashboard-screen' = 'Dashboard Screen'; 'task-screen' = 'Task Screen'; 'exceptions' = 'Exception Module'

'logger' = 'Logger Module'; 'Start-PMCTerminal' = 'Application Entry'

}



foreach ($pattern in $componentMap.Keys) {

if ($fileName -like "*$pattern*") { return $componentMap[$pattern] }

}

return "Unknown ($fileName)"

} catch { return "Component Identification Failed" }

}



function _Get-DetailedError {

param(

[System.Management.Automation.ErrorRecord]$ErrorRecord,

[hashtable]$AdditionalContext = @{}

)

try {

$errorInfo = [PSCustomObject]@{

Timestamp = Get-Date -Format "o"; Summary = $ErrorRecord.Exception.Message; Type = $ErrorRecord.Exception.GetType().FullName

Category = $ErrorRecord.CategoryInfo.Category.ToString(); TargetObject = $ErrorRecord.TargetObject

ScriptName = $ErrorRecord.InvocationInfo.ScriptName; LineNumber = $ErrorRecord.InvocationInfo.ScriptLineNumber

Line = $ErrorRecord.InvocationInfo.Line; PositionMessage = $ErrorRecord.InvocationInfo.PositionMessage

StackTrace = $ErrorRecord.Exception.StackTrace; InnerExceptions = @(); AdditionalContext = $AdditionalContext

SystemContext = @{

ProcessId = $PID; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId

PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS

}

}



$innerEx = $ErrorRecord.Exception.InnerException

while ($innerEx) {

$errorInfo.InnerExceptions += [PSCustomObject]@{ Message = $innerEx.Message; Type = $innerEx.GetType().FullName; StackTrace = $innerEx.StackTrace }

$innerEx = $innerEx.InnerException

}

return $errorInfo

} catch {

return [PSCustomObject]@{ Timestamp = Get-Date -Format "o"; Summary = "CRITICAL: Error analysis failed."; OriginalError = $ErrorRecord.Exception.Message; AnalysisError = $_.Exception.Message; Type = "ErrorAnalysisFailure" }

}

}



# ------------------------------------------------------------------------------

# Public Functions

# ------------------------------------------------------------------------------



function Invoke-WithErrorHandling {

[CmdletBinding()]

param(

[Parameter(Mandatory)] [string]$Component,

[Parameter(Mandatory)] [string]$Context,

[Parameter(Mandatory)] [scriptblock]$ScriptBlock,

[hashtable]$AdditionalData = @{}

)



if (-not $ScriptBlock) { throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null." }

$Component = [string]::IsNullOrWhiteSpace($Component) ? "Unknown Component" : $Component

$Context = [string]::IsNullOrWhiteSpace($Context) ? "Unknown Operation" : $Context



try {

return (& $ScriptBlock)

}

catch {

$originalErrorRecord = $_

$identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord

$finalComponent = ($Component -ne "Unknown Component") ? $Component : $identifiedComponent



$errorContext = @{ Operation = $Context }

$AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }

$detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext



if (Get-Command Write-Log -ErrorAction SilentlyContinue) {

Write-Log -Level Error -Message "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)" -Data $detailedError

}



[void]$script:ErrorHistory.Add($detailedError)

if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) { $script:ErrorHistory.RemoveAt(0) }



$contextHashtable = @{

Operation = $Context; Timestamp = $detailedError.Timestamp; LineNumber = $detailedError.LineNumber

ScriptName = $detailedError.ScriptName ?? "Unknown"

}



foreach ($key in $AdditionalData.Keys) {

$value = $AdditionalData[$key]

if ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) { $contextHashtable[$key] = $value }

}



$heliosException = New-Object Helios.HeliosException($originalErrorRecord.Exception.Message, $finalComponent, $contextHashtable, $originalErrorRecord.Exception)

throw $heliosException

}

}



function Get-ErrorHistory {

[CmdletBinding()]

param([int]$Count = 25)



$total = $script:ErrorHistory.Count

if ($Count -ge $total) { return $script:ErrorHistory }

$start = $total - $Count

return $script:ErrorHistory.GetRange($start, $Count)

}
# --- END OF ORIGINAL FILE: modules\exceptions\exceptions.psm1 ---

# --- START OF ORIGINAL FILE: modules\models\models.psm1 ---
# modules/models/models.psm1
enum TaskPriority { Low; Medium; High; Critical }
enum TaskStatus { Pending; InProgress; Completed; Cancelled }

class PmcTask {
    [string]$Id = [Guid]::NewGuid().ToString(); [string]$Title; [string]$Description; [TaskPriority]$Priority = [TaskPriority]::Medium; [TaskStatus]$Status = [TaskStatus]::Pending; [string]$ProjectKey; [datetime]$CreatedAt = [datetime]::Now; [datetime]$UpdatedAt = [datetime]::Now; [datetime]$DueDate; [bool]$Completed = $false
    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) { $this.Title = $title; $this.Description = $description; $this.Priority = $priority; $this.ProjectKey = $projectKey }
    [hashtable] ToLegacyFormat() { return @{ Id = $this.Id; Title = $this.Title; Description = $this.Description; Priority = $this.Priority.ToString(); Status = $this.Status.ToString(); ProjectKey = $this.ProjectKey; CreatedAt = $this.CreatedAt.ToString("o"); UpdatedAt = $this.UpdatedAt.ToString("o"); DueDate = if($this.DueDate) {$this.DueDate.ToString("o")} else {$null}; Completed = $this.Completed } }
    static [PmcTask] FromLegacyFormat([hashtable]$data) { $task = [PmcTask]::new($data.Title, $data.Description, [TaskPriority]::$($data.Priority), $data.ProjectKey); $task.Id = $data.Id; $task.Status = [TaskStatus]::$($data.Status); $task.CreatedAt = [datetime]::Parse($data.CreatedAt); $task.UpdatedAt = [datetime]::Parse($data.UpdatedAt); if ($data.DueDate) { $task.DueDate = [datetime]::Parse($data.DueDate) }; $task.Completed = $data.Completed; return $task }
}

class PmcProject {
    [string]$Key; [string]$Name; [string]$Description
    PmcProject([string]$key, [string]$name) { $this.Key = $key; $this.Name = $name }
    [hashtable] ToLegacyFormat() { return @{ Key = $this.Key; Name = $this.Name; Description = $this.Description } }
    static [PmcProject] FromLegacyFormat([hashtable]$data) { $project = [PmcProject]::new($data.Key, $data.Name); $project.Description = $data.Description; return $project }
}
# --- END OF ORIGINAL FILE: modules\models\models.psm1 ---

# --- START OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---
# ==============================================================================
# TUI Primitives v3.2 - Truecolor Compositor Foundation
# ==============================================================================
class TuiAnsiHelper {
    static [hashtable] HexToRgb([string]$hexColor) { if ([string]::IsNullOrEmpty($hexColor) -or -not $hexColor.StartsWith("#") -or $hexColor.Length -ne 7) { return $null }; try { return @{ R = [System.Convert]::ToInt32($hexColor.Substring(1, 2), 16); G = [System.Convert]::ToInt32($hexColor.Substring(3, 2), 16); B = [System.Convert]::ToInt32($hexColor.Substring(5, 2), 16) } } catch { Write-Log -Level Warning -Message "Failed to parse hex color: $hexColor."; return $null } }
    static [string] GetAnsiSequence([string]$fgHex, [string]$bgHex, [hashtable]$attributes) { $s = [System.Collections.Generic.List[string]]::new(); if ($fgHex) { $rgb = [TuiAnsiHelper]::HexToRgb($fgHex); if ($rgb) { $s.Add("38;2;$($rgb.R);$($rgb.G);$($rgb.B)") } }; if ($bgHex) { $rgb = [TuiAnsiHelper]::HexToRgb($bgHex); if ($rgb) { $s.Add("48;2;$($rgb.R);$($rgb.G);$($rgb.B)") } }; if ($attributes) { if ($attributes.Bold) { $s.Add("1") }; if ($attributes.Italic) { $s.Add("3") }; if ($attributes.Underline) { $s.Add("4") }; if ($attributes.Strikethrough) { $s.Add("9") } }; if ($s.Count -eq 0) { return "" }; return "`e[$($s -join ';')m" }
    static [string] Reset() { return "`e[0m" }
}
class TuiCell {
    [char]$Char=' ';hidden [string]$_fg="#C0C0C0";hidden [string]$_bg=$null;[string]get_ForegroundColor(){return $this._fg};[void]set_ForegroundColor([string]$v){if($v -match '^#[0-9A-Fa-f]{6}$'){$this._fg=$v}elseif($null-ne $v){Write-Log -Level Warning -Message "Invalid FG: '$v'"}};[string]get_BackgroundColor(){return $this._bg};[void]set_BackgroundColor([string]$v){if($null-eq $v){$this._bg=$null}elseif($v -match '^#[0-9A-Fa-f]{6}$'){$this._bg=$v}else{Write-Log -Level Warning -Message "Invalid BG: '$v'"}};[bool]$Bold=$false;[bool]$Underline=$false;[bool]$Italic=$false;[bool]$Strikethrough=$false;TuiCell(){};TuiCell([TuiCell]$o){if($null-ne $o){$this.Char=$o.Char;$this.ForegroundColor=$o.ForegroundColor;$this.BackgroundColor=$o.BackgroundColor;$this.Bold=$o.Bold;$this.Underline=$o.Underline;$this.Italic=$o.Italic;$this.Strikethrough=$o.Strikethrough}}[bool]DiffersFrom([TuiCell]$o){if($null-eq $o){return $true};return ($this.Char -ne $o.Char -or $this.ForegroundColor -ne $o.ForegroundColor -or $this.BackgroundColor -ne $o.BackgroundColor -or $this.Bold -ne $o.Bold -or $this.Underline -ne $o.Underline -or $this.Italic -ne $o.Italic -or $this.Strikethrough -ne $o.Strikethrough)}
}
class TuiBuffer {
    [TuiCell[,]]$Cells;[int]$Width;[int]$Height;[string]$Name;TuiBuffer([int]$w,[int]$h,[string]$n="Unnamed"){if($w -le 0 -or $h -le 0){throw "!"};$this.Width=$w;$this.Height=$h;$this.Name=$n;$this.Cells=New-Object 'TuiCell[,]' $h,$w;$this.Clear()}[void]Clear(){$this.Clear([TuiCell]::new())}[void]Clear([TuiCell]$fc){for($y=0;$y-lt $this.Height;$y++){for($x=0;$x-lt $this.Width;$x++){$this.Cells[$y,$x]=[TuiCell]::new($fc)}}}[TuiCell]GetCell([int]$x,[int]$y){if($x-lt 0-or $x-ge $this.Width -or $y-lt 0 -or $y-ge $this.Height){return $null};return $this.Cells[$y,$x]}[void]SetCell([int]$x,[int]$y,[TuiCell]$c){if($x-ge 0-and $x-lt $this.Width-and $y-ge 0-and $y-lt $this.Height-and $null-ne $c){$this.Cells[$y,$x]=$c}}[void]BlendBuffer([TuiBuffer]$o,[int]$ox,[int]$oy){if($null-eq $o){return};for($y=0;$y-lt $o.Height;$y++){for($x=0;$x-lt $o.Width;$x++){$tx=$ox+$x;$ty=$oy+$y;if($tx-ge 0-and $tx-lt $this.Width-and $ty-ge 0-and $ty-lt $this.Height){$sc=$o.GetCell($x,$y);if($null-ne $sc -and $null-ne $sc.BackgroundColor){$this.SetCell($tx,$ty,$sc)}elseif($null-ne $sc-and $sc.Char-ne ' '){$tc=$this.GetCell($tx,$ty);if($null-ne $tc){$sc.BackgroundColor=$tc.BackgroundColor;$this.SetCell($tx,$ty,$sc)}}}}}}[void]Resize([int]$nw,[int]$nh){if($nw -le 0 -or $nh -le 0){throw "!"};$oc=$this.Cells;$ow=$this.Width;$oh=$this.Height;$this.Width=$nw;$this.Height=$nh;$this.Cells=New-Object 'TuiCell[,]' $nh,$nw;$this.Clear();$cw=[Math]::Min($ow,$nw);$ch=[Math]::Min($oh,$nh);for($y=0;$y-lt $ch;$y++){for($x=0;$x-lt $cw;$x++){$this.Cells[$y,$x]=$oc[$y,$x]}}}
    # ADDED: The missing GetSubBuffer method required by ScrollablePanel
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($x -lt 0 -or $y -lt 0 -or $width -le 0 -or $height -le 0) { return $null }
        if ($x + $width > $this.Width -or $y + $height > $this.Height) { return $null }
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy); if ($sourceCell) { $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell)) }
            }
        }
        return $subBuffer
    }
}
function Write-TuiText{param([TuiBuffer]$B,[int]$X,[int]$Y,[string]$T,[hashtable]$S=@{})if($null-eq $B -or [string]::IsNullOrEmpty($T)){return};$c=[TuiCell]::new();$c.ForegroundColor=$S.FG??"#C0C0C0";$c.BackgroundColor=$S.BG??$null;$c.Bold=[bool]($S.Bold??$false);$c.Italic=[bool]($S.Italic??$false);$c.Underline=[bool]($S.Underline??$false);$c.Strikethrough=[bool]($S.Strikethrough??$false);$cx=$X;foreach($char in $T.ToCharArray()){if($cx -ge $B.Width){break};if($cx-ge 0-and $Y-ge 0-and $Y-lt $B.Height){$cc=[TuiCell]::new($c);$cc.Char=$char;$B.SetCell($cx,$Y,$cc)};$cx++}}
function Get-TuiBorderChars{param([string]$S="Single");$styles=@{Single=@{TL='┌';T='─';TR='┐';L='│';R='│';BL='└';B='─';BR='┘'};Double=@{TL='╔';T='═';TR='╗';L='║';R='║';BL='╚';B='═';BR='╝'};Rounded=@{TL='╭';T='─';TR='╮';L='│';R='│';BL='╰';B='─';BR='╯'}};return $styles[$S]??$styles.Single}
function Write-TuiBox{param([TuiBuffer]$B,[int]$X,[int]$Y,[int]$W,[int]$H,[string]$Title="",[hashtable]$S=@{})if($null-eq $B -or $W-le 0-or $H-le 0){return};$bc=Get-TuiBorderChars -Style ($S.BorderStyle??'Single');$bs=@{FG=$S.BorderFG;BG=$S.BG};$ts=@{FG=$S.TitleFG;BG=$S.BG};foreach($k in ($S.TitleStyle??@{}).Keys){$ts[$k]=$S.TitleStyle[$k]};Write-TuiText -B $B -X $X -Y $Y -T "$($bc.TL)$($bc.T*($W-2))$($bc.TR)" -S $bs;if($H>1){Write-TuiText -B $B -X $X -Y($Y+$H-1) -T "$($bc.BL)$($bc.B*($W-2))$($bc.BR)" -S $bs};$fn=($S.BG-ne $null);$fs=@{BG=$S.BG};for($i=1;$i-lt($H-1);$i++){Write-TuiText -B $B -X $X -Y($Y+$i) -T $bc.L -S $bs;if($fn){Write-TuiText -B $B -X($X+1) -Y($Y+$i) -T(' '*($W-2)) -S $fs};Write-TuiText -B $B -X($X+$W-1) -Y($Y+$i) -T $bc.R -S $bs};if(-not[string]::IsNullOrEmpty($Title)){$tt=" $Title ";if($tt.Length-lt($W-2)){$tx=$X+[Math]::Floor(($W-$tt.Length)/2);Write-TuiText -B $B -X $tx -Y $Y -T $tt -S $ts}}}
# --- END OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---

# --- START OF ORIGINAL FILE: modules\event-system\event-system.psm1 ---
# modules/event-system/event-system.psm1
$global:EventHandlers = @{}
$global:HandlerCounter = 0

function Subscribe-Event {
    param([string]$EventName, [scriptblock]$Handler, [string]$Source)
    $id = "handler_$($global:HandlerCounter++)"
    if (-not $global:EventHandlers.ContainsKey($EventName)) {
        $global:EventHandlers[$EventName] = [System.Collections.Concurrent.ConcurrentDictionary[string, object]]::new()
    }
    $global:EventHandlers[$EventName][$id] = @{Handler=$Handler; Source=$Source}
    return $id
}

function Publish-Event {
    param([string]$EventName, $Data)
    if ($global:EventHandlers.ContainsKey($EventName)) {
        foreach ($handlerId in $global:EventHandlers[$EventName].Keys) {
            try { & $global:EventHandlers[$EventName][$handlerId].Handler $Data } catch { Write-Log -Level Error -Message "Event handler ($($handlerId)) failed for event '$EventName': $_" }
        }
    }
}

function Unsubscribe-Event {
    param([string]$HandlerId)
    foreach ($eventName in $global:EventHandlers.Keys) {
        if ($global:EventHandlers[$eventName].ContainsKey($HandlerId)) {
            $global:EventHandlers[$eventName].TryRemove($HandlerId, [ref]$null) | Out-Null
        }
    }
}
# --- END OF ORIGINAL FILE: modules\event-system\event-system.psm1 ---

# --- START OF ORIGINAL FILE: modules\theme-manager\theme-manager.psm1 ---
# modules/theme-manager/theme-manager.psm1 (minimal stub for Phase 1)
class ThemeEngine {
    [hashtable] GetStyle([string]$path) {
        # This is a stub that returns sensible defaults so the app doesn't crash.
        # A full implementation will load these from theme files.
        return @{
            FG = "#C0C0C0"
            BG = $null # Use transparent background by default
            BorderFG = "#808080"
            TitleFG = "#FFFFFF"
            BorderStyle = "Single"
        }
    }
    [string[]] GetThemeKeys() { return @("Default") } # Stub
    [void] SetTheme([string]$themeName) { Write-Log -Level Info -Message "Theme changed to $themeName" } # Stub
}
function Initialize-ThemeEngine { return [ThemeEngine]::new() }
# --- END OF ORIGINAL FILE: modules\theme-manager\theme-manager.psm1 ---

# --- START OF ORIGINAL FILE: components\ui-classes\ui-classes.psm1 ---
# ==============================================================================
# UI Classes v3.2 - Resource-Managed Component Hierarchy
# ==============================================================================

class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 0
    [int] $Height = 0
    [bool] $Visible = $true
    [bool] $Focused = $false
    hidden [TuiBuffer] $_private_buffer = $null
    hidden [UIElement] $_parent = $null
    hidden [System.Collections.Generic.List[UIElement]] $_children = [System.Collections.Generic.List[UIElement]]::new()
    hidden [hashtable] $_eventHandlers = @{}
    hidden [System.Collections.Generic.List[string]] $_subscriptions = [System.Collections.Generic.List[string]]::new()
    
    UIElement() { $this.Initialize() }
    
    # Lifecycle Methods
    [void] Initialize() {
        $this.OnInitialize()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }
    
    [void] Dispose() {
        $this.OnDispose()
        foreach ($sub in $this._subscriptions) { Unsubscribe-Event -HandlerId $sub }
        foreach ($child in $this._children) { $child.Dispose() }
        $this._children.Clear()
        $this._private_buffer = $null
    }
    
    # Hierarchy Management
    [void] AddChild([UIElement]$child) {
        if ($null -eq $child -or $child._parent -ne $null) { return }
        $child._parent = $this
        $this._children.Add($child)
        $this.OnChildAdded($child)
    }
    
    [void] RemoveChild([UIElement]$child) {
        if ($null -eq $child -or $child._parent -ne $this) { return }
        $child._parent = $null
        $this._children.Remove($child) | Out-Null
        $this.OnChildRemoved($child)
    }
    
    [UIElement[]] GetChildren() { return $this._children.ToArray() }
    [UIElement] GetParent() { return $this._parent }
    
    # Rendering Pipeline
    [void] Render() {
        if (-not $this.Visible -or $this.Width -le 0 -or $this.Height -le 0) { return }
        
        # Ensure buffer exists and is correct size
        if ($null -eq $this._private_buffer -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
            $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        }
        
        # Clear and render self
        $this._private_buffer.Clear()
        $this.OnRender()
        
        # Render children into this buffer
        foreach ($child in $this._children) {
            if ($child.Visible) {
                $child.Render()
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
    }
    
    # Event Handling
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # First give focused children a chance
        foreach ($child in $this._children) {
            if ($child.Focused -and $child.HandleInput($key)) { return $true }
        }
        # Then handle in self
        return $this.OnHandleInput($key)
    }
    
    # Event Subscription Helper
    [void] SubscribeToEvent([string]$eventName, [scriptblock]$handler) {
        $id = Subscribe-Event -EventName $eventName -Handler $handler -Source $this.Name
        $this._subscriptions.Add($id)
    }
    
    # Virtual Methods for Override
    [void] OnInitialize() {}
    [void] OnDispose() {}
    [void] OnRender() {}
    [bool] OnHandleInput([ConsoleKeyInfo]$key) { return $false }
    [void] OnChildAdded([UIElement]$child) {}
    [void] OnChildRemoved([UIElement]$child) {}
    [void] OnResize([int]$oldWidth, [int]$oldHeight) {}
    
    # Focus Management
    [void] SetFocus([bool]$focused) {
        if ($this.Focused -eq $focused) { return }
        $this.Focused = $focused
        $this.OnFocusChanged($focused)
    }
    
    [void] OnFocusChanged([bool]$focused) {}
    
    # Utility Methods
    [void] InvalidateRender() {
        if ($null -ne $this._parent) { $this._parent.InvalidateRender() }
    }
    
    [void] Resize([int]$newWidth, [int]$newHeight) {
        $oldWidth = $this.Width
        $oldHeight = $this.Height
        $this.Width = $newWidth
        $this.Height = $newHeight
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Resize($newWidth, $newHeight)
        }
        $this.OnResize($oldWidth, $oldHeight)
    }
}

# Base Component Class
class Component : UIElement {
    [hashtable] $Style = @{}
    
    Component() : base() {}
    Component([string]$name) : base() { $this.Name = $name }
    
    [void] OnInitialize() {
        $this.LoadDefaultStyle()
    }
    
    [void] LoadDefaultStyle() {
        # Override in derived classes to set default styles
    }
}

# Base Panel Class (Container)
class Panel : Component {
    [string] $Title = ""
    [bool] $ShowBorder = $true
    [string] $BorderStyle = "Single"
    hidden [int] $_contentOffsetX = 1
    hidden [int] $_contentOffsetY = 1
    
    Panel() : base() {}
    Panel([string]$name, [string]$title) : base($name) { $this.Title = $title }
    
    [void] OnRender() {
        if ($this.ShowBorder -and $null -ne $this._private_buffer) {
            $borderStyle = @{
                BorderStyle = $this.BorderStyle
                BorderFG = $this.Style.BorderFG ?? "#808080"
                BG = $this.Style.BG ?? $null
                TitleFG = $this.Style.TitleFG ?? "#FFFFFF"
            }
            Write-TuiBox -B $this._private_buffer -X 0 -Y 0 -W $this.Width -H $this.Height -Title $this.Title -S $borderStyle
        }
    }
    
    [int] GetContentX() { return $this.ShowBorder ? $this._contentOffsetX : 0 }
    [int] GetContentY() { return $this.ShowBorder ? $this._contentOffsetY : 0 }
    [int] GetContentWidth() { return $this.ShowBorder ? ($this.Width - 2) : $this.Width }
    [int] GetContentHeight() { return $this.ShowBorder ? ($this.Height - 2) : $this.Height }
}

# Base Screen Class
class Screen : UIElement {
    [string] $Route = ""
    hidden [NavigationService] $_navigationService = $null
    hidden [DataManager] $_dataManager = $null
    hidden [ThemeEngine] $_themeEngine = $null
    
    Screen() : base() {}
    Screen([string]$name, [string]$route) : base() {
        $this.Name = $name
        $this.Route = $route
    }
    
    [void] InjectServices([NavigationService]$nav, [DataManager]$data, [ThemeEngine]$theme) {
        $this._navigationService = $nav
        $this._dataManager = $data
        $this._themeEngine = $theme
        $this.OnServicesInjected()
    }
    
    [void] OnServicesInjected() {}
    
    [void] OnScreenActivated() {}
    [void] OnScreenDeactivated() {}
}
# --- END OF ORIGINAL FILE: components\ui-classes\ui-classes.psm1 ---

# --- START OF ORIGINAL FILE: layout\panels-class\panels-class.psm1 ---
# ==============================================================================
# Panels v3.2 - Advanced Layout Container Classes
# ==============================================================================

# Note: The basic Panel class is defined in ui-classes.psm1
# This file extends with specialized panel types

class ScrollablePanel : Panel {
    hidden [int] $_scrollX = 0
    hidden [int] $_scrollY = 0
    hidden [int] $_contentWidth = 0
    hidden [int] $_contentHeight = 0
    hidden [TuiBuffer] $_contentBuffer = $null
    [bool] $ShowScrollbars = $true
    
    ScrollablePanel() : base() {}
    ScrollablePanel([string]$name, [string]$title) : base($name, $title) {}
    
    [void] OnInitialize() {
        ([Panel]$this).OnInitialize()
        $this._contentBuffer = [TuiBuffer]::new(100, 100, "$($this.Name).Content")
    }
    
    [void] OnDispose() {
        $this._contentBuffer = $null
        ([Panel]$this).OnDispose()
    }
    
    [void] SetContentSize([int]$width, [int]$height) {
        $this._contentWidth = [Math]::Max($width, $this.GetContentWidth())
        $this._contentHeight = [Math]::Max($height, $this.GetContentHeight())
        if ($null -ne $this._contentBuffer) {
            $this._contentBuffer.Resize($this._contentWidth, $this._contentHeight)
        }
    }
    
    [void] OnRender() {
        # First render the border
        ([Panel]$this).OnRender()
        
        if ($null -eq $this._contentBuffer -or $null -eq $this._private_buffer) { return }
        
        # Clear content buffer and let children render into it
        $this._contentBuffer.Clear()
        
        # Temporarily adjust child positions for scrolling
        foreach ($child in $this._children) {
            $originalX = $child.X
            $originalY = $child.Y
            $child.X -= $this._scrollX
            $child.Y -= $this._scrollY
            
            if ($child.Visible) {
                $child.Render()
                if ($null -ne $child._private_buffer) {
                    $this._contentBuffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
            
            # Restore original positions
            $child.X = $originalX
            $child.Y = $originalY
        }
        
        # Extract visible portion and blend into panel
        $visibleWidth = $this.GetContentWidth()
        $visibleHeight = $this.GetContentHeight()
        $visibleBuffer = $this._contentBuffer.GetSubBuffer($this._scrollX, $this._scrollY, $visibleWidth, $visibleHeight)
        
        if ($null -ne $visibleBuffer) {
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.GetContentX(), $this.GetContentY())
        }
        
        # Render scrollbars if needed
        if ($this.ShowScrollbars) {
            $this.RenderScrollbars()
        }
    }
    
    hidden [void] RenderScrollbars() {
        if ($null -eq $this._private_buffer) { return }
        
        $contentX = $this.GetContentX()
        $contentY = $this.GetContentY()
        $visibleWidth = $this.GetContentWidth()
        $visibleHeight = $this.GetContentHeight()
        
        # Vertical scrollbar
        if ($this._contentHeight -gt $visibleHeight) {
            $scrollbarHeight = [Math]::Max(1, [int]($visibleHeight * $visibleHeight / $this._contentHeight))
            $scrollbarPos = [int]($this._scrollY * ($visibleHeight - $scrollbarHeight) / ($this._contentHeight - $visibleHeight))
            
            for ($y = 0; $y -lt $visibleHeight; $y++) {
                $char = if ($y -ge $scrollbarPos -and $y -lt ($scrollbarPos + $scrollbarHeight)) { '█' } else { '│' }
                Write-TuiText -B $this._private_buffer -X ($contentX + $visibleWidth) -Y ($contentY + $y) -T $char -S @{FG="#606060"}
            }
        }
        
        # Horizontal scrollbar
        if ($this._contentWidth -gt $visibleWidth) {
            $scrollbarWidth = [Math]::Max(1, [int]($visibleWidth * $visibleWidth / $this._contentWidth))
            $scrollbarPos = [int]($this._scrollX * ($visibleWidth - $scrollbarWidth) / ($this._contentWidth - $visibleWidth))
            
            for ($x = 0; $x -lt $visibleWidth; $x++) {
                $char = if ($x -ge $scrollbarPos -and $x -lt ($scrollbarPos + $scrollbarWidth)) { '█' } else { '─' }
                Write-TuiText -B $this._private_buffer -X ($contentX + $x) -Y ($contentY + $visibleHeight) -T $char -S @{FG="#606060"}
            }
        }
    }
    
    [bool] OnHandleInput([ConsoleKeyInfo]$key) {
        $handled = $false
        $visibleHeight = $this.GetContentHeight()
        $visibleWidth = $this.GetContentWidth()
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.ScrollUp(5)
                    $handled = $true
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.ScrollDown(5)
                    $handled = $true
                }
            }
            ([ConsoleKey]::PageUp) {
                $this.ScrollUp($visibleHeight - 1)
                $handled = $true
            }
            ([ConsoleKey]::PageDown) {
                $this.ScrollDown($visibleHeight - 1)
                $handled = $true
            }
            ([ConsoleKey]::Home) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this._scrollY = 0
                    $this.InvalidateRender()
                    $handled = $true
                }
            }
            ([ConsoleKey]::End) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this._scrollY = [Math]::Max(0, $this._contentHeight - $visibleHeight)
                    $this.InvalidateRender()
                    $handled = $true
                }
            }
        }
        
        if (-not $handled) {
            $handled = ([Panel]$this).OnHandleInput($key)
        }
        
        return $handled
    }
    
    [void] ScrollUp([int]$lines) {
        $this._scrollY = [Math]::Max(0, $this._scrollY - $lines)
        $this.InvalidateRender()
    }
    
    [void] ScrollDown([int]$lines) {
        $maxScroll = [Math]::Max(0, $this._contentHeight - $this.GetContentHeight())
        $this._scrollY = [Math]::Min($maxScroll, $this._scrollY + $lines)
        $this.InvalidateRender()
    }
    
    [void] ScrollLeft([int]$cols) {
        $this._scrollX = [Math]::Max(0, $this._scrollX - $cols)
        $this.InvalidateRender()
    }
    
    [void] ScrollRight([int]$cols) {
        $maxScroll = [Math]::Max(0, $this._contentWidth - $this.GetContentWidth())
        $this._scrollX = [Math]::Min($maxScroll, $this._scrollX + $cols)
        $this.InvalidateRender()
    }
    
    [void] ScrollToChild([UIElement]$child) {
        if ($null -eq $child -or -not $this._children.Contains($child)) { return }
        
        $visibleWidth = $this.GetContentWidth()
        $visibleHeight = $this.GetContentHeight()
        
        # Adjust scroll to make child visible
        if ($child.Y -lt $this._scrollY) {
            $this._scrollY = $child.Y
        } elseif (($child.Y + $child.Height) -gt ($this._scrollY + $visibleHeight)) {
            $this._scrollY = $child.Y + $child.Height - $visibleHeight
        }
        
        if ($child.X -lt $this._scrollX) {
            $this._scrollX = $child.X
        } elseif (($child.X + $child.Width) -gt ($this._scrollX + $visibleWidth)) {
            $this._scrollX = $child.X + $child.Width - $visibleWidth
        }
        
        $this.InvalidateRender()
    }
}

class GroupPanel : Panel {
    [bool] $Collapsed = $false
    hidden [int] $_expandedHeight = 0
    
    GroupPanel() : base() {}
    GroupPanel([string]$name, [string]$title) : base($name, $title) {}
    
    [void] Toggle() {
        if ($this.Collapsed) {
            $this.Expand()
        } else {
            $this.Collapse()
        }
    }
    
    [void] Collapse() {
        if ($this.Collapsed) { return }
        $this._expandedHeight = $this.Height
        $this.Height = 3  # Just title bar
        $this.Collapsed = $true
        $this.InvalidateRender()
    }
    
    [void] Expand() {
        if (-not $this.Collapsed) { return }
        $this.Height = $this._expandedHeight
        $this.Collapsed = $false
        $this.InvalidateRender()
    }
    
    [void] OnRender() {
        ([Panel]$this).OnRender()
        
        # Add collapse/expand indicator to title
        if (-not [string]::IsNullOrEmpty($this.Title) -and $this.ShowBorder) {
            $indicator = if ($this.Collapsed) { " [+]" } else { " [-]" }
            $titleWithIndicator = $this.Title + $indicator
            
            # Re-render title with indicator
            $titleStyle = @{
                FG = $this.Style.TitleFG ?? "#FFFFFF"
                BG = $this.Style.BG ?? $null
            }
            
            $maxTitleLength = $this.Width - 4
            if ($titleWithIndicator.Length -le $maxTitleLength) {
                $titleX = 2  # Start after border and space
                Write-TuiText -B $this._private_buffer -X $titleX -Y 0 -T $titleWithIndicator -S $titleStyle
            }
        }
        
        # Don't render children if collapsed
        if ($this.Collapsed) {
            foreach ($child in $this._children) {
                $child.Visible = $false
            }
        } else {
            foreach ($child in $this._children) {
                $child.Visible = $true
            }
        }
    }
    
    [bool] OnHandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Enter -or $key.Key -eq [ConsoleKey]::Spacebar) {
            $this.Toggle()
            return $true
        }
        
        # Don't process child input if collapsed
        if ($this.Collapsed) {
            return $false
        }
        
        return ([Panel]$this).OnHandleInput($key)
    }
}

# Layout Managers
class VerticalStackLayout {
    [int] $Spacing = 1
    [bool] $ExpandChildren = $false
    
    [void] ArrangeChildren([Panel]$panel) {
        $children = $panel.GetChildren()
        if ($children.Count -eq 0) { return }
        
        $contentX = $panel.GetContentX()
        $contentY = $panel.GetContentY()
        $contentWidth = $panel.GetContentWidth()
        $contentHeight = $panel.GetContentHeight()
        
        $currentY = 0
        $visibleChildren = $children | Where-Object { $_.Visible }
        
        if ($this.ExpandChildren -and $visibleChildren.Count -gt 0) {
            # Distribute height evenly among visible children
            $totalSpacing = [Math]::Max(0, ($visibleChildren.Count - 1) * $this.Spacing)
            $childHeight = [Math]::Floor(($contentHeight - $totalSpacing) / $visibleChildren.Count)
            
            foreach ($child in $visibleChildren) {
                $child.X = 0
                $child.Y = $currentY
                $child.Width = $contentWidth
                $child.Height = $childHeight
                $child.Resize($child.Width, $child.Height)
                $currentY += $childHeight + $this.Spacing
            }
        } else {
            # Use natural height of children
            foreach ($child in $visibleChildren) {
                $child.X = 0
                $child.Y = $currentY
                if ($child.Width -eq 0 -or $child.Width -gt $contentWidth) {
                    $child.Width = $contentWidth
                }
                $currentY += $child.Height + $this.Spacing
            }
        }
    }
}

class HorizontalStackLayout {
    [int] $Spacing = 1
    [bool] $ExpandChildren = $false
    
    [void] ArrangeChildren([Panel]$panel) {
        $children = $panel.GetChildren()
        if ($children.Count -eq 0) { return }
        
        $contentX = $panel.GetContentX()
        $contentY = $panel.GetContentY()
        $contentWidth = $panel.GetContentWidth()
        $contentHeight = $panel.GetContentHeight()
        
        $currentX = 0
        $visibleChildren = $children | Where-Object { $_.Visible }
        
        if ($this.ExpandChildren -and $visibleChildren.Count -gt 0) {
            # Distribute width evenly among visible children
            $totalSpacing = [Math]::Max(0, ($visibleChildren.Count - 1) * $this.Spacing)
            $childWidth = [Math]::Floor(($contentWidth - $totalSpacing) / $visibleChildren.Count)
            
            foreach ($child in $visibleChildren) {
                $child.X = $currentX
                $child.Y = 0
                $child.Width = $childWidth
                $child.Height = $contentHeight
                $child.Resize($child.Width, $child.Height)
                $currentX += $childWidth + $this.Spacing
            }
        } else {
            # Use natural width of children
            foreach ($child in $visibleChildren) {
                $child.X = $currentX
                $child.Y = 0
                if ($child.Height -eq 0 -or $child.Height -gt $contentHeight) {
                    $child.Height = $contentHeight
                }
                $currentX += $child.Width + $this.Spacing
            }
        }
    }
}

class GridLayout {
    [int] $Columns = 2
    [int] $RowSpacing = 1
    [int] $ColumnSpacing = 1
    [bool] $ExpandChildren = $true
    
    [void] ArrangeChildren([Panel]$panel) {
        $children = $panel.GetChildren()
        if ($children.Count -eq 0) { return }
        
        $contentWidth = $panel.GetContentWidth()
        $contentHeight = $panel.GetContentHeight()
        
        $visibleChildren = $children | Where-Object { $_.Visible }
        if ($visibleChildren.Count -eq 0) { return }
        
        $rows = [Math]::Ceiling($visibleChildren.Count / $this.Columns)
        $totalColumnSpacing = [Math]::Max(0, ($this.Columns - 1) * $this.ColumnSpacing)
        $totalRowSpacing = [Math]::Max(0, ($rows - 1) * $this.RowSpacing)
        
        $cellWidth = [Math]::Floor(($contentWidth - $totalColumnSpacing) / $this.Columns)
        $cellHeight = [Math]::Floor(($contentHeight - $totalRowSpacing) / $rows)
        
        $index = 0
        foreach ($child in $visibleChildren) {
            $col = $index % $this.Columns
            $row = [Math]::Floor($index / $this.Columns)
            
            $child.X = $col * ($cellWidth + $this.ColumnSpacing)
            $child.Y = $row * ($cellHeight + $this.RowSpacing)
            
            if ($this.ExpandChildren) {
                $child.Width = $cellWidth
                $child.Height = $cellHeight
                $child.Resize($child.Width, $child.Height)
            }
            
            $index++
        }
    }
}
# --- END OF ORIGINAL FILE: layout\panels-class\panels-class.psm1 ---

# --- START OF ORIGINAL FILE: components\navigation-class\navigation-class.psm1 ---
# Navigation Component Classes Module for PMC Terminal v5

# Phase 1 Migration Complete - Proper UIElement inheritance and Panel integration

# CORRECTED (v2): Removed unused and confusing `BuildContextMenu` method.



# NavigationItem - Represents a single menu item

class NavigationItem {

[string] $Key

[string] $Label

[scriptblock] $Action

[bool] $Enabled = $true

[bool] $Visible = $true

[string] $Description = ""

[ConsoleColor] $KeyColor = [ConsoleColor]::Yellow

[ConsoleColor] $LabelColor = [ConsoleColor]::White



NavigationItem([string]$key, [string]$label, [scriptblock]$action) {

if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }

if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }

if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }



$this.Key = $key.ToUpper()

$this.Label = $label

$this.Action = $action

}



[void] Execute() {

if (-not $this.Enabled) {

Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"

return

}



try {

Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"

& $this.Action

}

catch {

Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"

throw

}

}



[string] FormatDisplay([bool]$showDescription = $false) {

$display = "[$($this.Key)] "



if ($this.Enabled) {

$display += $this.Label

}

else {

$display += "$($this.Label) (Disabled)"

}



if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {

$display += " - $($this.Description)"

}



return $display

}

}



# AI: REFACTORED - NavigationMenu now properly inherits from UIElement

class NavigationMenu : UIElement {

[System.Collections.Generic.List[NavigationItem]] $Items

[hashtable] $Services

[string] $Orientation = "Vertical"

[string] $Separator = "  |  "

[bool] $ShowDescriptions = $false

[ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray

[int] $SelectedIndex = 0

[bool] $IsFocused = $false



NavigationMenu([string]$name) : base() {

$this.Name = $name

$this.Items = [System.Collections.Generic.List[NavigationItem]]::new()

$this.IsFocusable = $true

$this.SelectedIndex = 0

$this.Width = 30

$this.Height = 10

}



NavigationMenu([string]$name, [hashtable]$services) : base() {

if ($null -eq $services) { throw [ArgumentNullException]::new("services") }

$this.Name = $name

$this.Services = $services

$this.Items = [System.Collections.Generic.List[NavigationItem]]::new()

$this.IsFocusable = $true

$this.SelectedIndex = 0

$this.Width = 30

$this.Height = 10

}



[void] AddItem([NavigationItem]$item) {

if (-not $item) { throw [ArgumentNullException]::new("item") }

if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) {

throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists")

}

$this.Items.Add($item)

$this.RequestRedraw()

}



[void] RemoveItem([string]$key) {

$item = $this.GetItem($key)

if ($item) {

[void]$this.Items.Remove($item)

$this.RequestRedraw()

}

}



[NavigationItem] GetItem([string]$key) {

return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})

}



[void] ExecuteAction([string]$key) {

$item = $this.GetItem($key)

if ($item -and $item.Visible) {

Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock {

$item.Execute()

}

}

}



[void] AddSeparator() {

$separatorItem = [NavigationItem]::new("-", "---", {})

$separatorItem.Enabled = $false

$this.Items.Add($separatorItem)

$this.RequestRedraw()

}



# AI: REFACTORED - Now uses Panel buffer integration

[void] OnRender() {

if (-not $this.Visible -or $null -eq $this._private_buffer) { return }



try {

# Clear our buffer

$this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))



# Get visible items

$visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })

if ($visibleItems.Count -eq 0) { return }



if ($this.Orientation -eq "Horizontal") {

$this.RenderHorizontal($visibleItems)

}

else {

$this.RenderVertical($visibleItems)

}



} catch {

Write-Log -Level Error -Message "NavigationMenu render error for '$($this.Name)': $_"

}

}



hidden [void] RenderHorizontal([object[]]$items) {

if ($null -eq $items -or $items.Count -eq 0) { return }



$menuText = ""

$isFirst = $true

foreach ($item in $items) {

if ($null -eq $item) { continue }



if (-not $isFirst) {

$menuText += $this.Separator

}

$menuText += "[$($item.Key)] $($item.Label)"

$isFirst = $false

}



# Write to our private buffer

$this._private_buffer.WriteString(0, 0, $menuText, [ConsoleColor]::White, [ConsoleColor]::Black)

}



hidden [void] RenderVertical([object[]]$items) {

if ($null -eq $items -or $items.Count -eq 0) { return }



# Ensure SelectedIndex is within bounds

if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {

$this.SelectedIndex = 0

}



for ($i = 0; $i -lt $items.Count; $i++) {

$item = $items[$i]

if ($null -eq $item) { continue }



$prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }

$menuText = "$prefix[$($item.Key)] $($item.Label)"



# Pad text to clear the full line width

if ($menuText.Length -lt $this.Width) {

$menuText = $menuText.PadRight($this.Width)

}



$fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") {

[ConsoleColor]::Black

} else {

[ConsoleColor]::White

}

$bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") {

[ConsoleColor]::White

} else {

[ConsoleColor]::Black

}



# Write to our private buffer

$this._private_buffer.WriteString(0, $i, $menuText, $fg, $bg)

}

}



# AI: REFACTORED - Updated input handling for new architecture

[bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {

try {

$visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })

if ($visibleItems.Count -eq 0) { return $false }



switch ($keyInfo.Key) {

([ConsoleKey]::UpArrow) {

if ($this.SelectedIndex -gt 0) {

$this.SelectedIndex--

$this.RequestRedraw()

}

return $true

}

([ConsoleKey]::DownArrow) {

if ($this.SelectedIndex -lt ($visibleItems.Count - 1)) {

$this.SelectedIndex++

$this.RequestRedraw()

}

return $true

}

([ConsoleKey]::Enter) {

if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $visibleItems.Count) {

$selectedItem = $visibleItems[$this.SelectedIndex]

if ($selectedItem.Enabled -and $selectedItem.Key -ne "-") {

$selectedItem.Execute()

}

}

return $true

}

default {

# Check for direct key matches

$keyChar = $keyInfo.KeyChar.ToString().ToUpper()

$matchingItem = $this.Items.Find({param($x) $x.Key -eq $keyChar})

if ($matchingItem -and $matchingItem.Enabled -and $matchingItem.Visible) {

$matchingItem.Execute()

return $true

}

}

}



} catch {

Write-Log -Level Error -Message "NavigationMenu input error for '$($this.Name)': $_"

}



return $false

}



# AI: NEW - Focus management

[void] OnFocus() {

$this.IsFocused = $true

$this.RequestRedraw()

}



[void] OnBlur() {

$this.IsFocused = $false

$this.RequestRedraw()

}

}
# --- END OF ORIGINAL FILE: components\navigation-class\navigation-class.psm1 ---

# --- START OF ORIGINAL FILE: components\tui-components\tui-components.psm1 ---
# ==============================================================================
# TUI Components v3.2 - Core UI Widget Library
# ==============================================================================

# Label Component
class LabelComponent : Component {
    [string] $Text = ""
    [string] $TextAlign = "Left"  # Left, Center, Right
    
    LabelComponent() : base() { $this.Height = 1 }
    LabelComponent([string]$text) : base() { 
        $this.Text = $text
        $this.Height = 1
        $this.Width = $text.Length
    }
    
    [void] OnRender() {
        if ([string]::IsNullOrEmpty($this.Text) -or $null -eq $this._private_buffer) { return }
        
        $style = @{
            FG = $this.Style.FG ?? "#C0C0C0"
            BG = $this.Style.BG ?? $null
            Bold = $this.Style.Bold ?? $false
            Italic = $this.Style.Italic ?? $false
            Underline = $this.Style.Underline ?? $false
        }
        
        # Calculate text position based on alignment
        $x = 0
        switch ($this.TextAlign) {
            "Center" { $x = [Math]::Max(0, [Math]::Floor(($this.Width - $this.Text.Length) / 2)) }
            "Right" { $x = [Math]::Max(0, $this.Width - $this.Text.Length) }
        }
        
        # Truncate text if needed
        $displayText = if ($this.Text.Length -gt $this.Width) {
            $this.Text.Substring(0, [Math]::Max(0, $this.Width - 3)) + "..."
        } else {
            $this.Text
        }
        
        Write-TuiText -B $this._private_buffer -X $x -Y 0 -T $displayText -S $style
    }
}

# Button Component
class ButtonComponent : Component {
    [string] $Text = "Button"
    [scriptblock] $OnClick = {}
    [bool] $IsDefault = $false
    
    ButtonComponent() : base() { $this.Height = 3 }
    ButtonComponent([string]$text, [scriptblock]$onClick) : base() {
        $this.Text = $text
        $this.OnClick = $onClick
        $this.Width = [Math]::Max(10, $text.Length + 6)
        $this.Height = 3
    }
    
    [void] LoadDefaultStyle() {
        $this.Style = @{
            FG = "#FFFFFF"
            BG = "#0066CC"
            BorderStyle = "Rounded"
            FocusedBG = "#0088FF"
            FocusedFG = "#FFFFFF"
            DisabledFG = "#808080"
            DisabledBG = "#404040"
        }
    }
    
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        
        # Determine colors based on state
        $fg = $this.Style.FG
        $bg = $this.Style.BG
        $borderStyle = $this.Style.BorderStyle ?? "Rounded"
        
        if ($this.Focused) {
            $fg = $this.Style.FocusedFG ?? $fg
            $bg = $this.Style.FocusedBG ?? "#0088FF"
        }
        
        # Draw button background
        $boxStyle = @{
            BorderStyle = $borderStyle
            BorderFG = $fg
            BG = $bg
        }
        Write-TuiBox -B $this._private_buffer -X 0 -Y 0 -W $this.Width -H $this.Height -S $boxStyle
        
        # Draw button text centered
        $textX = [Math]::Floor(($this.Width - $this.Text.Length) / 2)
        $textY = 1
        $textStyle = @{ FG = $fg; BG = $bg; Bold = $true }
        Write-TuiText -B $this._private_buffer -X $textX -Y $textY -T $this.Text -S $textStyle
        
        # Draw focus indicator
        if ($this.Focused) {
            Write-TuiText -B $this._private_buffer -X 2 -Y 1 -T ">" -S @{FG=$fg;BG=$bg}
            Write-TuiText -B $this._private_buffer -X ($this.Width - 3) -Y 1 -T "<" -S @{FG=$fg;BG=$bg}
        }
    }
    
    [bool] OnHandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Enter -or $key.Key -eq [ConsoleKey]::Spacebar) {
            if ($null -ne $this.OnClick) {
                & $this.OnClick
            }
            return $true
        }
        return $false
    }
}

# TextBox Component
class TextBoxComponent : Component {
    [string] $Text = ""
    [string] $Placeholder = ""
    [int] $MaxLength = 100
    [bool] $IsPassword = $false
    hidden [int] $_cursorPosition = 0
    hidden [int] $_viewOffset = 0
    
    TextBoxComponent() : base() { $this.Height = 3 }
    TextBoxComponent([string]$placeholder) : base() {
        $this.Placeholder = $placeholder
        $this.Height = 3
        $this.Width = 30
    }
    
    [void] LoadDefaultStyle() {
        $this.Style = @{
            FG = "#FFFFFF"
            BG = "#1A1A1A"
            BorderFG = "#606060"
            FocusedBorderFG = "#0088FF"
            PlaceholderFG = "#808080"
            CursorFG = "#FFFFFF"
            CursorBG = "#0088FF"
        }
    }
    
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        
        # Border color changes when focused
        $borderFG = if ($this.Focused) { $this.Style.FocusedBorderFG } else { $this.Style.BorderFG }
        
        # Draw textbox border
        $boxStyle = @{
            BorderStyle = "Single"
            BorderFG = $borderFG
            BG = $this.Style.BG
        }
        Write-TuiBox -B $this._private_buffer -X 0 -Y 0 -W $this.Width -H $this.Height -S $boxStyle
        
        # Prepare display text
        $displayText = if ($this.IsPassword -and $this.Text.Length -gt 0) {
            "*" * $this.Text.Length
        } else {
            $this.Text
        }
        
        # Calculate visible portion
        $visibleWidth = $this.Width - 4  # Account for borders and padding
        $this.AdjustViewOffset($visibleWidth)
        
        # Draw text or placeholder
        if ($displayText.Length -gt 0) {
            $visibleText = if ($displayText.Length -gt $this._viewOffset) {
                $endIndex = [Math]::Min($displayText.Length, $this._viewOffset + $visibleWidth)
                $displayText.Substring($this._viewOffset, $endIndex - $this._viewOffset)
            } else { "" }
            
            Write-TuiText -B $this._private_buffer -X 2 -Y 1 -T $visibleText -S @{FG=$this.Style.FG;BG=$this.Style.BG}
        } elseif (-not [string]::IsNullOrEmpty($this.Placeholder) -and -not $this.Focused) {
            $placeholderText = if ($this.Placeholder.Length -gt $visibleWidth) {
                $this.Placeholder.Substring(0, $visibleWidth - 3) + "..."
            } else { $this.Placeholder }
            
            Write-TuiText -B $this._private_buffer -X 2 -Y 1 -T $placeholderText -S @{FG=$this.Style.PlaceholderFG;BG=$this.Style.BG}
        }
        
        # Draw cursor when focused
        if ($this.Focused) {
            $cursorScreenPos = $this._cursorPosition - $this._viewOffset + 2
            if ($cursorScreenPos -ge 2 -and $cursorScreenPos -lt ($this.Width - 2)) {
                # Draw cursor character
                $cursorChar = if ($this._cursorPosition -lt $displayText.Length) {
                    $displayText[$this._cursorPosition]
                } else { ' ' }
                
                Write-TuiText -B $this._private_buffer -X $cursorScreenPos -Y 1 -T $cursorChar -S @{FG=$this.Style.CursorFG;BG=$this.Style.CursorBG}
            }
        }
    }
    
    hidden [void] AdjustViewOffset([int]$visibleWidth) {
        # Ensure cursor is visible
        if ($this._cursorPosition -lt $this._viewOffset) {
            $this._viewOffset = $this._cursorPosition
        } elseif ($this._cursorPosition -ge ($this._viewOffset + $visibleWidth)) {
            $this._viewOffset = $this._cursorPosition - $visibleWidth + 1
        }
        
        # Ensure view offset is valid
        $this._viewOffset = [Math]::Max(0, $this._viewOffset)
    }
    
    [bool] OnHandleInput([ConsoleKeyInfo]$key) {
        $handled = $true
        
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) {
                if ($this._cursorPosition -gt 0) {
                    $this._cursorPosition--
                    $this.InvalidateRender()
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this._cursorPosition -lt $this.Text.Length) {
                    $this._cursorPosition++
                    $this.InvalidateRender()
                }
            }
            ([ConsoleKey]::Home) {
                $this._cursorPosition = 0
                $this.InvalidateRender()
            }
            ([ConsoleKey]::End) {
                $this._cursorPosition = $this.Text.Length
                $this.InvalidateRender()
            }
            ([ConsoleKey]::Backspace) {
                if ($this._cursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this._cursorPosition - 1, 1)
                    $this._cursorPosition--
                    $this.InvalidateRender()
                    Publish-Event -EventName "TextBox.Changed" -Data @{Component=$this;Text=$this.Text}
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this._cursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this._cursorPosition, 1)
                    $this.InvalidateRender()
                    Publish-Event -EventName "TextBox.Changed" -Data @{Component=$this;Text=$this.Text}
                }
            }
            default {
                if ($key.KeyChar -and $key.KeyChar -ne 0 -and $this.Text.Length -lt $this.MaxLength) {
                    $this.Text = $this.Text.Insert($this._cursorPosition, $key.KeyChar)
                    $this._cursorPosition++
                    $this.InvalidateRender()
                    Publish-Event -EventName "TextBox.Changed" -Data @{Component=$this;Text=$this.Text}
                } else {
                    $handled = $false
                }
            }
        }
        
        return $handled
    }
    
    [void] SetText([string]$text) {
        $this.Text = if ($text.Length -gt $this.MaxLength) {
            $text.Substring(0, $this.MaxLength)
        } else { $text }
        $this._cursorPosition = $this.Text.Length
        $this.InvalidateRender()
    }
}

# CheckBox Component
class CheckBoxComponent : Component {
    [bool] $Checked = $false
    [string] $Label = ""
    [scriptblock] $OnChange = {}
    
    CheckBoxComponent() : base() { $this.Height = 1 }
    CheckBoxComponent([string]$label) : base() {
        $this.Label = $label
        $this.Height = 1
        $this.Width = $label.Length + 4
    }
    
    [void] LoadDefaultStyle() {
        $this.Style = @{
            FG = "#C0C0C0"
            CheckedFG = "#00FF00"
            FocusedFG = "#FFFFFF"
            BoxFG = "#808080"
            FocusedBoxFG = "#0088FF"
        }
    }
    
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        
        $boxFG = if ($this.Focused) { $this.Style.FocusedBoxFG } else { $this.Style.BoxFG }
        $labelFG = if ($this.Focused) { $this.Style.FocusedFG } else { $this.Style.FG }
        
        # Draw checkbox
        $checkChar = if ($this.Checked) { "✓" } else { " " }
        $checkFG = if ($this.Checked) { $this.Style.CheckedFG } else { $boxFG }
        
        Write-TuiText -B $this._private_buffer -X 0 -Y 0 -T "[" -S @{FG=$boxFG}
        Write-TuiText -B $this._private_buffer -X 1 -Y 0 -T $checkChar -S @{FG=$checkFG;Bold=$true}
        Write-TuiText -B $this._private_buffer -X 2 -Y 0 -T "]" -S @{FG=$boxFG}
        
        # Draw label
        if (-not [string]::IsNullOrEmpty($this.Label)) {
            Write-TuiText -B $this._private_buffer -X 4 -Y 0 -T $this.Label -S @{FG=$labelFG}
        }
    }
    
    [bool] OnHandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Spacebar -or $key.Key -eq [ConsoleKey]::Enter) {
            $this.Toggle()
            return $true
        }
        return $false
    }
    
    [void] Toggle() {
        $this.Checked = -not $this.Checked
        $this.InvalidateRender()
        if ($null -ne $this.OnChange) {
            & $this.OnChange $this.Checked
        }
        Publish-Event -EventName "CheckBox.Changed" -Data @{Component=$this;Checked=$this.Checked}
    }
}

# RadioButton Component
class RadioButtonComponent : Component {
    [bool] $Selected = $false
    [string] $Label = ""
    [string] $GroupName = ""
    [scriptblock] $OnSelect = {}
    
    RadioButtonComponent() : base() { $this.Height = 1 }
    RadioButtonComponent([string]$label, [string]$groupName) : base() {
        $this.Label = $label
        $this.GroupName = $groupName
        $this.Height = 1
        $this.Width = $label.Length + 4
    }
    
    [void] LoadDefaultStyle() {
        $this.Style = @{
            FG = "#C0C0C0"
            SelectedFG = "#00FF00"
            FocusedFG = "#FFFFFF"
            BoxFG = "#808080"
            FocusedBoxFG = "#0088FF"
        }
    }
    
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        
        $boxFG = if ($this.Focused) { $this.Style.FocusedBoxFG } else { $this.Style.BoxFG }
        $labelFG = if ($this.Focused) { $this.Style.FocusedFG } else { $this.Style.FG }
        
        # Draw radio button
        $selectChar = if ($this.Selected) { "●" } else { " " }
        $selectFG = if ($this.Selected) { $this.Style.SelectedFG } else { $boxFG }
        
        Write-TuiText -B $this._private_buffer -X 0 -Y 0 -T "(" -S @{FG=$boxFG}
        Write-TuiText -B $this._private_buffer -X 1 -Y 0 -T $selectChar -S @{FG=$selectFG;Bold=$true}
        Write-TuiText -B $this._private_buffer -X 2 -Y 0 -T ")" -S @{FG=$boxFG}
        
        # Draw label
        if (-not [string]::IsNullOrEmpty($this.Label)) {
            Write-TuiText -B $this._private_buffer -X 4 -Y 0 -T $this.Label -S @{FG=$labelFG}
        }
    }
    
    [bool] OnHandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Spacebar -or $key.Key -eq [ConsoleKey]::Enter) {
            $this.Select()
            return $true
        }
        return $false
    }
    
    [void] Select() {
        if (-not $this.Selected) {
            # Deselect all other radio buttons in the same group
            if (-not [string]::IsNullOrEmpty($this.GroupName)) {
                Publish-Event -EventName "RadioButton.GroupSelect" -Data @{
                    GroupName = $this.GroupName
                    SelectedComponent = $this
                }
            }
            
            $this.Selected = $true
            $this.InvalidateRender()
            
            if ($null -ne $this.OnSelect) {
                & $this.OnSelect
            }
        }
    }
    
    [void] Deselect() {
        $this.Selected = $false
        $this.InvalidateRender()
    }
}

# ProgressBar Component
class ProgressBarComponent : Component {
    [int] $Value = 0
    [int] $Maximum = 100
    [string] $DisplayFormat = "Percentage"  # Percentage, Fraction, Both, None
    [bool] $ShowBorder = $true
    
    ProgressBarComponent() : base() { $this.Height = 3 }
    ProgressBarComponent([int]$max) : base() {
        $this.Maximum = $max
        $this.Height = 3
        $this.Width = 30
    }
    
    [void] LoadDefaultStyle() {
        $this.Style = @{
            FG = "#00FF00"
            BG = "#1A1A1A"
            BorderFG = "#606060"
            BarChar = "█"
            EmptyChar = "░"
        }
    }
    
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $boxStyle = @{
                BorderStyle = "Single"
                BorderFG = $this.Style.BorderFG
                BG = $this.Style.BG
            }
            Write-TuiBox -B $this._private_buffer -X 0 -Y 0 -W $this.Width -H $this.Height -S $boxStyle
        }
        
        # Calculate progress
        $percentage = if ($this.Maximum -gt 0) {
            [Math]::Min(100, [Math]::Max(0, [int](($this.Value / $this.Maximum) * 100)))
        } else { 0 }
        
        $barWidth = if ($this.ShowBorder) { $this.Width - 2 } else { $this.Width }
        $barY = if ($this.ShowBorder) { 1 } else { 0 }
        $barX = if ($this.ShowBorder) { 1 } else { 0 }
        
        $filledWidth = [int](($percentage / 100) * $barWidth)
        
        # Draw progress bar
        $barText = ($this.Style.BarChar * $filledWidth).PadRight($barWidth, $this.Style.EmptyChar)
        
        for ($i = 0; $i -lt $barText.Length; $i++) {
            $char = $barText[$i]
            $fg = if ($i -lt $filledWidth) { $this.Style.FG } else { $this.Style.BorderFG }
            Write-TuiText -B $this._private_buffer -X ($barX + $i) -Y $barY -T $char -S @{FG=$fg;BG=$this.Style.BG}
        }
        
        # Draw text overlay
        $text = switch ($this.DisplayFormat) {
            "Percentage" { "$percentage%" }
            "Fraction" { "$($this.Value)/$($this.Maximum)" }
            "Both" { "$($this.Value)/$($this.Maximum) ($percentage%)" }
            default { "" }
        }
        
        if (-not [string]::IsNullOrEmpty($text)) {
            $textX = $barX + [Math]::Floor(($barWidth - $text.Length) / 2)
            Write-TuiText -B $this._private_buffer -X $textX -Y $barY -T $text -S @{FG="#FFFFFF";BG=$null;Bold=$true}
        }
    }
    
    [void] SetValue([int]$value) {
        $this.Value = [Math]::Max(0, [Math]::Min($this.Maximum, $value))
        $this.InvalidateRender()
    }
}
# --- END OF ORIGINAL FILE: components\tui-components\tui-components.psm1 ---

# --- START OF ORIGINAL FILE: components\advanced-data-components\advanced-data-components.psm1 ---
# Advanced Data Components Module for PMC Terminal v5

# Phase 1 Migration Complete - Enhanced data display with proper UIElement inheritance

















#region Table Classes



class TableColumn {

[string]$Key

[string]$Header

[int]$Width

[string]$Alignment = "Left"



TableColumn([string]$key, [string]$header, [int]$width) {

$this.Key = $key

$this.Header = $header

$this.Width = $width

}

}



# AI: REFACTORED - Table now properly inherits from UIElement

class Table : UIElement {

[System.Collections.Generic.List[TableColumn]]$Columns

[object[]]$Data = @()

[int]$SelectedIndex = 0

[bool]$ShowBorder = $true

[bool]$ShowHeader = $true

[bool]$IsFocused = $false



Table([string]$name) : base() {

$this.Name = $name

$this.Columns = [System.Collections.Generic.List[TableColumn]]::new()

$this.Data = @()

$this.SelectedIndex = 0

$this.IsFocusable = $true

$this.Width = 60

$this.Height = 15

}



[void] SetColumns([TableColumn[]]$columns) {

$this.Columns.Clear()

foreach ($col in $columns) {

$this.Columns.Add($col)

}

$this.RequestRedraw()

}



[void] SetData([object[]]$data) {

$this.Data = if ($null -eq $data) { @() } else { @($data) }

$dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }

if ($this.SelectedIndex -ge $dataCount) {

$this.SelectedIndex = [Math]::Max(0, $dataCount - 1)

}

$this.RequestRedraw()

}



[void] SelectNext() {

$dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }

if ($this.SelectedIndex -lt ($dataCount - 1)) {

$this.SelectedIndex++

$this.RequestRedraw()

}

}



[void] SelectPrevious() {

if ($this.SelectedIndex -gt 0) {

$this.SelectedIndex--

$this.RequestRedraw()

}

}



[object] GetSelectedItem() {

if ($null -eq $this.Data) { return $null }



$dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }



if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {

return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }

}

return $null

}



# AI: REFACTORED - Now uses UIElement buffer system

[void] OnRender() {

if (-not $this.Visible -or $null -eq $this._private_buffer) { return }



try {

# Clear buffer

$this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))



# Draw border if enabled

if ($this.ShowBorder) {

Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `

-BorderStyle "Single" -BorderColor ([ConsoleColor]::Gray) -BackgroundColor ([ConsoleColor]::Black)

}



$currentY = if ($this.ShowBorder) { 1 } else { 0 }

$contentWidth = if ($this.ShowBorder) { $this.Width - 2 } else { $this.Width }

$renderX = if ($this.ShowBorder) { 1 } else { 0 }



# Header

if ($this.ShowHeader -and $this.Columns.Count -gt 0) {

$headerLine = ""

foreach ($col in $this.Columns) {

$headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))

$headerLine += $headerText + " "

}



if ($headerLine.TrimEnd().Length -gt $contentWidth) {

$headerLine = $headerLine.Substring(0, $contentWidth)

}



Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $headerLine.TrimEnd() `

-ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)

$currentY++



Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY `

-Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $contentWidth)) `

-ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)

$currentY++

}



# Data rows

$dataToRender = @()

if ($null -ne $this.Data) {

$dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }

}



for ($i = 0; $i -lt $dataToRender.Count; $i++) {

$row = $dataToRender[$i]

if ($null -eq $row) { continue }



$rowLine = ""

$isSelected = ($i -eq $this.SelectedIndex)



foreach ($col in $this.Columns) {

$cellValue = ""

if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {

$cellValue = $row[$col.Key]?.ToString() ?? ""

} elseif ($row.PSObject.Properties[$col.Key]) {

$propValue = $row.($col.Key)

if ($col.Key -eq 'DueDate' -and $propValue -is [DateTime]) {

$cellValue = $propValue.ToString('yyyy-MM-dd')

} else {

$cellValue = if ($null -ne $propValue) { $propValue.ToString() } else { "" }

}

}



$cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))

$rowLine += $cellText + " "

}



$finalLine = $rowLine.TrimEnd()

if ($isSelected) {

$finalLine = "> $finalLine"

} else {

$finalLine = "  $finalLine"

}



$fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }

$bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }



if ($finalLine.Length -gt $contentWidth) {

$finalLine = $finalLine.Substring(0, $contentWidth)

}



Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $finalLine `

-ForegroundColor $fg -BackgroundColor $bg

$currentY++



# Don't exceed available space

if ($currentY -ge ($this.Height - 1)) { break }

}



if ($dataToRender.Count -eq 0) {

Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text "  No data to display" `

-ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)

}



} catch {

Write-Log -Level Error -Message "Table render error for '$($this.Name)': $_"

}

}



# AI: REFACTORED - Updated input handling

[bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {

try {

switch ($keyInfo.Key) {

([ConsoleKey]::UpArrow) {

$this.SelectPrevious()

return $true

}

([ConsoleKey]::DownArrow) {

$this.SelectNext()

return $true

}

([ConsoleKey]::Enter) {

$selectedItem = $this.GetSelectedItem()

if ($null -ne $selectedItem) {

# Trigger selection event or action

Write-Log -Level Debug -Message "Table item selected: $($selectedItem)"

}

return $true

}

}

} catch {

Write-Log -Level Error -Message "Table input error for '$($this.Name)': $_"

}



return $false

}



[void] OnFocus() {

$this.IsFocused = $true

$this.RequestRedraw()

}



[void] OnBlur() {

$this.IsFocused = $false

$this.RequestRedraw()

}

}



# AI: DELETED - Obsolete DataTableComponent class was here and has been removed.



#endregion



#region Factory Functions



function New-TuiTable {

# AI: REFACTORED - Creates a proper Table instance

param([hashtable]$Props = @{})



$name = $Props.Name ?? "Table_$([Guid]::NewGuid().ToString('N').Substring(0,8))"

$table = [Table]::new($name)



if ($Props.Columns) {

$table.SetColumns($Props.Columns)

}

if ($Props.Data) {

$table.SetData($Props.Data)

}



$table.X = $Props.X ?? $table.X

$table.Y = $Props.Y ?? $table.Y

$table.Width = $Props.Width ?? $table.Width

$table.Height = $Props.Height ?? $table.Height

$table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder

$table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader

$table.Visible = $Props.Visible ?? $table.Visible



return $table

}



#endregion
# --- END OF ORIGINAL FILE: components\advanced-data-components\advanced-data-components.psm1 ---

# --- START OF ORIGINAL FILE: components\advanced-input-components\advanced-input-components.psm1 ---
# Advanced Input Components - Phase 2 Migration Complete

# All components now inherit from UIElement and use buffer-based rendering











#region Advanced Input Classes



# AI: REFACTORED - MultilineTextBox converted from functional to class-based

class MultilineTextBoxComponent : UIElement {

[string[]]$Lines = @("")

[string]$Placeholder = "Enter text..."

[int]$MaxLines = 10

[int]$MaxLineLength = 100

[int]$CurrentLine = 0

[int]$CursorPosition = 0

[int]$ScrollOffsetY = 0

[bool]$WordWrap = $true

[scriptblock]$OnChange



MultilineTextBoxComponent([string]$name) : base() {

$this.Name = $name

$this.IsFocusable = $true

$this.Width = 40

$this.Height = 10

}



# AI: REFACTORED - Now uses UIElement buffer system

[void] OnRender() {

if (-not $this.Visible -or $null -eq $this._private_buffer) { return }



try {

# Clear buffer

$this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))



$borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray



# AI: Draw border

Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `

-BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)



# AI: Calculate visible area

$textAreaHeight = $this.Height - 2

$textAreaWidth = $this.Width - 2

$startLine = $this.ScrollOffsetY

$endLine = [Math]::Min($this.Lines.Count - 1, $startLine + $textAreaHeight - 1)



# AI: Render text lines

for ($i = $startLine; $i -le $endLine; $i++) {

if ($i -ge $this.Lines.Count) { break }



$line = $this.Lines[$i] ?? ""

$displayLine = $line

if ($displayLine.Length -gt $textAreaWidth) {

$displayLine = $displayLine.Substring(0, $textAreaWidth)

}



$lineY = 1 + ($i - $startLine)

Write-TuiText -Buffer $this._private_buffer -X 1 -Y $lineY -Text $displayLine `

-ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)

}



# AI: Show placeholder if empty and not focused

if ($this.Lines.Count -eq 1 -and [string]::IsNullOrEmpty($this.Lines[0]) -and -not $this.IsFocused) {

Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $this.Placeholder `

-ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)

}



# AI: Draw cursor if focused

if ($this.IsFocused) {

$cursorLine = $this.CurrentLine - $this.ScrollOffsetY

if ($cursorLine -ge 0 -and $cursorLine -lt $textAreaHeight) {

$cursorX = 1 + $this.CursorPosition

$cursorY = 1 + $cursorLine

if ($cursorX -lt $this.Width - 1) {

Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y $cursorY -Text "_" `

-ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)

}

}

}



} catch {

Write-Log -Level Error -Message "MultilineTextBox render error for '$($this.Name)': $_"

}

}



[bool] HandleInput([System.ConsoleKeyInfo]$key) {

try {

$currentLineText = $this.Lines[$this.CurrentLine] ?? ""

$originalLines = $this.Lines.Clone()

$handled = $true



switch ($key.Key) {

([ConsoleKey]::UpArrow) {

if ($this.CurrentLine -gt 0) {

$this.CurrentLine--

$this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)

$this._UpdateScrolling()

}

}

([ConsoleKey]::DownArrow) {

if ($this.CurrentLine -lt ($this.Lines.Count - 1)) {

$this.CurrentLine++

$this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)

$this._UpdateScrolling()

}

}

([ConsoleKey]::LeftArrow) {

if ($this.CursorPosition -gt 0) {

$this.CursorPosition--

} elseif ($this.CurrentLine -gt 0) {

$this.CurrentLine--

$this.CursorPosition = $this.Lines[$this.CurrentLine].Length

$this._UpdateScrolling()

}

}

([ConsoleKey]::RightArrow) {

if ($this.CursorPosition -lt $currentLineText.Length) {

$this.CursorPosition++

} elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {

$this.CurrentLine++

$this.CursorPosition = 0

$this._UpdateScrolling()

}

}

([ConsoleKey]::Home) { $this.CursorPosition = 0 }

([ConsoleKey]::End) { $this.CursorPosition = $currentLineText.Length }

([ConsoleKey]::Enter) {

if ($this.Lines.Count -lt $this.MaxLines) {

$beforeCursor = $currentLineText.Substring(0, $this.CursorPosition)

$afterCursor = $currentLineText.Substring($this.CursorPosition)



$this.Lines[$this.CurrentLine] = $beforeCursor

$this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($afterCursor) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])



$this.CurrentLine++

$this.CursorPosition = 0

$this._UpdateScrolling()

}

}

([ConsoleKey]::Backspace) {

if ($this.CursorPosition -gt 0) {

$this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition - 1, 1)

$this.CursorPosition--

} elseif ($this.CurrentLine -gt 0 -and $this.Lines.Count -gt 1) {

$previousLine = $this.Lines[$this.CurrentLine - 1]

$this.CursorPosition = $previousLine.Length

$this.Lines[$this.CurrentLine - 1] = $previousLine + $currentLineText

$this.Lines = @($this.Lines[0..($this.CurrentLine - 1)]) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])

$this.CurrentLine--

$this._UpdateScrolling()

}

}

([ConsoleKey]::Delete) {

if ($this.CursorPosition -lt $currentLineText.Length) {

$this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition, 1)

} elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {

$nextLine = $this.Lines[$this.CurrentLine + 1]

$this.Lines[$this.CurrentLine] = $currentLineText + $nextLine

$this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($this.Lines[($this.CurrentLine + 2)..($this.Lines.Count - 1)])

}

}

default {

if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentLineText.Length -lt $this.MaxLineLength) {

$this.Lines[$this.CurrentLine] = $currentLineText.Insert($this.CursorPosition, $key.KeyChar)

$this.CursorPosition++

} else {

$handled = $false

}

}

}



if ($handled -and $this.OnChange -and -not $this._ArraysEqual($originalLines, $this.Lines)) {

Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock {

& $this.OnChange -NewValue $this.Lines

}

$this.RequestRedraw()

}



return $handled

} catch {

Write-Log -Level Error -Message "MultilineTextBox input error for '$($this.Name)': $_"

return $false

}

}



hidden [void] _UpdateScrolling() {

$textAreaHeight = $this.Height - 2

if ($this.CurrentLine -lt $this.ScrollOffsetY) {

$this.ScrollOffsetY = $this.CurrentLine

} elseif ($this.CurrentLine -ge ($this.ScrollOffsetY + $textAreaHeight)) {

$this.ScrollOffsetY = $this.CurrentLine - $textAreaHeight + 1

}

}



hidden [bool] _ArraysEqual([string[]]$array1, [string[]]$array2) {

if ($array1.Count -ne $array2.Count) { return $false }

for ($i = 0; $i -lt $array1.Count; $i++) {

if ($array1[$i] -ne $array2[$i]) { return $false }

}

return $true

}



[string] GetText() {

return $this.Lines -join "`n"

}



[void] SetText([string]$text) {

$this.Lines = if ([string]::IsNullOrEmpty($text)) { @("") } else { $text -split "`n" }

$this.CurrentLine = 0

$this.CursorPosition = 0

$this.ScrollOffsetY = 0

$this.RequestRedraw()

}

}



# AI: REFACTORED - NumericInput converted from functional to class-based

class NumericInputComponent : UIElement {

[double]$Value = 0

[double]$Min = [double]::MinValue

[double]$Max = [double]::MaxValue

[double]$Step = 1

[int]$DecimalPlaces = 0

[string]$TextValue = "0"

[int]$CursorPosition = 0

[string]$Suffix = ""

[scriptblock]$OnChange



NumericInputComponent([string]$name) : base() {

$this.Name = $name

$this.IsFocusable = $true

$this.Width = 20

$this.Height = 3

$this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")

}



# AI: REFACTORED - Now uses UIElement buffer system

[void] OnRender() {

if (-not $this.Visible -or $null -eq $this._private_buffer) { return }



try {

# Clear buffer

$this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))



$borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray



# AI: Draw border

Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `

-BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)



# AI: Display value with suffix

$displayText = $this.TextValue + $this.Suffix

$maxDisplayLength = $this.Width - 6

if ($displayText.Length -gt $maxDisplayLength) {

$displayText = $displayText.Substring(0, $maxDisplayLength)

}



Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `

-ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)



# AI: Draw spinner arrows

Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 0 -Text "▲" `

-ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)

Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 2 -Text "▼" `

-ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)



# AI: Draw cursor if focused

if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {

$cursorX = 2 + $this.CursorPosition

if ($cursorX -lt $this.Width - 4) {

Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" `

-ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)

}

}



} catch {

Write-Log -Level Error -Message "NumericInput render error for '$($this.Name)': $_"

}

}



[bool] HandleInput([System.ConsoleKeyInfo]$key) {

try {

$handled = $true

$originalValue = $this.Value



switch ($key.Key) {

([ConsoleKey]::UpArrow) {

$this._IncrementValue()

}

([ConsoleKey]::DownArrow) {

$this._DecrementValue()

}

([ConsoleKey]::LeftArrow) {

if ($this.CursorPosition -gt 0) {

$this.CursorPosition--

}

}

([ConsoleKey]::RightArrow) {

if ($this.CursorPosition -lt $this.TextValue.Length) {

$this.CursorPosition++

}

}

([ConsoleKey]::Home) { $this.CursorPosition = 0 }

([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }

([ConsoleKey]::Backspace) {

if ($this.CursorPosition -gt 0) {

$this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)

$this.CursorPosition--

}

}

([ConsoleKey]::Delete) {

if ($this.CursorPosition -lt $this.TextValue.Length) {

$this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)

}

}

([ConsoleKey]::Enter) {

$this._ValidateAndUpdate()

}

default {

if ($key.KeyChar -and ($key.KeyChar -match '[\d\.\-]' -or

($key.KeyChar -eq '.' -and $this.DecimalPlaces -gt 0 -and -not $this.TextValue.Contains('.')))) {

$this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)

$this.CursorPosition++

} else {

$handled = $false

}

}

}



if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {

Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock {

& $this.OnChange -NewValue $this.Value

}

$this.RequestRedraw()

}



return $handled

} catch {

Write-Log -Level Error -Message "NumericInput input error for '$($this.Name)': $_"

return $false

}

}



hidden [void] _IncrementValue() {

$newValue = [Math]::Min($this.Max, $this.Value + $this.Step)

$this._SetValue($newValue)

}



hidden [void] _DecrementValue() {

$newValue = [Math]::Max($this.Min, $this.Value - $this.Step)

$this._SetValue($newValue)

}



hidden [void] _SetValue([double]$value) {

$this.Value = $value

$this.TextValue = $value.ToString("F$($this.DecimalPlaces)")

$this.CursorPosition = $this.TextValue.Length

}



hidden [bool] _ValidateAndUpdate() {

try {

$newValue = [double]$this.TextValue

$newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))

$newValue = [Math]::Round($newValue, $this.DecimalPlaces)



$this._SetValue($newValue)

return $true

} catch {

$this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")

Write-Log -Level Warning -Message "NumericInput validation failed for '$($this.Name)': $_"

return $false

}

}

}



# AI: REFACTORED - DateInput converted from functional to class-based

class DateInputComponent : UIElement {

[DateTime]$Value = (Get-Date)

[DateTime]$MinDate = [DateTime]::MinValue

[DateTime]$MaxDate = [DateTime]::MaxValue

[string]$Format = "yyyy-MM-dd"

[string]$TextValue = ""

[int]$CursorPosition = 0

[bool]$ShowCalendar = $false

[scriptblock]$OnChange



DateInputComponent([string]$name) : base() {

$this.Name = $name

$this.IsFocusable = $true

$this.Width = 25

$this.Height = 3

$this.TextValue = $this.Value.ToString($this.Format)

}



# AI: REFACTORED - Now uses UIElement buffer system

[void] OnRender() {

if (-not $this.Visible -or $null -eq $this._private_buffer) { return }



try {

# Clear buffer

$this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))



$borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray



# AI: Draw border

Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `

-BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)



# AI: Display date value

$displayText = $this.TextValue

$maxDisplayLength = $this.Width - 6

if ($displayText.Length -gt $maxDisplayLength) {

$displayText = $displayText.Substring(0, $maxDisplayLength)

}



Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `

-ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)



# AI: Draw calendar icon

Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text "📅" `

-ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)



# AI: Draw cursor if focused

if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {

$cursorX = 2 + $this.CursorPosition

if ($cursorX -lt $this.Width - 4) {

Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" `

-ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)

}

}



} catch {

Write-Log -Level Error -Message "DateInput render error for '$($this.Name)': $_"

}

}



[bool] HandleInput([System.ConsoleKeyInfo]$key) {

try {

$handled = $true

$originalValue = $this.Value



if ($this.ShowCalendar) {

switch ($key.Key) {

([ConsoleKey]::Escape) { $this.ShowCalendar = $false }

([ConsoleKey]::LeftArrow) { $this.Value = $this.Value.AddDays(-1) }

([ConsoleKey]::RightArrow) { $this.Value = $this.Value.AddDays(1) }

([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(-7) }

([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(7) }

([ConsoleKey]::Enter) {

$this.ShowCalendar = $false

$this.TextValue = $this.Value.ToString($this.Format)

}

default { $handled = $false }

}

} else {

switch ($key.Key) {

([ConsoleKey]::F4) { $this.ShowCalendar = $true }

([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(1); $this.TextValue = $this.Value.ToString($this.Format) }

([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(-1); $this.TextValue = $this.Value.ToString($this.Format) }

([ConsoleKey]::LeftArrow) {

if ($this.CursorPosition -gt 0) { $this.CursorPosition-- }

}

([ConsoleKey]::RightArrow) {

if ($this.CursorPosition -lt $this.TextValue.Length) { $this.CursorPosition++ }

}

([ConsoleKey]::Home) { $this.CursorPosition = 0 }

([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }

([ConsoleKey]::Backspace) {

if ($this.CursorPosition -gt 0) {

$this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)

$this.CursorPosition--

}

}

([ConsoleKey]::Delete) {

if ($this.CursorPosition -lt $this.TextValue.Length) {

$this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)

}

}

([ConsoleKey]::Enter) {

$this._ValidateAndUpdate()

}

default {

if ($key.KeyChar -and ($key.KeyChar -match '[\d\-\/]')) {

$this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)

$this.CursorPosition++

} else {

$handled = $false

}

}

}

}



if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {

Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock {

& $this.OnChange -NewValue $this.Value

}

$this.RequestRedraw()

}



return $handled

} catch {

Write-Log -Level Error -Message "DateInput input error for '$($this.Name)': $_"

return $false

}

}



hidden [bool] _ValidateAndUpdate() {

try {

$newDate = [DateTime]::ParseExact($this.TextValue, $this.Format, $null)

if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {

$this.Value = $newDate

$this.TextValue = $newDate.ToString($this.Format)

return $true

}

} catch {

# Reset to current value on parse error

$this.TextValue = $this.Value.ToString($this.Format)

Write-Log -Level Warning -Message "DateInput validation failed for '$($this.Name)': $_"

}

return $false

}

}



# AI: REFACTORED - ComboBox converted from functional to class-based

class ComboBoxComponent : UIElement {

[object[]]$Items = @()

[object]$SelectedItem = $null

[int]$SelectedIndex = -1

[string]$DisplayMember = "Display"

[string]$ValueMember = "Value"

[string]$Placeholder = "Select an item..."

[bool]$IsDropDownOpen = $false

[int]$MaxDropDownHeight = 6

[int]$ScrollOffset = 0

[scriptblock]$OnSelectionChanged



ComboBoxComponent([string]$name) : base() {

$this.Name = $name

$this.IsFocusable = $true

$this.Width = 30

$this.Height = 3

}



# AI: REFACTORED - Now uses UIElement buffer system

[void] OnRender() {

if (-not $this.Visible -or $null -eq $this._private_buffer) { return }

#```



try {

# Clear buffer

$this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))



$borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray



# AI: Draw main combobox

Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `

-BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)



# AI: Display selected item or placeholder

$displayText = ""

if ($this.SelectedItem) {

if ($this.SelectedItem -is [string]) {

$displayText = $this.SelectedItem

} elseif ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.DisplayMember)) {

$displayText = $this.SelectedItem[$this.DisplayMember]

} else {

$displayText = $this.SelectedItem.ToString()

}

} else {

$displayText = $this.Placeholder

}



$maxDisplayLength = $this.Width - 6

if ($displayText.Length -gt $maxDisplayLength) {

$displayText = $displayText.Substring(0, $maxDisplayLength - 3) + "..."

}



$textColor = $this.SelectedItem ? [ConsoleColor]::White : [ConsoleColor]::DarkGray

Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `

-ForegroundColor $textColor -BackgroundColor ([ConsoleColor]::Black)



# AI: Draw dropdown arrow

$arrow = $this.IsDropDownOpen ? "▲" : "▼"

Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text $arrow `

-ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)



} catch {

Write-Log -Level Error -Message "ComboBox render error for '$($this.Name)': $_"

}

}



[bool] HandleInput([System.ConsoleKeyInfo]$key) {

try {

$handled = $true

$originalSelection = $this.SelectedItem



if ($this.IsDropDownOpen) {

switch ($key.Key) {

([ConsoleKey]::Escape) {

$this.IsDropDownOpen = $false

}

([ConsoleKey]::Enter) {

if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {

$this.SelectedItem = $this.Items[$this.SelectedIndex]

}

$this.IsDropDownOpen = $false

}

([ConsoleKey]::UpArrow) {

if ($this.SelectedIndex -gt 0) {

$this.SelectedIndex--

$this._UpdateScrolling()

}

}

([ConsoleKey]::DownArrow) {

if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {

$this.SelectedIndex++

$this._UpdateScrolling()

}

}

default { $handled = $false }

}

} else {

switch ($key.Key) {

([ConsoleKey]::Enter) { $this._OpenDropDown() }

([ConsoleKey]::Spacebar) { $this._OpenDropDown() }

([ConsoleKey]::DownArrow) { $this._OpenDropDown() }

([ConsoleKey]::UpArrow) { $this._OpenDropDown() }

([ConsoleKey]::F4) { $this._OpenDropDown() }

default { $handled = $false }

}

}



if ($handled -and $this.SelectedItem -ne $originalSelection -and $this.OnSelectionChanged) {

Invoke-WithErrorHandling -Component "$($this.Name).OnSelectionChanged" -Context "Selection Change" -ScriptBlock {

& $this.OnSelectionChanged -SelectedItem $this.SelectedItem

}

$this.RequestRedraw()

}



return $handled

} catch {

Write-Log -Level Error -Message "ComboBox input error for '$($this.Name)': $_"

return $false

}

}



hidden [void] _OpenDropDown() {

if ($this.Items.Count -gt 0) {

$this.IsDropDownOpen = $true

$this._FindCurrentSelection()

}

}



hidden [void] _FindCurrentSelection() {

$this.SelectedIndex = -1

if ($this.SelectedItem) {

for ($i = 0; $i -lt $this.Items.Count; $i++) {

if ($this._ItemsEqual($this.Items[$i], $this.SelectedItem)) {

$this.SelectedIndex = $i

break

}

}

}

if ($this.SelectedIndex -eq -1) { $this.SelectedIndex = 0 }

$this._UpdateScrolling()

}



hidden [void] _UpdateScrolling() {

if ($this.SelectedIndex -lt $this.ScrollOffset) {

$this.ScrollOffset = $this.SelectedIndex

} elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $this.MaxDropDownHeight)) {

$this.ScrollOffset = $this.SelectedIndex - $this.MaxDropDownHeight + 1

}

}



hidden [bool] _ItemsEqual([object]$item1, [object]$item2) {

if ($item1 -is [string] -and $item2 -is [string]) {

return $item1 -eq $item2

} elseif ($item1 -is [hashtable] -and $item2 -is [hashtable]) {

return $item1[$this.ValueMember] -eq $item2[$this.ValueMember]

} else {

return $item1 -eq $item2

}

}



[void] SetItems([object[]]$items) {

$this.Items = $items

$this.SelectedItem = $null

$this.SelectedIndex = -1

$this.ScrollOffset = 0

$this.IsDropDownOpen = $false

$this.RequestRedraw()

}



[object] GetSelectedValue() {

if ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.ValueMember)) {

return $this.SelectedItem[$this.ValueMember]

}

return $this.SelectedItem

}

}



#endregion



#region Factory Functions



# AI: Updated factories to return class instances



function New-TuiMultilineTextBox {

param([hashtable]$Props = @{})



$name = $Props.Name ?? "MultilineTextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"

$textBox = [MultilineTextBoxComponent]::new($name)



$textBox.X = $Props.X ?? $textBox.X

$textBox.Y = $Props.Y ?? $textBox.Y

$textBox.Width = $Props.Width ?? $textBox.Width

$textBox.Height = $Props.Height ?? $textBox.Height

$textBox.Visible = $Props.Visible ?? $textBox.Visible

$textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex

$textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder

$textBox.MaxLines = $Props.MaxLines ?? $textBox.MaxLines

$textBox.MaxLineLength = $Props.MaxLineLength ?? $textBox.MaxLineLength

$textBox.WordWrap = $Props.WordWrap ?? $textBox.WordWrap

$textBox.OnChange = $Props.OnChange ?? $textBox.OnChange



if ($Props.Text) {

$textBox.SetText($Props.Text)

}



return $textBox

}



function New-TuiNumericInput {

param([hashtable]$Props = @{})



$name = $Props.Name ?? "NumericInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"

$numericInput = [NumericInputComponent]::new($name)



$numericInput.X = $Props.X ?? $numericInput.X

$numericInput.Y = $Props.Y ?? $numericInput.Y

$numericInput.Width = $Props.Width ?? $numericInput.Width

$numericInput.Height = $Props.Height ?? $numericInput.Height

$numericInput.Visible = $Props.Visible ?? $numericInput.Visible

$numericInput.ZIndex = $Props.ZIndex ?? $numericInput.ZIndex

$numericInput.Value = $Props.Value ?? $numericInput.Value

$numericInput.Min = $Props.Min ?? $numericInput.Min

$numericInput.Max = $Props.Max ?? $numericInput.Max

$numericInput.Step = $Props.Step ?? $numericInput.Step

$numericInput.DecimalPlaces = $Props.DecimalPlaces ?? $numericInput.DecimalPlaces

$numericInput.Suffix = $Props.Suffix ?? $numericInput.Suffix

$numericInput.OnChange = $Props.OnChange ?? $numericInput.OnChange



# Update text value based on initial value

$numericInput.TextValue = $numericInput.Value.ToString("F$($numericInput.DecimalPlaces)")



return $numericInput

}



function New-TuiDateInput {

param([hashtable]$Props = @{})



$name = $Props.Name ?? "DateInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"

$dateInput = [DateInputComponent]::new($name)



$dateInput.X = $Props.X ?? $dateInput.X

$dateInput.Y = $Props.Y ?? $dateInput.Y

$dateInput.Width = $Props.Width ?? $dateInput.Width

$dateInput.Height = $Props.Height ?? $dateInput.Height

$dateInput.Visible = $Props.Visible ?? $dateInput.Visible

$dateInput.ZIndex = $Props.ZIndex ?? $dateInput.ZIndex

$dateInput.Value = $Props.Value ?? $dateInput.Value

$dateInput.MinDate = $Props.MinDate ?? $dateInput.MinDate

$dateInput.MaxDate = $Props.MaxDate ?? $dateInput.MaxDate

$dateInput.Format = $Props.Format ?? $dateInput.Format

$dateInput.OnChange = $Props.OnChange ?? $dateInput.OnChange



# Update text value based on initial value

$dateInput.TextValue = $dateInput.Value.ToString($dateInput.Format)



return $dateInput

}



function New-TuiComboBox {

param([hashtable]$Props = @{})



$name = $Props.Name ?? "ComboBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"

$comboBox = [ComboBoxComponent]::new($name)



$comboBox.X = $Props.X ?? $comboBox.X

$comboBox.Y = $Props.Y ?? $comboBox.Y

$comboBox.Width = $Props.Width ?? $comboBox.Width

$comboBox.Height = $Props.Height ?? $comboBox.Height

$comboBox.Visible = $Props.Visible ?? $comboBox.Visible

$comboBox.ZIndex = $Props.ZIndex ?? $comboBox.ZIndex

$comboBox.DisplayMember = $Props.DisplayMember ?? $comboBox.DisplayMember

$comboBox.ValueMember = $Props.ValueMember ?? $comboBox.ValueMember

$comboBox.Placeholder = $Props.Placeholder ?? $comboBox.Placeholder

$comboBox.MaxDropDownHeight = $Props.MaxDropDownHeight ?? $comboBox.MaxDropDownHeight

$comboBox.OnSelectionChanged = $Props.OnSelectionChanged ?? $comboBox.OnSelectionChanged



if ($Props.Items) {

$comboBox.SetItems($Props.Items)

}



if ($Props.SelectedItem) {

$comboBox.SelectedItem = $Props.SelectedItem

}



return $comboBox

}



#endregion
# --- END OF ORIGINAL FILE: components\advanced-input-components\advanced-input-components.psm1 ---

# --- START OF ORIGINAL FILE: modules\data-manager-class\data-manager-class.psm1 ---
# DELETED - This file's contents have been merged into modules\data-manager\data-manager.psm1
# --- END OF ORIGINAL FILE: modules\data-manager-class\data-manager-class.psm1 ---

# --- START OF ORIGINAL FILE: services\keybinding-service-class\keybinding-service-class.psm1 ---
# keybinding-service-class.psm1

# Contains only the KeybindingService class definition.







class KeybindingService {

[hashtable] $KeyMap = @{}

[hashtable] $GlobalHandlers = @{}

[System.Collections.Generic.List[string]] $ContextStack

[bool] $EnableChords = $false



KeybindingService() {

$this.ContextStack = [System.Collections.Generic.List[string]]::new()

$this.InitializeDefaultBindings()



Write-Log -Level Info -Message "KeybindingService initialized"

}



KeybindingService([bool]$enableChords) {

$this.ContextStack = [System.Collections.Generic.List[string]]::new()

$this.EnableChords = $enableChords

$this.InitializeDefaultBindings()



Write-Log -Level Info -Message "KeybindingService initialized with chords: $enableChords"

}



hidden [void] InitializeDefaultBindings() {

# AI: Standard application keybindings

$this.KeyMap = @{

"app.exit" = @{ Key = "Q"; Modifiers = @("Ctrl") }

"app.help" = @{ Key = [System.ConsoleKey]::F1; Modifiers = @() }

"nav.back" = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }

"nav.up" = @{ Key = [System.ConsoleKey]::UpArrow; Modifiers = @() }

"nav.down" = @{ Key = [System.ConsoleKey]::DownArrow; Modifiers = @() }

"nav.left" = @{ Key = [System.ConsoleKey]::LeftArrow; Modifiers = @() }

"nav.right" = @{ Key = [System.ConsoleKey]::RightArrow; Modifiers = @() }

"nav.select" = @{ Key = [System.ConsoleKey]::Enter; Modifiers = @() }

"nav.pageup" = @{ Key = [System.ConsoleKey]::PageUp; Modifiers = @() }

"nav.pagedown" = @{ Key = [System.ConsoleKey]::PageDown; Modifiers = @() }

"nav.home" = @{ Key = [System.ConsoleKey]::Home; Modifiers = @() }

"nav.end" = @{ Key = [System.ConsoleKey]::End; Modifiers = @() }

"nav.tab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @() }

"nav.shifttab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @("Shift") }

"edit.delete" = @{ Key = [System.ConsoleKey]::Delete; Modifiers = @() }

"edit.backspace" = @{ Key = [System.ConsoleKey]::Backspace; Modifiers = @() }

"edit.new" = @{ Key = "n"; Modifiers = @() }

"edit.save" = @{ Key = "s"; Modifiers = @("Ctrl") }

"app.refresh" = @{ Key = [System.ConsoleKey]::F5; Modifiers = @() }

}

}



[void] SetBinding([string]$actionName, [System.ConsoleKey]$key, [string[]]$modifiers) {

Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {

if ([string]::IsNullOrWhiteSpace($actionName)) {

throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")

}



$this.KeyMap[$actionName.ToLower()] = @{

Key = $key

Modifiers = if ($modifiers) { @($modifiers) } else { @() }

}



Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"

}

}



[void] SetBinding([string]$actionName, [char]$key, [string[]]$modifiers) {

Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {

if ([string]::IsNullOrWhiteSpace($actionName)) {

throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")

}



$this.KeyMap[$actionName.ToLower()] = @{

Key = $key

Modifiers = if ($modifiers) { @($modifiers) } else { @() }

}



Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"

}

}



[void] SetBinding([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {

if ([string]::IsNullOrWhiteSpace($actionName)) {

throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")

}



$modifiers = @()

if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) { $modifiers += "Ctrl" }

if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) { $modifiers += "Alt" }

if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) { $modifiers += "Shift" }



$this.KeyMap[$actionName.ToLower()] = @{

Key = $keyInfo.Key

KeyChar = $keyInfo.KeyChar

Modifiers = $modifiers

}

Write-Log -Level Debug -Message "Set keybinding for '$actionName': $($this.GetBindingDescription($actionName))"

}



[void] RemoveBinding([string]$actionName) {

Invoke-WithErrorHandling -Component "KeybindingService" -Context "RemoveBinding:$actionName" -ScriptBlock {

if ([string]::IsNullOrWhiteSpace($actionName)) {

return

}



$normalizedName = $actionName.ToLower()

if ($this.KeyMap.ContainsKey($normalizedName)) {

$this.KeyMap.Remove($normalizedName)

Write-Log -Level Debug -Message "Removed keybinding: $actionName"

}

}

}



[bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {

return $this.IsAction($actionName, $keyInfo, $null)

}



[bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo, [string]$context) {

return Invoke-WithErrorHandling -Component "KeybindingService" -Context "IsAction:$actionName" -ScriptBlock {

if ([string]::IsNullOrWhiteSpace($actionName)) {

return $false

}



$normalizedName = $actionName.ToLower()

if (-not $this.KeyMap.ContainsKey($normalizedName)) {

return $false

}



$binding = $this.KeyMap[$normalizedName]



# Check if the key matches

$keyMatches = $false

if ($binding.Key -is [System.ConsoleKey]) {

$keyMatches = ($keyInfo.Key -eq $binding.Key)

}

elseif ($binding.Key -is [char]) {

$keyMatches = ($keyInfo.KeyChar -eq $binding.Key)

}

elseif ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {

# Character-based binding (case-insensitive)

$keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.KeyChar.ToString(), [System.StringComparison]::OrdinalIgnoreCase)

}

else {

# Try string comparison for backward compatibility

$keyString = $binding.Key.ToString()

if ($keyString.Length -eq 1) {

$keyMatches = ($keyInfo.KeyChar.ToString().ToUpper() -eq $keyString.ToUpper())

}

else {

# Try to match against ConsoleKey enum

try {

$consoleKey = [System.ConsoleKey]::Parse([System.ConsoleKey], $keyString, $true)

$keyMatches = ($keyInfo.Key -eq $consoleKey)

}

catch {

$keyMatches = $false

}

}

}



if (-not $keyMatches) {

return $false

}



# Check modifiers

$hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0

$hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0

$hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0



$expectedCtrl = $binding.Modifiers -contains "Ctrl"

$expectedAlt = $binding.Modifiers -contains "Alt"

$expectedShift = $binding.Modifiers -contains "Shift"



return ($hasCtrl -eq $expectedCtrl) -and ($hasAlt -eq $expectedAlt) -and ($hasShift -eq $expectedShift)

}

}



[string] GetAction([System.ConsoleKeyInfo]$keyInfo) {

return Invoke-WithErrorHandling -Component "KeybindingService" -Context "GetAction" -ScriptBlock {

foreach ($actionName in $this.KeyMap.Keys) {

if ($this.IsAction($actionName, $keyInfo)) {

return $actionName

}

}

return $null

}

}



[void] RegisterGlobalHandler([string]$actionName, [scriptblock]$handler) {

Invoke-WithErrorHandling -Component "KeybindingService" -Context "RegisterGlobalHandler:$actionName" -ScriptBlock {

if ([string]::IsNullOrWhiteSpace($actionName)) {

throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")

}

if ($null -eq $handler) {

throw [System.ArgumentNullException]::new("handler", "Handler cannot be null")

}



$this.GlobalHandlers[$actionName.ToLower()] = $handler

Write-Log -Level Debug -Message "Registered global handler: $actionName"

}

}



[object] HandleKey([System.ConsoleKeyInfo]$keyInfo) {

return $this.HandleKey($keyInfo, $null)

}



[object] HandleKey([System.ConsoleKeyInfo]$keyInfo, [string]$context) {

return Invoke-WithErrorHandling -Component "KeybindingService" -Context "HandleKey" -ScriptBlock {

# Check all registered actions

foreach ($action in $this.KeyMap.Keys) {

if ($this.IsAction($action, $keyInfo, $context)) {

# Execute global handler if registered

if ($this.GlobalHandlers.ContainsKey($action)) {

Write-Log -Level Debug -Message "Executing global handler: $action"

try {

return & $this.GlobalHandlers[$action] -KeyInfo $keyInfo -Context $context

}

catch {

Write-Log -Level Error -Message "Global handler failed for '$action': $_"

return $null

}

}



# Return the action name for the caller to handle

return $action

}

}



return $null

}

}



[void] PushContext([string]$context) {

if (-not [string]::IsNullOrWhiteSpace($context)) {

$this.ContextStack.Add($context)

Write-Log -Level Debug -Message "Pushed keybinding context: $context (Stack depth: $($this.ContextStack.Count))"

}

}



[string] PopContext() {

if ($this.ContextStack.Count -gt 0) {

$context = $this.ContextStack[-1]

$this.ContextStack.RemoveAt($this.ContextStack.Count - 1)

Write-Log -Level Debug -Message "Popped keybinding context: $context (Stack depth: $($this.ContextStack.Count))"

return $context

}

return $null

}



[string] GetCurrentContext() {

if ($this.ContextStack.Count -gt 0) {

return $this.ContextStack[-1]

}

return "global"

}



[string] GetBindingDescription([string]$actionName) {

if ([string]::IsNullOrWhiteSpace($actionName)) {

return $null

}



$normalizedName = $actionName.ToLower()

if (-not $this.KeyMap.ContainsKey($normalizedName)) {

return "Unbound"

}



$binding = $this.KeyMap[$normalizedName]

$keyStr = if ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {

$binding.KeyChar.ToString().ToUpper()

} elseif ($binding.Key -is [System.ConsoleKey]) {

$binding.Key.ToString()

} else {

$binding.Key.ToString().ToUpper()

}



if ($binding.Modifiers.Count -gt 0) {

return "$($binding.Modifiers -join '+') + $keyStr"

}



return $keyStr

}



[hashtable] GetAllBindings() {

return $this.GetAllBindings($false)

}



[hashtable] GetAllBindings([bool]$groupByCategory) {

if (-not $groupByCategory) {

return $this.KeyMap.Clone()

}



# Group by category (part before the dot)

$grouped = @{}

foreach ($action in $this.KeyMap.Keys) {

$parts = $action.Split('.')

$category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }

if (-not $grouped.ContainsKey($category)) {

$grouped[$category] = @{}

}

$grouped[$category][$action] = $this.KeyMap[$action]

}



return $grouped

}



[void] ExportBindings([string]$path) {

Invoke-WithErrorHandling -Component "KeybindingService" -Context "ExportBindings" -ScriptBlock {

if ([string]::IsNullOrWhiteSpace($path)) {

throw [System.ArgumentException]::new("Path cannot be null or empty", "path")

}



$this.KeyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $path -Encoding UTF8

Write-Log -Level Info -Message "Exported keybindings to: $path"

}

}



[void] ImportBindings([string]$path) {

Invoke-WithErrorHandling -Component "KeybindingService" -Context "ImportBindings" -ScriptBlock {

if ([string]::IsNullOrWhiteSpace($path)) {

throw [System.ArgumentException]::new("Path cannot be null or empty", "path")

}



if (-not (Test-Path $path)) {

Write-Log -Level Warning -Message "Keybindings file not found: $path"

return

}



try {

$imported = Get-Content $path -Raw | ConvertFrom-Json

foreach ($prop in $imported.PSObject.Properties) {

$bindingData = @{

Key = $prop.Value.Key

Modifiers = $prop.Value.Modifiers

}

if ($prop.Value.PSObject.Properties.Name -contains 'KeyChar') {

$bindingData['KeyChar'] = $prop.Value.KeyChar

}

$this.KeyMap[$prop.Name] = $bindingData

}

Write-Log -Level Info -Message "Imported keybindings from: $path"

}

catch {

Write-Log -Level Error -Message "Failed to import keybindings from '$path': $_"

throw

}

}

}

}
# --- END OF ORIGINAL FILE: services\keybinding-service-class\keybinding-service-class.psm1 ---

# --- START OF ORIGINAL FILE: modules\dialog-system-class\dialog-system-class.psm1 ---
# ==============================================================================

# PMC Terminal v5 - Class-Based Dialog System

# Implements dialogs as proper UIElement classes following the unified architecture

# ==============================================================================



# A UIElement designed to be displayed modally over other content using the

# TUI Engine's overlay system. It handles its own rendering and input,

# and uses Show-TuiOverlay/Close-TopTuiOverlay to manage its lifecycle.

class Dialog : UIElement {

[string] $Title = "Dialog"

[string] $Message = ""

[ConsoleColor] $BorderColor = [ConsoleColor]::Cyan

[ConsoleColor] $TitleColor = [ConsoleColor]::White

[ConsoleColor] $MessageColor = [ConsoleColor]::Gray



Dialog([string]$name) : base($name) {

$this.IsFocusable = $true

$this.Width = 50

$this.Height = 10

}



[void] Show() {

$this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)

$this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 2)

if ($null -eq $this.{_private_buffer} -or $this.{_private_buffer}.Width -ne $this.Width -or $this.{_private_buffer}.Height -ne $this.Height) {

$this.{_private_buffer} = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")

}

Show-TuiOverlay -Element $this

}



[void] Close() {

Close-TopTuiOverlay

}



[void] OnRender() {

if ($null -eq $this.{_private_buffer}) { return }

$this.{_private_buffer}.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))

Write-TuiBox -Buffer $this.{_private_buffer} -X 0 -Y 0 -Width $this.Width -Height $this.Height `

-BorderStyle "Single" -BorderColor $this.BorderColor -BackgroundColor [ConsoleColor]::Black -Title $this.Title

if (-not [string]::IsNullOrWhiteSpace($this.Message)) { $this.RenderMessage() }

$this.RenderDialogContent()

}



hidden [void] RenderMessage() {

$messageY = 2; $messageX = 2; $maxWidth = $this.Width - 4

$wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth

foreach ($line in $wrappedLines) {

if ($messageY -ge ($this.Height - 3)) { break }

Write-TuiText -Buffer $this.{_private_buffer} -X $messageX -Y $messageY -Text $line -ForegroundColor $this.MessageColor

$messageY++

}

}



[void] RenderDialogContent() { }



[bool] HandleInput([ConsoleKeyInfo]$key) {

if ($key.Key -eq [ConsoleKey]::Escape) { $this.OnCancel(); return $true }

return $false

}



[void] OnConfirm() { $this.Close() }

[void] OnCancel() { $this.Close() }

}



class AlertDialog : Dialog {

[string] $ButtonText = "OK"

AlertDialog([string]$title, [string]$message) : base("AlertDialog") {

$this.Title = $title; $this.Message = $message; $this.Height = 10

$this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))

}

[void] RenderDialogContent() {

$buttonY = $this.Height - 2; $buttonLabel = "[ $($this.ButtonText) ]"

$buttonX = [Math]::Floor(($this.Width - $buttonLabel.Length) / 2)

Write-TuiText -Buffer $this.{_private_buffer} -X $buttonX -Y $buttonY -Text $buttonLabel -ForegroundColor ([ConsoleColor]::Yellow)

}

[bool] HandleInput([ConsoleKeyInfo]$key) {

if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) { $this.OnConfirm(); return $true }

return ([Dialog]$this).HandleInput($key)

}

}



class ConfirmDialog : Dialog {

[scriptblock] $OnConfirmAction; [scriptblock] $OnCancelAction

[string[]] $Buttons = @("Yes", "No"); [int] $SelectedButton = 0

ConfirmDialog([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) : base("ConfirmDialog") {

$this.Title = $title; $this.Message = $message; $this.OnConfirmAction = $onConfirm; $this.OnCancelAction = $onCancel

$this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10)); $this.Height = 10

}

[void] RenderDialogContent() {

$buttonY = $this.Height - 3; $totalButtonWidth = ($this.Buttons.Count * 12) + (($this.Buttons.Count - 1) * 2)

$buttonX = [Math]::Floor(($this.Width - $totalButtonWidth) / 2)

for ($i = 0; $i -lt $this.Buttons.Count; $i++) {

$isSelected = ($i -eq $this.SelectedButton)

$buttonLabel = if ($isSelected) { "[ $($this.Buttons[$i]) ]" } else { "  $($this.Buttons[$i])  " }

$color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }

Write-TuiText -Buffer $this.{_private_buffer} -X $buttonX -Y $buttonY -Text $buttonLabel -ForegroundColor $color

$buttonX += 14

}

}

[bool] HandleInput([ConsoleKeyInfo]$key) {

switch ($key.Key) {

([ConsoleKey]::LeftArrow) { $this.SelectedButton = [Math]::Max(0, $this.SelectedButton - 1); $this.RequestRedraw(); return $true }

([ConsoleKey]::RightArrow) { $this.SelectedButton = [Math]::Min($this.Buttons.Count - 1, $this.SelectedButton + 1); $this.RequestRedraw(); return $true }

([ConsoleKey]::Tab) { $this.SelectedButton = ($this.SelectedButton + 1) % $this.Buttons.Count; $this.RequestRedraw(); return $true }

([ConsoleKey]::Enter) { if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }; return $true }

([ConsoleKey]::Spacebar) { if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }; return $true }

}

return ([Dialog]$this).HandleInput($key)

}

[void] OnConfirm() { $this.Close(); if ($this.OnConfirmAction) { Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnConfirm" -ScriptBlock $this.OnConfirmAction } }

[void] OnCancel() { $this.Close(); if ($this.OnCancelAction) { Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction } }

}



class InputDialog : Dialog {

[string] $Prompt = ""

[string] $InputValue = ""

[int] $CursorPosition = 0

[scriptblock] $OnSubmitAction

[scriptblock] $OnCancelAction



InputDialog([string]$title, [string]$prompt, [scriptblock]$onSubmit, [scriptblock]$onCancel) : base("InputDialog") {

$this.Title = $title

$this.Prompt = $prompt

$this.OnSubmitAction = $onSubmit

$this.OnCancelAction = $onCancel

$this.Width = [Math]::Min(80, [Math]::Max(50, $prompt.Length + 20))

$this.Height = 12

}



[void] SetDefaultValue([string]$value) {

$this.InputValue = $value

$this.CursorPosition = $value.Length

}



[void] RenderDialogContent() {

$promptY = 3; $promptX = 4

Write-TuiText -Buffer $this.{_private_buffer} -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor [ConsoleColor]::White



$inputY = 5; $inputX = 4; $inputWidth = $this.Width - 8

Write-TuiBox -Buffer $this.{_private_buffer} -X $inputX -Y $inputY -Width $inputWidth -Height 3 -BorderStyle "Single" -BorderColor [ConsoleColor]::DarkGray



$displayValue = $this.InputValue

if ($displayValue.Length -gt ($inputWidth - 3)) {

$displayValue = $displayValue.Substring($displayValue.Length - ($inputWidth - 3))

}

Write-TuiText -Buffer $this.{_private_buffer} -X ($inputX + 1) -Y ($inputY + 1) -Text $displayValue -ForegroundColor [ConsoleColor]::Yellow



$buttonY = $this.Height - 3; $okLabel = "[ OK ]"; $cancelLabel = "[ Cancel ]"

$totalWidth = $okLabel.Length + $cancelLabel.Length + 4

$startX = [Math]::Floor(($this.Width - $totalWidth) / 2)

Write-TuiText -Buffer $this.{_private_buffer} -X $startX -Y $buttonY -Text $okLabel -ForegroundColor [ConsoleColor]::Green

Write-TuiText -Buffer $this.{_private_buffer} -X ($startX + $okLabel.Length + 4) -Y $buttonY -Text $cancelLabel -ForegroundColor [ConsoleColor]::Gray

}



[bool] HandleInput([ConsoleKeyInfo]$key) {

switch ($key.Key) {

([ConsoleKey]::Enter) { $this.OnSubmit(); return $true }

([ConsoleKey]::Escape) { $this.OnCancel(); return $true }

([ConsoleKey]::Backspace) { if ($this.CursorPosition -gt 0) { $this.InputValue = $this.InputValue.Remove($this.CursorPosition - 1, 1); $this.CursorPosition--; $this.RequestRedraw() }; return $true }

([ConsoleKey]::Delete) { if ($this.CursorPosition -lt $this.InputValue.Length) { $this.InputValue = $this.InputValue.Remove($this.CursorPosition, 1); $this.RequestRedraw() }; return $true }

([ConsoleKey]::LeftArrow) { if ($this.CursorPosition -gt 0) { $this.CursorPosition--; $this.RequestRedraw() }; return $true }

([ConsoleKey]::RightArrow) { if ($this.CursorPosition -lt $this.InputValue.Length) { $this.CursorPosition++; $this.RequestRedraw() }; return $true }

([ConsoleKey]::Home) { $this.CursorPosition = 0; $this.RequestRedraw(); return $true }

([ConsoleKey]::End) { $this.CursorPosition = $this.InputValue.Length; $this.RequestRedraw(); return $true }

default {

if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or $key.KeyChar -in @(' ', '.', '-', '_', '@', '!', '?', ',', ';', ':', '/', '\', '(', ')', '[', ']', '{', '}')) {

$this.InputValue = $this.InputValue.Insert($this.CursorPosition, $key.KeyChar)

$this.CursorPosition++

$this.RequestRedraw()

return $true

}

}

}

return ([Dialog]$this).HandleInput($key)

}



[void] OnSubmit() {

$this.Close()

if ($this.OnSubmitAction) {

Invoke-WithErrorHandling -Component "InputDialog" -Context "OnSubmit" -ScriptBlock { & $this.OnSubmitAction $this.InputValue }

}

}



[void] OnCancel() {

$this.Close()

if ($this.OnCancelAction) {

Invoke-WithErrorHandling -Component "InputDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction

}

}

}



class ProgressDialog : Dialog {

[int] $PercentComplete = 0

[string] $StatusText = ""

[bool] $ShowCancel = $false

[bool] $IsCancelled = $false



ProgressDialog([string]$title, [string]$message) : base("ProgressDialog") {

$this.Title = $title; $this.Message = $message; $this.Width = 60; $this.Height = 10

}



[void] UpdateProgress([int]$percent, [string]$status = "") {

$this.PercentComplete = [Math]::Max(0, [Math]::Min(100, $percent))

if ($status) { $this.StatusText = $status }

$this.RequestRedraw()

}



[void] RenderDialogContent() {

$barY = 4; $barX = 4; $barWidth = $this.Width - 8

$filledWidth = [Math]::Floor($barWidth * ($this.PercentComplete / 100.0))

Write-TuiText -Buffer $this.{_private_buffer} -X $barX -Y $barY -Text ('─' * $barWidth) -ForegroundColor [ConsoleColor]::DarkGray

if ($filledWidth -gt 0) { Write-TuiText -Buffer $this.{_private_buffer} -X $barX -Y $barY -Text ('█' * $filledWidth) -ForegroundColor [ConsoleColor]::Green }



$percentText = "$($this.PercentComplete)%"; $percentX = [Math]::Floor(($this.Width - $percentText.Length) / 2)

Write-TuiText -Buffer $this.{_private_buffer} -X $percentX -Y ($barY + 1) -Text $percentText -ForegroundColor [ConsoleColor]::White



if ($this.StatusText) {

$statusY = $barY + 3; $maxStatusWidth = $this.Width - 8

$displayStatus = if ($this.StatusText.Length -gt $maxStatusWidth) { $this.StatusText.Substring(0, $maxStatusWidth - 3) + "..." } else { $this.StatusText }

$statusX = [Math]::Floor(($this.Width - $displayStatus.Length) / 2)

Write-TuiText -Buffer $this.{_private_buffer} -X $statusX -Y $statusY -Text $displayStatus -ForegroundColor [ConsoleColor]::Gray

}



if ($this.ShowCancel) {

$buttonY = $this.Height - 2; $cancelLabel = "[ Cancel ]"; $buttonX = [Math]::Floor(($this.Width - $cancelLabel.Length) / 2)

Write-TuiText -Buffer $this.{_private_buffer} -X $buttonX -Y $buttonY -Text $cancelLabel -ForegroundColor [ConsoleColor]::Yellow

}

}



[bool] HandleInput([ConsoleKeyInfo]$key) {

if ($this.ShowCancel -and $key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {

$this.IsCancelled = $true

$this.Close()

return $true

}

return $false

}

}



class ListDialog : Dialog {

[string] $Prompt = ""; [string[]] $Items = @(); [int] $SelectedIndex = 0; [int] $ScrollOffset = 0; [int] $VisibleItems = 10; [bool] $AllowMultiple = $false; [System.Collections.Generic.HashSet[int]] $SelectedIndices; [scriptblock] $OnSelectAction; [scriptblock] $OnCancelAction



ListDialog([string]$title, [string]$prompt, [string[]]$items, [scriptblock]$onSelect, [scriptblock]$onCancel) : base("ListDialog") {

$this.Title = $title; $this.Prompt = $prompt; $this.Items = $items; $this.OnSelectAction = $onSelect; $this.OnCancelAction = $onCancel

$this.SelectedIndices = [System.Collections.Generic.HashSet[int]]::new()

$maxItemWidth = ($items | Measure-Object -Property Length -Maximum).Maximum

$this.Width = [Math]::Min(80, [Math]::Max(40, $maxItemWidth + 10))

$this.VisibleItems = [Math]::Min(10, $items.Count)

$this.Height = $this.VisibleItems + 8

}



[void] RenderDialogContent() {

if ($this.Prompt) { $promptY = 2; $promptX = 4; Write-TuiText -Buffer $this.{_private_buffer} -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor [ConsoleColor]::White }



$listY = 4; $listX = 4; $listWidth = $this.Width - 8

$endIndex = [Math]::Min($this.ScrollOffset + $this.VisibleItems, $this.Items.Count)

for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {

$relativeY = $listY + ($i - $this.ScrollOffset); $item = $this.Items[$i]; $isSelected = ($i -eq $this.SelectedIndex); $isChecked = $this.SelectedIndices.Contains($i)

if ($item.Length -gt ($listWidth - 4)) { $item = $item.Substring(0, $listWidth - 7) + "..." }

$prefix = if ($this.AllowMultiple) { if ($isChecked) { "[x] " } else { "[ ] " } } else { "" }

$displayText = "$prefix$item"

$fg = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }; $bg = if ($isSelected) { [ConsoleColor]::DarkGray } else { [ConsoleColor]::Black }

Write-TuiText -Buffer $this.{_private_buffer} -X $listX -Y $relativeY -Text (' ' * $listWidth) -BackgroundColor $bg

Write-TuiText -Buffer $this.{_private_buffer} -X $listX -Y $relativeY -Text $displayText -ForegroundColor $fg -BackgroundColor $bg

}



if ($this.ScrollOffset -gt 0) { Write-TuiText -Buffer $this.{_private_buffer} -X ($this.Width - 5) -Y $listY -Text "▲" -ForegroundColor [ConsoleColor]::DarkGray }

if ($endIndex -lt $this.Items.Count) { Write-TuiText -Buffer $this.{_private_buffer} -X ($this.Width - 5) -Y ($listY + $this.VisibleItems - 1) -Text "▼" -ForegroundColor [ConsoleColor]::DarkGray }



$instructY = $this.Height - 3; $instructions = if ($this.AllowMultiple) { "Space: Toggle, Enter: Confirm, Esc: Cancel" } else { "Enter: Select, Esc: Cancel" }; $instructX = [Math]::Floor(($this.Width - $instructions.Length) / 2)

Write-TuiText -Buffer $this.{_private_buffer} -X $instructX -Y $instructY -Text $instructions -ForegroundColor [ConsoleColor]::DarkGray

}



[bool] HandleInput([ConsoleKeyInfo]$key) {

switch ($key.Key) {

([ConsoleKey]::UpArrow) { if ($this.SelectedIndex -gt 0) { $this.SelectedIndex--; if ($this.SelectedIndex -lt $this.ScrollOffset) { $this.ScrollOffset = $this.SelectedIndex }; $this.RequestRedraw() }; return $true }

([ConsoleKey]::DownArrow) { if ($this.SelectedIndex -lt ($this.Items.Count - 1)) { $this.SelectedIndex++; if ($this.SelectedIndex -ge ($this.ScrollOffset + $this.VisibleItems)) { $this.ScrollOffset = $this.SelectedIndex - $this.VisibleItems + 1 }; $this.RequestRedraw() }; return $true }

([ConsoleKey]::Spacebar) { if ($this.AllowMultiple) { if ($this.SelectedIndices.Contains($this.SelectedIndex)) { [void]$this.SelectedIndices.Remove($this.SelectedIndex) } else { [void]$this.SelectedIndices.Add($this.SelectedIndex) }; $this.RequestRedraw() }; return $true }

([ConsoleKey]::Enter) { $this.OnSelect(); return $true }

([ConsoleKey]::Escape) { $this.OnCancel(); return $true }

}

return $false

}



[void] OnSelect() {

$this.Close()

if ($this.OnSelectAction) {

if ($this.AllowMultiple) {

$selectedItems = @(); foreach ($index in $this.SelectedIndices) { $selectedItems += $this.Items[$index] }

Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock { & $this.OnSelectAction $selectedItems }

} else {

$selectedItem = $this.Items[$this.SelectedIndex]

Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock { & $this.OnSelectAction $selectedItem }

}

}

}



[void] OnCancel() {

$this.Close()

if ($this.OnCancelAction) {

Invoke-WithErrorHandling -Component "ListDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction

}

}

}



function Get-WordWrappedLines {

param([string]$Text, [int]$MaxWidth)

$lines = @(); $words = $Text -split '\s+'; $currentLine = ""

foreach ($word in $words) {

if ($currentLine.Length -eq 0) { $currentLine = $word }

elseif (($currentLine.Length + 1 + $word.Length) -le $MaxWidth) { $currentLine += " " + $word }

else { $lines += $currentLine; $currentLine = $word }

}

if ($currentLine.Length -gt 0) { $lines += $currentLine }

return $lines

}



function Initialize-DialogSystem {

Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {

Subscribe-Event -EventName "Confirm.Request" -Handler { param($EventData) $params = $EventData.Data; Show-ConfirmDialog @params }

Subscribe-Event -EventName "Alert.Show" -Handler { param($EventData) $params = $EventData.Data; Show-AlertDialog @params }

Subscribe-Event -EventName "Input.Request" -Handler { param($EventData) $params = $EventData.Data; Show-InputDialog @params }

Write-Log -Level Info -Message "Class-based Dialog System initialized"

}

}



function Show-AlertDialog { param([string]$Title="Alert", [string]$Message); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock { ([AlertDialog]::new($Title, $Message)).Show() } }

function Show-ConfirmDialog { param([string]$Title="Confirm", [string]$Message, [scriptblock]$OnConfirm, [scriptblock]$OnCancel={}); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock { ([ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)).Show() } }

function Show-InputDialog { param([string]$Title="Input", [string]$Prompt, [string]$DefaultValue="", [scriptblock]$OnSubmit, [scriptblock]$OnCancel={}); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock { $d = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel); if ($DefaultValue) { $d.SetDefaultValue($DefaultValue) }; $d.Show() } }

function Show-ProgressDialog { param([string]$Title="Progress", [string]$Message="Processing...", [int]$PercentComplete=0, [switch]$ShowCancel); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock { $d = [ProgressDialog]::new($Title, $Message); $d.PercentComplete = $PercentComplete; $d.ShowCancel = $ShowCancel; $d.Show(); return $d } }

function Show-ListDialog { param([string]$Title="Select Item", [string]$Prompt="Choose an item:", [string[]]$Items, [scriptblock]$OnSelect, [scriptblock]$OnCancel={}, [switch]$AllowMultiple); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock { $d = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel); $d.AllowMultiple = $AllowMultiple; $d.Show() } }

function Close-TuiDialog { Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock { Close-TopTuiOverlay } }



# --- END OF FULL REPLACEMENT for modules\dialog-system-class\dialog-system-class.psm1 ---
# --- END OF ORIGINAL FILE: modules\dialog-system-class\dialog-system-class.psm1 ---

# --- START OF ORIGINAL FILE: screens\dashboard-screen\dashboard-screen.psm1 ---
# ==============================================================================

# PMC Terminal v5 - NCurses Dashboard Screen

# Main entry screen with buffer-based rendering

# CORRECTED (v3): Fixed variable scoping in menu actions and implemented proper

#                 component focus management for navigation.

#

# ARCHITECTURAL NOTE:

# This class is a "Screen" and acts as a top-level container. It does not

# perform any rendering itself. Instead, it orchestrates child "Panel"

# components, which are responsible for their own rendering. The TUI Engine

# composites the final view from the buffers of these child components.

# ==============================================================================

class DashboardScreen : Screen {

# --- Core Architecture ---

[Panel] $MainPanel

[Panel] $SummaryPanel

[Panel] $MenuPanel

[Panel] $StatusPanel

[NavigationMenu] $MainMenu

[System.Collections.Generic.List[UIElement]] $Components



# --- State Management ---

[object[]] $Tasks = @()

[int] $TotalTasks = 0

[int] $CompletedTasks = 0

[int] $PendingTasks = 0



# --- Constructor ---

DashboardScreen([hashtable]$services) : base("DashboardScreen", $services) {

$this.Name = "DashboardScreen"

$this.Components = [System.Collections.Generic.List[UIElement]]::new()

$this.IsFocusable = $true

$this.Enabled = $true

$this.Visible = $true

$this.Tasks = @()



Write-Log -Level Info -Message "Creating DashboardScreen with NCurses architecture"

}



# --- Initialization ---

[void] Initialize() {

Invoke-WithErrorHandling -Component "DashboardScreen" -Context "Initialize" -ScriptBlock {

$this.Width = $global:TuiState.BufferWidth

$this.Height = $global:TuiState.BufferHeight



if ($null -ne $this.{_private_buffer}) {

$this.{_private_buffer}.Resize($this.Width, $this.Height)

}



$this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "PMC Terminal v5 - Dashboard")

$this.MainPanel.HasBorder = $true

$this.MainPanel.BorderStyle = "Double"

$this.MainPanel.BorderColor = [ConsoleColor]::Cyan

$this.MainPanel.BackgroundColor = [ConsoleColor]::Black

$this.MainPanel.TitleColor = [ConsoleColor]::White

$this.MainPanel.Name = "MainDashboardPanel"

$this.AddChild($this.MainPanel)



$summaryWidth = [Math]::Floor($this.Width * 0.4)

$this.SummaryPanel = [Panel]::new(2, 2, $summaryWidth, 12, "Task Summary")

$this.SummaryPanel.HasBorder = $true

$this.SummaryPanel.BorderStyle = "Single"

$this.SummaryPanel.BorderColor = [ConsoleColor]::Green

$this.SummaryPanel.BackgroundColor = [ConsoleColor]::Black

$this.SummaryPanel.Name = "SummaryPanel"

$this.MainPanel.AddChild($this.SummaryPanel)



$menuX = $summaryWidth + 4

$menuWidth = $this.Width - $menuX - 2

$this.MenuPanel = [Panel]::new($menuX, 2, $menuWidth, 15, "Main Menu")

$this.MenuPanel.HasBorder = $true

$this.MenuPanel.BorderStyle = "Single"

$this.MenuPanel.BorderColor = [ConsoleColor]::Yellow

$this.MenuPanel.BackgroundColor = [ConsoleColor]::Black

$this.MenuPanel.Name = "MenuPanel"

$this.MainPanel.AddChild($this.MenuPanel)



$this.StatusPanel = [Panel]::new(2, 19, $this.Width - 4, $this.Height - 21, "System Status")

$this.StatusPanel.HasBorder = $true

$this.StatusPanel.BorderStyle = "Single"

$this.StatusPanel.BorderColor = [ConsoleColor]::Magenta

$this.StatusPanel.BackgroundColor = [ConsoleColor]::Black

$this.StatusPanel.Name = "StatusPanel"

$this.MainPanel.AddChild($this.StatusPanel)



$this.MainMenu = [NavigationMenu]::new("MainMenu")

$this.MainMenu.Move(0, 0)

$this.MainMenu.Resize($this.MenuPanel.ContentWidth, $this.MenuPanel.ContentHeight)

$this.BuildMainMenu()

$this.MenuPanel.AddChild($this.MainMenu)



$this.RefreshData()

$this.UpdateDisplay()



$this.RequestRedraw()

$this.Render()



Write-Log -Level Info -Message "DashboardScreen initialized with NCurses architecture"

}

}



# --- Menu Building ---

hidden [void] BuildMainMenu() {

try {

# Capture the screen instance ($this) into a local variable. The scriptblocks

# below will form a closure over this variable, giving them access to the screen's services.

$screen_this = $this



$this.MainMenu.AddItem([NavigationItem]::new("1", "Task Management", {

$screen_this.Services.Navigation.GoTo("/tasks", @{})

}))

$this.MainMenu.AddItem([NavigationItem]::new("2", "Project Management", {

# This action is not yet implemented, so we'll show a dialog.

Show-AlertDialog -Title "Not Implemented" -Message "Project Management screen is coming soon!"

}))

$this.MainMenu.AddItem([NavigationItem]::new("3", "Settings", {

# This action is not yet implemented, so we'll show a dialog.

Show-AlertDialog -Title "Not Implemented" -Message "Settings screen is coming soon!"

}))

$this.MainMenu.AddSeparator()

$this.MainMenu.AddItem([NavigationItem]::new("Q", "Quit Application", {

$screen_this.Services.Navigation.RequestExit()

}))



Write-Log -Level Debug -Message "Main menu built with $($this.MainMenu.Items.Count) items"

} catch {

Write-Log -Level Error -Message "Failed to build main menu: $_"

}

}



# --- Data Management ---

hidden [void] RefreshData() {

Invoke-WithErrorHandling -Component "DashboardScreen" -Context "RefreshData" -ScriptBlock {

$this.Tasks = @()

$this.TotalTasks = 0

$this.CompletedTasks = 0

$this.PendingTasks = 0



if ($null -eq $this.Services.DataManager) {

Write-Log -Level Warning -Message "DataManager service not available"

return

}



try {

$this.Tasks = @($this.Services.DataManager.GetTasks())

$this.TotalTasks = $this.Tasks.Count



if ($this.TotalTasks -gt 0) {

$completedTasks = @($this.Tasks | Where-Object { $_.Status -eq [TaskStatus]::Completed })

$this.CompletedTasks = $completedTasks.Count

$this.PendingTasks = $this.TotalTasks - $this.CompletedTasks

}



Write-Log -Level Debug -Message "Dashboard data refreshed - $($this.TotalTasks) tasks loaded"

} catch {

Write-Log -Level Warning -Message "Failed to load tasks: $_"

$this.Tasks = @()

}

}

}



hidden [void] UpdateDisplay() {

Invoke-WithErrorHandling -Component "DashboardScreen" -Context "UpdateDisplay" -ScriptBlock {

$this.UpdateSummaryPanel()

$this.SummaryPanel.RequestRedraw()



$this.UpdateStatusPanel()

$this.StatusPanel.RequestRedraw()



$this.MenuPanel.RequestRedraw()



$this.RequestRedraw()

}

}



hidden [void] UpdateSummaryPanel() {

if ($null -eq $this.SummaryPanel) { return }



$this.ClearPanelContent($this.SummaryPanel)



$summaryLines = @(

"Task Overview",

"═══════════════",

"",

"Total Tasks:    $($this.TotalTasks)",

"Completed:      $($this.CompletedTasks)",

"Pending:        $($this.PendingTasks)",

"",

"Progress: $($this.GetProgressBar())",

"",

"Use number keys or",

"arrow keys + Enter"

)



for ($i = 0; $i -lt $summaryLines.Count; $i++) {

$color = if ($i -eq 0) { [ConsoleColor]::White } elseif ($i -eq 1) { [ConsoleColor]::Gray } else { [ConsoleColor]::Cyan }

$this.WriteTextToPanel($this.SummaryPanel, $summaryLines[$i], 1, $i, $color)

}



$this.SummaryPanel.RequestRedraw()

}



hidden [void] UpdateStatusPanel() {

if ($null -eq $this.StatusPanel) { return }



$this.ClearPanelContent($this.StatusPanel)



$statusLines = @(

"System Information",

"════════════════════",

"",

"PowerShell Version: $($global:PSVersionTable.PSVersion)",

"Platform:           $($global:PSVersionTable.Platform)",

"Memory Usage:       $($this.GetMemoryUsage())",

"Current Time:       $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"

)



for ($i = 0; $i -lt $statusLines.Count; $i++) {

$color = if ($i -eq 0) { [ConsoleColor]::White } elseif ($i -eq 1) { [ConsoleColor]::Gray } else { [ConsoleColor]::Green }

$this.WriteTextToPanel($this.StatusPanel, $statusLines[$i], 1, $i, $color)

}



$this.StatusPanel.RequestRedraw()

}



# --- Helper Methods ---

hidden [string] GetProgressBar() {

if ($this.TotalTasks -eq 0) { return "No tasks" }



$percentage = [Math]::Round(($this.CompletedTasks / $this.TotalTasks) * 100)

$barLength = 20

$filledLength = [Math]::Round(($percentage / 100) * $barLength)

$bar = "█" * $filledLength + "░" * ($barLength - $filledLength)

return "$bar $percentage%"

}



hidden [string] GetMemoryUsage() {

try {

$process = Get-Process -Id $global:PID

$memoryMB = [Math]::Round($process.WorkingSet64 / 1MB, 2)

return "$memoryMB MB"

} catch {

return "Unknown"

}

}



hidden [void] ClearPanelContent([Panel]$panel) {

if ($null -eq $panel -or $null -eq $panel.{_private_buffer}) { return }



$clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $panel.BackgroundColor)

for ($y = $panel.ContentY; $y -lt ($panel.ContentY + $panel.ContentHeight); $y++) {

for ($x = $panel.ContentX; $x -lt ($panel.ContentX + $panel.ContentWidth); $x++) {

$panel.{_private_buffer}.SetCell($x, $y, $clearCell)

}

}

}



hidden [void] WriteTextToPanel([Panel]$panel, [string]$text, [int]$x, [int]$y, [ConsoleColor]$color) {

if ($null -eq $panel -or $null -eq $panel.{_private_buffer}) { return }

if ($y -ge $panel.ContentHeight) { return }



$chars = $text.ToCharArray()

for ($i = 0; $i -lt $chars.Length -and ($x + $i) -lt $panel.ContentWidth; $i++) {

$cell = [TuiCell]::new($chars[$i], $color, $panel.BackgroundColor)

$panel.{_private_buffer}.SetCell($panel.ContentX + $x + $i, $panel.ContentY + $y, $cell)

}

}



# --- Input Handling ---

[bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {

# This handler is now simplified. The TUI engine will automatically

# route arrow keys/enter to the focused component (the MainMenu).

# This handler only needs to process screen-specific shortcuts.

$self = $this

Invoke-WithErrorHandling -Component "DashboardScreen" -Context "HandleInput" -ScriptBlock {

$keyChar = $keyInfo.KeyChar.ToString().ToUpper()



# Screen-level shortcuts for convenience

if ($keyChar -match '^[123Q]$') {

$self.MainMenu.ExecuteAction($keyChar)

return $true

}



switch ($keyInfo.Key) {

([ConsoleKey]::Escape) {

$self.Services.Navigation.RequestExit()

return $true

}

([ConsoleKey]::F5) {

$self.RefreshData()

$self.UpdateDisplay()

return $true

}

}

}

# Return $false because this screen-level handler did not consume the key.

# This allows the TUI engine to know the key is available for other layers if needed.

return $false

}



# --- Lifecycle Methods ---

[void] OnEnter() {

$this.RefreshData()

$this.UpdateDisplay()



# Set the initial focus to the MainMenu. This is critical for

# allowing the menu to receive and handle arrow key/enter input.

Set-ComponentFocus -Component $this.MainMenu

}



[void] OnExit() { }



[void] OnDeactivate() {

$this.Cleanup()

}



[void] Cleanup() {

$this.Components.Clear()

$this.Children.Clear()

}

}



# --- END OF ORIGINAL FILE for screens\dashboard-screen\dashboard-screen.psm1 ---
# --- END OF ORIGINAL FILE: screens\dashboard-screen\dashboard-screen.psm1 ---

# --- START OF ORIGINAL FILE: screens\task-list-screen\task-list-screen.psm1 ---
# ==============================================================================

# PMC Terminal v5 - NCurses Task List Screen

# Displays and manages tasks with buffer-based rendering

# CORRECTED (v2): Fixed $this scoping issue in scriptblocks for dialogs/input.

#

# ARCHITECTURAL NOTE:

# This class is a "Screen" and acts as a top-level container. It does not

# perform any rendering itself. Instead, it orchestrates child "Panel"

# components, which are responsible for their own rendering. The TUI Engine

# composites the final view from the buffers of these child components.

# ==============================================================================

class TaskListScreen : Screen {

# --- Core Architecture ---

[Panel] $MainPanel

[Panel] $HeaderPanel

[Panel] $TablePanel

[Panel] $FooterPanel

[Table] $TaskTable

[System.Collections.Generic.List[UIElement]] $Components



# --- State Management ---

[string] $FilterStatus = "All"

[object[]] $AllTasks = @()

[System.Collections.ArrayList] $FilteredTasks = [System.Collections.ArrayList]::new()

[int] $SelectedIndex = 0



# --- Constructor ---

TaskListScreen([hashtable]$services) : base("TaskListScreen", $services) {

$this.Name = "TaskListScreen"

$this.Components = [System.Collections.Generic.List[UIElement]]::new()

$this.IsFocusable = $true

$this.Enabled = $true

$this.Visible = $true

}



# --- Initialization ---

[void] Initialize() {

Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {

$this.Width = $global:TuiState.BufferWidth

$this.Height = $global:TuiState.BufferHeight



if ($null -ne $this.{_private_buffer}) {

$this.{_private_buffer}.Resize($this.Width, $this.Height)

}



$this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "Task List")

$this.MainPanel.HasBorder = $true

$this.MainPanel.BorderStyle = "Double"

$this.MainPanel.BorderColor = [ConsoleColor]::Gray

$this.MainPanel.BackgroundColor = [ConsoleColor]::Black

$this.MainPanel.Name = "MainTaskPanel"

$this.AddChild($this.MainPanel)



$this.HeaderPanel = [Panel]::new(1, 1, $this.Width - 2, 3, "")

$this.HeaderPanel.HasBorder = $false

$this.HeaderPanel.BackgroundColor = [ConsoleColor]::Black

$this.HeaderPanel.Name = "HeaderPanel"

$this.MainPanel.AddChild($this.HeaderPanel)



$this.TablePanel = [Panel]::new(1, 4, $this.Width - 2, $this.Height - 8, "")

$this.TablePanel.HasBorder = $true

$this.TablePanel.BorderStyle = "Single"

$this.TablePanel.BorderColor = [ConsoleColor]::DarkGray

$this.TablePanel.BackgroundColor = [ConsoleColor]::Black

$this.TablePanel.Name = "TablePanel"

$this.MainPanel.AddChild($this.TablePanel)



$this.FooterPanel = [Panel]::new(1, $this.Height - 4, $this.Width - 2, 3, "")

$this.FooterPanel.HasBorder = $false

$this.FooterPanel.BackgroundColor = [ConsoleColor]::Black

$this.FooterPanel.Name = "FooterPanel"

$this.MainPanel.AddChild($this.FooterPanel)



$this.TaskTable = [Table]::new("TaskTable")

$this.TaskTable.Move(0, 0)

$this.TaskTable.Resize($this.TablePanel.ContentWidth, $this.TablePanel.ContentHeight)

$this.TaskTable.ShowBorder = $false



$columns = @(

[TableColumn]::new('Title', 'Task Title', 50),

[TableColumn]::new('Status', 'Status', 15),

[TableColumn]::new('Priority', 'Priority', 12),

[TableColumn]::new('DueDate', 'Due Date', 15)

)

$this.TaskTable.SetColumns($columns)



$this.TablePanel.AddChild($this.TaskTable)



$this.RefreshData()

$this.UpdateDisplay()



$this.RequestRedraw()

$this.Render()

}

}



# --- Data Management ---

hidden [void] RefreshData() {

Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {

try {

$this.AllTasks = @($this.Services.DataManager.GetTasks())

if ($null -eq $this.AllTasks) { $this.AllTasks = @() }

} catch {

Write-Log -Level Warning -Message "Failed to load tasks: $_"

$this.AllTasks = @()

}



$filterResult = switch ($this.FilterStatus) {

"Active" { $this.AllTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed } }

"Completed" { $this.AllTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed } }

default { $this.AllTasks }

}



$this.FilteredTasks = [System.Collections.ArrayList]::new()

if ($null -ne $filterResult) {

if ($filterResult -is [array]) {

foreach ($item in $filterResult) { $this.FilteredTasks.Add($item) | Out-Null }

} else {

$this.FilteredTasks.Add($filterResult) | Out-Null

}

}



$this.TaskTable.SetData($this.FilteredTasks)



if ($null -ne $this.FilteredTasks -and $this.SelectedIndex -ge $this.FilteredTasks.Count) {

$this.SelectedIndex = [Math]::Max(0, $this.FilteredTasks.Count - 1)

}



$this.RequestRedraw()

}

}



hidden [void] UpdateDisplay() {

Invoke-WithErrorHandling -Component "TaskListScreen" -Context "UpdateDisplay" -ScriptBlock {

$taskCount = if ($null -ne $this.FilteredTasks) { $this.FilteredTasks.Count } else { 0 }

$headerText = "Filter: $($this.FilterStatus) | Total: $taskCount tasks"

$this.WriteTextToPanel($this.HeaderPanel, $headerText, 0, 0, [ConsoleColor]::White)

$this.HeaderPanel.RequestRedraw()



$footerText = "[↑↓]Navigate [Space]Toggle [N]ew [E]dit [D]elete [F]ilter [Esc]Back"

$this.WriteTextToPanel($this.FooterPanel, $footerText, 0, 0, [ConsoleColor]::Yellow)

$this.FooterPanel.RequestRedraw()



$this.TaskTable.SelectedIndex = $this.SelectedIndex



$this.RequestRedraw()

}

}



# --- Helper Methods ---

hidden [void] WriteTextToPanel([Panel]$panel, [string]$text, [int]$x, [int]$y, [ConsoleColor]$color) {

if ($null -eq $panel -or $null -eq $panel.{_private_buffer}) { return }

$chars = $text.ToCharArray()

for ($i = 0; $i -lt $chars.Length -and ($x + $i) -lt $panel.ContentWidth; $i++) {

$cell = [TuiCell]::new($chars[$i], $color, $panel.BackgroundColor)

$panel.{_private_buffer}.SetCell($panel.ContentX + $x + $i, $panel.ContentY + $y, $cell)

}

}



# --- Input Handling ---

[bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {

# Capture the screen instance ($this) into a local variable so the

# scriptblock passed to Invoke-WithErrorHandling can access it.

$self = $this

Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {

switch ($keyInfo.Key) {

([ConsoleKey]::UpArrow) {

if ($self.SelectedIndex -gt 0) {

$self.SelectedIndex--

$self.UpdateDisplay()

return $true

}

}

([ConsoleKey]::DownArrow) {

if ($self.SelectedIndex -lt ($self.FilteredTasks.Count - 1) -and $self.FilteredTasks.Count -gt 0) {

$self.SelectedIndex++

$self.UpdateDisplay()

return $true

}

}

([ConsoleKey]::Spacebar) {

$self.ToggleSelectedTask()

return $true

}

([ConsoleKey]::Escape) {

$self.NavigateBack()

return $true

}

default {

$keyChar = $keyInfo.KeyChar.ToString().ToUpper()

switch ($keyChar) {

'N' { $self.ShowNewTaskDialog(); return $true }

'E' { $self.EditSelectedTask(); return $true }

'D' { $self.DeleteSelectedTask(); return $true }

'F' { $self.CycleFilter(); return $true }

}

}

}

}

return $false

}



# --- Task Actions ---

hidden [void] ToggleSelectedTask() {

if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) { return }

$task = $this.FilteredTasks[$this.SelectedIndex]

if ($null -eq $task) { return }

$newCompletedStatus = $task.Status -ne [TaskStatus]::Completed

$this.Services.DataManager.UpdateTask(@{ Task = $task; Completed = $newCompletedStatus })

$this.RefreshData()

$this.UpdateDisplay()

}



hidden [void] ShowNewTaskDialog() {

# Capture necessary context for the dialog's callback scriptblock.

$dataManager = $this.Services.DataManager

$screen = $this

Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {

param($Value)

if (-not [string]::IsNullOrWhiteSpace($Value)) {

$dataManager.AddTask($Value, "", "medium", "General")

$screen.RefreshData()

$screen.UpdateDisplay()

}

}

}



hidden [void] EditSelectedTask() {

if ($null -eq $this.FilteredTasks -or $this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) { return }

$task = $this.FilteredTasks[$this.SelectedIndex]

if ($null -eq $task) { return }

# Capture necessary context for the dialog's callback scriptblock.

$dataManager = $this.Services.DataManager

$screen = $this

Show-InputDialog -Title "Edit Task" -Prompt "New title:" -DefaultValue $task.Title -OnSubmit {

param($Value)

if (-not [string]::IsNullOrWhiteSpace($Value)) {

$dataManager.UpdateTask(@{ Task = $task; Title = $Value })

$screen.RefreshData()

$screen.UpdateDisplay()

}

}

}



hidden [void] DeleteSelectedTask() {

if ($null -eq $this.FilteredTasks -or $this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) { return }

$task = $this.FilteredTasks[$this.SelectedIndex]

if ($null -eq $task) { return }

# Capture necessary context for the dialog's callback scriptblock.

$dataManager = $this.Services.DataManager

$screen = $this

Show-ConfirmDialog -Title "Delete Task" -Message "Are you sure you want to delete `"$($task.Title)`"?" -OnConfirm {

$dataManager.RemoveTask($task)

$screen.RefreshData()

$screen.UpdateDisplay()

}

}



hidden [void] CycleFilter() {

$this.FilterStatus = switch ($this.FilterStatus) {

"All" { "Active" }

"Active" { "Completed" }

default { "All" }

}

$this.RefreshData()

$this.UpdateDisplay()

}



hidden [void] NavigateBack() {

$this.Services.Navigation.PopScreen()

}



# --- Lifecycle Methods ---

[void] OnEnter() {

$this.RefreshData()

$this.UpdateDisplay()

}



[void] OnExit() { }



[void] Cleanup() {

$this.Components.Clear()

$this.Children.Clear()

}

}



# --- END OF ORIGINAL FILE for screens\task-list-screen\task-list-screen.psm1 ---
# --- END OF ORIGINAL FILE: screens\task-list-screen\task-list-screen.psm1 ---

# --- START OF ORIGINAL FILE: services\navigation-service-class\navigation-service-class.psm1 ---
# ==============================================================================
# Navigation Service v3.2 - Screen Routing and Management
# ==============================================================================

class NavigationService {
    hidden [System.Collections.Generic.Stack[Screen]] $_screenStack
    hidden [hashtable] $_routes = @{}
    hidden [Screen] $_currentScreen = $null
    hidden [TuiEngine] $_engine = $null
    hidden [DataManager] $_dataManager = $null
    hidden [ThemeEngine] $_themeEngine = $null
    
    NavigationService() {
        $this._screenStack = [System.Collections.Generic.Stack[Screen]]::new()
        Write-Log -Level Info -Message "NavigationService initialized"
    }
    
    [void] InjectDependencies([TuiEngine]$engine, [DataManager]$dataManager, [ThemeEngine]$themeEngine) {
        $this._engine = $engine
        $this._dataManager = $dataManager
        $this._themeEngine = $themeEngine
        Write-Log -Level Info -Message "Dependencies injected into NavigationService"
    }
    
    [void] RegisterRoute([string]$route, [type]$screenType) {
        if ([string]::IsNullOrEmpty($route)) {
            throw [System.ArgumentException]::new("Route cannot be empty")
        }
        
        if (-not $screenType.IsSubclassOf([Screen])) {
            throw [System.ArgumentException]::new("Screen type must inherit from Screen class")
        }
        
        $this._routes[$route] = $screenType
        Write-Log -Level Info -Message "Registered route '$route' -> $($screenType.Name)"
    }
    
    [void] NavigateTo([string]$route) {
        NavigateTo($route, @{})
    }
    
    [void] NavigateTo([string]$route, [hashtable]$parameters) {
        if (-not $this._routes.ContainsKey($route)) {
            throw [System.InvalidOperationException]::new("Route '$route' not registered")
        }
        
        try {
            # Deactivate current screen
            if ($null -ne $this._currentScreen) {
                $this._currentScreen.OnScreenDeactivated()
                $this._currentScreen.Dispose()
            }
            
            # Create new screen instance
            $screenType = $this._routes[$route]
            $newScreen = $screenType::new()
            $newScreen.Route = $route
            
            # Inject services
            $newScreen.InjectServices($this, $this._dataManager, $this._themeEngine)
            
            # Initialize screen with engine dimensions
            if ($null -ne $this._engine) {
                $newScreen.Width = $this._engine.ScreenWidth
                $newScreen.Height = $this._engine.ScreenHeight
            }
            
            $newScreen.Initialize()
            
            # Push to stack and activate
            $this._screenStack.Push($newScreen)
            $this._currentScreen = $newScreen
            $this._currentScreen.OnScreenActivated()
            
            # Update engine's current screen
            if ($null -ne $this._engine) {
                $this._engine.SetCurrentScreen($newScreen)
            }
            
            Write-Log -Level Info -Message "Navigated to route: $route"
            Publish-Event -EventName "Navigation.Changed" -Data @{Route=$route;Screen=$newScreen}
            
        } catch {
            Write-Log -Level Error -Message "Failed to navigate to route '$route': $_"
            throw
        }
    }
    
    [void] GoBack() {
        if ($this._screenStack.Count -le 1) {
            Write-Log -Level Warning -Message "Cannot go back - no previous screen"
            return
        }
        
        try {
            # Remove current screen
            $oldScreen = $this._screenStack.Pop()
            $oldScreen.OnScreenDeactivated()
            $oldScreen.Dispose()
            
            # Activate previous screen
            $this._currentScreen = $this._screenStack.Peek()
            $this._currentScreen.OnScreenActivated()
            
            # Update engine
            if ($null -ne $this._engine) {
                $this._engine.SetCurrentScreen($this._currentScreen)
            }
            
            Write-Log -Level Info -Message "Navigated back to: $($this._currentScreen.Route)"
            Publish-Event -EventName "Navigation.Back" -Data @{Screen=$this._currentScreen}
            
        } catch {
            Write-Log -Level Error -Message "Failed to go back: $_"
            throw
        }
    }
    
    [Screen] GetCurrentScreen() {
        return $this._currentScreen
    }
    
    [string] GetCurrentRoute() {
        return if ($null -ne $this._currentScreen) { $this._currentScreen.Route } else { $null }
    }
    
    [bool] CanGoBack() {
        return $this._screenStack.Count -gt 1
    }
    
    [void] ClearHistory() {
        while ($this._screenStack.Count -gt 1) {
            $screen = $this._screenStack.Pop()
            $screen.Dispose()
        }
        Write-Log -Level Info -Message "Navigation history cleared"
    }
}

# Screen Registry for easier management
class ScreenRegistry {
    hidden static [hashtable] $_registry = @{}
    
    static [void] Register([string]$name, [type]$screenType) {
        if (-not $screenType.IsSubclassOf([Screen])) {
            throw [System.ArgumentException]::new("Type must inherit from Screen")
        }
        [ScreenRegistry]::_registry[$name] = $screenType
        Write-Log -Level Info -Message "Registered screen: $name"
    }
    
    static [type] Get([string]$name) {
        if (-not [ScreenRegistry]::_registry.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("Screen '$name' not registered")
        }
        return [ScreenRegistry]::_registry[$name]
    }
    
    static [string[]] GetRegisteredScreens() {
        return [ScreenRegistry]::_registry.Keys
    }
    
    static [void] Clear() {
        [ScreenRegistry]::_registry.Clear()
    }
}
# --- END OF ORIGINAL FILE: services\navigation-service-class\navigation-service-class.psm1 ---

# --- START OF ORIGINAL FILE: modules\data-manager\data-manager.psm1 ---
# ==============================================================================
# Data Manager v3.2 - Persistence and State Management
# ==============================================================================

class DataManager {
    hidden [string] $_dataPath
    hidden [hashtable] $_cache = @{
        Tasks = [System.Collections.Generic.List[PmcTask]]::new()
        Projects = [System.Collections.Generic.List[PmcProject]]::new()
    }
    hidden [bool] $_isDirty = $false
    hidden [System.Threading.Timer] $_autoSaveTimer = $null
    
    DataManager() {
        $this._dataPath = Join-Path $env:APPDATA "PMCTerminal\data.json"
        $this.Initialize()
    }
    
    DataManager([string]$dataPath) {
        $this._dataPath = $dataPath
        $this.Initialize()
    }
    
    hidden [void] Initialize() {
        # Ensure directory exists
        $dir = Split-Path $this._dataPath -Parent
        if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
        
        # Load existing data
        $this.Load()
        
        # Setup auto-save timer (every 5 minutes)
        $callback = {
            param($state)
            if ($state._isDirty) {
                $state.Save()
            }
        }
        $this._autoSaveTimer = [System.Threading.Timer]::new($callback, $this, 300000, 300000)
        
        Write-Log -Level Info -Message "DataManager initialized with path: $($this._dataPath)"
    }
    
    [void] Load() {
        try {
            if (Test-Path $this._dataPath) {
                $json = Get-Content $this._dataPath -Raw
                $data = ConvertFrom-Json $json -AsHashtable
                
                # Load projects
                $this._cache.Projects.Clear()
                if ($data.ContainsKey('Projects')) {
                    foreach ($projData in $data.Projects) {
                        $project = [PmcProject]::FromLegacyFormat($projData)
                        $this._cache.Projects.Add($project)
                    }
                }
                
                # Load tasks
                $this._cache.Tasks.Clear()
                if ($data.ContainsKey('Tasks')) {
                    foreach ($taskData in $data.Tasks) {
                        $task = [PmcTask]::FromLegacyFormat($taskData)
                        $this._cache.Tasks.Add($task)
                    }
                }
                
                Write-Log -Level Info -Message "Loaded $($this._cache.Projects.Count) projects and $($this._cache.Tasks.Count) tasks"
            } else {
                # Create default data
                $this.CreateDefaultData()
            }
            
            $this._isDirty = $false
            Publish-Event -EventName "Data.Loaded" -Data @{Projects=$this._cache.Projects;Tasks=$this._cache.Tasks}
            
        } catch {
            Write-Log -Level Error -Message "Failed to load data: $_"
            $this.CreateDefaultData()
        }
    }
    
    [void] Save() {
        try {
            $data = @{
                Projects = $this._cache.Projects | ForEach-Object { $_.ToLegacyFormat() }
                Tasks = $this._cache.Tasks | ForEach-Object { $_.ToLegacyFormat() }
                Metadata = @{
                    Version = "3.2"
                    LastSaved = [datetime]::Now.ToString("o")
                }
            }
            
            $json = ConvertTo-Json $data -Depth 10
            Set-Content -Path $this._dataPath -Value $json -Encoding UTF8
            
            $this._isDirty = $false
            Write-Log -Level Info -Message "Data saved successfully"
            Publish-Event -EventName "Data.Saved" -Data @{Path=$this._dataPath}
            
        } catch {
            Write-Log -Level Error -Message "Failed to save data: $_"
            throw
        }
    }
    
    hidden [void] CreateDefaultData() {
        # Create default project
        $defaultProject = [PmcProject]::new("DEFAULT", "Default Project")
        $defaultProject.Description = "Tasks not assigned to a specific project"
        $this._cache.Projects.Add($defaultProject)
        
        # Create sample task
        $sampleTask = [PmcTask]::new(
            "Welcome to PMC Terminal",
            "This is a sample task. Press Enter to edit or create new tasks.",
            [TaskPriority]::Medium,
            "DEFAULT"
        )
        $this._cache.Tasks.Add($sampleTask)
        
        $this._isDirty = $true
        Write-Log -Level Info -Message "Created default data"
    }
    
    # Project Management
    [PmcProject[]] GetProjects() {
        return $this._cache.Projects.ToArray()
    }
    
    [PmcProject] GetProject([string]$key) {
        return $this._cache.Projects | Where-Object { $_.Key -eq $key } | Select-Object -First 1
    }
    
    [void] AddProject([PmcProject]$project) {
        if ($null -eq $project) { throw [System.ArgumentNullException]::new("project") }
        
        # Check for duplicate key
        if ($this.GetProject($project.Key)) {
            throw [System.InvalidOperationException]::new("Project with key '$($project.Key)' already exists")
        }
        
        $this._cache.Projects.Add($project)
        $this._isDirty = $true
        
        Write-Log -Level Info -Message "Added project: $($project.Name)"
        Publish-Event -EventName "Project.Added" -Data $project
    }
    
    [void] UpdateProject([PmcProject]$project) {
        if ($null -eq $project) { throw [System.ArgumentNullException]::new("project") }
        
        $existing = $this.GetProject($project.Key)
        if ($null -eq $existing) {
            throw [System.InvalidOperationException]::new("Project not found: $($project.Key)")
        }
        
        # Update properties
        $existing.Name = $project.Name
        $existing.Description = $project.Description
        
        $this._isDirty = $true
        Write-Log -Level Info -Message "Updated project: $($project.Name)"
        Publish-Event -EventName "Project.Updated" -Data $project
    }
    
    [void] RemoveProject([string]$key) {
        $project = $this.GetProject($key)
        if ($null -eq $project) { return }
        
        # Check for tasks assigned to this project
        $assignedTasks = $this._cache.Tasks | Where-Object { $_.ProjectKey -eq $key }
        if ($assignedTasks.Count -gt 0) {
            throw [System.InvalidOperationException]::new("Cannot remove project with assigned tasks")
        }
        
        $this._cache.Projects.Remove($project) | Out-Null
        $this._isDirty = $true
        
        Write-Log -Level Info -Message "Removed project: $($project.Name)"
        Publish-Event -EventName "Project.Removed" -Data $project
    }
    
    # Task Management
    [PmcTask[]] GetTasks() {
        return $this._cache.Tasks.ToArray()
    }
    
    [PmcTask[]] GetTasksByProject([string]$projectKey) {
        return $this._cache.Tasks | Where-Object { $_.ProjectKey -eq $projectKey }
    }
    
    [PmcTask[]] GetTasksByStatus([TaskStatus]$status) {
        return $this._cache.Tasks | Where-Object { $_.Status -eq $status }
    }
    
    [PmcTask] GetTask([string]$id) {
        return $this._cache.Tasks | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [void] AddTask([PmcTask]$task) {
        if ($null -eq $task) { throw [System.ArgumentNullException]::new("task") }
        
        # Verify project exists
        if (-not $this.GetProject($task.ProjectKey)) {
            throw [System.InvalidOperationException]::new("Project not found: $($task.ProjectKey)")
        }
        
        $this._cache.Tasks.Add($task)
        $this._isDirty = $true
        
        Write-Log -Level Info -Message "Added task: $($task.Title)"
        Publish-Event -EventName "Task.Added" -Data $task
    }
    
    [void] UpdateTask([PmcTask]$task) {
        if ($null -eq $task) { throw [System.ArgumentNullException]::new("task") }
        
        $existing = $this.GetTask($task.Id)
        if ($null -eq $existing) {
            throw [System.InvalidOperationException]::new("Task not found: $($task.Id)")
        }
        
        # Update properties
        $existing.Title = $task.Title
        $existing.Description = $task.Description
        $existing.Priority = $task.Priority
        $existing.Status = $task.Status
        $existing.ProjectKey = $task.ProjectKey
        $existing.DueDate = $task.DueDate
        $existing.Completed = $task.Completed
        $existing.UpdatedAt = [datetime]::Now
        
        $this._isDirty = $true
        Write-Log -Level Info -Message "Updated task: $($task.Title)"
        Publish-Event -EventName "Task.Updated" -Data $task
    }
    
    [void] RemoveTask([string]$id) {
        $task = $this.GetTask($id)
        if ($null -eq $task) { return }
        
        $this._cache.Tasks.Remove($task) | Out-Null
        $this._isDirty = $true
        
        Write-Log -Level Info -Message "Removed task: $($task.Title)"
        Publish-Event -EventName "Task.Removed" -Data $task
    }
    
    [void] CompleteTask([string]$id) {
        $task = $this.GetTask($id)
        if ($null -eq $task) { return }
        
        $task.Status = [TaskStatus]::Completed
        $task.Completed = $true
        $task.UpdatedAt = [datetime]::Now
        
        $this._isDirty = $true
        Write-Log -Level Info -Message "Completed task: $($task.Title)"
        Publish-Event -EventName "Task.Completed" -Data $task
    }
    
    # Statistics
    [hashtable] GetStatistics() {
        $stats = @{
            TotalTasks = $this._cache.Tasks.Count
            TotalProjects = $this._cache.Projects.Count
            TasksByStatus = @{}
            TasksByPriority = @{}
            TasksByProject = @{}
        }
        
        foreach ($status in [Enum]::GetValues([TaskStatus])) {
            $stats.TasksByStatus[$status.ToString()] = ($this._cache.Tasks | Where-Object { $_.Status -eq $status }).Count
        }
        
        foreach ($priority in [Enum]::GetValues([TaskPriority])) {
            $stats.TasksByPriority[$priority.ToString()] = ($this._cache.Tasks | Where-Object { $_.Priority -eq $priority }).Count
        }
        
        foreach ($project in $this._cache.Projects) {
            $stats.TasksByProject[$project.Key] = ($this._cache.Tasks | Where-Object { $_.ProjectKey -eq $project.Key }).Count
        }
        
        return $stats
    }
    
    [void] Dispose() {
        if ($this._isDirty) {
            $this.Save()
        }
        
        if ($null -ne $this._autoSaveTimer) {
            $this._autoSaveTimer.Dispose()
            $this._autoSaveTimer = $null
        }
        
        Write-Log -Level Info -Message "DataManager disposed"
    }
}
# --- END OF ORIGINAL FILE: modules\data-manager\data-manager.psm1 ---

# --- START OF ORIGINAL FILE: services\keybinding-service\keybinding-service.psm1 ---
# ==============================================================================
# Keybinding Service v3.2 - Global Keyboard Shortcut Management
# ==============================================================================

class KeyBinding {
    [ConsoleKey] $Key
    [ConsoleModifiers] $Modifiers
    [string] $Description
    [scriptblock] $Action
    [string] $Context = "Global"
    [bool] $Enabled = $true
    
    KeyBinding([ConsoleKey]$key, [scriptblock]$action) {
        $this.Key = $key
        $this.Action = $action
        $this.Modifiers = [ConsoleModifiers]::None
    }
    
    KeyBinding([ConsoleKey]$key, [ConsoleModifiers]$modifiers, [scriptblock]$action) {
        $this.Key = $key
        $this.Modifiers = $modifiers
        $this.Action = $action
    }
    
    [bool] Matches([ConsoleKeyInfo]$keyInfo) {
        return $this.Enabled -and 
               $keyInfo.Key -eq $this.Key -and 
               $keyInfo.Modifiers -eq $this.Modifiers
    }
    
    [string] ToString() {
        $parts = @()
        if ($this.Modifiers -band [ConsoleModifiers]::Control) { $parts += "Ctrl" }
        if ($this.Modifiers -band [ConsoleModifiers]::Alt) { $parts += "Alt" }
        if ($this.Modifiers -band [ConsoleModifiers]::Shift) { $parts += "Shift" }
        $parts += $this.Key.ToString()
        return $parts -join "+"
    }
}

class KeybindingService {
    hidden [System.Collections.Generic.List[KeyBinding]] $_bindings
    hidden [hashtable] $_contextStates = @{}
    hidden [string] $_activeContext = "Global"
    
    KeybindingService() {
        $this._bindings = [System.Collections.Generic.List[KeyBinding]]::new()
        $this.RegisterDefaultBindings()
        Write-Log -Level Info -Message "KeybindingService initialized"
    }
    
    hidden [void] RegisterDefaultBindings() {
        # Global navigation
        $this.RegisterKeybinding([ConsoleKey]::Escape, {
            Publish-Event -EventName "Navigation.Back" -Data $null
        }, "Go back", "Global")
        
        $this.RegisterKeybinding([ConsoleKey]::Q, [ConsoleModifiers]::Control, {
            Publish-Event -EventName "Application.Quit" -Data $null
        }, "Quit application", "Global")
        
        $this.RegisterKeybinding([ConsoleKey]::S, [ConsoleModifiers]::Control, {
            Publish-Event -EventName "Data.Save" -Data $null
        }, "Save data", "Global")
        
        $this.RegisterKeybinding([ConsoleKey]::R, [ConsoleModifiers]::Control, {
            Publish-Event -EventName "Screen.Refresh" -Data $null
        }, "Refresh screen", "Global")
        
        # Navigation between components
        $this.RegisterKeybinding([ConsoleKey]::Tab, {
            Publish-Event -EventName "Focus.Next" -Data $null
        }, "Next component", "Global")
        
        $this.RegisterKeybinding([ConsoleKey]::Tab, [ConsoleModifiers]::Shift, {
            Publish-Event -EventName "Focus.Previous" -Data $null
        }, "Previous component", "Global")
        
        # Help
        $this.RegisterKeybinding([ConsoleKey]::F1, {
            Publish-Event -EventName "Help.Show" -Data $null
        }, "Show help", "Global")
        
        Write-Log -Level Info -Message "Registered default keybindings"
    }
    
    [void] RegisterKeybinding([ConsoleKey]$key, [scriptblock]$action, [string]$description) {
        $this.RegisterKeybinding($key, [ConsoleModifiers]::None, $action, $description, "Global")
    }
    
    [void] RegisterKeybinding([ConsoleKey]$key, [scriptblock]$action, [string]$description, [string]$context) {
        $this.RegisterKeybinding($key, [ConsoleModifiers]::None, $action, $description, $context)
    }
    
    [void] RegisterKeybinding([ConsoleKey]$key, [ConsoleModifiers]$modifiers, [scriptblock]$action, [string]$description) {
        $this.RegisterKeybinding($key, $modifiers, $action, $description, "Global")
    }
    
    [void] RegisterKeybinding([ConsoleKey]$key, [ConsoleModifiers]$modifiers, [scriptblock]$action, [string]$description, [string]$context) {
        # Check for existing binding
        $existing = $this._bindings | Where-Object {
            $_.Key -eq $key -and 
            $_.Modifiers -eq $modifiers -and 
            $_.Context -eq $context
        }
        
        if ($existing) {
            # Update existing
            $existing.Action = $action
            $existing.Description = $description
            Write-Log -Level Info -Message "Updated keybinding: $($existing.ToString()) in context '$context'"
        } else {
            # Add new
            $binding = [KeyBinding]::new($key, $modifiers, $action)
            $binding.Description = $description
            $binding.Context = $context
            $this._bindings.Add($binding)
            Write-Log -Level Info -Message "Registered keybinding: $($binding.ToString()) in context '$context'"
        }
    }
    
    [void] UnregisterKeybinding([ConsoleKey]$key) {
        $this.UnregisterKeybinding($key, [ConsoleModifiers]::None, "Global")
    }
    
    [void] UnregisterKeybinding([ConsoleKey]$key, [ConsoleModifiers]$modifiers) {
        $this.UnregisterKeybinding($key, $modifiers, "Global")
    }
    
    [void] UnregisterKeybinding([ConsoleKey]$key, [ConsoleModifiers]$modifiers, [string]$context) {
        $toRemove = $this._bindings | Where-Object {
            $_.Key -eq $key -and 
            $_.Modifiers -eq $modifiers -and 
            $_.Context -eq $context
        }
        
        foreach ($binding in $toRemove) {
            $this._bindings.Remove($binding) | Out-Null
            Write-Log -Level Info -Message "Unregistered keybinding: $($binding.ToString()) from context '$context'"
        }
    }
    
    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {
        # First check context-specific bindings
        $contextBindings = $this._bindings | Where-Object {
            $_.Context -eq $this._activeContext -and $_.Matches($keyInfo)
        }
        
        if ($contextBindings) {
            $binding = $contextBindings | Select-Object -First 1
            try {
                Write-Log -Level Debug -Message "Executing keybinding: $($binding.ToString()) in context '$($this._activeContext)'"
                & $binding.Action
                return $true
            } catch {
                Write-Log -Level Error -Message "Failed to execute keybinding: $_"
            }
        }
        
        # Then check global bindings
        if ($this._activeContext -ne "Global") {
            $globalBindings = $this._bindings | Where-Object {
                $_.Context -eq "Global" -and $_.Matches($keyInfo)
            }
            
            if ($globalBindings) {
                $binding = $globalBindings | Select-Object -First 1
                try {
                    Write-Log -Level Debug -Message "Executing global keybinding: $($binding.ToString())"
                    & $binding.Action
                    return $true
                } catch {
                    Write-Log -Level Error -Message "Failed to execute keybinding: $_"
                }
            }
        }
        
        return $false
    }
    
    [void] SetContext([string]$context) {
        if ([string]::IsNullOrEmpty($context)) { $context = "Global" }
        $this._activeContext = $context
        Write-Log -Level Debug -Message "Keybinding context set to: $context"
        Publish-Event -EventName "Keybinding.ContextChanged" -Data @{Context=$context}
    }
    
    [string] GetContext() {
        return $this._activeContext
    }
    
    [void] EnableContext([string]$context) {
        $this._contextStates[$context] = $true
        Write-Log -Level Debug -Message "Enabled keybinding context: $context"
    }
    
    [void] DisableContext([string]$context) {
        $this._contextStates[$context] = $false
        Write-Log -Level Debug -Message "Disabled keybinding context: $context"
    }
    
    [bool] IsContextEnabled([string]$context) {
        if (-not $this._contextStates.ContainsKey($context)) {
            return $true  # Contexts are enabled by default
        }
        return $this._contextStates[$context]
    }
    
    [KeyBinding[]] GetKeybindings() {
        return $this._bindings.ToArray()
    }
    
    [KeyBinding[]] GetKeybindingsByContext([string]$context) {
        return $this._bindings | Where-Object { $_.Context -eq $context }
    }
    
    [hashtable[]] GetKeybindingHelp() {
        $help = @()
        
        # Group by context
        $contexts = $this._bindings | Group-Object -Property Context
        
        foreach ($contextGroup in $contexts) {
            foreach ($binding in $contextGroup.Group) {
                if ($binding.Enabled) {
                    $help += @{
                        Key = $binding.ToString()
                        Description = $binding.Description
                        Context = $binding.Context
                    }
                }
            }
        }
        
        return $help | Sort-Object Context, Key
    }
    
    [void] EnableKeybinding([ConsoleKey]$key, [ConsoleModifiers]$modifiers, [string]$context) {
        $binding = $this._bindings | Where-Object {
            $_.Key -eq $key -and 
            $_.Modifiers -eq $modifiers -and 
            $_.Context -eq $context
        } | Select-Object -First 1
        
        if ($binding) {
            $binding.Enabled = $true
        }
    }
    
    [void] DisableKeybinding([ConsoleKey]$key, [ConsoleModifiers]$modifiers, [string]$context) {
        $binding = $this._bindings | Where-Object {
            $_.Key -eq $key -and 
            $_.Modifiers -eq $modifiers -and 
            $_.Context -eq $context
        } | Select-Object -First 1
        
        if ($binding) {
            $binding.Enabled = $false
        }
    }
}
# --- END OF ORIGINAL FILE: services\keybinding-service\keybinding-service.psm1 ---

# --- START OF ORIGINAL FILE: services\navigation-service\navigation-service.psm1 ---
# navigation-service-functions.psm1

# Contains only the factory function for the NavigationService.







function Initialize-NavigationService {

param([hashtable]$Services)

if (-not $Services) { throw [System.ArgumentNullException]::new("Services") }

return [NavigationService]::new($Services)

}
# --- END OF ORIGINAL FILE: services\navigation-service\navigation-service.psm1 ---

# --- START OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---
# TUI Engine v5.2 - Pure Compositor Edition

# Implements a pure NCurses-style compositor loop. The engine's core responsibilities

# are: running the main application loop, processing the input queue, and orchestrating

# the compositor pipeline (Screen -> Overlays -> Console). All rendering is handled

# via TuiBuffer objects, ensuring a flicker-free, layered UI.



#region Core TUI State

$global:TuiState = @{

Running         = $false

BufferWidth     = 0

BufferHeight    = 0

CompositorBuffer = $null    # The master compositor buffer (TuiBuffer) that gets drawn to the console.

PreviousCompositorBuffer = $null # A copy of the last frame's compositor buffer, used for optimized diff-rendering.

ScreenStack     = [System.Collections.Stack]::new()

CurrentScreen   = $null

OverlayStack    = [System.Collections.Generic.List[UIElement]]::new() # A list to hold modal elements like dialogs.

IsDirty         = $true

RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }

Components      = @()

Layouts         = @{}

FocusedComponent = $null

InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()

InputRunspace   = $null

InputPowerShell = $null

InputAsyncResult = $null

CancellationTokenSource = $null

EventHandlers   = @{}

}

#endregion



#region Engine Lifecycle & Main Loop



function Initialize-TuiEngine {

param(

[int]$Width = [Console]::WindowWidth,

[int]$Height = [Console]::WindowHeight - 1

)

Write-Log -Level Info -Message "Initializing TUI Engine v5.2 (Pure Compositor): ${Width}x${Height}"

try {

if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }



$global:TuiState.BufferWidth = $Width

$global:TuiState.BufferHeight = $Height



$global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")

$global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new($Width, $Height, "PreviousCompositor")



[Console]::CursorVisible = $false

[Console]::Clear()



$global:TuiState.EventHandlers = @{}

[Console]::TreatControlCAsInput = $false



Subscribe-Event -EventName "TUI.RefreshRequested" -Handler {

Request-TuiRefresh

} -Source "TuiEngine"



Initialize-InputThread



Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }

Write-Log -Level Info -Message "TUI Engine v5.2 initialized successfully"

}

catch {

Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red

$_.Exception | Format-List * -Force

throw "TUI Engine initialization failed."

}

}



function Initialize-InputThread {

$global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()

$token = $global:TuiState.CancellationTokenSource.Token



$runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()

$runspace.Open()

$runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)

$runspace.SessionStateProxy.SetVariable('token', $token)



$ps = [System.Management.Automation.PowerShell]::Create()

$ps.Runspace = $runspace



$ps.AddScript({

try {

while (-not $token.IsCancellationRequested) {

if ([Console]::KeyAvailable) {

if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }

} else {

Start-Sleep -Milliseconds 20

}

}

}

catch [System.Management.Automation.PipelineStoppedException] { return }

catch { Write-Warning "Input thread error: $_" }

}) | Out-Null



$global:TuiState.InputRunspace = $runspace

$global:TuiState.InputPowerShell = $ps

$global:TuiState.InputAsyncResult = $ps.BeginInvoke()

}



function Process-TuiInput {

$processedAny = $false

$keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)

while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {

$processedAny = $true

try {

Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }

} catch {

Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_

Request-TuiRefresh

}

}

return $processedAny

}



function Process-SingleKeyInput {

param($keyInfo)



# 1. Give the topmost overlay (e.g., a dialog) exclusive input priority.

if ($global:TuiState.OverlayStack.Count -gt 0) {

$topOverlay = $global:TuiState.OverlayStack[-1]

if ($topOverlay.HandleInput($keyInfo)) {

return # Overlay handled the input, stop processing.

}

}



# 2. If no overlay handled it, check for global tab navigation.

if ($keyInfo.Key -eq [ConsoleKey]::Tab) {

Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)

return

}



# 3. Give the currently focused component a chance to handle the input.

$focusedComponent = Get-FocusedComponent

if ($focusedComponent -and $focusedComponent.HandleInput($keyInfo)) {

return

}



# 4. Finally, let the current screen handle the input.

$currentScreen = $global:TuiState.CurrentScreen

if ($currentScreen) {

try {

$currentScreen.HandleInput($keyInfo)

} catch {

Write-Warning "Screen input handler error: $_"

Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"

}

}

}



function Start-TuiLoop {

param([UIElement]$InitialScreen)

try {

if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }

if ($InitialScreen) { Push-Screen -Screen $InitialScreen }

if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }



$global:TuiState.Running = $true

$frameTime = [System.Diagnostics.Stopwatch]::new()

$targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS



while ($global:TuiState.Running) {

try {

$frameTime.Restart()

$hadInput = Process-TuiInput

if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }

$elapsed = $frameTime.ElapsedMilliseconds

if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }

}

catch [Helios.HeliosException] {

Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context

Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"

$global:TuiState.IsDirty = $true

}

catch {

Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_

Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."

$global:TuiState.Running = $false

}

}

}

finally { Cleanup-TuiEngine }

}



function Render-Frame {

try {

$global:TuiState.RenderStats.FrameCount++



Render-FrameCompositor



# After rendering, copy the current compositor state to the previous state buffer for the next frame's diff.

$global:TuiState.PreviousCompositorBuffer.Clear()

$global:TuiState.PreviousCompositorBuffer.BlendBuffer($global:TuiState.CompositorBuffer, 0, 0)



# Position the cursor out of the way to prevent visual artifacts

[Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)

} catch {

Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_

}

}



function Render-FrameCompositor {

try {

# 1. Clear the master compositor buffer

$clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))

$global:TuiState.CompositorBuffer.Clear($clearCell)



# 2. Render current screen to its private buffer, then composite

if ($global:TuiState.CurrentScreen) {

Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {

$global:TuiState.CurrentScreen.Render()

$screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()

if ($null -ne $screenBuffer) {

$global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)

}

}

}



# 3. Render overlays (e.g., dialogs) on top of the screen

foreach ($overlay in $global:TuiState.OverlayStack) {

Invoke-WithErrorHandling -Component ($overlay.Name ?? "Overlay") -Context "Overlay Render" -ScriptBlock {

$overlay.Render()

$overlayBuffer = $overlay.GetBuffer()

if ($null -ne $overlayBuffer) {

$pos = $overlay.GetAbsolutePosition()

$global:TuiState.CompositorBuffer.BlendBuffer($overlayBuffer, $pos.X, $pos.Y)

}

}

}



# 4. Convert TuiBuffer to console output with optimal diffing

Render-CompositorToConsole



} catch {

Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_

}

}



function Render-CompositorToConsole {

$outputBuilder = [System.Text.StringBuilder]::new(20000)

$currentBuffer = $global:TuiState.CompositorBuffer

$previousBuffer = $global:TuiState.PreviousCompositorBuffer

$lastFG = -1; $lastBG = -1

$forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1



try {

for ($y = 0; $y -lt $currentBuffer.Height; $y++) {

$rowChanged = $false

for ($x = 0; $x -lt $currentBuffer.Width; $x++) {

$newCell = $currentBuffer.GetCell($x, $y)

$oldCell = $previousBuffer.GetCell($x, $y)



if ($forceFullRender -or $newCell.DiffersFrom($oldCell)) {

if (-not $rowChanged) {

[void]$outputBuilder.Append("`e[$($y + 1);1H")

if ($x > 0) { [void]$outputBuilder.Append("`e[$($y + 1);$($x + 1)H") }

$rowChanged = $true

}



if ($newCell.ForegroundColor -ne $lastFG -or $newCell.BackgroundColor -ne $lastBG) {

$fgCode = Get-AnsiColorCode $newCell.ForegroundColor

$bgCode = Get-AnsiColorCode $newCell.BackgroundColor -IsBackground $true

[void]$outputBuilder.Append("`e[${fgCode};${bgCode}m")

$lastFG = $newCell.ForegroundColor

$lastBG = $newCell.BackgroundColor

}

[void]$outputBuilder.Append($newCell.Char)

} elseif ($rowChanged) {

[void]$outputBuilder.Append("`e[$($y + 1);$($x + 2)H")

}

}

}



if ($lastFG -ne -1) { [void]$outputBuilder.Append("`e[0m") }



if ($outputBuilder.Length -gt 10) {

[Console]::Write($outputBuilder.ToString())

}

} catch {

Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_

}

}



function Request-TuiRefresh { $global:TuiState.IsDirty = $true }



function Cleanup-TuiEngine {

try {

$global:TuiState.CancellationTokenSource?.Cancel()

$global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)

$global:TuiState.InputPowerShell?.Dispose()

$global:TuiState.InputRunspace?.Dispose()

$global:TuiState.CancellationTokenSource?.Dispose()



Stop-AllTuiAsyncJobs



foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }

$global:TuiState.EventHandlers.Clear()



if ($Host.Name -ne 'Visual Studio Code Host') {

[Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()

}

} catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }

}

#endregion



#region Screen & Overlay Management

function Push-Screen {

param([UIElement]$Screen)

if (-not $Screen) { return }



Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"



try {

$global:TuiState.FocusedComponent?.OnBlur()

if ($global:TuiState.CurrentScreen) {

$global:TuiState.CurrentScreen.OnExit()

$global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)

}

$global:TuiState.CurrentScreen = $Screen

$global:TuiState.FocusedComponent = $null



if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) { # Default size

$Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)

}



# Call OnEnter lifecycle method

if ($Screen -is [Screen] -or $Screen.GetType().GetMethod("OnEnter")) {

$Screen.OnEnter()

}



$Screen.RequestRedraw()



Request-TuiRefresh

Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $Screen.Name }

} catch {

Write-Warning "Push screen error: $_"

Write-Log -Level Error -Message "Failed to push screen '$($Screen.Name)': $_"

}

}



function Pop-Screen {

if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }

Write-Log -Level Debug -Message "Popping screen"

try {

$global:TuiState.FocusedComponent?.OnBlur()

$screenToExit = $global:TuiState.CurrentScreen

$global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()

$global:TuiState.FocusedComponent = $null



$screenToExit?.OnExit()

$global:TuiState.CurrentScreen?.OnResume()

if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }



Request-TuiRefresh

Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }

return $true

} catch { Write-Warning "Pop screen error: $_"; return $false }

}



function Show-TuiOverlay {

param([UIElement]$Element)

$global:TuiState.OverlayStack.Add($Element)

Request-TuiRefresh

}



function Close-TopTuiOverlay {

if ($global:TuiState.OverlayStack.Count > 0) {

$global:TuiState.OverlayStack.RemoveAt($global:TuiState.OverlayStack.Count - 1)

Request-TuiRefresh

}

}

#endregion



#region Component System

function Set-ComponentFocus {

param([UIElement]$Component)

if ($Component -and (-not $Component.Enabled)) { return }



$global:TuiState.FocusedComponent?.OnBlur()

if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }

$global:TuiState.FocusedComponent = $Component

$Component?.OnFocus()



Request-TuiRefresh

}



function Get-NextFocusableComponent {

param([UIElement]$CurrentComponent, [bool]$Reverse = $false)

if (-not $global:TuiState.CurrentScreen) { return $null }



$focusableComponents = [System.Collections.Generic.List[UIElement]]::new()



function Find-Focusable([UIElement]$Comp) {

if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {

$focusableComponents.Add($Comp)

}

foreach ($child in $Comp.Children) { Find-Focusable $child }

}



Find-Focusable $global:TuiState.CurrentScreen



if ($focusableComponents.Count -eq 0) { return $null }



$sorted = $focusableComponents | Sort-Object { $_.TabIndex * 10000 + $_.Y * 100 + $_.X }



if ($Reverse) { [Array]::Reverse($sorted) }



$currentIndex = [array]::IndexOf($sorted, $CurrentComponent)

if ($currentIndex -ge 0) {

return $sorted[($currentIndex + 1) % $sorted.Count]

} else {

return $sorted[0]

}

}



function Move-Focus { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

function Get-FocusedComponent { return $global:TuiState.FocusedComponent }

function Stop-AllTuiAsyncJobs { Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)" }

#endregion



#region Utilities

function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }

function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }

function Stop-TuiLoop { Stop-TuiEngine }

#endregion
# --- END OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---

# --- START OF ORIGINAL FILE: modules\tui-framework\tui-framework.psm1 ---
# TUI Framework Integration Module

# Contains utility functions for interacting with the TUI engine and components.

# AI: FIX - Added all missing dependencies.









$script:TuiAsyncJobs = @()



function Invoke-TuiMethod {

<# .SYNOPSIS Safely invokes a method on a TUI component. #>

param(

[Parameter(Mandatory)] [hashtable]$Component,

[Parameter(Mandatory)] [string]$MethodName,

[Parameter()] [hashtable]$Arguments = @{}

)

if (-not $Component) { return }

$method = $Component[$MethodName]

if (-not ($method -is [scriptblock])) { return }



$Arguments['self'] = $Component

Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock { & $method @Arguments }

}



function Initialize-TuiFramework {

Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {

if (-not $global:TuiState) { throw "TUI Engine must be initialized before the TUI Framework." }

Write-Log -Level Info -Message "TUI Framework initialized."

}

}



function Invoke-TuiAsync {

<# .SYNOPSIS Executes a script block asynchronously with job management. #>

param(

[Parameter(Mandatory)] [scriptblock]$ScriptBlock,

[string]$JobName = "TuiAsyncJob_$(Get-Random)",

[hashtable]$ArgumentList = @{}

)

Invoke-WithErrorHandling -Component "TuiFramework.Async" -Context "Starting async job: $JobName" -ScriptBlock {

$job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList -Name $JobName

$script:TuiAsyncJobs += $job

Write-Log -Level Debug -Message "Started async job: $JobName" -Data @{ JobId = $job.Id }

return $job

}

}



function Get-TuiAsyncResults {

<# .SYNOPSIS Checks for completed async jobs and returns their results. #>

param([switch]$RemoveCompleted = $true)

Invoke-WithErrorHandling -Component "TuiFramework.AsyncResults" -Context "Checking async job results" -ScriptBlock {

$results = @()

$completedJobs = $script:TuiAsyncJobs | Where-Object { $_.State -in @('Completed', 'Failed', 'Stopped') }



foreach ($job in $completedJobs) {

$results += @{

JobId = $job.Id; JobName = $job.Name; State = $job.State

Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job } else { $null }

Error = if ($job.State -eq 'Failed') { $job.ChildJobs[0].JobStateInfo.Reason } else { $null }

}

Write-Log -Level Debug -Message "Async job completed: $($job.Name)" -Data @{ JobId = $job.Id; State = $job.State }

}



if ($RemoveCompleted -and $completedJobs.Count -gt 0) {

foreach ($job in $completedJobs) {

Remove-Job -Job $job -Force -ErrorAction SilentlyContinue

$script:TuiAsyncJobs = $script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id }

}

}

return $results

}

}



function Stop-AllTuiAsyncJobs {

Invoke-WithErrorHandling -Component "TuiFramework.StopAsync" -Context "Stopping all async jobs" -ScriptBlock {

foreach ($job in $script:TuiAsyncJobs) {

try {

Stop-Job -Job $job -ErrorAction SilentlyContinue

Remove-Job -Job $job -Force -ErrorAction SilentlyContinue

Write-Log -Level Debug -Message "Stopped async job: $($job.Name)"

} catch {

Write-Log -Level Warning -Message "Failed to stop job $($job.Name): $_"

}

}

$script:TuiAsyncJobs = @()

Write-Log -Level Info -Message "All TUI async jobs stopped."

}

}







function Get-TuiState { return $global:TuiState }



function Test-TuiState {

param([switch]$ThrowOnError)

$isValid = $global:TuiState -and $global:TuiState.Running -and $global:TuiState.CurrentScreen

if (-not $isValid -and $ThrowOnError) { throw "TUI state is not properly initialized. Call Initialize-TuiEngine first." }

return $isValid

}
# --- END OF ORIGINAL FILE: modules\tui-framework\tui-framework.psm1 ---

# --- START OF MAIN EXECUTION LOGIC ---
# This is the original startup logic from the monolith, now running after all
# --- END OF MAIN EXECUTION LOGIC ---

