Okay, let's take this one step at a time. The most impactful and foundational improvement to pull from "Project Acta" into "Axiom-Phoenix" is the **Truecolor Theming System and Enhanced Rendering Primitives**.

This addresses a critical performance and visual fidelity issue identified in the previous review (Axiom's lack of truecolor output and inefficient rendering diffing).

---

### Improvement 1: Truecolor Theming System and Enhanced Rendering Primitives

**1. Explanation of Value:**

This upgrade revolutionizes how your TUI handles colors and rendering, offering several significant benefits:

*   **Truecolor (24-bit RGB) Support**: Instead of being limited to the 16 `[ConsoleColor]` values, you can now use any hex color code (e.g., `#FF8700`). This allows for vastly richer and more modern themes.
*   **Hierarchical Theming**: Themes are now structured with a `Palette` (base colors) and `Components` (styles for specific UI elements, like `Table.Header.Foreground`). Styles can reference palette colors, making theme creation more organized and less repetitive.
*   **Centralized Style Retrieval**: A new `ThemeEngine` service provides a `GetStyle()` method, returning a comprehensive hashtable of foreground, background, and text attributes (`Bold`, `Italic`, `Underline`, `Strikethrough`). This decouples UI components from hardcoded colors.
*   **Optimized ANSI Output**: The underlying `TuiAnsiHelper` is redesigned to generate correct ANSI escape sequences for 24-bit colors and to minimize redundant escape codes during rendering.
*   **Correct Differential Rendering**: The `TuiCell` class's `DiffersFrom` method (along with changes to `TuiEngine`'s `Render-CompositorToConsole` which are implicitly part of this upgrade) will correctly identify only the cells that have visually changed, drastically reducing console writes and improving performance and flicker.

**2. Relevant Code to Pull:**

You'll need to **replace or heavily modify** the following files in your Axiom-Phoenix structure:

*   `modules\theme-manager\theme-manager.psm1` (replace with `modules\theme-engine\theme-engine.psm1` from Acta)
*   `components\tui-primitives\tui-primitives.psm1` (modify with new `TuiAnsiHelper`, `TuiCell`, `Write-TuiText`, `Write-TuiBox` from Acta)

---

**Code Block 1: `modules\theme-engine\theme-engine.psm1` (Full Replacement)**

This file *replaces* your existing `modules\theme-manager\theme-manager.psm1`.

```powershell
# MODULE: ThemeEngine
# PURPOSE: Loads and serves theme styles from JSON files, enabling full user customization.

using namespace System.Text
using namespace System.Management.Automation
using namespace System

class ThemeEngine {
    hidden [hashtable] $_themes
    hidden [string] $_currentThemeKey
    hidden [hashtable] $_currentThemeObject

    ThemeEngine([string]$themesDirectory) {
        $this._themes = @{}
        $this.LoadThemesFromDirectory($themesDirectory)

        # HARDENING: Ensure there is at least a fallback theme in case none are found or loadable.
        # This prevents the application from crashing on first run or with a bad configuration.
        if ($this._themes.Count -eq 0) {
            Write-Log -Level Warning -Message "No valid themes found. Loading internal default fallback."
            $this._themes['Default'] = @{
                Name = 'Default Fallback'
                Palette = @{ 
                    background = '#0d1117'; foreground = '#c9d1d9'; accent1 = '#58a6ff'; accent2 = '#f78166';
                    border = '#30363d'; borderFocus = '#58a6ff'; success = '#3fb950'; error = '#f85149';
                    errorHighlight = '#FF00FF'
                }
                Components = @{ 
                    Default = @{ FG = '$Palette.foreground'; BG = '$Palette.background' }
                    Panel = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.foreground' }
                    PanelFocus = @{ BorderFG = '$Palette.borderFocus' }
                    Table = @{ Header = @{ FG = '$Palette.accent1'; Bold = $true } }
                    FileBrowser = @{
                        Default = @{ FG = '$Palette.foreground' }
                        Directory = @{ FG = '$Palette.accent1'; Bold = $true }
                        Selected = @{ BG = '#2ea043'; FG = '#ffffff' }
                    }
                    Kanban = @{
                        Column = @{ BorderFG = '$Palette.border' }
                        Card = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent2' }
                        CardSelected = @{ BorderFG = '$Palette.borderFocus'; BG = '#30363d' }
                    }
                    Widget = @{
                        UpNext = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent1' }
                        Stats = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent2' }
                        Text = @{ Default = @{ FG = '$Palette.foreground' }; Overdue = @{ FG = '$Palette.error'; Bold = $true } }
                    }
                }
            }
        }

        # Set the first available theme as the current one.
        $this.SetTheme(($this._themes.Keys | Select-Object -First 1))
    }

    [void] LoadThemesFromDirectory([string]$dir) {
        if (-not (Test-Path $dir)) { Write-Log -Level Warning -Message "Themes directory not found: $dir"; return }
        $themeFiles = Get-ChildItem -Path $dir -Filter "*.theme.json" -File
        foreach ($file in $themeFiles) {
            try {
                $themeKey = ($file.BaseName -replace '\.theme$', '')
                $themeObject = Get-Content -Path $file.FullName -Raw | ConvertFrom-Json -AsHashtable
                $this._themes[$themeKey] = $themeObject
                Write-Log -Level Info -Message "Loaded theme '$themeKey' from $($file.Name)"
            } catch {
                # HARDENING: Resiliently handles corrupted or malformed theme files without crashing.
                Write-Log -Level Error -Message "Failed to load theme file '$($file.Name)': $_"
            }
        }
    }

    [void] SetTheme([string]$themeKey) {
        if ($this._themes.ContainsKey($themeKey)) {
            $this._currentThemeKey = $themeKey
            $this._currentThemeObject = $this._themes[$themeKey]
            Publish-Event -EventName "Theme.Changed" -Data @{ Name = $themeKey }
            Write-Log -Level Info -Message "Theme changed to: $themeKey"
        } else {
            Write-Log -Level Warning -Message "Attempted to set non-existent theme: $themeKey"
        }
    }

    # The core method for retrieving a fully resolved style object for a component.
    [hashtable] GetStyle([string]$componentPath) {
        $pathSegments = $componentPath.Split('.')
        $currentValue = $this._currentThemeObject
        
        # Traverse the path in the theme file (e.g., Components.Table.Header)
        foreach($segment in $pathSegments) {
            if ($currentValue -is [hashtable] -and $currentValue.ContainsKey($segment)) {
                $currentValue = $currentValue[$segment]
            } else {
                # Path not found, return an empty style to avoid errors in the calling code.
                return @{}
            }
        }
        
        # Now, resolve all palette references (e.g., '$Palette.accent1') in the retrieved style object.
        $resolvedStyle = @{}
        if ($currentValue -is [hashtable]) {
            foreach ($key in $currentValue.Keys) {
                $val = $currentValue[$key]
                $depth = 0 # HARDENING: Introduce depth counter to prevent infinite loops from circular references.
                
                while ($val -is [string] -and $val.StartsWith('$Palette.') -and $depth -lt 10) {
                    $paletteKey = $val.Substring(9)
                    # HARDENING: Check if the palette key actually exists to prevent errors.
                    if ($this._currentThemeObject.Palette.ContainsKey($paletteKey)) {
                        $val = $this._currentThemeObject.Palette[$paletteKey]
                    } else {
                        # Key not found, break loop and assign a visible error color for easy debugging.
                        Write-Log -Level Warning -Message "Theme '$($this._currentThemeKey)' is missing palette key: '$paletteKey' requested by '$componentPath'"
                        $val = $this._currentThemeObject.Palette.errorHighlight ?? '#FF00FF'
                        break
                    }
                    $depth++
                }
                # If it's still a variable after max depth, it's a circular reference.
                if ($val -is [string] -and $val.StartsWith('$Palette.')) {
                    Write-Log -Level Error -Message "Circular or unresolved palette reference detected at '$componentPath' for value '$val'"
                    $val = $this._currentThemeObject.Palette.errorHighlight ?? '#FF00FF'
                }
                $resolvedStyle[$key] = $val
            }
        }
        
        return $resolvedStyle
    }

    [string[]] GetThemeKeys() {
        return @($this._themes.Keys)
    }

    [hashtable] GetCurrentTheme() {
        return $this._currentThemeObject
    }
}

# Factory function to create the engine instance.
function Initialize-ThemeEngine {
    param([string]$themesDirectory)
    return [ThemeEngine]::new($themesDirectory)
}
```

---

**Code Block 2: `components\tui-primitives\tui-primitives.psm1` (Heavy Modification)**

This file needs to be updated with the new `TuiAnsiHelper` and `TuiCell` definitions. The `Write-TuiText` and `Write-TuiBox` functions are also updated to use the new style parameter. You will replace the existing content of these specific classes/functions in your Axiom's `tui-primitives.psm1` with the following.

```powershell
# ==============================================================================
# MODULE: tui-primitives (Axiom-Phoenix v5.0 - Truecolor Edition)
# PURPOSE: Provides core TuiCell class and primitive drawing operations
#          with support for 24-bit truecolor.
# ==============================================================================

using namespace System.Text
using namespace System.Management.Automation
using namespace System

#region TuiAnsiHelper - ANSI Code Generation with Truecolor Support
# Provides static methods for generating ANSI escape codes for colors and text styles.
# Supports 24-bit hex colors.
class TuiAnsiHelper {
    # Caches resolved hex codes to ANSI escape sequences to avoid repeated calculations.
    hidden static [System.Collections.Concurrent.ConcurrentDictionary[string, string]] $_fgCache = [System.Collections.Concurrent.ConcurrentDictionary[string, string]]::new()
    hidden static [System.Collections.Concurrent.ConcurrentDictionary[string, string]] $_bgCache = [System.Collections.Concurrent.ConcurrentDictionary[string, string]]::new()

    # Converts a hex string like "#RRGGBB" to an RGB integer array.
    # Returns $null if the format is invalid.
    static [int[]] ParseHexColor([string]$hexColor) {
        if ([string]::IsNullOrWhiteSpace($hexColor) -or -not $hexColor.StartsWith("#")) { return $null }
        $hex = $hexColor.Substring(1)
        if ($hex.Length -eq 3) { $hex = "$($hex[0])$($hex[0])$($hex[1])$($hex[1])$($hex[2])$($hex[2])" }
        if ($hex.Length -ne 6) { return $null }
        try {
            $r = [System.Convert]::ToInt32($hex.Substring(0, 2), 16)
            $g = [System.Convert]::ToInt32($hex.Substring(2, 2), 16)
            $b = [System.Convert]::ToInt32($hex.Substring(4, 2), 16)
            return @($r, $g, $b)
        } catch { return $null }
    }
    
    # The new core method to generate a full ANSI sequence for Truecolor and styling.
    static [string] GetAnsiSequence([string]$fgHex, [string]$bgHex, [hashtable]$attributes) {
        $sequences = [System.Collections.Generic.List[string]]::new()

        # Foreground color (Truecolor - SGR 38;2)
        if ($fgHex) {
            $rgb = [TuiAnsiHelper]::ParseHexColor($fgHex)
            if ($rgb) {
                # Cache lookup for foreground
                $fgKey = "FG:$fgHex"
                if (-not [TuiAnsiHelper]::_fgCache.ContainsKey($fgKey)) {
                    [TuiAnsiHelper]::_fgCache[$fgKey] = "38;2;$($rgb[0]);$($rgb[1]);$($rgb[2])"
                }
                $sequences.Add([TuiAnsiHelper]::_fgCache[$fgKey])
            }
        }

        # Background color (Truecolor - SGR 48;2)
        if ($bgHex) {
            $rgb = [TuiAnsiHelper]::ParseHexColor($bgHex)
            if ($rgb) {
                # Cache lookup for background
                $bgKey = "BG:$bgHex"
                if (-not [TuiAnsiHelper]::_bgCache.ContainsKey($bgKey)) {
                    [TuiAnsiHelper]::_bgCache[$bgKey] = "48;2;$($rgb[0]);$($rgb[1]);$($rgb[2])"
                }
                $sequences.Add([TuiAnsiHelper]::_bgCache[$bgKey])
            }
        }

        # Style attributes
        if ($attributes) {
            if ([bool]($attributes.Bold ?? $false)) { $sequences.Add("1") }
            if ([bool]($attributes.Italic ?? $false)) { $sequences.Add("3") }
            if ([bool]($attributes.Underline ?? $false)) { $sequences.Add("4") }
            if ([bool]($attributes.Strikethrough ?? $false)) { $sequences.Add("9") }
        }

        # If no styles, return empty string. Otherwise, build the full escape sequence.
        if ($sequences.Count -eq 0) { return "" }
        return "`e[$($sequences -join ';')m"
    }

    # A single, universal reset sequence (SGR 0)
    static [string] Reset() { return "`e[0m" }
}
#endregion

#region TuiCell Class - Core Compositor Unit with Truecolor Support
# Represents a single character cell within the TUI buffer, including its character,
# colors, and styling attributes. Now uses hex color formats.
class TuiCell {
    [char] $Char = ' '
    
    # --- HARDENING: Resilient Property Setters for Hex Colors ---
    # Store colors as hex strings. Default foreground is light gray. Background can be null (transparent).
    hidden [string] $_foregroundColor = "#C0C0C0" 
    hidden [string] $_backgroundColor = $null 

    [string] get_ForegroundColor() { return $this._foregroundColor }
    [void] set_ForegroundColor([string]$value) {
        if ($null -eq $value) { 
            # If null, default to a safe value or make it explicit based on design
            $this._foregroundColor = "#C0C0C0" 
            Write-Log -Level Warning -Message "TuiCell: Attempted to set null ForegroundColor. Defaulting to #C0C0C0."
        } elseif ($value -match '^#[0-9A-Fa-f]{6}$') { # Enforce #RRGGBB format
            $this._foregroundColor = $value
        } else {
            Write-Log -Level Warning -Message "TuiCell: Invalid foreground color format: '$value'. Must be '#RRGGBB'. Using last valid color."
        }
    }

    [string] get_BackgroundColor() { return $this._backgroundColor }
    [void] set_BackgroundColor([string]$value) {
        if ($null -eq $value) { # Allow null for transparent background
            $this._backgroundColor = $null
        } elseif ($value -match '^#[0-9A-Fa-f]{6}$') {
            $this._backgroundColor = $value
        } else {
            Write-Log -Level Warning -Message "TuiCell: Invalid background color format: '$value'. Must be '#RRGGBB' or null. Using last valid color."
        }
    }
    # --- END HARDENING ---

    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [bool] $Strikethrough = $false # New style attribute
    [string] $StyleFlags = "" # Reserved for future custom styling or flags
    [int] $ZIndex = 0        # Used for layering, higher Z-index means it's drawn on top
    [object] $Metadata = $null # Allows attaching arbitrary data to a specific cell

    # Default constructor: Initializes a cell with default properties
    TuiCell() { }

    # Character constructor: Initializes a cell with a specified character
    TuiCell([char]$char) { $this.Char = $char }

    # Full constructor: Now accepts hex strings for colors and explicit style flags
    TuiCell([char]$char, [string]$fg, [string]$bg, [bool]$bold=$false, [bool]$italic=$false, [bool]$underline=$false, [bool]$strikethrough=$false) {
        $this.Char = $char
        $this.ForegroundColor = $fg # Uses the new setter logic
        $this.BackgroundColor = $bg # Uses the new setter logic
        $this.Bold = $bold
        $this.Italic = $italic
        $this.Underline = $underline
        $this.Strikethrough = $strikethrough
    }

    # Copy constructor: Creates a new TuiCell by copying all properties
    TuiCell([Parameter(Mandatory)][ValidateNotNull()][TuiCell]$other) {
        $this.Char = $other.Char
        $this.ForegroundColor = $other.ForegroundColor
        $this.BackgroundColor = $other.BackgroundColor
        $this.Bold = $other.Bold
        $this.Underline = $other.Underline
        $this.Italic = $other.Italic
        $this.Strikethrough = $other.Strikethrough
        $this.StyleFlags = $other.StyleFlags
        $this.ZIndex = $other.ZIndex
        $this.Metadata = $other.Metadata
    }

    # Creates a new TuiCell with new colors (style object)
    [TuiCell] WithStyle([hashtable]$style) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $style.FG ?? $copy.ForegroundColor
        $copy.BackgroundColor = $style.BG ?? $copy.BackgroundColor
        $copy.Bold = $style.Bold ?? $copy.Bold
        $copy.Italic = $style.Italic ?? $copy.Italic
        $copy.Underline = $style.Underline ?? $copy.Underline
        $copy.Strikethrough = $style.Strikethrough ?? $copy.Strikethrough
        return $copy
    }

    # Creates a new TuiCell with a new character
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blends this TuiCell with another TuiCell (Z-order aware)
    [TuiCell] BlendWith([Parameter(Mandatory)][ValidateNotNull()][TuiCell]$other) {
        # The 'other' cell is on top if its ZIndex is higher.
        if ($other.ZIndex -gt $this.ZIndex) {
            return $other 
        }
        # If ZIndex is equal, the 'other' cell takes precedence if it has a non-space character
        # or a non-transparent background (if this cell has transparent background).
        if ($other.ZIndex -eq $this.ZIndex) {
            # If other has a non-space character, it wins for the character
            if ($other.Char -ne ' ') { return $other }
            # If other has a background color and this one doesn't, other's background wins
            if ($null -ne $other.BackgroundColor -and $null -eq $this.BackgroundColor) { return $other }
        }
        return $this # This cell remains
    }

    # Checks if this TuiCell differs visually from another TuiCell
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic -or
                $this.Strikethrough -ne $other.Strikethrough)
    }

    # Provides a human-readable string representation
    [string] ToString() {
        return "TuiCell(Char='$($this.Char)', FG='$($this.ForegroundColor)', BG='$($this.BackgroundColor)', Bold=$($this.Bold), Underline=$($this.Underline), Italic=$($this.Italic), Strikethrough=$($this.Strikethrough), ZIndex=$($this.ZIndex))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
# Represents a rectangular region of TuiCells, acting as a canvas or layer in the TUI system.
class TuiBuffer {
    [TuiCell[,]] $Cells       # The 2D array holding the TuiCell objects
    [int] $Width             # Width of the buffer in characters
    [int] $Height            # Height of the buffer in characters
    [string] $Name            # A descriptive name for the buffer
    [bool] $IsDirty = $true  # Flag indicating if the buffer's content has changed

    # Constructor: Initializes a new 2D buffer of TuiCells with specified dimensions
    TuiBuffer(
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$width,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$height,
        [string]$name = "Unnamed"
    ) {
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear() # Initialize all cells to default empty cells
        Write-Verbose "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
    }

    # Clears the entire buffer with default empty cells
    [void] Clear() {
        $this.Clear([TuiCell]::new()) # Call the overloaded Clear method
        Write-Verbose "TuiBuffer '$($this.Name)' cleared with default cell."
    }

    # Clears the entire buffer with copies of a specified TuiCell
    [void] Clear([Parameter(Mandatory)][ValidateNotNull()][TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                # Create a new instance to avoid all cells referencing the same object
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell) 
            }
        }
        $this.IsDirty = $true # Mark buffer as dirty
        Write-Verbose "TuiBuffer '$($this.Name)' cleared with specified cell."
    }

    # Safely retrieves the TuiCell at the specified coordinates
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            # Return an empty cell (with default transparent background) for out-of-bounds access
            return [TuiCell]::new() 
        }
        return $this.Cells[$y, $x]
    }

    # Safely sets the TuiCell at the specified coordinates
    [void] SetCell([int]$x, [int]$y, [Parameter(Mandatory)][ValidateNotNull()][TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true # Mark buffer as dirty
        } else {
            Write-Warning "Attempted to set cell out of bounds in TuiBuffer '$($this.Name)': ($x, $y) is outside 0..$($this.Width-1), 0..$($this.Height-1). Cell: '$($cell.Char)'."
        }
    }

    # Writes a string of characters to the buffer with color support
    # Note: This function is generally superseded by Write-TuiText for richer styling.
    # It remains for simplicity where only basic character/FG/BG setting is needed.
    [void] WriteString([int]$x, [int]$y, [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$text, [string]$fg, [string]$bg) {
        # Check if the starting Y position is out of bounds
        if ($y -lt 0 -or $y -ge $this.Height) {
            Write-Warning "Skipping WriteString: Y coordinate ($y) out of bounds for buffer '$($this.Name)' (0..$($this.Height-1)). Text: '$text'."
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break } # Stop if beyond buffer width
            
            if ($currentX -ge 0) {
                # Create a new TuiCell with the given character and colors.
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
        $this.IsDirty = $true
        Write-Verbose "WriteString: Wrote '$text' to buffer '$($this.Name)' at ($x, $y)."
    }

    # Blends another TuiBuffer onto this buffer
    [void] BlendBuffer([Parameter(Mandatory)][ValidateNotNull()][TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                # Only blend if target coordinates are within bounds
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
        $this.IsDirty = $true
        Write-Verbose "BlendBuffer: Blended buffer '$($other.Name)' onto '$($this.Name)' at ($offsetX, $offsetY)."
    }

    # Creates a sub-buffer representing a section of this buffer
    [TuiBuffer] GetSubBuffer(
        [int]$x, [int]$y,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$width,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$height
    ) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell)) # Use copy constructor
            }
        }
        Write-Verbose "GetSubBuffer: Created sub-buffer '$($subBuffer.Name)' from '$($this.Name)' at ($x, $y) with dimensions $($width)x$($height)."
        return $subBuffer
    }

    # Resizes the buffer to new dimensions
    [void] Resize(
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$newWidth,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$newHeight
    ) {
        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear() # Clear with default cells

        # Copy existing content from old buffer
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
        Write-Verbose "TuiBuffer '$($this.Name)' resized from $($oldWidth)x$($oldHeight) to $($newWidth)x$($newHeight)."
    }

    # Provides a human-readable string representation
    [string] ToString() {
        return "TuiBuffer(Name='$($this.Name)', Width=$($this.Width), Height=$($this.Height), IsDirty=$($this.IsDirty))"
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions with Truecolor Support

function Write-TuiText {
    <#
    .SYNOPSIS
    Writes a string of text onto a specified TuiBuffer with rich style support.
    .DESCRIPTION
    Accepts a single Style hashtable which can contain Foreground (FG), Background (BG)
    hex colors, and boolean flags for Bold, Italic, Underline, and Strikethrough.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNull()]
        [TuiBuffer]$Buffer,
        
        [Parameter(Mandatory)]
        [int]$X,
        
        [Parameter(Mandatory)]
        [int]$Y,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Text,
        
        [Parameter(Mandatory)] # Style hashtable is now mandatory
        [hashtable]$Style # Contains FG, BG, Bold, Italic, Underline, Strikethrough
    )
    
    try {
        # Check for Y-coordinate being out of bounds
        if ($Y -lt 0 -or $Y -ge $Buffer.Height) {
            Write-Warning "Skipping Write-TuiText: Y coordinate ($Y) for text '$Text' is out of buffer '$($Buffer.Name)' vertical bounds (0..$($Buffer.Height-1))."
            return
        }

        # Extract properties from the style object, providing safe defaults using the null-coalescing operator.
        $fg = $Style.FG ?? "#C0C0C0" # Default light gray foreground
        $bg = $Style.BG ?? $null     # Default transparent background
        $bold = [bool]($Style.Bold ?? $false)
        $italic = [bool]($Style.Italic ?? $false)
        $underline = [bool]($Style.Underline ?? $false)
        $strikethrough = [bool]($Style.Strikethrough ?? $false)
        
        $currentX = $X
        foreach ($char in $Text.ToCharArray()) {
            if ($currentX -ge $Buffer.Width) { break } 
            
            if ($currentX -ge 0) {
                # Create a new TuiCell with the desired attributes
                $charCell = [TuiCell]::new($char, $fg, $bg, $bold, $italic, $underline, $strikethrough)
                $Buffer.SetCell($currentX, $Y, $charCell)
            }
            $currentX++
        }
        Write-Verbose "Write-TuiText: Wrote '$Text' to buffer '$($Buffer.Name)' at ($X, $Y) with style."
    }
    catch {
        Write-Error "Failed to write text to TUI buffer '$($Buffer.Name)' at ($X, $Y): $($_.Exception.Message)"
        throw
    }
}

function Write-TuiBox {
    <#
    .SYNOPSIS
    Draws a rectangular box onto a specified TuiBuffer with rich style support.
    .DESCRIPTION
    Accepts a single Style hashtable for border and background colors, and title styles.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNull()]
        [TuiBuffer]$Buffer,
        
        [Parameter(Mandatory)]
        [int]$X,
        
        [Parameter(Mandatory)]
        [int]$Y,
        
        [Parameter(Mandatory)]
        [ValidateRange(1, [int]::MaxValue)]
        [int]$Width,
        
        [Parameter(Mandatory)]
        [ValidateRange(1, [int]::MaxValue)]
        [int]$Height,
        
        [string]$Title = "",
        
        [Parameter(Mandatory)] # Style hashtable is now mandatory
        [hashtable]$Style # Contains BorderStyle, BorderFG, BG, TitleFG, TitleStyle (nested)
    )
    
    try {
        # Quick exit if box is entirely outside buffer bounds
        if ($X -ge $Buffer.Width -or ($X + $Width) -le 0 -or $Y -ge $Buffer.Height -or ($Y + $Height) -le 0) {
            Write-Verbose "Skipping Write-TuiBox: Box at ($X, $Y) with dimensions $($Width)x$($Height) is entirely outside buffer '$($Buffer.Name)'."
            return
        }

        # Extract properties from the style object with safe fallbacks.
        $borderStyleName = $Style.BorderStyle ?? "Single"
        $borderFG = $Style.BorderFG ?? "#808080" # Default border foreground: medium gray
        $bg = $Style.BG ?? $null               # Default background: transparent
        $titleFG = $Style.TitleFG ?? $borderFG # Title foreground defaults to border foreground if not specified.
        $titleStyleOverrides = $Style.TitleStyle ?? @{} # Allow specific overrides for title, e.g., Bold = $true

        $borders = Get-TuiBorderChars -Style $borderStyleName
        
        # Define base style objects for child calls to Write-TuiText.
        $borderBaseStyle = @{ FG = $borderFG; BG = $bg }
        $titleBaseStyle = @{ FG = $titleFG; BG = $bg }
        # Merge title overrides into the title style
        foreach($key in $titleStyleOverrides.Keys) { $titleBaseStyle[$key] = $titleStyleOverrides[$key] }
        
        # Determine actual drawing region
        $drawStartX = [Math]::Max(0, $X)
        $drawStartY = [Math]::Max(0, $Y)
        $drawEndX = [Math]::Min($Buffer.Width, $X + $Width)
        $drawEndY = [Math]::Min($Buffer.Height, $Y + $Height)
        
        $effectiveWidth = $drawEndX - $drawStartX
        $effectiveHeight = $drawEndY - $drawStartY

        if ($effectiveWidth -le 0 -or $effectiveHeight -le 0) {
            Write-Verbose "Write-TuiBox: Effective drawing area is invalid after clipping. Skipping."
            return
        }

        # Fill the box interior area (excluding borders, as they are drawn on top)
        # We use the background color provided in the style.
        $fillCell = [TuiCell]::new(' ', $borderFG, $bg) # Character ' ', FG arbitrary (will be covered), BG as specified
        for ($currentY = $drawStartY + 1; $currentY -lt $drawEndY - 1; $currentY++) { # Skip top/bottom border rows
            for ($currentX = $drawStartX + 1; $currentX -lt $drawEndX - 1; $currentX++) { # Skip left/right border columns
                $Buffer.SetCell($currentX, $currentY, [TuiCell]::new($fillCell)) # Use copy constructor
            }
        }
        
        # Draw corners
        # Note: SetCell handles bounds checking internally
        $Buffer.SetCell($X, $Y, [TuiCell]::new($borders.TopLeft, $borderFG, $bg))
        $Buffer.SetCell($X + $Width - 1, $Y, [TuiCell]::new($borders.TopRight, $borderFG, $bg))
        $Buffer.SetCell($X, $Y + $Height - 1, [TuiCell]::new($borders.BottomLeft, $borderFG, $bg))
        $Buffer.SetCell($X + $Width - 1, $Y + $Height - 1, [TuiCell]::new($borders.BottomRight, $borderFG, $bg))

        # Horizontal borders
        for ($cx = 1; $cx -lt ($Width - 1); $cx++) {
            $Buffer.SetCell($X + $cx, $Y, [TuiCell]::new($borders.Horizontal, $borderFG, $bg))
            if ($Height -gt 1) {
                $Buffer.SetCell($X + $cx, $Y + $Height - 1, [TuiCell]::new($borders.Horizontal, $borderFG, $bg))
            }
        }

        # Vertical borders
        for ($cy = 1; $cy -lt ($Height - 1); $cy++) {
            $Buffer.SetCell($X, $Y + $cy, [TuiCell]::new($borders.Vertical, $borderFG, $bg))
            if ($Width -gt 1) {
                $Buffer.SetCell($X + $Width - 1, $Y + $cy, [TuiCell]::new($borders.Vertical, $borderFG, $bg))
            }
        }

        # Draw title if specified (on top of border)
        if (-not [string]::IsNullOrEmpty($Title) -and $Y -ge 0 -and $Y -lt $Buffer.Height) {
            $titleText = " $Title "
            if ($titleText.Length -le ($Width - 2)) { 
                $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
                Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -Style $titleBaseStyle
            }
        }
        Write-Verbose "Write-TuiBox: Drew '$borderStyleName' box on buffer '$($Buffer.Name)' at ($X, $Y) with dimensions $($Width)x$($Height)."
    }
    catch {
        Write-Error "Failed to draw TUI box on buffer '$($Buffer.Name)' at ($X, $Y), $($Width)x$($Height): $($_.Exception.Message)"
        throw
    }
}

function Get-TuiBorderChars {
    <#
    .SYNOPSIS
    Retrieves Unicode characters for various box border styles.
    #>
    [CmdletBinding()]
    param(
        [ValidateSet("Single", "Double", "Rounded", "Thick")]
        [string]$Style = "Single"
    )
    
    try {
        $styles = @{
            Single = @{
                TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
                Horizontal = '─'; Vertical = '│'
            }
            Double = @{
                TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
                Horizontal = '═'; Vertical = '║'
            }
            Rounded = @{
                TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
                Horizontal = '─'; Vertical = '│'
            }
            Thick = @{
                TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
                Horizontal = '━'; Vertical = '┃'
            }
        }
        
        $selectedStyle = $styles[$Style]
        if ($null -eq $selectedStyle) {
            Write-Warning "Get-TuiBorderChars: Border style '$Style' not found. Returning 'Single' style."
            return $styles.Single
        }
        
        Write-Verbose "Get-TuiBorderChars: Retrieved TUI border characters for style: $Style."
        return $selectedStyle
    }
    catch {
        Write-Error "Failed to get TUI border characters for style '$Style': $($_.Exception.Message)"
        throw
    }
}
#endregion

# Export all public classes and functions
Export-ModuleMember -Function Write-TuiText, Write-TuiBox, Get-TuiBorderChars -Class TuiAnsiHelper, TuiCell, TuiBuffer
```

---

**3. Integration Ideas for Axiom-Phoenix:**

After replacing the above files:

1.  **Update `run.ps1`'s Theme Initialization:**
    *   Change the line `Initialize-ThemeManager` to `Initialize-ThemeEngine`.
    *   Ensure the `ThemeEngine` instance is registered with your `ServiceContainer`. You'll need to pass the path to your themes directory.

    ```powershell
    # ... (existing module sourcing) ...

    # 1. Initialize standalone services
    Write-Host "`nInitializing services..." -ForegroundColor Yellow
    Initialize-Logger -Level $(if ($Debug) { "Debug" } else { "Info" })
    Initialize-EventSystem
    # Initialize-DialogSystem # <--- Remove this line if it's still there
    
    # Ensure themes directory exists and pass it to ThemeEngine
    $themesDir = Join-Path $PSScriptRoot "themes"
    if (-not (Test-Path $themesDir)) { 
        Write-Log -Level Info -Message "Themes directory not found, creating at: $themesDir"
        New-Item -Path $themesDir -ItemType Directory | Out-Null 
    }
    $themeEngine = Initialize-ThemeEngine -themesDirectory $themesDir # <--- New call
    
    # 2. Create the service container
    Write-Host "Creating service container..." -ForegroundColor Yellow
    $container = Initialize-ServiceContainer
    
    # 3. Register all services with the container using factories
    $container.Register("ThemeEngine", $themeEngine) # <--- Register the initialized ThemeEngine instance
    $container.RegisterFactory("TuiFramework", { param($c) Initialize-TuiFrameworkService })
    # ... (rest of service registrations) ...
    ```

2.  **Update `modules\tui-engine\tui-engine.psm1`'s `Render-CompositorToConsole`:**
    *   The `Render-CompositorToConsole` function in your `tui-engine.psm1` will need to use the new `TuiCell` properties and `TuiAnsiHelper`. Your previous `tui-engine.psm1` already had `DiffersFrom` and was *attempting* to do diffing, but the `ConsoleColor` to ANSI conversion was simple. The replacement from Acta's `tui-engine.psm1` (which was shown to you in the *previous* full output) contains the correct implementation for `Render-CompositorToConsole`. You will need to apply that entire updated function from Acta to your Axiom's `tui-engine.psm1`.

3.  **Update All UI Components to Consume Styles from `ThemeEngine`:**
    *   This is the biggest **manual refactoring task**. Every UI component that draws (`LabelComponent`, `ButtonComponent`, `TextBoxComponent`, `CheckBoxComponent`, `RadioButtonComponent`, `Table`, `Panel`, `ScrollablePanel`, `GroupPanel`, `Dialog` subclasses, etc.) will need to:
        *   Get the `ThemeEngine` service in their `OnInitialize` or constructor:
            ```powershell
            class MyComponent : UIElement {
                # ...
                hidden [ThemeEngine]$_themeEngine # Declare it
                
                MyComponent([string]$name, [object]$serviceContainer) : base($name) {
                    # ...
                    $this.IsFocusable = $true
                    # ...
                    # Get ThemeEngine in constructor/initialize if needed before OnRender
                    $this._themeEngine = $serviceContainer.GetService("ThemeEngine")
                }
                # ...
                [void] OnRender() {
                    # ...
                    # Get style using the service
                    $buttonStyle = $this._themeEngine.GetStyle("Components.Button")
                    $buttonFocusStyle = $this._themeEngine.GetStyle("Components.Button.Focus")

                    $currentStyle = if ($this.IsFocused) { $buttonFocusStyle } else { $buttonStyle }
                    
                    # Pass the style hashtable to Write-TuiBox/Write-TuiText
                    Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -Style $currentStyle
                    Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -Style $currentStyle
                    # ...
                }
            }
            ```
        *   Change `Write-TuiText` and `Write-TuiBox` calls from:
            `Write-TuiText -Buffer $buf -X 0 -Y 0 -Text "Hi" -ForegroundColor [ConsoleColor]::White -BackgroundColor [ConsoleColor]::Black`
            TO:
            `Write-TuiText -Buffer $buf -X 0 -Y 0 -Text "Hi" -Style @{ FG = '#FFFFFF'; BG = '#000000'; Bold = $true }`
            (Or, even better, pass the style object retrieved from `ThemeEngine.GetStyle()`).
        *   Remove all hardcoded `[ConsoleColor]` values in component rendering logic and replace them with dynamic calls to `$this._themeEngine.GetStyle("...")` and style parameter passing.

This is a **large but crucial refactoring** that will enable true customization and a significantly smoother visual experience.


Okay, let's proceed with the next significant improvement to pull from "Project Acta" into "Axiom-Phoenix."

---

### Improvement 2: Enhanced Dialog System with Asynchronous API

**1. Explanation of Value:**

This set of changes completely overhauls the dialog and modal overlay system, offering several key advancements:

*   **Proper UIElement-based Dialogs**: All dialogs (`Dialog`, `AlertDialog`, `ConfirmDialog`, `InputDialog`) are now proper `UIElement` subclasses. This integrates them seamlessly into the rendering and input hierarchy.
*   **Asynchronous (Promise-Based) API**: The `Show-AlertDialog`, `Show-ConfirmDialog`, and `Show-InputDialog` functions (and their corresponding class `Show()` methods) return a `Task<object>`. This allows you to use `await` (if running in a PowerShell runspace that supports `await` for tasks, or by explicitly awaiting `.Result` or `.Wait()`) to get the dialog's result without blocking the main TUI loop. This is a *major* improvement for responsive UI and cleaner event-driven code.
*   **Centralized Overlay Management**: Dialogs leverage `Show-TuiOverlay` and `Close-TopTuiOverlay` from `tui-engine.psm1` to ensure they are rendered correctly on top of the current screen and handle input priority.
*   **Improved `CommandPalette`**: The Command Palette is now implemented as a `Dialog` subclass, benefiting from all the new dialog features. It's properly integrated into the overlay system.
*   **Lifecycle Awareness**: Dialogs implement `OnInitialize` for setting up their internal components (like the `TextBox` in `InputDialog`) and are automatically cleaned up when `Close-TopTuiOverlay` is called (thanks to the cascading `Cleanup()` method added to `UIElement` in the previous step).

**2. Relevant Code to Pull:**

You'll need to **replace** the contents of `modules\dialog-system-class\dialog-system-class.psm1` in your Axiom-Phoenix structure with the updated version from Acta. Note that the `CommandPalette` class is now *included* within this module in Acta's monolith, making your original `components\command-palette\command-palette.psm1` file redundant (you can delete it after this step, but we'll cover that in the integration).

---

**Code Block 1: `modules\dialog-system-class\dialog-system-class.psm1` (Full Replacement)**

This replaces your existing `modules\dialog-system-class\dialog-system.psm1` file.

```powershell
# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================

using namespace System.Management.Automation
using namespace System.Threading.Tasks
using namespace System.Collections.Generic # For Dictionary in InputDialog/ConfirmDialog

#region Base Dialog Class

class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    hidden [TaskCompletionSource[object]] $_tcs # For promise-based async result

    Dialog([Parameter(Mandatory)][string]$name) : base($name) {
        $this.IsFocusable = $true # Dialogs typically receive focus
        $this.Width = 50
        $this.Height = 10
        $this._tcs = [TaskCompletionSource[object]]::new()
        Write-Verbose "Dialog: Constructor called for '$($this.Name)'"
    }

    # Shows the dialog as a modal overlay. Returns a Task that resolves when the dialog is closed.
    [Task[object]] Show() {
        try {
            # Center the dialog on screen relative to current TUI buffer dimensions
            $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
            $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 4)
            
            # Show as overlay (uses TUI Engine's global function)
            Show-TuiOverlay -Element $this
            # Set focus to the dialog itself (uses TUI Engine's global function)
            Set-ComponentFocus -Component $this
            
            Write-Verbose "Dialog '$($this.Name)': Shown at ($($this.X), $($this.Y))"
            return $this._tcs.Task
        }
        catch {
            Write-Error "Dialog '$($this.Name)': Error showing dialog: $($_.Exception.Message)"
            $this._tcs.TrySetException($_.Exception) # Set exception on the task if showing fails
            return $this._tcs.Task
        }
    }

    # Closes the dialog, resolving its Task.
    [void] Close([object]$result, [bool]$wasCancelled = $false) {
        try {
            if ($wasCancelled) {
                $this._tcs.TrySetCanceled()
                Write-Verbose "Dialog '$($this.Name)': Closed with cancellation"
            } else {
                $this._tcs.TrySetResult($result)
                Write-Verbose "Dialog '$($this.Name)': Closed with result: $result"
            }
            
            # Close the top overlay (assumed to be this dialog)
            Close-TopTuiOverlay
        }
        catch {
            Write-Error "Dialog '$($this.Name)': Error closing dialog: $($_.Exception.Message)"
            $this._tcs.TrySetException($_.Exception) # Set exception on the task if closing fails
        }
    }

    [void] OnRender() {
        if (-not $this._private_buffer) { return }
        
        try {
            # Get base dialog style from ThemeEngine
            # Make sure $Global:AxiomServices.ThemeEngine exists and is initialized
            # (requires previous step's ThemeEngine integration)
            $dialogStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Dialog")
            $borderFocusColor = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Dialog.Focus")?.BorderFG ?? $dialogStyle.BorderFG
            
            # Use combined style for the box
            $boxStyle = @{
                BorderStyle = $dialogStyle.BorderStyle ?? "Double"
                BorderFG = if ($this.IsFocused) { $borderFocusColor } else { $dialogStyle.BorderFG }
                BG = $dialogStyle.BG
                TitleFG = $dialogStyle.TitleFG
                TitleStyle = $dialogStyle.TitleStyle # Pass nested style properties
            }

            # Clear buffer and draw dialog box
            $this._private_buffer.Clear([TuiCell]::new(' ', $dialogStyle.TitleFG, $dialogStyle.BG)) # Clear with default background cell
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -Title " $($this.Title) " -Style $boxStyle

            # Render message if present
            if (-not [string]::IsNullOrWhiteSpace($this.Message)) {
                $this._RenderMessage($dialogStyle)
            }
            
            # Allow subclasses to render their specific content
            $this.RenderDialogContent()
            
            Write-Verbose "Dialog '$($this.Name)': Rendered"
        }
        catch {
            Write-Error "Dialog '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    hidden [void] _RenderMessage([hashtable]$baseStyle) {
        try {
            $messageStyle = @{ 
                FG = $baseStyle.MessageFG ?? $baseStyle.FG 
                BG = $baseStyle.BG 
            }
            
            $messageY = 2 # Starting Y below title and border
            $messageX = 2 # Starting X inside left border
            $maxWidth = $this.Width - 4 # Account for 2 chars border on each side
            
            $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
            foreach ($line in $wrappedLines) {
                if ($messageY -ge ($this.Height - 3)) { break } # Don't overwrite buttons/bottom border
                Write-TuiText -Buffer $this._private_buffer -X $messageX -Y $messageY -Text $line -Style $messageStyle
                $messageY++
            }
        }
        catch {
            Write-Error "Dialog '$($this.Name)': Error rendering message: $($_.Exception.Message)"
        }
    }

    # Virtual method for subclasses to render their specific content (e.g., buttons, input fields)
    [void] RenderDialogContent() { 
        # Override in subclasses
    }

    # Default input handling for dialogs: Escape key for cancellation
    [bool] HandleInput([Parameter(Mandatory)][ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Close($null, $true) # Close with cancellation
            return $true
        }
        return $false # Not handled, allow parent/engine to process
    }

    [string] ToString() {
        return "Dialog(Name='$($this.Name)', Title='$($this.Title)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

#endregion

#region Specialized Dialogs

class AlertDialog : Dialog {
    AlertDialog([Parameter(Mandatory)][string]$title, [Parameter(Mandatory)][string]$message) : base("AlertDialog") {
        $this.Title = $title
        $this.Message = $message
        # Calculate optimal size based on message length
        $this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))
        $messageLines = Get-WordWrappedLines -Text $message -MaxWidth ($this.Width - 4)
        $this.Height = [Math]::Max(8, 5 + $messageLines.Count) # 5 for borders, title, button row
        Write-Verbose "AlertDialog: Created with title '$title'"
    }

    [void] RenderDialogContent() {
        try {
            # Get button styles from ThemeEngine
            $buttonStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Dialog.Button")
            $buttonFocusStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Dialog.Button.Focus")
            
            $buttonY = $this.Height - 2 # Position button near bottom border
            $buttonLabel = " [ OK ] "
            $buttonX = [Math]::Floor(($this.Width - $buttonLabel.Length) / 2) # Center horizontally
            
            # Render button with focus style
            Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY -Text $buttonLabel -Style $buttonFocusStyle
        }
        catch {
            Write-Error "AlertDialog '$($this.Name)': Error rendering content: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([Parameter(Mandatory)][ConsoleKeyInfo]$key) {
        # AlertDialog only responds to Enter, Spacebar, or Escape (from base Dialog)
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            $this.Close($true) # Close with true result (OK pressed)
            return $true
        }
        return ([Dialog]$this).HandleInput($key) # Call base Dialog's input handler (for Escape)
    }
}

class ConfirmDialog : Dialog {
    hidden [int] $_selectedButton = 0 # 0 for Yes, 1 for No

    ConfirmDialog([Parameter(Mandatory)][string]$title, [Parameter(Mandatory)][string]$message) : base("ConfirmDialog") {
        $this.Title = $title
        $this.Message = $message
        # Calculate optimal size based on message length
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10))
        $messageLines = Get-WordWrappedLines -Text $message -MaxWidth ($this.Width - 4)
        $this.Height = [Math]::Max(8, 5 + $messageLines.Count)
        Write-Verbose "ConfirmDialog: Created with title '$title'"
    }

    [void] RenderDialogContent() {
        try {
            # Get button styles from ThemeEngine
            $buttonNormalStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Dialog.Button")
            $buttonFocusStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Dialog.Button.Focus")
            
            $buttonY = $this.Height - 3 # Position buttons slightly above bottom border
            $buttons = @("  Yes  ", "  No   ") # Text labels for buttons
            $buttonSpacing = 14 # Approximate width of button + gap
            $totalButtonsWidth = ($buttons.Count * 8) + (($buttons.Count - 1) * (14-8))
            $startX = [Math]::Floor(($this.Width - $totalButtonsWidth) / 2) # Center buttons
            
            for ($i = 0; $i -lt $buttons.Count; $i++) {
                $isFocused = ($i -eq $this._selectedButton)
                $label = if ($isFocused) { "[ $($buttons[$i].Trim()) ]" } else { $buttons[$i] } # Add brackets for focus visual
                $currentStyle = if ($isFocused) { $buttonFocusStyle } else { $buttonNormalStyle }
                
                Write-TuiText -Buffer $this._private_buffer -X ($startX + ($i * $buttonSpacing)) -Y $buttonY -Text $label -Style $currentStyle
            }
        }
        catch {
            Write-Error "ConfirmDialog '$($this.Name)': Error rendering content: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([Parameter(Mandatory)][ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow), ([ConsoleKey]::RightArrow), ([ConsoleKey]::Tab) {
                # Toggle selected button between Yes (0) and No (1)
                $this._selectedButton = ($this._selectedButton + 1) % 2
                $this.RequestRedraw()
                return $true
            }
            ([ConsoleKey]::Enter) {
                $result = ($this._selectedButton -eq 0) # True for Yes, False for No
                $this.Close($result)
                return $true
            }
        }
        return ([Dialog]$this).HandleInput($key) # Call base Dialog's input handler (for Escape)
    }
}

class InputDialog : Dialog {
    hidden [TextBoxComponent] $_textBox # Child text box component
    
    InputDialog([Parameter(Mandatory)][string]$title, [Parameter(Mandatory)][string]$message, [string]$defaultValue = "") : base("InputDialog") {
        $this.Title = $title
        $this.Message = $message
        # Calculate optimal size
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 20))
        $messageLines = Get-WordWrappedLines -Text $message -MaxWidth ($this.Width - 4)
        $this.Height = [Math]::Max(10, 7 + $messageLines.Count) # 7 for borders, title, message space, input box, buttons
        
        # Store default value as metadata for OnInitialize
        $this.Metadata.DefaultValue = $defaultValue
        Write-Verbose "InputDialog: Created with title '$title'"
    }

    # OnInitialize is called by the TUI Engine after the component is created and added to the hierarchy.
    # It's the right place to create child components.
    [void] OnInitialize() {
        try {
            # Create a TextBoxComponent instance
            $this._textBox = [TextBoxComponent]::new("DialogInput")
            $this._textBox.Width = $this.Width - 4 # Fit inside dialog borders
            $this._textBox.Height = 3 # Standard textbox height
            $this._textBox.X = 2 # Position inside dialog (relative to dialog's top-left)
            $this._textBox.Y = 2 + (Get-WordWrappedLines -Text $this.Message -MaxWidth ($this.Width - 4)).Count # Position below message
            $this._textBox.Text = $this.Metadata.DefaultValue # Set initial text
            $this._textBox.Placeholder = "Type here..."
            $this._textBox.MaxLength = 200 # Arbitrary max length for dialog input
            
            # Add the text box as a child of the dialog. This makes it part of the dialog's rendering tree.
            $this.AddChild($this._textBox)

            # Set initial focus to the text box
            Set-ComponentFocus -Component $this._textBox

            Write-Verbose "InputDialog '$($this.Name)': TextBox component initialized"
        }
        catch {
            Write-Error "InputDialog '$($this.Name)': Error initializing: $($_.Exception.Message)"
        }
    }

    # OnResize is called if the dialog itself resizes (e.g., due to window resize).
    # It ensures child components adapt their size/position.
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        ([Dialog]$this).OnResize($newWidth, $newHeight) # Call base
        if ($this._textBox) {
            $this._textBox.Width = $newWidth - 4
            $this._textBox.Y = 2 + (Get-WordWrappedLines -Text $this.Message -MaxWidth ($newWidth - 4)).Count
            $this._textBox.Resize($this._textBox.Width, $this._textBox.Height) # Trigger textbox's own resize logic
        }
    }

    [void] RenderDialogContent() {
        try {
            # Buttons are static text rendered directly to the dialog's buffer.
            # The textbox is a child, handled by the base UIElement.Render() call.
            
            # Get button styles from ThemeEngine
            $buttonNormalStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Dialog.Button")
            $buttonFocusStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Dialog.Button.Focus")
            
            $buttonY = $this.Height - 2 # Position buttons near bottom border
            $okLabel = "[ OK ]"
            $cancelLabel = "[ Cancel ]"
            $spacing = 2
            $totalButtonsWidth = $okLabel.Length + $cancelLabel.Length + $spacing
            $startX = $this.Width - $totalButtonsWidth - 2 # Position buttons near right side

            Write-TuiText -Buffer $this._private_buffer -X $startX -Y $buttonY -Text $okLabel -Style $buttonFocusStyle # OK is typically default focus
            Write-TuiText -Buffer $this._private_buffer -X ($startX + $okLabel.Length + $spacing) -Y $buttonY -Text $cancelLabel -Style $buttonNormalStyle
        }
        catch {
            Write-Error "InputDialog '$($this.Name)': Error rendering content: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([Parameter(Mandatory)][ConsoleKeyInfo]$key) {
        # Always give the internal TextBoxComponent first chance to handle input
        if ($this._textBox -and $this._textBox.HandleInput($key)) {
            return $true
        }
        
        # If TextBox didn't handle it, process dialog-specific keys
        switch ($key.Key) {
            ([ConsoleKey]::Enter) {
                # Get text from textbox and close dialog with result
                $result = $this._textBox ? $this._textBox.Text : ""
                $this.Close($result)
                return $true
            }
        }
        # Fallback to base Dialog's input handler (for Escape)
        return ([Dialog]$this).HandleInput($key)
    }
}

class CommandPalette : Dialog {
    [TextBoxComponent]$inputBox
    [Table]$resultsTable
    [object[]]$allActions
    [object[]]$filteredActions

    CommandPalette() : base("CommandPalette") {
        $this.Title = "Command Palette"
        # Dynamically size the palette to be a large portion of the screen.
        $this.Width = [Math]::Floor($global:TuiState.BufferWidth * 0.6)
        $this.Height = [Math]::Floor($global:TuiState.BufferHeight * 0.7)
        
        # Get the master list of actions from the service.
        # Ensure $Global:AxiomServices.ActionService exists and is initialized.
        $this.allActions = @($Global:AxiomServices.ActionService.GetAllActions()) # Use GetAllActions from ActionService
        $this.filteredActions = $this.allActions
        
        # Create the input box for filtering.
        $this.inputBox = [TextBoxComponent]::new("PaletteInput")
        $this.inputBox.Width = $this.Width - 4
        $this.inputBox.Height = 3
        $this.inputBox.X = 2
        $this.inputBox.Y = 1
        # Wire up the text box's OnChange event to our filtering method.
        # Use .GetNewClosure() for event handlers to capture $this scope
        $this.inputBox.OnChange = { param($NewValue) $this.FilterActions($NewValue) }.GetNewClosure()
        $this.AddChild($this.inputBox)

        # Create the table to display results.
        $this.resultsTable = [Table]::new("PaletteResults")
        $this.resultsTable.Width = $this.Width - 4
        $this.resultsTable.Height = $this.Height - 5 # Account for borders, title, input box, and spacing
        $this.resultsTable.X = 2
        $this.resultsTable.Y = 4
        $this.resultsTable.ShowBorder = $false # Table's own border is hidden as it's inside the dialog's box
        $this.resultsTable.SetColumns(@(
            # Adjust column widths dynamically based on palette width
            [TableColumn]::new('Name', 'Action', [Math]::Floor(($this.Width-6)*0.7)),
            [TableColumn]::new('Category', 'Category', [Math]::Floor(($this.Width-6)*0.3)) # Column named Category from ActionService
        ))
        $this.resultsTable.SetData($this.filteredActions)
        $this.AddChild($this.resultsTable)
        
        # Set focus to the input box when the palette is initialized/shown
        Set-ComponentFocus -Component $this.inputBox
    }

    [void] FilterActions([string]$searchText) {
        if ([string]::IsNullOrWhiteSpace($searchText)) {
            $this.filteredActions = $this.allActions
        } else {
            # Simple fuzzy matching (case-insensitive contains) on Name and Description
            $this.filteredActions = $this.allActions | Where-Object { 
                $_.Name -like "*$searchText*" -or 
                $_.Description -like "*$searchText*" -or
                $_.Category -like "*$searchText*"
            }
        }
        $this.resultsTable.SetData($this.filteredActions)
        $this.RequestRedraw()
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender() # Call base dialog render to draw box and title
        # Children (input box and results table) are automatically rendered by UIElement's _RenderContent
        # since they were added with AddChild.
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # First, pass input to the currently focused child.
        # This will either be the inputBox or the resultsTable (if focus shifts).
        foreach ($child in $this.Children) {
            if ($child.IsFocused -and $child.HandleInput($key)) {
                return $true
            }
        }
        
        # If no child handled the input, process palette-specific navigation or actions.
        switch ($key.Key) {
            ([ConsoleKey]::Escape) { $this.Close($null, $true); return $true } # Close palette on Esc
            ([ConsoleKey]::Enter) { $this.ExecuteSelectedAction(); return $true }
            ([ConsoleKey]::DownArrow) { 
                # If focus is on input, move to table. Else, move selection in table.
                if ($this._textBox.IsFocused) { Set-ComponentFocus -Component $this.resultsTable }
                else { $this.resultsTable.SelectNext() }
                return $true 
            }
            ([ConsoleKey]::UpArrow) { 
                # If focus is on table, move to previous selection. If at top, move to input.
                if ($this.resultsTable.IsFocused -and $this.resultsTable.SelectedIndex -eq 0) {
                     Set-ComponentFocus -Component $this.inputBox
                } else {
                     $this.resultsTable.SelectPrevious()
                }
                return $true 
            }
            ([ConsoleKey]::PageUp) { # PageUp/PageDown for table scrolling
                0..($this.resultsTable.Height - 1) | ForEach-Object { $this.resultsTable.SelectPrevious() }
                return $true
            }
            ([ConsoleKey]::PageDown) {
                0..($this.resultsTable.Height - 1) | ForEach-Object { $this.resultsTable.SelectNext() }
                return $true
            }
            ([ConsoleKey]::Home) { # Home/End for table scrolling
                $this.resultsTable.SelectedIndex = 0
                $this.resultsTable.RequestRedraw()
                return $true
            }
            ([ConsoleKey]::End) {
                $this.resultsTable.SelectedIndex = $this.resultsTable.Data.Count - 1
                $this.resultsTable.RequestRedraw()
                return $true
            }
            ([ConsoleKey]::Tab) { # Tab cycles focus between input and table
                 if ($this.inputBox.IsFocused) { Set-ComponentFocus -Component $this.resultsTable }
                 else { Set-ComponentFocus -Component $this.inputBox }
                 return $true
            }
        }
        # Fallback to base dialog handling for any unhandled keys.
        return ([Dialog]$this).HandleInput($key)
    }

    [void] ExecuteSelectedAction() {
        $selectedAction = $this.resultsTable.GetSelectedItem()
        if ($selectedAction) {
            $this.Close($null, $false) # Close palette first.
            # Execute the ScriptBlock associated with the selected action.
            Invoke-WithErrorHandling -Component "CommandPalette" -Context "ExecuteAction" -ScriptBlock {
                & $selectedAction.ScriptBlock # Execute the actual ScriptBlock of the action
            } -AdditionalData @{ ActionName = $selectedAction.Name }
        } else {
            # If nothing selected and Enter pressed, perhaps clear filter or close.
            if (-not [string]::IsNullOrWhiteSpace($this.inputBox.Text)) {
                $this.inputBox.Text = "" # Clear search text
                $this.inputBox.RequestRedraw()
                $this.FilterActions("")
                Set-ComponentFocus -Component $this.inputBox # Keep focus on input
            } else {
                $this.Close($null, $true) # Close if no text and no selection
            }
        }
    }
}

#endregion

#region Factory Functions (Promise-based API)

# Simple text wrapping utility. Moved from previous iteration's `Get-WordWrappedLines`.
function Get-WordWrappedLines {
    <#
    .SYNOPSIS
    Wraps text to fit within a specified width.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Text,
        [Parameter(Mandatory)][int]$MaxWidth
    )
    
    if ([string]::IsNullOrWhiteSpace($Text)) { return @() }
    
    $lines = [System.Collections.Generic.List[string]]::new()
    $words = $Text -split '\s+'
    $currentLine = ""
    
    foreach ($word in $words) {
        $testLine = if ($currentLine) { "$currentLine $word" } else { $word }
        
        if ($testLine.Length -le $MaxWidth) {
            $currentLine = $testLine
        } else {
            if ($currentLine) {
                [void]$lines.Add($currentLine)
                $currentLine = $word
            } else {
                # Word is longer than max width, break it
                while ($word.Length -gt $MaxWidth) {
                    [void]$lines.Add($word.Substring(0, $MaxWidth))
                    $word = $word.Substring($MaxWidth)
                }
                $currentLine = $word
            }
        }
    }
    
    if ($currentLine) {
        [void]$lines.Add($currentLine)
    }
    
    return $lines.ToArray()
}

# Initializes event subscriptions for dialogs (e.g., for global alert/confirm events)
function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        # Example subscriptions (if you want to trigger dialogs via events):
        # Subscribe-Event -EventName "Confirm.Request" -Handler { param($EventData) $params = $EventData.Data; Show-ConfirmDialog @params }
        # Subscribe-Event -EventName "Alert.Show" -Handler { param($EventData) $params = $EventData.Data; Show-AlertDialog @params }
        # Subscribe-Event -EventName "Input.Request" -Handler { param($EventData) $params = $EventData.Data; Show-InputDialog @params }
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

# Factory function to show an alert dialog. Returns a Task.
function Show-AlertDialog {
    <#
    .SYNOPSIS
    Shows an alert dialog with a message and OK button.
    .DESCRIPTION
    Displays a modal alert dialog with the specified title and message.
    Returns a Task that can be awaited for the user's acknowledgment.
    .PARAMETER Title
    The title of the alert dialog.
    .PARAMETER Message
    The message to display in the dialog.
    .EXAMPLE
    $result = Show-AlertDialog -Title "Success" -Message "Operation completed successfully!" | Wait-Task # Or await if async context
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Title,
        [Parameter(Mandatory)][string]$Message
    )
    
    try {
        $dialog = [AlertDialog]::new($Title, $Message)
        Write-Verbose "Show-AlertDialog: Created alert dialog '$Title'"
        return $dialog.Show()
    }
    catch {
        Write-Error "Show-AlertDialog: Error creating alert dialog: $($_.Exception.Message)"
        throw
    }
}

# Factory function to show a confirmation dialog. Returns a Task<bool>.
function Show-ConfirmDialog {
    <#
    .SYNOPSIS
    Shows a confirmation dialog with Yes/No buttons.
    .DESCRIPTION
    Displays a modal confirmation dialog with the specified title and message.
    Returns a Task that resolves to $true for Yes, $false for No, or $null if cancelled.
    .PARAMETER Title
    The title of the confirmation dialog.
    .PARAMETER Message
    The message to display in the dialog.
    .EXAMPLE
    $confirmed = Show-ConfirmDialog -Title "Delete" -Message "Are you sure you want to delete this item?" | Wait-Task
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Title,
        [Parameter(Mandatory)][string]$Message
    )
    
    try {
        $dialog = [ConfirmDialog]::new($Title, $Message)
        Write-Verbose "Show-ConfirmDialog: Created confirm dialog '$Title'"
        return $dialog.Show()
    }
    catch {
        Write-Error "Show-ConfirmDialog: Error creating confirm dialog: $($_.Exception.Message)"
        throw
    }
}

# Factory function to show an input dialog. Returns a Task<string>.
function Show-InputDialog {
    <#
    .SYNOPSIS
    Shows an input dialog for text entry.
    .DESCRIPTION
    Displays a modal input dialog with the specified title, message, and optional default value.
    Returns a Task that resolves to the entered text, or $null if cancelled.
    .PARAMETER Title
    The title of the input dialog.
    .PARAMETER Message
    The message to display in the dialog.
    .PARAMETER DefaultValue
    The default value to pre-fill in the text box.
    .EXAMPLE
    $userInput = Show-InputDialog -Title "Name" -Message "Enter your name:" -DefaultValue "John Doe" | Wait-Task
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Title,
        [Parameter(Mandatory)][string]$Message,
        [string]$DefaultValue = ""
    )
    
    try {
        $dialog = [InputDialog]::new($Title, $Message, $DefaultValue)
        Write-Verbose "Show-InputDialog: Created input dialog '$Title'"
        return $dialog.Show()
    }
    catch {
        Write-Error "Show-InputDialog: Error creating input dialog: $($_.Exception.Message)"
        throw
    }
}

# Global function to show the command palette.
function Show-CommandPalette {
    <#
    .SYNOPSIS
    Shows the global command palette.
    .DESCRIPTION
    Creates and displays the CommandPalette as a modal overlay, allowing users to
    search and execute application actions.
    #>
    [CmdletBinding()]
    param()

    try {
        # CommandPalette constructor now handles getting ActionService from $Global:AxiomServices
        $palette = [CommandPalette]::new() 
        Write-Verbose "Show-CommandPalette: Created command palette"
        return $palette.Show()
    }
    catch {
        Write-Error "Show-CommandPalette: Error creating/showing command palette: $($_.Exception.Message)"
        throw
    }
}

# Global function to close the topmost TUI dialog (managed by TUI Engine)
function Close-TuiDialog {
    <#
    .SYNOPSIS
    Closes the currently active topmost TUI dialog or overlay.
    #>
    [CmdletBinding()]
    param()
    Close-TopTuiOverlay # This function is part of TUI Engine
}

#endregion
```

---

**3. Integration Ideas for Axiom-Phoenix:**

1.  **Update `run.ps1`'s Module Loading & Initialization:**
    *   **Delete `components\command-palette\command-palette.psm1`**: Since `CommandPalette` is now defined within `dialog-system-class.psm1`, the old file is redundant. Remove its entry from `run.ps1`'s `$FileLoadOrder`.
    *   **Adjust `dialog-system-class.psm1` Load Order**: Ensure `dialog-system-class.psm1` is loaded *after* `tui-components.psm1` and `advanced-data-components.psm1` (because dialogs might contain `TextBoxComponent` and `Table`).
    *   **Update Dialog System Initialization**: Remove the `Initialize-DialogSystem` call from `run.ps1` if it's currently a no-op placeholder. It's now correctly placed within the `dialog-system-class.psm1` itself.
    *   **Remove `Register-CommandPalette` Call**: The `CommandPalette` class itself now handles its initialization and setup in its constructor. The `Show-CommandPalette` function is the new entry point. Your previous `Register-CommandPalette` function (in `components\command-palette\command-palette.psm1`) is no longer needed. The global action and keybinding for the command palette needs to be set up manually in `run.ps1` or a dedicated "global actions" file (like Acta's `commands\global-commands.psm1`).

    ```powershell
    # --- run.ps1 Snippet ---

    # ... (updated FileLoadOrder without old command-palette.psm1) ...

    # 1. Initialize standalone services
    Write-Host "`nInitializing services..." -ForegroundColor Yellow
    Initialize-Logger -Level $(if ($Debug) { "Debug" } else { "Info" })
    Initialize-EventSystem
    # No direct Initialize-DialogSystem call here needed anymore.
    # ... (Initialize-ThemeEngine as per previous step) ...
    
    # 2. Create the service container
    # ...
    
    # 3. Register all services with the container using factories
    # ... (all existing services) ...
    
    # 4. Register screen classes with the Navigation Service
    # ...
    
    # 5. Manually register the global action for Command Palette:
    # Get services that will be used by global actions
    $actionService = $container.GetService("ActionService")
    $keybindingService = $container.GetService("KeybindingService")
    $navigationService = $container.GetService("NavigationService") # Needed for navigation actions
    
    # Register the action that opens the command palette
    $actionService.RegisterAction(
        "app.showCommandPalette", 
        "Show the command palette for quick action access", 
        { 
            # This action now simply calls the new Show-CommandPalette function
            Show-CommandPalette | Out-Null # Ensure it's not blocking the pipeline
        },
        "Application"
    )
    # Bind Ctrl+P to the palette action
    $keybindingService.SetBinding("app.showCommandPalette", 'P', @('Ctrl'))

    # Add other global actions from Acta's commands/global-commands.psm1 if desired
    $actionService.RegisterAction("app.exit", "Exits the application", { $navigationService.RequestExit() }, "Application")
    $keybindingService.SetBinding("app.exit", 'Q', @('Ctrl'))

    # You might want to remove existing default bindings from KeybindingService.InitializeDefaultBindings()
    # if you are re-registering them here or via the command palette.

    Write-Host "Service container configured with $($container.GetAllRegisteredServices().Count) services!" -ForegroundColor Green

    # ... (rest of run.ps1) ...
    ```

2.  **Update `modules\tui-engine\tui-engine.psm1`'s `Process-SingleKeyInput`:**
    *   The Acta `tui-engine.psm1`'s `Process-SingleKeyInput` has specific logic for handling the `Ctrl+P` global hotkey. You'll need to incorporate this.

    ```powershell
    # In modules\tui-engine\tui-engine.psm1

    function Process-SingleKeyInput {
        param($keyInfo)
        
        # --- HARDENING: Focus Validation (from previous step) ---
        # ... (existing focus validation) ...
        
        # NEW: Check for global command palette keybind (Ctrl+P) at the highest priority.
        # This will call the new Show-CommandPalette function from dialog-system-class.psm1
        if (($keyInfo.Modifiers -band [ConsoleModifiers]::Control) -and $keyInfo.Key -eq [ConsoleKey]::P) { # Corrected to ConsoleKey::P
            Show-CommandPalette | Out-Null # Call the global function
            return # Input is handled.
        }

        # ... (rest of Process-SingleKeyInput: overlay handling, Tab, focused component, current screen) ...
    }
    ```

3.  **Refactor Dialog Calls in Your Application:**
    *   Wherever you previously had:
        *   `Show-AlertDialog -Title "..." -Message "..."`
        *   `Show-ConfirmDialog -Title "..." -Message "..." -OnConfirm { ... }` (note: the new API uses task result, not callbacks)
        *   `Show-InputDialog -Title "..." -Message "..." -OnSubmit { ... }` (note: same for this)
    *   You will now use the **async API**:
        ```powershell
        # Example using the new API in a function:
        function Do-SomethingThatNeedsConfirmation {
            param($itemToDelete)

            # Show dialog and await its result
            # Use 'Wait-Task' if not in an async context, or simply 'await' if supported.
            $confirmed = Show-ConfirmDialog -Title "Delete Item" -Message "Are you sure you want to delete $($itemToDelete.Name)?" | Wait-Task

            if ($confirmed -is [bool] -and $confirmed) { # Check type because cancellation returns $null
                # User clicked Yes
                Write-Host "Deleting item..."
            } elseif ($confirmed -is [bool] -and -not $confirmed) {
                # User clicked No
                Write-Host "Deletion cancelled by user."
            } else {
                # User cancelled (e.g., pressed Escape)
                Write-Host "Dialog dismissed without selection."
            }
        }
        ```
    *   **Crucial Note for `ComboBoxComponent`**: The `ComboBoxComponent` (your old critical issue) needs a similar pattern. When `IsDropDownOpen` is set to `$true`, instead of trying to render a `_dropdownBuffer` directly, it should create a *separate, transient `UIElement` component* (e.g., `ComboBoxDropdownList`) that takes the `ComboBox`'s position and item data, renders *itself* (perhaps as a plain list or table), and is pushed onto `TuiState.OverlayStack`. When an item is selected or the overlay is dismissed, it would signal back to the parent `ComboBox`. This is a significant refactor of `ComboBoxComponent`, but aligns it with the new robust dialog/overlay pattern. This is a separate, complex refactor, but the new dialog system provides the *pattern* to implement it correctly.



Okay, let's move on to the third significant improvement to pull from "Project Acta" into "Axiom-Phoenix." This next one focuses on solidifying the UI component structure and enhancing event cleanup.

---

### Improvement 3: Refined UI Element Hierarchy with Comprehensive Cleanup

**1. Explanation of Value:**

This set of changes enhances the fundamental UI component classes, making them more robust, maintainable, and prevent memory leaks:

*   **Standardized `UIElement` Lifecycle**: The base `UIElement` gains explicit `Resize` and `Cleanup` methods.
*   **Cascading `Cleanup`**: The `Cleanup` method on `UIElement` is designed to automatically cascade calls to all child components. This is crucial for correctly releasing resources and unsubscribing from events when a component (or an entire screen) is no longer needed.
*   **Explicit Event Unsubscription**: Components (like `Screen` and `UpcomingTasksWidget` in Acta) are now shown to explicitly track their event subscriptions and unsubscribe from them during their `OnCleanup` or `Cleanup` phase. This is the primary mechanism to prevent memory leaks in event-driven applications where events might hold references to disposed objects.
*   **Improved `Panel` Functionality**: `Panel` now correctly overrides `OnResize` to update its content bounds and re-layout children, ensuring responsive layout on screen resizing. Its `_RenderContent` method is correctly set up to render children relative to the panel's content area.

**2. Relevant Code to Pull:**

You'll need to **replace or heavily modify** the following files in your Axiom-Phoenix structure:

*   `components\ui-classes\ui-classes.psm1` (Full Replacement)
*   `layout\panels-class\panels-class.psm1` (Full Replacement)

---

**Code Block 1: `components\ui-classes\ui-classes.psm1` (Full Replacement)**

This replaces your existing `components\ui-classes\ui-classes.psm1` file.

```powershell
# ==============================================================================
# PMC Terminal v5 - Base UI Class Hierarchy
# Provides the foundational classes for all UI components with NCurses compositor support.
# ==============================================================================

using namespace System.Management.Automation
using namespace System.Collections.Generic # For List in UIElement.Children and Screen.EventSubscriptions

#region UIElement - Base Class for all UI Components
# The foundational class for all visual components in the TUI.
# It provides basic properties like position, size, visibility, and a private TuiBuffer for rendering.
class UIElement {
    [string] $Name = "UIElement" # Default name for logging/debugging
    [int] $X = 0               # X-coordinate relative to parent or screen
    [int] $Y = 0               # Y-coordinate relative to parent or screen
    [int] $Width = 10          # Width of the element. Must be positive.
    [int] $Height = 3          # Height of the element. Must be positive.
    [bool] $Visible = $true    # Determines if the element is rendered
    [bool] $Enabled = $true    # Determines if the element can receive input or be focused
    [bool] $IsFocusable = $false # Can this element receive focus?
    [bool] $IsFocused = $false  # Is this element currently focused?
    [int] $TabIndex = 0        # For tab navigation order
    [int] $ZIndex = 0          # Determines rendering order, higher ZIndex means drawn on top
    [UIElement] $Parent = $null # Reference to parent UIElement
    [System.Collections.Generic.List[UIElement]] $Children # List of child UIElement instances
    
    # Private backing fields for buffer and redraw flag
    # These are marked 'hidden' to prevent accidental direct access and manipulation
    # from outside the class, enforcing proper rendering lifecycle.
    hidden [TuiBuffer] $_private_buffer = $null
    hidden [bool] $_needs_redraw = $true
    
    [hashtable] $Metadata = @{} # For arbitrary data attachment

    # Default Constructor: Initializes a basic UIElement.
    # Uses default dimensions (10x3) which are typically overridden.
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        # Initialize buffer with default dimensions. Actual dimensions might be set later.
        # Ensure TuiBuffer is imported and available here (from tui-primitives.psm1).
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        Write-Verbose "UIElement 'Unnamed' created with default size ($($this.Width)x$($this.Height))."
    }

    # Constructor with Name: Initializes a UIElement with a specified name.
    UIElement([Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$name) {
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        Write-Verbose "UIElement '$($this.Name)' created with default size ($($this.Width)x$($this.Height))."
    }

    # Constructor with Position and Size: Initializes a UIElement with specified dimensions.
    UIElement(
        [Parameter(Mandatory)][int]$x,
        [Parameter(Mandatory)][int]$y,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$width,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$height
    ) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "Unnamed.Buffer")
        Write-Verbose "UIElement 'Unnamed' created at ($x, $y) with dimensions $($width)x$($height)."
    }

    # GetAbsolutePosition: Calculates the absolute screen coordinates of this element.
    # It aggregates the X and Y positions from itself and all its parent elements.
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # AddChild: Adds a child UIElement to this component.
    # The child's parent reference is set, and a redraw is requested.
    [void] AddChild([Parameter(Mandatory)][ValidateNotNull()][UIElement]$child) {
        try {
            if ($child -eq $this) { throw [System.ArgumentException]::new("Cannot add an element as its own child.") }
            if ($this.Children.Contains($child)) {
                Write-Warning "Child '$($child.Name)' is already a child of '$($this.Name)'. Skipping addition."
                return
            }
            if ($child.Parent -ne $null) {
                Write-Warning "Child '$($child.Name)' already has a parent ('$($child.Parent.Name)'). Consider removing it from its current parent first."
            }

            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
            Write-Verbose "Added child '$($child.Name)' to parent '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add child '$($child.Name)' to '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    # RemoveChild: Removes a specified child UIElement from this component.
    # The child's parent reference is nulled, and a redraw is requested.
    [void] RemoveChild([Parameter(Mandatory)][ValidateNotNull()][UIElement]$child) {
        try {
            if ($this.Children.Remove($child)) {
                $child.Parent = $null
                $this.RequestRedraw()
                Write-Verbose "Removed child '$($child.Name)' from parent '$($this.Name)'."
            } else {
                Write-Warning "Child '$($child.Name)' not found in parent '$($this.Name)' for removal. No action taken."
            }
        }
        catch {
            Write-Error "Failed to remove child '$($child.Name)' from '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    # RequestRedraw: Marks this component and all its ancestors as needing a redraw.
    # This ensures that changes are propagated up the component tree to the root screen/engine.
    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw() # Propagate redraw request up the hierarchy
        }
        Write-Verbose "Redraw requested for '$($this.Name)'."
    }

    # Resize: Resizes the component and its internal TuiBuffer.
    # Calls the virtual OnResize method for custom subclass logic.
    [void] Resize(
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$newWidth,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$newHeight
    ) {
        try {
            if ($this.Width -eq $newWidth -and $this.Height -eq $newHeight) {
                Write-Verbose "Resize: Component '$($this.Name)' already has target dimensions ($($newWidth)x$($newHeight)). No change."
                return # No change needed
            }

            $this.Width = $newWidth
            $this.Height = $newHeight
            
            # Recreate or resize buffer to match new dimensions.
            # Important: Ensure dimensions are valid before creating buffer (min 1x1).
            $bufferWidth = [Math]::Max(1, $newWidth)
            $bufferHeight = [Math]::Max(1, $newHeight)
            
            if ($null -ne $this._private_buffer) {
                $this._private_buffer.Resize($bufferWidth, $bufferHeight)
            } else {
                $this._private_buffer = [TuiBuffer]::new($bufferWidth, $bufferHeight, "$($this.Name).Buffer")
                Write-Verbose "Re-initialized buffer for '$($this.Name)' due to null buffer."
            }
            
            $this.RequestRedraw()
            $this.OnResize($newWidth, $newHeight) # Call virtual method
            Write-Verbose "Component '$($this.Name)' resized to $($newWidth)x$($newHeight)."
        }
        catch {
            Write-Error "Failed to resize component '$($this.Name)' to $($newWidth)x$($newHeight): $($_.Exception.Message)"
            throw
        }
    }

    # Move: Moves the component to new coordinates.
    # Calls the virtual OnMove method for custom subclass logic.
    [void] Move([Parameter(Mandatory)][int]$newX, [Parameter(Mandatory)][int]$newY) {
        if ($this.X -eq $newX -and $this.Y -eq $newY) {
            Write-Verbose "Move: Component '$($this.Name)' already at target position ($($newX), $($newY)). No change."
            return # No change needed
        }

        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw() # Position change always requires redraw
        $this.OnMove($newX, $newY) # Call virtual method
        Write-Verbose "Component '$($this.Name)' moved to ($newX, $newY)."
    }

    # ContainsPoint: Checks if a given point (relative to the component's own origin) falls within its bounds.
    [bool] ContainsPoint([Parameter(Mandatory)][int]$x, [Parameter(Mandatory)][int]$y) {
        return ($x -ge 0 -and $x -lt $this.Width -and # Check X within 0 to Width-1
                $y -ge 0 -and $y -lt $this.Height)  # Check Y within 0 to Height-1
    }

    # GetChildAtPoint: Finds the topmost visible child component at a specific point (relative to this component).
    # Iterates children in reverse order (from last added/highest ZIndex potentially) to find the top-most.
    [UIElement] GetChildAtPoint([Parameter(Mandatory)][int]$x, [Parameter(Mandatory)][int]$y) {
        # Iterate in reverse order to find the topmost child (higher ZIndex or later in list)
        # Note: If ZIndex is implemented, it would be ideal to sort children by ZIndex descending, then iterate.
        # The current implementation iterates by list order (last added child is 'on top' if ZIndex is equal).
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            # Check if child is visible and the point falls within its relative bounds
            # The point ($x, $y) is relative to this parent, so transform it for the child.
            if ($child.Visible -and $child.ContainsPoint($x - $child.X, $y - $child.Y)) {
                return $child # Found the child, return it
            }
        }
        return $null # No child found at this point
    }

    # Render: The public entry point for rendering an element and its children.
    # This method coordinates the rendering process. The TUI Engine is expected to
    # wrap calls to this method with application-wide error handling (e.g., Invoke-WithErrorHandling).
    [void] Render() {
        if (-not $this.Visible) { 
            Write-Verbose "Skipping Render for '$($this.Name)': Not visible."
            return 
        }
        
        # _RenderContent is the internal, protected method that does the actual work.
        # It's explicitly called here. Error handling for this *entire* render call
        # (including all children and blending) is typically handled by the TUI Engine
        # which calls the root screen/overlay's Render() method.
        $this._RenderContent() 
    }

    # _RenderContent: Protected internal method for rendering the component's content and compositing children.
    # This method handles the core rendering logic: drawing the component itself,
    # then recursively rendering and blending its visible children.
    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return } # Defensive check, should be caught by Render()

        # Step 1: Render this component's own content to its private buffer.
        # This only happens if the component is marked as dirty (_needs_redraw)
        # or if its private buffer has not yet been initialized or its dimensions changed.
        if ($this._needs_redraw -or ($null -eq $this._private_buffer) -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
            # Ensure dimensions are valid before creating buffer
            $bufferWidth = [Math]::Max(1, $this.Width)
            $bufferHeight = [Math]::Max(1, $this.Height)
            
            # Re-initialize/resize buffer to current dimensions
            if ($null -eq $this._private_buffer) {
                $this._private_buffer = [TuiBuffer]::new($bufferWidth, $bufferHeight, "$($this.Name).Buffer")
            } else {
                $this._private_buffer.Resize($bufferWidth, $bufferHeight) # Ensure it's the correct size
            }
            
            $this.OnRender() # Call the virtual method for actual drawing logic
            $this._needs_redraw = $false # Reset redraw flag after rendering
            Write-Verbose "Rendered own content for '$($this.Name)'."
        }

        # Step 2: Recursively render visible children and composite their buffers onto this component's buffer.
        # Sorting by ZIndex ensures correct layering (lower ZIndex drawn first, higher last).
        foreach ($child in $this.Children | Sort-Object ZIndex) { 
            if ($child.Visible) {
                $child.Render() # Recursively call Render for child
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child._private_buffer) {
                    # Children's coordinates are relative to their parent's content area.
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                    Write-Verbose "Blended child '$($child.Name)' onto '$($this.Name)' at ($($child.X), $($child.Y))."
                }
            }
        }
    }

    # GetBuffer: Returns the component's internal TuiBuffer containing its rendered content.
    [TuiBuffer] GetBuffer() { return $this._private_buffer }
    
    # ToString: Provides a human-readable string representation for debugging.
    [string] ToString() {
        return "$($this.GetType().Name)(Name='$($this.Name)', X=$($this.X), Y=$($this.Y), Width=$($this.Width), Height=$($this.Height), Visible=$($this.Visible))"
    }

    #region Virtual Methods (for subclasses to override)
    # OnRender: Virtual method for subclasses to override.
    # This is where the component's own content drawing logic should reside.
    # Default implementation clears the component's private buffer.
    [void] OnRender() {
        if ($null -ne $this._private_buffer) {
            # Default clear using an empty cell with a transparent background
            $this._private_buffer.Clear([TuiCell]::new(' ', '#FFFFFF', $null))
        }
        Write-Verbose "OnRender called for '$($this.Name)': Default buffer clear."
    }

    # OnResize: Virtual method for subclasses to override.
    # Called after the component's dimensions are updated by the Resize method.
    [void] OnResize([Parameter(Mandatory)][int]$newWidth, [Parameter(Mandatory)][int]$newHeight) {
        Write-Verbose "OnResize called for '$($this.Name)': No custom resize logic."
    }

    # OnMove: Virtual method for subclasses to override.
    # Called after the component's position is updated by the Move method.
    [void] OnMove([Parameter(Mandatory)][int]$newX, [Parameter(Mandatory)][int]$newY) {
        Write-Verbose "OnMove called for '$($this.Name)': No custom move logic."
    }

    # OnInitialize: Virtual method for subclasses to override.
    # Called once after a component is created and added to the UI hierarchy (e.g., when a Screen is pushed).
    # Ideal for creating child components.
    [void] OnInitialize() {
        Write-Verbose "OnInitialize called for '$($this.Name)': Default (no-op)."
    }

    # OnFocus: Virtual method for subclasses to override.
    # Called when the component gains focus.
    [void] OnFocus() {
        $this.IsFocused = $true
        Write-Verbose "OnFocus called for '$($this.Name)'."
    }

    # OnBlur: Virtual method for subclasses to override.
    # Called when the component loses focus.
    [void] OnBlur() {
        $this.IsFocused = $false
        Write-Verbose "OnBlur called for '$($this.Name)'."
    }

    # HandleInput: Virtual method for subclasses to override.
    # This is the primary entry point for a component to process keyboard input.
    # Returns $true if the input was handled, $false otherwise.
    [bool] HandleInput([Parameter(Mandatory)][System.ConsoleKeyInfo]$keyInfo) {
        Write-Verbose "HandleInput called for '$($this.Name)': Key: $($keyInfo.Key)."
        return $false # Default: Input not handled
    }

    # Cleanup: Virtual method for subclasses to override for specific resource cleanup.
    # This method is called by the UIElement.Cleanup() base method and cascades down.
    # Crucial for unsubscribing from events and disposing of managed resources.
    [void] Cleanup() {
        Write-Verbose "Cleanup called for '$($this.Name)': Default (no-op)."
        # Recursively call cleanup on children.
        # Note: Iterating a copy of the list because children might remove themselves during cleanup.
        foreach ($child in $this.Children.ToArray()) { 
            try { $child.Cleanup() }
            catch { Write-Warning "Error cleaning up child '$($child.Name)' of '$($this.Name)': $($_.Exception.Message)" }
        }
        $this.Children.Clear() # Clear the list of children after cleanup.
    }
    #endregion
}
#endregion

#region Component - A generic container component
# Inherits from UIElement and can contain other UI elements.
# Its primary purpose is to group children. Its _RenderContent defers to the base UIElement.
class Component : UIElement {
    # Constructor: Initializes a Component with a name.
    Component([Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$name) : base($name) {
        Write-Verbose "Component '$($this.Name)' created."
    }

    # _RenderContent: Overrides the base method but simply calls the parent's implementation.
    # This means a generic 'Component' does not draw anything itself beyond what UIElement does,
    # relying on its children to populate its buffer.
    hidden [void] _RenderContent() {
        # Call parent implementation for buffer management and child rendering
        ([UIElement]$this)._RenderContent()
        Write-Verbose "_RenderContent called for Component '$($this.Name)' (delegating to base UIElement)."
    }

    # ToString: Provides a human-readable string representation for debugging.
    [string] ToString() {
        return "Component(Name='$($this.Name)', Children=$($this.Children.Count))"
    }
}
#endregion

# Note: Panel class is now defined in layout\panels-class.psm1 (part of the monolith structure)

#region Screen - Top-level Container for Application Views
# Represents a full-screen application view. Screens manage panels and have their own lifecycle methods
# (Initialize, OnEnter, OnExit, OnResume) and service dependencies.
class Screen : UIElement {
    [System.Collections.Generic.Hashtable]$Services # Reference to the service container (or a simple hashtable)
    [System.Collections.Generic.Dictionary[string, object]]$State # To hold screen-specific data/state
    [UIElement]$LastFocusedComponent # Tracks the last component that had focus on this screen
    
    # Stores event subscription IDs (HandlerId) for cleanup when the screen exits.
    hidden [System.Collections.Generic.Dictionary[string, string]] $EventSubscriptions 

    # Constructor: Initializes a screen with a name and a service container (or hashtable of services).
    Screen(
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$name,
        [Parameter(Mandatory)][ValidateNotNull()][System.Collections.Generic.Hashtable]$services
    ) : base($name) {
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        Write-Verbose "Screen '$($this.Name)' created with services."
    }

    # Initialize: Virtual method for screen-specific setup that occurs once after creation.
    # Typically used for setting up components, initial data loading, etc.
    # This is called by the TUI Engine's Push-Screen before OnEnter.
    [void] OnInitialize() {
        Write-Verbose "OnInitialize called for Screen '$($this.Name)': Default (no-op)."
    }

    # OnEnter: Virtual method called when the screen becomes active (e.g., pushed onto navigation stack).
    # Useful for refreshing data, setting initial focus, or starting screen-specific processes.
    [void] OnEnter() {
        Write-Verbose "OnEnter called for Screen '$($this.Name)': Default (no-op)."
    }

    # OnExit: Virtual method called when the screen is no longer active (e.g., another screen pushed, or popped off stack).
    # Used for saving temporary state, pausing screen-specific activities, etc.
    [void] OnExit() {
        Write-Verbose "OnExit called for Screen '$($this.Name)': Default (no-op)."
    }

    # OnResume: Virtual method called when a screen becomes active again after another screen is popped off the stack.
    # Useful for refreshing data that might have changed while this screen was inactive.
    [void] OnResume() {
        Write-Verbose "OnResume called for Screen '$($this.Name)': Default (no-op)."
    }

    # HandleInput: Virtual method for screen-specific input handling.
    # It receives the raw ConsoleKeyInfo. Returns $true if input was handled.
    # Note: In this TUI architecture, focusable components usually handle input first.
    # This method is primarily for screen-wide shortcuts or unhandled input.
    [bool] HandleInput([Parameter(Mandatory)][System.ConsoleKeyInfo]$keyInfo) {
        Write-Verbose "HandleInput called for Screen '$($this.Name)': Key: $($keyInfo.Key). Default (no-op)."
        return $false # Default: Input not handled
    }

    # Cleanup: Cleans up resources specific to this screen when it's no longer needed.
    # This critically includes unsubscribing from events to prevent memory leaks.
    # This method overrides UIElement.Cleanup() and ensures base functionality is called.
    [void] Cleanup() {
        try {
            Write-Verbose "Cleanup called for Screen '$($this.Name)'."
            # Unsubscribe from all events managed by this screen
            # This relies on the global 'Unsubscribe-Event' function from the EventSystem module.
            foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
                try {
                    # The value stored in EventSubscriptions is the HandlerId (subscriptionId) returned by Subscribe-Event
                    Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value
                    Write-Verbose "Unsubscribed event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)'."
                }
                catch {
                    Write-Warning "Failed to unsubscribe event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)': $($_.Exception.Message)"
                }
            }
            $this.EventSubscriptions.Clear() # Clear the tracking list after unsubscription
            
            # Call base UIElement Cleanup to cascade to child components.
            # This is crucial for cleaning up the UI tree.
            ([UIElement]$this).Cleanup() 
            
            Write-Verbose "Cleaned up resources for screen: $($this.Name)."
        }
        catch {
            Write-Error "Error during Cleanup for screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    # AddChild: Overrides UIElement.AddChild to ensure panels are added to both lists.
    # Screens directly manage their top-level children (often panels) for layout/organizational purposes.
    [void] AddChild([Parameter(Mandatory)][ValidateNotNull()][UIElement]$child) {
        # Call base UIElement AddChild to add it to the generic Children collection.
        ([UIElement]$this).AddChild($child) 
        Write-Verbose "Added child '$($child.Name)' to screen '$($this.Name)' (via base UIElement.AddChild)."
    }

    # SubscribeToEvent: A helper method for screens to easily subscribe to global events
    # and automatically manage their unsubscription during cleanup.
    # This assumes the global 'Subscribe-Event' function from EventSystem is available.
    [void] SubscribeToEvent(
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$eventName,
        [Parameter(Mandatory)][ValidateNotNull()][scriptblock]$action
    ) {
        try {
            # Call the global Subscribe-Event function and store the unique HandlerId it returns.
            $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name # Pass 'Source' for bulk cleanup
            $this.EventSubscriptions[$eventName] = $subscriptionId # Store the HandlerId for later unsubscription
            Write-Verbose "Screen '$($this.Name)' subscribed to event '$eventName' with HandlerId: $subscriptionId."
        }
        catch {
            Write-Error "Failed for screen '$($this.Name)' to subscribe to event '$eventName': $($_.Exception.Message)"
            throw
        }
    }
    
    # _RenderContent: Overrides the base UIElement method to correctly render the screen's content.
    # No longer iterates over a separate 'Panels' list. It simply calls the base,
    # which will render all `Children` (including panels) already added via `AddChild`.
    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent() # Call base implementation for buffer management and children rendering.
        Write-Verbose "_RenderContent called for Screen '$($this.Name)' (rendering all UIElement children)."
    }

    # ToString: Provides a human-readable string representation for debugging.
    [string] ToString() {
        return "Screen(Name='$($this.Name)', Children=$($this.Children.Count), Visible=$($this.Visible))"
    }
}
#endregion
```

---

**Code Block 2: `layout\panels-class\panels-class.psm1` (Full Replacement)**

This replaces your existing `layout\panels-class\panels-class.psm1` file.

```powershell
# ==============================================================================
# Panel Classes v5.2 - Axiom-Phoenix Layout Foundation
# Provides Panel base class for layout management and specialized panel types.
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#region Panel Class - A specialized UIElement
# A Panel is a container UIElement that can draw a border and title,
# and it intelligently manages child elements, positioning them correctly
# within its bordered "content area".
class Panel : UIElement {
    [string] $Title = ""                     # Title displayed on the top border
    [string] $BorderStyle = "Single"         # Style of the border (e.g., "Single", "Double", "Rounded", "Thick")
    hidden [string] $_borderColor = "#808080" # Default border color (hex)
    hidden [string] $_backgroundColor = $null # Default background color (hex, transparent)
    hidden [string] $_titleColor = "#C0C0C0"  # Default title color (hex)
    [bool] $HasBorder = $true                # Whether the panel should draw a border
    [bool] $CanFocus = $false                # Can this panel itself receive focus (e.g., for navigation)?
    [int] $ContentX = 0                      # X-coordinate of the panel's content area (relative to panel's origin)
    [int] $ContentY = 0                      # Y-coordinate of the panel's content area (relative to panel's origin)
    [int] $ContentWidth = 0                   # Width of the panel's content area
    [int] $ContentHeight = 0                  # Height of the panel's content area
    [string] $LayoutType = "Manual"          # Defines how children are automatically laid out ("Manual", "Vertical", "Horizontal", "Grid")
    [hashtable] $Style = @{}                 # New: Stores the resolved style object for this panel

    # Constructor with default name
    Panel() : base("Panel_$(Get-Random -Maximum 1000)") {
        $this.IsFocusable = $false # Panels themselves are typically not focusable by default
        $this.UpdateContentBounds()
        Write-Verbose "Panel: Default constructor called for '$($this.Name)'."
    }

    # Constructor with position and size.
    Panel(
        [Parameter(Mandatory)][int]$x,
        [Parameter(Mandatory)][int]$y,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$width,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$height
    ) : base("Panel_$(Get-Random -Maximum 1000)", $x, $y, $width, $height) {
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
        Write-Verbose "Panel: Constructor with dimensions called for '$($this.Name)' at ($x, $y) with $($width)x$($height)."
    }

    # Constructor with title.
    Panel(
        [Parameter(Mandatory)][int]$x,
        [Parameter(Mandatory)][int]$y,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$width,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$height,
        [Parameter(Mandatory)][string]$title
    ) : base("Panel_$(Get-Random -Maximum 1000)", $x, $y, $width, $height) {
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
        Write-Verbose "Panel: Constructor with title called for '$($this.Name)' ('$title') at ($x, $y) with $($width)x$($height)."
    }
    
    # New: Properties to allow setting hex colors directly if not using theme engine fully
    [string] get_BorderColor() { return $this._borderColor }
    [void] set_BorderColor([string]$value) {
        if ($value -match '^#[0-9A-Fa-f]{6}$') { $this._borderColor = $value }
        else { Write-Warning "Panel '$($this.Name)': Invalid BorderColor format: '$value'. Must be '#RRGGBB'." }
    }

    [string] get_BackgroundColor() { return $this._backgroundColor }
    [void] set_BackgroundColor([string]$value) {
        if ($value -match '^#[0-9A-Fa-f]{6}$' -or $null -eq $value) { $this._backgroundColor = $value }
        else { Write-Warning "Panel '$($this.Name)': Invalid BackgroundColor format: '$value'. Must be '#RRGGBB' or null." }
    }

    [string] get_TitleColor() { return $this._titleColor }
    [void] set_TitleColor([string]$value) {
        if ($value -match '^#[0-9A-Fa-f]{6}$') { $this._titleColor = $value }
        else { Write-Warning "Panel '$($this.Name)': Invalid TitleColor format: '$value'. Must be '#RRGGBB'." }
    }

    # UpdateContentBounds: Calculates the size and position of the interior content area,
    # accounting for the border if present.
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            # Content width/height is reduced by 2 for borders (1 on each side).
            # Ensure dimensions do not go below 0.
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            # If no border, content area is the full panel size.
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
        Write-Verbose "Panel '$($this.Name)': Content bounds updated to ($($this.ContentX), $($this.ContentY)) - $($this.ContentWidth)x$($this.ContentHeight) (HasBorder: $($this.HasBorder))."
    }

    # OnResize: Overrides UIElement's virtual method.
    # Called when the panel's dimensions change. It updates content bounds and performs layout.
    [void] OnResize([Parameter(Mandatory)][int]$newWidth, [Parameter(Mandatory)][int]$newHeight) {
        # Call base implementation first
        ([UIElement]$this).OnResize($newWidth, $newHeight) 

        $this.UpdateContentBounds() # Recalculate content area based on new size
        $this.PerformLayout()        # Re-layout children based on new content area
        Write-Verbose "Panel '$($this.Name)': OnResize triggered, new content bounds calculated and layout performed."
    }

    # PerformLayout: Automatically arranges child elements based on the LayoutType property.
    [void] PerformLayout() {
        try {
            if ($this.Children.Count -eq 0) {
                Write-Verbose "Panel '$($this.Name)': No children to lay out."
                return
            }

            switch ($this.LayoutType) {
                "Vertical" { $this.LayoutVertical() }
                "Horizontal" { $this.LayoutHorizontal() }
                "Grid" { $this.LayoutGrid() }
                "Manual" { Write-Verbose "Panel '$($this.Name)': LayoutType is Manual, skipping auto-layout." } # No automatic layout
                default { Write-Warning "Panel '$($this.Name)': Unknown LayoutType '$($this.LayoutType)'. Skipping auto-layout." }
            }
            $this.RequestRedraw() # Layout changes require redraw
            Write-Verbose "Panel '$($this.Name)': Layout performed for type '$($this.LayoutType)'."
        }
        catch {
            Write-Error "Panel '$($this.Name)': Error during PerformLayout for type '$($this.LayoutType)': $($_.Exception.Message)"
            throw # Re-throw for Invoke-WithErrorHandling to catch
        }
    }

    # LayoutVertical: Arranges children stacked vertically within the content area.
    hidden [void] LayoutVertical() {
        if ($this.Children.Count -eq 0) { return }
        if ($this.ContentHeight -le 0) {
            Write-Warning "Panel '$($this.Name)': ContentHeight is 0 or less for vertical layout. Children will have 0 height."
            return # Avoid division by zero or negative heights
        }

        $currentY = $this.ContentY # Start Y position for children (relative to panel's origin)
        $childWidth = $this.ContentWidth # Children fill the full content width
        $availableHeight = $this.ContentHeight
        
        # Ensure childHeight is at least 1 to avoid zero-height components
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count)) 

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $this.ContentX # Child's X relative to panel's origin
            $child.Y = $currentY       # Child's Y relative to panel's origin
            
            # For the last child, assign remaining height to fill any gaps due to floor() division.
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, [Math]::Max(1, $remainingHeight)) # Ensure height is at least 1
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $child.Height # Advance Y for next child
        }
        Write-Verbose "Panel '$($this.Name)': Performed Vertical Layout for $($this.Children.Count) children."
    }

    # LayoutHorizontal: Arranges children side-by-side horizontally within the content area.
    hidden [void] LayoutHorizontal() {
        if ($this.Children.Count -eq 0) { return }
        if ($this.ContentWidth -le 0) {
            Write-Warning "Panel '$($this.Name)': ContentWidth is 0 or less for horizontal layout. Children will have 0 width."
            return # Avoid division by zero or negative widths
        }

        $currentX = $this.ContentX # Start X position for children (relative to panel's origin)
        $childHeight = $this.ContentHeight # Children fill the full content height
        $availableWidth = $this.ContentWidth
        
        # Ensure childWidth is at least 1 to avoid zero-width components
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $currentX # Child's X relative to panel's origin
            $child.Y = $this.ContentY # Child's Y relative to panel's origin
            
            # For the last child, assign remaining width to fill any gaps.
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize([Math]::Max(1, $remainingWidth), $childHeight) # Ensure width is at least 1
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $child.Width # Advance X for next child
        }
        Write-Verbose "Panel '$($this.Name)': Performed Horizontal Layout for $($this.Children.Count) children."
    }

    # LayoutGrid: Arranges children in a grid pattern within the content area.
    hidden [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }
        if ($this.ContentWidth -le 0 -or $this.ContentHeight -le 0) {
            Write-Warning "Panel '$($this.Name)': Content dimensions are zero or less for grid layout. Children will have 0 dimensions."
            return
        }

        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount)) # Calculate number of columns
        $rows = [Math]::Ceiling($childCount / $cols)     # Calculate number of rows
        
        # Ensure cell dimensions are at least 1
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            # Calculate child's absolute position within the panel
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            # Adjust last column/row to fill remaining space
            $width = if ($col -eq ($cols - 1)) { $this.ContentX + $this.ContentWidth - $x } else { $cellWidth }
            $height = if ($row -eq ($rows - 1)) { $this.ContentY + $this.ContentHeight - $y } else { $cellHeight }
            
            $child.Move($x, $y) # Move child to calculated position
            $child.Resize([Math]::Max(1, $width), [Math]::Max(1, $height)) # Resize child
        }
        Write-Verbose "Panel '$($this.Name)': Performed Grid Layout for $($this.Children.Count) children ($rows x $cols grid)."
    }

    # SetBorderStyle: Updates the border style and colors.
    [void] SetBorderStyle(
        [Parameter(Mandatory)][ValidateSet("Single", "Double", "Rounded", "Thick")][string]$style,
        [Parameter(Mandatory)][string]$color # Now expects hex string
    ) {
        $this.BorderStyle = $style
        $this.BorderColor = $color # Uses the new setter
        $this.RequestRedraw()
        Write-Verbose "Panel '$($this.Name)': Border style set to '$style' with color '$color'."
    }

    # SetBorder: Enables or disables the border, updating content bounds and layout.
    [void] SetBorder([Parameter(Mandatory)][bool]$hasBorder) {
        if ($this.HasBorder -eq $hasBorder) {
            Write-Verbose "Panel '$($this.Name)': Border status already $($hasBorder). No change."
            return # No change needed
        }
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds() # Recalculate content area
        $this.PerformLayout()        # Re-layout children
        $this.RequestRedraw()       # Request redraw for visual update
        Write-Verbose "Panel '$($this.Name)': Border set to '$hasBorder'. Content bounds updated and layout performed."
    }

    # SetTitle: Updates the panel's title.
    [void] SetTitle([Parameter(Mandatory)][string]$title) {
        if ($this.Title -eq $title) {
            Write-Verbose "Panel '$($this.Name)': Title already set to '$title'. No change."
            return
        }
        $this.Title = $title
        $this.RequestRedraw()
        Write-Verbose "Panel '$($this.Name)': Title set to '$title'."
    }

    # ContainsContentPoint: Checks if a point (relative to panel's origin) is within its content area.
    [bool] ContainsContentPoint([Parameter(Mandatory)][int]$x, [Parameter(Mandatory)][int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    # GetContentBounds: Returns a hashtable describing the content area's position and dimensions.
    [hashtable] GetContentBounds() {
        return @{ X = $this.ContentX; Y = $this.ContentY; Width = $this.ContentWidth; Height = $this.ContentHeight }
    }
    
    # GetContentArea: Alias for GetContentBounds.
    [hashtable] GetContentArea() {
        return $this.GetContentBounds()
    }
    
    # WriteToBuffer: Helper to write text directly to the panel's internal buffer, within its coordinates.
    # Note: This is a legacy helper; prefer getting the buffer and calling Write-TuiText directly with full styles.
    [void] WriteToBuffer(
        [Parameter(Mandatory)][int]$x,
        [Parameter(Mandatory)][int]$y,
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$text,
        [Parameter(Mandatory)][string]$fg, # Now expects hex string
        [Parameter(Mandatory)][string]$bg  # Now expects hex string
    ) {
        # Check if the panel's buffer is initialized before attempting to write.
        if ($null -eq $this._private_buffer) { 
            Write-Warning "Panel '$($this.Name)': Internal buffer is null, cannot write text. (Call OnRender first)."
            return 
        }
        # Use simple style object for this helper.
        Write-TuiText -Buffer $this._private_buffer -X $x -Y $y -Text $text -Style @{ FG = $fg; BG = $bg }
        Write-Verbose "Panel '$($this.Name)': Wrote text to buffer at ($x, $y)."
    }
    
    # DrawBoxToBuffer: Helper to draw a sub-box directly to the panel's internal buffer.
    # Note: This is a legacy helper; prefer getting the buffer and calling Write-TuiBox directly with full styles.
    [void] DrawBoxToBuffer(
        [Parameter(Mandatory)][int]$x,
        [Parameter(Mandatory)][int]$y,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$width,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$height,
        [Parameter(Mandatory)][string]$borderColor, # Now expects hex string
        [Parameter(Mandatory)][string]$bgColor      # Now expects hex string
    ) {
        if ($null -eq $this._private_buffer) { 
            Write-Warning "Panel '$($this.Name)': Internal buffer is null, cannot draw box. (Call OnRender first)."
            return 
        }
        Write-TuiBox -Buffer $this._private_buffer -X $x -Y $y -Width $width -Height $height `
            -Style @{ BorderStyle = "Single"; BorderFG = $borderColor; BG = $bgColor }
        Write-Verbose "Panel '$($this.Name)': Drew sub-box on buffer at ($x, $y) with $($width)x$($height)."
    }

    # ClearContent: Clears only the interior content area of the panel.
    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return } # Should not be null if rendered
        # Use theme's background color for clearing if available, else default to panel's background
        $actualBgColor = $this.Style.BG ?? $this._backgroundColor ?? $null
        $clearCell = [TuiCell]::new(' ', '#FFFFFF', $actualBgColor) # FG is irrelevant for clear
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, [TuiCell]::new($clearCell)) # Use copy constructor
            }
        }
        $this.RequestRedraw() # Clearing content means it needs redraw
        Write-Verbose "Panel '$($this.Name)': Content area cleared."
    }

    # OnRender: Overrides UIElement's virtual method.
    # This is where the Panel draws its own border and background.
    [void] OnRender() {
        # Ensure the buffer is ready. Base UIElement handles its creation/resize.
        if ($null -eq $this._private_buffer) { 
            Write-Warning "Panel '$($this.Name)': OnRender called but internal buffer is null. Skipping render."
            return 
        }
        
        # Get Panel's base style from ThemeEngine
        # Assume $Global:AxiomServices.ThemeEngine exists and is initialized
        $panelBaseStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Panel")
        
        # Merge properties set directly on the panel (like Title, BorderColor) with theme styles
        $currentStyle = $panelBaseStyle.Clone() # Start with theme's base panel style
        if ($this.Style.Count -gt 0) { # Allow local style overrides via $this.Style property
            foreach ($key in $this.Style.Keys) { $currentStyle[$key] = $this.Style[$key] }
        }
        # Explicit properties like these should override theme, or theme should provide better control
        # For simplicity, we'll ensure explicitly set colors are used.
        $currentStyle.BorderFG = $this._borderColor ?? $currentStyle.BorderFG
        $currentStyle.BG = $this._backgroundColor ?? $currentStyle.BG
        $currentStyle.TitleFG = $this._titleColor ?? $currentStyle.TitleFG

        # Clear the entire panel buffer with its resolved background color.
        $clearCell = [TuiCell]::new(' ', '#FFFFFF', $currentStyle.BG)
        $this._private_buffer.Clear($clearCell)
        
        # Draw border if enabled.
        if ($this.HasBorder) {
            # Write-TuiBox handles clipping automatically.
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -Title $this.Title -Style $currentStyle
        }
        Write-Verbose "Panel '$($this.Name)': OnRender completed (background and border)."
    }

    # _RenderContent: Overrides UIElement's _RenderContent to render children within content bounds.
    hidden [void] _RenderContent() {
        # First, render the panel's own background and border.
        $this.OnRender()
        
        # Then, recursively render visible children and composite their buffers onto this panel's buffer,
        # adjusting for the panel's content area offset.
        # Sorting by ZIndex ensures correct layering (lower ZIndex drawn first, higher last).
        foreach ($child in $this.Children | Sort-Object ZIndex) { 
            if ($child.Visible) {
                $child.Render() # Recursively call Render for child
                
                # Composite child's buffer onto this panel's buffer.
                # Crucially, add the panel's content X/Y to the child's relative X/Y.
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, ($child.X + $this.ContentX), ($child.Y + $this.ContentY))
                    Write-Verbose "Blended child '$($child.Name)' onto '$($this.Name)' at (relative: $($child.X), $($child.Y); effective: $($child.X + $this.ContentX), $($child.Y + $this.ContentY))."
                }
            }
        }
        # Mark dirty here, but also handled by SetCell. This ensures Panel itself is marked dirty.
        $this._private_buffer.IsDirty = $true
    }

    # OnFocus: Overrides UIElement's virtual method.
    # Changes border color when the panel gains focus, if it's focusable.
    [void] OnFocus() {
        ([UIElement]$this).OnFocus() # Call base implementation to set IsFocused = $true
        if ($this.CanFocus) {
            $this._borderColor = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Panel.Focus")?.BorderFG ?? "#00FFFF" # Theme-driven accent color
            $this.RequestRedraw()
            Write-Verbose "Panel '$($this.Name)': Gained focus, border color set to theme accent."
        }
    }

    # OnBlur: Overrides UIElement's virtual method.
    # Changes border color back when the panel loses focus.
    [void] OnBlur() {
        ([UIElement]$this).OnBlur() # Call base implementation to set IsFocused = $false
        if ($this.CanFocus) {
            $this._borderColor = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Panel")?.BorderFG ?? "#808080" # Theme-driven normal border color
            $this.RequestRedraw()
            Write-Verbose "Panel '$($this.Name)': Lost focus, border color set to theme border."
        }
    }

    # GetFirstFocusableChild: Finds the first focusable child within this panel or its nested panels.
    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children | Sort-Object TabIndex) { # Sort by TabIndex to get logical order
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                Write-Verbose "Panel '$($this.Name)': Found first focusable child '$($child.Name)'."
                return $child
            }
            # Recursively check if child is a Panel and has focusable children
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    Write-Verbose "Panel '$($this.Name)': Found nested focusable child '$($nestedChild.Name)'."
                    return $nestedChild
                }
            }
        }
        Write-Verbose "Panel '$($this.Name)': No focusable children found."
        return $null
    }

    # GetFocusableChildren: Collects all focusable children, including those nested in child panels.
    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        foreach ($child in $this.Children | Sort-Object TabIndex) { # Sort by TabIndex for logical order
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                [void]$focusable.Add($child)
            }
            # Recursively collect from nested panels
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        Write-Verbose "Panel '$($this.Name)': Collected $($focusable.Count) focusable children."
        return $focusable
    }

    # HandleInput: Overrides UIElement's virtual method.
    # Handles basic navigation (Tab, Enter) to move focus to its first child if CanFocus is true.
    # Then delegates input to its children.
    [bool] HandleInput([Parameter(Mandatory)][System.ConsoleKeyInfo]$keyInfo) {
        try {
            # If this panel *can* focus and *is* focused, handle focus-transfer keys.
            if ($this.CanFocus -and $this.IsFocused) {
                switch ($keyInfo.Key) {
                    ([ConsoleKey]::Tab) {
                        # When panel is tabbed into, try to pass focus to its first focusable child.
                        $firstChild = $this.GetFirstFocusableChild()
                        if ($null -ne $firstChild) {
                            # Don't directly set IsFocused, use the global Set-ComponentFocus.
                            Set-ComponentFocus -Component $firstChild
                            Write-Verbose "Panel '$($this.Name)': Redirecting focus to first child '$($firstChild.Name)' on Tab press."
                            return $true # Handled
                        }
                    }
                    ([ConsoleKey]::Enter) {
                        # Similar to Tab, Enter can also pass focus into the panel.
                        $firstChild = $this.GetFirstFocusableChild()
                        if ($null -ne $firstChild) {
                            Set-ComponentFocus -Component $firstChild
                            Write-Verbose "Panel '$($this.Name)': Redirecting focus to first child '$($firstChild.Name)' on Enter press."
                            return $true # Handled
                        }
                    }
                }
            }
            
            # If the panel itself is focused (and didn't transfer focus) or if it's not focusable but
            # acts as a container, try to delegate input to its children if one of them is focused.
            # Or, if this panel *is* the focused component, and it didn't transfer focus with Tab/Enter,
            # then it should pass the key to its currently focused child.
            foreach ($child in $this.Children) {
                # Only give input to a child if it's visible, enabled, and currently focused (if any).
                # The TUI Engine routes input to the *globally* focused component.
                # If this panel is the focused component, and its child is *also* focused, it handles it.
                # This logic simplifies when a child is focused directly.
                if ($child.Visible -and $child.Enabled -and $child.IsFocused) {
                    if ($child.HandleInput($keyInfo)) {
                        Write-Verbose "Panel '$($this.Name)': Focused child '$($child.Name)' handled input."
                        return $true # Child handled the input
                    }
                }
            }
            
            # If no children handled it, and the panel itself didn't use it, then it's unhandled by this element.
            Write-Verbose "Panel '$($this.Name)': Did not handle input. Key: $($keyInfo.Key)."
        }
        catch {
            Write-Error "Panel '$($this.Name)': Error handling input (Key: $($keyInfo.Key)): $($_.Exception.Message)"
            throw # Re-throw for Invoke-WithErrorHandling
        }
        return ([UIElement]$this).HandleInput($keyInfo) # Fallback to base UIElement (which returns false by default)
    }

    # ToString: Provides a human-readable string representation for debugging.
    [string] ToString() {
        return "Panel(Name='$($this.Name)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height), HasBorder=$($this.HasBorder), Children=$($this.Children.Count))"
    }
}
#endregion

#region Specialized Panel Types

# ScrollablePanel: A panel that supports scrolling its content.
class ScrollablePanel : Panel {
    [ValidateRange(0, [int]::MaxValue)][int] $ScrollX = 0 # Horizontal scroll offset
    [ValidateRange(0, [int]::MaxValue)][int] $ScrollY = 0 # Vertical scroll offset
    [ValidateRange(0, [int]::MaxValue)][int] $VirtualWidth = 0 # Total width of content, possibly larger than panel's width
    [ValidateRange(0, [int]::MaxValue)][int] $VirtualHeight = 0 # Total height of content, possibly larger than panel's height
    [bool] $ShowScrollbars = $true # Whether to display scrollbar indicators
    
    hidden [TuiBuffer]$_virtual_buffer = $null # Buffer holding the entire virtual (scrollable) content

    # Default constructor.
    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $true # Scrollable panels are typically focusable
        $this.CanFocus = $true
        Write-Verbose "ScrollablePanel: Default constructor called for '$($this.Name)'."
    }

    # Constructor with position and size.
    ScrollablePanel(
        [Parameter(Mandatory)][int]$x,
        [Parameter(Mandatory)][int]$y,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$width,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$height
    ) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        Write-Verbose "ScrollablePanel: Constructor with dimensions called for '$($this.Name)'."
    }

    # SetVirtualSize: Sets the total "virtual" size of the content, which might be larger than the panel's visible area.
    # This determines the scrollable range.
    [void] SetVirtualSize(
        [Parameter(Mandatory)][ValidateRange(0, [int]::MaxValue)][int]$width,
        [Parameter(Mandatory)][ValidateRange(0, [int]::MaxValue)][int]$height
    ) {
        try {
            if ($this.VirtualWidth -eq $width -and $this.VirtualHeight -eq $height) {
                Write-Verbose "ScrollablePanel '$($this.Name)': Virtual size already set to $($width)x$($height). No change."
                return # No change needed
            }
            $this.VirtualWidth = $width
            $this.VirtualHeight = $height
            
            # Recreate or resize the virtual buffer to match the new virtual size.
            if ($width -gt 0 -and $height -gt 0) {
                if ($null -ne $this._virtual_buffer -and $this._virtual_buffer.Width -eq $width -and $this._virtual_buffer.Height -eq $height) {
                    Write-Verbose "ScrollablePanel '$($this.Name)': Virtual buffer already correct size."
                } else {
                    $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
                    Write-Verbose "ScrollablePanel '$($this.Name)': Virtual buffer re-initialized to $($width)x$($height)."
                }
            } else {
                $this._virtual_buffer = $null # Clear virtual buffer if dimensions are zero
                Write-Verbose "ScrollablePanel '$($this.Name)': Virtual size set to 0, clearing virtual buffer."
            }
            
            # Adjust scroll position to be within new bounds.
            $this.ScrollTo($this.ScrollX, $this.ScrollY)
            $this.RequestRedraw()
            Write-Verbose "ScrollablePanel '$($this.Name)': Virtual size set to $($width)x$($height)."
        }
        catch {
            Write-Error "ScrollablePanel '$($this.Name)': Error setting virtual size to $($width)x$($height): $($_.Exception.Message)"
            throw
        }
    }

    # ScrollTo: Sets the current scroll offset.
    # The scroll position is clamped to valid ranges based on virtual and content size.
    [void] ScrollTo([Parameter(Mandatory)][int]$x, [Parameter(Mandatory)][int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        
        $newScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $newScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))

        if ($this.ScrollX -eq $newScrollX -and $this.ScrollY -eq $newScrollY) {
            Write-Verbose "ScrollablePanel '$($this.Name)': Scroll position already at ($newScrollX, $newScrollY). No change."
            return # No change needed
        }

        $this.ScrollX = $newScrollX
        $this.ScrollY = $newScrollY
        $this.RequestRedraw()
        Write-Verbose "ScrollablePanel '$($this.Name)': Scrolled to ($($this.ScrollX), $($this.ScrollY))."
    }

    # ScrollBy: Adjusts the scroll offset by a delta.
    [void] ScrollBy([Parameter(Mandatory)][int]$deltaX, [Parameter(Mandatory)][int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
        Write-Verbose "ScrollablePanel '$($this.Name)': Scrolled by ($deltaX, $deltaY)."
    }

    # HandleInput: Overrides Panel's method to process scrolling-related key presses.
    [bool] HandleInput([Parameter(Mandatory)][System.ConsoleKeyInfo]$keyInfo) {
        # This panel handles scrolling if it's focused.
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true } # Scroll to bottom of virtual content
            }
        }
        # If this panel didn't handle scrolling, let its base Panel's input handler deal with children.
        return ([Panel]$this).HandleInput($keyInfo)
    }

    # OnRender: Overrides Panel's method to render virtual content and scrollbars.
    [void] OnRender() {
        # Call base Panel's OnRender to draw border and background.
        ([Panel]$this).OnRender()
        Write-Verbose "ScrollablePanel '$($this.Name)': Base Panel OnRender completed."

        # If a virtual buffer exists, get the visible portion and blend it onto the panel's buffer.
        if ($null -ne $this._virtual_buffer -and $this.ContentWidth -gt 0 -and $this.ContentHeight -gt 0) {
            # GetSubBuffer automatically clips to its requested dimensions.
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            # Blend the visible part of the virtual buffer into the panel's content area.
            # BlendBuffer adds to ContentX/Y for positioning.
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
            Write-Verbose "ScrollablePanel '$($this.Name)': Blended virtual content."
        } else {
            Write-Verbose "ScrollablePanel '$($this.Name)': No virtual content to blend or content area is zero."
        }

        # Draw scrollbars if enabled and if content exceeds visible area.
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
            Write-Verbose "ScrollablePanel '$($this.Name)': Scrollbars drawn."
        }
    }

    # DrawScrollbars: Draws horizontal and/or vertical scrollbars on the panel's border area.
    hidden [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return } # Should not be null if OnRender called
        
        # Get scrollbar style from ThemeEngine
        $scrollbarStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Scrollbar")
        $thumbChar = $scrollbarStyle.ThumbChar ?? '█'
        $trackChar = $scrollbarStyle.TrackChar ?? '▒'
        $fg = $scrollbarStyle.FG ?? "#808080" # Default gray
        $bg = $scrollbarStyle.BG ?? $this.BackgroundColor # Use panel's background for scrollbar background

        # Vertical Scrollbar
        if ($this.VirtualHeight -gt $this.ContentHeight -and $this.Width -gt 1) { # Only draw if scrollable vertically and enough width for border
            $scrollbarX = $this.Width - 1 # Rightmost column of the panel
            $scrollbarTrackHeight = $this.Height - 2 # Exclude top/bottom borders of panel
            
            # Calculate thumb position relative to the scrollbar track height
            $scrollRatioY = ($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight))
            $thumbPositionInTrack = [Math]::Floor($scrollRatioY * ($scrollbarTrackHeight - 1))
            
            for ($y = 1; $y -lt ($this.Height - 1); $y++) { # Iterate along the vertical track (excluding panel corners)
                $char = if ($y -eq ($thumbPositionInTrack + 1)) { $thumbChar } else { $trackChar } 
                $cell = [TuiCell]::new($char, $fg, $bg)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
            Write-Verbose "ScrollablePanel '$($this.Name)': Vertical scrollbar drawn."
        }

        # Horizontal Scrollbar
        if ($this.VirtualWidth -gt $this.ContentWidth -and $this.Height -gt 1) { # Only draw if scrollable horizontally and enough height for border
            $scrollbarY = $this.Height - 1 # Bottommost row of the panel
            $scrollbarTrackWidth = $this.Width - 2 # Exclude left/right borders of panel
            
            # Calculate thumb position relative to the scrollbar track width
            $scrollRatioX = ($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth))
            $thumbPositionInTrack = [Math]::Floor($scrollRatioX * ($scrollbarTrackWidth - 1))
            
            for ($x = 1; $x -lt ($this.Width - 1); $x++) { # Iterate along the horizontal track (excluding panel corners)
                $char = if ($x -eq ($thumbPositionInTrack + 1)) { $thumbChar } else { $trackChar }
                $cell = [TuiCell]::new($char, $fg, $bg)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
            Write-Verbose "ScrollablePanel '$($this.Name)': Horizontal scrollbar drawn."
        }
    }

    # GetVirtualBuffer: Returns the internal buffer that holds the entire scrollable content.
    # This allows external code to draw directly onto the virtual content.
    [TuiBuffer] GetVirtualBuffer() {
        return $this._virtual_buffer
    }

    # ToString: Provides a human-readable string representation for debugging.
    [string] ToString() {
        return "ScrollablePanel(Name='$($this.Name)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height), VirtualSize=$($this.VirtualWidth)x$($this.VirtualHeight), Scroll=($($this.ScrollX),$($this.ScrollY)))"
    }
}

# GroupPanel: A specialized panel that can be collapsed/expanded.
class GroupPanel : Panel {
    [bool] $IsCollapsed = $false         # Current state of the panel
    [ValidateRange(1, [int]::MaxValue)][int] $ExpandedHeight = 0 # Height when expanded
    [int] $HeaderHeight = 1              # Height of the header (title bar part)
    hidden [string] $_headerColor = "#4682B4" # Default Header color (hex)
    [string] $CollapseChar = "▼"         # Character displayed when expanded, allows collapsing
    [string] $ExpandChar = "▶"           # Character displayed when collapsed, allows expanding

    # Default constructor.
    GroupPanel() : base() {
        $this.Name = "GroupPanel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height # Initial height is the expanded height
        Write-Verbose "GroupPanel: Default constructor called for '$($this.Name)'."
    }

    # Constructor with position, size, and title.
    GroupPanel(
        [Parameter(Mandatory)][int]$x,
        [Parameter(Mandatory)][int]$y,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$width,
        [Parameter(Mandatory)][ValidateRange(1, [int]::MaxValue)][int]$height,
        [Parameter(Mandatory)][string]$title
    ) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height # Initial height is the expanded height
        Write-Verbose "GroupPanel: Constructor with dimensions and title called for '$($this.Name)' ('$title')."
    }

    # New: Property to allow setting hex color directly
    [string] get_HeaderColor() { return $this._headerColor }
    [void] set_HeaderColor([string]$value) {
        if ($value -match '^#[0-9A-Fa-f]{6}$') { $this._headerColor = $value }
        else { Write-Warning "GroupPanel '$($this.Name)': Invalid HeaderColor format: '$value'. Must be '#RRGGBB'." }
    }

    # ToggleCollapsed: Toggles the collapsed state of the panel.
    [void] ToggleCollapsed() {
        try {
            $this.IsCollapsed = -not $this.IsCollapsed
            if ($this.IsCollapsed) {
                # Save current height as expanded height before collapsing.
                $this.ExpandedHeight = $this.Height
                $this.Resize($this.Width, [Math]::Max(1, $this.HeaderHeight + 2)) # Resize to header + borders
                Write-Verbose "GroupPanel '$($this.Name)': Collapsed. Resized to $($this.Width)x$($this.Height)."
            } else {
                # Restore to saved expanded height.
                $this.Resize($this.Width, [Math]::Max(1, $this.ExpandedHeight))
                Write-Verbose "GroupPanel '$($this.Name)': Expanded. Resized to $($this.Width)x$($this.Height)."
            }
            
            # Update visibility of all children based on collapsed state.
            foreach ($child in $this.Children) {
                $child.Visible = -not $this.IsCollapsed
            }
            $this.RequestRedraw()
            Write-Verbose "GroupPanel '$($this.Name)': Toggled collapsed state to $($this.IsCollapsed). Children visibility updated."
        }
        catch {
            Write-Error "GroupPanel '$($this.Name)': Error toggling collapsed state: $($_.Exception.Message)"
            throw
        }
    }

    # HandleInput: Overrides Panel's method to handle Enter/Spacebar for toggling collapse.
    [bool] HandleInput([Parameter(Mandatory)][System.ConsoleKeyInfo]$keyInfo) {
        try {
            # Let the base Panel handle its own focus transfer (Tab/Enter) to its children.
            # This must happen before our toggle logic, otherwise Enter to toggle might also transfer focus.
            if (([Panel]$this).HandleInput($keyInfo)) { return $true }

            if ($this.IsFocused) {
                switch ($keyInfo.Key) {
                    ([ConsoleKey]::Enter), ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
                }
            }
            
            # Only delegate input to children (via base Panel's input handling) if the panel is not collapsed.
            # The base Panel's HandleInput also iterates children. This avoids double-delegation.
            # The above call to ([Panel]$this).HandleInput($keyInfo) already handled this.
            # So, if we reached here and the panel is NOT collapsed, and we didn't toggle,
            # it means no input was handled specific to this GroupPanel.
            Write-Verbose "GroupPanel '$($this.Name)': Did not handle input. Key: $($keyInfo.Key)."
        }
        catch {
            Write-Error "GroupPanel '$($this.Name)': Error handling input (Key: $($keyInfo.Key)): $($_.Exception.Message)"
            throw
        }
        return $false # Input not handled by this group panel
    }

    # OnRender: Overrides Panel's method to draw the collapse/expand indicator.
    [void] OnRender() {
        # Call base Panel's OnRender to draw border and background.
        ([Panel]$this).OnRender()
        Write-Verbose "GroupPanel '$($this.Name)': Base Panel OnRender completed."

        # Draw the collapse/expand indicator character on the top border.
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            
            # Get style from ThemeEngine or fallback to local property
            $indicatorStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.GroupPanel.Indicator")
            $indicatorStyle.FG = $indicatorStyle.FG ?? $this._headerColor # Use explicit header color if set
            $indicatorStyle.BG = $indicatorStyle.BG ?? $this._backgroundColor # Use explicit background if set

            # Position indicator after a few spaces on the left, ensuring it's within bounds
            if (2 -lt ($this.Width - 1)) { # 2 for padding from left edge
                Write-TuiText -Buffer $this._private_buffer -X 2 -Y 0 -Text $indicator -Style $indicatorStyle
                Write-Verbose "GroupPanel '$($this.Name)': Indicator '$indicator' drawn."
            }
        }
    }

    # ToString: Provides a human-readable string representation for debugging.
    [string] ToString() {
        return "GroupPanel(Name='$($this.Name)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height), Collapsed=$($this.IsCollapsed))"
    }
}
#endregion
```

---

**3. Integration Ideas for Axiom-Phoenix:**

1.  **Update `run.ps1`'s Module Load Order:**
    *   Ensure `components\ui-classes\ui-classes.psm1` is loaded very early, as it defines the base `UIElement`.
    *   Ensure `layout\panels-class\panels-class.psm1` is loaded after `ui-classes`.

    ```powershell
    # --- run.ps1 Snippet ---
    $FileLoadOrder = @(
        'modules/logger/logger.psm1',
        'modules/panic-handler/panic-handler.psm1',
        'modules/exceptions/exceptions.psm1',
        'modules/event-system/event-system.psm1', # EventSystem before UI classes for subscriptions
        
        # Core TUI Primitives and Base Classes (MUST come first)
        'components/tui-primitives/tui-primitives.psm1', 
        'components/ui-classes/ui-classes.psm1', # UIElement, Component, Screen base classes
        'layout/panels-class/panels-class.psm1', # Panel, ScrollablePanel, GroupPanel (depend on UIElement)
        
        'modules/theme-engine/theme-engine.psm1', # ThemeEngine after primitives for TuiCell access
        
        # Components (depend on UIElement, TuiBuffer, etc.)
        'components/tui-components/tui-components.psm1',
        'components/advanced-data-components/advanced-data-components.psm1',
        'components/advanced-input-components/advanced-input-components.psm1',
        
        # Dialog System (depends on UI components)
        'modules/dialog-system-class/dialog-system-class.psm1', # Includes CommandPalette now
        
        # Services & Models (can be flexible, but data/models before services that use them)
        'modules/models/models.psm1',
        'modules/data-manager/data-manager.psm1',
        
        'services/service-container/service-container.psm1',
        'services/action-service/action-service.psm1',
        'services/keybinding-service/keybinding-service.psm1',
        'services/navigation-service/navigation-service.psm1',
        # Add TimeSheetService if you're importing it next
        'services/timesheet-service/timesheet-service.psm1', # Assuming you'll add this from Acta soon
        
        # Screens (depend on everything else)
        'screens/dashboard-screen/dashboard-screen.psm1',
        'screens/task-list-screen/task-list-screen.psm1',
        'screens/task-flow-screen/task-flow-screen.psm1', # New Kanban screen
        'screens/explorer-screen/explorer-screen.psm1',    # New File Explorer screen
        'screens/timesheet-screen/timesheet-screen.psm1',  # New TimeSheet screen

        # Global commands (depend on services)
        'commands/global-commands.psm1', # New global commands

        # TUI Framework/Engine (orchestrates everything)
        'modules/tui-framework/tui-framework.psm1',
        'modules/tui-engine/tui-engine.psm1'
    )
    # ... rest of run.ps1 remains similar ...
    ```

2.  **Ensure `ServiceContainer` is passed to `Screen` Constructors:**
    *   The `Screen` constructor (and thus `ScreenFactory`) now consistently expects a `[hashtable]$services` (representing your `ServiceContainer`). Ensure all your existing `Screen` subclasses (Dashboard, TaskList) call `base($name, $services)` in their constructors.

3.  **Refactor Existing Components to Use New `UIElement`/`Panel` Methods:**
    *   **`OnInitialize` for Child Creation**: Move logic for creating child components from constructors into `OnInitialize`. This ensures children are created when the component is part of an active UI tree.
    *   **`Cleanup` for Resource Release**: Implement `OnCleanup()` in components that subscribe to events or hold other disposable resources. Remember `Screen.Cleanup()` now calls `([UIElement]$this).Cleanup()` which recursively cleans up children.
    *   **Consistent `OnResize`**: Ensure components properly handle their own resizing within `OnResize`, especially if they contain nested elements or complex layouts.
    *   **Panel Children Layout**: Review components that add children to `Panel`s. Ensure they add children to the `Panel` itself, and rely on `Panel.PerformLayout()` (or manually `Move`/`Resize` children) to position them within the `Panel`'s `ContentX`/`ContentY` area. The `Panel._RenderContent` now handles blending children into its content area correctly.

This phase significantly improves the architectural cleanliness and resource management of your TUI framework. It's a critical step for building robust and scalable PowerShell TUI applications.



Okay, let's proceed with the fourth significant improvement to pull from "Project Acta" into "Axiom-Phoenix." This focuses on modernizing your data models and enhancing the core `DataManager` for resilience and event integration.

---

### Improvement 4: Modernized Data Models & Enhanced Data Manager

**1. Explanation of Value:**

This set of changes overhauls your application's data layer, making it more robust, type-safe, and integrated with the broader framework:

*   **Standardized Data Models (`PmcTask`, `PmcProject`)**:
    *   **Proper Constructors**: Models have clear constructors for initialization.
    *   **Built-in Validation**: `ValidationBase` provides a mechanism for simple, reusable input validation within the models.
    *   **Type Safety**: Use of `[Nullable[datetime]]` and `enum` types for better data integrity.
    *   **Serialization/Deserialization**: `ToLegacyFormat()` and `FromLegacyFormat()` methods are provided for consistent serialization (e.g., to JSON for persistence).
*   **Centralized `DataManager` (`modules\data-manager\data-manager.psm1`)**:
    *   **Unified Data Store**: The `_dataStore` now centralizes all application data types (`Projects`, `Tasks`, `TimeEntries`, `ActiveTimers`, `Settings`, etc.).
    *   **Resilient Data Loading**: The `LoadData()` method includes `try/catch` blocks for *each individual record* during deserialization. If a single record is corrupted in the JSON file, it logs a warning and skips that record, allowing the rest of the data to load without crashing the entire application. This is a crucial hardening measure.
    *   **Automatic Backups**: `SaveData()` now automatically creates timestamped backups before overwriting the main data file and cleans up old backups.
    *   **Event-Driven Updates**: All CRUD operations (`AddTask`, `UpdateTask`, `RemoveTask`) publish `Tasks.Changed` or `Projects.Changed` events. This is fundamental for decoupling the data layer from the UI, allowing UI components to react to data changes without directly querying the `DataManager` on every render.
    *   **Transactional Updates (Optional, if you wish to re-add)**: The Acta monolith also showed transactional update support (`BeginUpdate`/`EndUpdate`) to defer saves until a batch of operations is complete. The provided snippet doesn't include it fully, but it's a good pattern to consider.
    *   **Default Data Initialization**: If no data file is found, the `DataManager` initializes with some sample data, making the first-run experience smoother.

**2. Relevant Code to Pull:**

You'll need to **replace or heavily modify** the following files in your Axiom-Phoenix structure:

*   `modules\models\models.psm1` (Full Replacement)
*   `modules\data-manager\data-manager.psm1` (Full Replacement)

---

**Code Block 1: `modules\models\models.psm1` (Full Replacement)**

This replaces your existing `modules\models\models.psm1` file.

```powershell
# ==============================================================================
# PMC Terminal v5 - Core Data Models
# Defines all core business entity classes with built-in validation and improved diagnostics.
# ==============================================================================

using namespace System.Management.Automation # For CmdletBinding, Parameter, Validate...
using namespace System # For Nullable, DateTime, Guid, Math, etc.
using namespace System.Collections # For Hashtable
using namespace System.Collections.Generic # For List in some contexts

#region Enums

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

enum BillingType {
    Billable
    NonBillable
}

#endregion

#region Base Validation Class

# Provides common validation methods used across model classes.
class ValidationBase {
    # Validates that a string value is not null, empty, or whitespace.
    # Throws an ArgumentException if the validation fails.
    static [void] ValidateNotEmpty(
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$value,
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$parameterName
    ) {
        try {
            if ([string]::IsNullOrWhiteSpace($value)) {
                $errorMessage = "Parameter '$($parameterName)' cannot be null or empty."
                # Write-Error here for immediate feedback if this is called directly as a cmdlet.
                # In normal class usage, the thrown exception is usually sufficient.
                # Write-Error $errorMessage -ErrorAction Stop # Can be very noisy for class internal validation
                throw [System.ArgumentException]::new($errorMessage, $parameterName)
            }
            Write-Verbose "ValidationBase::ValidateNotEmpty: Parameter '$($parameterName)' passed validation."
        }
        catch {
            # Log and re-throw to ensure calling context handles the exception.
            # Using Write-Warning here as an internal validation failure might not be a 'system' error.
            Write-Warning "ValidationBase::ValidateNotEmpty failed for parameter '$($parameterName)': $($_.Exception.Message)"
            throw # Re-throw to ensure the original exception propagates.
        }
    }
}

#endregion

#region Core Model Classes

# Represents a single task with various attributes and lifecycle methods.
class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString() # Unique identifier for the task
    [string]$Title                            # Short descriptive title
    [string]$Description                      # Detailed description
    [TaskStatus]$Status = [TaskStatus]::Pending # Current status of the task
    [TaskPriority]$Priority = [TaskPriority]::Medium # Importance level
    [string]$ProjectKey = "General"           # Associated project (key)
    [string]$Category                         # Alias for ProjectKey, for broader use
    [datetime]$CreatedAt = [datetime]::Now   # Timestamp of creation
    [datetime]$UpdatedAt = [datetime]::Now   # Last update timestamp
    [Nullable[datetime]]$DueDate             # Optional due date
    [string[]]$Tags = @()                     # Array of tags
    [int]$Progress = 0                        # Progress percentage (0-100)
    [bool]$Completed = $false                 # Convenience flag for completed status

    # Default constructor: Initializes a new task with default values.
    PmcTask() {
        Write-Verbose "PmcTask: Default constructor called. ID: $($this.Id)"
    }
    
    # Constructor: Initializes a new task with a title.
    PmcTask([Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$title) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title
        $this.Category = $this.ProjectKey # Initialize category with default project key
        Write-Verbose "PmcTask: Created task with title '$title'. ID: $($this.Id)"
    }
    
    # Constructor: Initializes a new task with common detailed properties.
    PmcTask(
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$title,
        [string]$description, # Can be empty or null
        [Parameter(Mandatory)][ValidateSet("Low", "Medium", "High")][TaskPriority]$priority,
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$projectKey
    ) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")

        $this.Title = $title
        $this.Description = $description
        $this.Priority = $priority
        $this.ProjectKey = $projectKey
        $this.Category = $projectKey # Category is often an alias for ProjectKey
        Write-Verbose "PmcTask: Created detailed task '$title' for project '$projectKey'. ID: $($this.Id)"
    }

    # New constructor overload from Acta monolith that includes DueDate and Status as strings
    PmcTask(
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$title,
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$projectKey,
        [Parameter(Mandatory)][ValidateSet("Low", "Medium", "High")][string]$priority, # String for enum conversion
        [datetime]$dueDate, # DateTime type directly
        [Parameter(Mandatory)][ValidateSet("Pending", "InProgress", "Completed", "Cancelled")][string]$status # String for enum conversion
    ) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")
        $this.Title = $title
        $this.ProjectKey = $projectKey
        $this.Category = $projectKey
        
        try { $this.Priority = [TaskPriority]::$priority }
        catch { 
            Write-Warning "PmcTask: Invalid priority '$priority'. Defaulting to Medium." 
            $this.Priority = [TaskPriority]::Medium 
        }
        
        $this.DueDate = $dueDate # Nullable handles if it's MinValue or not set
        
        try { $this.Status = [TaskStatus]::$status }
        catch { 
            Write-Warning "PmcTask: Invalid status '$status'. Defaulting to Pending." 
            $this.Status = [TaskStatus]::Pending 
        }
        
        # Set Completed flag based on status
        $this.Completed = ($this.Status -eq [TaskStatus]::Completed)
        $this.Progress = if ($this.Completed) { 100 } elseif ($this.Status -eq [TaskStatus]::InProgress) { 50 } else { 0 }
        
        Write-Verbose "PmcTask: Created task '$title' with specific status/due date. ID: $($this.Id)"
    }


    # Complete: Marks the task as completed, setting progress to 100% and updating timestamp.
    [void] Complete() {
        $this.Status = [TaskStatus]::Completed
        $this.Completed = $true
        $this.Progress = 100
        $this.UpdatedAt = [datetime]::Now
        Write-Verbose "PmcTask '$($this.Id)': Marked as Completed."
    }

    # UpdateProgress: Updates the task's progress and adjusts status accordingly.
    # Throws an ArgumentOutOfRangeException if newProgress is outside 0-100.
    [void] UpdateProgress([Parameter(Mandatory)][ValidateRange(0, 100)][int]$newProgress) {
        try {
            $this.Progress = $newProgress
            # Update status based on progress: Completed (100), InProgress (>0), Pending (0)
            $this.Status = switch ($newProgress) {
                100 { [TaskStatus]::Completed }
                { $_ -gt 0 } { [TaskStatus]::InProgress }
                default { [TaskStatus]::Pending }
            }
            $this.Completed = ($this.Status -eq [TaskStatus]::Completed)
            $this.UpdatedAt = [datetime]::Now
            Write-Verbose "PmcTask '$($this.Id)': Progress updated to $($newProgress)% (Status: $($this.Status))."
        }
        catch {
            # Throwing a proper exception type for out-of-range arguments
            throw [System.ArgumentOutOfRangeException]::new("newProgress", $newProgress, "Progress must be between 0 and 100.")
        }
    }

    # GetDueDateString: Returns the due date as a formatted string, or "N/A" if null.
    [string] GetDueDateString() {
        $dueDateString = $this.DueDate ? $this.DueDate.Value.ToString("yyyy-MM-dd") : "N/A"
        Write-Verbose "PmcTask '$($this.Id)': DueDate string is '$dueDateString'."
        return $dueDateString
    }

    # ToLegacyFormat: Converts the PmcTask object to a hashtable compatible with older data structures (JSON serialization).
    [hashtable] ToLegacyFormat() {
        $legacyData = @{
            id = $this.Id
            title = $this.Title
            description = $this.Description
            completed = $this.Completed
            priority = $this.Priority.ToString() # Convert enum to string (e.g., "Medium")
            project = $this.ProjectKey
            category = $this.Category # Ensure category is included
            status = $this.Status.ToString() # New: Include Status
            progress = $this.Progress # New: Include Progress
            due_date = $this.DueDate ? $this.GetDueDateString() : $null
            created_at = $this.CreatedAt.ToString("o") # ISO 8601 format
            updated_at = $this.UpdatedAt.ToString("o")
            tags = $this.Tags # Include tags
        }
        Write-Verbose "PmcTask '$($this.Id)': Converted to legacy format."
        return $legacyData
    }

    # FromLegacyFormat: Static method to create a PmcTask object from a legacy hashtable format.
    static [PmcTask] FromLegacyFormat([Parameter(Mandatory)][ValidateNotNull()][hashtable]$legacyData) {
        $task = [PmcTask]::new() # Start with a default PmcTask instance
        
        # Populate properties, using null-coalescing where appropriate
        $task.Id = $legacyData.id ?? $task.Id
        $task.Title = $legacyData.title ?? "" # Ensure title is not null
        $task.Description = $legacyData.description ?? ""

        # Handle priority conversion with error handling
        if ($legacyData.priority) {
            try {
                $task.Priority = [TaskPriority]::$($legacyData.priority)
            } catch {
                Write-Warning "PmcTask.FromLegacyFormat: Could not parse priority '$($legacyData.priority)' for task ID '$($task.Id)'. Using default 'Medium'. Error: $($_.Exception.Message)"
                $task.Priority = [TaskPriority]::Medium # Fallback to default
            }
        }
        
        $task.ProjectKey = $legacyData.project ?? $legacyData.Category ?? "General"
        $task.Category = $task.ProjectKey
        
        # Handle status conversion
        if ($legacyData.status) {
            try {
                $task.Status = [TaskStatus]::$($legacyData.status)
            } catch {
                Write-Warning "PmcTask.FromLegacyFormat: Could not parse status '$($legacyData.status)' for task ID '$($task.Id)'. Using default 'Pending'. Error: $($_.Exception.Message)"
                $task.Status = [TaskStatus]::Pending
            }
        }

        # Handle progress
        if ($legacyData.progress -ne $null) {
            try { $task.Progress = [int]$legacyData.progress }
            catch { Write-Warning "PmcTask.FromLegacyFormat: Could not parse progress '$($legacyData.progress)' for task ID '$($task.Id)'. Using 0." }
        }

        # Handle datetime conversions with error handling
        if ($legacyData.created_at) {
            try {
                $task.CreatedAt = [datetime]::Parse($legacyData.created_at)
            } catch {
                Write-Warning "PmcTask.FromLegacyFormat: Could not parse CreatedAt '$($legacyData.created_at)' for task ID '$($task.Id)'. Using current time. Error: $($_.Exception.Message)"
                $task.CreatedAt = [datetime]::Now # Fallback to current time
            }
        }
        
        if ($legacyData.updated_at) {
            try {
                $task.UpdatedAt = [datetime]::Parse($legacyData.updated_at)
            } catch {
                Write-Warning "PmcTask.FromLegacyFormat: Could not parse UpdatedAt '$($legacyData.updated_at)' for task ID '$($task.Id)'. Using CreatedAt. Error: $($_.Exception.Message)"
                $task.UpdatedAt = $task.CreatedAt # Fallback to CreatedAt
            }
        } else {
            $task.UpdatedAt = $task.CreatedAt # Default to CreatedAt if no UpdatedAt in legacy
        }
        
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") {
            try {
                # Handle ISO 8601 or other common date formats for parsing
                $task.DueDate = [DateTime]::Parse($legacyData.due_date, [System.Globalization.CultureInfo]::InvariantCulture, [System.Globalization.DateTimeStyles]::AssumeLocal)
            } catch {
                Write-Warning "PmcTask.FromLegacyFormat: Could not parse DueDate '$($legacyData.due_date)' for task ID '$($task.Id)'. Setting to null. Error: $($_.Exception.Message)"
                $task.DueDate = $null # Fallback to null
            }
        } else {
            $task.DueDate = $null # Explicitly set to null if N/A or not present
        }

        # Handle 'completed' flag for backward compatibility
        if ($legacyData.completed -is [bool]) {
            $task.Completed = $legacyData.completed
            # Ensure Status and Progress are consistent with this flag if it overrides.
            if ($task.Completed -and $task.Status -ne [TaskStatus]::Completed) {
                $task.Status = [TaskStatus]::Completed
                $task.Progress = 100
            } elseif (-not $task.Completed -and $task.Status -eq [TaskStatus]::Completed) {
                # If completed is false but status is completed, revert status
                $task.Status = [TaskStatus]::Pending
                $task.Progress = 0
            }
        } else {
            # If no 'completed' flag, infer from status/progress, which is already done by default.
            $task.Completed = ($task.Status -eq [TaskStatus]::Completed)
        }

        # Handle tags
        if ($legacyData.tags -is [array]) { $task.Tags = @($legacyData.tags) }
        elseif ($legacyData.tags -is [string]) { $task.Tags = @($legacyData.tags) } # Handle single tag as string
        else { $task.Tags = @() }
        
        Write-Verbose "PmcTask.FromLegacyFormat: Converted legacy data for task ID '$($task.Id)'."
        return $task
    }

    # ToString: Provides a human-readable string representation of the PmcTask object.
    [string] ToString() {
        return "PmcTask(ID: $($this.Id.Substring(0, 8)), Title: '$($this.Title)', Status: $($this.Status), Priority: $($this.Priority))"
    }
}

# Represents a project with various attributes.
class PmcProject : ValidationBase {
    [string]$Key = ([Guid]::NewGuid().ToString().Split('-')[0]).ToUpper() # Unique short key (e.g., "ABCD123")
    [string]$Name                                                    # Full project name
    [string]$Description = ""                                        # New: Add description field
    [string]$Client = ""                                             # Client associated with the project
    [BillingType]$BillingType = [BillingType]::NonBillable           # Billing status
    [double]$Rate = 0.0                                             # Billing rate per hour/unit
    [double]$Budget = 0.0                                           # Project budget
    [bool]$Active = $true                                           # Is the project currently active?
    [datetime]$CreatedAt = [datetime]::Now                         # Timestamp of creation
    [datetime]$UpdatedAt = [datetime]::Now                         # Last update timestamp

    # Default constructor: Initializes a new project with default values.
    PmcProject() {
        Write-Verbose "PmcProject: Default constructor called. Key: $($this.Key)"
    }
    
    # Constructor: Initializes a new project with a key and name.
    PmcProject(
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$key,
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$name
    ) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key.ToUpper() # Ensure key is always uppercase
        $this.Name = $name
        Write-Verbose "PmcProject: Created project '$name' with key '$key'."
    }

    # Constructor from Acta: (name, description) -- this is ambiguous with (key, name)
    # Replaced this with a single comprehensive constructor or reliance on property setting.
    # The monolith provided: PmcProject([string]$name, [string]$description) { $this.Name = $name }
    # This specific overload from Acta in the monolith is problematic as it overlaps with the more logical key/name.
    # We will assume you want to use the key/name constructor and set description via property after.

    # ToLegacyFormat: Converts the PmcProject object to a hashtable compatible with older data structures.
    [hashtable] ToLegacyFormat() {
        $legacyData = @{
            Key = $this.Key
            Name = $this.Name
            Description = $this.Description # Include new description field
            Client = $this.Client
            BillingType = $this.BillingType.ToString() # Convert enum to string
            Rate = $this.Rate
            Budget = $this.Budget
            Active = $this.Active
            CreatedAt = $this.CreatedAt.ToString("o") # ISO 8601 format
            UpdatedAt = $this.UpdatedAt.ToString("o") # Include UpdatedAt for consistency
        }
        Write-Verbose "PmcProject '$($this.Key)': Converted to legacy format."
        return $legacyData
    }

    # FromLegacyFormat: Static method to create a PmcProject object from a legacy hashtable format.
    static [PmcProject] FromLegacyFormat([Parameter(Mandatory)][ValidateNotNull()][hashtable]$legacyData) {
        $project = [PmcProject]::new() # Start with a default PmcProject instance
        
        # Populate properties, using null-coalescing where appropriate
        $project.Key = ($legacyData.Key ?? $project.Key).ToUpper() # Key from legacy, or default
        $project.Name = $legacyData.Name ?? ""
        $project.Description = $legacyData.Description ?? "" # Populate new description field
        $project.Client = $legacyData.Client ?? ""
        
        if ($legacyData.Rate -ne $null) {
            try { $project.Rate = [double]$legacyData.Rate }
            catch { Write-Warning "PmcProject.FromLegacyFormat: Could not parse Rate '$($legacyData.Rate)' for project '$($project.Key)'. Using 0.0. Error: $($_.Exception.Message)" }
        }
        
        if ($legacyData.Budget -ne $null) {
            try { $project.Budget = [double]$legacyData.Budget }
            catch { Write-Warning "PmcProject.FromLegacyFormat: Could not parse Budget '$($legacyData.Budget)' for project '$($project.Key)'. Using 0.0. Error: $($_.Exception.Message)" }
        }
        
        if ($legacyData.Active -is [bool]) {
            $project.Active = $legacyData.Active
        }
        
        # Handle BillingType conversion with error handling
        if ($legacyData.BillingType) {
            try {
                $project.BillingType = [BillingType]::$($legacyData.BillingType)
            } catch {
                Write-Warning "PmcProject.FromLegacyFormat: Could not parse BillingType '$($legacyData.BillingType)' for project '$($project.Key)'. Using default 'NonBillable'. Error: $($_.Exception.Message)"
                $project.BillingType = [BillingType]::NonBillable # Fallback to default
            }
        }
        
        # Handle CreatedAt conversion with error handling
        if ($legacyData.CreatedAt) {
            try {
                $project.CreatedAt = [datetime]::Parse($legacyData.CreatedAt)
            } catch {
                Write-Warning "PmcProject.FromLegacyFormat: Could not parse CreatedAt '$($legacyData.CreatedAt)' for project '$($project.Key)'. Using current time. Error: $($_.Exception.Message)"
                $project.CreatedAt = [datetime]::Now # Fallback to current time
            }
        }
        
        if ($legacyData.UpdatedAt) {
             try {
                $project.UpdatedAt = [datetime]::Parse($legacyData.UpdatedAt)
            } catch {
                Write-Warning "PmcProject.FromLegacyFormat: Could not parse UpdatedAt '$($legacyData.UpdatedAt)' for project '$($project.Key)'. Using CreatedAt. Error: $($_.Exception.Message)"
                $project.UpdatedAt = $project.CreatedAt # Fallback to CreatedAt for consistency
            }
        } else {
            $project.UpdatedAt = $project.CreatedAt # Defaulting to CreatedAt for consistency
        }
        
        Write-Verbose "PmcProject.FromLegacyFormat: Converted legacy data for project key '$($project.Key)'."
        return $project
    }

    # ToString: Provides a human-readable string representation of the PmcProject object.
    [string] ToString() {
        return "PmcProject(Key: $($this.Key), Name: '$($this.Name)', Active: $($this.Active))"
    }
}

#endregion

# Export all public classes and enums so they are available when the module is imported.
Export-ModuleMember -Class PmcTask, PmcProject -Enum TaskStatus, TaskPriority, BillingType
```

---

**Code Block 2: `modules\data-manager\data-manager.psm1` (Full Replacement)**

This replaces your existing `modules\data-manager\data-manager.psm1` file.

```powershell
# ==============================================================================
# Data Manager Module - Axiom-Phoenix v5.0 Enhancement
# High-performance, transaction-safe, and lifecycle-aware data service.
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation # For CmdletBinding, Parameter, Validate...
using namespace System # For DateTime, Guid, etc.
using namespace System.Collections # For ArrayList, Hashtable

# The factory function for the DataManager.
function Initialize-DataManager {
    <#
    .SYNOPSIS
    Creates and returns a new DataManager instance.
    #>
    [CmdletBinding()]
    param()
    
    return Invoke-WithErrorHandling -Component "DataManager.Initialize" -Context "Creating DataManager instance" -ScriptBlock {
        Write-Verbose "DataManager: Initializing new instance."
        return [DataManager]::new()
    }
}

# The DataManager class is the single, encapsulated source of truth for all
# application data. It handles loading from and saving to disk, provides
# strongly-typed CRUD methods, and integrates with the event system to
# notify other components of data changes. Direct access to its internal
# data store is prevented, enforcing predictable and safe data flow.
class DataManager : IDisposable {
    #region Private State
    # Main data store as a hashtable holding ArrayLists for collections
    hidden [hashtable] $_dataStore
    hidden [string] $_dataFilePath
    hidden [string] $_backupPath
    hidden [datetime] $_lastSaveTime
    hidden [bool] $_dataModified = $false
    
    # Internal tracking for event subscriptions, for cleanup
    hidden [System.Collections.Generic.Dictionary[string, string]] $_eventSubscriptions 
    #endregion

    #region Constructor and Initialization
    DataManager() {
        $this.{_dataStore} = @{
            # Using ArrayLists for mutable collections that can be modified in-place
            Projects = [System.Collections.ArrayList]::new()
            Tasks = [System.Collections.ArrayList]::new()
            
            # Additional data types from Acta
            TimeEntries = [System.Collections.ArrayList]::new() # Could be objects representing time entries
            ActiveTimers = [System.Collections.Hashtable]::new() # For ongoing timers
            TodoTemplates = [System.Collections.Hashtable]::new() # For reusable task templates
            
            # Settings managed by DataManager
            Settings = @{ 
                DefaultView = "Dashboard"
                Theme = "Modern"
                AutoSave = $true
                BackupCount = 5
            }
            # Add explicit properties for compatibility with older code (e.g. TimesheetService in Acta)
            time_entries = $this.{_dataStore}.TimeEntries
            timers = $this.{_dataStore}.ActiveTimers
        }
        
        # Set up file paths in user's local app data directory
        $baseDir = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal"
        $this.{_dataFilePath} = Join-Path $baseDir "pmc-data.json"
        $this.{_backupPath} = Join-Path $baseDir "backups"

        # Initialize event subscriptions tracking
        $this.{_eventSubscriptions} = [System.Collections.Generic.Dictionary[string, string]]::new()

        Invoke-WithErrorHandling -Component "DataManager.Constructor" -Context "DataManager initialization" -ScriptBlock {
            # Ensure base directories exist
            if (-not (Test-Path $baseDir)) {
                New-Item -ItemType Directory -Path $baseDir -Force | Out-Null
                Write-Log -Level Info -Message "Created base data directory: $baseDir"
            }
            if (-not (Test-Path $this.{_backupPath})) {
                New-Item -ItemType Directory -Path $this.{_backupPath} -Force | Out-Null
                Write-Log -Level Info -Message "Created backup directory: $($this.{_backupPath})"
            }

            $this.LoadData()
            $this.InitializeEventHandlers()
            
            Write-Log -Level Info -Message "DataManager initialized successfully." -Data @{
                DataPath = $this.{_dataFilePath}
                BackupPath = $this.{_backupPath}
                TaskCount = $this.{_dataStore}.Tasks.Count
                ProjectCount = $this.{_dataStore}.Projects.Count
            }
        }
    }

    # Loads data from the JSON file, handling corruption gracefully.
    hidden [void] LoadData() {
        Invoke-WithErrorHandling -Component "DataManager.LoadData" -Context "Loading data from file" -ScriptBlock {
            if (Test-Path $this.{_dataFilePath}) {
                try {
                    $jsonData = Get-Content $this.{_dataFilePath} -Raw | ConvertFrom-Json -AsHashtable
                    
                    # --- HARDENING: Resilient Deserialization for Collections ---
                    # Iterate collections and try to parse each item, skipping corrupted ones.
                    if ($jsonData.ContainsKey('Tasks') -and $jsonData.Tasks -is [array]) {
                        $this.{_dataStore}.Tasks.Clear()
                        $taskIdx = 0
                        foreach ($taskData in $jsonData.Tasks) {
                            try {
                                if ($taskData -isnot [hashtable]) { throw "Task record is not a valid hashtable." }
                                $task = [PmcTask]::FromLegacyFormat($taskData)
                                [void]$this.{_dataStore}.Tasks.Add($task)
                            } catch {
                                Write-Log -Level Warning -Message "Skipping corrupted task record at index $taskIdx in data file. Error: $($_.Exception.Message)"
                            }
                            $taskIdx++
                        }
                    }
                    
                    if ($jsonData.ContainsKey('Projects') -and $jsonData.Projects -is [hashtable]) { # Projects are now a hashtable by key
                        $this.{_dataStore}.Projects.Clear()
                        foreach ($projectKey in $jsonData.Projects.Keys) {
                            $projectData = $jsonData.Projects[$projectKey]
                            try {
                                if ($projectData -isnot [hashtable]) { throw "Project record is not a valid hashtable." }
                                $project = [PmcProject]::FromLegacyFormat($projectData)
                                [void]$this.{_dataStore}.Projects.Add($project)
                            } catch {
                                Write-Log -Level Warning -Message "Skipping corrupted project record for key '$projectKey' in data file. Error: $($_.Exception.Message)"
                            }
                        }
                    }

                    if ($jsonData.ContainsKey('TimeEntries') -and $jsonData.TimeEntries -is [array]) {
                        $this.{_dataStore}.TimeEntries.Clear()
                        $entryIdx = 0
                        foreach ($entryData in $jsonData.TimeEntries) {
                            try {
                                # Assuming TimeEntry is a simple hashtable; validate structure if a class is introduced
                                if ($entryData -isnot [hashtable]) { throw "Time entry record is not a valid hashtable." }
                                [void]$this.{_dataStore}.TimeEntries.Add($entryData)
                            } catch {
                                Write-Log -Level Warning -Message "Skipping corrupted time entry record at index $entryIdx in data file. Error: $($_.Exception.Message)"
                            }
                            $entryIdx++
                        }
                    }

                    if ($jsonData.ContainsKey('ActiveTimers') -and $jsonData.ActiveTimers -is [hashtable]) {
                        $this.{_dataStore}.ActiveTimers.Clear()
                        foreach ($timerKey in $jsonData.ActiveTimers.Keys) {
                            $timerData = $jsonData.ActiveTimers[$timerKey]
                            try {
                                # Validate timerData structure if a class is introduced
                                if ($timerData -isnot [hashtable]) { throw "Active timer record is not a valid hashtable." }
                                $this.{_dataStore}.ActiveTimers[$timerKey] = $timerData
                            } catch {
                                Write-Log -Level Warning -Message "Skipping corrupted active timer record for key '$timerKey' in data file. Error: $($_.Exception.Message)"
                            }
                        }
                    }

                    if ($jsonData.ContainsKey('Settings') -and $jsonData.Settings -is [hashtable]) {
                        foreach ($key in $jsonData.Settings.Keys) {
                            $this.{_dataStore}.Settings[$key] = $jsonData.Settings[$key]
                        }
                    }
                    # --- END HARDENING ---
                    
                    $this.{_lastSaveTime} = [datetime]::Now
                    Write-Log -Level Info -Message "Loaded data from '$($this.{_dataFilePath})'."
                } catch {
                    Write-Log -Level Error -Message "Failed to parse data file '$($this.{_dataFilePath})': $($_.Exception.Message). Starting with empty or default data."
                    # On severe parse error, clear existing data to prevent partial/corrupted state
                    $this.{_dataStore}.Tasks.Clear()
                    $this.{_dataStore}.Projects.Clear()
                    $this.{_dataStore}.TimeEntries.Clear()
                    $this.{_dataStore}.ActiveTimers.Clear()
                }
            } else {
                Write-Log -Level Info -Message "No existing data file found. Initializing with default data."
                $this._InitializeDefaultData()
            }
        }
    }
    
    # Initializes default sample data if no file exists.
    hidden [void] _InitializeDefaultData() {
        # Clear existing to ensure clean defaults
        $this.{_dataStore}.Tasks.Clear()
        $this.{_dataStore}.Projects.Clear()

        # Add default project first to ensure it exists for tasks
        $defaultProject = [PmcProject]::new("DEFAULT", "Default Project")
        $defaultProject.Description = "Tasks that don't belong to a specific project."
        [void]$this.{_dataStore}.Projects.Add($defaultProject)

        # Add sample tasks
        [void]$this.{_dataStore}.Tasks.Add([PmcTask]::new("Setup Project Acta Environment", "Install PowerShell, clone repo, set up modules.", [TaskPriority]::High, "DEFAULT"))
        [void]$this.{_dataStore}.Tasks.Add([PmcTask]::new("Review Project Acta Codebase", "Familiarize with code structure, services, and UI components.", [TaskPriority]::Medium, "DEFAULT"))
        $completedTask = [PmcTask]::new("Initial Setup Complete", "Verify all dependencies are met and basic TUI loads.", [TaskPriority]::Low, "DEFAULT")
        $completedTask.Complete()
        [void]$this.{_dataStore}.Tasks.Add($completedTask)

        $overdueTask = [PmcTask]::new("Write Demo Script", "Create a short script to showcase key features.", [TaskPriority]::High, "DEFAULT", (Get-Date).AddDays(-2), "InProgress")
        [void]$this.{_dataStore}.Tasks.Add($overdueTask)

        $futureTask = [PmcTask]::new("Plan Feature X", "Brainstorm ideas for future enhancements.", [TaskPriority]::Low, "DEFAULT", (Get-Date).AddDays(7), "Pending")
        [void]$this.{_dataStore}.Tasks.Add($futureTask)

        # Mark data as modified so it gets saved on first exit
        $this.{_dataModified} = $true 
    }

    # Saves current data to the JSON file, performing backups.
    hidden [void] SaveData() {
        Invoke-WithErrorHandling -Component "DataManager.SaveData" -Context "Saving unified data to disk" -ScriptBlock {
            # Create backup before saving
            $this.CreateBackup()
            
            # Prepare data for serialization
            # Projects are serialized as a hashtable where key is Project.Key
            $projectsToSave = [System.Collections.Hashtable]::new()
            foreach ($proj in $this.{_dataStore}.Projects) {
                $projectsToSave[$proj.Key] = $proj.ToLegacyFormat()
            }

            $dataToSave = @{
                Tasks = @($this.{_dataStore}.Tasks | ForEach-Object { $_.ToLegacyFormat() })
                Projects = $projectsToSave
                TimeEntries = @($this.{_dataStore}.TimeEntries)
                ActiveTimers = @($this.{_dataStore}.ActiveTimers) # Serialize as array or handle deeper if needed
                TodoTemplates = @($this.{_dataStore}.TodoTemplates)
                Settings = $this.{_dataStore}.Settings.Clone()
                SavedAt = [datetime]::Now
            }
            
            # Save to file
            $dataToSave | ConvertTo-Json -Depth 10 | Set-Content -Path $this.{_dataFilePath} -Encoding UTF8 -Force
            $this.{_lastSaveTime} = [datetime]::Now
            $this.{_dataModified} = $false
            
            Write-Log -Level Debug -Message "Data saved successfully." -Data @{
                FilePath = $this.{_dataFilePath}
                TaskCount = $this.{_dataStore}.Tasks.Count
                ProjectCount = $this.{_dataStore}.Projects.Count
            }
        }
    }
    
    # Creates a timestamped backup of the current data file and cleans up old backups.
    hidden [void] CreateBackup() {
        try {
            if (Test-Path $this.{_dataFilePath}) {
                $timestamp = (Get-Date).ToString("yyyyMMdd-HHmmss")
                $backupFileName = "pmc-data-$timestamp.json"
                $backupFilePath = Join-Path $this.{_backupPath} $backupFileName
                
                Copy-Item -Path $this.{_dataFilePath} -Destination $backupFilePath -Force
                
                # Clean up old backups
                $backupCountLimit = $this.{_dataStore}.Settings.BackupCount
                $backups = Get-ChildItem -Path $this.{_backupPath} -Filter "pmc-data-*.json" | Sort-Object LastWriteTime -Descending
                if ($backups.Count -gt $backupCountLimit) {
                    $backupsToDelete = $backups | Select-Object -Skip $backupCountLimit
                    foreach ($backup in $backupsToDelete) {
                        Remove-Item -Path $backup.FullName -Force
                        Write-Verbose "DataManager: Removed old backup '$($backup.Name)'."
                    }
                }
                
                Write-Verbose "DataManager: Created backup '$backupFileName'."
            }
        } catch {
            Write-Warning "DataManager: Failed to create backup: $($_.Exception.Message)"
        }
    }
    
    # Initializes internal event handlers for DataManager.
    hidden [void] InitializeEventHandlers() {
        # Capture the current instance ($this) into a local variable ($self)
        # so the scriptblocks used for event handlers can access it reliably.
        $self = $this 
        
        Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -Context "Initializing data event handlers" -ScriptBlock {
            # Example: Handle a request to refresh all tasks (e.g., from a UI component)
            $subscriptionId = Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
                param($EventData)
                # When refresh is requested, re-publish the current state of tasks
                Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Refreshed"; Tasks = @($self.{_dataStore}.Tasks) }
            } -Source $this.Name
            $this.{_eventSubscriptions}["Tasks.RefreshRequested"] = $subscriptionId

            Write-Log -Level Debug -Message "Data event handlers initialized."
        }
    }
    #endregion
    
    #region Lifecycle Management (IDisposable)
    [void] Dispose() {
        Write-Log -Level Info -Message "DataManager disposing. Checking for unsaved data."
        
        # Unsubscribe all events managed by this DataManager instance
        foreach ($kvp in $this.{_eventSubscriptions}.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value
                Write-Verbose "DataManager: Unsubscribed event '$($kvp.Key)' (HandlerId: $($kvp.Value)) during dispose."
            } catch {
                Write-Warning "DataManager: Failed to unsubscribe event '$($kvp.Key)' during dispose: $($_.Exception.Message)"
            }
        }
        $this.{_eventSubscriptions}.Clear()

        # Force save on dispose if data was modified
        if ($this.{_dataModified}) {
            try {
                $this.SaveData()
                Write-Log -Level Info -Message "Performed final save of modified data during dispose."
            } catch {
                Write-Warning "DataManager: Failed to save data during dispose: $($_.Exception.Message)"
            }
        }
        Write-Verbose "DataManager: Dispose complete."
    }
    #endregion

    #region Task Management Methods
    # Adds a new task with specified properties.
    [PmcTask] AddTask(
        [Parameter(Mandatory)][string]$Title,
        [string]$Description = "",
        [Parameter(Mandatory)][ValidateSet("Low", "Medium", "High")][string]$Priority,
        [Parameter(Mandatory)][string]$ProjectKey,
        [string]$DueDate = "" # Optional, string format to be parsed
    ) {
        return Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task" -AdditionalData @{ Title = $Title; Project = $ProjectKey } -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($Title)) { throw [System.ArgumentException]::new("Task title cannot be empty.") }
            if ([string]::IsNullOrWhiteSpace($ProjectKey)) { throw [System.ArgumentException]::new("Project key cannot be empty.") }

            # Create a new PmcTask instance
            $newTask = [PmcTask]::new($Title, $Description, [TaskPriority]::$Priority, $ProjectKey)
            
            # Parse DueDate if provided
            if (-not [string]::IsNullOrWhiteSpace($DueDate) -and $DueDate -ne "N/A") {
                try {
                    $newTask.DueDate = [DateTime]::Parse($DueDate) # Use Parse for flexibility
                } catch {
                    Write-Warning "DataManager: Invalid DueDate format '$DueDate' for new task '$Title'. DueDate will be null. Error: $($_.Exception.Message)"
                    $newTask.DueDate = $null
                }
            }
            
            [void]$this.{_dataStore}.Tasks.Add($newTask)
            $this.{_dataModified} = $true
            
            # Save data if auto-save is enabled
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            
            # Publish event for UI updates
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Created"; Task = $newTask }
            
            Write-Verbose "DataManager: Added task '$($newTask.Title)' with ID '$($newTask.Id)'."
            return $newTask
        }
    }

    # Updates an existing task with new properties provided in a hashtable.
    [PmcTask] UpdateTask([Parameter(Mandatory)][hashtable]$UpdateParameters) {
        return Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating task" -AdditionalData @{ TaskId = $UpdateParameters.Id } -ScriptBlock {
            if (-not $UpdateParameters.ContainsKey('Id')) { throw [System.ArgumentException]::new("UpdateParameters must contain an 'Id' for the task to update.") }
            
            $taskId = $UpdateParameters.Id
            $managedTask = $this.{_dataStore}.Tasks.Find({$_.Id -eq $taskId})
            
            if (-not $managedTask) { throw [System.InvalidOperationException]::new("Task with ID '$taskId' not found for update.") }
            
            $updatedFields = [System.Collections.Generic.List[string]]::new()

            # Apply updates only if the key exists in UpdateParameters
            if ($UpdateParameters.ContainsKey('Title')) { $managedTask.Title = $UpdateParameters.Title.Trim(); [void]$updatedFields.Add("Title") }
            if ($UpdateParameters.ContainsKey('Description')) { $managedTask.Description = $UpdateParameters.Description; [void]$updatedFields.Add("Description") }
            if ($UpdateParameters.ContainsKey('Priority')) { 
                try { $managedTask.Priority = [TaskPriority]::$($UpdateParameters.Priority) }
                catch { Write-Warning "DataManager: Invalid Priority update '$($UpdateParameters.Priority)' for task '$taskId'. Skipping." }
                [void]$updatedFields.Add("Priority") 
            }
            if ($UpdateParameters.ContainsKey('ProjectKey')) { $managedTask.ProjectKey = $UpdateParameters.ProjectKey; $managedTask.Category = $UpdateParameters.ProjectKey; [void]$updatedFields.Add("ProjectKey") }
            if ($UpdateParameters.ContainsKey('Tags')) { $managedTask.Tags = @($UpdateParameters.Tags); [void]$updatedFields.Add("Tags") }
            
            # Handle DueDate update (supports null to clear)
            if ($UpdateParameters.ContainsKey('DueDate')) {
                if ($UpdateParameters.DueDate -and $UpdateParameters.DueDate -ne "N/A" -and $UpdateParameters.DueDate -isnot [DateTime]::MinValue) {
                    try { $managedTask.DueDate = [DateTime]::Parse($UpdateParameters.DueDate.ToString()) }
                    catch { Write-Warning "DataManager: Invalid DueDate update '$($UpdateParameters.DueDate)' for task '$taskId'. DueDate not updated." }
                } else {
                    $managedTask.DueDate = $null # Clear DueDate
                }
                [void]$updatedFields.Add("DueDate")
            }
            
            # Handle Status and Progress updates
            if ($UpdateParameters.ContainsKey('Status')) {
                try { $managedTask.Status = [TaskStatus]::$($UpdateParameters.Status) }
                catch { Write-Warning "DataManager: Invalid Status update '$($UpdateParameters.Status)' for task '$taskId'. Skipping." }
                [void]$updatedFields.Add("Status")
            }
            
            if ($UpdateParameters.ContainsKey('Progress')) { 
                try { $managedTask.UpdateProgress($UpdateParameters.Progress) } # Uses PmcTask's method which updates Status/Completed
                catch { Write-Warning "DataManager: Invalid Progress update '$($UpdateParameters.Progress)' for task '$taskId'. Skipping." }
                [void]$updatedFields.Add("Progress")
            }
            
            # Handle direct 'Completed' flag for convenience (updates status/progress internally)
            if ($UpdateParameters.ContainsKey('Completed')) {
                if ([bool]$UpdateParameters.Completed) { $managedTask.Complete() } else { $managedTask.Status = [TaskStatus]::Pending; $managedTask.Completed = $false; $managedTask.Progress = 0 }
                [void]$updatedFields.Add("Completed")
            }

            $managedTask.UpdatedAt = [datetime]::Now
            $this.{_dataModified} = $true
            
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Updated"; TaskId = $taskId; Task = $managedTask; UpdatedFields = $updatedFields.ToArray() }
            
            Write-Verbose "DataManager: Updated task '$($managedTask.Title)' (ID: '$taskId'). Fields updated: $($updatedFields -join ', ')"
            return $managedTask
        }
    }

    # Removes a task by its PmcTask object or ID.
    [bool] RemoveTask([Parameter(Mandatory)][object]$taskIdentifier) {
        return Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task" -AdditionalData @{ Identifier = $taskIdentifier.ToString() } -ScriptBlock {
            $taskId = if ($taskIdentifier -is [PmcTask]) { $taskIdentifier.Id } else { $taskIdentifier.ToString() }
            
            $taskToRemove = $this.{_dataStore}.Tasks.Find({$_.Id -eq $taskId})
            if (-not $taskToRemove) {
                Write-Warning "DataManager: Task with ID '$taskId' not found for removal."
                return $false
            }
            
            [void]$this.{_dataStore}.Tasks.Remove($taskToRemove)
            $this.{_dataModified} = $true
            
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Deleted"; TaskId = $taskId }
            
            Write-Verbose "DataManager: Removed task with ID '$taskId'."
            return $true
        }
    }
    
    # Retrieves a single task by ID.
    [PmcTask] GetTask([Parameter(Mandatory)][string]$taskId) {
        return $this.{_dataStore}.Tasks.Find({$_.Id -eq $taskId})
    }
    
    # Retrieves a filtered list of tasks.
    [PmcTask[]] GetTasks([bool]$IncludeCompleted = $true, [string]$Priority = $null, [string]$ProjectKey = $null, [string[]]$Tags = $null, [int]$TopN = 0) {
        return Invoke-WithErrorHandling -Component "DataManager.GetTasks" -Context "Retrieving tasks" -ScriptBlock {
            $tasks = $this.{_dataStore}.Tasks | Where-Object { $_ -ne $null } # Filter out potential nulls from corrupted loads
            
            if (-not $IncludeCompleted) { $tasks = $tasks | Where-Object { -not $_.Completed } }
            if (-not [string]::IsNullOrWhiteSpace($Priority)) { 
                try { $priorityEnum = [TaskPriority]::$Priority; $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum } }
                catch { Write-Warning "DataManager.GetTasks: Invalid Priority filter '$Priority'. Skipping filter." }
            }
            if (-not [string]::IsNullOrWhiteSpace($ProjectKey)) { $tasks = $tasks | Where-Object { $_.ProjectKey -eq $ProjectKey } }
            
            if ($null -ne $Tags -and $Tags.Length -gt 0) {
                $tasks = $tasks | Where-Object { 
                    $taskTags = $_.Tags # Get tags for the current task
                    if ($null -eq $taskTags) { return $false } # No tags, no match
                    # Check if ANY of the filter tags are present in the task's tags
                    foreach ($tag in $Tags) {
                        if ($taskTags -contains $tag) { return $true }
                    }
                    return $false
                }
            }
            
            # Convert to array and sort (e.g., by DueDate, then Priority)
            $sortedTasks = @($tasks | Sort-Object { $_.DueDate ?? [datetime]::MaxValue }, Priority)
            
            # Apply TopN limit
            if ($TopN -gt 0) { $sortedTasks = $sortedTasks | Select-Object -First $TopN }
            
            return $sortedTasks
        }
    }
    #endregion
    
    #region Project Management Methods
    # Adds a new project.
    [PmcProject] AddProject([Parameter(Mandatory)][PmcProject]$newProject) {
        return Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding new project" -AdditionalData @{ ProjectKey = $newProject.Key; ProjectName = $newProject.Name } -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($newProject.Key)) { throw [System.ArgumentException]::new("Project Key is required.") }
            if ([string]::IsNullOrWhiteSpace($newProject.Name)) { throw [System.ArgumentException]::new("Project Name is required.") }

            # Check for duplicate key
            if ($this.{_dataStore}.Projects.Find({$_.Key -eq $newProject.Key})) {
                throw [System.InvalidOperationException]::new("Project with Key '$($newProject.Key)' already exists.")
            }
            
            [void]$this.{_dataStore}.Projects.Add($newProject)
            $this.{_dataModified} = $true
            
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            
            Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Created"; Project = $newProject }
            
            Write-Verbose "DataManager: Added project '$($newProject.Name)' with Key '$($newProject.Key)'."
            return $newProject
        }
    }
    
    # Updates an existing project.
    [PmcProject] UpdateProject([Parameter(Mandatory)][hashtable]$UpdateParameters) {
        return Invoke-WithErrorHandling -Component "DataManager.UpdateProject" -Context "Updating project" -AdditionalData @{ ProjectKey = $UpdateParameters.Key } -ScriptBlock {
            if (-not $UpdateParameters.ContainsKey('Key')) { throw [System.ArgumentException]::new("UpdateParameters must contain a 'Key' for the project to update.") }

            $projectKey = $UpdateParameters.Key
            $managedProject = $this.{_dataStore}.Projects.Find({$_.Key -eq $projectKey})
            
            if (-not $managedProject) { throw [System.InvalidOperationException]::new("Project with Key '$projectKey' not found for update.") }
            
            $updatedFields = [System.Collections.Generic.List[string]]::new()
            
            if ($UpdateParameters.ContainsKey('Name')) { $managedProject.Name = $UpdateParameters.Name; [void]$updatedFields.Add("Name") }
            if ($UpdateParameters.ContainsKey('Description')) { $managedProject.Description = $UpdateParameters.Description; [void]$updatedFields.Add("Description") }
            if ($UpdateParameters.ContainsKey('Client')) { $managedProject.Client = $UpdateParameters.Client; [void]$updatedFields.Add("Client") }
            if ($UpdateParameters.ContainsKey('BillingType')) { 
                try { $managedProject.BillingType = [BillingType]::$($UpdateParameters.BillingType) }
                catch { Write-Warning "DataManager: Invalid BillingType update '$($UpdateParameters.BillingType)' for project '$projectKey'. Skipping." }
                [void]$updatedFields.Add("BillingType") 
            }
            if ($UpdateParameters.ContainsKey('Rate')) { 
                try { $managedProject.Rate = [double]$UpdateParameters.Rate }
                catch { Write-Warning "DataManager: Invalid Rate update '$($UpdateParameters.Rate)' for project '$projectKey'. Skipping." }
                [void]$updatedFields.Add("Rate") 
            }
            if ($UpdateParameters.ContainsKey('Budget')) { 
                try { $managedProject.Budget = [double]$UpdateParameters.Budget }
                catch { Write-Warning "DataManager: Invalid Budget update '$($UpdateParameters.Budget)' for project '$projectKey'. Skipping." }
                [void]$updatedFields.Add("Budget") 
            }
            if ($UpdateParameters.ContainsKey('Active')) { $managedProject.Active = [bool]$UpdateParameters.Active; [void]$updatedFields.Add("Active") }

            $managedProject.UpdatedAt = [datetime]::Now
            $this.{_dataModified} = $true
            
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            
            Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Updated"; Project = $managedProject; UpdatedFields = $updatedFields.ToArray() }
            
            Write-Verbose "DataManager: Updated project '$($managedProject.Name)' with Key '$projectKey'. Fields updated: $($updatedFields -join ', ')"
            return $managedProject
        }
    }
    
    # Removes a project by its key.
    [bool] RemoveProject([Parameter(Mandatory)][string]$projectKey) {
        return Invoke-WithErrorHandling -Component "DataManager.RemoveProject" -Context "Removing project" -AdditionalData @{ ProjectKey = $projectKey } -ScriptBlock {
            $projectToRemove = $this.{_dataStore}.Projects.Find({$_.Key -eq $projectKey})
            if (-not $projectToRemove) {
                Write-Warning "DataManager: Project with Key '$projectKey' not found for removal."
                return $false
            }
            
            # --- HARDENING: Prevent deletion of projects with associated tasks ---
            $associatedTasks = $this.{_dataStore}.Tasks | Where-Object { $_.ProjectKey -eq $projectKey }
            if ($associatedTasks.Count -gt 0) {
                $taskTitles = ($associatedTasks | Select-Object -ExpandProperty Title -First 3) -join ", "
                if ($associatedTasks.Count -gt 3) { $taskTitles += ", ..." }
                throw [System.InvalidOperationException]::new("Cannot delete project '$projectKey'. It has $($associatedTasks.Count) associated tasks (e.g., '$taskTitles'). Please reassign or delete tasks first.")
            }
            # --- END HARDENING ---

            [void]$this.{_dataStore}.Projects.Remove($projectToRemove)
            $this.{_dataModified} = $true
            
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            
            Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Deleted"; ProjectKey = $projectKey }
            
            Write-Verbose "DataManager: Removed project with Key '$projectKey'."
            return $true
        }
    }
    
    # Retrieves a single project by key.
    [PmcProject] GetProject([Parameter(Mandatory)][string]$projectKey) {
        return $this.{_dataStore}.Projects.Find({$_.Key -eq $projectKey})
    }
    
    # Retrieves all projects.
    [PmcProject[]] GetProjects() {
        return @($this.{_dataStore}.Projects | Where-Object { $_ -ne $null }) # Filter out potential nulls
    }
    #endregion

    #region Settings and Utility Methods
    [string] GetSetting([Parameter(Mandatory)][string]$settingName, [object]$defaultValue = $null) {
        return $this.{_dataStore}.Settings[$settingName] ?? $defaultValue
    }

    [void] SetSetting([Parameter(Mandatory)][string]$settingName, [object]$value) {
        $this.{_dataStore}.Settings[$settingName] = $value
        $this.{_dataModified} = $true
        Write-Verbose "DataManager: Setting '$settingName' updated to '$value'."
        if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
        Publish-Event -EventName "Settings.Changed" -Data @{ SettingName = $settingName; NewValue = $value }
    }

    [bool] IsAutoSaveEnabled() {
        return $this.{_dataStore}.Settings.AutoSave
    }
    
    [void] SetAutoSave([bool]$enabled) {
        $this.{_dataStore}.Settings.AutoSave = $enabled
        $this.{_dataModified} = $true
        Write-Verbose "DataManager: AutoSave set to '$enabled'."
        if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
    }
    
    [datetime] GetLastSaveTime() {
        return $this.{_lastSaveTime}
    }
    
    [void] ForceSave() {
        $this.SaveData()
    }
    #endregion

    #region Timesheet Data (Provided for compatibility with TimesheetService)
    # The TimeSheetService directly accesses DataManager's internal TimeEntries and ActiveTimers.
    # While generally discouraged for strict encapsulation, this is a pragmatic choice for existing
    # code integration. The DataManager still owns the persistence.
    [System.Collections.ArrayList] GetTimeEntriesCollection() {
        return $this.{_dataStore}.TimeEntries
    }

    [System.Collections.Hashtable] GetActiveTimersCollection() {
        return $this.{_dataStore}.ActiveTimers
    }
    #endregion
}

# Export the factory function
Export-ModuleMember -Function Initialize-DataManager -Class DataManager
```

---

**3. Integration Ideas for Axiom-Phoenix:**

1.  **Update `run.ps1`'s Module Load Order:**
    *   Ensure `modules\models\models.psm1` is loaded *before* `modules\data-manager\data-manager.psm1`, as the Data Manager relies on the `PmcTask` and `PmcProject` classes.

    ```powershell
    # --- run.ps1 Snippet ---
    $FileLoadOrder = @(
        # ... (existing core modules) ...
        
        # Models (MUST be loaded before DataManager)
        'modules/models/models.psm1',
        
        # Data Manager (depends on models)
        'modules/data-manager/data-manager.psm1',
        
        # ... (rest of service, component, screen modules) ...
    )
    # ... rest of run.ps1 remains similar ...
    ```

2.  **Update `run.ps1`'s Service Registration:**
    *   The `DataManager` initialization remains the same.
    *   Make sure you are registering `DataManager` as a singleton in your `ServiceContainer` as it's meant to be a single, application-wide data source.

    ```powershell
    # --- run.ps1 Snippet ---
    # ... (existing service initialization) ...

    # 3. Register all services with the container using factories
    # ... (existing service registrations) ...
    $container.RegisterFactory("DataManager", { param($c) Initialize-DataManager }) # Ensure this factory returns the new DataManager
    # ... (rest of service registrations) ...
    
    # IMPORTANT: If you plan to incorporate the TimesheetService later, ensure it's
    # registered here and injected with the DataManager.
    # $container.RegisterFactory("TimeSheetService", { param($c) Initialize-TimeSheetService -DataManager ($c.GetService("DataManager")) })
    ```

3.  **Refactor Components/Screens to use New `DataManager` API & Event-Driven Updates:**
    *   **Dashboard Screen**: Your existing Dashboard Screen should react to `Tasks.Changed` events to update its summary.
    *   **Task List Screen**:
        *   Replace direct `DataManager.GetTasks()` calls in `_RefreshData` with reacting to `Tasks.Changed` events. The `DataManager` will `Publish-Event` after any CRUD operation.
        *   Make sure `AddTask`, `UpdateTask`, `RemoveTask` calls use the new `DataManager` method signatures (e.g., `AddTask($title, $description, $priority, $projectKey)`).
    *   **Any other Screens/Components**: If you have other parts of your UI that display task or project data, they should be updated to listen for the `Tasks.Changed` and `Projects.Changed` events and refresh their UI accordingly, rather than polling the `DataManager`. This is fundamental for UI responsiveness.

This phase drastically improves data integrity, resilience, and the reactive nature of your application's UI, moving it closer to a modern, event-driven architecture.





Okay, let's proceed with the fifth significant improvement to pull from "Project Acta" into "Axiom-Phoenix." This one introduces a new complex interactive UI component for visualizing tasks.

---

### Improvement 5: New Complex Interactive Component - Kanban Board

**1. Explanation of Value:**

This addition provides a powerful new way to visualize and interact with tasks, demonstrating advanced capabilities of your TUI framework:

*   **Advanced UI Component (`KanbanBoardComponent`)**: This component is far more complex than basic inputs or tables. It manages multiple columns, each containing multiple cards, and handles horizontal and vertical navigation within this grid.
*   **`ScrollablePanel` in Action**: The `KanbanBoardComponent` extends `ScrollablePanel`. This is a fantastic demonstration of how `ScrollablePanel` facilitates rendering content that extends beyond the visible boundaries of a panel, providing automatic scrolling and scrollbar rendering.
*   **Data Transformation for Visualization**: It takes raw `PmcTask` objects (from your `DataManager`) and transforms them into view-specific `KanbanCard` and `KanbanColumn` objects, organizing tasks by their status. This illustrates the separation of concerns between raw data and its presentation.
*   **Sophisticated Input Handling**: The component implements detailed input logic for navigating between columns (Left/Right arrow) and within columns (Up/Down arrow), and it intelligently delegates page-scrolling keys (PageUp/PageDown) to its parent `ScrollablePanel`.
*   **Advanced Theme Integration**: It showcases how to apply granular theming using `ThemeEngine.GetStyle()` for various parts of the component (column borders, card borders, selected card backgrounds/foregrounds).

**2. Relevant Code to Pull:**

You'll need to **add** the contents of `screens\task-flow-screen\task-flow-screen.psm1` to your Axiom-Phoenix structure. This file contains both the `KanbanCard` and `KanbanColumn` view models, the `KanbanBoardComponent` itself, and the `TaskFlowScreen` that hosts it.

---

**Code Block 1: `screens\task-flow-screen\task-flow-screen.psm1` (New File)**

Create a new file `screens\task-flow-screen\task-flow-screen.psm1` and add the following content:

```powershell
# ==============================================================================
# Project Acta - Task Flow (Kanban) Screen
# Visual, interactive task board for managing workflow. This screen provides a
# more intuitive way to view and manage task progression than a simple list.
# ==============================================================================

using namespace System.Management.Automation # For CmdletBinding, Parameter
using namespace System.Collections.Generic # For List

# Define simple data models for the board's structure. These are view-models,
# not the core PmcTask model.
class KanbanCard {
    [string]$Id
    [string]$Title
    [string]$Priority
    [object]$Data # The original PmcTask object
}
class KanbanColumn {
    [string]$Title
    [System.Collections.Generic.List[KanbanCard]]$Cards
}

# This is a complex, interactive component that renders a horizontally scrollable Kanban board.
class KanbanBoardComponent : ScrollablePanel {
    [KanbanColumn[]]$Columns
    [int]$SelectedColumn = 0
    [int]$SelectedCard = 0

    KanbanBoardComponent([Parameter(Mandatory)][string]$name) : base($name) {
        $this.Name = $name
        $this.Columns = @()
        $this.IsFocusable = $true
        # Initial size, will be set by parent screen
        $this.Width = 80
        $this.Height = 20
    }

    # Populates the component with data transformed from the DataManager.
    # This method is designed to be called externally (e.g., by its parent screen).
    [void] SetData([Parameter(Mandatory)][PmcTask[]]$tasks) {
        # Initialize columns with empty card lists
        $this.Columns = @(
            [KanbanColumn]@{ Title="Pending"; Cards = [System.Collections.Generic.List[KanbanCard]]::new() };
            [KanbanColumn]@{ Title="In Progress"; Cards = [System.Collections.Generic.List[KanbanCard]]::new() };
            [KanbanColumn]@{ Title="Completed"; Cards = [System.Collections.Generic.List[KanbanCard]]::new() };
            [KanbanColumn]@{ Title="Cancelled"; Cards = [System.Collections.Generic.List[KanbanCard]]::new() }
        )

        # Create a lookup for columns by title for efficient card assignment
        $columnLookup = [System.Collections.Generic.Dictionary[string, System.Collections.Generic.List[KanbanCard]]]::new([System.StringComparer]::OrdinalIgnoreCase)
        foreach ($col in $this.Columns) {
            # Use status string that matches PmcTask.Status.ToString()
            $columnLookup[$col.Title.Replace(" ", "")] = $col.Cards 
        }

        foreach ($task in $tasks) {
            # Create a KanbanCard view model from the PmcTask
            $card = [KanbanCard]@{ Id = $task.Id; Title = $task.Title; Priority = $task.Priority.ToString(); Data = $task }
            $statusString = $task.Status.ToString() 

            if ($columnLookup.ContainsKey($statusString)) {
                $columnLookup[$statusString].Add($card)
            } else {
                Write-Log -Level Warning -Message "KanbanBoardComponent '$($this.Name)': Task status '$statusString' does not map to a Kanban column. Task: $($task.Title)"
            }
        }
        
        # Calculate virtual size based on actual content
        $columnWidth = 30 # Each column is 30 chars wide
        $columnSpacing = 1 # 1 char space between columns
        $this.VirtualWidth = ($this.Columns.Count * $columnWidth) + (($this.Columns.Count - 1) * $columnSpacing)
        $this.VirtualHeight = 30 # Arbitrary large virtual height to allow vertical scrolling within columns
        
        # Clamp selected indices after data update
        $this._ClampSelection()

        $this.RequestRedraw()
        Write-Verbose "KanbanBoardComponent '$($this.Name)': Data set with $($tasks.Count) tasks."
    }
    
    [void] OnRender() {
        # This component renders to the virtual buffer provided by its parent ScrollablePanel class.
        $buffer = $this.GetVirtualBuffer()
        if ($null -eq $buffer) { 
            Write-Warning "KanbanBoardComponent '$($this.Name)': Virtual buffer is null during OnRender."
            return 
        }
        $buffer.Clear() # Clear the virtual buffer for fresh drawing
        
        # Get styles from ThemeEngine
        $colStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Kanban.Column")
        $cardStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Kanban.Card")
        $cardSelectedStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Kanban.CardSelected")

        $xOffset = 0
        $columnWidth = 30
        $columnSpacing = 1

        for ($c = 0; $c -lt $this.Columns.Count; $c++) {
            $column = $this.Columns[$c]
            
            # Determine column border style (can be enhanced for column focus)
            $currentColStyle = $colStyle.Clone()
            # if ($c -eq $this.SelectedColumn -and $this.IsFocused) {
            #     # Merge column focus style here if desired
            # }

            # Draw the column container box.
            Write-TuiBox -Buffer $buffer -X $xOffset -Y 0 -Width $columnWidth -Height ($this.VirtualHeight -1) -Title "$($column.Title) ($($column.Cards.Count))" -Style $currentColStyle

            $yOffset = 2 # Start Y position for cards within a column (below title/border)
            $cardHeight = 4 # Each card is 3 lines tall + 1 line spacing

            for ($r = 0; $r -lt $column.Cards.Count; $r++) {
                # Ensure card fits within the column's visual height minus border.
                # Adjust for inner padding of the column border (Y=1 is top inner, Y=ContentHeight-1 is bottom inner)
                if ($yOffset + $cardHeight > ($this.VirtualHeight - 2)) { break } 
                
                $card = $column.Cards[$r]
                
                # Determine the style based on component focus and selection state.
                $currentCardStyle = $cardStyle.Clone() # Start with base card style
                if ($c -eq $this.SelectedColumn -and $r -eq $this.SelectedCard -and $this.IsFocused) {
                    # Merge the 'Selected' style over the top of the card's base style.
                    foreach($key in $cardSelectedStyle.Keys) { $currentCardStyle[$key] = $cardSelectedStyle[$key] }
                }
                
                # Draw the card as a smaller box within the column.
                $cardTitleText = "$($card.Title) [$($card.Priority)]"
                # Truncate card title to fit within internal width
                $maxCardTitleWidth = $columnWidth - 4 # Accounting for card border
                if ($cardTitleText.Length -gt $maxCardTitleWidth) { $cardTitleText = $cardTitleText.Substring(0, $maxCardTitleWidth - 3) + "..." }
                
                Write-TuiBox -Buffer $buffer -X ($xOffset+1) -Y $yOffset -Width ($columnWidth-2) -Height ($cardHeight-1) -Title $cardTitleText -Style $currentCardStyle
                $yOffset += $cardHeight
            }
            $xOffset += $columnWidth + $columnSpacing # Move to the next column position.
        }
        Write-Verbose "KanbanBoardComponent '$($this.Name)': Rendered $($this.Columns.Count) columns."
        # Call base Panel's OnRender after this to draw borders and then blend the virtual buffer
        ([ScrollablePanel]$this).OnRender()
    }
    
    [bool] HandleInput([Parameter(Mandatory)][System.ConsoleKeyInfo]$keyInfo) {
        $colCount = $this.Columns.Count
        if ($colCount -eq 0) { return $false }
        
        $handledByMe = $true # Assume handled unless proven otherwise
        $oldSelectedColumn = $this.SelectedColumn
        $oldSelectedCard = $this.SelectedCard

        switch ($keyInfo.Key) {
            ([ConsoleKey]::RightArrow) {
                if ($this.SelectedColumn -lt $colCount - 1) { 
                    $this.SelectedColumn++; 
                    $this._ClampCardSelection() # Adjust card selection for new column
                    $this._EnsureSelectedColumnVisible() # Scroll horizontally
                }
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this.SelectedColumn -gt 0) { 
                    $this.SelectedColumn--; 
                    $this._ClampCardSelection() # Adjust card selection for new column
                    $this._EnsureSelectedColumnVisible() # Scroll horizontally
                }
            }
            ([ConsoleKey]::DownArrow) {
                $currentColumnCardCount = $this.Columns[$this.SelectedColumn].Cards.Count
                if ($currentColumnCardCount -gt 0 -and $this.SelectedCard -lt $currentColumnCardCount - 1) { 
                    $this.SelectedCard++; 
                    $this._EnsureSelectedCardVisible() # Scroll vertically
                }
            }
            ([ConsoleKey]::UpArrow) {
                $currentColumnCardCount = $this.Columns[$this.SelectedColumn].Cards.Count
                if ($currentColumnCardCount -gt 0 -and $this.SelectedCard -gt 0) { 
                    $this.SelectedCard--; 
                    $this._EnsureSelectedCardVisible() # Scroll vertically
                }
            }
            ([ConsoleKey]::Enter) {
                $selectedCard = $this._GetSelectedCard()
                if ($selectedCard) {
                    # Example: Publish an event or open a dialog to edit the task
                    Publish-Event -EventName "Kanban.CardSelected" -Data @{ Card = $selectedCard; OriginalTask = $selectedCard.Data }
                    Write-Log -Level Debug "Kanban card selected: $($selectedCard.Title)"
                }
            }
            default { $handledByMe = $false } # Key not handled by Kanban's specific navigation
        }
        
        if ($handledByMe) {
            if ($this.SelectedColumn -ne $oldSelectedColumn -or $this.SelectedCard -ne $oldSelectedCard) {
                $this.RequestRedraw()
            }
            return $true 
        }
        
        # Pass unhandled keys (like PageUp/PageDown, Home/End) to the parent ScrollablePanel for generic scrolling.
        # This allows the ScrollablePanel to manage its _virtual_buffer scrolling.
        return ([ScrollablePanel]$this).HandleInput($keyInfo)
    }

    hidden [void] _ClampSelection() {
        $this._ClampColumnSelection()
        $this._ClampCardSelection()
    }

    hidden [void] _ClampColumnSelection() {
        $this.SelectedColumn = [Math]::Max(0, [Math]::Min($this.SelectedColumn, $this.Columns.Count - 1))
    }

    hidden [void] _ClampCardSelection() {
        if ($this.Columns.Count -gt 0) {
            $currentColumnCardCount = $this.Columns[$this.SelectedColumn].Cards.Count
            $this.SelectedCard = [Math]::Max(0, [Math]::Min($this.SelectedCard, $currentColumnCardCount - 1))
        } else {
            $this.SelectedCard = 0 # No cards if no columns
        }
    }

    hidden [object] _GetSelectedCard() {
        if ($this.Columns.Count -eq 0 -or $this.SelectedColumn -lt 0) { return $null }
        $column = $this.Columns[$this.SelectedColumn]
        if ($column.Cards.Count -eq 0 -or $this.SelectedCard -lt 0) { return $null }
        return $column.Cards[$this.SelectedCard]
    }

    hidden [void] _EnsureSelectedColumnVisible() {
        # Calculate the X position of the selected column within the virtual buffer
        $selectedColumnX = $this.SelectedColumn * (30 + 1) # Column width + spacing

        # If the selected column starts before the current scroll offset, scroll left
        if ($selectedColumnX < $this.ScrollX) {
            $this.ScrollTo($selectedColumnX, $this.ScrollY)
        }
        # If the selected column ends after the visible content width, scroll right
        elseif (($selectedColumnX + 30) > ($this.ScrollX + $this.ContentWidth)) {
            $newScrollX = ($selectedColumnX + 30) - $this.ContentWidth
            $this.ScrollTo($newScrollX, $this.ScrollY)
        }
    }

    hidden [void] _EnsureSelectedCardVisible() {
        # Calculate the Y position of the selected card within its column's virtual space
        $selectedCardY = 2 + ($this.SelectedCard * 4) # Y-offset in column + card height/spacing

        # If the selected card is above the current scroll offset, scroll up
        if ($selectedCardY < $this.ScrollY) {
            $this.ScrollTo($this.ScrollX, $selectedCardY)
        }
        # If the selected card is below the visible content height, scroll down
        elseif (($selectedCardY + 4) > ($this.ScrollY + $this.ContentHeight)) {
            $newScrollY = ($selectedCardY + 4) - $this.ContentHeight
            $this.ScrollTo($this.ScrollX, $newScrollY)
        }
    }
}

# The screen class is a simple host for the Kanban board.
class TaskFlowScreen : Screen {
    [KanbanBoardComponent]$kanbanBoard
    hidden [string] $_eventSubscriptionId # To track event subscription for cleanup

    TaskFlowScreen([Parameter(Mandatory)][System.Collections.Hashtable]$services) : base("TaskFlowScreen", $services) { }

    [void] OnInitialize() {
        # Ensure screen takes up full TUI engine buffer space
        $this.Width = $global:TuiState.BufferWidth
        $this.Height = $global:TuiState.BufferHeight

        # Create the Kanban board component
        $this.kanbanBoard = [KanbanBoardComponent]::new("TaskKanban")
        # The Kanban board is sized to the screen's full content area.
        $this.kanbanBoard.Resize($this.Width, $this.Height)
        $this.kanbanBoard.HasBorder = $false # The screen itself might provide a border/frame.
        $this.AddChild($this.kanbanBoard) # Add it as a child of the screen

        # Subscribe to Task.Changed events to refresh the board automatically
        # Capture $this (the screen instance) for the scriptblock.
        $self = $this
        $this._eventSubscriptionId = $this.SubscribeToEvent("Tasks.Changed", {
            param($EventData)
            Write-Log -Level Debug "TaskFlowScreen: Tasks.Changed event received. Refreshing Kanban board."
            $self.RefreshKanbanBoardData()
        })
        Write-Verbose "TaskFlowScreen '$($this.Name)': Initialized and subscribed to Tasks.Changed."
    }
    
    # OnCleanup overrides the base Screen.Cleanup to specifically unsubscribe
    # from events the screen subscribed to directly. The base's cleanup will then
    # cascade to children.
    [void] OnCleanup() {
        if ($this._eventSubscriptionId) {
            # Unsubscribe using the global function, providing the stored HandlerId.
            Unsubscribe-Event -HandlerId $this._eventSubscriptionId
            $this._eventSubscriptionId = $null # Clear reference
            Write-Verbose "TaskFlowScreen '$($this.Name)': Unsubscribed from Tasks.Changed event."
        }
        ([Screen]$this).Cleanup() # Call base Screen cleanup to cascade to children
    }

    [void] OnEnter() {
        # When the screen is entered, fetch fresh data and populate the component.
        $this.RefreshKanbanBoardData()
        # Set initial focus to the Kanban board for interaction.
        Set-ComponentFocus -Component $this.kanbanBoard
        Write-Verbose "TaskFlowScreen '$($this.Name)': Entered and focused Kanban board."
    }

    [void] OnResize([Parameter(Mandatory)][int]$newWidth, [Parameter(Mandatory)][int]$newHeight) {
        # When the screen resizes, ensure the Kanban board component resizes with it.
        ([Screen]$this).OnResize($newWidth, $newHeight) # Call base Screen's OnResize
        $this.kanbanBoard.Resize($newWidth, $newHeight)
        Write-Verbose "TaskFlowScreen '$($this.Name)': Resized to $($newWidth)x$($newHeight)."
    }

    # Helper method to get data from DataManager and set it on the Kanban board.
    hidden [void] RefreshKanbanBoardData() {
        $dataManager = $this.Services.DataManager # Get DataManager from injected services
        if ($null -eq $dataManager) {
            Write-Error "TaskFlowScreen: DataManager service not found. Cannot refresh Kanban data."
            return
        }
        $tasks = $dataManager.GetTasks() # Get all tasks
        $this.kanbanBoard.SetData($tasks)
        Write-Verbose "TaskFlowScreen '$($this.Name)': Kanban board data refreshed."
    }

    # The screen's input handler delegates all input to its child component (the Kanban board).
    [bool] HandleInput([Parameter(Mandatory)][System.ConsoleKeyInfo]$keyInfo) { 
        # The focused component (KanbanBoardComponent) will receive input first from TUI Engine.
        # This screen method is primarily for screen-level hotkeys not handled by KanbanBoard.
        # For now, it delegates to the base Screen's handler (which returns false).
        return ([Screen]$this).HandleInput($keyInfo)
    }
}
```

---

**3. Integration Ideas for Axiom-Phoenix:**

1.  **Update `run.ps1`'s Module Load Order:**
    *   Add `screens\task-flow-screen\task-flow-screen.psm1` to your `$FileLoadOrder` list, ensuring it's after `modules\models\models.psm1`, `layout\panels-class\panels-class.psm1` (for `ScrollablePanel`), and `modules\data-manager\data-manager.psm1`.

2.  **Register `TaskFlowScreen` with `NavigationService`:**
    *   In `run.ps1`, after `NavigationService` is initialized and `ScreenFactory` is set up, register the new screen class:

    ```powershell
    # --- run.ps1 Snippet ---
    # ...
    # 4. Register screen classes with the Navigation Service
    $navService = $container.GetService("NavigationService")
    $navService.RegisterScreenClass("DashboardScreen", [DashboardScreen])
    $navService.RegisterScreenClass("TaskListScreen", [TaskListScreen])
    $navService.RegisterScreenClass("TaskFlowScreen", [TaskFlowScreen]) # <--- ADD THIS LINE
    # ...
    ```

3.  **Add a Navigation Route to `TaskFlowScreen`:**
    *   In `run.ps1`, or wherever you define your `NavigationService.RouteMap`, add a route to access the new screen:

    ```powershell
    # --- run.ps1 Snippet ---
    # ...
    # 7. Add routes for all the new screens
    $navService.RouteMap["/"] = "DashboardScreen" # Default route
    $navService.RouteMap["/dashboard"] = "DashboardScreen"
    $navService.RouteMap["/tasks"] = "TaskListScreen" # Existing list screen
    $navService.RouteMap["/kanban"] = "TaskFlowScreen" # <--- ADD THIS LINE
    # ...
    ```

4.  **Add a Global Command to Navigate to Kanban Board (Optional but Recommended):**
    *   If you've implemented the `commands\global-commands.psm1` pattern (as suggested in previous steps), add a function there:

    ```powershell
    # --- commands\global-commands.psm1 Snippet ---
    # ... (existing global commands) ...

    function Navigate-ToKanbanBoard {
        $Global:AxiomServices.Navigation.GoTo("/kanban")
    }
    ```
    *   Then, in `run.ps1`, register this action with the `ActionService` for the Command Palette:

    ```powershell
    # --- run.ps1 Snippet ---
    # ...
    # 5. Manually register the global action for Command Palette:
    # ...
    $actionService.RegisterAction("Navigation: Go to Kanban Board", "Navigation", ${function:Navigate-ToKanbanBoard}) # <--- ADD THIS LINE
    # ...
    ```

5.  **Define Kanban-Specific Styles in Your Theme (`themes\default.theme.json` or similar):**
    *   To make the Kanban board visually appealing and theme-aware, you'll need to define new entries in your theme's `Components` section (e.g., `themes\Modern.theme.json` or whatever theme you're using).
    *   Example `*.theme.json` snippet:

    ```json
    {
      "Name": "Modern",
      "Palette": {
        "background": "#0d1117",
        "foreground": "#c9d1d9",
        "accent1": "#58a6ff",
        "accent2": "#f78166",
        "border": "#30363d",
        "borderFocus": "#58a6ff",
        "success": "#3fb950",
        "error": "#f85149",
        "errorHighlight": "#FF00FF",
        "subtle": "#6a737d",
        "selectionBg": "#2ea043",
        "selectionFg": "#ffffff"
      },
      "Components": {
        "Default": {
          "FG": "$Palette.foreground",
          "BG": "$Palette.background"
        },
        "Panel": {
          "BorderFG": "$Palette.border",
          "BG": "$Palette.background",
          "TitleFG": "$Palette.foreground"
        },
        "Panel.Focus": {
          "BorderFG": "$Palette.borderFocus"
        },
        "Table": {
          "Header": { "FG": "$Palette.accent1", "Bold": true },
          "Row": { "FG": "$Palette.foreground", "BG": "$Palette.background" },
          "SelectedRow": { "FG": "$Palette.selectionFg", "BG": "$Palette.selectionBg" }
        },
        "Kanban": {
          "Column": {
            "BorderFG": "$Palette.border",
            "BG": "$Palette.background",
            "TitleFG": "$Palette.accent1",
            "TitleStyle": { "Bold": true }
          },
          "Card": {
            "BorderFG": "$Palette.border",
            "BG": "$Palette.background",
            "TitleFG": "$Palette.foreground"
          },
          "CardSelected": {
            "BorderFG": "$Palette.borderFocus",
            "BG": "$Palette.subtle",
            "TitleFG": "$Palette.foreground"
          }
        },
        "Scrollbar": {
            "ThumbChar": "█",
            "TrackChar": "▒",
            "FG": "$Palette.subtle",
            "BG": "$Palette.background"
        }
      }
    }
    ```

This step adds a visually rich and interactive new feature to your TUI, leveraging the improved `ScrollablePanel` and the advanced theming system.






