# Enhanced PowerShell Todoist TUI - Professional Version
# Rich display, smart completions, full feature implementation

# === GLOBAL CONFIGURATION ===
$global:TaskFile = Join-Path $PSScriptRoot "tasks.json"
$global:BackupFile = Join-Path $PSScriptRoot "tasks.bak"
$global:UndoFile = Join-Path $PSScriptRoot "tasks.undo"
$global:ConfigFile = Join-Path $PSScriptRoot "config.json"
$global:LastShownTaskMap = @{}
$global:CurrentContext = "inbox"
$global:LastAction = $null
$global:SessionStats = @{
    TasksAdded = 0
    TasksCompleted = 0
    TimeLogged = 0
    CommandsRun = 0
    SessionStart = Get-Date
}

# Debug logging helper (file-only). Enabled when -Debug is used or Behavior.DebugLogging is true.
function Write-DebugLog {
    param([string]$Message)
    try {
        $logEnabled = $false
        try {
            $cfg = [ConfigManager]::Config
            if ($cfg -and $cfg.Behavior -and $cfg.Behavior.DebugLogging) { $logEnabled = $true }
        } catch {}
        if ($DebugPreference -and $DebugPreference -ne 'SilentlyContinue') { $logEnabled = $true }
        if (-not $logEnabled) { return }
        $logPath = Join-Path $PSScriptRoot 'debug.log'
        # Simple rotation if > 10MB
        if (Test-Path $logPath) {
            try {
                $len = (Get-Item $logPath).Length
                if ($len -gt 10MB) { Move-Item -Force $logPath ($logPath + '.old') }
            } catch {}
        }
        $ts = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss.fff')
        Add-Content -Path $logPath -Value ("[$ts] " + $Message)
    } catch {}
}

# LastShownTaskMap capacity guard
function Ensure-LastShownCapacity {
    param([int]$Max = 1000)
    try {
        if ($global:LastShownTaskMap.Count -gt $Max) {
            $global:LastShownTaskMap.Clear()
            Write-DebugLog "LastShownTaskMap cleared due to capacity"
        }
    } catch {}
}

function Set-LastShownEntry {
    param([int]$LocalId, [int]$TaskId)
    Ensure-LastShownCapacity
    $global:LastShownTaskMap[$LocalId] = $TaskId
}

# === CONFIGURATION MANAGER ===
class ConfigManager {
    static [hashtable] $Config = @{
        Colors = @{
            Overdue = "Red"
            Today = "Yellow"
            Tomorrow = "Cyan"
            Upcoming = "Green"
            Priority1 = "Magenta"
            Priority2 = "Yellow"
            Priority3 = "Blue"
            Project = "DarkCyan"
            Context = "Cyan"
            TimeLog = "Blue"
        }
        Display = @{
            MaxTasksPerSection = 10
            ShowEmptyProjects = $false
            ShowCompletedInReports = $true
            DateFormat = "ddd MM/dd"
            Use24Hour = $false
            CompactMode = $false
            UseAsciiIcons = $false
        }
        Behavior = @{
            AutoArchiveAfterDays = 30
            DefaultDueDateDays = 7
            WarnBeforeDelete = $true
            ShowWelcome = $true
            EnableNotifications = $false
            EnableCsvLedger = $true
            AcceptOnType = $true
            ShowGhostNext = $true
            ShowSyntaxLine = $true
            DebugLogging = $false
            NonInteractive = $false
        }
        Shortcuts = @{
            't' = 'today'
            'tm' = 'tomorrow'
            'nd' = 'noduedate'
            'od' = 'overdue'
        }
        Paths = @{
            CsvLedgerPath = 'time_ledger.csv'
        }
        Excel = @{
            SourceFolder = 'C:\\Path\\To\\T2020\\Input'
            DestinationPath = 'C:\\Path\\To\\T2020\\Destination\\Output.xlsm'
            SourceSheet = 'SVI-CAS'
            DestSheet = 'Output'
            ID2FieldName = 'CASNumber'
        }
    }
    
    static [void] Load() {
        if (Test-Path $global:ConfigFile) {
            try {
                # Load as hashtable to avoid PSCustomObject indexing issues
                $saved = Get-Content $global:ConfigFile -Raw | ConvertFrom-Json -AsHashtable
            } catch {
                # Fallback without -AsHashtable; convert PSCustomObject to hashtable
                $tmp = Get-Content $global:ConfigFile -Raw | ConvertFrom-Json
                $saved = Convert-PSObjectToHashtable $tmp
            }
            # Deep merge saved values into defaults, preserving new keys
            foreach ($k in $saved.Keys) {
                if ([ConfigManager]::Config.ContainsKey($k) -and ([ConfigManager]::Config[$k] -is [hashtable]) -and ($saved[$k] -is [hashtable])) {
                    foreach ($k2 in $saved[$k].Keys) { [ConfigManager]::Config[$k][$k2] = $saved[$k][$k2] }
                } else {
                    [ConfigManager]::Config[$k] = $saved[$k]
                }
            }
        }
    }
    
    static [void] Save() {
        [ConfigManager]::Config | ConvertTo-Json -Depth 10 | Set-Content $global:ConfigFile
    }
}

# Minimal VT100 helpers (inlined)
class VT {
    static [string] MoveTo([int]$x, [int]$y) { return "`e[$y;$($x)H" }
    static [string] SavePos() { return "`e[s" }
    static [string] RestorePos() { return "`e[u" }
    static [string] Hide() { return "`e[?25l" }
    static [string] Show() { return "`e[?25h" }
    static [string] ClearLine() { return "`e[2K" }
}

# === INITIALIZE DATA STORAGE ===
    if (-not (Test-Path $global:TaskFile)) {
        @{
            tasks = @()
            lastId = 0
            deleted = @()
            completed = @()
            schema_version = 1
            projects = @( 
            @{ 
                name = 'inbox'
                description = 'Default inbox for uncategorized tasks'
                color = 'Gray'
                icon = 'üì•'
                sortOrder = 0
                isArchived = $false
                settings = @{}
                # === NEW PMC FIELDS ===
                ID1 = 'N/A'
                ID2 = 'INBOX'
                ProjFolder = ''
                AssignedDate = ''
                DueDate = ''
                BFDate = ''
                CAAName = ''
                RequestName = ''
                T2020 = ''
            },
            @{
                name = 'personal'
                description = 'Personal tasks and reminders'
                color = 'Green'
                icon = 'üè†'
                sortOrder = 1
                isArchived = $false
                # === NEW PMC FIELDS ===
                ID1 = ''
                ID2 = 'PERSONAL'
                ProjFolder = ''
                AssignedDate = ''
                DueDate = ''
                BFDate = ''
                CAAName = ''
                RequestName = ''
                T2020 = ''
            },
            @{
                name = 'work'
                description = 'Work-related tasks'
                color = 'Blue'
                icon = 'üíº'
                sortOrder = 2
                isArchived = $false
                # === NEW PMC FIELDS ===
                ID1 = ''
                ID2 = 'WORK'
                ProjFolder = ''
                AssignedDate = ''
                DueDate = ''
                BFDate = ''
                CAAName = ''
                RequestName = ''
                T2020 = ''
            }
        )
        timelogs = @()
        currentContext = 'inbox'
        templates = @{}
        labels = @('urgent', 'waiting', 'someday', 'reference')
        customFields = @{}
        recurringTemplates = @()
        blockedTasks = @()
        dependencies = @()
        notes = @{}
        attachments = @{}
        activityLog = @()
    } | ConvertTo-Json -Depth 10 | Set-Content $global:TaskFile
}

# === ENHANCED DATA FUNCTIONS WITH CACHING & UNDO ===

# Global state for caching, undo, and context
$global:DataCache = $null
$global:CacheTimestamp = 0
$global:UndoStack = @()
$global:RedoStack = @()
$global:MaxUndoLevels = 10
$global:LastShownTaskMap = @{}
$global:CurrentContext = 'inbox'

function Get-TaskData { 
    param([switch]$ForceRefresh)
    
    if (-not (Test-Path $global:TaskFile)) {
        return $null
    }
    
    $currentTimestamp = (Get-Item $global:TaskFile).LastWriteTime.Ticks
    
    if ($ForceRefresh -or -not $global:DataCache -or $global:CacheTimestamp -ne $currentTimestamp) {
        try {
            $global:DataCache = Get-Content $global:TaskFile -Raw | ConvertFrom-Json
            $global:CacheTimestamp = $currentTimestamp
            
            # Ensure all required properties exist
            $requiredProps = @{
                'activityLog' = @()
                'dependencies' = @()
                'projects' = @(@{
                    name = 'inbox'
                    description = 'Default project'
                    aliases = @('i', 'in')
                })
                'timelogs' = @()
                'currentContext' = 'inbox'
                'templates' = @{}
                'preferences' = @{
                    agendaShowOverdue = $true
                    agendaShowToday = $true  
                    agendaShowUpcoming = $true
                    agendaShowTimeToday = $true
                    agendaDaysAhead = 3
                    autoBackup = $true
                    defaultView = 'agenda'
                    generateRecurring = $true
                    maxSearchResults = 50
                }
                'deleted' = @()
                'completed' = @()
                'lastUsedProject' = $null
                'excelImports' = @()
            }
            
            foreach ($prop in $requiredProps.GetEnumerator()) {
                if (-not $global:DataCache.PSObject.Properties[$prop.Key]) {
                    $global:DataCache | Add-Member -MemberType NoteProperty -Name $prop.Key -Value $prop.Value
                }
            }
            # Schema version migration stub
            try {
                $ver = if ($global:DataCache.PSObject.Properties['schema_version']) { [int]$global:DataCache.schema_version } else { 0 }
                if ($ver -lt 1) {
                    $global:DataCache | Add-Member -Force -MemberType NoteProperty -Name schema_version -Value 1
                    Save-TaskData -data $global:DataCache -NoUndo
                }
            } catch { Write-DebugLog ("Schema migration error: " + $_) }
            
            # Set global context from data
            if ($global:DataCache.currentContext) {
                $global:CurrentContext = $global:DataCache.currentContext
            }
            
        } catch {
            Write-Error "Failed to load data: $_"
            if (Test-Path $global:BackupFile) {
                Write-Host "Attempting to restore from backup..." -ForegroundColor Yellow
                Copy-Item $global:BackupFile $global:TaskFile -Force
                $global:DataCache = Get-Content $global:TaskFile -Raw | ConvertFrom-Json
            }
        }
    }
    
    return $global:DataCache
}

function Save-TaskData($data, [switch]$NoUndo) {
    # Acquire simple file lock to prevent concurrent writers
    $lockPath = $global:TaskFile + '.lock'
    $lock = $null
    try {
        $maxRetries = 20; $delay = 100; $acquired = $false
        for ($i=0; $i -lt $maxRetries; $i++) {
            try {
                $lock = [System.IO.File]::Open($lockPath, [System.IO.FileMode]::OpenOrCreate, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None)
                $acquired = $true; break
            } catch {
                Start-Sleep -Milliseconds $delay
            }
        }
        if (-not $acquired) { throw "Could not acquire lock for task file" }
    } catch { Write-DebugLog ("Save-TaskData lock acquire failed: " + $_) }

    # Save to undo stack unless explicitly told not to
    if (-not $NoUndo) {
        try {
            # Snapshot the on-disk state (pre-change) to ensure true undo
            if (Test-Path $global:TaskFile) {
                $prev = Get-Content $global:TaskFile -Raw
                if ($prev) { $global:UndoStack += $prev }
            } elseif ($global:DataCache) {
                $global:UndoStack += ($global:DataCache | ConvertTo-Json -Depth 10)
            }
        } catch { Write-DebugLog ("Undo snapshot failed: " + $_) }
        if ($global:UndoStack.Count -gt $global:MaxUndoLevels) {
            $global:UndoStack = $global:UndoStack[-$global:MaxUndoLevels..-1]
        }
        
        # Persist undo stack
        if ($global:UndoStack.Count -gt 0) {
            $global:UndoStack | ConvertTo-Json -Depth 10 | Set-Content $global:UndoFile -Encoding UTF8
        }
    }
    
    # Add activity log entry
    if (-not $data.activityLog) {
        $data | Add-Member -MemberType NoteProperty -Name activityLog -Value @()
    }
    
    $data.activityLog += @{
        timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        action = $global:LastAction
        user = $env:USERNAME
    }
    
    # Keep only last 1000 activity entries
    if ($data.activityLog.Count -gt 1000) {
        $data.activityLog = $data.activityLog[-1000..-1]
    }
    
    $tempFile = "$($global:TaskFile).tmp"
    
    try {
        # Create backup before saving
        if ($data.preferences -and $data.preferences.autoBackup -and (Test-Path $global:TaskFile)) {
            Copy-Item $global:TaskFile $global:BackupFile -Force
        }
        
        $data | ConvertTo-Json -Depth 10 | Set-Content -Path $tempFile -Encoding UTF8
        Move-Item -Path $tempFile -Destination $global:TaskFile -Force
        
        # Update cache
        $global:DataCache = $data
        $global:CacheTimestamp = (Get-Item $global:TaskFile).LastWriteTime.Ticks
    }
    catch {
        Write-Error "Failed to save: $_"
    }
    finally {
        try { if ($lock) { $lock.Close() } } catch {}
        try { if (Test-Path $lockPath) { Remove-Item $lockPath -Force -ErrorAction SilentlyContinue } } catch {}
        if (Test-Path $tempFile) { 
            Remove-Item $tempFile -ErrorAction SilentlyContinue 
        }
    }
}

# === CORE UTILITY FUNCTIONS ===

function Get-SafePath {
    param(
        [string]$Path,
        [string]$Base = $PSScriptRoot
    )
    # Returns a path that is safe to write. If relative, anchors under $Base and normalizes.
    # If absolute, returns as-is but still normalizes directory creation.
    if ([string]::IsNullOrWhiteSpace($Path)) {
        return (Join-Path $Base 'output.txt')
    }
    try {
        $isAbsolute = [System.IO.Path]::IsPathRooted($Path)
        if (-not $isAbsolute) {
            # Anchor under Base
            $combined = Join-Path $Base $Path
            $full = [System.IO.Path]::GetFullPath($combined)
            $baseFull = [System.IO.Path]::GetFullPath($Base)
            if (-not $full.StartsWith($baseFull, [System.StringComparison]::OrdinalIgnoreCase)) {
                # Prevent traversal outside base
                $full = Join-Path $baseFull ([System.IO.Path]::GetFileName($Path))
            }
            return $full
        }
        else {
            return ([System.IO.Path]::GetFullPath($Path))
        }
    } catch {
        # Fallback to base
        return (Join-Path $Base ([System.IO.Path]::GetFileName($Path)))
    }
}

# Generate next task id and update data.lastId atomically
function Get-NextTaskId {
    param($data)
    if (-not $data) { $data = Get-TaskData }
    try {
        if ($data.PSObject.Properties['lastId']) {
            $data.lastId = [int]$data.lastId + 1
        } else {
            # Initialize if missing
            $data | Add-Member -MemberType NoteProperty -Name lastId -Value 1 -Force
        }
    } catch {
        # Fallback
        $data.lastId = 1
    }
    return [int]$data.lastId
}

function Get-Tasks {
    param(
        [string]$Filter = '',
        [int]$Priority = -1,
        [string]$Project = '',
        [string]$Search = '',
        [string]$Tag = '',
        [string]$ByID2 = '',
        [switch]$Sort
    )
    $data = Get-TaskData
    $tasks = @($data.tasks | Where-Object { $_.status -eq 'pending' })
    $today = (Get-Date).Date
    if ($Project) { $tasks = $tasks | Where-Object { $_.project -eq $Project } }
    if ($Priority -ge 0) { $tasks = $tasks | Where-Object { $_.priority -eq $Priority } }
    if ($Search) { $s = $Search.ToLower(); $tasks = $tasks | Where-Object { $_.text.ToLower().Contains($s) } }
    if ($Tag) { $tasks = $tasks | Where-Object { $_.tags -and ($_.tags -contains $Tag) } }
    if ($ByID2) { $tasks = $tasks | Where-Object { $_.project -and ($data.projects | Where-Object { $_.name -eq $_.project -and $_.ID2 -eq $ByID2 }) }
    }
    switch ($Filter) {
        'today'     { $tasks = $tasks | Where-Object { $_.due -eq $today.ToString('yyyy-MM-dd') } }
        'tomorrow'  { $tasks = $tasks | Where-Object { $_.due -eq $today.AddDays(1).ToString('yyyy-MM-dd') } }
        'overdue'   { $tasks = $tasks | Where-Object { $_.due -and [datetime]$_.due -lt $today } }
        'upcoming'  { $tasks = $tasks | Where-Object { $_.due -and [datetime]$_.due -gt $today -and [datetime]$_.due -le $today.AddDays(7) } }
        'noduedate' { $tasks = $tasks | Where-Object { -not $_.due } }
        'blocked'   { $tasks = $tasks | Where-Object { $_.depends -and $_.depends.Count -gt 0 } }
        default {} 
    }
    if ($Sort) {
        $tasks = $tasks | Sort-Object @(
            @{Expression = { if ($_.priority) { 4 - $_.priority } else { 0 } }; Descending = $false },
            @{Expression = { if ($_.due) { [datetime]$_.due } else { [datetime]::MaxValue } }; Descending = $false }
        )
    }
    return ,$tasks
}

function Undo-LastAction {
    # Initialize in-memory stack once if not already loaded
    if (-not $global:UndoStack -or $global:UndoStack.Count -eq 0) {
        if (Test-Path $global:UndoFile) {
            $global:UndoStack = Get-Content $global:UndoFile -Raw | ConvertFrom-Json
        } else {
            $global:UndoStack = @()
        }
    }
    
    if ($global:UndoStack.Count -eq 0) {
        Write-Host "Nothing to undo" -ForegroundColor Gray
        return
    }
    
    # Push current state to redo stack for Redo-Action support
    if ($global:DataCache) {
        $global:RedoStack += ($global:DataCache | ConvertTo-Json -Depth 10)
    }
    $previousState = $global:UndoStack[-1] | ConvertFrom-Json
    if ($global:UndoStack.Count -gt 1) {
        $global:UndoStack = $global:UndoStack[0..($global:UndoStack.Count - 2)]
    } else {
        $global:UndoStack = @()
    }
    
    # Save without adding to undo stack
    Save-TaskData -data $previousState -NoUndo
    
    # Persist updated stack
    if ($global:UndoStack.Count -gt 0) {
        $global:UndoStack | ConvertTo-Json -Depth 10 | Set-Content $global:UndoFile -Encoding UTF8
    } else {
        Remove-Item $global:UndoFile -ErrorAction SilentlyContinue
    }
    
    Write-Host "Undid last action" -ForegroundColor Green
}

function Set-CurrentContext {
    param([string]$projectName)
    
    $global:CurrentContext = $projectName
    $data = Get-TaskData  # use cached data
    if ($data) {
        $data.currentContext = $projectName
        Save-TaskData $data -NoUndo
    }
}

function Get-ContextPrompt {
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        return "Suite ($global:CurrentContext)> "
    }
    return "Suite> "
}

function Resolve-TaskIds {
    param([string]$inputString)
    
    $globalIds = @()
    $parts = $inputString -split '[,\s]+' | Where-Object { $_ }
    
    foreach ($part in $parts) {
        if ($part -match '^(\d+)-(\d+)$') {
            # Range support
            $start = [int]$matches[1]
            $end = [int]$matches[2]
            
            for ($i = $start; $i -le $end; $i++) {
                if ($global:LastShownTaskMap.ContainsKey($i)) {
                    $globalIds += $global:LastShownTaskMap[$i]
                } else {
                    $globalIds += $i  # Assume global ID
                }
            }
        }
        elseif ($part -match '^\d+$') {
            $localId = [int]$part
            
            # Check if it's a local ID from the last display
            if ($global:LastShownTaskMap.ContainsKey($localId)) {
                $globalIds += $global:LastShownTaskMap[$localId]
            } else {
                $globalIds += $localId  # Treat as global ID
            }
        }
    }
    
    return $globalIds | Select-Object -Unique
}

function Parse-DurationToMinutes {
    param([string]$duration)
    
    if ($duration -match '^(\d+(?:\.\d+)?)([mh])$') {
        $value = [double]$matches[1]
        if ($matches[2] -eq 'h') { 
            return [int]($value * 60) 
        } else { 
            return [int]$value 
        }
    }
    
    return 0
}

function Format-Duration {
    param([int]$minutes)
    
    if ($minutes -le 0) { return "" }
    
    $hours = [Math]::Floor($minutes / 60)
    $mins = $minutes % 60
    
    if ($hours -gt 0 -and $mins -gt 0) {
        return "${hours}h ${mins}m"
    } elseif ($hours -gt 0) {
        return "${hours}h"
    } else {
        return "${mins}m"
    }
}

function Parse-DateRange {
    param([string]$range)
    
    $today = (Get-Date).Date
    $result = @{ Start = $null; End = $null; Display = "" }
    
    switch -Regex ($range.ToLower()) {
        '^today$' {
            $result.Start = $today
            $result.End = $today.AddDays(1)
            $result.Display = "today"
        }
        '^yesterday$' {
            $result.Start = $today.AddDays(-1)
            $result.End = $today
            $result.Display = "yesterday"
        }
        '^this week$|^week$' {
            $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
            $result.Start = $weekStart
            $result.End = $weekStart.AddDays(7)
            $result.Display = "this week"
        }
        '^next week$|^nextweek$' {
            $thisWeekStart = $today.AddDays(-[int]$today.DayOfWeek)
            $nextWeekStart = $thisWeekStart.AddDays(7)
            $result.Start = $nextWeekStart
            $result.End = $nextWeekStart.AddDays(7)
            $result.Display = "next week"
        }
        '^last week$' {
            $lastWeekStart = $today.AddDays(-[int]$today.DayOfWeek - 7)
            $result.Start = $lastWeekStart
            $result.End = $lastWeekStart.AddDays(7)
            $result.Display = "last week"
        }
        '^this month$|^month$' {
            $result.Start = Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0
            $result.End = $result.Start.AddMonths(1)
            $result.Display = "this month"
        }
        '^last month$' {
            $firstOfMonth = Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0
            $result.Start = $firstOfMonth.AddMonths(-1)
            $result.End = $firstOfMonth
            $result.Display = "last month"
        }
        '(\d{4}-\d{2}-\d{2})\s+to\s+(\d{4}-\d{2}-\d{2})' {
            $result.Start = [datetime]$matches[1]
            $result.End = ([datetime]$matches[2]).AddDays(1)
            $result.Display = "$($matches[1]) to $($matches[2])"
        }
        '^\d{4}-\d{2}-\d{2}$' {
            $result.Start = [datetime]$range
            $result.End = $result.Start.AddDays(1)
            $result.Display = $range
        }
        default {
            $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
            $result.Start = $weekStart
            $result.End = $weekStart.AddDays(7)
            $result.Display = "this week (default)"
        }
    }
    
    return $result
}

function Extract-Metadata {
    param([string]$text)
    
    $result = @{
        CleanText = $text
        Project = $null
        Priority = 0
        Due = $null
        Duration = $null
        EstimatedTime = $null
        Tags = @()
        CustomFields = @{}
        Recur = $null
        RecurUntil = $null
        DependsOn = @()
    }
    
    $cleanText = $text
    
    # Extract @project (anywhere in string)
    if ($cleanText -match '@(\S+)') {
        $result.Project = $matches[1]
        $cleanText = $cleanText -replace '@\S+', ''
    }
    
    # Extract priority markers
    if ($cleanText -match '\s*(p1|!!!)(?:\s|$)') { 
        $result.Priority = 1
        $cleanText = $cleanText -replace '\s*(p1|!!!)(?:\s|$)', ' '
    }
    elseif ($cleanText -match '\s*(p2|!!)(?:\s|$)') { 
        $result.Priority = 2
        $cleanText = $cleanText -replace '\s*(p2|!!)(?:\s|$)', ' '
    }
    elseif ($cleanText -match '\s*(p3|!)(?:\s|$)') { 
        $result.Priority = 3
        $cleanText = $cleanText -replace '\s*(p3|!)(?:\s|$)', ' '
    }
    
    # Extract time duration (for logging)
    if ($cleanText -match '\s+(for|took):(\d+(?:\.\d+)?[hm])(?:\s|$)') {
        $result.Duration = $matches[2]
        $cleanText = $cleanText -replace '\s+(for|took):\d+(?:\.\d+)?[hm](?:\s|$)', ' '
    }
    
    # est: removed ‚Äî no estimate parsing
    
    # Extract due date
    if ($cleanText -match '\s+due:(\S+)(?:\s|$)') {
        $result.Due = $matches[1]
        $cleanText = $cleanText -replace '\s+due:\S+(?:\s|$)', ' '
    }
    
    # Extract recurrence
    if ($cleanText -match '\s+recur:(\S+)(?:\s|$)') {
        $result.Recur = $matches[1]
        $cleanText = $cleanText -replace '\s+recur:\S+(?:\s|$)', ' '
    }
    
    # Extract recurrence end
    if ($cleanText -match '\s+until:(\S+)(?:\s|$)') {
        $result.RecurUntil = $matches[1]
        $cleanText = $cleanText -replace '\s+until:\S+(?:\s|$)', ' '
    }
    
    # Extract dependencies
    while ($cleanText -match '\s+depends:(\d+)(?:\s|$)') {
        $result.DependsOn += [int]$matches[1]
        $cleanText = $cleanText -replace '\s+depends:\d+(?:\s|$)', ' '
    }
    
    # Extract custom fields (key:value)
    while ($cleanText -match '\s+(\w+):([^\s:]+)(?:\s|$)') {
        $key = $matches[1]
        if ($key -notin @('for', 'took', 'est', 'due', 'recur', 'until', 'depends')) {
            $result.CustomFields[$key] = $matches[2]
            $cleanText = $cleanText -replace ("\s+$([regex]::Escape($key)):[^\s:]+(?:\s|$)"), ' '
        }
    }
    
    # Extract hashtags (#tag) and plus-tags (+tag)
    while ($cleanText -match '(?:^|\s)[#\+](\w+)(?:\s|$)') {
        $result.Tags += $matches[1]
        $cleanText = $cleanText -replace '(?:^|\s)[#\+]\w+(?:\s|$)', ' '
    }
    # Remove minus-tags from text (they are handled separately for updates)
    while ($cleanText -match '(?:^|\s)-#?(\w+)(?:\s|$)') {
        $cleanText = $cleanText -replace '(?:^|\s)-#?\w+(?:\s|$)', ' '
    }
    
    # Clean up whitespace
    $result.CleanText = $cleanText.Trim() -replace '\s+', ' '
    
    return $result
}

function Format-StyledTable {
    param(
        [string[]]$Headers,
        [object[]]$DataRows,
        [string]$Title = "",
        [string]$BorderColor = "DarkGray",
        [string]$HeaderColor = "Yellow", 
        [string]$TitleColor = "Cyan",
        [string]$DataColor = "White",
        [int]$MaxTextWidth = 50  # Max width for text columns (usually task descriptions)
    )
    
    if ($Title) {
        Write-Host "`n  $Title" -ForegroundColor $TitleColor
        Write-Host "  $('‚îÄ' * $Title.Length)" -ForegroundColor $BorderColor
    }

    if (-not $DataRows -or $DataRows.Count -eq 0) {
        # Contextual empty state based on title or headers
        $emptyMessage = "  üì≠ No data to display"
        if ($Title -match "(?i)(task|todo)") {
            $emptyMessage = "  üìã No tasks found`n  üí° Use 'add <description>' to create your first task"
        } elseif ($Title -match "(?i)project") {
            $emptyMessage = "  üìÅ No projects found`n  üí° Use 'proj add <name>' to create your first project"
        } elseif ($Title -match "(?i)(time|report|log)") {
            $emptyMessage = "  ‚è±Ô∏è  No time entries found`n  üí° Use 'log @project date hours [desc]' to log time"
        }
        
        Write-Host $emptyMessage -ForegroundColor Yellow
        Write-Host ""
        return
    }

    # Apply text truncation to data rows for better layout
    $processedRows = @()
    foreach ($row in $DataRows) {
        $processedRow = @()
        for ($i = 0; $i -lt $row.Count; $i++) {
            $cell = if ($row[$i] -ne $null) { $row[$i].ToString() } else { "" }
            
            # Apply truncation to text columns (typically task descriptions in column 2 or 3)
            if ($i -eq 2 -or ($Headers[$i] -match "(?i)(task|text|description|content|note)")) {
                if ($cell.Length -gt $MaxTextWidth) {
                    $cell = $cell.Substring(0, $MaxTextWidth - 3) + "..."
                }
            }
            
            $processedRow += $cell
        }
        $processedRows += ,$processedRow
    }

    # Calculate column widths dynamically using processed data
    $colWidths = for ($i = 0; $i -lt $Headers.Length; $i++) {
        $headerLength = $Headers[$i].Length
        $dataLengths = $processedRows | ForEach-Object { 
            if ($_ -and $_.Count -gt $i -and $_[$i] -ne $null) { 
                $_[$i].ToString().Length 
            } else { 
                0 
            }
        }
        # Add a minimum width to prevent tiny columns and ensure padding
        [Math]::Max(8, [Math]::Max($headerLength, ($dataLengths | Measure-Object -Maximum).Maximum))
    }

    # Reusable scriptblock to build and write a line
    $builder = {
        param($items, $color)
        $line = "  "
        for ($i = 0; $i -lt $Headers.Length; $i++) {
            $value = if ($items -and $items.Count -gt $i -and $items[$i] -ne $null) { 
                $items[$i].ToString() 
            } else { 
                "" 
            }
            $line += $value.PadRight($colWidths[$i]) + "  " # 2 spaces for separation
        }
        Write-Host $line.TrimEnd() -ForegroundColor $color
    }

    # Draw Header
    & $builder $Headers $HeaderColor

    # Draw Separator
    $separatorItems = $colWidths | ForEach-Object { '‚îÄ' * $_ }
    & $builder $separatorItems $BorderColor

    # Draw Data Rows (using processed rows with truncation)
    foreach ($row in $processedRows) {
        & $builder $row $DataColor
    }
    Write-Host ""
}

function Format-ProjectID2Csv {
    param([string]$id2)
    if ([string]::IsNullOrWhiteSpace($id2)) { return "" }
    $core = $id2.Trim()
    $padLen = 12 - (1 + $core.Length + 1)
    if ($padLen -lt 0) { $padLen = 0 }
    return "V" + ("0" * $padLen) + $core + "S"
}

function Get-PriorityIcon {
    param([int]$Priority)
    $useAscii = $false
    try { $useAscii = [ConfigManager]::Config.Display.UseAsciiIcons } catch {}
    if ($useAscii) {
        switch ($Priority) {
            3 { return '^' }
            2 { return '+' }
            1 { return '-' }
            default { return '' }
        }
    } else {
        switch ($Priority) {
            3 { return 'üî∫' }
            2 { return 'üî∏' }
            1 { return 'üîπ' }
            default { return ' ' }
        }
    }
}

function Pause-Screen {
    Write-Host "`nPress any key to continue..." -ForegroundColor DarkGray
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

# Helpers: convert PSCustomObject trees to hashtables for safe indexing/merging
function Convert-PSObjectToHashtable {
    param($Object)
    if ($null -eq $Object) { return $null }
    if ($Object -is [hashtable]) { return $Object }
    if ($Object -is [pscustomobject]) {
        $ht = @{}
        foreach ($p in $Object.PSObject.Properties) { $ht[$p.Name] = Convert-PSObjectToHashtable $p.Value }
        return $ht
    }
    if ($Object -is [System.Collections.IEnumerable] -and -not ($Object -is [string])) {
        return @($Object | ForEach-Object { Convert-PSObjectToHashtable $_ })
    }
    return $Object
}

# === CONFIGURATION UI ===
function Show-Config {
    try { [ConfigManager]::Load() } catch {}
    $cfg = [ConfigManager]::Config
    $rows = @()
    foreach ($kv in $cfg.Display.GetEnumerator() | Sort-Object Name) { $rows += , @("Display.$($kv.Key)", "$($kv.Value)") }
    foreach ($kv in $cfg.Behavior.GetEnumerator() | Sort-Object Name) { $rows += , @("Behavior.$($kv.Key)", "$($kv.Value)") }
    if ($cfg.Paths) { foreach ($kv in $cfg.Paths.GetEnumerator() | Sort-Object Name) { $rows += , @("Paths.$($kv.Key)", "$($kv.Value)") } }
    if ($cfg.Excel) { foreach ($kv in $cfg.Excel.GetEnumerator() | Sort-Object Name) { $rows += , @("Excel.$($kv.Key)", "$($kv.Value)") } }
    Format-StyledTable -Headers @('Key','Value') -DataRows $rows -Title '‚öô CURRENT SETTINGS'
}

function Convert-ToTypedValue {
    param([string]$Text)
    if ($null -eq $Text) { return $null }
    $t = $Text.Trim()
    if ($t -match '^(?i:true|false)$') { return [bool]::Parse($t) }
    if ($t -match '^-?\d+$') { return [int]$t }
    if ($t -match '^-?\d+\.\d+$') { return [double]$t }
    return $t
}

function Set-ConfigValue {
    param(
        [Parameter(Mandatory=$true)][string]$Path,
        [Parameter(Mandatory=$true)]$Value
    )
    $cfg = [ConfigManager]::Config
    if ($Path -match '^(?<section>\w+)\.(?<key>\w+)$') {
        $section = $matches.section
        $key = $matches.key
        if (-not $cfg.ContainsKey($section)) { Write-Host "Unknown section: $section" -ForegroundColor Yellow; return }
        $typed = if ($Value -is [string]) { Convert-ToTypedValue $Value } else { $Value }
        $cfg.$section[$key] = $typed
        [ConfigManager]::Config = $cfg
    } else {
        Write-Host "Use Section.Key format, e.g., Display.UseAsciiIcons" -ForegroundColor Yellow
    }
}

function Toggle-ConfigValue {
    param([string]$Path)
    if ($Path -match '^(?<section>\w+)\.(?<key>\w+)$') {
        $cfg = [ConfigManager]::Config
        $section = $matches.section; $key = $matches.key
        if ($cfg.$section.ContainsKey($key)) {
            $current = $cfg.$section[$key]
            if ($current -is [bool]) { $cfg.$section[$key] = -not $current } else { Write-Host "Not a boolean: $Path" -ForegroundColor Yellow }
            [ConfigManager]::Config = $cfg
        }
    }
}

function Set-ConfigFromCommand {
    param([CommandContext]$context)
    $text = $context.GetText()
    if ($text -match '^(?<path>\S+)\s+(?<val>.+)$') {
        Set-ConfigValue -Path $matches.path -Value $matches.val
        [ConfigManager]::Save()
        Show-Config
    } else {
        Write-Host "Usage: config set <Section.Key> <value>" -ForegroundColor Yellow
        Write-Host "Example: config set Display.UseAsciiIcons true" -ForegroundColor Gray
    }
}

function Show-ConfigEditor {
    param([CommandContext]$context)
    try { [ConfigManager]::Load() } catch {}
    while ($true) {
        Clear-Host
        Show-Config
        Write-Host "Commands: set <Section.Key> <value> | toggle <Section.Key> | save | exit" -ForegroundColor DarkGray
        $input = Read-Host "config>"
        if (-not $input) { break }
        if ($input -match '^(?i)(exit|quit|q)$') { break }
        elseif ($input -match '^(?i)save$') { [ConfigManager]::Save(); Write-Host "Saved." -ForegroundColor Green; Start-Sleep -Milliseconds 600 }
        elseif ($input -match '^(?i)toggle\s+(\S+)$') { Toggle-ConfigValue $matches[1] }
        elseif ($input -match '^(?i)set\s+(\S+)\s+(.+)$') { Set-ConfigValue -Path $matches[1] -Value $matches[2] }
        else { Write-Host "Unrecognized command." -ForegroundColor Yellow; Start-Sleep -Milliseconds 800 }
    }
}

# === EXCEL T2020 INTEGRATION ===
function Ensure-ExcelModule {
    $modulePath = Join-Path $PSScriptRoot 'ExcelT2020.psm1'
    if (-not (Get-Module -Name ExcelT2020 -ListAvailable)) {
        if (Test-Path $modulePath) { Import-Module $modulePath -Force } else { throw "ExcelT2020 module not found at $modulePath" }
    }
}

function Import-ExcelT2020 {
    try { Ensure-ExcelModule } catch { Write-Host $_ -ForegroundColor Red; return }
    # Apply config to module if available
    try {
        [ConfigManager]::Load()
        $cfg = [ConfigManager]::Config
        if ($cfg.Excel) {
            Set-ExcelT2020Config -SourceFolder $cfg.Excel.SourceFolder -DestinationPath $cfg.Excel.DestinationPath -SourceSheetName $cfg.Excel.SourceSheet -DestSheetName $cfg.Excel.DestSheet
        }
    } catch {}
    $result = Invoke-T2020Batch
    if (-not $result.Success) { Write-Host "Excel import failed" -ForegroundColor Red; return }

    # Persist a summary inside T2 data for viewing
    $data = Get-TaskData
    if (-not $data.excelImports) { $data | Add-Member -NotePropertyName excelImports -NotePropertyValue @() -Force }
    foreach ($rec in $result.Summary) {
        $data.excelImports += [PSCustomObject]@{
            Timestamp = $rec.Timestamp
            Source    = $rec.Source
            Destination = $rec.Destination
            Count     = $rec.Count
            Success   = $rec.Success
            Fields    = $rec.Fields
        }
    }

    # Attempt to bind imports to projects using ID2 = CASNumber
    $id2Field = 'CASNumber'
    try { if ($cfg.Excel -and $cfg.Excel.ID2FieldName) { $id2Field = $cfg.Excel.ID2FieldName } } catch {}
    foreach ($rec in $result.Summary) {
        if (-not $rec.Fields) { continue }
        $id2Val = $null
        foreach ($p in $rec.Fields.PSObject.Properties) { if ($p.Name -ieq $id2Field) { $id2Val = $p.Value; break } }
        if ([string]::IsNullOrWhiteSpace($id2Val)) { continue }
        $proj = $data.projects | Where-Object { $_.ID2 -and $_.ID2 -eq $id2Val } | Select-Object -First 1
        if ($proj) {
            # Store fields on the project for direct viewing
            if (-not $proj.PSObject.Properties['ExcelFields']) { $proj | Add-Member -NotePropertyName ExcelFields -NotePropertyValue @{} -Force }
            $proj.ExcelFields = $rec.Fields
            # Optionally backfill ID1 from TaxID if empty
            if (-not $proj.ID1 -or [string]::IsNullOrWhiteSpace($proj.ID1)) {
                foreach ($p in $rec.Fields.PSObject.Properties) { if ($p.Name -ieq 'TaxID' -and $p.Value) { $proj.ID1 = $p.Value; break } }
            }
        }
    }
    $global:LastAction = 'excel import'
    Save-TaskData $data

    # Show quick table summary
    $rows = @()
    foreach ($rec in $result.Summary | Select-Object -Last 10) {
        $rows += , @($rec.Timestamp, (Split-Path $rec.Source -Leaf), $rec.Count, ($rec.Success ? 'OK' : 'ERR'))
    }
    if ($rows.Count -eq 0) { $rows = @(@('(no files)', '', '', '')) }
    Format-StyledTable -Headers @('Time','File','Fields','Status') -DataRows $rows -Title 'Excel T2020 Import Summary'
    Write-Host ("  ‚úÖ Imported {0}/{1} file(s)" -f ($result.Summary | Where-Object { $_.Success }).Count, ($result.Summary).Count) -ForegroundColor Green
}

function Show-ExcelLatest {
    $data = Get-TaskData
    $imports = @($data.excelImports)
    if ($imports.Count -eq 0) { Format-StyledTable -Headers @('Info') -DataRows @(@('No Excel imports yet')) -Title 'Excel Imports'; return }
    $rows = @()
    $last = $imports | Select-Object -Last 10
    $i = [Math]::Max(1, $imports.Count - $last.Count + 1)
    foreach ($rec in $last) {
        $rows += , @($i, $rec.Timestamp, (Split-Path $rec.Source -Leaf), $rec.Count, ($rec.Success ? 'OK' : 'ERR'))
        $i++
    }
    Format-StyledTable -Headers @('#','Time','File','Fields','Status') -DataRows $rows -Title 'Recent Excel Imports'
}

function Show-ExcelImportDetails {
    param($context)
    $data = Get-TaskData
    $imports = @($data.excelImports)
    if ($imports.Count -eq 0) { Format-StyledTable -Headers @('Info') -DataRows @(@('No Excel imports yet')) -Title 'Excel Import Details'; return }
    $arg = if ($context) { $context.GetText() } else { '' }
    $rec = $null
    if ($arg -match '^\d+$') {
        $idx = [int]$arg
        if ($idx -ge 1 -and $idx -le $imports.Count) { $rec = $imports[$idx - 1] }
    } elseif ($arg) {
        $rec = ($imports | Where-Object { $_.Source -like "*${arg}*" } | Select-Object -Last 1)
    } else {
        $rec = $imports[-1]
    }
    if (-not $rec) { Format-StyledTable -Headers @('Info') -DataRows @(@('Import not found')) -Title 'Excel Import Details'; return }
    $rows = @();
    foreach ($k in $rec.Fields.Keys) { $rows += , @($k, ($rec.Fields[$k] -as [string])) }
    if ($rows.Count -eq 0) { $rows = @(@('(no fields)','')) }
    $title = "Fields for: " + (Split-Path $rec.Source -Leaf)
    Format-StyledTable -Headers @('Field','Value') -DataRows $rows -Title $title
}

function Show-ExcelProjectFields {
    param($context)
    $name = if ($context) { $context.GetText() } else { '' }
    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Usage: excel view project <name>" -ForegroundColor Yellow; return }
    $project = Find-Project -query $name -Interactive
    if (-not $project) { return }
    if (-not $project.PSObject.Properties['ExcelFields'] -or -not $project.ExcelFields) {
        Format-StyledTable -Headers @('Info') -DataRows @(@('No Excel fields on this project. Run "excel import".')) -Title ("EXCEL FIELDS - " + $project.name.ToUpper())
        return
    }
    $rows = @(); foreach ($p in $project.ExcelFields.PSObject.Properties) { $rows += , @($p.Name, ($p.Value -as [string])) }
    Format-StyledTable -Headers @('Field','Value') -DataRows $rows -Title ("EXCEL FIELDS - " + $project.name.ToUpper())
}

function Set-ProjectFields {
    param($context)
    $text = $context.GetText()
    if (-not $text) {
        Write-Host "Usage: proj set <name> key=value [key=value ...]" -ForegroundColor Yellow
        return
    }
    # Split project name and updates
    $parts = $text -split '\s+', 2
    if ($parts.Count -lt 2) { Write-Host "Usage: proj set <name> key=value [key=value ...]" -ForegroundColor Yellow; return }
    $name = $parts[0]
    $updates = $parts[1]
    $data = Get-TaskData
    $project = $data.projects | Where-Object { $_.name -eq $name } | Select-Object -First 1
    if (-not $project) { Write-Host "Project '$name' not found" -ForegroundColor Red; return }

    $allowed = @('ID1','ID2','ProjFolder','AssignedDate','DueDate','BFDate','CAAName','RequestName','T2020')
    $changed = @()
    # Tokenize updates with quoted-value support key="some value"
    $pattern = '(\w+)=(("[^"]+")|[^\s]+)'
    $m = [regex]::Matches($updates, $pattern)
    foreach ($match in $m) {
        $k = $match.Groups[1].Value
        $v = $match.Groups[2].Value.Trim('"')
        if ($k -eq 'x' -and $v -match '^(\w+):(.*)$') {
            # x:FieldName:Value -> set ExcelFields
            $xf = $matches[1]; $xv = $matches[2]
            if (-not $project.PSObject.Properties['ExcelFields']) { $project | Add-Member -NotePropertyName ExcelFields -NotePropertyValue @{} -Force }
            $project.ExcelFields[$xf] = $xv
            $changed += "ExcelFields.$xf=$xv"
            continue
        }
        if ($k -notin $allowed) { Write-Host "Skipping unknown field '$k'" -ForegroundColor Yellow; continue }
        # Basic normalization for dates (store as yyyy-MM-dd if matchable)
        if ($k -match 'Date$') {
            try { $d = [datetime]::Parse($v); $v = $d.ToString('yyyy-MM-dd') } catch {}
        }
        if ($project.PSObject.Properties[$k]) { $project.$k = $v } else { Add-Member -InputObject $project -MemberType NoteProperty -Name $k -Value $v }
        $changed += "$k=$v"
    }
    Save-TaskData $data
    if ($changed.Count -gt 0) { Write-Host ("Updated {0}: {1}" -f $project.name, ($changed -join ', ')) -ForegroundColor Green } else { Write-Host "No valid updates applied." -ForegroundColor Yellow }
}

# === ROBUST COMPLETION SYSTEM ===

# Completion modes - finite state machine
enum CompletionMode {
    Command          # Completing command names (add, done, proj)
    Subcommand      # Completing subcommands (proj add, timer start)
    SyntaxDiscovery # Showing argument syntax patterns (@, p1, due:)
    PrefixCompletion # Completing within a prefix (@projects, due:dates)
    FreeText        # No completions available
    Help           # Showing help/syntax guidance
}

# Comprehensive completion state
class CompletionState {
    # Current parsing state
    [string] $OriginalBuffer = ""
    [string] $CurrentCommand = ""          # Legacy - use FullCommandName instead
    [array] $CompletedArguments = @()      # Legacy - use ParsedArguments instead
    [string] $CurrentToken = ""
    [bool] $TokenComplete = $false
    [int] $CursorPosition = 0
    
    # Enhanced parsing state (Phase 2)
    [string] $FullCommandName = ""         # Complete resolved command name
    [array] $ArgumentTokens = @()          # Array of ParsedToken objects for arguments
    [ParsedToken] $TokenUnderCursor = $null   # Token at cursor position
    [bool] $IsOnNewWord = $false           # True if cursor is on a new word position
    [hashtable] $ParsedArguments = @{}     # Structured argument parsing
    
    # Completion mode and context
    [CompletionMode] $Mode = [CompletionMode]::Command
    [string] $PrefixBeingCompleted = ""
    [array] $AvailableCompletions = @()
    [hashtable] $ParsedContext = @{}
    
    # State management with deep copy support
    [CompletionState] Clone() {
        $clone = [CompletionState]::new()
        
        # Copy legacy properties
        $clone.OriginalBuffer = $this.OriginalBuffer
        $clone.CurrentCommand = $this.CurrentCommand
        $clone.CompletedArguments = @($this.CompletedArguments)  # New array, same references
        $clone.CurrentToken = $this.CurrentToken
        $clone.TokenComplete = $this.TokenComplete
        $clone.CursorPosition = $this.CursorPosition
        
        # Copy enhanced properties (Phase 2)
        $clone.FullCommandName = $this.FullCommandName
        $clone.ArgumentTokens = @($this.ArgumentTokens)  # New array, same token references
        $clone.TokenUnderCursor = $this.TokenUnderCursor  # Reference copy is fine for immutable tokens
        $clone.IsOnNewWord = $this.IsOnNewWord
        $clone.ParsedArguments = @{}  # Create new hashtable
        if ($this.ParsedArguments) {
            foreach ($key in $this.ParsedArguments.Keys) {
                $clone.ParsedArguments[$key] = $this.ParsedArguments[$key]
            }
        }
        
        # Copy completion context
        $clone.Mode = $this.Mode
        $clone.PrefixBeingCompleted = $this.PrefixBeingCompleted
        $clone.AvailableCompletions = @($this.AvailableCompletions)  # New array
        $clone.ParsedContext = @{}  # Create new hashtable
        if ($this.ParsedContext) {
            foreach ($key in $this.ParsedContext.Keys) {
                $clone.ParsedContext[$key] = $this.ParsedContext[$key]
            }
        }
        
        return $clone
    }
    
    [void] Reset() {
        # Reset legacy properties
        $this.OriginalBuffer = ""
        $this.CurrentCommand = ""
        $this.CompletedArguments = @()
        $this.CurrentToken = ""
        $this.TokenComplete = $false
        $this.CursorPosition = 0
        
        # Reset enhanced properties (Phase 2)
        $this.FullCommandName = ""
        $this.ArgumentTokens = @()
        $this.TokenUnderCursor = $null
        $this.IsOnNewWord = $false
        $this.ParsedArguments = @{}
        
        # Reset completion context
        $this.Mode = [CompletionMode]::Command
        $this.PrefixBeingCompleted = ""
        $this.AvailableCompletions = @()
        $this.ParsedContext = @{}
    }
}

# Token with position information
class ParsedToken {
    [string] $Text = ""
    [int] $StartPos = 0
    [int] $EndPos = 0
    [bool] $IsComplete = $true
    [string] $Type = "Unknown"  # Command, Argument, Prefix, etc.
    
    ParsedToken([string] $text, [int] $start, [int] $end) {
        $this.Text = $text
        $this.StartPos = $start
        $this.EndPos = $end
    }
}

# Completion item with rich metadata
class CompletionItem {
    [string] $Text = ""
    [string] $Description = ""
    [string] $Category = ""
    [string] $Type = ""
    [int] $Score = 0
    [hashtable] $Metadata = @{}
    
    CompletionItem([string] $text, [string] $description, [string] $category, [int] $score) {
        $this.Text = $text
        $this.Description = $description
        $this.Category = $category
        $this.Score = $score
    }
}

# Command execution context - wrapper around CompletionState for command handlers
class CommandContext {
    [string] $CommandName = ""           # The resolved command name (e.g., "add", "proj add")
    [hashtable] $Args = @{}              # Structured arguments (e.g., @{project="work"; priority=1})
    [string[]] $FreeText = @()           # Non-argument text tokens
    [string] $RawText = ""               # Clean remaining text after argument extraction
    [CompletionState] $State = $null     # Full parser state for advanced use cases
    [object] $Parser = $null             # Reference to parser for schema access
    
    # Validation properties
    [string[]] $ValidationErrors = @()   # List of validation error messages
    [string[]] $ValidationWarnings = @() # List of validation warnings
    [bool] $IsValid = $true              # True if no validation errors
    
    # Constructor from CompletionState and Parser
    CommandContext([CompletionState] $state, [object] $parser) {
        $this.State = $state
        $this.Parser = $parser
        $this.CommandName = $state.FullCommandName
        $this.ParseArguments()
        $this.ValidateCommand()  # Validate after parsing arguments
    }
    
    # Legacy constructor for backward compatibility
    CommandContext([CompletionState] $state) {
        $this.State = $state
        $this.CommandName = $state.FullCommandName
        $this.ParseArguments()
        $this.ValidateCommand()  # Validate after parsing arguments
    }
    
    # Parse ArgumentTokens into structured Args and FreeText
    [void] ParseArguments() {
        $this.Args = @{}
        $freeTextTokens = @()
        $cmdName = if ($this.CommandName) { $this.CommandName.ToLower() } else { '' }
        $preserveArgsInFreeText = ($cmdName -in @('update','move','postpone','duplicate','delete','done'))
        
        foreach ($token in $this.State.ArgumentTokens) {
            $text = $token.Text
            
            # Project arguments (@project)
            if ($text -match '^@(.+)$') {
                $projVal = $matches[1]
                if ($projVal.StartsWith('"') -and $projVal.EndsWith('"') -and $projVal.Length -ge 2) {
                    $projVal = $projVal.Substring(1, $projVal.Length-2)
                }
                $this.Args['project'] = $projVal
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Priority arguments (p1, p2, p3, !, !!, !!!)
            elseif ($text -match '^p([123])$') {
                $this.Args['priority'] = [int]$matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            elseif ($text -eq '!') {
                $this.Args['priority'] = 1
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            elseif ($text -eq '!!') {
                $this.Args['priority'] = 2
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            elseif ($text -eq '!!!') {
                $this.Args['priority'] = 3
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Due date arguments (due:date)
            elseif ($text -match '^due:(.+)$') {
                $this.Args['due'] = $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # est: removed ‚Äî do not parse
            # Description argument (desc:text)
            elseif ($text -match '^desc:(.+)$') {
                $this.Args['desc'] = $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Tag arguments (#tag or +tag)
            elseif ($text -match '^#(.+)$') {
                if (-not $this.Args.ContainsKey('tags')) {
                    $this.Args['tags'] = @()
                }
                $this.Args['tags'] += $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            elseif ($text -match '^\+(.+)$') {
                if (-not $this.Args.ContainsKey('tags')) {
                    $this.Args['tags'] = @()
                }
                $this.Args['tags'] += $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Remove tag arguments (-tag or -#tag)
            elseif ($text -match '^-#?(.+)$') {
                if (-not $this.Args.ContainsKey('removeTags')) {
                    $this.Args['removeTags'] = @()
                }
                $this.Args['removeTags'] += $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Recurrence arguments (recur:pattern)
            elseif ($text -match '^recur:(.+)$') {
                $this.Args['recur'] = $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Dependency arguments (dep:id)
            elseif ($text -match '^dep:(.+)$') {
                if (-not $this.Args.ContainsKey('dependencies')) {
                    $this.Args['dependencies'] = @()
                }
                $this.Args['dependencies'] += $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Everything else is free text
            else {
                $freeTextTokens += $text
            }
        }
        
        $this.FreeText = $freeTextTokens
        $this.RawText = ($freeTextTokens -join ' ').Trim()

        # Command-aware normalization: extract IDs/delta from free text into Args (without removing from text)
        try {
            $cmd = if ($this.CommandName) { $this.CommandName.ToLower() } else { '' }
            $needsId = $cmd -in @('update','move','postpone','duplicate','delete','done')
            if ($needsId -and $this.FreeText.Count -gt 0) {
                $idToken = $this.FreeText[0]
                if ($idToken -match '^\d+([,-]\d+)*$') { $this.Args['id'] = $idToken }
                if ($cmd -eq 'postpone' -and $this.FreeText.Count -gt 1) { $this.Args['delta'] = $this.FreeText[1] }
            }
        } catch { }
    }
    
    # Helper methods for common operations
    [bool] HasArg([string] $name) {
        return $this.Args.ContainsKey($name)
    }
    
    [object] GetArg([string] $name, [object] $default = $null) {
        if ($this.Args.ContainsKey($name)) {
            return $this.Args[$name]
        }
        return $default
    }
    
    [string] GetProject() {
        return $this.GetArg('project', $global:CurrentContext)
    }
    
    [int] GetPriority() {
        return $this.GetArg('priority', 0)
    }
    
    [string[]] GetTags() {
        return $this.GetArg('tags', @())
    }
    
    [string] GetText() {
        return $this.RawText
    }
    
    # Validation methods
    [void] AddError([string] $message) {
        $this.ValidationErrors += $message
        $this.IsValid = $false
    }
    
    [void] AddWarning([string] $message) {
        $this.ValidationWarnings += $message
    }
    
    [void] ValidateCommand() {
        # Use schema-based validation if available
        if ($this.Parser -and $this.Parser.CommandSchemas -and $this.Parser.CommandSchemas.ContainsKey($this.CommandName)) {
            $this.ValidateWithSchema($this.Parser.CommandSchemas[$this.CommandName])
        } else {
            # Fall back to legacy validation
            $this.ValidateWithoutSchema()
        }
    }
    
    [void] ValidateWithSchema([CommandSchema] $schema) {
        # Validate required arguments
        foreach ($argSchema in $schema.Arguments) {
            if ($argSchema.Required) {
                if ($argSchema.Type -eq "text") {
                    # Text arguments are validated by checking FreeText
                    if ($this.FreeText.Count -eq 0 -or [string]::IsNullOrWhiteSpace($this.GetText())) {
                        $this.AddError("$($argSchema.Description) is required")
                    }
                } elseif (-not $this.HasArg($argSchema.Name)) {
                    # Option B: allow required arg to be satisfied from FreeText when it matches pattern/expectation
                    $satisfied = $false
                    if ($this.FreeText -and $this.FreeText.Count -gt 0) {
                        # Check all free-text tokens for a match (first wins)
                        foreach ($tok in $this.FreeText) {
                            if ($argSchema.Pattern -and ($tok -match $argSchema.Pattern)) { $satisfied = $true; break }
                            elseif (-not $argSchema.Pattern) {
                                # Heuristics for common types
                                if ($argSchema.Name -eq 'id' -and $tok -match '^\d+([,-]\d+)*$') { $satisfied = $true; break }
                                elseif ($argSchema.Name -eq 'delta' -and ($tok -match '^\+\d+d$' -or $tok -match '^\d{4}-\d{2}-\d{2}$' -or $tok -match '^(?i)tomorrow|today$')) { $satisfied = $true; break }
                                elseif ($argSchema.Type -eq 'project' -and $tok -match '^@') { $satisfied = $true; break }
                                elseif ($argSchema.Type -eq 'duration' -and $tok -match '^\d+(?:\.\d+)?[hm]$') { $satisfied = $true; break }
                                elseif ($argSchema.Type -eq 'date' -and ($tok -match '^\d{4}-\d{2}-\d{2}$' -or $tok -match '^(?i)today|tomorrow$')) { $satisfied = $true; break }
                                else { if (-not [string]::IsNullOrWhiteSpace($tok)) { $satisfied = $true; break } }
                            }
                        }
                    }
                    if (-not $satisfied) {
                        $this.AddError("$($argSchema.Description) is required")
                    }
                }
            }
        }
        
        # Validate argument patterns and values
        foreach ($argName in $this.Args.Keys) {
            $argSchema = $schema.GetArgumentSchema($argName)
            if ($argSchema) {
                $value = $this.Args[$argName]
                
                # Pattern validation
                if ($argSchema.Pattern -and $value -notmatch $argSchema.Pattern) {
                    $this.AddError("Invalid format for $($argSchema.Name): '$value'. Expected format: $($argSchema.Example)")
                }
                
                # Valid values validation
                if ($argSchema.ValidValues.Count -gt 0 -and $value -notin $argSchema.ValidValues) {
                    $validStr = $argSchema.ValidValues -join ", "
                    $this.AddError("Invalid value for $($argSchema.Name): '$value'. Valid values: $validStr")
                }
            }
        }
    }
    
    [void] ValidateWithoutSchema() {
        # Legacy validation for backward compatibility
        switch ($this.CommandName) {
            'add' {
                # Add command validation
                if ([string]::IsNullOrWhiteSpace($this.GetText())) {
                    $this.AddError("Task description is required")
                }
                
                # Check for conflicting priority arguments
                if ($this.HasArg('priority')) {
                    $priority = $this.GetArg('priority', 0)
                    if ($priority -lt 0 -or $priority -gt 3) {
                        $this.AddError("Priority must be between 0 and 3 (p1=high, p2=med, p3=low)")
                    }
                }
                
                # Validate due date format if provided
                if ($this.HasArg('due')) {
                    $dueStr = $this.GetArg('due', '')
                    if (-not [string]::IsNullOrEmpty($dueStr)) {
                        # Normalize and validate with both smart and natural parsers
                        $norm = $dueStr.Trim()
                        if ($norm.StartsWith('"') -and $norm.EndsWith('"') -and $norm.Length -ge 2) { $norm = $norm.Substring(1, $norm.Length-2) }
                        if ($norm.StartsWith("'") -and $norm.EndsWith("'") -and $norm.Length -ge 2) { $norm = $norm.Substring(1, $norm.Length-2) }
                        $norm = $norm.Trim().TrimEnd(',', '.', ';', ':')
                        Write-DebugLog ("VALID: due normalized from '" + $dueStr + "' -> '" + $norm + "'")
                        $ok = $false
                        try { $tmp = Parse-SmartDate $norm; if ($tmp) { $ok = $true } } catch {}
                        if (-not $ok) { try { $tmp2 = Parse-NaturalDate -input $norm; if ($tmp2) { $ok = $true } } catch {} }
                        if (-not $ok) {
                            $this.AddError("Invalid due date format: '" + $dueStr + "'. Use formats like 'today', 'tomorrow', '+3d', 'eom', or '2024-12-25'")
                        }
                    }
                }
                
                # est: removed ‚Äî no estimate validation
                
                # Check for empty project name
                if ($this.HasArg('project')) {
                    $proj = $this.GetArg('project', '')
                    if ([string]::IsNullOrWhiteSpace($proj)) {
                        $this.AddError("Project name cannot be empty")
                    }
                }
            }
            
            'proj add' {
                # Project creation validation
                if ([string]::IsNullOrWhiteSpace($this.GetText())) {
                    $this.AddError("Project name is required")
                }
            }
            
            'dep add' {
                # Dependency validation - need two task IDs
                $argCount = $this.FreeText.Count
                if ($argCount -lt 2) {
                    $this.AddError("Dependency requires two task IDs: dep add <task> <depends-on>")
                } elseif ($argCount -gt 2) {
                    $this.AddWarning("Extra arguments ignored. Usage: dep add <task> <depends-on>")
                }
            }
        }
    }
    
    [void] ShowValidationErrors() {
        if ($this.ValidationErrors.Count -gt 0) {
            Write-Host "  ‚ùå VALIDATION ERRORS:" -ForegroundColor Red
            foreach ($error in $this.ValidationErrors) {
                Write-Host "     ‚Ä¢ $error" -ForegroundColor Red
            }
            Write-Host ""
        }
        
        if ($this.ValidationWarnings.Count -gt 0) {
            Write-Host "  ‚ö†Ô∏è  WARNINGS:" -ForegroundColor Yellow
            foreach ($warning in $this.ValidationWarnings) {
                Write-Host "     ‚Ä¢ $warning" -ForegroundColor Yellow
            }
            Write-Host ""
        }
    }
}

# Argument schema system for command validation and smart completions
class ArgumentSchema {
    [string] $Name = ""              # Argument name (e.g., "project", "priority", "due")
    [string] $Type = ""              # Argument type (e.g., "project", "priority", "date", "text")
    [string] $Prefix = ""            # Required prefix (e.g., "@", "due:", "#")
    [bool] $Required = $false        # Whether this argument is required
    [string[]] $ValidValues = @()    # Valid values for enum-type arguments
    [string] $Pattern = ""           # Regex pattern for validation
    [string] $Description = ""       # Human-readable description
    [string] $Example = ""           # Example usage
}

class CommandSchema {
    [string] $CommandName = ""       # The command this schema applies to
    [ArgumentSchema[]] $Arguments = @() # Array of argument schemas
    [string] $Description = ""       # Command description
    [string] $Syntax = ""           # Syntax example
    
    # Helper to get schema for a specific argument
    [ArgumentSchema] GetArgumentSchema([string] $argName) {
        return $this.Arguments | Where-Object { $_.Name -eq $argName } | Select-Object -First 1
    }
    
    # Get all argument schemas by type
    [ArgumentSchema[]] GetArgumentsByType([string] $type) {
        return $this.Arguments | Where-Object { $_.Type -eq $type }
    }
}

class SmartCommandParser {
    [hashtable] $Commands = @{}
    [hashtable] $Aliases = @{}
    [hashtable] $CommandSchemas = @{}     # Command argument schemas
    [CompletionState] $CurrentState = [CompletionState]::new()
    [object] $CachedData = $null
    [datetime] $CacheTime = [datetime]::MinValue
    # Lightweight memoization for repeated identical completion requests
    [string] $LastCompletionBuffer = ""
    [int] $LastCompletionCursor = -1
    [array] $LastCompletionResult = @()
    [datetime] $LastCompletionTime = [datetime]::MinValue
    
    SmartCommandParser() {
        $this.InitializeCommands()
        $this.InitializeAliases()
        $this.InitializeCommandSchemas()
    }
    
    [void] InitializeCommands() {
        $this.Commands = @{
            # === VIEW COMMANDS (Enhanced) ===
            'agenda' = @{
                Handler = { Show-RichAgenda }
                Description = "Smart agenda with calendar integration"
                Category = "View"
            }
            'list' = @{
                Handler = { param($context) Show-AllTasks $context }
                Description = "List all pending tasks grouped by project"
                Category = "View"
            }
            'view' = @{
                Handler = { param($context) Show-TaskDetails $context }
                Description = "View detailed information about a specific task"
                Category = "View" 
                NeedsArg = $true
            }
            'projects' = @{
                Handler = { Show-ProjectDashboard }
                Description = "Display project dashboard with task counts and stats"
                Category = "View"
            }
            'today' = @{
                Handler = { Show-FilteredTasks @{Filter='today'} }
                Description = "Tasks due today"
                Category = "View"
            }
            'tomorrow' = @{
                Handler = { Show-FilteredTasks @{Filter='tomorrow'} }
                Description = "Tasks due tomorrow"
                Category = "View"
            }
            'week' = @{
                Handler = { Show-WeekView }
                Description = "Week calendar view"
                Category = "View"
            }
            'month' = @{
                Handler = { Show-MonthView }
                Description = "Month calendar view"
                Category = "View"
            }
            'overdue' = @{
                Handler = { Show-FilteredTasks @{Filter='overdue'} }
                Description = "Overdue tasks"
                Category = "View"
            }
            'upcoming' = @{
                Handler = { Show-FilteredTasks @{Filter='upcoming'} }
                Description = "Next 7 days"
                Category = "View"
            }
            'noduedate' = @{
                Handler = { Show-FilteredTasks @{Filter='noduedate'} }
                Description = "Tasks without due dates"
                Category = "View"
            }
            'priority' = @{
                Handler = { param($context) Show-FilteredTasks @{Priority=$context.GetText()} }
                Description = "Filter by priority (1-3)"
                Category = "View"
                NeedsArg = $true
            }
            'search' = @{
                Handler = { param($context) Show-FilteredTasks @{Search=$context.GetText()} }
                Description = "Search tasks"
                Category = "View"
                NeedsArg = $true
            }
            'blocked' = @{
                Handler = { Show-BlockedTasks }
                Description = "Tasks with unmet dependencies"
                Category = "View"
            }
            
            # === PROJECT COMMANDS (Enhanced) ===
            'proj' = @{
                Handler = { Show-ProjectDashboard }
                Description = "Project dashboard with stats"
                Category = "Project"
            }
            'project' = @{
                Handler = { Show-ProjectDashboard }
                Description = "Project dashboard with stats"
                Category = "Project"
            }
            'proj add' = @{
                Handler = { param($context) 
                    $name = ($context.GetText()).Trim()
                    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Project name is required" -ForegroundColor Red; return }
                    $parsed = @{ Name = $name; Fields = @{} }
                    Add-Project $parsed 
                }
                Description = "Create new project"
                Category = "Project"
                NeedsArg = $true
            }
            'project add' = @{
                Handler = { param($context) 
                    $name = ($context.GetText()).Trim()
                    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Project name is required" -ForegroundColor Red; return }
                    $parsed = @{ Name = $name; Fields = @{} }
                    Add-Project $parsed 
                }
                Description = "Create new project"
                Category = "Project"
                NeedsArg = $true
            }
            'proj rename' = @{
                Handler = { param($context) Rename-Project $context }
                Description = "Rename project"
                Category = "Project"
                NeedsArg = $true
            }
            'project rename' = @{
                Handler = { param($context) Rename-Project $context }
                Description = "Rename project"
                Category = "Project"
                NeedsArg = $true
            }
            'proj archive' = @{
                Handler = { param($context) Archive-Project $context }
                Description = "Archive project"
                Category = "Project"
                NeedsArg = $true
            }
            'project archive' = @{
                Handler = { param($context) Archive-Project $context }
                Description = "Archive project"
                Category = "Project"
                NeedsArg = $true
            }
            'proj delete' = @{
                Handler = { param($context) Delete-Project $context }
                Description = "Delete project (requires confirmation)"
                Category = "Project"
                NeedsArg = $true
            }
            'project delete' = @{
                Handler = { param($context) Delete-Project $context }
                Description = "Delete project (requires confirmation)"
                Category = "Project"
                NeedsArg = $true
            }
            'proj list' = @{
                Handler = { Show-ProjectDashboard }
                Description = "List projects with stats"
                Category = "Project"
            }
            'project list' = @{
                Handler = { Show-ProjectDashboard }
                Description = "List projects with stats"
                Category = "Project"
            }
            'proj stats' = @{
                Handler = { param($context) Show-ProjectStats $context }
                Description = "Detailed project statistics"
                Category = "Project"
            }
            'project stats' = @{
                Handler = { param($context) Show-ProjectStats $context }
                Description = "Detailed project statistics"
                Category = "Project"
            }
            'proj fields' = @{
                Handler = { param($context) Show-ExcelProjectFields $context }
                Description = "Show Excel/T2020 fields for a project"
                Category = "Project"
                NeedsArg = $true
            }
            'project fields' = @{
                Handler = { param($context) Show-ExcelProjectFields $context }
                Description = "Show Excel/T2020 fields for a project"
                Category = "Project"
                NeedsArg = $true
            }
            'proj set' = @{
                Handler = { param($context) Set-ProjectFields $context }
                Description = "Set PMC fields: ID1, ID2, ProjFolder, AssignedDate, DueDate, BFDate, CAAName, RequestName, T2020"
                Category = "Project"
                NeedsArg = $true
            }
            'project set' = @{
                Handler = { param($context) Set-ProjectFields $context }
                Description = "Set PMC fields: ID1, ID2, ProjFolder, AssignedDate, DueDate, BFDate, CAAName, RequestName, T2020"
                Category = "Project"
                NeedsArg = $true
            }
            'proj view' = @{
                Handler = { param($context) Show-ProjectDetails $context }
                Description = "View project details"
                Category = "Project"
                NeedsArg = $true
            }
            'project view' = @{
                Handler = { param($context) Show-ProjectDetails $context }
                Description = "View project details"
                Category = "Project"
                NeedsArg = $true
            }
            'proj info' = @{
                Handler = { param($context) Show-ProjectDetails $context }
                Description = "View project details"
                Category = "Project"
                NeedsArg = $true
            }
            'project info' = @{
                Handler = { param($context) Show-ProjectDetails $context }
                Description = "View project details"
                Category = "Project"
                NeedsArg = $true
            }
            'proj recent' = @{
                Handler = { Show-RecentProjects }
                Description = "Show recently used projects"
                Category = "Project"
            }
            'project recent' = @{
                Handler = { Show-RecentProjects }
                Description = "Show recently used projects"
                Category = "Project"
            }
            'proj new' = @{
                Handler = { param($context) Add-ProjectGuided $context }
                Description = "Create project with guided wizard"
                Category = "Project"
            }
            'project new' = @{
                Handler = { param($context) Add-ProjectGuided $context }
                Description = "Create project with guided wizard"
                Category = "Project"
            }
            'new project' = @{
                Handler = { param($context) Add-ProjectGuided $context }
                Description = "Create project with guided wizard"
                Category = "Project"
            }
            'show project' = @{
                Handler = { param($context) Show-ProjectDetails $context }
                Description = "Show detailed project information with PMC fields"
                Category = "Project" 
                NeedsArg = $true
            }
            
            # === TASK MANAGEMENT (Enhanced) ===
            'add' = @{
                Handler = { param($context) Add-SmartTask $context }
                Description = "Add task with natural language"
                Category = "Task"
                NeedsArg = $true
            }
            'done' = @{
                Handler = { param($context) Complete-SmartTasks $context }
                Description = "Complete tasks (supports ranges)"
                Category = "Task"
                NeedsArg = $true
            }
            'delete' = @{
                Handler = { param($context) Delete-SmartTasks $context }
                Description = "Delete tasks with confirmation"
                Category = "Task"
                NeedsArg = $true
            }
            'update' = @{
                Handler = { param($context) Update-SmartTask $context }
                Description = "Update task properties"
                Category = "Task"
                NeedsArg = $true
            }
            'postpone' = @{
                Handler = { param($context) Postpone-Task $context }
                Description = "Postpone task by N days"
                Category = "Task"
                NeedsArg = $true
            }
            'duplicate' = @{
                Handler = { param($context) Duplicate-Task $context }
                Description = "Duplicate existing task"
                Category = "Task"
                NeedsArg = $true
            }
            'move' = @{
                Handler = { param($context) Move-Task $context }
                Description = "Move task to different project"
                Category = "Task"
                NeedsArg = $true
            }
            'note' = @{
                Handler = { param($context) Add-TaskNote $context }
                Description = "Add note to task"
                Category = "Task"
                NeedsArg = $true
            }
            
            # === TIME TRACKING (Professional) ===
            'log' = @{
                Handler = { param($context) Log-StructuredEntry $context }
                Description = "Log time: @project date hours [desc] OR #ID1 date hours [desc]"
                Category = "Time"
                NeedsArg = $true
            }
            'timer start' = @{
                Handler = { param($context) Start-Timer $context }
                Description = "Start time tracking"
                Category = "Time"
            }
            'timer stop' = @{
                Handler = { Stop-Timer }
                Description = "Stop and log current timer"
                Category = "Time"
            }
            'timer status' = @{
                Handler = { Show-TimerStatus }
                Description = "Show running timer"
                Category = "Time"
            }
            'report' = @{
                Handler = { param($context)
                    $raw = if ($context) { $context.GetText().Trim() } else { '' }
                    $rng = ''
                    $withIDs = $false
                    $exportCsv = $false
                    $outPath = ''
                    $byId2 = ''
                    if ($raw) {
                        $tokens = $raw -split '\s+'
                        foreach ($t in $tokens) {
                            $tok = $t.ToLower()
                            switch -Regex ($tok) {
                                '^(today|yesterday|week|lastweek|nextweek|month)$' { $rng = $matches[1]; continue }
                                '^(--?withids)$' { $withIDs = $true; continue }
                                '^(--?export(csv)?|exporttocsv|csv)$' { $exportCsv = $true; continue }
                                '^(out|output|path)[:=](.+)$' { $outPath = $matches[2]; continue }
                                '^byid2[:=](.+)$' { $byId2 = $matches[1]; continue }
                            }
                        }
                    }
                    if ([string]::IsNullOrWhiteSpace($rng)) { $rng = 'week' }
                    Show-TimeReportEnhanced -DateRange $rng -WithIDs:$withIDs -ExportCsv:$exportCsv -OutputPath $outPath -ByID2 $byId2
                }
                Description = "Enhanced time report (table + CSV export)"
                Category = "Time"
            }
            'time list' = @{
                Handler = { param($context) Show-TimeLogList $context }
                Description = "List time entries (supports filters)"
                Category = "Time"
            }
            'time edit' = @{
                Handler = { param($context) Edit-TimeLog $context }
                Description = "Edit a time entry by id (date=, hours=, desc=, project=@)"
                Category = "Time"
                NeedsArg = $true
            }
            'time delete' = @{
                Handler = { param($context) Delete-TimeLog $context }
                Description = "Delete a time entry by id (supports --yes)"
                Category = "Time"
                NeedsArg = $true
            }
            'log time' = @{
                Handler = { param($context)
                    # Back-compat: allow legacy 'log time <project> <duration> [desc]' to map to structured entry for today
                    $txt = if ($context) { $context.GetText() } else { '' }
                    if ($txt -match '^(?<p>@?\S+)\s+(?<dur>\d+(?:\.\d+)?[hm])\s*(?<d>.*)$') {
                        $pRaw = $matches.p; $dur = $matches.dur; $desc = $matches.d
                        $mins = Parse-DurationToMinutes $dur
                        if ($mins -le 0) { Write-Host "Invalid duration" -ForegroundColor Red; return }
                        $hrs = [Math]::Round($mins / 60, 2)
                        $today = (Get-Date).ToString('yyyy-MM-dd')
                        $pToken = if ($pRaw.StartsWith('@')) { $pRaw } else { "@" + $pRaw }
                        $composed = ("{0} {1} {2} {3}" -f $pToken, $today, $hrs, $desc).Trim()
                        $parser = [SmartCommandParser]::new()
                        $parser.ExecuteStructured("log $composed")
                    } else {
                        Write-Host "Usage: log time <project> <duration> [description]" -ForegroundColor Yellow
                        Write-Host "Example: log time @work 1.25 Weekly sync" -ForegroundColor Gray
                    }
                }
                Description = "Legacy log format; maps to structured 'log' for today"
                Category = "Time"
            }
            'time report' = @{
                Handler = { param($context) 
                    if ($context -match '(.+)') {
                        Show-TimeReportEnhanced -DateRange $matches[1] -ExportCsv
                    } else {
                        Show-TimeReportEnhanced
                    }
                }
                Description = "Enhanced time reports with CSV export"
                Category = "Time"
            }
            'report detailed' = @{
                Handler = { param($context) Show-DetailedReport $context }
                Description = "Detailed time breakdown"
                Category = "Time"
            }

            # === EXCEL T2020 INTEGRATION ===
            'excel import' = @{
                Handler = { Import-ExcelT2020 }
                Description = "Run Excel T2020 copy/paste batch"
                Category = "Utility"
            }
            'excel latest' = @{
                Handler = { Show-ExcelLatest }
                Description = "Show latest Excel import summary"
                Category = "Utility"
            }
            'excel view' = @{
                Handler = { param($context) Show-ExcelImportDetails $context }
                Description = "View Excel import fields for a file or index"
                Category = "Utility"
                NeedsArg = $false
            }
            'excel view project' = @{
                Handler = { param($context) Show-ExcelProjectFields $context }
                Description = "View Excel fields for a given project"
                Category = "Utility"
                NeedsArg = $true
            }
            
            # === TEMPLATES & AUTOMATION ===
            'template save' = @{
                Handler = { param($context) Save-SmartTemplate $context }
                Description = "Save current view as template"
                Category = "Template"
                NeedsArg = $true
            }
            'template apply' = @{
                Handler = { param($context) Apply-SmartTemplate $context }
                Description = "Apply saved template"
                Category = "Template"
                NeedsArg = $true
            }
            'template list' = @{
                Handler = { Show-Templates }
                Description = "List all templates"
                Category = "Template"
            }
            'recurring add' = @{
                Handler = { param($context) Add-RecurringTask $context }
                Description = "Add recurring task"
                Category = "Template"
                NeedsArg = $true
            }
            'recurring list' = @{
                Handler = { Show-RecurringTasks }
                Description = "Show recurring tasks"
                Category = "Template"
            }
            
            # === DEPENDENCIES ===
            'dep add' = @{
                Handler = { param($context) Add-SmartDependency $context }
                Description = "Add task dependency"
                Category = "Dependency"
                NeedsArg = $true
            }
            'dep remove' = @{
                Handler = { param($context) Remove-SmartDependency $context }
                Description = "Remove dependency"
                Category = "Dependency"
                NeedsArg = $true
            }
            'dep show' = @{
                Handler = { param($context) Show-Dependencies $context }
                Description = "Show task dependencies"
                Category = "Dependency"
            }
            'dep graph' = @{
                Handler = { Show-DependencyGraph }
                Description = "Visual dependency graph"
                Category = "Dependency"
            }
            
            # === CONTEXT & FOCUS ===
            'focus' = @{
                Handler = { param($context) Set-SmartFocus $context }
                Description = "Set project context"
                Category = "Context"
                NeedsArg = $true
            }
            'unfocus' = @{
                Handler = { Clear-Focus }
                Description = "Clear context"
                Category = "Context"
            }
            'context' = @{
                Handler = { Show-ContextInfo }
                Description = "Show current context details"
                Category = "Context"
            }
            
            # === PRODUCTIVITY ===
            'next' = @{
                Handler = { Show-NextActions }
                Description = "AI-suggested next actions"
                Category = "Productivity"
            }
            'review' = @{
                Handler = { Start-WeeklyReview }
                Description = "Weekly review workflow"
                Category = "Productivity"
            }
            'stats' = @{
                Handler = { Show-ProductivityStats }
                Description = "Productivity analytics"
                Category = "Productivity"
            }
            'burndown' = @{
                Handler = { Show-BurndownChart }
                Description = "Sprint burndown chart"
                Category = "Productivity"
            }
            'velocity' = @{
                Handler = { Show-VelocityChart }
                Description = "Task completion velocity"
                Category = "Productivity"
            }
            
            # === UTILITIES ===
            'undo' = @{
                Handler = { Undo-LastAction }
                Description = "Undo last action"
                Category = "Utility"
            }
            'redo' = @{
                Handler = { Redo-Action }
                Description = "Redo undone action"
                Category = "Utility"
            }
            'export' = @{
                Handler = { param($context) Export-Tasks $context }
                Description = "Export to CSV/JSON/Markdown"
                Category = "Utility"
                NeedsArg = $true
            }
            'import' = @{
                Handler = { param($context) Import-Tasks $context }
                Description = "Import from file"
                Category = "Utility"
                NeedsArg = $true
            }
            'backup' = @{
                Handler = { Backup-Data }
                Description = "Create backup"
                Category = "Utility"
            }
            'clean' = @{
                Handler = { Clean-CompletedTasks }
                Description = "Archive old completed tasks"
                Category = "Utility"
            }
            'prefs' = @{
                Handler = { Edit-Configuration }
                Description = "Edit legacy preferences"
                Category = "Utility"
            }
            'help' = @{
                Handler = { param($context) Show-SmartHelp $context }
                Description = "Context-aware help"
                Category = "Utility"
            }
            'quit' = @{
                Handler = { Exit-SmartTUI }
                Description = "Save and exit"
                Category = "Utility"
            }
            
            # === CONFIGURATION ===
            'config' = @{
                Handler = { Show-Config }
                Description = "Show current configuration"
                Category = "Utility"
            }
            'config edit' = @{
                Handler = { param($context) Show-ConfigEditor $context }
                Description = "Interactive config editor"
                Category = "Utility"
            }
            'config set' = @{
                Handler = { param($context) Set-ConfigFromCommand $context }
                Description = "Set a config value (e.g., config set Display.UseAsciiIcons true)"
                Category = "Utility"
                NeedsArg = $true
            }
            'config icons ascii' = @{
                Handler = { Set-ConfigValue -Path "Display.UseAsciiIcons" -Value $true; [ConfigManager]::Save(); Show-Config }
                Description = "Use ASCII icons in UI"
                Category = "Utility"
            }
            'config icons emoji' = @{
                Handler = { Set-ConfigValue -Path "Display.UseAsciiIcons" -Value $false; [ConfigManager]::Save(); Show-Config }
                Description = "Use emoji icons in UI"
                Category = "Utility"
            }
        }
    }
    
    [void] InitializeAliases() {
        $this.Aliases = @{
            # Single letter aliases
            'a' = 'add'
            'd' = 'done'
            'u' = 'update'
            'p' = 'proj'
            'f' = 'focus'
            't' = 'today'
            'w' = 'week'
            'n' = 'next'
            's' = 'search'
            'r' = 'report'
            'h' = 'help'
            'q' = 'quit'
            
            # Common shortcuts
            'td' = 'today'
            'tm' = 'tomorrow'
            'od' = 'overdue'
            'nd' = 'noduedate'
            'del' = 'delete'
            'rm' = 'delete'
            'mv' = 'move'
            'ls' = 'list'      # Changed from 'agenda' to more intuitive 'list'
            'll' = 'list'      # Alternative list command  
            'all' = 'list'     # Show all tasks
            'show' = 'view'    # Show task details
            'ps' = 'projects'  # Show projects (like Unix ps for processes)
            # 'proj' previously aliased to 'projects' (view) ‚Äî removed to allow subcommands
            'proj' = 'project'  # Map to command group for subcommands
            'x' = 'done'
            'xx' = 'delete'
            
            # Power user shortcuts
            'qa' = 'add'  # quick add
            'qd' = 'done' # quick done
            'ql' = 'log'  # quick log
            'qr' = 'report' # quick report
            # Config shortcuts
            'cfg' = 'config'
            'settings' = 'config edit'
        }
    }
    
    [void] InitializeCommandSchemas() {
        # Schema for 'add' command
        $addSchema = [CommandSchema]::new()
        $addSchema.CommandName = "add"
        $addSchema.Description = "Add a new task with optional arguments"
        $addSchema.Syntax = "add [@project] [p1-3] [due:date] [#tags] <description>"
        
        # Project argument
        $projectArg = [ArgumentSchema]::new()
        $projectArg.Name = "project"
        $projectArg.Type = "project"
        $projectArg.Prefix = "@"
        $projectArg.Required = $false
        $projectArg.Description = "Project to add task to"
        $projectArg.Example = "@work"
        
        # Priority argument
        $priorityArg = [ArgumentSchema]::new()
        $priorityArg.Name = "priority"
        $priorityArg.Type = "priority"
        $priorityArg.Prefix = "p"
        $priorityArg.Required = $false
        $priorityArg.ValidValues = @(1, 2, 3)
        $priorityArg.Description = "Task priority (p1=high, p2=medium, p3=low)"
        $priorityArg.Example = "p1"
        
        # Due date argument
        $dueArg = [ArgumentSchema]::new()
        $dueArg.Name = "due"
        $dueArg.Type = "date"
        $dueArg.Prefix = "due:"
        $dueArg.Required = $false
        $dueArg.Description = "Due date for the task"
        $dueArg.Example = "due:today"
        
        # est: removed ‚Äî no estimate argument
        
        # Tags argument
        $tagArg = [ArgumentSchema]::new()
        $tagArg.Name = "tags"
        $tagArg.Type = "tag"
        $tagArg.Prefix = "#"
        $tagArg.Required = $false
        $tagArg.Description = "Tags for the task"
        $tagArg.Example = "#urgent"
        
        # Description argument (free text)
        $descArg = [ArgumentSchema]::new()
        $descArg.Name = "description"
        $descArg.Type = "text"
        $descArg.Required = $true
        $descArg.Description = "Task description (required)"
        $descArg.Example = "Review project documentation"
        
        $addSchema.Arguments = @($projectArg, $priorityArg, $dueArg, $tagArg, $descArg)
        $this.CommandSchemas["add"] = $addSchema

        # Update command schema (for completion hints)
        $updSchema = [CommandSchema]::new()
        $updSchema.CommandName = "update"
        $updSchema.Description = "Update task fields"
        $updSchema.Syntax = "update <id> [@project] [p1|p2|p3|p0] [due:<date|none>] [#tag|-#tag] <text>"
        $uId=[ArgumentSchema]::new(); $uId.Name='id'; $uId.Type='taskid'; $uId.Required=$true; $uId.Pattern='^\d+([,-]\d+)*$'; $uId.Description='Task ID(s)';
        $uProj=[ArgumentSchema]::new(); $uProj.Name='project'; $uProj.Type='project'; $uProj.Prefix='@'; $uProj.Required=$false; $uProj.Description='Project';
        $uPri=[ArgumentSchema]::new(); $uPri.Name='priority'; $uPri.Type='priority'; $uPri.Prefix='p'; $uPri.Required=$false; $uPri.ValidValues=@('0','1','2','3'); $uPri.Description='Priority level';
        $uDue=[ArgumentSchema]::new(); $uDue.Name='due'; $uDue.Type='date'; $uDue.Prefix='due:'; $uDue.Required=$false; $uDue.Description='Due date or none';
        $uAddTag=[ArgumentSchema]::new(); $uAddTag.Name='tags'; $uAddTag.Type='tag'; $uAddTag.Prefix='#'; $uAddTag.Required=$false; $uAddTag.Description='Add tag';
        $uRemTag=[ArgumentSchema]::new(); $uRemTag.Name='removeTags'; $uRemTag.Type='tag'; $uRemTag.Prefix='-'; $uRemTag.Required=$false; $uRemTag.Description='Remove tag';
        $uText=[ArgumentSchema]::new(); $uText.Name='text'; $uText.Type='text'; $uText.Required=$false; $uText.Description='New text';
        $updSchema.Arguments=@($uId,$uProj,$uPri,$uDue,$uAddTag,$uRemTag,$uText)
        $this.CommandSchemas["update"] = $updSchema

        # Move command schema
        $mvSchema = [CommandSchema]::new()
        $mvSchema.CommandName = "move"
        $mvSchema.Description = "Move task to a project"
        $mvSchema.Syntax = "move <id> @project"
        $mId=[ArgumentSchema]::new(); $mId.Name='id'; $mId.Type='taskid'; $mId.Required=$true; $mId.Pattern='^\d+$';
        $mProj=[ArgumentSchema]::new(); $mProj.Name='project'; $mProj.Type='project'; $mProj.Prefix='@'; $mProj.Required=$true;
        $mvSchema.Arguments=@($mId,$mProj)
        $this.CommandSchemas["move"] = $mvSchema

        # Postpone schema
        $ppSchema = [CommandSchema]::new()
        $ppSchema.CommandName = "postpone"
        $ppSchema.Description = "Postpone due date"
        $ppSchema.Syntax = "postpone <id> <+Nd|tomorrow|YYYY-MM-DD>"
        $postId=[ArgumentSchema]::new(); $postId.Name='id'; $postId.Type='taskid'; $postId.Required=$true; $postId.Pattern='^\d+$';
        $pDelta=[ArgumentSchema]::new(); $pDelta.Name='delta'; $pDelta.Type='date'; $pDelta.Required=$true; $pDelta.Description='Offset or date';
        $ppSchema.Arguments=@($postId,$pDelta)
        $this.CommandSchemas["postpone"] = $ppSchema

        # Duplicate schema
        $dupSchema = [CommandSchema]::new()
        $dupSchema.CommandName = "duplicate"
        $dupSchema.Description = "Duplicate task"
        $dupSchema.Syntax = "duplicate <id> [new text] [+Nd]"
        $dId=[ArgumentSchema]::new(); $dId.Name='id'; $dId.Type='taskid'; $dId.Required=$true; $dId.Pattern='^\d+$';
        $dText=[ArgumentSchema]::new(); $dText.Name='text'; $dText.Type='text'; $dText.Required=$false;
        $dOff=[ArgumentSchema]::new(); $dOff.Name='offset'; $dOff.Type='text'; $dOff.Required=$false; $dOff.Pattern='^\+\d+d$'; $dOff.Example='+2d';
        $dupSchema.Arguments=@($dId,$dText,$dOff)
        $this.CommandSchemas["duplicate"] = $dupSchema

        # Dependency commands
        $depAdd = [CommandSchema]::new(); $depAdd.CommandName = "dep add"; $depAdd.Description = "Add dependency"; $depAdd.Syntax = "dep add <task> <depends-on>"; $this.CommandSchemas["dep add"] = $depAdd
        $depRem = [CommandSchema]::new(); $depRem.CommandName = "dep remove"; $depRem.Description = "Remove dependency"; $depRem.Syntax = "dep remove <task> <depends-on>"; $this.CommandSchemas["dep remove"] = $depRem
        $depShow = [CommandSchema]::new(); $depShow.CommandName = "dep show"; $depShow.Description = "Show dependencies"; $depShow.Syntax = "dep show <task>"; $this.CommandSchemas["dep show"] = $depShow

        # Time management schemas
        $tList = [CommandSchema]::new(); $tList.CommandName='time list'; $tList.Description='List time entries'; $tList.Syntax='time list [@project] [week|month|YYYY-MM-DD..YYYY-MM-DD]'; $this.CommandSchemas['time list']=$tList
        $tEdit = [CommandSchema]::new(); $tEdit.CommandName='time edit'; $tEdit.Description='Edit time entry'; $tEdit.Syntax='time edit <id> [date=YYYY-MM-DD] [hours=H.HH] [desc=...] [project=@...]'; $teId=[ArgumentSchema]::new(); $teId.Name='id'; $teId.Type='text'; $teId.Required=$true; $tEdit.Arguments=@($teId); $this.CommandSchemas['time edit']=$tEdit
        $tDel = [CommandSchema]::new(); $tDel.CommandName='time delete'; $tDel.Description='Delete time entry'; $tDel.Syntax='time delete <id> [--yes]'; $tdId=[ArgumentSchema]::new(); $tdId.Name='id'; $tdId.Type='text'; $tdId.Required=$true; $tDel.Arguments=@($tdId); $this.CommandSchemas['time delete']=$tDel

        # Schema for 'log' command (for completion on @project and #id1)
        $logSchema = [CommandSchema]::new()
        $logSchema.CommandName = "log"
        $logSchema.Description = "Log time: @project date hours [desc] OR #ID1 date hours [desc]"
        $logSchema.Syntax = "log @project YYYY-MM-DD 1.25 [desc] | log #1234 YYYY-MM-DD 0.25 [desc]"

        $logProjectArg = [ArgumentSchema]::new()
        $logProjectArg.Name = "project"
        $logProjectArg.Type = "project"
        $logProjectArg.Prefix = "@"
        $logProjectArg.Required = $false
        $logProjectArg.Description = "Existing project name"
        $logProjectArg.Example = "@work"

        $logId1Arg = [ArgumentSchema]::new()
        $logId1Arg.Name = "id1"
        $logId1Arg.Type = "text"
        $logId1Arg.Prefix = "#"
        $logId1Arg.Required = $false
        $logId1Arg.Pattern = "^#\d{2,5}$"
        $logId1Arg.Description = "ID1 numeric code (2-5 digits)"
        $logId1Arg.Example = "#1234"

        $logSchema.Arguments = @($logProjectArg, $logId1Arg)
        $this.CommandSchemas["log"] = $logSchema
        
        # Schema for 'edit' command
        $editSchema = [CommandSchema]::new()
        $editSchema.CommandName = "edit"
        $editSchema.Description = "Edit an existing task"
        $editSchema.Syntax = "edit <task_id> [new_content]"
        
        $taskIdArg = [ArgumentSchema]::new()
        $taskIdArg.Name = "taskId"
        $taskIdArg.Type = "taskid"
        $taskIdArg.Required = $true
        $taskIdArg.Pattern = "^\d+$"
        $taskIdArg.Description = "ID of task to edit"
        $taskIdArg.Example = "123"
        
        $editContentArg = [ArgumentSchema]::new()
        $editContentArg.Name = "content"
        $editContentArg.Type = "text"
        $editContentArg.Required = $false
        $editContentArg.Description = "New task content"
        $editContentArg.Example = "Updated task description"
        
        $editSchema.Arguments = @($taskIdArg, $editContentArg)
        $this.CommandSchemas["edit"] = $editSchema
        
        # Schema for 'done' command  
        $doneSchema = [CommandSchema]::new()
        $doneSchema.CommandName = "done"
        $doneSchema.Description = "Mark task(s) as completed"
        $doneSchema.Syntax = "done <task_id> | done <range>"
        
        $doneTaskArg = [ArgumentSchema]::new()
        $doneTaskArg.Name = "taskRef"
        $doneTaskArg.Type = "taskref"
        $doneTaskArg.Required = $true
        $doneTaskArg.Pattern = "^\d+(-\d+)?$"
        $doneTaskArg.Description = "Task ID or range (e.g., 1-5)"
        $doneTaskArg.Example = "123"
        
        $doneSchema.Arguments = @($doneTaskArg)
        $this.CommandSchemas["done"] = $doneSchema
        
        # Schema for 'proj' command
        $projSchema = [CommandSchema]::new()
        $projSchema.CommandName = "proj"
        $projSchema.Description = "Project management commands"
        $projSchema.Syntax = "proj <subcommand> [args]"
        
        $subcmdArg = [ArgumentSchema]::new()
        $subcmdArg.Name = "subcommand"
        $subcmdArg.Type = "subcommand"
        $subcmdArg.Required = $true
        $subcmdArg.ValidValues = @("add", "list", "archive", "edit", "delete")
        $subcmdArg.Description = "Project subcommand"
        $subcmdArg.Example = "add"
        
        $projSchema.Arguments = @($subcmdArg)
        $this.CommandSchemas["proj"] = $projSchema

        # === VIEW/FILTER COMMANDS ===
        $listSchema = [CommandSchema]::new(); $listSchema.CommandName = "list"; $listSchema.Description = "List tasks"; $listSchema.Syntax = "list"; $this.CommandSchemas["list"] = $listSchema
        $viewSchema = [CommandSchema]::new(); $viewSchema.CommandName = "view"; $viewSchema.Description = "View task details"; $viewSchema.Syntax = "view <id>";
        $vId = [ArgumentSchema]::new(); $vId.Name='id'; $vId.Type='taskid'; $vId.Required=$true; $vId.Pattern='^\d+$'; $vId.Description='Task ID'; $vId.Example='123';
        $viewSchema.Arguments = @($vId); $this.CommandSchemas["view"] = $viewSchema
        foreach ($v in @('projects','today','tomorrow','week','month','overdue','upcoming','noduedate','blocked')) { $s=[CommandSchema]::new(); $s.CommandName=$v; $s.Description="View: $v"; $s.Syntax=$v; $this.CommandSchemas[$v]=$s }
        $prioSchema = [CommandSchema]::new(); $prioSchema.CommandName = "priority"; $prioSchema.Description = "Filter by priority"; $prioSchema.Syntax = "priority <1|2|3>";
        $pLevel = [ArgumentSchema]::new(); $pLevel.Name='level'; $pLevel.Type='priority'; $pLevel.Required=$true; $pLevel.ValidValues=@('1','2','3'); $pLevel.Description='Priority level'; $pLevel.Example='1';
        $prioSchema.Arguments=@($pLevel); $this.CommandSchemas["priority"] = $prioSchema
        $searchSchema = [CommandSchema]::new(); $searchSchema.CommandName = "search"; $searchSchema.Description = "Search tasks"; $searchSchema.Syntax = "search <query>";
        $sQuery=[ArgumentSchema]::new(); $sQuery.Name='query'; $sQuery.Type='text'; $sQuery.Required=$true; $sQuery.Description='Search text'; $sQuery.Example='meeting';
        $searchSchema.Arguments=@($sQuery); $this.CommandSchemas["search"] = $searchSchema

        # === PROJECT SUBCOMMANDS ===
        $projAdd = [CommandSchema]::new(); $projAdd.CommandName = "proj add"; $projAdd.Description = "Create project"; $projAdd.Syntax = "proj add <name>"; $pName=[ArgumentSchema]::new(); $pName.Name='name'; $pName.Type='text'; $pName.Required=$true; $pName.Description='Project name'; $pName.Example='@work'; $projAdd.Arguments=@($pName); $this.CommandSchemas["proj add"] = $projAdd
        $projectAdd = [CommandSchema]::new(); $projectAdd.CommandName = "project add"; $projectAdd.Description = "Create project"; $projectAdd.Syntax = "project add <name>"; $ppName=[ArgumentSchema]::new(); $ppName.Name='name'; $ppName.Type='text'; $ppName.Required=$true; $ppName.Description='Project name'; $projectAdd.Arguments=@($ppName); $this.CommandSchemas["project add"] = $projectAdd
        $projRen = [CommandSchema]::new(); $projRen.CommandName = "proj rename"; $projRen.Description = "Rename project"; $projRen.Syntax = "proj rename <old> <new>"; $old=[ArgumentSchema]::new(); $old.Name='old'; $old.Type='text'; $old.Required=$true; $old.Description='Old name'; $new=[ArgumentSchema]::new(); $new.Name='new'; $new.Type='text'; $new.Required=$true; $new.Description='New name'; $projRen.Arguments=@($old,$new); $this.CommandSchemas["proj rename"] = $projRen
        $projectRen = [CommandSchema]::new(); $projectRen.CommandName = "project rename"; $projectRen.Description = "Rename project"; $projectRen.Syntax = "project rename <old> <new>"; $o2=[ArgumentSchema]::new(); $o2.Name='old'; $o2.Type='text'; $o2.Required=$true; $n2=[ArgumentSchema]::new(); $n2.Name='new'; $n2.Type='text'; $n2.Required=$true; $projectRen.Arguments=@($o2,$n2); $this.CommandSchemas["project rename"] = $projectRen
        $projArc = [CommandSchema]::new(); $projArc.CommandName = "proj archive"; $projArc.Description = "Archive project"; $projArc.Syntax = "proj archive <name>"; $aName=[ArgumentSchema]::new(); $aName.Name='name'; $aName.Type='text'; $aName.Required=$true; $aName.Description='Project name'; $projArc.Arguments=@($aName); $this.CommandSchemas["proj archive"] = $projArc
        $projectArc = [CommandSchema]::new(); $projectArc.CommandName = "project archive"; $projectArc.Description = "Archive project"; $projectArc.Syntax = "project archive <name>"; $apName=[ArgumentSchema]::new(); $apName.Name='name'; $apName.Type='text'; $apName.Required=$true; $projectArc.Arguments=@($apName); $this.CommandSchemas["project archive"] = $projectArc
        $projDel = [CommandSchema]::new(); $projDel.CommandName = "proj delete"; $projDel.Description = "Delete project"; $projDel.Syntax = "proj delete <name>"; $dName=[ArgumentSchema]::new(); $dName.Name='name'; $dName.Type='text'; $dName.Required=$true; $dName.Description='Project name'; $projDel.Arguments=@($dName); $this.CommandSchemas["proj delete"] = $projDel
        $projectDel = [CommandSchema]::new(); $projectDel.CommandName = "project delete"; $projectDel.Description = "Delete project"; $projectDel.Syntax = "project delete <name>"; $dpName=[ArgumentSchema]::new(); $dpName.Name='name'; $dpName.Type='text'; $dpName.Required=$true; $projectDel.Arguments=@($dpName); $this.CommandSchemas["project delete"] = $projectDel
        $projStats = [CommandSchema]::new(); $projStats.CommandName = "proj stats"; $projStats.Description = "Project stats"; $projStats.Syntax = "proj stats [name]"; $sName=[ArgumentSchema]::new(); $sName.Name='name'; $sName.Type='text'; $sName.Required=$false; $sName.Description='Project name'; $projStats.Arguments=@($sName); $this.CommandSchemas["proj stats"] = $projStats
        $projectStats = [CommandSchema]::new(); $projectStats.CommandName = "project stats"; $projectStats.Description = "Project stats"; $projectStats.Syntax = "project stats [name]"; $psName=[ArgumentSchema]::new(); $psName.Name='name'; $psName.Type='text'; $psName.Required=$false; $psName.Description='Project name'; $projectStats.Arguments=@($psName); $this.CommandSchemas["project stats"] = $projectStats
        $projList = [CommandSchema]::new(); $projList.CommandName = "proj list"; $projList.Description = "List projects"; $projList.Syntax = "proj list"; $this.CommandSchemas['proj list']=$projList
        $projectList = [CommandSchema]::new(); $projectList.CommandName = "project list"; $projectList.Description = "List projects"; $projectList.Syntax = "project list"; $this.CommandSchemas['project list']=$projectList
        $projFields = [CommandSchema]::new(); $projFields.CommandName='proj fields'; $projFields.Description='Show Excel fields'; $projFields.Syntax='proj fields <name>'; $pf=[ArgumentSchema]::new(); $pf.Name='name'; $pf.Type='text'; $pf.Required=$true; $pf.Description='Project name'; $projFields.Arguments=@($pf); $this.CommandSchemas['proj fields']=$projFields
        $projectFields = [CommandSchema]::new(); $projectFields.CommandName='project fields'; $projectFields.Description='Show Excel fields'; $projectFields.Syntax='project fields <name>'; $pf2=[ArgumentSchema]::new(); $pf2.Name='name'; $pf2.Type='text'; $pf2.Required=$true; $pf2.Description='Project name'; $projectFields.Arguments=@($pf2); $this.CommandSchemas['project fields']=$projectFields
        $projSet = [CommandSchema]::new(); $projSet.CommandName='proj set'; $projSet.Description='Set PMC fields'; $projSet.Syntax='proj set <name> key=value [key=value ...]'; $psn=[ArgumentSchema]::new(); $psn.Name='name'; $psn.Type='text'; $psn.Required=$true; $psa=[ArgumentSchema]::new(); $psa.Name='updates'; $psa.Type='text'; $psa.Required=$true; $projSet.Arguments=@($psn,$psa); $this.CommandSchemas['proj set']=$projSet
        $projectSet = [CommandSchema]::new(); $projectSet.CommandName='project set'; $projectSet.Description='Set PMC fields'; $projectSet.Syntax='project set <name> key=value [key=value ...]'; $psn2=[ArgumentSchema]::new(); $psn2.Name='name'; $psn2.Type='text'; $psn2.Required=$true; $psa2=[ArgumentSchema]::new(); $psa2.Name='updates'; $psa2.Type='text'; $psa2.Required=$true; $projectSet.Arguments=@($psn2,$psa2); $this.CommandSchemas['project set']=$projectSet
        $projView = [CommandSchema]::new(); $projView.CommandName='proj view'; $projView.Description='View project details'; $projView.Syntax='proj view <name>'; $pvn=[ArgumentSchema]::new(); $pvn.Name='name'; $pvn.Type='text'; $pvn.Required=$true; $projView.Arguments=@($pvn); $this.CommandSchemas['proj view']=$projView
        $projectView = [CommandSchema]::new(); $projectView.CommandName='project view'; $projectView.Description='View project details'; $projectView.Syntax='project view <name>'; $pvn2=[ArgumentSchema]::new(); $pvn2.Name='name'; $pvn2.Type='text'; $pvn2.Required=$true; $projectView.Arguments=@($pvn2); $this.CommandSchemas['project view']=$projectView
        $projNew = [CommandSchema]::new(); $projNew.CommandName = "proj new"; $projNew.Description = "Create project (guided)"; $projNew.Syntax = "proj new [name]"; $pn=[ArgumentSchema]::new(); $pn.Name='name'; $pn.Type='text'; $pn.Required=$false; $pn.Description='Project name'; $projNew.Arguments=@($pn); $this.CommandSchemas["proj new"] = $projNew
        $projectNew = [CommandSchema]::new(); $projectNew.CommandName = "project new"; $projectNew.Description = "Create project (guided)"; $projectNew.Syntax = "project new [name]"; $pnn=[ArgumentSchema]::new(); $pnn.Name='name'; $pnn.Type='text'; $pnn.Required=$false; $pnn.Description='Project name'; $projectNew.Arguments=@($pnn); $this.CommandSchemas["project new"] = $projectNew
        $showProj = [CommandSchema]::new(); $showProj.CommandName = "show project"; $showProj.Description = "Show project details"; $showProj.Syntax = "show project <name>"; $sp=[ArgumentSchema]::new(); $sp.Name='name'; $sp.Type='text'; $sp.Required=$true; $sp.Description='Project name'; $showProj.Arguments=@($sp); $this.CommandSchemas["show project"] = $showProj
        $newProject = [CommandSchema]::new(); $newProject.CommandName = "new project"; $newProject.Description = "Create project (guided)"; $newProject.Syntax = "new project [name]"; $np=[ArgumentSchema]::new(); $np.Name='name'; $np.Type='text'; $np.Required=$false; $np.Description='Project name'; $newProject.Arguments=@($np); $this.CommandSchemas["new project"] = $newProject

        # === TASK COMMANDS ===
        $noteSchema = [CommandSchema]::new(); $noteSchema.CommandName = "note"; $noteSchema.Description = "Add note to task"; $noteSchema.Syntax = "note <id> <text>";
        $nId=[ArgumentSchema]::new(); $nId.Name='id'; $nId.Type='taskid'; $nId.Required=$true; $nId.Pattern='^\d+$'; $nId.Description='Task ID';
        $nText=[ArgumentSchema]::new(); $nText.Name='text'; $nText.Type='text'; $nText.Required=$true; $nText.Description='Note text';
        $noteSchema.Arguments=@($nId,$nText); $this.CommandSchemas["note"] = $noteSchema

        # === TIMER/REPORTING ===
        foreach ($t in @('timer start','timer stop','timer status')) { $s=[CommandSchema]::new(); $s.CommandName=$t; $s.Description=$t; $s.Syntax=$t; $this.CommandSchemas[$t]=$s }
        $report = [CommandSchema]::new(); $report.CommandName = "report"; $report.Description = "Time reports"; $report.Syntax = "report [week|month] [-WithIDs]";
        $rRange=[ArgumentSchema]::new(); $rRange.Name='range'; $rRange.Type='text'; $rRange.Required=$false; $rRange.Description='Date range'; $rRange.Example='week';
        $report.Arguments=@($rRange); $this.CommandSchemas["report"] = $report
        $timeReport = [CommandSchema]::new(); $timeReport.CommandName = "time report"; $timeReport.Description = "Time report (advanced)"; $timeReport.Syntax = "time report <range> [-ExportCsv]";
        $trRange=[ArgumentSchema]::new(); $trRange.Name='range'; $trRange.Type='text'; $trRange.Required=$true; $trRange.Description='Date range'; $trRange.Example='month';
        $timeReport.Arguments=@($trRange); $this.CommandSchemas["time report"] = $timeReport
        $repDet = [CommandSchema]::new(); $repDet.CommandName = "report detailed"; $repDet.Description = "Detailed report"; $repDet.Syntax = "report detailed [args]"; $this.CommandSchemas["report detailed"] = $repDet

        # === EXCEL ===
        $excImp=[CommandSchema]::new(); $excImp.CommandName='excel import'; $excImp.Description='Excel import'; $excImp.Syntax='excel import'; $this.CommandSchemas['excel import']=$excImp
        $excLat=[CommandSchema]::new(); $excLat.CommandName='excel latest'; $excLat.Description='Excel latest'; $excLat.Syntax='excel latest'; $this.CommandSchemas['excel latest']=$excLat
        $excView=[CommandSchema]::new(); $excView.CommandName='excel view'; $excView.Description='Excel view'; $excView.Syntax='excel view [file|index]'; $ev=[ArgumentSchema]::new(); $ev.Name='fileOrIndex'; $ev.Type='text'; $ev.Required=$false; $excView.Arguments=@($ev); $this.CommandSchemas['excel view']=$excView
        $excProj=[CommandSchema]::new(); $excProj.CommandName='excel view project'; $excProj.Description='Excel project fields'; $excProj.Syntax='excel view project <name>'; $ep=[ArgumentSchema]::new(); $ep.Name='name'; $ep.Type='text'; $ep.Required=$true; $excProj.Arguments=@($ep); $this.CommandSchemas['excel view project']=$excProj

        # === DEPENDENCY GRAPH ===
        $depGraph=[CommandSchema]::new(); $depGraph.CommandName='dep graph'; $depGraph.Description='Dependency graph'; $depGraph.Syntax='dep graph'; $this.CommandSchemas['dep graph']=$depGraph

        # === CONTEXT ===
        $focus=[CommandSchema]::new(); $focus.CommandName='focus'; $focus.Description='Set project context'; $focus.Syntax='focus <project>'; $fproj=[ArgumentSchema]::new(); $fproj.Name='project'; $fproj.Type='project'; $fproj.Required=$true; $focus.Arguments=@($fproj); $this.CommandSchemas['focus']=$focus
        $unfocus=[CommandSchema]::new(); $unfocus.CommandName='unfocus'; $unfocus.Description='Clear context'; $unfocus.Syntax='unfocus'; $this.CommandSchemas['unfocus']=$unfocus
        $context=[CommandSchema]::new(); $context.CommandName='context'; $context.Description='Show context'; $context.Syntax='context'; $this.CommandSchemas['context']=$context

        # === PRODUCTIVITY ===
        foreach ($c in @('next','review','stats','burndown','velocity')) { $s=[CommandSchema]::new(); $s.CommandName=$c; $s.Description=$c; $s.Syntax=$c; $this.CommandSchemas[$c]=$s }

        # === UTILITIES ===
        foreach ($c in @('undo','redo','backup','clean','prefs','quit')) { $s=[CommandSchema]::new(); $s.CommandName=$c; $s.Description=$c; $s.Syntax=$c; $this.CommandSchemas[$c]=$s }
        $export=[CommandSchema]::new(); $export.CommandName='export'; $export.Description='Export data'; $export.Syntax='export <json|csv|md> [path]'; $fmt=[ArgumentSchema]::new(); $fmt.Name='format'; $fmt.Type='text'; $fmt.Required=$true; $fmt.ValidValues=@('json','csv','md'); $fmt.Description='Export format'; $pth=[ArgumentSchema]::new(); $pth.Name='path'; $pth.Type='text'; $pth.Required=$false; $export.Arguments=@($fmt,$pth); $this.CommandSchemas['export']=$export
        $import=[CommandSchema]::new(); $import.CommandName='import'; $import.Description='Import tasks'; $import.Syntax='import <filePath>'; $ifp=[ArgumentSchema]::new(); $ifp.Name='filePath'; $ifp.Type='text'; $ifp.Required=$true; $import.Arguments=@($ifp); $this.CommandSchemas['import']=$import
        $help=[CommandSchema]::new(); $help.CommandName='help'; $help.Description='Help'; $help.Syntax='help [topic]'; $ht=[ArgumentSchema]::new(); $ht.Name='topic'; $ht.Type='text'; $ht.Required=$false; $help.Arguments=@($ht); $this.CommandSchemas['help']=$help

        # === CONFIG ===
        $cfg=[CommandSchema]::new(); $cfg.CommandName='config'; $cfg.Description='Show config'; $cfg.Syntax='config'; $this.CommandSchemas['config']=$cfg
        $cfgEdit=[CommandSchema]::new(); $cfgEdit.CommandName='config edit'; $cfgEdit.Description='Edit config'; $cfgEdit.Syntax='config edit'; $this.CommandSchemas['config edit']=$cfgEdit
        $cfgSet=[CommandSchema]::new(); $cfgSet.CommandName='config set'; $cfgSet.Description='Set config value'; $cfgSet.Syntax='config set <Section.Key> <value>'; $this.CommandSchemas['config set']=$cfgSet
        $cfgAscii=[CommandSchema]::new(); $cfgAscii.CommandName='config icons ascii'; $cfgAscii.Description='Use ASCII icons'; $cfgAscii.Syntax='config icons ascii'; $this.CommandSchemas['config icons ascii']=$cfgAscii
        $cfgEmoji=[CommandSchema]::new(); $cfgEmoji.CommandName='config icons emoji'; $cfgEmoji.Description='Use emoji icons'; $cfgEmoji.Syntax='config icons emoji'; $this.CommandSchemas['config icons emoji']=$cfgEmoji
    }
    
    # Get schema for a command
    [CommandSchema] GetCommandSchema([string] $commandName) {
        return $this.CommandSchemas[$commandName]
    }
    
    # LEGACY PARSE METHOD REMOVED - Now using ParseBufferToState + CommandContext
    
    # === MAIN COMPLETION ENTRY POINT ===
    [array] GetSmartCompletions([string] $buffer, [int] $cursorPosition = -1) {
        try {
            $actualCursor = if ($cursorPosition -eq -1) { $buffer.Length } else { $cursorPosition }
            "=== GetSmartCompletions START: buffer='$buffer', cursor=$actualCursor ===" | Write-Debug
            Write-DebugLog ("SMART: START buffer='" + $buffer + "' cursor=" + $actualCursor)

            # Memoization: return cached result for identical requests to avoid re-computation storms
            if ($this.LastCompletionBuffer -eq $buffer -and $this.LastCompletionCursor -eq $actualCursor) {
                Write-DebugLog ("SMART: CACHE HIT (" + ($this.LastCompletionResult.Count) + " items)")
                return $this.LastCompletionResult
            }
            # Ensure we have fresh data
            $this.RefreshDataCache()
            
            # Parse the buffer into completion state
            $state = $this.ParseBufferToState($buffer, $actualCursor)
            $this.CurrentState = $state
            "PARSED STATE: Mode=$($state.Mode), CurrentToken='$($state.CurrentToken)', CurrentCommand='$($state.CurrentCommand)'" | Write-Debug
            
            # Get completions based on state
            $completions = $this.GetCompletionsForState($state)
            "COMPLETIONS: Found $($completions.Count) items, Mode was $($state.Mode)" | Write-Debug
            Write-DebugLog ("SMART: GetCompletionsForState returned " + $completions.Count + " items (Mode=" + $state.Mode + ")")
            
            # Convert to legacy format for existing UI
            $result = $this.ConvertToLegacyFormat($completions)
            "CONVERTED: Returning $($result.Count) legacy format items" | Write-Debug
            Write-DebugLog ("SMART: Converted to legacy (" + $result.Count + ")")

            # Update memoization cache
            $this.LastCompletionBuffer = $buffer
            $this.LastCompletionCursor = $actualCursor
            $this.LastCompletionResult = $result
            $this.LastCompletionTime = Get-Date
            return $result
        }
        catch {
            # Never crash - return safe fallback
            return $this.GetErrorRecoveryCompletions($buffer, $_)
        }
    }
    
    # === ROBUST BUFFER PARSING ===
    # Overloaded method for backward compatibility (assumes cursor at end)
    [CompletionState] ParseBufferToState([string] $buffer) {
        return $this.ParseBufferToState($buffer, $buffer.Length)
    }
    
    # New cursor-aware method - the main implementation
    [CompletionState] ParseBufferToState([string] $buffer, [int] $cursorPosition) {
        "--- ParseBufferToState START (cursor-aware) ---" | Write-Debug
        $state = [CompletionState]::new()
        
        # Input validation and normalization
        if ($buffer -eq $null) { $buffer = "" }
        
        # Validate and clamp cursor position
        if ($cursorPosition -lt 0) { $cursorPosition = 0 }
        if ($cursorPosition -gt $buffer.Length) { $cursorPosition = $buffer.Length }
        
        $originalBuffer = $buffer
        # DON'T trim the buffer - we need exact positions for cursor logic
        "BUFFER: original='$originalBuffer', cursorPos=$cursorPosition" | Write-Debug
        $state.OriginalBuffer = $originalBuffer
        $state.CursorPosition = $cursorPosition
        
        # Handle truly empty buffer
        if ([string]::IsNullOrEmpty($buffer)) {
            $state.Mode = [CompletionMode]::Command
            return $state
        }
        
        # Handle whitespace-only buffer
        if ([string]::IsNullOrWhiteSpace($buffer)) {
            $state.Mode = [CompletionMode]::Command
            $state.IsOnNewWord = $true
            return $state
        }
        
        # Tokenize with position tracking
        $tokens = $this.TokenizeBuffer($buffer)
        "TOKENS: Found $($tokens.Count) tokens: $($tokens | ForEach-Object { "'$($_.Text)'" }) from buffer '$buffer'" | Write-Debug
        
        # Phase 2.3: Implement robust TokenUnderCursor logic
        # Find the token that contains the cursor position
        # Convention: Token.EndPos is exclusive (one character past the end)
        $state.TokenUnderCursor = $tokens | 
            Where-Object { $_.StartPos -le $cursorPosition -and $cursorPosition -lt $_.EndPos } | 
            Select-Object -Last 1
            
        # Determine if cursor is on a new word position
        $state.IsOnNewWord = ($cursorPosition -gt 0 -and $buffer[$cursorPosition - 1] -match '\s') -or 
                             ($buffer.EndsWith(' ') -and $cursorPosition -eq $buffer.Length)
        
        "CURSOR: TokenUnderCursor='$($state.TokenUnderCursor?.Text)', IsOnNewWord=$($state.IsOnNewWord)" | Write-Debug
        
        # Determine completion context with cursor awareness
        $this.AnalyzeTokensForCompletion($state, $tokens)
        "ANALYZE RESULT: Mode=$($state.Mode), CurrentToken='$($state.CurrentToken)', CurrentCommand='$($state.CurrentCommand)'" | Write-Debug
        
        return $state
    }
    
    [array] TokenizeBuffer([string] $buffer) {
        $tokens = @()
        
        # Handle edge case: empty or whitespace-only buffer
        if ([string]::IsNullOrWhiteSpace($buffer)) {
            return $tokens
        }
        
        # Phase 2.4: Enhanced tokenizer with quoted string support
        # Regex pattern: captures @"quoted" tokens, quoted strings, OR non-whitespace sequences
        $pattern = '(@"[^"]*")|("[^"]*")|(\S+)'
        $matches = [regex]::Matches($buffer, $pattern)
        
        foreach ($match in $matches) {
            $tokenText = $match.Value
            $startPos = $match.Index
            $endPos = $startPos + $match.Length
            
            # Create ParsedToken with accurate position information
            $token = [ParsedToken]::new($tokenText, $startPos, $endPos)
            
            # Set token type based on what was matched
            if ($match.Groups[1].Success -or $match.Groups[2].Success) {
                # Quoted string (including @"...")
                $token.Type = "QuotedString"
            } elseif ($match.Groups[3].Success) {
                # Regular token
                $token.Type = "Token"
            }
            
            $tokens += $token
        }
        
        return $tokens
    }
    
    [void] AnalyzeTokensForCompletion([CompletionState] $state, [array] $tokens) {
        "--- AnalyzeTokensForCompletion START ---" | Write-Debug
        if ($tokens.Count -eq 0) {
            "NO TOKENS: Setting Mode=Command" | Write-Debug
            $state.Mode = [CompletionMode]::Command
            return
        }
        
        # Check if buffer ends with space (indicates completed token)
        $endsWithSpace = $state.OriginalBuffer.EndsWith(' ')
        "SPACE DEBUG: buffer='$($state.OriginalBuffer)', length=$($state.OriginalBuffer.Length), endsWithSpace=$endsWithSpace" | Write-Debug
        
        # Determine command
        $firstToken = $tokens[0].Text.ToLower()
        $resolvedCommand = $this.ResolveAlias($firstToken)
        "COMMAND RESOLVE: firstToken='$firstToken' -> resolved='$resolvedCommand'" | Write-Debug
        
        # Check for multi-word commands
        if ($tokens.Count -ge 2 -and $this.IsMultiWordCommand($resolvedCommand, $tokens[1].Text)) {
            "MULTIWORD: $resolvedCommand $($tokens[1].Text.ToLower())" | Write-Debug
            
            # Populate both legacy and enhanced properties
            $fullCommandName = "$resolvedCommand $($tokens[1].Text.ToLower())"
            $state.CurrentCommand = $fullCommandName  # Legacy
            $state.FullCommandName = $fullCommandName  # Enhanced (Phase 2)
            
            # CRITICAL FIX: Multi-word commands are still commands, not arguments!
            $state.CompletedArguments = @()  # Legacy - Start with empty - arguments come after the full command
            "FIXED: Multi-word command CompletedArguments initialized as empty" | Write-Debug
            
            # Phase 2.5: Extract argument tokens for enhanced properties
            $argTokensOnly = @()
            if ($tokens.Count -gt 2) {
                $argTokensOnly = $tokens[2..($tokens.Count - 1)]
            }
            $state.ArgumentTokens = $argTokensOnly  # Enhanced (Phase 2)
            "FIXED: Extracted $($argTokensOnly.Count) argument tokens only (multi-word)" | Write-Debug
            
            # Pass the clean, safe array to the legacy function with startIndex=0
            $this.AnalyzeArgumentCompletion($state, $argTokensOnly, 0, $endsWithSpace)
        }
        elseif ($this.Commands.ContainsKey($resolvedCommand)) {
            "COMMAND MATCH: $resolvedCommand exists" | Write-Debug
            # Check if this is an exact command match, has trailing space, or has additional tokens
            if ($firstToken -eq $resolvedCommand -or $this.Aliases.ContainsKey($firstToken) -or $endsWithSpace -or $tokens.Count -gt 1) {
                # Exact command or completed with space - do argument completion
                "EXACT/SPACE: firstToken='$firstToken' == resolved='$resolvedCommand' OR endsWithSpace=$endsWithSpace -> ArgumentCompletion" | Write-Debug
                
                # Populate both legacy and enhanced properties  
                $state.CurrentCommand = $resolvedCommand  # Legacy
                $state.FullCommandName = $resolvedCommand  # Enhanced (Phase 2)
                
                # CRITICAL FIX: Don't add command to CompletedArguments - it's not an argument!
                $state.CompletedArguments = @()  # Legacy - Start with empty - arguments come after command
                "FIXED: CompletedArguments initialized as empty (command '$resolvedCommand' is not an argument)" | Write-Debug
                
                # Phase 2.5: Extract argument tokens for enhanced properties
                $argTokensOnly = @()
                if ($tokens.Count -gt 1) {
                    $argTokensOnly = $tokens[1..($tokens.Count - 1)]
                }
                $state.ArgumentTokens = $argTokensOnly  # Enhanced (Phase 2)
                "FIXED: Extracted $($argTokensOnly.Count) argument tokens only" | Write-Debug
                
                # Pass the clean, safe array to the legacy function with startIndex=0
                $this.AnalyzeArgumentCompletion($state, $argTokensOnly, 0, $endsWithSpace)
            } else {
                # Partial match like "a" -> "add" - still in command completion mode
                "PARTIAL: firstToken='$firstToken' != resolved='$resolvedCommand' -> Command mode" | Write-Debug
                $state.Mode = [CompletionMode]::Command
                $state.CurrentToken = $firstToken
            }
        }
        elseif ($this.CouldBeMultiWordCommand($resolvedCommand)) {
            # Partial multi-word command
            "COULD_BE_MULTIWORD: $resolvedCommand -> Subcommand mode" | Write-Debug
            $state.Mode = [CompletionMode]::Subcommand
            $state.CurrentCommand = $resolvedCommand
            # CRITICAL FIX: Even potential multi-word commands don't put command tokens in CompletedArguments
            $state.CompletedArguments = @()  # Commands are not arguments
            "FIXED: Partial multi-word command CompletedArguments initialized as empty" | Write-Debug
            
            if ($tokens.Count -gt 1 -and -not $endsWithSpace) {
                $state.CurrentToken = $tokens[-1].Text
            }
        }
        else {
            # First word completion
            "FALLBACK: No command match -> Command mode" | Write-Debug
            $state.Mode = [CompletionMode]::Command
            if (-not $endsWithSpace -and $tokens.Count -eq 1) {
                $state.CurrentToken = $tokens[0].Text
            }
        }
    }
    
    [void] AnalyzeArgumentCompletion([CompletionState] $state, [array] $tokens, [int] $startIndex, [bool] $endsWithSpace) {
        # We have a valid command, now determine what argument we're completing
        $argTokens = $tokens[$startIndex..($tokens.Count-1)]
        "ANALYZE ARG: === START === buffer='$($state.OriginalBuffer)', argTokens=$($argTokens.Count), endsWithSpace=$endsWithSpace" | Write-Debug
        "ANALYZE ARG: Current CompletedArguments: $($state.CompletedArguments -join ', ')" | Write-Debug
        
        # Log all argument tokens
        for ($i = 0; $i -lt $argTokens.Count; $i++) {
            "ANALYZE ARG: argTokens[$i]='$($argTokens[$i].Text)'" | Write-Debug
        }
        
        if ($argTokens.Count -eq 0) {
            # No arguments yet - show syntax discovery
            "ANALYZE ARG: NO ARGS -> SyntaxDiscovery" | Write-Debug
            $state.Mode = [CompletionMode]::SyntaxDiscovery
            $state.TokenComplete = $endsWithSpace
            return
        }
        
        if ($argTokens.Count -eq 1 -and $endsWithSpace) {
            # One argument with space - need to check what kind it is
            $lastToken = $argTokens[0].Text
            $isCompleted = $this.IsCompletedArgument($lastToken)
            $isPrefix = $this.IsArgumentPrefix($lastToken)
            "ANALYZE ARG: Single arg with space, lastToken='$lastToken', IsCompletedArgument=$isCompleted, IsArgumentPrefix=$isPrefix" | Write-Debug
            
            if ($isPrefix -and -not $isCompleted) {
                # Incomplete prefix like '@' followed by SPACE - user wants to complete VALUES
                $px = $this.ExtractPrefix($lastToken)
                if ([string]::IsNullOrEmpty($px)) {
                    "ANALYZE ARG: INCOMPLETE PREFIX but ExtractPrefix empty -> SyntaxDiscovery" | Write-Debug
                    Write-DebugLog ("ANALYZE: Guarded empty prefix on space; token='" + $lastToken + "'")
                    $state.Mode = [CompletionMode]::SyntaxDiscovery
                    $state.CurrentToken = $lastToken
                    return
                }
                "ANALYZE ARG: INCOMPLETE PREFIX + SPACE -> PrefixCompletion" | Write-Debug
                $state.Mode = [CompletionMode]::PrefixCompletion
                $state.PrefixBeingCompleted = $px
                $state.CurrentToken = $lastToken
                Write-DebugLog ("ANALYZE: PrefixCompletion start (prefix='" + $px + "')")
                return
            } else {
                # Valid completed argument - show next syntax discovery
                "ANALYZE ARG: SINGLE COMPLETED ARG -> SyntaxDiscovery, adding '$lastToken' to CompletedArguments" | Write-Debug
                $state.Mode = [CompletionMode]::SyntaxDiscovery
                $state.CompletedArguments += $lastToken  # Add the completed argument!
                "ANALYZE ARG: CompletedArguments after adding: $($state.CompletedArguments -join ', ')" | Write-Debug
                $state.TokenComplete = $endsWithSpace
                return
            }
        }
        
        # Check if we're in the middle of a prefix completion
        $lastToken = $argTokens[-1].Text
        $isLastCompleted = $this.IsCompletedArgument($lastToken)
        "ANALYZE ARG: MULTI-TOKEN - lastToken='$lastToken', IsCompletedArgument=$isLastCompleted, endsWithSpace=$endsWithSpace" | Write-Debug
        
        if ($isLastCompleted -and $endsWithSpace) {
            # Completed an argument, show next syntax options
            "ANALYZE ARG: BRANCH 1 - Completed arg + space -> SyntaxDiscovery" | Write-Debug
            $state.Mode = [CompletionMode]::SyntaxDiscovery
            
            # Add ALL previous arguments INCLUDING the last one
            foreach ($argToken in $argTokens) {
                $state.CompletedArguments += $argToken.Text
                "ANALYZE ARG: Added '$($argToken.Text)' to CompletedArguments" | Write-Debug
            }
            
            "ANALYZE ARG: Final CompletedArguments: $($state.CompletedArguments -join ', ')" | Write-Debug
            $state.TokenComplete = $true
        }
        elseif ($isLastCompleted -and -not $endsWithSpace) {
            # Completed argument but no space yet - user might want to modify it or add space
            # Treat as if they want to continue with this argument type
            "ANALYZE ARG: BRANCH 2 - Completed arg no space -> PrefixCompletion" | Write-Debug
            $px2 = $this.ExtractPrefix($lastToken)
            if ([string]::IsNullOrEmpty($px2)) {
                Write-DebugLog ("ANALYZE: Completed arg not a known prefix; switching to SyntaxDiscovery. token='" + $lastToken + "'")
                $state.Mode = [CompletionMode]::SyntaxDiscovery
                $state.CurrentToken = $lastToken
            } else {
                $state.Mode = [CompletionMode]::PrefixCompletion
                $state.PrefixBeingCompleted = $px2
                $state.CurrentToken = $lastToken
                Write-DebugLog ("ANALYZE: Continue PrefixCompletion (prefix='" + $px2 + "')")
            }
            
            # Add all previous arguments EXCEPT the last one (which is being completed)
            for ($i = 0; $i -lt ($argTokens.Count - 1); $i++) {
                $state.CompletedArguments += $argTokens[$i].Text
                "ANALYZE ARG: Added previous arg '$($argTokens[$i].Text)' to CompletedArguments" | Write-Debug
            }
        }
        elseif ($this.IsArgumentPrefix($lastToken) -and -not $endsWithSpace) {
            # Completing within a prefix (e.g., "add @per" -> completing @projects)
            "ANALYZE ARG: BRANCH 3 - Prefix arg no space -> PrefixCompletion" | Write-Debug
            $state.Mode = [CompletionMode]::PrefixCompletion
            $state.PrefixBeingCompleted = $this.ExtractPrefix($lastToken)
            $state.CurrentToken = $lastToken
            "ANALYZE ARG: Set PrefixBeingCompleted='$($state.PrefixBeingCompleted)', CurrentToken='$($state.CurrentToken)'" | Write-Debug
            Write-DebugLog ("ANALYZE: Prefix arg inline (prefix='" + $state.PrefixBeingCompleted + "')")
            
            # Add all previous arguments EXCEPT the last one (which is being completed)
            for ($i = 0; $i -lt ($argTokens.Count - 1); $i++) {
                $state.CompletedArguments += $argTokens[$i].Text
                "ANALYZE ARG: Added previous prefix arg '$($argTokens[$i].Text)' to CompletedArguments" | Write-Debug
            }
        }
        else {
            # Check if this is for 'add' command which should show syntax discovery for any incomplete state
            "ANALYZE ARG: BRANCH 4 - Fallback case, lastToken='$lastToken', CurrentCommand='$($state.CurrentCommand)'" | Write-Debug
            if ($state.CurrentCommand -eq 'add') {
                "ANALYZE ARG: ADD command fallback -> SyntaxDiscovery" | Write-Debug
                $state.Mode = [CompletionMode]::SyntaxDiscovery
                $state.CurrentToken = $lastToken
                
                # Add all previous arguments EXCEPT the last one (which is being completed)
                for ($i = 0; $i -lt ($argTokens.Count - 1); $i++) {
                    $state.CompletedArguments += $argTokens[$i].Text
                    "ANALYZE ARG: Added fallback arg '$($argTokens[$i].Text)' to CompletedArguments" | Write-Debug
                }
            } else {
                # Free text or unknown - show help
                "ANALYZE ARG: Non-ADD command fallback -> Help" | Write-Debug
                $state.Mode = [CompletionMode]::Help
                $state.CurrentToken = $lastToken
            }
        }
        
        "ANALYZE ARG: === END === Final state - Mode=$($state.Mode), CompletedArguments=($($state.CompletedArguments -join ', '))" | Write-Debug
    }
    
    # === HELPER METHODS FOR ANALYSIS ===
    [string] ResolveAlias([string] $word) {
        if ($this.Aliases.ContainsKey($word)) {
            return $this.Aliases[$word]
        }
        return $word
    }
    
    [bool] IsMultiWordCommand([string] $firstWord, [string] $secondWord) {
        $twoWord = "$firstWord $($secondWord.ToLower())"
        return $this.Commands.ContainsKey($twoWord)
    }
    
    [bool] CouldBeMultiWordCommand([string] $firstWord) {
        $pattern = "$firstWord *"
        return ($this.Commands.Keys | Where-Object { $_ -like $pattern }).Count -gt 0
    }
    
    [bool] IsArgumentPrefix([string] $token) {
        return $token.StartsWith('@') -or $token.StartsWith('due:') -or $token.StartsWith('#') -or $token.StartsWith('+') -or $token.StartsWith('-')
    }
    
    [string] ExtractPrefix([string] $token) {
        if ($token.StartsWith('@')) { return '@' }
        if ($token.StartsWith('due:')) { return 'due:' }
        if ($token.StartsWith('#')) { return '#' }
        if ($token.StartsWith('+')) { return '+' }
        if ($token.StartsWith('-')) { return '-' }
        return ''
    }
    
    [bool] IsCompletedArgument([string] $token) {
        # Check if this looks like a complete argument
        return ($token.StartsWith('@') -and $token.Length -gt 1) -or
               ($token.StartsWith('due:') -and $token.Length -gt 4) -or
               ($token.StartsWith('#') -and $token.Length -gt 1) -or
               ($token.StartsWith('+') -and $token.Length -gt 1) -or
               ($token.StartsWith('-') -and $token.Length -gt 1) -or
               ($token -match '^p[123]$')
    }
    
    # === COMPLETION ENGINE ===
    [array] GetCompletionsForState([CompletionState] $state) {
        # FIXED: Use the Mode-based completion that was set by parsing
        try { Write-DebugLog ("COMPSTATE: Mode=" + $state.Mode + ", CurrentToken='" + $state.CurrentToken + "', Prefix='" + $state.PrefixBeingCompleted + "', Cmd='" + ($state.FullCommandName ?? $state.CurrentCommand) + "'") } catch {}
        switch ($state.Mode) {
            ([CompletionMode]::Command) {
                $r = $this.GetCommandCompletions($state)
                try { Write-DebugLog ("COMPSTATE: Command -> " + $r.Count) } catch {}
                return $r
            }
            
            ([CompletionMode]::Subcommand) {
                $r = $this.GetSubcommandCompletions($state)
                try { Write-DebugLog ("COMPSTATE: Subcommand -> " + $r.Count) } catch {}
                return $r
            }
            
            ([CompletionMode]::SyntaxDiscovery) {
                $r = $this.GetSyntaxDiscoveryCompletions($state)
                try { Write-DebugLog ("COMPSTATE: SyntaxDiscovery -> " + $r.Count) } catch {}
                return $r
            }
            
            ([CompletionMode]::PrefixCompletion) {
                $r = $this.GetPrefixCompletions($state)
                try { Write-DebugLog ("COMPSTATE: PrefixCompletion -> " + $r.Count) } catch {}
                return $r
            }
            
            ([CompletionMode]::Help) {
                $r = $this.GetHelpCompletions($state)
                try { Write-DebugLog ("COMPSTATE: Help -> " + $r.Count) } catch {}
                return $r
            }
            
            default {
                $r = $this.GetFallbackCompletions($state)
                try { Write-DebugLog ("COMPSTATE: default(Fallback) -> " + $r.Count) } catch {}
                return $r
            }
        }
        # Explicit return for PowerShell compiler
        return @()
    }
    
    [array] GetSubcommandCompletions([CompletionState] $state) {
        $completions = @()
        $baseCmd = $state.CurrentCommand
        
        foreach ($cmd in $this.Commands.Keys | Where-Object { $_ -like "$baseCmd *" }) {
            $subCmd = $cmd.Substring($baseCmd.Length + 1)
            if ([string]::IsNullOrEmpty($state.CurrentToken) -or $subCmd.StartsWith($state.CurrentToken)) {
                $info = $this.Commands[$cmd]
                $completions += [CompletionItem]::new($subCmd, $info.Description, $info.Category, 100)
            }
        }
        
        return $completions
    }
    
    [array] GetSyntaxDiscoveryCompletions([CompletionState] $state) {
        $completions = @()
        try {
            # Determine command name and schema
            $cmdName = if ($state.FullCommandName) { $state.FullCommandName } else { $state.CurrentCommand }
            if ([string]::IsNullOrWhiteSpace($cmdName)) { return $completions }
            $schema = $null
            if ($this.CommandSchemas.ContainsKey($cmdName)) { $schema = $this.CommandSchemas[$cmdName] }
            else {
                $base = ($cmdName -split '\\s+')[0]
                if ($this.CommandSchemas.ContainsKey($base)) { $schema = $this.CommandSchemas[$base] }
            }
            # Track used simple prefixes to avoid duplicates for single-use args
            $used = @{}
            foreach ($arg in $state.CompletedArguments) {
                if ($arg.StartsWith('@')) { $used['@'] = $true }
                if ($arg.StartsWith('due:')) { $used['due:'] = $true }
                # est removed
                if ($arg -match '^p[0-3]$') { $used['p'] = $true }
                if ($arg.StartsWith('#') -or $arg.StartsWith('+') -or $arg.StartsWith('-')) { $used['tag'] = $true } # multi-use, but still track
            }

            if ($schema -and $schema.Arguments -and $schema.Arguments.Count -gt 0) {
                foreach ($argSchema in $schema.Arguments) {
                    $name = $argSchema.Name
                    # If arg is satisfied, skip
                    # Best-effort check using prefixes and CommandContext-like patterns
                    $already = $false
                    if ($argSchema.Prefix -eq '@' -and $used.ContainsKey('@')) { $already = $true }
                    if ($argSchema.Prefix -eq 'due:' -and $used.ContainsKey('due:')) { $already = $true }
                    # est removed
                    if ($argSchema.Prefix -eq 'p' -and $used.ContainsKey('p')) { $already = $true }
                    if ($already) { continue }

                    # Suggest based on prefix/valid values/type
                    if ($argSchema.Prefix -eq '@') { $completions += [CompletionItem]::new('@', 'Add project', 'Argument', 100) }
                    elseif ($argSchema.Prefix -eq 'due:') { $completions += [CompletionItem]::new('due:', 'Set due date', 'Argument', 95) }
                    elseif ($argSchema.Prefix -eq 'p') {
                        foreach ($v in @('1','2','3','0')) { $completions += [CompletionItem]::new("p$v", "Priority $v", 'Argument', 92) }
                    } elseif ($name -eq 'tags' -or $argSchema.Prefix -eq '#' -or $argSchema.Prefix -eq '+') {
                        $completions += [CompletionItem]::new('#', 'Add tag (#tag)', 'Argument', 90)
                        $completions += [CompletionItem]::new('+', 'Add tag (+tag)', 'Argument', 89)
                    } elseif ($name -eq 'removeTags' -or $argSchema.Prefix -eq '-') {
                        $completions += [CompletionItem]::new('-', 'Remove tag (-tag)', 'Argument', 88)
                    } elseif ($argSchema.ValidValues -and $argSchema.ValidValues.Count -gt 0) {
                        foreach ($v in $argSchema.ValidValues) { $completions += [CompletionItem]::new($v, "Value: $v", 'Value', 80) }
                    } elseif ($cmdName -eq 'report' -and $name -eq 'range') {
                        foreach ($v in @('today','yesterday','week','lastweek','nextweek','month')) { $completions += [CompletionItem]::new($v, "Range: $v", 'Value', 80) }
                    } elseif ($cmdName -eq 'time report' -and $name -eq 'range') {
                        foreach ($v in @('today','yesterday','week','lastweek','nextweek','month')) { $completions += [CompletionItem]::new($v, "Range: $v", 'Value', 80) }
                    } elseif ($cmdName -eq 'export' -and $name -eq 'format') {
                        foreach ($v in @('json','csv','md')) { $completions += [CompletionItem]::new($v, "Format: $v", 'Value', 80) }
                    }
                }
            } else {
                # Fallbacks for common commands
                if ($cmdName -eq 'add') {
                    if (-not $used.ContainsKey('@')) { $completions += [CompletionItem]::new('@', 'Add project', 'Argument', 100) }
                    if (-not $used.ContainsKey('p')) { foreach ($v in @('1','2','3')) { $completions += [CompletionItem]::new("p$v", "Priority $v", 'Argument', 92) } }
                    if (-not $used.ContainsKey('due:')) { $completions += [CompletionItem]::new('due:', 'Set due date', 'Argument', 95) }
                    $completions += [CompletionItem]::new('#', 'Add tag (#tag)', 'Argument', 90)
                    $completions += [CompletionItem]::new('+', 'Add tag (+tag)', 'Argument', 89)
                    $completions += [CompletionItem]::new('-', 'Remove tag (-tag)', 'Argument', 88)
                }
            }
        } catch { Write-DebugLog ("GetNextArgGhost error: " + $_) }

        return $completions
    }
    
    [array] GetPrefixCompletions([CompletionState] $state) {
        $partial = ""
        $prefix = $state.PrefixBeingCompleted
        if ($state.CurrentToken -and $prefix -and $state.CurrentToken.StartsWith($prefix)) {
            $partial = $state.CurrentToken.Substring($prefix.Length)
        }
        Write-DebugLog ("PREFIX: Enter prefix='" + ($prefix) + "' partial='" + ($partial) + "'")

        if ([string]::IsNullOrEmpty($prefix)) {
            Write-DebugLog ("PREFIX: Empty prefix -> SyntaxDiscovery fallback")
            $resEmpty = $this.GetSyntaxDiscoveryCompletions($state)
            Write-DebugLog ("PREFIX: Fallback returned " + $resEmpty.Count)
            return $resEmpty
        }

        $res = @()
        switch ($prefix) {
            '@'   { $res = $this.GetProjectCompletions($partial, '@') }
            'due:'{ $res = $this.GetDateCompletions($partial, 'due:') }
            '#'   { $res = $this.GetTagCompletions($partial, '#') }
            '+'   { $res = $this.GetTagCompletions($partial, '+') }
            '-'   { $res = $this.GetTagCompletions($partial, '-') }
            default { $res = @() }
        }
        if ($res.Count -eq 0) {
            Write-DebugLog ("PREFIX: No results for '" + $prefix + "' (partial='" + $partial + "'), using SyntaxDiscovery")
            $res = $this.GetSyntaxDiscoveryCompletions($state)
        }
        Write-DebugLog ("PREFIX: Returning " + $res.Count)
        return $res
    }
    
    [array] GetCommandCompletions([CompletionState] $state) {
        $completions = @()
        
        # Phase 3.2: Use enhanced properties - prefer TokenUnderCursor, fallback to CurrentToken
        $partial = ""
        if ($state.TokenUnderCursor) {
            $partial = $state.TokenUnderCursor.Text.ToLower()
            "ENHANCED: Using TokenUnderCursor='$partial' for command completion" | Write-Debug
        } elseif ($state.CurrentToken) {
            $partial = $state.CurrentToken.ToLower()
            "LEGACY FALLBACK: Using CurrentToken='$partial' for command completion" | Write-Debug
        }
        
        # Add all commands that match
        foreach ($cmd in $this.Commands.Keys | Sort-Object) {
            if ([string]::IsNullOrEmpty($partial) -or $cmd.StartsWith($partial)) {
                $info = $this.Commands[$cmd]
                $completions += [CompletionItem]::new($cmd, $info.Description, $info.Category, 100)
            }
        }
        
        # Add matching aliases
        foreach ($alias in $this.Aliases.Keys | Sort-Object) {
            if ([string]::IsNullOrEmpty($partial) -or $alias.StartsWith($partial)) {
                $target = $this.Aliases[$alias]
                if ($this.Commands.ContainsKey($target)) {
                    $completions += [CompletionItem]::new($alias, "‚Üí $target", $this.Commands[$target].Category, 90)
                }
            }
        }
        
        # Boost common commands
        if ([string]::IsNullOrEmpty($partial)) {
            $topCommands = @('agenda', 'add', 'done', 'today', 'focus')
            foreach ($comp in $completions) {
                if ($comp.Text -in $topCommands) {
                    $comp.Score = 150
                }
            }
        }
        
        return $completions
    }
    
    
    
    [array] GetProjectCompletions([string] $partial, [string] $prefix = '@') {
        $completions = @()
        
        if ($this.CachedData -and $this.CachedData.projects) {
            foreach ($proj in $this.CachedData.projects | Where-Object { -not $_.isArchived }) {
                if ([string]::IsNullOrEmpty($partial) -or $proj.name.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                    $text = if ($proj.name -match '\\s') { $prefix + '"' + $proj.name + '"' } else { $prefix + $proj.name }
                    $desc = $proj.description
                    if ([string]::IsNullOrEmpty($desc)) { $desc = "Project: $($proj.name)" }
                    $completions += [CompletionItem]::new($text, $desc, 'Project', 90)
                }
            }
        }
        
        # Always provide at least the standard projects
        if ($completions.Count -eq 0) {
            $completions += [CompletionItem]::new("${prefix}inbox", 'Default inbox project', 'Project', 90)
            $completions += [CompletionItem]::new("${prefix}personal", 'Personal tasks', 'Project', 85)
            $completions += [CompletionItem]::new("${prefix}work", 'Work projects', 'Project', 85)
        }
        
        return $completions
    }
    
    [array] GetDateCompletions([string] $partial, [string] $prefix = 'due:') {
        $completions = @()
        $dates = @(
            @{Text='today'; Desc='Due today'; Score=200},
            @{Text='tomorrow'; Desc='Due tomorrow'; Score=190},
            @{Text='tonight'; Desc='Due tonight'; Score=160},
            @{Text='eod'; Desc='End of day (today)'; Score=155},
            @{Text='mon'; Desc='Next Monday'; Score=120},
            @{Text='tue'; Desc='Next Tuesday'; Score=120},
            @{Text='wed'; Desc='Next Wednesday'; Score=120},
            @{Text='thu'; Desc='Next Thursday'; Score=120},
            @{Text='fri'; Desc='Next Friday'; Score=120},
            @{Text='sat'; Desc='Next Saturday'; Score=120},
            @{Text='sun'; Desc='Next Sunday'; Score=120},
            @{Text='nextweek'; Desc='Next week'; Score=110},
            @{Text='eom'; Desc='End of month'; Score=105}
        )
        
        foreach ($date in $dates) {
            if ([string]::IsNullOrEmpty($partial) -or $date.Text.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                $completions += [CompletionItem]::new("$prefix$($date.Text)", $date.Desc, 'Date', $date.Score)
            }
        }
        
        return $completions
    }
    
    # est: removed ‚Äî no estimate completions
    
    [array] GetTagCompletions([string] $partial, [string] $prefix = '#') {
        $completions = @()
        $tags = @('urgent', 'waiting', 'someday', 'reference', 'important', 'quick')
        
        foreach ($tag in $tags) {
            if ([string]::IsNullOrEmpty($partial) -or $tag.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                $completions += [CompletionItem]::new("$prefix$tag", "Tag: $tag", 'Tag', 75)
            }
        }
        
        return $completions
    }
    
    [array] GetTaskIdCompletions([string] $partial) {
        $completions = @()
        
        if ($global:LastShownTaskMap) {
            foreach ($localId in $global:LastShownTaskMap.Keys) {
                if ([string]::IsNullOrEmpty($partial) -or $localId.ToString().StartsWith($partial)) {
                    $taskId = $global:LastShownTaskMap[$localId]
                    if ($this.CachedData -and $this.CachedData.tasks) {
                        $task = $this.CachedData.tasks | Where-Object { $_.id -eq $taskId }
                        if ($task) {
                            $desc = $task.text
                            if ($desc.Length -gt 40) { $desc = $desc.Substring(0, 37) + "..." }
                            $completions += [CompletionItem]::new($localId.ToString(), $desc, 'Task', 95)
                        }
                    }
                }
            }
        }
        
        return $completions
    }
    
    # === UTILITY METHODS ===
    [void] RefreshDataCache() {
        if ((Get-Date) - $this.CacheTime -gt [TimeSpan]::FromSeconds(5)) {
            try {
                $this.CachedData = Get-TaskData
                $this.CacheTime = Get-Date
            }
            catch {
                # Don't crash on data load failure
                if ($this.CachedData -eq $null) {
                    $this.CachedData = @{ projects = @(); tasks = @() }
                }
            }
        }
    }
    
    [array] ConvertToLegacyFormat([array] $completions) {
        # Convert CompletionItem objects to legacy format for existing UI
        $legacy = @()
        foreach ($comp in $completions) {
            "CONVERT: comp.Text='$($comp.Text)', comp.Description='$($comp.Description)'" | Write-Debug
            $legacy += [PSCustomObject]@{
                Command = $comp.Text
                Description = $comp.Description
                Category = $comp.Category
                Score = $comp.Score
                Type = $comp.Type
            }
        }
        $sorted = $legacy | Sort-Object @{Expression='Score'; Descending=$true}, Command
        "CONVERT: Sorted $($sorted.Count) items, first Command='$($sorted[0].Command)'" | Write-Debug
        return $sorted
    }
    
    [array] GetErrorRecoveryCompletions([string] $buffer, [object] $error) {
        # Safe fallback that never crashes
        return @(
            [PSCustomObject]@{
                Command = ''
                Description = "Completion error: $($error.Message). Type 'help' for commands."
                Category = 'Error'
                Score = 0
                Type = 'Help'
            }
        )
    }
    
    [array] GetFallbackCompletions([CompletionState] $state) {
        return @(
            [PSCustomObject]@{
                Command = ''
                Description = 'Press Tab for completions, or type "help" for commands'
                Category = 'Help'
                Score = 0
                Type = 'Help'
            }
        )
    }
    
    [array] GetContextAwareCompletions([CommandContext] $context) {
        $completions = @()
        
        # Phase 4: Smart context-aware completions based on structured parsing
        $commandName = $context.CommandName.ToLower()
        
        switch ($commandName) {
            'add' {
                # OLD: return $this.GetAddCommandCompletions($context) - DELETED
                return @() # Will be handled by new schema-driven system
            }
            'edit' {
                return @() # OLD GetEditCommandCompletions DELETED
            }
            'proj' {
                return @() # OLD GetProjCommandCompletions DELETED
            }
            'due' {
                return $this.GetDueCommandCompletions($context)
            }
            'tag' {
                return $this.GetTagCommandCompletions($context)
            }
            default {
                # For commands without specific context-aware handlers, provide smart argument suggestions
                return $this.GetSmartArgumentCompletions($context)
            }
        }
        
        return $completions
    }
    
    # === CONTEXT-AWARE COMPLETION METHODS ===
    
# OLD GetAddCommandCompletions DELETED - using new schema-driven system
    
# OLD GetEditCommandCompletions DELETED
    
# OLD GetProjCommandCompletions, GetDueCommandCompletions, GetTagCommandCompletions DELETED
    
    
    [array] GetHelpCompletions([CompletionState] $state) {
        $completions = @()
        
        switch ($state.CurrentCommand) {
            'add' {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Syntax: add [@project] [p1-3] [due:date] [#tags] <description>'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
            'done' {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Syntax: done <task_number> or done <range> (e.g., done 1-5)'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
            default {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = "Type arguments for '$($state.CurrentCommand)' or press Tab for options"
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
        }
        
        return $completions
    }
    
    # LEGACY ParseCommandContext REMOVED - Now using ParseBufferToState + CommandContext
    
    [hashtable] IdentifyCommandPattern([array]$words) {
        $result = @{
            IsComplete = $false
            IsPartial = $false
            Command = ''
            BaseCommand = ''
            CommandWords = @()
        }
        
        if ($words.Count -eq 0) {
            return $result
        }
        
        $firstWord = $words[0].ToLower()
        
        # Check aliases first
        if ($this.Aliases.ContainsKey($firstWord)) {
            $firstWord = $this.Aliases[$firstWord]
        }
        
        # Check for single-word commands
        if ($this.Commands.ContainsKey($firstWord)) {
            $result.IsComplete = $true
            $result.Command = $firstWord
            $result.CommandWords = @($words[0])
            return $result
        }
        
        # Check for two-word commands
        if ($words.Count -ge 2) {
            $twoWord = "$firstWord $($words[1].ToLower())"
            if ($this.Commands.ContainsKey($twoWord)) {
                $result.IsComplete = $true
                $result.Command = $twoWord
                $result.CommandWords = @($words[0], $words[1])
                return $result
            }
        }
        
        # Check if first word could be part of a multi-word command
        $possibleTwoWordCommands = $this.Commands.Keys | Where-Object { $_.StartsWith($firstWord + ' ') }
        if ($possibleTwoWordCommands.Count -gt 0) {
            $result.IsPartial = $true
            $result.BaseCommand = $firstWord
            $result.CommandWords = @($words[0])
            return $result
        }
        
        # Not a recognized command pattern
        return $result
    }
    
    
    [array] GetCommandCompletions([string]$partial) {
        $completions = @()
        
        # Add main commands
        foreach ($cmd in $this.Commands.Keys | Sort-Object) {
            if ([string]::IsNullOrEmpty($partial) -or $cmd.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                $info = $this.Commands[$cmd]
                $completions += [PSCustomObject]@{
                    Command = $cmd
                    Description = $info.Description
                    Category = $info.Category
                    Score = 100
                    Type = 'Command'
                }
            }
        }
        
        # Add aliases
        foreach ($alias in $this.Aliases.Keys) {
            if ([string]::IsNullOrEmpty($partial) -or $alias.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                $target = $this.Aliases[$alias]
                if ($this.Commands.ContainsKey($target)) {
                    $completions += [PSCustomObject]@{
                        Command = $alias
                        Description = "‚Üí $target"
                        Category = $this.Commands[$target].Category
                        Score = 90
                        Type = 'Alias'
                    }
                }
            }
        }
        
        # Boost common commands when no partial
        if ([string]::IsNullOrEmpty($partial)) {
            $topCommands = @('agenda', 'add', 'done', 'today', 'focus')
            foreach ($tc in $topCommands) {
                $existing = $completions | Where-Object { $_.Command -eq $tc }
                if ($existing) { $existing.Score = 150 }
            }
        }
        
        return $completions
    }
    
    
    
    
    [array] GetHelpText([array]$words, $data) {
        $completions = @()
        
        if ($words.Count -eq 0) {
            return $completions  # Should not happen, but safe fallback
        }
        
        $command = $this.ResolveCommand($words)
        
        switch ($command) {
            'add' {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Syntax: add [@project] [p1-3] [due:date] [#tags] <description>'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
            'done' {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Syntax: done <task_number> or done <range> (e.g., done 1-5)'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
            'focus' {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Syntax: focus <project_name> - Set current project context'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
            default {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Type command and press Tab for completions, or try "help"'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
        }
        
        return $completions
    }
    
    [string] ResolveCommand([array]$words) {
        if ($words.Count -eq 0) { return '' }
        
        $firstWord = $words[0].ToLower()
        
        # Check if it's an alias
        if ($this.Aliases.ContainsKey($firstWord)) {
            return $this.Aliases[$firstWord]
        }
        
        # Check for two-word commands
        if ($words.Count -gt 1) {
            $twoWord = "$firstWord $($words[1].ToLower())"
            if ($this.Commands.ContainsKey($twoWord)) {
                return $twoWord
            }
        }
        
        # Single word command
        if ($this.Commands.ContainsKey($firstWord)) {
            return $firstWord
        }
        
        return $firstWord
    }
    
    
    # NEW: Execute using structured parsing - no more legacy!
    [void] ExecuteStructured([string]$commandText) {
        $global:SessionStats.CommandsRun++
        
        # Parse with structured parser
        $state = $this.ParseBufferToState($commandText.Trim())
        
        # Handle empty input = agenda
        if ([string]::IsNullOrWhiteSpace($commandText)) {
            $state.FullCommandName = 'agenda'
        }
        
        if ($state.FullCommandName -and $this.Commands.ContainsKey($state.FullCommandName)) {
            $global:LastAction = $state.FullCommandName
            $cmd = $this.Commands[$state.FullCommandName]
            
            try {
                # Always create CommandContext for consistency and smart features
                $context = [CommandContext]::new($state, $this)
                
                # Check validation before executing
                if (-not $context.IsValid) {
                    $context.ShowValidationErrors()
                    return
                }
                
                if ($cmd.NeedsArg) {
                    # Commands that expect arguments
                    & $cmd.Handler $context
                } else {
                    # No-argument commands - but still get context for optional smart features
                    & $cmd.Handler $context
                }
            }
            catch {
                Write-Host "Error executing $($state.FullCommandName): $_" -ForegroundColor Red
                Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
            }
        }
        else {
            if ($state.FullCommandName) {
                Write-Host "Unknown command: $($state.FullCommandName)" -ForegroundColor Red
            } else {
                Write-Host "Could not parse command from: '$commandText'" -ForegroundColor Red
            }
            Write-Host "Type 'help' for available commands" -ForegroundColor Gray
        }
    }
}

# === ENHANCED DISPLAY FUNCTIONS ===

# Full replacement for the Show-RichAgenda function
function Show-RichAgenda {
    $data = Get-TaskData; $today = (Get-Date).Date; $localId = 1; $global:LastShownTaskMap.Clear(); Ensure-LastShownCapacity
    Clear-Host
    Write-Host "`n  AGENDA - $(Get-Date -Format 'dddd, MMMM d, yyyy')" -ForegroundColor Cyan

    # OVERDUE Section
    $overdue = $data.tasks | Where-Object { $_.status -eq 'pending' -and $_.due -and [datetime]$_.due -lt $today } | Sort-Object due
    $overdueRows = @()
    foreach ($task in $overdue) {
        Set-LastShownEntry -LocalId $localId -TaskId $task.id
        $pri = Get-PriorityIcon $task.priority; $daysLate = ($today - [datetime]$task.due).Days
        $blk = if ($task.depends -and $task.depends.Count -gt 0) { '‚è∏' } else { '' }
        $overdueRows += , @($localId, $pri, $blk, $task.text, $task.project, "$daysLate day(s)")
        $localId++
    }
    Format-StyledTable -Headers ("#", "Pri", "Blk", "Task", "Project", "Late By") -DataRows $overdueRows -Title "üî¥ OVERDUE"

    # TODAY Section
    $todayTasks = $data.tasks | Where-Object { $_.status -eq 'pending' -and $_.due -eq $today.ToString("yyyy-MM-dd") } | Sort-Object priority -Descending
    $todayRows = @()
    foreach ($task in $todayTasks) {
        Set-LastShownEntry -LocalId $localId -TaskId $task.id
        $pri = Get-PriorityIcon $task.priority; $tags = ($task.tags -join ', ')
        $blk = if ($task.depends -and $task.depends.Count -gt 0) { '‚è∏' } else { '' }
        $todayRows += , @($localId, $pri, $blk, $task.text, $task.project, $tags)
        $localId++
    }
    Format-StyledTable -Headers ("#", "Pri", "Blk", "Task", "Project", "Tags") -DataRows $todayRows -Title "üìÖ TODAY"
    
    # UPCOMING Section
    $upcoming = $data.tasks | Where-Object { $_.status -eq 'pending' -and $_.due -and [datetime]$_.due -gt $today -and [datetime]$_.due -le $today.AddDays(7) } | Sort-Object due
    $upcomingRows = @()
    foreach ($task in $upcoming) {
        Set-LastShownEntry -LocalId $localId -TaskId $task.id
        $pri = Get-PriorityIcon $task.priority; $dueDay = ([datetime]$task.due).ToString('ddd, MMM d')
        $blk = if ($task.depends -and $task.depends.Count -gt 0) { '‚è∏' } else { '' }
        $upcomingRows += , @($localId, $pri, $blk, $task.text, $task.project, $dueDay)
        $localId++
    }
    Format-StyledTable -Headers ("#", "Pri", "Blk", "Task", "Project", "Due") -DataRows $upcomingRows -Title "üìÜ UPCOMING"

    Write-Host "  Tip: To log time, type 'log @' and press Tab to cycle projects, or use '#ID1' for codes." -ForegroundColor DarkGray
}

# Clean up legacy inline UI block accidentally left outside a function

# Full replacement for the Show-ProjectDashboard function
function Show-ProjectDashboard {
    $data = Get-TaskData
    Clear-Host
    
    $projects = $data.projects | Where-Object { -not $_.isArchived } | Sort-Object sortOrder

    $headers = "Focus", "Icon", "ID2", "Project Name", "Pending", "Overdue", "Done"
    $dataRows = @()

    foreach ($proj in $projects) {
        $tasks = @($data.tasks | Where-Object { $_.project -eq $proj.name -and $_.status -eq 'pending' })
        $completedInTasks = @($data.tasks | Where-Object { $_.project -eq $proj.name -and $_.status -eq 'completed' }).Count
        $completedArchived = if ($data.completed) { @($data.completed | Where-Object { $_.project -eq $proj.name }).Count } else { 0 }
        $completedTotal = $completedInTasks + $completedArchived
        $overdueCount = @($tasks | Where-Object { $_.due -and [datetime]$_.due -lt (Get-Date).Date }).Count
        $focusMarker = if ($proj.name -eq $global:CurrentContext) { "‚ñ∂" } else { " " }
        
        $dataRows += , @($focusMarker, $proj.icon, $proj.ID2, $proj.name, $tasks.Count, $overdueCount, $completedTotal)
    }

    Format-StyledTable -Headers $headers -DataRows $dataRows -Title "Project Dashboard"
    Write-Host "  Tip: Use 'focus <project>' to set context. For logging, type 'log @' and press Tab to cycle projects." -ForegroundColor DarkGray
}

function Show-AllTasks {
    # Replaced legacy Write-Host loops with styled tables per project
    $data = Get-TaskData
    Clear-Host

    $global:LastShownTaskMap.Clear(); Ensure-LastShownCapacity
    $localId = 1
    $projects = $data.projects | Where-Object { -not $_.isArchived } | Sort-Object sortOrder
    foreach ($proj in $projects) {
        $pending = @($data.tasks | Where-Object { $_.project -eq $proj.name -and $_.status -eq 'pending' })
        if ($pending.Count -eq 0) { continue }

        $title = "$(if($proj.icon){$proj.icon}else{"üìÅ"}) $($proj.name.ToUpper()) ($($pending.Count))$(if($global:CurrentContext -eq $proj.name){' ‚Üê FOCUSED'}else{''})"
        $rows = @()
        foreach ($task in $pending | Sort-Object @{Expression={4 - ($_.priority ? $_.priority : 0)}}, @{Expression={ if($_.due){ [datetime]$_.due } else { [datetime]::MaxValue }}}) {
            Set-LastShownEntry -LocalId $localId -TaskId $task.id
            $pri = Get-PriorityIcon $task.priority
            $due = if ($task.due) { ([datetime]$task.due).ToString('MM/dd') } else { '' }
            $rows += , @($localId, $pri, $task.text, $due)
            $localId++
        }
        # Include blocked indicator
        $rowsOut = @()
        foreach ($r in $rows) {
            $idLocal = $r[0]; $pri = $r[1]; $txt = $r[2]; $due = $r[3]
            $taskId = $global:LastShownTaskMap[[int]($idLocal -replace '[\[\]]','')]
            $tobj = ($data.tasks | Where-Object { $_.id -eq $taskId } | Select-Object -First 1)
            $blk = if ($tobj -and $tobj.depends -and $tobj.depends.Count -gt 0) { '‚è∏' } else { '' }
            $rowsOut += , @($idLocal, $pri, $blk, $txt, $due)
        }
        Format-StyledTable -Headers @('#','Pri','Blk','Task','Due') -DataRows $rowsOut -Title $title
    }
    Write-Host "  Tip: To log time, type 'log @' and press Tab to cycle projects, or use '#ID1' for codes." -ForegroundColor DarkGray
}


function Show-TaskDetails {
    param($context)
    
    if (-not $context) {
        Write-Host "Usage: view <task_id>" -ForegroundColor Yellow
        Write-Host "Example: view 3" -ForegroundColor Gray
        return
    }

    $taskIds = Resolve-TaskIds -inputString $context.GetText()
    if ($taskIds.Count -ne 1) {
        Write-Host "Usage: view <task_id> (specify exactly one task)" -ForegroundColor Yellow
        return
    }

    $data = Get-TaskData
    $task = $data.tasks | Where-Object { $_.id -eq $taskIds[0] }

    if (-not $task) {
        Write-Host "‚ùå Task with ID '$($taskIds[0])' not found." -ForegroundColor Red
        return
    }

    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor DarkGray
    Write-Host "  ‚ïë                     TASK DETAILS (#$($task.id))                        ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor DarkGray
    Write-Host ""

    # Main task info
    Write-Host "  üìù Description: " -NoNewline -ForegroundColor DarkGray
    Write-Host $task.text -ForegroundColor White
    Write-Host "  " + ("‚îÄ" * 50) -ForegroundColor DarkGray
    
    # Project
    $projectName = if ($task.project) { $task.project } else { "inbox" }
    Write-Host "  üìÅ Project:     " -NoNewline -ForegroundColor DarkGray
    Write-Host "@$projectName" -ForegroundColor DarkCyan
    
    # Status  
    $statusColor = if ($task.done) { "Green" } else { "Yellow" }
    $statusText = if ($task.done) { "‚úÖ Completed" } else { "‚è≥ Pending" }
    Write-Host "  üéØ Status:      " -NoNewline -ForegroundColor DarkGray
    Write-Host $statusText -ForegroundColor $statusColor
    
    # Priority
    $priorityText = switch ($task.priority) {
        3 { "üî∫ High (P1)" }
        2 { "üî∏ Medium (P2)" }  
        1 { "üîπ Low (P3)" }
        default { "   None" }
    }
    $priorityColor = switch ($task.priority) {
        3 { "Magenta" }
        2 { "Yellow" }
        1 { "Blue" }
        default { "Gray" }
    }
    Write-Host "  ‚ö° Priority:    " -NoNewline -ForegroundColor DarkGray
    Write-Host $priorityText -ForegroundColor $priorityColor

    # Dates
    Write-Host "  üìÖ Created:     " -NoNewline -ForegroundColor DarkGray
    Write-Host $task.created -ForegroundColor Gray
    
    if ($task.due) {
        $dueDate = [datetime]$task.due
        $today = (Get-Date).Date
        $daysDiff = ($dueDate.Date - $today).Days
        
        $dueStatus = switch ($daysDiff) {
            { $_ -lt 0 } { "‚ö†Ô∏è  OVERDUE ($([Math]::Abs($_)) days)" }
            0 { "üö® DUE TODAY" }
            1 { "‚è∞ Due tomorrow" }
            { $_ -le 7 } { "üìÖ Due in $_ days" }
            default { "üìÖ Due $($dueDate.ToString("yyyy-MM-dd"))" }
        }
        
        $dueColor = switch ($daysDiff) {
            { $_ -lt 0 } { "Red" }
            0 { "Red" }
            1 { "Yellow" }
            default { "White" }
        }
        
        Write-Host "  ‚è∞ Due Date:    " -NoNewline -ForegroundColor DarkGray
        Write-Host $dueStatus -ForegroundColor $dueColor
    }
    
    if ($task.completed) {
        Write-Host "  ‚úÖ Completed:  " -NoNewline -ForegroundColor DarkGray
        Write-Host $task.completed -ForegroundColor Green
    }

    # Optional fields
    if ($task.tags -and $task.tags.Count -gt 0) {
        Write-Host "  üè∑Ô∏è  Tags:       " -NoNewline -ForegroundColor DarkGray
        Write-Host ("#" + ($task.tags -join " #")) -ForegroundColor Blue
    }

    if ($task.estimated) {
        Write-Host "  ‚è±Ô∏è  Estimate:   " -NoNewline -ForegroundColor DarkGray
        Write-Host $task.estimated -ForegroundColor Cyan
    }

    # Dependencies
    if ($task.depends -and $task.depends.Count -gt 0) {
        Write-Host "  üîó Depends On:  " -NoNewline -ForegroundColor DarkGray
        $depTasks = $task.depends | ForEach-Object {
            $depTask = $data.tasks | Where-Object { $_.id -eq $_ }
            if ($depTask) {
                "Task #$_ ($($depTask.text | ForEach-Object { $_.Substring(0, [Math]::Min($_.Length, 30)) }))"
            } else {
                "Task #$_"
            }
        }
        Write-Host ($depTasks -join ", ") -ForegroundColor Magenta
    }

    # Blocking tasks
    $blockedTasks = @($data.tasks | Where-Object { 
        $_.depends -and $_.depends -contains $task.id -and -not $_.done
    })
    if ($blockedTasks.Count -gt 0) {
        Write-Host "  üö´ Blocking:    " -NoNewline -ForegroundColor DarkGray
        $blockText = $blockedTasks | ForEach-Object { 
            "Task #$($_.id) ($($_.text | ForEach-Object { $_.Substring(0, [Math]::Min($_.Length, 30)) }))"
        }
        Write-Host ($blockText -join ", ") -ForegroundColor Red
    }

    Write-Host ""
    Write-Host "  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -ForegroundColor DarkGray
    Write-Host "  üí° Use 'update $($task.id)' to edit | 'done $($task.id)' to complete" -ForegroundColor DarkCyan
    Write-Host ""
}

function Show-WeekView {
    $data = Get-TaskData
    $today = (Get-Date).Date
    $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
    
    Clear-Host
    for ($i = 0; $i -lt 7; $i++) {
        $currentDay = $weekStart.AddDays($i)
        $dayStr = $currentDay.ToString('yyyy-MM-dd')
        $isToday = $currentDay.Date -eq $today
        $dayTasks = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.due -eq $dayStr })

        $rows = @(); $localId = 1
        foreach ($task in $dayTasks | Sort-Object priority -Descending) {
            Set-LastShownEntry -LocalId $localId -TaskId $task.id
            $pri = Get-PriorityIcon $task.priority
            $est = if ($task.estimatedMinutes) { "$( [Math]::Round($task.estimatedMinutes/60,1) )h" } else { '' }
            $blk = if ($task.depends -and $task.depends.Count -gt 0) { '‚è∏' } else { '' }
            $rows += , @($localId, $pri, $blk, $task.text, $est)
            $localId++
        }
        $title = "$(if($isToday){'‚ñ∂ '}else{'  '})$($currentDay.ToString('dddd, MMM d'))$(if($isToday){' (TODAY)'}else{''})"
        Format-StyledTable -Headers @('#','Pri','Blk','Task','Est') -DataRows $rows -Title $title
    }
    Write-Host "  Tip: To log time, type 'log @' and press Tab to cycle projects, or use '#ID1' for codes." -ForegroundColor DarkGray
}

# Global debug logger
function Write-DebugLog([string]$message) {
    try {
        $ts = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss.fff')
        $path = Join-Path $PSScriptRoot 'debug.log'
        Add-Content -Path $path -Value ("[$ts] " + $message) -Encoding UTF8
    } catch { }
}

# NEW: Refactored to use structured CommandContext instead of regex parsing
function Add-SmartTask {
    param([CommandContext]$context)
    
    # Validate we have some text to work with
    if ([string]::IsNullOrWhiteSpace($context.GetText())) {
        Write-Host "Usage: add [@project] [p1-3] [due:date] [#tags] <description>" -ForegroundColor Yellow
        return
    }
    
    $data = Get-TaskData
    
    # Create task with structured parsing - no more regex!
    $task = @{
        id = ++$data.lastId
        text = $context.GetText()              # Clean text with arguments removed
        project = $context.GetProject()        # Handles @project or defaults to current context
        priority = $context.GetPriority()      # Handles p1-3, !, !!, !!!
        status = 'pending'
        created = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        due = $null
        estimatedMinutes = $null
        tags = $context.GetTags()              # Handles #tag1 #tag2
        depends = $context.GetArg('dependencies', @())  # Handles dep:id
        recur = $context.GetArg('recur', $null)       # Handles recur:pattern
        notes = @()
    }

    # Debug: capture parsed args and tokens for diagnostics (file-only)
    try {
        $orig = ''
        try { $orig = $context.State.OriginalBuffer } catch {}
        $argsDump = @()
        foreach ($k in $context.Args.Keys) { $argsDump += "$k=`"$($context.Args[$k])`"" }
        $tokensDump = @()
        try { foreach ($t in $context.State.ArgumentTokens) { $tokensDump += $t.Text } } catch {}
        Write-DebugLog ("ADD start: orig='" + ($orig) + "' text='" + $task.text + "' args={" + ($argsDump -join '; ') + "} tokens=[" + ($tokensDump -join ' | ') + "]")
    } catch {}
    
    # Handle project creation if needed
    if ($context.HasArg('project')) {
        $projName = $context.GetArg('project', '')
        $proj = $data.projects | Where-Object { 
            $_.name -eq $projName -or $_.name -like "$projName*"
        } | Select-Object -First 1
        
        if (-not $proj) {
            # Respect NonInteractive: skip prompt and continue
            try { [ConfigManager]::Load() } catch {}
            $cfg = $null; try { $cfg = [ConfigManager]::Config } catch {}
            $nonInteractive = $false
            try { if ($cfg -and $cfg.Behavior) { $nonInteractive = [bool]$cfg.Behavior.NonInteractive } } catch {}
            if ($nonInteractive) {
                Write-Host "Unknown project '$projName'; not creating in non-interactive mode." -ForegroundColor Yellow
            } else {
                # Offer to create new project
                Write-Host "Project '$projName' not found. Create it? (y/n): " -NoNewline -ForegroundColor Yellow
                if ((Read-Host) -eq 'y') {
                    $newProj = @{
                        name = $projName
                        description = ""
                        color = "Gray"
                        sortOrder = $data.projects.Count
                        isArchived = $false
                    }
                    $data.projects += $newProj
                    $task.project = $projName
                }
            }
        } else {
            $task.project = $proj.name
        }
    }
    
    # Handle due date parsing with fallback + warning
    if ($context.HasArg('due')) {
        $dueStr = ($context.GetArg('due', '')).Trim()
        # Normalize: strip surrounding quotes and trailing punctuation commonly typed
        if ($dueStr.StartsWith('"') -and $dueStr.EndsWith('"') -and $dueStr.Length -ge 2) { $dueStr = $dueStr.Substring(1, $dueStr.Length-2) }
        if ($dueStr.StartsWith("'") -and $dueStr.EndsWith("'") -and $dueStr.Length -ge 2) { $dueStr = $dueStr.Substring(1, $dueStr.Length-2) }
        $dueStr = $dueStr.Trim().TrimEnd(',', '.', ';', ':')
        Write-DebugLog ("ADD due normalized: '" + $dueStr + "'")
        $parsedDue = $null
        try { $parsedDue = Parse-SmartDate $dueStr } catch {}
        if (-not $parsedDue) { try { $parsedDue = Parse-NaturalDate -input $dueStr } catch {} }
        if ($parsedDue) {
            $task.due = $parsedDue
            Write-DebugLog ("ADD due parsed: input='" + $dueStr + "' -> '" + $parsedDue + "'")
        } else {
            Write-DebugLog ("ADD due parse FAILED: input='" + $dueStr + "'")
        }
    } else {
        Write-DebugLog ("ADD due missing in parsed args")
    }
    
    # est: removed ‚Äî do not handle estimate
    
    # Add to data
    $data.tasks += $task
    Save-TaskData $data
    $global:SessionStats.TasksAdded++

    # Debug: final persisted snapshot
    try {
        Write-DebugLog ("ADD saved: id=" + $task.id + ", project='" + ($task.project) + "', priority=" + $task.priority + ", due='" + ($task.due) + "', estMin='" + ($task.estimatedMinutes) + "', tags='" + (($task.tags -join ',')) + "'")
    } catch {}
    
    # Display confirmation with rich formatting (unchanged)
    Write-Host "`n  ‚úÖ " -NoNewline -ForegroundColor Green
    Write-Host "Task #$($task.id) created" -ForegroundColor White
    
    Write-Host "     " -NoNewline
    $priSymbol = @("", "üîπ", "üî∏", "üî∫")[$task.priority]
    if ($priSymbol) { Write-Host "$priSymbol " -NoNewline }
    Write-Host $task.text -ForegroundColor White
    
    if ($task.project -ne 'inbox') {
        Write-Host "     üìÅ @$($task.project)" -ForegroundColor DarkCyan
    }
    
    if ($task.due) {
        $dueDate = [datetime]::Parse($task.due)
        $daysUntil = [Math]::Round(($dueDate - (Get-Date).Date).TotalDays)
        $dueDisplay = $dueDate.ToString("ddd, MMM d")
        
        Write-Host "     üìÖ Due: $dueDisplay" -NoNewline -ForegroundColor Yellow
        if ($daysUntil -eq 0) {
            Write-Host " (today)" -ForegroundColor Yellow
        } elseif ($daysUntil -eq 1) {
            Write-Host " (tomorrow)" -ForegroundColor Yellow
        } elseif ($daysUntil -gt 0) {
            Write-Host " (in $daysUntil days)" -ForegroundColor Gray
        }
    }
    
    if ($task.estimatedMinutes) {
        $hrs = [Math]::Round($task.estimatedMinutes / 60, 1)
        Write-Host "     ‚è± Estimated: ${hrs}h" -ForegroundColor Cyan
    }
    
    if ($task.tags.Count -gt 0) {
        Write-Host "     üè∑ Tags: " -NoNewline -ForegroundColor Blue
        Write-Host ($task.tags | ForEach-Object { "#$_" }) -join ", " -ForegroundColor Blue
    }
    
    if ($task.recur) {
        Write-Host "     üîÑ Recurs: $($task.recur)" -ForegroundColor Magenta
    }
    
    Write-Host ""
}

function Parse-SmartDate {
    param([Alias('input')][string]$text)
    
    $today = (Get-Date).Date
    
    switch ($text.ToLower()) {
        'today' { return $today.ToString("yyyy-MM-dd") }
        'tomorrow' { return $today.AddDays(1).ToString("yyyy-MM-dd") }
        'tonight' { return $today.ToString("yyyy-MM-dd") }
        'eod' { return $today.ToString("yyyy-MM-dd") }
        'yesterday' { return $today.AddDays(-1).ToString("yyyy-MM-dd") }
        
        # Weekdays
        { $_ -in @('mon', 'monday') } { 
            $target = [DayOfWeek]::Monday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('tue', 'tuesday') } {
            $target = [DayOfWeek]::Tuesday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('wed', 'wednesday') } {
            $target = [DayOfWeek]::Wednesday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('thu', 'thursday') } {
            $target = [DayOfWeek]::Thursday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('fri', 'friday') } {
            $target = [DayOfWeek]::Friday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('sat', 'saturday') } {
            $target = [DayOfWeek]::Saturday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('sun', 'sunday') } {
            $target = [DayOfWeek]::Sunday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        
        # Relative dates
        'nextweek' { return $today.AddDays(7).ToString("yyyy-MM-dd") }
        'nextmonth' { return $today.AddMonths(1).ToString("yyyy-MM-dd") }
        'eow' { # End of week (Friday)
            $friday = [DayOfWeek]::Friday
            $daysUntil = ([int]$friday - [int]$today.DayOfWeek)
            if ($daysUntil -lt 0) { $daysUntil += 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        'eom' { # End of month
            $lastDay = [DateTime]::DaysInMonth($today.Year, $today.Month)
            return (Get-Date -Year $today.Year -Month $today.Month -Day $lastDay).ToString("yyyy-MM-dd")
        }
        
        default {
            # Try parsing as date
            if ($text -match '^\d{4}-\d{2}-\d{2}$') {
                return $text
            }
            # Try parsing as +N days
            if ($text -match '^\+(\d+)$') {
                return $today.AddDays([int]$matches[1]).ToString("yyyy-MM-dd")
            }
            # Try parsing as N days
            if ($text -match '^(\d+)d$') {
                return $today.AddDays([int]$matches[1]).ToString("yyyy-MM-dd")
            }
            
            return $null
        }
    }
}

function Show-NextActions {
    $data = Get-TaskData
    $today = (Get-Date).Date
    $todayStr = $today.ToString("yyyy-MM-dd")
    
    Clear-Host
    Write-Host "`n  üéØ NEXT ACTIONS - AI Recommendations" -ForegroundColor Cyan
    Write-Host "  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -ForegroundColor DarkCyan
    Write-Host ""
    
    # Algorithm: Score tasks based on multiple factors
    $scoredTasks = @()
    
    foreach ($task in $data.tasks | Where-Object { $_.status -eq 'pending' }) {
        $score = 0
        
        # Priority weight (0-30 points)
        $score += $task.priority * 10
        
        # Due date urgency (0-50 points)
        if ($task.due) {
            $dueDate = [datetime]::Parse($task.due)
            $daysUntil = ($dueDate - $today).TotalDays
            
            if ($daysUntil -lt 0) {
                $score += 50 + [Math]::Min([Math]::Abs($daysUntil) * 2, 20)  # Overdue
            } elseif ($daysUntil -eq 0) {
                $score += 45  # Today
            } elseif ($daysUntil -eq 1) {
                $score += 35  # Tomorrow
            } elseif ($daysUntil -le 3) {
                $score += 25  # This week
            } elseif ($daysUntil -le 7) {
                $score += 15  # Next week
            }
        }
        
        # Context match (0-20 points)
        if ($task.project -eq $global:CurrentContext) {
            $score += 20
        }
        
        # Has estimate (0-10 points) - ready to work on
        if ($task.estimatedMinutes) {
            $score += 10
        }
        
        # Small tasks get bonus (0-10 points) - quick wins
        if ($task.estimatedMinutes -and $task.estimatedMinutes -le 30) {
            $score += 10
        }
        
        # Blocked tasks get penalty
        if ($task.depends -and $task.depends.Count -gt 0) {
            $blockedBy = $data.tasks | Where-Object { 
                $_.id -in $task.depends -and $_.status -eq 'pending' 
            }
            if ($blockedBy) {
                $score -= 30
            }
        }
        
        $scoredTasks += [PSCustomObject]@{
            Task = $task
            Score = $score
            Reason = ""
        }
    }
    
    # Sort by score and take top 5
    $recommendations = $scoredTasks | Sort-Object Score -Descending | Select-Object -First 5
    
    if ($recommendations.Count -eq 0) {
        Write-Host "  No pending tasks to recommend!" -ForegroundColor Green
        Write-Host ""
        return
    }
    
    Write-Host "  Based on priority, urgency, and context:" -ForegroundColor Gray
    Write-Host ""
    
    $num = 1
    foreach ($rec in $recommendations) {
        $task = $rec.Task
        
        # Determine why this was recommended
        $reasons = @()
        if ($task.due) {
            $dueDate = [datetime]::Parse($task.due)
            $daysUntil = ($dueDate - $today).TotalDays
            
            if ($daysUntil -lt 0) {
                $reasons += "‚ö† OVERDUE"
            } elseif ($daysUntil -eq 0) {
                $reasons += "üìÖ Due today"
            } elseif ($daysUntil -eq 1) {
                $reasons += "‚è∞ Due tomorrow"
            }
        }
        
        if ($task.priority -eq 3) {
            $reasons += "üî∫ High priority"
        }
        
        if ($task.project -eq $global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
            $reasons += "üìç In current context"
        }
        
        if ($task.estimatedMinutes -and $task.estimatedMinutes -le 30) {
            $reasons += "‚ö° Quick win (${task.estimatedMinutes}m)"
        }
        
        # Display recommendation
        Write-Host "  $num. " -NoNewline -ForegroundColor Yellow
        Write-Host $task.text -ForegroundColor White
        
        if ($task.project -ne 'inbox') {
            Write-Host "     @$($task.project)" -ForegroundColor DarkCyan
        }
        
        if ($reasons.Count -gt 0) {
            Write-Host "     $($reasons -join ' | ')" -ForegroundColor Gray
        }
        
        Write-Host ""
        $num++
    }
    
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkGray
    Write-Host "  üí° Start with #1 for maximum productivity" -ForegroundColor DarkCyan
    Write-Host ""
}

function Show-ProductivityStats {
    $data = Get-TaskData
    
    Clear-Host
    
    # Calculate stats
    $totalTasks = $data.tasks.Count
    $pending = @($data.tasks | Where-Object { $_.status -eq 'pending' }).Count
    $completed = @($data.tasks | Where-Object { $_.status -eq 'completed' }).Count
    
    # Add completed from archive
    if ($data.completed) {
        $completed += $data.completed.Count
    }
    
    $completionRate = if ($totalTasks -gt 0) { 
        [Math]::Round(($completed / ($completed + $pending)) * 100, 1) 
    } else { 0 }
    
    # This week stats
    $weekStart = (Get-Date).Date.AddDays(-[int](Get-Date).DayOfWeek)
    $weekTasks = @($data.tasks | Where-Object {
        $_.created -and [datetime]::Parse($_.created) -ge $weekStart
    })
    $weekCompleted = @($weekTasks | Where-Object { $_.status -eq 'completed' }).Count
    $weekAdded = $weekTasks.Count
    
    # Time tracking stats
    $totalMinutes = 0
    $weekMinutes = 0
    $todayMinutes = 0
    
    if ($data.timelogs) {
        $totalMinutes = ($data.timelogs | Measure-Object minutes -Sum).Sum
        
        $weekLogs = $data.timelogs | Where-Object {
            [datetime]::Parse($_.date) -ge $weekStart
        }
        if ($weekLogs) {
            $weekMinutes = ($weekLogs | Measure-Object minutes -Sum).Sum
        }
        
        $todayLogs = $data.timelogs | Where-Object {
            $_.date -eq (Get-Date).ToString("yyyy-MM-dd")
        }
        if ($todayLogs) {
            $todayMinutes = ($todayLogs | Measure-Object minutes -Sum).Sum
        }
    }
    
    # Overview
    $overview = @()
    $overview += , @('Total Tasks', ($pending + $completed))
    $overview += , @('Pending', $pending)
    $overview += , @('Completed', $completed)
    $overview += , @('Completion Rate', "$completionRate%")
    Format-StyledTable -Headers @('Metric','Value') -DataRows $overview -Title 'üìä OVERVIEW'

    # This week
    $weekHours = [Math]::Round($weekMinutes / 60, 1)
    $weekRows = @()
    $weekRows += , @('Added', $weekAdded)
    $weekRows += , @('Completed', $weekCompleted)
    $weekRows += , @('Time Logged', "${weekHours}h")
    Format-StyledTable -Headers @('This Week','Value') -DataRows $weekRows -Title 'üìÖ THIS WEEK'

    # Project breakdown
    $projectStats = $data.tasks | Group-Object project | Sort-Object Count -Descending | Select-Object -First 5
    $projRows = @()
    foreach ($proj in $projectStats) {
        $projPending = @($proj.Group | Where-Object { $_.status -eq 'pending' }).Count
        $projCompleted = @($proj.Group | Where-Object { $_.status -eq 'completed' }).Count
        $projRows += , @($proj.Name, $projPending, $projCompleted)
    }
    if ($projRows.Count -gt 0) {
        Format-StyledTable -Headers @('Project','Pending','Completed') -DataRows $projRows -Title 'üìÅ BY PROJECT'
    }

    # Priority distribution
    $p0 = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.priority -eq 0 }).Count
    $p1 = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.priority -eq 1 }).Count
    $p2 = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.priority -eq 2 }).Count
    $p3 = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.priority -eq 3 }).Count
    $priRows = @(); $priRows += , @('None', $p0); $priRows += , @('Low (p1)', $p1); $priRows += , @('Med (p2)', $p2); $priRows += , @('High (p3)', $p3)
    Format-StyledTable -Headers @('Priority','Count') -DataRows $priRows -Title 'üéØ PRIORITY DISTRIBUTION'

    # Session stats
    $sessionTime = [Math]::Round(((Get-Date) - $global:SessionStats.SessionStart).TotalMinutes)
    $sessionRows = @()
    $sessionRows += , @('Duration', "${sessionTime}m")
    $sessionRows += , @('Commands Run', $global:SessionStats.CommandsRun)
    $sessionRows += , @('Tasks Added', $global:SessionStats.TasksAdded)
    $sessionRows += , @('Tasks Completed', $global:SessionStats.TasksCompleted)
    if ($global:SessionStats.TimeLogged -gt 0) {
        $loggedHours = [Math]::Round($global:SessionStats.TimeLogged / 60, 1)
        $sessionRows += , @('Time Logged', "${loggedHours}h")
    }
    Format-StyledTable -Headers @('Session','Value') -DataRows $sessionRows -Title '‚ö° THIS SESSION'
}

# === SMART HELP SYSTEM ===
function Show-SmartHelp {
    param([CommandContext]$context)
    
    Clear-Host
    
    # Get the help topic from context
    $helpText = $context.GetText()
    $helpTopic = if ($helpText) { $helpText.Trim().ToLower() } else { "" }
    
    if ([string]::IsNullOrEmpty($helpTopic)) {
        # General help - show all commands organized by category
        Show-GeneralHelp
    } elseif ($helpTopic.StartsWith('proj')) {
        # Project-related help
        Show-ProjectHelp $helpTopic
    } elseif ($helpTopic.StartsWith('dep')) {
        # Dependency-related help  
        Show-DependencyHelp $helpTopic
    } elseif ($helpTopic -eq 'add' -or $helpTopic -eq 'a') {
        # Detailed help for add command
        Show-AddCommandHelp
    } elseif ($helpTopic -eq 'input' -or $helpTopic -eq 'keys') {
        Show-InputHelp
    } elseif ($helpTopic.StartsWith('log')) {
        Show-LogHelp
    } elseif ($helpTopic.StartsWith('report')) {
        Show-TimeReportHelp
    } else {
        # Specific command help
        Show-CommandHelp $helpTopic
    }
}

function Show-GeneralHelp {
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Cyan
    Write-Host "  ‚ïë                    TODOIST TUI HELP                        ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Cyan
    Write-Host ""
    
    Write-Host "  üìã QUICK START" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  add @project p1 Task description     " -NoNewline -ForegroundColor White
    Write-Host "‚Üí Add task with project & priority" -ForegroundColor Gray
    Write-Host "  a @work due:tomorrow Fix bug         " -NoNewline -ForegroundColor White
    Write-Host "‚Üí Quick add with due date" -ForegroundColor Gray
    Write-Host "  done 1-3                             " -NoNewline -ForegroundColor White
    Write-Host "‚Üí Complete multiple tasks" -ForegroundColor Gray
    Write-Host "  delete 2,4-6 --yes                   " -NoNewline -ForegroundColor White
    Write-Host "‚Üí Delete without confirmation (use --yes or set WarnBeforeDelete=false)" -ForegroundColor Gray
    Write-Host "  proj add @newproject                 " -NoNewline -ForegroundColor White
    Write-Host "‚Üí Create new project" -ForegroundColor Gray
    Write-Host "  log @work 2025-09-10 1.25 Weekly sync" -NoNewline -ForegroundColor White
    Write-Host "‚Üí Log time to a project (date, hours)" -ForegroundColor Gray
    Write-Host "  log #1234 2025-09-10 0.25 Admin" -NoNewline -ForegroundColor White
    Write-Host "‚Üí Log time by ID1 code (2‚Äì5 digits)" -ForegroundColor Gray
    Write-Host "  report -WithIDs" -NoNewline -ForegroundColor White
    Write-Host "‚Üí Enhanced time report with ID columns" -ForegroundColor Gray
    Write-Host "" 
    
    Write-Host "  ‚è± LOGGING HINTS" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  ‚Ä¢ Use @project and press Tab to cycle existing projects" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Use #ID1 to enter a 2‚Äì5 digit code when no project applies" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Date is required (YYYY-MM-DD, or 'today'/'yesterday')" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Hours are decimal (e.g., .25, 1.25, 2)" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ CSV formats ProjectID2 as 12 chars: V + 0s + raw + S" -ForegroundColor Gray
    Write-Host "    (e.g., raw 'ABC123' ‚Üí 'V000000ABC123S')" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  üîç DETAILED HELP" -ForegroundColor Yellow  
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  help add         " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Syntax & examples for add command" -ForegroundColor Gray
    Write-Host "  help input       " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Input keys, completions, type-through" -ForegroundColor Gray
    Write-Host "  help proj        " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí All project commands" -ForegroundColor Gray
    Write-Host "  help [command]   " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Specific command syntax" -ForegroundColor Gray
    Write-Host "" 

    Write-Host "  ‚å® COMPLETIONS & KEYS" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  ‚Ä¢ Tab: show/cycle completions" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Shift+Tab: reverse-cycle completions" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Space: accept current completion" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Right/End: accept when at end" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Type-through: after Tab, typing accepts and continues (toggle with config)" -ForegroundColor Gray
    Write-Host "" 
    
    Write-Host "  ‚öô SETTINGS" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  config             " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Show current settings" -ForegroundColor Gray
    Write-Host "  config edit        " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Interactive editor (set/toggle/save)" -ForegroundColor Gray
    Write-Host "  config set Display.UseAsciiIcons true  " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Switch to ASCII icons" -ForegroundColor Gray
    Write-Host "  config icons emoji " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Switch to emoji icons" -ForegroundColor Gray
    Write-Host "  config set Behavior.NonInteractive true   " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Disable prompts (CI / scripting)" -ForegroundColor Gray
    Write-Host "  config set Behavior.WarnBeforeDelete false" -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Skip delete confirmations (use with care)" -ForegroundColor Gray
    Write-Host "  config set Behavior.AcceptOnType false " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Disable accept-on-type (keep Tab + Space only)" -ForegroundColor Gray
    Write-Host ""

}

function Show-InputHelp {
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Cyan
    Write-Host "  ‚ïë                  INPUT & COMPLETION HELP                   ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Cyan
    Write-Host ""

    Write-Host "  ‚å® KEYS" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  ‚Ä¢ Tab: show/cycle completions" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Shift+Tab: reverse-cycle completions" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Space: accept current completion" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Enter: accept completion (does not submit)" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Right/End: accept when cursor at end" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Home/Left at end: also accept current completion" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Ctrl+Left/Right: move by tokens" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Ctrl+Backspace: delete previous token" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Esc: cancel current completion" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ ‚Üë/‚Üì: command history" -ForegroundColor Gray
    Write-Host ""

    Write-Host "  ‚ú® TYPE-THROUGH" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  After Tab, just keep typing to accept the suggestion and continue." -ForegroundColor Gray
    Write-Host "  Prefixes (@, #, due:) do not add a space before your next character." -ForegroundColor Gray
    Write-Host "  Non-prefix words insert a single space automatically before your next character." -ForegroundColor Gray
    Write-Host "  Typing ':' after 'due' normalizes 'due :' ‚Üí 'due:'." -ForegroundColor Gray
    Write-Host ""

    Write-Host "  ‚öô SETTINGS" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  config set Behavior.AcceptOnType false  " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Disable type-through (Space/Tab acceptance only)" -ForegroundColor Gray
    Write-Host "  config save                             " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Persist configuration to config.json" -ForegroundColor Gray
    Write-Host ""

    Write-Host "  üîé EXAMPLES" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  add ‚ü∂ Tab ‚ü∂ @ ‚ü∂ w            " -NoNewline -ForegroundColor White
    Write-Host "‚Üí becomes: add @w ‚Ä¶" -ForegroundColor Gray
    Write-Host "  add d ‚ü∂ Tab (due:) ‚ü∂ : ‚ü∂ t   " -NoNewline -ForegroundColor White
    Write-Host "‚Üí becomes: add due:t ‚Ä¶ (no double colon)" -ForegroundColor Gray
    Write-Host "  proj ‚ü∂ Tab ‚ü∂ projects ‚ü∂ Enter" -NoNewline -ForegroundColor White
    Write-Host "‚Üí accepts completion without submitting" -ForegroundColor Gray
    Write-Host ""
    
    # Show command categories
    $parser = [SmartCommandParser]::new()
    $categories = @{}
    
    foreach ($cmd in $parser.Commands.GetEnumerator()) {
        $category = $cmd.Value.Category
        if (-not $categories.ContainsKey($category)) {
            $categories[$category] = @()
        }
        $categories[$category] += @{
            Name = $cmd.Key
            Description = $cmd.Value.Description
        }
    }
    
    foreach ($category in $categories.Keys | Sort-Object) {
        $icon = switch ($category) {
            'Task' { '‚úÖ' }
            'Project' { 'üìÅ' }  
            'Time' { '‚è±' }
            'View' { 'üëÅ' }
            'Utility' { 'üîß' }
            default { 'üìå' }
        }
        
        Write-Host "  $icon $($category.ToUpper())" -ForegroundColor Yellow
        Write-Host "  $('-' * ($category.Length + 3))" -ForegroundColor DarkYellow
        
        foreach ($command in $categories[$category] | Sort-Object Name) {
            $cmdName = $command.Name.PadRight(12)
            Write-Host "  $cmdName " -NoNewline -ForegroundColor Cyan
            Write-Host "‚Üí $($command.Description)" -ForegroundColor Gray
        }
        Write-Host ""
    }
}

function Show-AddCommandHelp {
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Green
    Write-Host "  ‚ïë                    ADD COMMAND HELP                        ‚ïë" -ForegroundColor Green  
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Green
    Write-Host ""
    
    Write-Host "  üìù SYNTAX" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  add [@project] [p1-3] [due:date] [#tags] <description>" -ForegroundColor White
    Write-Host "  add ‚Ä¶ also accepts +tags as alias for #tags" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  üéØ ARGUMENTS (can appear in any order)" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  @project     " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Assign to project (e.g., @work, @home)" -ForegroundColor Gray
    Write-Host "  p1, p2, p3   " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Set priority (p1=high, p3=low)" -ForegroundColor Gray
    Write-Host "  !, !!, !!!   " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Alternative priority syntax" -ForegroundColor Gray
    Write-Host "  due:date     " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Set due date (today, tomorrow, +3d, 2024-12-25)" -ForegroundColor Gray
    # est removed
    Write-Host "  #tag / +tag  " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Add tags (#urgent or +urgent)" -ForegroundColor Gray
    Write-Host "  recur:pattern" -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Recurring task (daily, weekly, monthly)" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  üí° EXAMPLES" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  add Write quarterly report" -ForegroundColor White
    Write-Host "  add @work p1 Review code before deadline" -ForegroundColor White
    Write-Host "  add @home due:tomorrow #shopping Buy groceries" -ForegroundColor White
    Write-Host "  add @project #meeting Prepare presentation" -ForegroundColor White
    Write-Host "  add p2 due:friday #urgent Complete tax filing" -ForegroundColor White
    Write-Host "  add recur:daily @personal Take vitamins" -ForegroundColor White
    Write-Host ""
    
    Write-Host "  üöÄ QUICK ALIASES" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  a            " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Short alias for 'add'" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  üìã SMART FEATURES" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  ‚Ä¢ Arguments can appear in ANY order" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Projects auto-created if they don't exist" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Smart date parsing (today, tomorrow, +1w)" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Multiple tags supported in one command" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Tab completion for projects and commands" -ForegroundColor Gray
    Write-Host ""
}

function Show-LogHelp {
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Green
    Write-Host "  ‚ïë                         LOG HELP                           ‚ïë" -ForegroundColor Green
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Green
    Write-Host ""
    Write-Host "  üìù SYNTAX" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  log @project YYYY-MM-DD <hours> [description]" -ForegroundColor White
    Write-Host "  log #<ID1>   YYYY-MM-DD <hours> [description]" -ForegroundColor White
    Write-Host ""
    Write-Host "  ‚úÖ RULES" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  ‚Ä¢ Projects must already exist (Tab completes @project)" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ ID1 is 2‚Äì5 digits (manual entry with #code)" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Date is required (YYYY-MM-DD)" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Hours are decimal (e.g., .25, 1.25, 2)" -ForegroundColor Gray
    Write-Host ""
    Write-Host "  üíæ CSV OUTPUT" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  ‚Ä¢ ProjectID2 is formatted as V + 0s + rawID2 + S to total 12" -ForegroundColor Gray
    Write-Host "    (example: raw 'ABC123' ‚Üí 'V000000ABC123S')" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ Nonproject logs write Project='(none)', ProjectID2 blank" -ForegroundColor Gray
    Write-Host ""
    Write-Host "  üîé EXAMPLES" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  log @work 2025-09-10 1.25 Weekly sync" -ForegroundColor White
    Write-Host "  log #1234 2025-09-10 0.25 Admin task" -ForegroundColor White
}

function Show-TimeReportHelp {
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Blue
    Write-Host "  ‚ïë                      TIME REPORT HELP                      ‚ïë" -ForegroundColor Blue
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Blue
    Write-Host ""
    Write-Host "  üìù SYNTAX" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  report -DateRange week [-WithIDs] [-ByID2 RAW]" -ForegroundColor White
    Write-Host "  time report -DateRange month -ExportCsv [-OutputPath path]" -ForegroundColor White
    Write-Host "  time list [@project] [range]" -ForegroundColor White
    Write-Host "  time edit <id> [date=..] [hours=..] [desc=..] [project=@..]" -ForegroundColor White
    Write-Host "  time delete <id> [--yes]" -ForegroundColor White
    Write-Host ""
    Write-Host "  ‚öô OPTIONS" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  ‚Ä¢ -WithIDs: include ID1/ID2 columns on screen" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ -ByID2: filter by raw project ID2 (not formatted)" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ -ExportCsv: export detailed entries to CSV" -ForegroundColor Gray
    Write-Host "  ‚Ä¢ time list: quick listing with project/range filters" -ForegroundColor Gray
    Write-Host ""
    Write-Host "  üîé EXAMPLES" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  report -DateRange week -WithIDs" -ForegroundColor White
    Write-Host "  time report -DateRange month -ExportCsv" -ForegroundColor White
}

# === TIME LOG MANAGEMENT ===
function Show-TimeLogList {
    param($context)
    $filterText = if ($context) { $context.GetText() } else { '' }
    $projFilter = $null; $range = 'week'; $start=$null; $end=$null
    if ($filterText) {
        foreach ($tok in ($filterText -split '\s+' | Where-Object { $_ })) {
            if ($tok -match '^@(.+)$') { $projFilter = $matches[1] }
            elseif ($tok -match '^(week|month)$') { $range = $tok }
            elseif ($tok -match '^(\d{4}-\d{2}-\d{2})\.\.(\d{4}-\d{2}-\d{2})$') { $start=$matches[1]; $end=$matches[2] }
        }
    }
    $dr = if ($start -and $end) { @{ Start=[datetime]$start; End=([datetime]$end).AddDays(1); Display="$start..$end" } } else { Parse-DateRange -range $range }
    $data = Get-TaskData
    $logs = @($data.timelogs | Where-Object { [datetime]$_.date -ge $dr.Start -and [datetime]$_.date -lt $dr.End })
    if ($projFilter) {
        $p = Find-Project -query $projFilter -Interactive:$false
        if ($p) { $logs = $logs | Where-Object { $_.project -eq $p.name } }
    }
    if (-not $logs -or $logs.Count -eq 0) { Format-StyledTable -Headers @('Info') -DataRows @(@('No time entries')) -Title ("Time Entries - " + $dr.Display); return }
    $rows = @(); $total=0
    foreach ($log in ($logs | Sort-Object date, time)) {
        $hrs = [Math]::Round($log.minutes / 60, 2); $total += $log.minutes
        $desc = if ($log.description) { $log.description } elseif ($log.notes) { $log.notes } else { '' }
        $rows += , @($log.id, $log.date, $log.time, $log.project, $hrs, $desc)
    }
    Format-StyledTable -Headers @('ID','Date','Time','Project','Hours','Description') -DataRows $rows -Title ("TIME ENTRIES - " + $dr.Display)
    $totHrs = [Math]::Round($total / 60, 2)
    Write-Host ("  Total: {0} h" -f $totHrs) -ForegroundColor DarkGray
}

function Edit-TimeLog {
    param($context)
    $text = $context.GetText()
    if (-not $text) { Write-Host "Usage: time edit <id> [date=..] [hours=..] [desc=..] [project=@..]" -ForegroundColor Yellow; return }
    $parts = $text -split '\s+'
    $id = $parts[0]
    $updates = if ($parts.Count -gt 1) { $parts[1..($parts.Count-1)] } else { @() }
    $data = Get-TaskData
    $log = $data.timelogs | Where-Object { $_.id -eq $id } | Select-Object -First 1
    if (-not $log) { Write-Host "Time entry not found: $id" -ForegroundColor Red; return }
    foreach ($tok in $updates) {
        if ($tok -match '^date=(\S+)$') {
            try { $d=[datetime]::Parse($matches[1]); $log.date=$d.ToString('yyyy-MM-dd') } catch { Write-Host "Invalid date: $($matches[1])" -ForegroundColor Yellow }
        } elseif ($tok -match '^hours=(\d+(?:\.\d+)?)$') {
            $h=[double]$matches[1]; if ($h -gt 0) { $log.minutes = [int][Math]::Round($h*60) }
        } elseif ($tok -match '^desc=(.+)$') {
            $log.description = $matches[1]
        } elseif ($tok -match '^project=@(.+)$') {
            $p = Find-Project -query $matches[1] -Interactive:$false
            if ($p) { $log.project = $p.name } else { Write-Host "Unknown project: $($matches[1])" -ForegroundColor Yellow }
        }
    }
    Save-TaskData $data
    Write-Host "Updated time entry $id" -ForegroundColor Green
}

function Delete-TimeLog {
    param($context)
    $text = $context.GetText()
    if (-not $text) { Write-Host "Usage: time delete <id> [--yes]" -ForegroundColor Yellow; return }
    $tokens = $text -split '\s+'
    $id = $tokens | Where-Object { $_ -notmatch '^-' } | Select-Object -First 1
    $yes = ($tokens -contains '--yes' -or $tokens -contains '-y')
    $data = Get-TaskData
    $log = $data.timelogs | Where-Object { $_.id -eq $id } | Select-Object -First 1
    if (-not $log) { Write-Host "Time entry not found: $id" -ForegroundColor Red; return }
    try { [ConfigManager]::Load() } catch {}
    $cfg = $null; try { $cfg = [ConfigManager]::Config } catch {}
    $nonInteractive = $false; $warn=$true
    try { if ($cfg -and $cfg.Behavior) { $nonInteractive=[bool]$cfg.Behavior.NonInteractive; $warn=[bool]$cfg.Behavior.WarnBeforeDelete } } catch {}
    if (-not ($yes -or $nonInteractive -or -not $warn)) {
        $resp = Read-Host ("Delete time entry {0}? (y/N)" -f $id)
        if ($resp.ToLower() -ne 'y') { Write-Host "Cancelled." -ForegroundColor Gray; return }
    }
    $data.timelogs = @($data.timelogs | Where-Object { $_.id -ne $id })
    Save-TaskData $data
    Write-Host "Deleted time entry $id" -ForegroundColor Green
}

function Show-ProjectHelp {
    param([string]$helpTopic)
    
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Blue
    Write-Host "  ‚ïë                   PROJECT COMMANDS                         ‚ïë" -ForegroundColor Blue
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Blue
    Write-Host ""
    
    Write-Host "  üìÅ PROJECT MANAGEMENT" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  proj add <name>      " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Create new project" -ForegroundColor Gray
    Write-Host "  proj rename <old> <new>" -NoNewline -ForegroundColor Cyan  
    Write-Host "‚Üí Rename existing project" -ForegroundColor Gray
    Write-Host "  proj archive <name>  " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Archive completed project" -ForegroundColor Gray
    Write-Host "  proj delete <name>   " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Delete project (with confirmation)" -ForegroundColor Gray
    Write-Host "  proj list            " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí List all projects with stats" -ForegroundColor Gray
    Write-Host "  proj stats [name]    " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Show project statistics" -ForegroundColor Gray
    Write-Host "  show project <name>  " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Show project details (PMC fields)" -ForegroundColor Gray
    Write-Host "  proj view <name>     " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Alias for 'show project'" -ForegroundColor Gray
    Write-Host "  proj fields <name>   " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Show Excel/T2020 fields" -ForegroundColor Gray
    Write-Host "  proj set <name> k=v [k=v...]" -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Set PMC fields (ID1, ID2, ProjFolder, AssignedDate, DueDate, BFDate, CAAName, RequestName, T2020)" -ForegroundColor Gray
    Write-Host "" 
    
    Write-Host "  üéØ PROJECT FOCUS" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  focus <project>      " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Set current project context" -ForegroundColor Gray
    Write-Host "  focus clear          " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Clear project context" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  üí° EXAMPLES" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  proj add @website-redesign" -ForegroundColor White
    Write-Host "  focus @website-redesign" -ForegroundColor White
    Write-Host "  add p1 Design new homepage    (uses focused project)" -ForegroundColor White
    Write-Host ""
}

function Show-DependencyHelp {
    param([string]$helpTopic)
    
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Magenta
    Write-Host "  ‚ïë                  DEPENDENCY COMMANDS                       ‚ïë" -ForegroundColor Magenta
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Magenta
    Write-Host ""
    
    Write-Host "  üîó TASK DEPENDENCIES" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  dep add <task> <depends-on>" -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Create dependency" -ForegroundColor Gray
    Write-Host "  dep remove <task> <depends-on>" -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Remove dependency" -ForegroundColor Gray
    Write-Host "  dep show [task]      " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Show dependencies" -ForegroundColor Gray
    Write-Host "  blocked              " -NoNewline -ForegroundColor Cyan
    Write-Host "‚Üí Show blocked tasks" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  üí° EXAMPLES" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  dep add 5 3          " -NoNewline -ForegroundColor White
    Write-Host "‚Üí Task 5 depends on task 3" -ForegroundColor Gray
    Write-Host "  dep show 5           " -NoNewline -ForegroundColor White
    Write-Host "‚Üí Show what task 5 depends on" -ForegroundColor Gray
    Write-Host ""
}

function Show-CommandHelp {
    param([string]$command)
    
    $parser = [SmartCommandParser]::new()
    
    if ($parser.Commands.ContainsKey($command)) {
        $cmd = $parser.Commands[$command]
        
        Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Cyan
        Write-Host "  ‚ïë                   COMMAND: $($command.ToUpper().PadRight(40))‚ïë" -ForegroundColor Cyan
        Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Cyan
        Write-Host ""
        
        Write-Host "  üìù DESCRIPTION" -ForegroundColor Yellow
        Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
        Write-Host "  $($cmd.Description)" -ForegroundColor White
        Write-Host ""
        
        Write-Host "  üìÇ CATEGORY" -ForegroundColor Yellow
        Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
        Write-Host "  $($cmd.Category)" -ForegroundColor White
        Write-Host ""
        
        if ($cmd.NeedsArg) {
            Write-Host "  ‚öôÔ∏è  USAGE" -ForegroundColor Yellow
            Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
            Write-Host "  $command <arguments>" -ForegroundColor Cyan
            Write-Host ""
        }
        
        # Check for aliases
        $aliases = @()
        foreach ($alias in $parser.Aliases.GetEnumerator()) {
            if ($alias.Value -eq $command) {
                $aliases += $alias.Key
            }
        }
        
        if ($aliases.Count -gt 0) {
            Write-Host "  üöÄ ALIASES" -ForegroundColor Yellow
            Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
            Write-Host "  $($aliases -join ', ')" -ForegroundColor Cyan
            Write-Host ""
        }
        
        Write-Host "  üí° TIP: Use 'help add' for detailed syntax help on complex commands" -ForegroundColor DarkCyan
    } else {
        Write-Host "`n  ‚ùå Unknown command: '$command'" -ForegroundColor Red
        Write-Host "  Type 'help' to see all available commands" -ForegroundColor Gray
    }
    Write-Host ""
}

# === ENHANCED INPUT HANDLER ===
class SmartInputHandler {
    [SmartCommandParser] $Parser
    [string] $Buffer = ""
    [int] $CursorPos = 0
    [int] $InputRow = -1
    [array] $Completions = @()
    [array] $CompletionDetails = @()
    [int] $CompletionIndex = -1
    [bool] $InCompletion = $false
    [string] $OriginalInput = ""
    # Reserved HUD rows below the input line
    [int] $HudLine1Row = -1   # status/details line (input row + 1)
    [int] $HudLine2Row = -1   # syntax line (input row + 2)
    [bool] $HudReserved = $false
    [object] $LastState = $null
    [array] $History = @()
    [int] $HistoryIndex = -1
    [bool] $ReverseCycle = $false

    [void] ClampCursor() {
        if ($this.CursorPos -lt 0) { $this.CursorPos = 0 }
        $max = if ($this.Buffer) { $this.Buffer.Length } else { 0 }
        if ($this.CursorPos -gt $max) { $this.CursorPos = $max }
    }

    [void] SafeInsert([int]$pos, [string]$text) {
        if (-not $text) { return }
        $len = if ($this.Buffer) { $this.Buffer.Length } else { 0 }
        if ($pos -lt 0) { $pos = 0 }
        if ($pos -gt $len) { $pos = $len }
        $this.Buffer = $this.Buffer.Insert($pos, $text)
    }

    [void] SafeRemove([int]$pos, [int]$count) {
        $len = if ($this.Buffer) { $this.Buffer.Length } else { 0 }
        if ($count -le 0 -or $len -eq 0) { return }
        if ($pos -lt 0) { return }
        if ($pos -ge $len) { return }
        if ($pos + $count -gt $len) { $count = $len - $pos }
        if ($count -le 0) { return }
        $this.Buffer = $this.Buffer.Remove($pos, $count)
    }

    [bool] IsShowGhostNextEnabled() {
        try { [ConfigManager]::Load(); $cfg = [ConfigManager]::Config; if ($cfg -and $cfg.Behavior -and $cfg.Behavior.ShowGhostNext -ne $null) { return [bool]$cfg.Behavior.ShowGhostNext } } catch {}
        return $true
    }

    [bool] IsShowSyntaxLineEnabled() {
        try { [ConfigManager]::Load(); $cfg = [ConfigManager]::Config; if ($cfg -and $cfg.Behavior -and $cfg.Behavior.ShowSyntaxLine -ne $null) { return [bool]$cfg.Behavior.ShowSyntaxLine } } catch {}
        return $true
    }

    [CompletionState] GetAndCacheState() {
        try { $state = $this.Parser.ParseBufferToState($this.Buffer, $this.CursorPos); $this.LastState = $state; return $state } catch { return $null }
    }

    [string] GetNextArgGhost([CompletionState] $state) {
        if (-not $this.IsShowGhostNextEnabled()) { return '' }
        if (-not $state) { $state = $this.GetAndCacheState() }
        if (-not $state) { return '' }
        $cmd = if ($state.FullCommandName) { $state.FullCommandName } else { $state.CurrentCommand }
        if ([string]::IsNullOrWhiteSpace($cmd)) { return '' }
        $ctx = $null
        try { $ctx = [CommandContext]::new($state, $this.Parser) } catch { Write-DebugLog ("BuildSyntaxSegments CommandContext error: " + $_) }
        if ($cmd -eq 'add') {
            $hasProj = $ctx -and $ctx.HasArg('project'); $hasPri = $ctx -and $ctx.HasArg('priority'); $hasDue = $ctx -and $ctx.HasArg('due')
            $hasTags = $ctx -and $ctx.HasArg('tags') -and $ctx.GetTags().Count -gt 0; $raw = if ($ctx) { $ctx.GetText() } else { '' }
            if (-not $hasProj) { return ' @project' }
            if (-not $hasPri) { return ' p1' }
            if (-not $hasDue) { return ' due:<date>' }
            if (-not $hasTags) { return ' #tag' }
            if ([string]::IsNullOrWhiteSpace($raw)) { return ' <description>' }
            return ''
        } elseif ($cmd -eq 'log') {
            return ' @project <yyyy-mm-dd> <hours> [desc]'
        } else {
            try { $schema = $this.Parser.CommandSchemas[$cmd]; if ($schema -and $schema.Syntax) { return ' ' + $schema.Syntax } } catch {}
        }
        return ''
    }

    [array] BuildSyntaxSegments([CompletionState] $state) {
        $segments = @()
        if (-not $state) { $state = $this.GetAndCacheState() }
        if (-not $state) { return $segments }
        $full = if ($state.FullCommandName) { $state.FullCommandName } else { $state.CurrentCommand }
        if ([string]::IsNullOrWhiteSpace($full)) { return $segments }
        $parts = $full -split '\s+'
        $base = $parts[0]
        $sub = if ($parts.Count -gt 1) { $parts[1] } else { '' }

        # Always start with the base command as fixed
        $segments += [PSCustomObject]@{ Text = $base; Type = 'fixed'; Done = $true; Required = $true }
        if ($sub) { $segments += [PSCustomObject]@{ Text = ' ' + $sub; Type = 'fixed'; Done = $true; Required = $true } }

        $ctx = $null
        try { $ctx = [CommandContext]::new($state, $this.Parser) } catch {}

        $schema = $null
        try {
            if ($this.Parser.CommandSchemas.ContainsKey($full)) { $schema = $this.Parser.CommandSchemas[$full] }
            elseif ($this.Parser.CommandSchemas.ContainsKey($base)) { $schema = $this.Parser.CommandSchemas[$base] }
        } catch { Write-DebugLog ("BuildSyntaxSegments schema lookup error: " + $_) }
        if ($schema -and $schema.Arguments -and $schema.Arguments.Count -gt 0) {
            foreach ($arg in $schema.Arguments) {
                $name = $arg.Name
                $required = $arg.Required
                $done = $false
                if ($name -eq 'subcommand') { $done = -not [string]::IsNullOrWhiteSpace($sub) }
                elseif ($ctx) { try { $done = $ctx.HasArg($name) } catch { $done = $false } }
                # Build prefix-rich label when possible
                $shape = $name
                if ($arg.Prefix) {
                    switch ($arg.Prefix) {
                        '@'   { $shape = '@project' }
                        'due:'{ $shape = 'due:date' }
                        '#'   { $shape = '#tag' }
                        '+'   { $shape = '+tag' }
                        '-'   { $shape = '-tag' }
                        'p'   {
                            # Show common priority shape
                            $shape = 'p1-3'
                        }
                        default { $shape = $name }
                    }
                } elseif ($arg.ValidValues -and $arg.ValidValues.Count -gt 0 -and $arg.ValidValues.Count -le 4) {
                    $shape = ($arg.ValidValues -join '|')
                }
                $labelCore = $shape
                $label = if ($required) { " <${labelCore}>" } else { " [${labelCore}]" }
                $segments += [PSCustomObject]@{ Text = $label; Type = 'arg'; Done = $done; Required = $required }
            }
        } else {
            # No schema; fall back to NeedsArg flag if present
            try {
                if ($this.Parser.Commands.ContainsKey($full)) {
                    $needs = $this.Parser.Commands[$full].NeedsArg
                    if ($needs) { $segments += [PSCustomObject]@{ Text = ' <args>'; Type = 'arg'; Done = $false; Required = $true } }
                } elseif ($this.Parser.Commands.ContainsKey($base)) {
                    $needs = $this.Parser.Commands[$base].NeedsArg
                    if ($needs) { $segments += [PSCustomObject]@{ Text = ' <args>'; Type = 'arg'; Done = -not [string]::IsNullOrWhiteSpace($sub); Required = $true } }
                }
            } catch {}
        }
        return $segments
    }

    [void] RenderSyntaxLine([CompletionState] $state) {
        if (-not $this.IsShowSyntaxLineEnabled()) { return }
        if (-not $state) { $state = $this.GetAndCacheState() }
        if (-not $state) { return }
        $this.EnsureHud()
        $segments = $this.BuildSyntaxSegments($state)
        if ($segments.Count -eq 0) { return }
        try {
            $syntaxTop = if ($this.HudLine2Row -ge 0) { $this.HudLine2Row } else { $this.InputRow + 2 }
            Write-Host -NoNewline ([VT]::SavePos())
            Write-Host -NoNewline ([VT]::MoveTo(1, $syntaxTop))
            Write-Host -NoNewline ([VT]::ClearLine())
            Write-Host -NoNewline ([VT]::MoveTo(1, $syntaxTop))
            Write-Host -NoNewline "    Syntax: " -ForegroundColor DarkGray
            # Determine next segment (first arg not done)
            $next = $segments | Where-Object { $_.Type -eq 'arg' -and -not $_.Done } | Select-Object -First 1
            foreach ($seg in $segments) {
                if ($seg.Type -eq 'fixed') { Write-Host -NoNewline $seg.Text -ForegroundColor Gray; continue }
                if ($seg.Done) { Write-Host -NoNewline $seg.Text -ForegroundColor DarkGray }
                elseif ($seg.Required) { Write-Host -NoNewline $seg.Text -ForegroundColor White }
                else { Write-Host -NoNewline $seg.Text -ForegroundColor Gray }
            }
            Write-Host -NoNewline ([VT]::RestorePos())
        } finally { }
    }

    [void] TryAutoOpenPrefixCompletion() {
        try {
            # Only auto-open when not already cycling
            if ($this.InCompletion) { return }
            $state = $this.Parser.ParseBufferToState($this.Buffer, $this.CursorPos)
            $this.LastState = $state
            if ($state.Mode -eq [CompletionMode]::PrefixCompletion) {
                Write-DebugLog ("UI: AutoOpenPrefixCompletion for buffer='" + $this.Buffer + "' cursor=" + $this.CursorPos)
                $this.OriginalInput = $this.Buffer
                $smartCompletions = $this.Parser.GetSmartCompletions($this.Buffer, $this.CursorPos)
                $cnt = if ($smartCompletions) { $smartCompletions.Count } else { 0 }
                Write-DebugLog ("UI: AutoOpenPrefixCompletion got {0} items" -f $cnt)
                if ($smartCompletions -and $smartCompletions.Count -gt 0) {
                    $this.Completions = @($smartCompletions | Select-Object -ExpandProperty Command)
                    $this.CompletionDetails = $smartCompletions
                    $this.InCompletion = $true
                    $this.CompletionIndex = 0
                    # Do not auto-apply a value; just show indicators + ghost to avoid greedy completion
                    $this.RedrawLine()
                    $this.ShowCompletionIndicators()
                } else {
                    Write-DebugLog ("UI: AutoOpenPrefixCompletion no items; not entering completion mode")
                }
            }
        } catch { Write-DebugLog ("RenderSyntaxLine error: " + $_) }
    }

    [void] MoveCursorWordLeft() {
        $i = $this.CursorPos
        if ($i -le 0) { return }
        $j = $i - 1
        while ($j -ge 0 -and [char]::IsWhiteSpace($this.Buffer[$j])) { $j-- }
        while ($j -ge 0 -and -not [char]::IsWhiteSpace($this.Buffer[$j]) -and ($this.Buffer[$j] -notin @('@','#','+','-',';','|',':'))) { $j-- }
        $this.CursorPos = [Math]::Max(0, $j + 1)
        [Console]::SetCursorPosition((Get-Prompt).Length + $this.CursorPos, $this.InputRow)
    }

    [void] MoveCursorWordRight() {
        $i = $this.CursorPos
        $n = $this.Buffer.Length
        if ($i -ge $n) { return }
        $j = $i
        while ($j -lt $n -and [char]::IsWhiteSpace($this.Buffer[$j])) { $j++ }
        while ($j -lt $n -and -not [char]::IsWhiteSpace($this.Buffer[$j]) -and ($this.Buffer[$j] -notin @('@','#','+','-',';','|',':'))) { $j++ }
        $this.CursorPos = [Math]::Min($n, $j)
        [Console]::SetCursorPosition((Get-Prompt).Length + $this.CursorPos, $this.InputRow)
    }

    [void] DeletePrevToken() {
        if ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) { $this.AcceptCompletion(); $this.OriginalInput = $this.Buffer }
        $i = $this.CursorPos
        if ($i -le 0) { return }
        $j = $i
        while ($j -gt 0 -and [char]::IsWhiteSpace($this.Buffer[$j-1])) { $j-- }
        while ($j -gt 0 -and -not [char]::IsWhiteSpace($this.Buffer[$j-1])) { $j-- }
        $len = $i - $j
        if ($len -gt 0) {
            if ($j -ge 0 -and $len -gt 0 -and ($j + $len) -le $this.Buffer.Length) {
                $this.SafeRemove($j, $len)
            }
            $this.CursorPos = $j
            $this.RedrawLine()
        }
    }
    
    SmartInputHandler([SmartCommandParser]$parser) {
        $this.Parser = $parser
        $this.LoadHistory()
    }
    
    [void] LoadHistory() {
        $historyFile = Join-Path $PSScriptRoot "history.txt"
        if (Test-Path $historyFile) {
            $this.History = Get-Content $historyFile
        }
    }
    
    [void] SaveHistory() {
        $historyFile = Join-Path $PSScriptRoot "history.txt"
        $this.History[-100..-1] | Set-Content $historyFile
    }
    
    [bool] IsAcceptOnTypeEnabled() {
        try {
            $cfg = [ConfigManager]::Config
            if ($cfg -and $cfg.Behavior -and $cfg.Behavior.AcceptOnType -ne $null) {
                return [bool]$cfg.Behavior.AcceptOnType
            }
        } catch {}
        return $true
    }

    [void] NormalizeDueEstBeforeColon() {
        try {
            if ($this.CursorPos -le 0) { return }
            $pos = $this.CursorPos
            $j = $pos - 1
            $hadSpace = $false
            if ($j -ge 0 -and $this.Buffer[$j] -eq ' ') { $hadSpace = $true; $j-- }
            if ($j -lt 0) { return }
            $start = $j
            while ($start -gt 0 -and ($this.Buffer[$start - 1] -match '\\S')) { $start-- }
            $length = $j - $start + 1
            if ($length -le 0) { return }
            $token = $this.Buffer.Substring($start, $length)
            if ($token -match '^(?i)(due)$') {
                if ($hadSpace) {
                    # Remove the space between token and ':'
                    $removeIndex = $start + $token.Length
                    if ($removeIndex -ge 0 -and $removeIndex -lt $this.Buffer.Length) {
                        $this.SafeRemove($removeIndex, 1)
                        if ($this.CursorPos -gt 0) { $this.CursorPos-- }
                        "INPUT: Normalized '${token} :' to '${token}:'" | Write-Debug
                    }
                }
            }
        } catch {}
    }
    
    [string] ReadCommand() {
        $this.Buffer = ""
        $this.CursorPos = 0
        $this.InCompletion = $false
        $this.HistoryIndex = -1
        # Anchor input row (1-based for VT) with bottom clamp for HUD
        $currentRow1 = [Console]::CursorTop + 1
        $windowH = [Console]::WindowHeight
        $targetRow = if ($currentRow1 + 2 -le $windowH) { $currentRow1 } else { [Math]::Max(1, $windowH - 2) }
        $this.InputRow = $targetRow
        $this.EnsureHud()
        $this.RedrawLine()
        
        while ($true) {
            $key = [Console]::ReadKey($true)
            
            switch ($key.Key) {
                'Tab' {
                    # Support Shift+Tab for reverse cycling
                    $reverse = (($key.Modifiers -band [ConsoleModifiers]::Shift) -ne 0)
                    $this.ReverseCycle = $reverse
                    $this.HandleTab()
                }
                'Enter' {
                    if ($this.InCompletion) {
                        $this.AcceptCompletion()
                        # Don't submit, just accept completion and continue editing
                    } else {
                        Write-Host ""
                        
                        # Add to history
                        if (-not [string]::IsNullOrWhiteSpace($this.Buffer)) {
                            $this.History += $this.Buffer
                            $this.SaveHistory()
                        }
                        
                        return $this.Buffer
                    }
                }
                'Escape' {
                    if ($this.InCompletion) {
                        $this.CancelCompletion()
                    } else {
                        $this.Buffer = ""
                        $this.CursorPos = 0
                        $this.RedrawLine()
                    }
                }
                'Backspace' {
                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {
                        $this.DeletePrevToken()
                    } else {
                        if ($this.InCompletion) { $this.CancelCompletion() }
                        if ($this.CursorPos -gt 0) {
                            $this.SafeRemove($this.CursorPos - 1, 1)
                            $this.CursorPos--
                            $this.ClampCursor()
                            $this.RedrawLine()
                        }
                    }
                }
                'UpArrow' {
                    if ($this.History.Count -gt 0) {
                        if ($this.HistoryIndex -eq -1) {
                            $this.HistoryIndex = $this.History.Count - 1
                        } elseif ($this.HistoryIndex -gt 0) {
                            $this.HistoryIndex--
                        }
                        
                        $this.Buffer = $this.History[$this.HistoryIndex]
                        $this.CursorPos = $this.Buffer.Length
                        $this.RedrawLine()
                    }
                }
                'DownArrow' {
                    if ($this.HistoryIndex -ge 0) {
                        if ($this.HistoryIndex -lt $this.History.Count - 1) {
                            $this.HistoryIndex++
                            $this.Buffer = $this.History[$this.HistoryIndex]
                        } else {
                            $this.HistoryIndex = -1
                            $this.Buffer = ""
                        }
                        $this.CursorPos = $this.Buffer.Length
                        $this.RedrawLine()
                    }
                }
                'LeftArrow' {
                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {
                        if ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) { $this.AcceptCompletion(); $this.OriginalInput = $this.Buffer }
                        $this.MoveCursorWordLeft()
                    } else {
                        if ($this.InCompletion -and $this.CursorPos -eq $this.Buffer.Length -and $this.IsAcceptOnTypeEnabled()) {
                            $this.AcceptCompletion(); $this.OriginalInput = $this.Buffer
                        }
                        if ($this.CursorPos -gt 0) {
                            $this.CursorPos--
                            $promptLen = (Get-Prompt).Length
                            Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
                        }
                    }
                }
                'RightArrow' {
                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {
                        if ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) { $this.AcceptCompletion(); $this.OriginalInput = $this.Buffer }
                        $this.MoveCursorWordRight()
                    } else {
                        # If we're at the end and a completion is showing, accept it
                        if ($this.InCompletion -and $this.CursorPos -eq $this.Buffer.Length -and $this.IsAcceptOnTypeEnabled()) {
                            $this.AcceptCompletion(); $this.OriginalInput = $this.Buffer
                        }
                        elseif ($this.CursorPos -lt $this.Buffer.Length) {
                            $this.CursorPos++
                            $promptLen = (Get-Prompt).Length
                            Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
                        }
                    }
                }
                'Home' {
                    if ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) {
                        $this.AcceptCompletion()
                        $this.OriginalInput = $this.Buffer
                    }
                    $this.CursorPos = 0
                    $promptLen = (Get-Prompt).Length
                    Write-Host -NoNewline ([VT]::MoveTo($promptLen + 1, $this.InputRow))
                }
                'End' {
                    # If a completion is showing, accept before moving to end
                    if ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) {
                        $this.AcceptCompletion()
                        $this.OriginalInput = $this.Buffer
                    }
                    $this.CursorPos = $this.Buffer.Length
                    $promptLen = (Get-Prompt).Length
                    Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
                }
                default {
                    "INPUT: Processing key='$($key.KeyChar)' (KeyCode=$($key.Key)), InCompletion=$($this.InCompletion)" | Write-Debug
                    "INPUT: Before - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                    
                    if ($this.InCompletion -and $key.KeyChar -eq ' ') {
                        # Space accepts the current completion
                        "INPUT: Space pressed - accepting completion" | Write-Debug
                        
                        # Check what completion we're accepting to see if it needs immediate input
                        $selectedCompletion = ""
                        if ($this.Completions.Count -gt 0 -and $this.CompletionIndex -ge 0 -and $this.CompletionIndex -lt $this.Completions.Count) {
                            $selectedCompletion = $this.Completions[$this.CompletionIndex]
                        }
                        "INPUT: Selected completion='$selectedCompletion'" | Write-Debug
                        
                        $this.AcceptCompletion()
                        # Update OriginalInput to current buffer so next Tab works correctly
                        $this.OriginalInput = $this.Buffer
                        "INPUT: Updated OriginalInput to '$($this.OriginalInput)'" | Write-Debug
                        
                        # Only add space if:
                        # 1. Buffer doesn't already end with space (prevents double-space)
                        # 2. Completion is not a prefix that needs immediate input (@, #, due:, est:)
                        $needsImmediateInput = ($selectedCompletion -eq '@' -or $selectedCompletion -eq '#' -or 
                                              $selectedCompletion.EndsWith(':'))
                        
                        if (-not $this.Buffer.EndsWith(' ') -and -not $needsImmediateInput) {
                            $this.SafeInsert($this.CursorPos, ' ')
                            $this.CursorPos++
                            "INPUT: Added space - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                        } else {
                            if ($needsImmediateInput) {
                                "INPUT: Prefix needs immediate input, no space added - Buffer='$($this.Buffer)'" | Write-Debug
                            } else {
                                "INPUT: Buffer already ends with space, no space added - Buffer='$($this.Buffer)'" | Write-Debug
                            }
                        }
                        $this.RedrawLine()
                        if ($key.KeyChar -ne ' ') { $this.TryAutoOpenPrefixCompletion() }
                    } elseif ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) {
                        # Accept-on-type: accept current completion, then insert the typed char
                        "INPUT: Regular printable key while in completion - accepting and continuing" | Write-Debug
                        $selectedCompletion = ""
                        if ($this.Completions.Count -gt 0 -and $this.CompletionIndex -ge 0 -and $this.CompletionIndex -lt $this.Completions.Count) {
                            $selectedCompletion = $this.Completions[$this.CompletionIndex]
                        }
                        "INPUT: Selected completion='$selectedCompletion'" | Write-Debug
                        
                        # If we're completing a prefix value and the user types a letter/number, keep typing instead of accepting
                        $isAlphaNum = ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar))
                        $isPrefixMode = $false
                        try {
                            if ($this.LastState) { $isPrefixMode = ($this.LastState.Mode -eq [CompletionMode]::PrefixCompletion) }
                            else { $isPrefixMode = ($this.Parser.ParseBufferToState($this.OriginalInput).Mode -eq [CompletionMode]::PrefixCompletion) }
                        } catch {}
                        $needsImmediateInput = ($selectedCompletion -eq '@' -or $selectedCompletion -eq '#' -or $selectedCompletion.EndsWith(':'))

                        if ($isPrefixMode -and $isAlphaNum -and -not $needsImmediateInput) {
                            "INPUT: Prefix completion and alphanumeric typed ‚Äî continue typing (do not accept)" | Write-Debug
                            $this.CancelCompletion()
                            if ($key.KeyChar -eq ':') { $this.NormalizeDueEstBeforeColon() }
                            $this.SafeInsert($this.CursorPos, $key.KeyChar)
                            $this.CursorPos++
                            $this.RedrawLine()
                            $this.TryAutoOpenPrefixCompletion()
                        } else {
                            $this.AcceptCompletion()
                            $this.OriginalInput = $this.Buffer

                            # If it's not a prefix and we don't already end with space, insert one
                            if (-not $needsImmediateInput -and -not $this.Buffer.EndsWith(' ')) {
                                $this.SafeInsert($this.CursorPos, ' ')
                                $this.CursorPos++
                                "INPUT: Inserted implied space before typed char" | Write-Debug
                            }

                            # Collision guard: avoid duplicating ':' after a '...:' completion
                            $skipTypedChar = ($selectedCompletion.EndsWith(':') -and $key.KeyChar -eq ':')
                            # Normalize 'due :' -> 'due:' if typing ':'
                            if (-not $skipTypedChar -and $key.KeyChar -eq ':') { $this.NormalizeDueEstBeforeColon() }
                            if (-not $skipTypedChar -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                                $this.SafeInsert($this.CursorPos, $key.KeyChar)
                                $this.CursorPos++
                                "INPUT: Added char after accepting completion - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                            } else {
                                if ($skipTypedChar) { "INPUT: Skipped duplicate ':' after prefix completion" | Write-Debug }
                            }
                            $this.RedrawLine()
                        }
                        
                        if ($key.KeyChar -ne ' ') { $this.TryAutoOpenPrefixCompletion() }
                    } elseif ($this.InCompletion) {
                        # Accept-on-type disabled: keep legacy behavior (cancel then type)
                        "INPUT: Regular key while in completion - cancelling first (accept-on-type disabled)" | Write-Debug
                        $this.CancelCompletion()
                        if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                            if ($key.KeyChar -eq ':') { $this.NormalizeDueEstBeforeColon() }
                            $this.SafeInsert($this.CursorPos, $key.KeyChar)
                            $this.CursorPos++
                            $this.RedrawLine()
                            if ($key.KeyChar -ne ' ') { $this.TryAutoOpenPrefixCompletion() }
                        }
                    } else {
                        "INPUT: Normal key processing (not in completion)" | Write-Debug
                        if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                            if ($key.KeyChar -eq ':') { $this.NormalizeDueEstBeforeColon() }
                            $this.SafeInsert($this.CursorPos, $key.KeyChar)
                            $this.CursorPos++
                            "INPUT: Added char normally - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                            $this.RedrawLine()
                            if ($key.KeyChar -ne ' ') { $this.TryAutoOpenPrefixCompletion() }
                        }
                    }
                }
            }
        }
        # Fallback return ‚Äì should not be hit in normal flow
        return ""
    }
    
    [void] HandleTab() {
        "=== HANDLETAB START ===" | Write-Debug
        "HANDLETAB: InCompletion=$($this.InCompletion), Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
        "HANDLETAB: OriginalInput='$($this.OriginalInput)'" | Write-Debug
        "HANDLETAB: ReverseCycle=$($this.ReverseCycle)" | Write-Debug
        Write-DebugLog ("UI: HandleTab start InCompletion=" + $this.InCompletion + ", Buffer='" + $this.Buffer + "', CursorPos=" + $this.CursorPos)
        
        if (-not $this.InCompletion) {
            $this.OriginalInput = $this.Buffer
            "HANDLETAB: Set OriginalInput to '$($this.OriginalInput)'" | Write-Debug
            "HANDLETAB: Getting completions for buffer '$($this.Buffer)'" | Write-Debug
            Write-DebugLog ("UI: HandleTab querying completions")
            
            $smartCompletions = $this.Parser.GetSmartCompletions($this.Buffer, $this.CursorPos)
            "HANDLETAB: GetSmartCompletions returned $($smartCompletions.Count) items" | Write-Debug
            $htCnt = if ($smartCompletions) { $smartCompletions.Count } else { 0 }
            Write-DebugLog ("UI: HandleTab completions count={0}" -f $htCnt)
            
            for ($i = 0; $i -lt $smartCompletions.Count; $i++) {
                $comp = $smartCompletions[$i]
                "HANDLETAB: Completion[$i]: Command='$($comp.Command)', Description='$($comp.Description)', Type='$($comp.Type)'" | Write-Debug
                if ($i -lt 3) { Write-DebugLog ("UI: Completion[" + $i + "] '" + $comp.Command + "' ‚Äî '" + ($comp.Description) + "'") }
            }
            
            $this.Completions = @($smartCompletions | Select-Object -ExpandProperty Command)
            $this.CompletionDetails = $smartCompletions
            "HANDLETAB: Set Completions=$($this.Completions.Count), CompletionDetails=$($this.CompletionDetails.Count)" | Write-Debug
            "HANDLETAB: Completions array: $($this.Completions -join ', ')" | Write-Debug
            Write-DebugLog ("UI: Entering completion? Count=" + $this.Completions.Count)
            
            if ($this.Completions.Count -gt 0) {
                "HANDLETAB: Found completions, entering completion mode" | Write-Debug
                $this.InCompletion = $true
                if ($this.ReverseCycle) {
                    $this.CompletionIndex = $this.Completions.Count - 1
                } else {
                    $this.CompletionIndex = 0
                }
                "HANDLETAB: About to call ApplyCompletion()" | Write-Debug
                Write-DebugLog ("UI: ApplyCompletion initial index=" + $this.CompletionIndex)
                $this.ApplyCompletion()
                "HANDLETAB: ApplyCompletion() returned" | Write-Debug
                Write-DebugLog ("UI: ApplyCompletion returned; Buffer='" + $this.Buffer + "' CursorPos=" + $this.CursorPos)
                # Ensure cursor returns to input line
                $promptLen = (Get-Prompt).Length
                Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
            } else {
                "HANDLETAB: No completions found" | Write-Debug
                Write-DebugLog ("UI: No completions found")
            }
        } else {
            # Cycle through
            "HANDLETAB: Cycling through completions, index was $($this.CompletionIndex)" | Write-Debug
            Write-DebugLog ("UI: Cycle completion from index=" + $this.CompletionIndex + "/" + $this.Completions.Count)
            $oldIndex = $this.CompletionIndex
            if ($this.ReverseCycle) {
                $this.CompletionIndex = ($this.CompletionIndex - 1)
                if ($this.CompletionIndex -lt 0) { $this.CompletionIndex = $this.Completions.Count - 1 }
            } else {
                $this.CompletionIndex = ($this.CompletionIndex + 1) % $this.Completions.Count
            }
            "HANDLETAB: Changed index from $oldIndex to $($this.CompletionIndex)" | Write-Debug
            "HANDLETAB: About to call ApplyCompletion() for cycling" | Write-Debug
            Write-DebugLog ("UI: ApplyCompletion (cycle) index=" + $this.CompletionIndex)
            $this.ApplyCompletion()
            "HANDLETAB: ApplyCompletion() for cycling returned" | Write-Debug
            Write-DebugLog ("UI: After cycle ApplyCompletion Buffer='" + $this.Buffer + "' CursorPos=" + $this.CursorPos)
            $promptLen = (Get-Prompt).Length
            Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
        }
        # Reset reverse flag
        $this.ReverseCycle = $false
        "HANDLETAB: COMPLETE - Buffer is now '$($this.Buffer)'" | Write-Debug
        Write-DebugLog ("UI: HandleTab complete Buffer='{0}'" -f $this.Buffer)
    }
    
    [void] ApplyCompletion() {
        "=== APPLYCOMPLETION START ===" | Write-Debug
        "APPLY: Buffer BEFORE='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
        "APPLY: OriginalInput='$($this.OriginalInput)'" | Write-Debug
        "APPLY: Completions.Count=$($this.Completions.Count), CompletionIndex=$($this.CompletionIndex)" | Write-Debug
        Write-DebugLog ("UI: ApplyCompletion start; count={0}, index={1}" -f $this.Completions.Count, $this.CompletionIndex)
        
        if ($this.Completions.Count -gt 0 -and $this.CompletionIndex -ge 0 -and $this.CompletionIndex -lt $this.Completions.Count) {
            $completion = $this.Completions[$this.CompletionIndex]
            "APPLY: Selected completion='$completion'" | Write-Debug
            Write-DebugLog ("UI: Selected completion '" + $completion + "'")
            
            # Use the robust parser's current state - BUT REANALYZE with original input
            "APPLY: About to get parser state for OriginalInput='$($this.OriginalInput)'" | Write-Debug
            # CRITICAL FIX: AnalyzeInput doesn't exist - we need to parse the original input to get the state
            $state = $this.Parser.ParseBufferToState($this.OriginalInput)
            $this.Parser.CurrentState = $state  # Update the parser's state
            $this.LastState = $state
            "APPLY: Parser re-analyzed - Mode=$($state.Mode), CurrentToken='$($state.CurrentToken)', CurrentCommand='$($state.CurrentCommand)'" | Write-Debug
            "APPLY: State details - CompletedArguments.Count=$($state.CompletedArguments.Count), OriginalBuffer='$($state.OriginalBuffer)'" | Write-Debug
            $cmdForLog = if ($state.FullCommandName) { $state.FullCommandName } else { $state.CurrentCommand }
            Write-DebugLog ("UI: State Mode={0}, Token='{1}', Cmd='{2}'" -f $state.Mode, $state.CurrentToken, $cmdForLog)
            
            # Log all completed arguments
            for ($i = 0; $i -lt $state.CompletedArguments.Count; $i++) {
                "APPLY: CompletedArguments[$i]='$($state.CompletedArguments[$i])'" | Write-Debug
            }
            
            # Apply completion based on robust state analysis
            "APPLY: About to call BuildNewBufferWithCompletion" | Write-Debug
            $newBuffer = $this.BuildNewBufferWithCompletion($completion, $state)
            "APPLY: BuildNewBufferWithCompletion returned '$newBuffer'" | Write-Debug
            Write-DebugLog ("UI: BuildNewBufferWithCompletion -> '" + ($newBuffer) + "'")
            
            if ($newBuffer -ne $null -and $newBuffer -ne $this.Buffer) {
                "APPLY: Changing buffer from '$($this.Buffer)' to '$newBuffer'" | Write-Debug
                $oldBuffer = $this.Buffer
                $this.Buffer = $newBuffer
                $this.CursorPos = $this.Buffer.Length
                "APPLY: Updated Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
            $this.RedrawLine()
            "APPLY: RedrawLine() complete" | Write-Debug
            } else {
                "APPLY: Buffer unchanged (newBuffer='$newBuffer', current='$($this.Buffer)')" | Write-Debug
            }
            
            # Show completion indicators
            "APPLY: About to show completion indicators" | Write-Debug
            $this.ShowCompletionIndicators()
            "APPLY: ShowCompletionIndicators() complete" | Write-Debug
            Write-DebugLog ("UI: ShowCompletionIndicators done; index=" + $this.CompletionIndex + "/" + $this.Completions.Count)
        } else {
            "APPLY: Cannot apply - invalid state (Count=$($this.Completions.Count), Index=$($this.CompletionIndex))" | Write-Debug
            Write-DebugLog ("UI: ApplyCompletion invalid state; count=" + $this.Completions.Count + ", index=" + $this.CompletionIndex)
        }
        "APPLY: COMPLETE - Final buffer='$($this.Buffer)'" | Write-Debug
        Write-DebugLog ("UI: ApplyCompletion complete Buffer='" + $this.Buffer + "' CursorPos=" + $this.CursorPos)
    }
    
    [void] ShowCompletionIndicators() {
        if ($this.Completions.Count -le 0 -or $this.CompletionIndex -lt 0) { return }
        $this.EnsureHud()
        try {
            $current = $this.CompletionIndex + 1
            $total = $this.Completions.Count
            Write-DebugLog ("UI: Indicators show current=" + $current + "/" + $total)
            
            if ($this.CompletionDetails.Count -gt 0 -and $this.CompletionIndex -lt $this.CompletionDetails.Count) {
                $detail = $this.CompletionDetails[$this.CompletionIndex]
                if ($detail) {
                    $hudTop = if ($this.HudLine1Row -ge 0) { $this.HudLine1Row } else { $this.InputRow + 1 }
                    Write-Host -NoNewline ([VT]::SavePos())
                    Write-Host -NoNewline ([VT]::MoveTo(1, $hudTop))
                    Write-Host -NoNewline ([VT]::ClearLine())
                    Write-Host -NoNewline ([VT]::MoveTo(1, $hudTop))
                    $mode = ''; $prefix = ''
                    try { if ($this.LastState) { $mode = $this.LastState.Mode.ToString(); if ($this.LastState.PrefixBeingCompleted) { $prefix = " (" + $this.LastState.PrefixBeingCompleted + ")" } } } catch {}
                    $desc = if ($detail.Description) { $detail.Description } else { '' }
                    # Show top 2 suggestions inline for quick preview
                    $topPreview = ''
                    try {
                        $top = @()
                        for ($i = 0; $i -lt [Math]::Min(2, $this.Completions.Count); $i++) { $top += $this.Completions[$i] }
                        if ($top.Count -gt 0) { $topPreview = ' ‚Ä¢ ' + ($top -join '  ') }
                    } catch {}
                    $status = "  $mode$prefix ‚Ä¢ $total suggestions$topPreview"
                    if ($desc) { $status += " ‚Äî $desc" }
                    Write-Host -NoNewline $status -ForegroundColor DarkCyan
                    Write-DebugLog ("UI: Indicator status='" + $status + "'")
                    try { $st2 = if ($this.LastState) { $this.LastState } else { $this.Parser.ParseBufferToState($this.Buffer, $this.CursorPos) }; $this.RenderSyntaxLine($st2) } catch {}
                    Write-Host -NoNewline ([VT]::RestorePos())
                }
            }
        } finally {
            # Ensure cursor returns to input line
            $promptLen = (Get-Prompt).Length
            Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
        }
    }
    
    [string] BuildNewBufferWithCompletion([string] $completion, [CompletionState] $state) {
        "=== BUILDNEWBUFFER START ===" | Write-Debug
        "BUILD: completion='$completion', state.Mode=$($state.Mode), state.OriginalBuffer='$($state.OriginalBuffer)'" | Write-Debug
        try {
            switch ($state.Mode) {
                ([CompletionMode]::Command) { return $completion }
                ([CompletionMode]::Subcommand) {
                    if ($state.CompletedArguments.Count -gt 0) { return ($state.CompletedArguments -join ' ') + ' ' + $completion }
                    return $completion
                }
                ([CompletionMode]::SyntaxDiscovery) {
                    $commandPart = $state.CurrentCommand
                    $base = if ($state.CompletedArguments.Count -gt 0) { "$commandPart $($state.CompletedArguments -join ' ')" } else { $commandPart }
                    if ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#') { return "$base $completion" }
                    return "$base $completion "
                }
                ([CompletionMode]::PrefixCompletion) {
                    $orig = $state.OriginalBuffer
                    $trim = $orig.TrimEnd()
                    $idx = $trim.LastIndexOf(' ')
                    if ($idx -ge 0) {
                        $pre = $trim.Substring(0, $idx + 1)
                        if ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#') { return $pre + $completion }
                        return $pre + $completion + ' '
                    }
                    if ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#') { return $completion }
                    return $completion + ' '
                }
                default {
                    $needsSpace = -not ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#')
                    if ($state.OriginalBuffer.EndsWith(' ')) {
                        return $state.OriginalBuffer + $completion + ($(if ($needsSpace) { ' ' } else { '' }))
                    }
                    return $state.OriginalBuffer + ' ' + $completion + ($(if ($needsSpace) { ' ' } else { '' }))
                }
            }
        }
        catch {
            "BUILD CATCH: Exception occurred, using fallback" | Write-Debug
            Write-DebugLog ("BuildNewBufferWithCompletion exception: " + $_)
            return $state.OriginalBuffer + ' ' + $completion
        }
        # Final fallback to satisfy static analysis
        return $state.OriginalBuffer
    }
    
    [void] AcceptCompletion() {
        $this.InCompletion = $false
        $this.Completions = @()
        $this.CompletionDetails = @()
        $this.CompletionIndex = -1
        
        # Clear HUD status line and restore cursor
        $hud1 = if ($this.HudLine1Row -ge 0) { $this.HudLine1Row } else { $this.InputRow + 1 }
        $promptLen = (Get-Prompt).Length
        Write-Host -NoNewline ([VT]::SavePos())
        Write-Host -NoNewline ([VT]::MoveTo(1, $hud1))
        Write-Host -NoNewline ([VT]::ClearLine())
        Write-Host -NoNewline ([VT]::RestorePos())
        Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
    }
    
    [void] CancelCompletion() {
        "=== CANCELCOMPLETION START ===" | Write-Debug
        "CANCEL: Before - Buffer='$($this.Buffer)', OriginalInput='$($this.OriginalInput)'" | Write-Debug
        "CANCEL: InCompletion=$($this.InCompletion), CompletionIndex=$($this.CompletionIndex)" | Write-Debug
        
        $this.Buffer = $this.OriginalInput
        $this.CursorPos = $this.Buffer.Length
        $this.InCompletion = $false
        $this.Completions = @()
        $this.CompletionDetails = @()
        $this.CompletionIndex = -1
        
        "CANCEL: After reset - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
        "CANCEL: About to redraw line" | Write-Debug
        $this.RedrawLine()
        "CANCEL: COMPLETE" | Write-Debug
    }
    
    [void] RedrawLine() {
        # Redraw anchored input line using VT
        if ($this.InputRow -lt 1) { $this.InputRow = [Console]::CursorTop + 1 }
        $prompt = Get-Prompt
        $promptLen = $prompt.Length
        Write-Host -NoNewline ([VT]::Hide())
        Write-Host -NoNewline ([VT]::MoveTo(1, $this.InputRow))
        Write-Host -NoNewline ([VT]::ClearLine())
        Write-Host -NoNewline $prompt
        Write-Host -NoNewline $this.Buffer
        
        # Ghost remainder overlay (non-greedy): show the rest of the selected completion without altering buffer
        if ($this.InCompletion -and $this.Completions.Count -gt 0 -and $this.CompletionIndex -ge 0 -and $this.CompletionIndex -lt $this.Completions.Count) {
            $selected = $this.Completions[$this.CompletionIndex]
            $typedToken = ''
            try {
                if ($this.LastState -and $this.LastState.CurrentToken) { $typedToken = $this.LastState.CurrentToken }
                else {
                    # Fallback: last whitespace-delimited token from buffer
                    $parts = $this.Buffer -split '\\s+'
                    if ($parts.Count -gt 0) { $typedToken = $parts[-1] }
                }
                if ($typedToken -and $selected -and $selected.StartsWith($typedToken)) {
                    $ghost = $selected.Substring($typedToken.Length)
                    if ($ghost) { Write-Host -NoNewline $ghost -ForegroundColor DarkGray }
                }
            } catch {}
        }
        else {
            # Ghost next-token hint when not actively showing remainder
            $state = $this.GetAndCacheState()
            $hint = $this.GetNextArgGhost($state)
            if ($hint) { Write-Host -NoNewline $hint -ForegroundColor DarkGray }
        }
        
        # Position cursor
        Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
        Write-Host -NoNewline ([VT]::Show())
    }

    [void] EnsureHud() {
        try {
            if ($this.HudReserved) { return }
            if ($this.InputRow -lt 1) { $this.InputRow = [Console]::CursorTop + 1 }
            $this.HudLine1Row = $this.InputRow + 1
            $this.HudLine2Row = $this.InputRow + 2
            $this.HudReserved = $true
            Write-DebugLog ("HUD: Reserved at rows " + $this.HudLine1Row + ", " + $this.HudLine2Row)
        } catch { $this.HudReserved = $false }
    }
}

function Get-Prompt {
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        return "todo:$($global:CurrentContext)> "
    }
    return "todo> "
}

function Exit-SmartTUI {
    # Save session stats
    $duration = [Math]::Round(((Get-Date) - $global:SessionStats.SessionStart).TotalMinutes)
    
    Write-Host "`n  üëã SESSION SUMMARY" -ForegroundColor Cyan
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkCyan
    Write-Host "  Duration: ${duration}m" -ForegroundColor White
    Write-Host "  Tasks Added: $($global:SessionStats.TasksAdded)" -ForegroundColor Green
    Write-Host "  Tasks Completed: $($global:SessionStats.TasksCompleted)" -ForegroundColor Green
    Write-Host "  Commands Run: $($global:SessionStats.CommandsRun)" -ForegroundColor Gray
    Write-Host "`n  Goodbye! üöÄ" -ForegroundColor Cyan
    Write-Host ""
    
    exit
}

# === MAIN ENTRY POINT ===
function Start-TodoistTUI {
    [ConfigManager]::Load()
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Cyan
    Write-Host "  ‚ïë           TODOIST TUI PROFESSIONAL - v2.0                   ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïë                                                              ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïë  Tab: Complete | Space/Right/End: Accept | help: Commands   ‚ïë" -ForegroundColor DarkCyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Cyan
    
    # Load context
    $data = Get-TaskData
    $global:CurrentContext = $data.currentContext
    
    # Show agenda
    Show-RichAgenda
    
    # Initialize
    $parser = [SmartCommandParser]::new()
    $inputHandler = [SmartInputHandler]::new($parser)
    
    # Main loop
    while ($true) {
        try {
            $command = $inputHandler.ReadCommand()
            
            if ($command -eq 'exit' -or $command -eq 'quit' -or $command -eq 'q') {
                Exit-SmartTUI
            }
            
            # NEW: Use structured parsing directly
            $parser.ExecuteStructured($command)
        }
        catch {
            Write-Host "Error: $_" -ForegroundColor Red
            Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
        }
    }
}

# === MISSING FUNCTION IMPLEMENTATIONS ===

function Show-FilteredTasks {
    param([hashtable]$params = @{})
    
    # Normalize filters
    $filter = if ($params.ContainsKey('Filter')) { $params.Filter } else { '' }
    $prio   = if ($params.ContainsKey('Priority')) { [int]$params.Priority } else { -1 }
    $search = if ($params.ContainsKey('Search')) { $params.Search } else { '' }

    $tasks  = Get-Tasks -Filter $filter -Priority $prio -Search $search -Sort

    # Display results using styled table
    Clear-Host
    $title = if ($filter) { "TASKS: $($filter.ToUpper())" } elseif ($prio -ge 0) { "PRIORITY $prio TASKS" } elseif ($search) { "SEARCH: '$search'" } else { "FILTERED TASKS" }

    if ($tasks.Count -eq 0) {
        $rows = @(); $rows += , @('No tasks match the criteria')
        Format-StyledTable -Headers @('Info') -DataRows $rows -Title $title
        return
    }

    $rows = @(); $global:LastShownTaskMap.Clear(); $localId = 1
    foreach ($t in $tasks) {
        Set-LastShownEntry -LocalId $localId -TaskId $t.id
        $pri = Get-PriorityIcon $t.priority
        $due = if ($t.due) { ([datetime]$t.due).ToString('MM/dd') } else { '' }
        $proj = if ($t.project) { $t.project } else { '(none)' }
        $rows += , @($localId, $pri, $t.text, $proj, $due)
        $localId++
    }
    Format-StyledTable -Headers @('#','Pri','Task','Project','Due') -DataRows $rows -Title $title
    Write-Host "  Tip: To log time, type 'log @' and press Tab to cycle projects, or use '#ID1' for codes." -ForegroundColor DarkGray
}

function Show-MonthView {
    Clear-Host
    $today = Get-Date
    $year = $today.Year
    $month = $today.Month
    
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Magenta
    $header = (Get-Date -Month $month -Day 1 -Format 'MMMM yyyy').ToUpper()
    Write-Host "  ‚ïë$($header.PadLeft(32 + $header.Length/2).PadRight(60))‚ïë" -ForegroundColor Magenta
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Magenta
    
    # Calendar header
    Write-Host "`n    Sun  Mon  Tue  Wed  Thu  Fri  Sat" -ForegroundColor Cyan
    Write-Host "    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkCyan
    
    # Get first day of month and number of days
    $firstDay = Get-Date -Year $year -Month $month -Day 1
    $daysInMonth = [DateTime]::DaysInMonth($year, $month)
    $startDayOfWeek = [int]$firstDay.DayOfWeek
    
    # Get task data for highlighting days with tasks
    $data = Get-TaskData
    $taskDays = @{}
    foreach ($task in $data.tasks) {
        if ($task.due -and -not $task.completed) {
            try {
                $dueDate = [DateTime]::Parse($task.due)
                if ($dueDate.Year -eq $year -and $dueDate.Month -eq $month) {
                    $taskDays[$dueDate.Day] = $true
                }
            } catch {}
        }
    }
    
    Write-Host "   " -NoNewline
    
    # Add padding for first week
    for ($i = 0; $i -lt $startDayOfWeek; $i++) {
        Write-Host "     " -NoNewline
    }
    
    # Print calendar days
    for ($day = 1; $day -le $daysInMonth; $day++) {
        $dayOfWeek = ($startDayOfWeek + $day - 1) % 7
        
        # Highlight today
        if ($day -eq $today.Day -and $month -eq $today.Month -and $year -eq $today.Year) {
            Write-Host " [$($day.ToString().PadLeft(2))]" -NoNewline -ForegroundColor Yellow
        }
        # Highlight days with tasks
        elseif ($taskDays.ContainsKey($day)) {
            Write-Host "  $($day.ToString().PadLeft(2)) " -NoNewline -ForegroundColor Green
        }
        else {
            Write-Host "  $($day.ToString().PadLeft(2)) " -NoNewline -ForegroundColor White
        }
        
        # New line after Saturday
        if ($dayOfWeek -eq 6) {
            Write-Host ""
            if ($day -lt $daysInMonth) {
                Write-Host "   " -NoNewline
            }
        }
    }
    
    Write-Host "`n"
    Write-Host "  Legend: [Today] " -NoNewline -ForegroundColor Yellow
    Write-Host "Days with tasks " -ForegroundColor Green
    Write-Host ""
    Write-Host "  Tip: To log time, type 'log @' and press Tab to cycle projects, or use '#ID1' for codes." -ForegroundColor DarkGray
}

function Show-BlockedTasks {
    $data = Get-TaskData
    $blocked = $data.tasks | Where-Object { 
        $_.dependencies -and $_.dependencies.Count -gt 0 -and -not $_.completed
    }
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Red
    Write-Host "  ‚ïë                      BLOCKED TASKS                         ‚ïë" -ForegroundColor Red
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Red
    
    if ($blocked.Count -eq 0) {
        Write-Host "`n  üéâ No blocked tasks!" -ForegroundColor Green
        return
    }
    
    Write-Host "`n  Found $($blocked.Count) blocked task$(if($blocked.Count -ne 1){'s'}):`n" -ForegroundColor Yellow
    
    foreach ($task in $blocked) {
        Write-Host "  üö´ $($task.text)" -ForegroundColor Red
        Write-Host "     Waiting on: $($task.dependencies -join ', ')" -ForegroundColor DarkRed
        Write-Host ""
    }
}

function Add-Project {
    param($parsed)
    
    $data = Get-TaskData
    
    # Validate name
    if (-not $parsed.Name -or $parsed.Name.Length -eq 0) {
        Write-Host "Project name is required" -ForegroundColor Red
        return
    }
    
    # Check for duplicates
    if ($data.projects | Where-Object { $_.name -eq $parsed.Name }) {
        Write-Host "Project '$($parsed.Name)' already exists." -ForegroundColor Yellow
        return
    }
    
    # Generate smart aliases
    $aliases = Generate-ProjectAliases -name $parsed.Name -existingProjects $data.projects
    
    # Create project
    $newProject = [PSCustomObject]@{
        name = $parsed.Name
        description = if ($parsed.Fields.description) { $parsed.Fields.description } else { "Created $(Get-Date -Format 'yyyy-MM-dd')" }
        aliases = $aliases
        created = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    }
    
    # Add custom fields
    foreach ($key in $parsed.Fields.Keys) {
        if ($key -ne 'description') {
            Add-Member -InputObject $newProject -MemberType NoteProperty -Name $key -Value $parsed.Fields[$key]
        }
    }
    
    $data.projects += $newProject
    Save-TaskData $data
    
    Write-Host "Project '$($parsed.Name)' created." -ForegroundColor Green
    if ($aliases.Count -gt 0) {
        Write-Host "  Shortcuts: $($aliases -join ', ')" -ForegroundColor Gray
    }
}

function Rename-Project {
    param([CommandContext]$context)
    
    $text = $context.GetText()
    $parts = $text -split '\s+', 2
    
    if ($parts.Count -lt 2) {
        Write-Host "‚ùå Usage: proj rename <old-name> <new-name>" -ForegroundColor Red
        Write-Host "   Example: proj rename work office" -ForegroundColor Gray
        return
    }
    
    $oldName = $parts[0]
    $newName = $parts[1]
    
    $data = Get-TaskData
    $project = $data.projects | Where-Object { $_.name -eq $oldName } | Select-Object -First 1
    
    if (-not $project) {
        Write-Host "‚ùå Project '$oldName' not found" -ForegroundColor Red
        Write-Host "   Available projects: $(@($data.projects | ForEach-Object { $_.name }) -join ', ')" -ForegroundColor Gray
        return
    }
    
    # Check for name conflicts
    if ($data.projects | Where-Object { $_.name -eq $newName -and $_.name -ne $oldName }) {
        Write-Host "‚ùå Project '$newName' already exists" -ForegroundColor Red
        return
    }
    
    # Update project name
    $project.name = $newName
    
    # Update all tasks that reference this project
    $updatedTasks = 0
    foreach ($task in $data.tasks) {
        if ($task.project -eq $oldName) {
            $task.project = $newName
            $updatedTasks++
        }
    }
    
    # Update context if it matches
    if ($global:CurrentContext -eq $oldName) {
        $global:CurrentContext = $newName
        $data.currentContext = $newName
    }
    
    Save-TaskData $data
    Write-Host "‚úÖ Renamed project '$oldName' to '$newName'" -ForegroundColor Green
    if ($updatedTasks -gt 0) {
        Write-Host "   Updated $updatedTasks task$(if($updatedTasks -ne 1){'s'})" -ForegroundColor Gray
    }
}

function Archive-Project {
    param([CommandContext]$context)
    
    $projectName = $context.GetText().Trim()
    
    if ([string]::IsNullOrWhiteSpace($projectName)) {
        Write-Host "‚ùå Usage: proj archive <project-name>" -ForegroundColor Red
        Write-Host "   Example: proj archive oldwork" -ForegroundColor Gray
        return
    }
    
    $data = Get-TaskData
    $project = $data.projects | Where-Object { $_.name -eq $projectName } | Select-Object -First 1
    
    if (-not $project) {
        Write-Host "‚ùå Project '$projectName' not found" -ForegroundColor Red
        return
    }
    
    if ($project.isArchived) {
        Write-Host "‚ö†Ô∏è  Project '$projectName' is already archived" -ForegroundColor Yellow
        return
    }
    
    # Check for pending tasks
    $pendingTasks = @($data.tasks | Where-Object { $_.project -eq $projectName -and $_.status -eq 'pending' })
    
    if ($pendingTasks.Count -gt 0) {
        Write-Host "‚ö†Ô∏è  Project '$projectName' has $($pendingTasks.Count) pending task$(if($pendingTasks.Count -ne 1){'s'})" -ForegroundColor Yellow
        $confirm = Read-Host "Archive anyway? This will hide the project but keep tasks (y/N)"
        if ($confirm.ToLower() -ne 'y') {
            Write-Host "Archive cancelled" -ForegroundColor Gray
            return
        }
    }
    
    # Archive the project
    $project.isArchived = $true
    $project.archivedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    
    # Clear context if it matches
    if ($global:CurrentContext -eq $projectName) {
        $global:CurrentContext = 'inbox'
        $data.currentContext = 'inbox'
    }
    
    Save-TaskData $data
    Write-Host "‚úÖ Archived project '$projectName'" -ForegroundColor Green
    Write-Host "   Use 'proj list --archived' to view archived projects" -ForegroundColor Gray
}

function Delete-Project {
    param([CommandContext]$context)
    
    $projectName = $context.GetText().Trim()
    
    if ([string]::IsNullOrWhiteSpace($projectName)) {
        Write-Host "‚ùå Usage: proj delete <project-name>" -ForegroundColor Red
        Write-Host "   Example: proj delete tempproject" -ForegroundColor Gray
        return
    }
    
    $data = Get-TaskData
    $project = $data.projects | Where-Object { $_.name -eq $projectName } | Select-Object -First 1
    
    if (-not $project) {
        Write-Host "‚ùå Project '$projectName' not found" -ForegroundColor Red
        return
    }
    
    # Prevent deletion of default projects
    if ($projectName -in @('inbox', 'personal', 'work')) {
        Write-Host "‚ùå Cannot delete default project '$projectName'" -ForegroundColor Red
        return
    }
    
    # Count associated data
    $tasks = @($data.tasks | Where-Object { $_.project -eq $projectName })
    $pendingTasks = @($tasks | Where-Object { $_.status -eq 'pending' })
    $timeLogs = @($data.timelogs | Where-Object { $_.project -eq $projectName })
    
    # Show impact
    Write-Host "‚ö†Ô∏è  Deleting project '$projectName' will:" -ForegroundColor Yellow
    if ($tasks.Count -gt 0) {
        Write-Host "   ‚Ä¢ Delete $($tasks.Count) task$(if($tasks.Count -ne 1){'s'}) ($($pendingTasks.Count) pending)" -ForegroundColor Yellow
    }
    if ($timeLogs.Count -gt 0) {
        Write-Host "   ‚Ä¢ Delete $($timeLogs.Count) time log$(if($timeLogs.Count -ne 1){'s'})" -ForegroundColor Yellow
    }
    
    $confirm = Read-Host "Are you sure? This cannot be undone (y/N)"
    if ($confirm.ToLower() -ne 'y') {
        Write-Host "Deletion cancelled" -ForegroundColor Gray
        return
    }
    
    # Delete associated data
    $data.tasks = @($data.tasks | Where-Object { $_.project -ne $projectName })
    $data.timelogs = @($data.timelogs | Where-Object { $_.project -ne $projectName })
    
    # Delete project
    $data.projects = @($data.projects | Where-Object { $_.name -ne $projectName })
    
    # Clear context if it matches
    if ($global:CurrentContext -eq $projectName) {
        $global:CurrentContext = 'inbox'
        $data.currentContext = 'inbox'
    }
    
    Save-TaskData $data
    Write-Host "‚úÖ Deleted project '$projectName' and all associated data" -ForegroundColor Green
}

function Show-ProjectStats {
    param($context)
    $projectName = $context.GetText()
    $data = Get-TaskData
    
    $projectTasks = $data.tasks | Where-Object { $_.project -eq $projectName }
    $completed = $projectTasks | Where-Object { $_.completed }
    $pending = $projectTasks | Where-Object { -not $_.completed }
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Blue
    Write-Host "  ‚ïë                   PROJECT: @$($projectName.ToUpper().PadRight(40))‚ïë" -ForegroundColor Blue
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Blue
    
    Write-Host "`n  üìä STATISTICS" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  Total tasks:     $($projectTasks.Count)" -ForegroundColor White
    Write-Host "  Completed:       $($completed.Count)" -ForegroundColor Green
    Write-Host "  Pending:         $($pending.Count)" -ForegroundColor Red
    
    if ($projectTasks.Count -gt 0) {
        $percent = [math]::Round(($completed.Count / $projectTasks.Count) * 100, 1)
        Write-Host "  Progress:        $percent%" -ForegroundColor Cyan
    }
    
    Write-Host ""
}

function Update-SmartTask {
    param($context)
    $text = $context.GetText().Trim()
    if (-not $text) {
    Write-Host "Usage: update <id> [@project] [p1|p2|p3] [due:<date>] [#tags] <new text>" -ForegroundColor Yellow
        return
    }
    # Split first token as ID(s), rest as update tokens
    $parts = $text -split '\s+', 2
    if ($parts.Count -lt 1) { Write-Host "Usage: update <id> ..." -ForegroundColor Yellow; return }
    $idPart = $parts[0]
    $rest = if ($parts.Count -gt 1) { $parts[1] } else { '' }
    
    if ([string]::IsNullOrWhiteSpace($rest)) {
        Edit-TaskInteractive -IdText $idPart
        Show-RichAgenda
    } else {
        $parsed = @{ Id = $idPart; Text = $rest }
        Update-Task -parsed $parsed
        Show-RichAgenda
    }
}

function Edit-TaskInteractive {
    param([string]$IdText)
    $data = Get-TaskData
    $ids = Resolve-TaskIds -inputString $IdText
    if ($ids.Count -ne 1) { Write-Host "Interactive edit requires exactly one task ID" -ForegroundColor Yellow; return }
    $task = $data.tasks | Where-Object { $_.id -eq $ids[0] } | Select-Object -First 1
    if (-not $task) { Write-Host "Task not found" -ForegroundColor Red; return }
    
    Write-Host "Editing task #$($task.id)" -ForegroundColor Cyan
    $newText = Read-Host ("Text [{0}]" -f $task.text)
    $newProj = Read-Host ("Project [{0}]" -f (if($task.project){$task.project}else{'(none)'}))
    $newPri  = Read-Host ("Priority (0-3) [{0}]" -f (if($task.priority){$task.priority}else{0}))
    $newDue  = Read-Host ("Due (YYYY-MM-DD/today/yesterday/none) [{0}]" -f (if($task.due){$task.due}else{'(none)'}))
    $newTags = Read-Host ("Tags (comma-separated) [{0}]" -f (if($task.tags){$task.tags -join ', '}else{''}))
    
    if ($newText) { $task.text = $newText }
    if ($newProj) {
        if ($newProj -ne '(none)') {
            $p = Find-Project -query $newProj -Interactive:$false
            if ($p) { $task.project = $p.name } else { Write-Host "Unknown project: $newProj (keeping current)" -ForegroundColor Yellow }
        } else { $task.project = $null }
    }
    if ($newPri -match '^[0-3]$') { $task.priority = [int]$newPri }
    if ($newDue) {
        if ($newDue -match '^(?i)none$') { $task.due = $null }
        else {
            $pd = Parse-NaturalDate -input $newDue
            if ($pd) { $task.due = $pd } else { Write-Host "Invalid due date; keeping current" -ForegroundColor Yellow }
        }
    }
    if ($newTags -ne $null) {
        $trimmed = $newTags.Trim()
        if ($trimmed) { $task.tags = @($trimmed -split '\s*,\s*') } else { $task.tags = @() }
    }
    Save-TaskData $data
    Write-Host "Saved changes for #$($task.id)" -ForegroundColor Green
}

function Add-TaskNote {
    param($context)
    $noteText = $context.GetText()
    
    Write-Host "`n  üìù Note added: '$noteText'" -ForegroundColor Cyan
    Write-Host "  (Note system not fully implemented)" -ForegroundColor Yellow
}

function Postpone-Task {
    param($context)
    $text = $context.GetText()
    if (-not $text) { Write-Host "Usage: postpone <id> <+Nd|tomorrow|YYYY-MM-DD>" -ForegroundColor Yellow; return }
    $parts = $text -split '\s+', 2
    if ($parts.Count -lt 2) { Write-Host "Usage: postpone <id> <+Nd|tomorrow|YYYY-MM-DD>" -ForegroundColor Yellow; return }
    $ids = Resolve-TaskIds -inputString $parts[0]
    if ($ids.Count -eq 0) { Write-Host "Invalid task id" -ForegroundColor Red; return }
    $delta = $parts[1]
    $data = Get-TaskData
    foreach ($id in $ids) {
        $task = $data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1
        if (-not $task) { continue }
        $base = if ($task.due) { [datetime]$task.due } else { (Get-Date).Date }
        $newDue = $null
        if ($delta -match '^\+(\d+)d$') { $newDue = $base.AddDays([int]$matches[1]) }
        elseif ($delta -match '^(?i)tomorrow$') { $newDue = (Get-Date).Date.AddDays(1) }
        else { try { $newDue = [datetime]::ParseExact($delta,'yyyy-MM-dd',$null) } catch { $newDue = $null } }
        if ($newDue) { $task.due = $newDue.ToString('yyyy-MM-dd'); Write-Host "Postponed #$id to $($task.due)" -ForegroundColor Yellow }
    }
    Save-TaskData $data
    Show-RichAgenda
}

function Move-Task {
    param($context)
    $text = $context.GetText()
    if (-not $text) { Write-Host "Usage: move <id> @project" -ForegroundColor Yellow; return }
    $parts = $text -split '\s+', 2
    if ($parts.Count -lt 2 -or -not ($parts[1] -match '^@(.+)$')) { Write-Host "Usage: move <id> @project" -ForegroundColor Yellow; return }
    $ids = Resolve-TaskIds -inputString $parts[0]
    if ($ids.Count -eq 0) { Write-Host "Invalid task id" -ForegroundColor Red; return }
    $projName = $matches[1]
    $proj = Find-Project -query $projName -Interactive:$false
    if (-not $proj) { Write-Host "Unknown project: $projName" -ForegroundColor Red; return }
    $data = Get-TaskData
    foreach ($id in $ids) {
        $task = $data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1
        if ($task) { $task.project = $proj.name; Write-Host "Moved #$id to @$($proj.name)" -ForegroundColor Yellow }
    }
    Save-TaskData $data
    Show-ProjectDashboard
}

function Duplicate-Task {
    param($context)
    $text = $context.GetText()
    if (-not $text) { Write-Host "Usage: duplicate <id> [new text] [+Nd]" -ForegroundColor Yellow; return }
    $parts = $text -split '\s+', 3
    $id = (Resolve-TaskIds -inputString $parts[0]) | Select-Object -First 1
    if (-not $id) { Write-Host "Invalid task id" -ForegroundColor Red; return }
    $data = Get-TaskData
    $orig = $data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1
    if (-not $orig) { Write-Host "Task #$id not found" -ForegroundColor Red; return }
    $newId = Get-NextTaskId $data
    $copy = @{}
    $orig.PSObject.Properties | ForEach-Object { if ($_.Name -ne 'id' -and $_.Name -ne 'completed') { $copy[$_.Name] = $_.Value } }
    $copy.id = $newId
    $copy.status = 'pending'
    $newText = if ($parts.Count -gt 1) { $parts[1] } else { '' }
    $maybeOffset = if ($parts.Count -gt 2) { $parts[2] } else { '' }
    if ($newText) { $copy.text = $newText }
    if ($maybeOffset -match '^\+(\d+)d$') {
        if ($copy.due) { $copy.due = ([datetime]$copy.due).AddDays([int]$matches[1]).ToString('yyyy-MM-dd') }
    }
    $data.tasks += $copy
    Save-TaskData $data
    Write-Host "Duplicated #$id -> #$newId" -ForegroundColor Green
    Show-AllTasks
}

function Start-Timer {
    param($context)
    
    $project = if ($context) { $context.GetArg('project', $global:CurrentContext) } else { $global:CurrentContext }
    if (-not $project) { $project = 'inbox' }
    
    $description = if ($context) { $context.GetArg('desc', '') } else { '' }
    if (-not $description) {
        # Avoid prompt in non-interactive mode
        try { [ConfigManager]::Load() } catch {}
        $cfg = $null; try { $cfg = [ConfigManager]::Config } catch {}
        $nonInteractive = $false
        try { if ($cfg -and $cfg.Behavior) { $nonInteractive = [bool]$cfg.Behavior.NonInteractive } } catch {}
        if (-not $nonInteractive) {
            $description = Read-Host "Timer description (optional)"
        }
    }
    
    $data = Get-TaskData
    if (-not (Get-Variable -Name SessionTimerLogs -Scope Global -ErrorAction SilentlyContinue)) { $global:SessionTimerLogs = @() }
    if (-not ($data.PSObject.Properties['timer'])) { Add-Member -InputObject $data -MemberType NoteProperty -Name timer -Value @{} }
    
    # Stop existing timer if running
    if ($data.timer.active) {
        Stop-Timer -silent
    }
    
    $data.timer = @{
        active = $true
        project = $project
        description = $description
        startTime = Get-Date
        startTimeString = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    }
    
    Save-TaskData $data -NoUndo
    
    Write-Host "‚è±Ô∏è  Timer started for project '$project'" -ForegroundColor Green
    if ($description) {
        Write-Host "   Description: $description" -ForegroundColor Gray
    }
    Write-Host "   Started at: $($data.timer.startTimeString)" -ForegroundColor Gray
}

function Stop-Timer {
    param([switch]$silent)
    
    $data = Get-TaskData
    
    if (-not $data.timer -or -not $data.timer.active) {
        if (-not $silent) {
            Write-Host "No active timer" -ForegroundColor Yellow
        }
        return
    }
    
    $endTime = Get-Date
    $startTime = [DateTime]$data.timer.startTime
    $duration = $endTime - $startTime
    $minutes = [Math]::Round($duration.TotalMinutes, 1)
    
    # Build session-only time record (do not persist to timelogs)
    $timeLog = @{
        project = $data.timer.project
        description = $data.timer.description
        date = $endTime.ToString("yyyy-MM-dd")
        startTime = $data.timer.startTimeString
        endTime = $endTime.ToString("yyyy-MM-dd HH:mm:ss")
        minutes = $minutes
        duration = "$($duration.Hours)h $($duration.Minutes)m"
        id = [System.Guid]::NewGuid().ToString()
    }
    # Track only for this session (not persisted, not included in reports)
    if (-not (Get-Variable -Name SessionTimerLogs -Scope Global -ErrorAction SilentlyContinue)) { $global:SessionTimerLogs = @() }
    $global:SessionTimerLogs += $timeLog
    
    # Clear timer
    $data.timer = @{ active = $false }
    
    # Do not persist session timer entries to timelogs or CSV
    Save-TaskData $data -NoUndo
    
    if (-not $silent) {
        Write-Host "‚è±Ô∏è  Timer stopped" -ForegroundColor Green
        Write-Host "   Project: $($timeLog.project)" -ForegroundColor Gray
        Write-Host "   Duration: $($timeLog.duration) ($minutes minutes)" -ForegroundColor Gray
        Write-Host "   Time logged successfully" -ForegroundColor Green
    }
}

function Show-TimerStatus {
    $data = Get-TaskData
    
    Write-Host "`n‚è±Ô∏è  TIMER STATUS" -ForegroundColor Yellow
    
    if (-not $data.timer -or -not $data.timer.active) {
        Write-Host "  No active timer" -ForegroundColor Gray
        Write-Host "`n  Start timer with: timer start [project] [description]" -ForegroundColor Gray
        return
    }
    
    $startTime = [DateTime]$data.timer.startTime
    $currentTime = Get-Date
    $elapsed = $currentTime - $startTime
    
    Write-Host "  Status: RUNNING" -ForegroundColor Green
    Write-Host "  Project: $($data.timer.project)" -ForegroundColor White
    if ($data.timer.description) {
        Write-Host "  Description: $($data.timer.description)" -ForegroundColor Gray
    }
    Write-Host "  Started: $($data.timer.startTimeString)" -ForegroundColor Gray
    Write-Host "  Elapsed: $($elapsed.Hours)h $($elapsed.Minutes)m $($elapsed.Seconds)s" -ForegroundColor Cyan
    
    Write-Host "`n  Stop timer with: timer stop" -ForegroundColor Gray
}

function Show-ProfessionalReport {
    param($context)
    
    $period = if ($context) { $context.GetArg('period', 'week') } else { 'week' }
    $data = Get-TaskData
    $today = (Get-Date).Date
    
    # Calculate date range
    $startDate = switch ($period.ToLower()) {
        'day' { $today }
        'week' { $today.AddDays(-[int]$today.DayOfWeek) }
        'month' { $today.AddDays(-$today.Day + 1) }
        'quarter' { 
            $quarter = [Math]::Ceiling($today.Month / 3)
            $startMonth = ($quarter - 1) * 3 + 1
            (Get-Date -Year $today.Year -Month $startMonth -Day 1).Date
        }
        default { $today.AddDays(-7) }
    }
    
    $endDate = $today.AddDays(1)
    
    # Task completion statistics
    $completedTasks = @($data.tasks | Where-Object { 
        $_.done -and $_.completed -and 
        [datetime]$_.completed -ge $startDate -and [datetime]$_.completed -lt $endDate
    })
    
    $totalTasks = @($data.tasks | Where-Object { 
        [datetime]$_.created -ge $startDate -and [datetime]$_.created -lt $endDate
    })
    
    # Time tracking
    $timeLogs = @($data.timelogs | Where-Object {
        [datetime]$_.date -ge $startDate -and [datetime]$_.date -lt $endDate
    })
    
    $totalMinutes = ($timeLogs | Measure-Object minutes -Sum).Sum
    $totalHours = [Math]::Round($totalMinutes / 60, 1)
    $avgSession = if ($timeLogs.Count -gt 0) { [Math]::Round($totalMinutes / $timeLogs.Count, 1) } else { 0 }

    # Overview tables
    $periodRows = @(); $periodRows += , @('Start', $startDate.ToString('yyyy-MM-dd')); $periodRows += , @('End', $today.ToString('yyyy-MM-dd'))
    Format-StyledTable -Headers @('Metric','Value') -DataRows $periodRows -Title ("üìà PROFESSIONAL REPORT (" + $period + ")")

    $taskRows = @(); $taskRows += , @('Tasks Created', $totalTasks.Count); $taskRows += , @('Tasks Completed', $completedTasks.Count); $taskRows += , @('Completion Rate', (if ($totalTasks.Count -gt 0) { [Math]::Round(($completedTasks.Count / $totalTasks.Count) * 100, 1) } else { 0 }).ToString() + '%')
    Format-StyledTable -Headers @('Task Metric','Value') -DataRows $taskRows -Title 'TASK COMPLETION'

    $timeRows = @(); $timeRows += , @('Total Hours', $totalHours); $timeRows += , @('Time Entries', $timeLogs.Count); $timeRows += , @('Avg Session (min)', $avgSession)
    Format-StyledTable -Headers @('Time Metric','Value') -DataRows $timeRows -Title 'TIME TRACKING'

    # Project breakdown
    $projectTime = $timeLogs | Group-Object project | ForEach-Object {
        [PSCustomObject]@{
            Project = $_.Name
            Hours = [Math]::Round(($_.Group | Measure-Object minutes -Sum).Sum / 60, 1)
            Sessions = $_.Count
        }
    } | Sort-Object Hours -Descending | Select-Object -First 5
    
    if ($projectTime) {
        $rows = @(); foreach ($p in $projectTime) { $rows += , @($p.Project, $p.Sessions, $p.Hours) }
        Format-StyledTable -Headers @('Project','Entries','Total Hours') -DataRows $rows -Title 'TOP PROJECTS (by time)'
    }
}

function Show-DetailedReport {
    param($context)
    
    $data = Get-TaskData
    $today = (Get-Date).Date
    
    # Overall statistics
    $allTasks = $data.tasks
    $completedTasks = @($allTasks | Where-Object { $_.done })
    $pendingTasks = @($allTasks | Where-Object { -not $_.done })
    $rate = if ($allTasks.Count -gt 0) { [Math]::Round(($completedTasks.Count / $allTasks.Count) * 100, 1) } else { 0 }
    $overall = @();
    $overall += , @('Total Tasks', $allTasks.Count)
    $overall += , @('Completed', $completedTasks.Count)
    $overall += , @('Pending', $pendingTasks.Count)
    $overall += , @('Completion Rate', "$rate%")
    Format-StyledTable -Headers @('Metric','Value') -DataRows $overall -Title 'üìä OVERALL STATISTICS'

    # Priority breakdown
    $priorityStats = $allTasks | Group-Object { if ($_.priority) { "p$($_.priority)" } else { "none" } } | Sort-Object Name
    $priRows = @()
    foreach ($grp in $priorityStats) {
        $c = @($grp.Group | Where-Object { $_.done }).Count
        $t = $grp.Count
        $r = if ($t -gt 0) { [Math]::Round(($c / $t) * 100, 1) } else { 0 }
        $priRows += , @($grp.Name, "$c/$t", "$r%")
    }
    if ($priRows.Count -gt 0) { Format-StyledTable -Headers @('Priority','Completed/Total','Rate') -DataRows $priRows -Title 'üéØ PRIORITY BREAKDOWN' }

    # Project performance
    $projPerf = $allTasks | Where-Object { $_.project } | Group-Object project | ForEach-Object {
        $c = @($_.Group | Where-Object { $_.done }).Count
        $t = $_.Count
        $r = if ($t -gt 0) { [Math]::Round(($c / $t) * 100, 1) } else { 0 }
        [PSCustomObject]@{ Project = $_.Name; Total = $t; Completed = $c; Rate = $r }
    } | Sort-Object Rate -Descending
    if ($projPerf) {
        $rows = @()
        foreach ($p in ($projPerf | Select-Object -First 10)) { $rows += , @($p.Project, $p.Completed, $p.Total, "$($p.Rate)%") }
        Format-StyledTable -Headers @('Project','Completed','Total','Rate') -DataRows $rows -Title 'üìÅ PROJECT PERFORMANCE'
    }

    # Overdue analysis
    $overdueTasks = @($pendingTasks | Where-Object { $_.due -and [datetime]$_.due -lt $today })
    $overRows = @()
    $overRows += , @('Overdue Count', $overdueTasks.Count)
    $oldestOverdue = $null
    if ($overdueTasks.Count -gt 0) {
        $oldestOverdue = $overdueTasks | Sort-Object due | Select-Object -First 1
        if ($oldestOverdue) { $daysPast = ($today - [datetime]$oldestOverdue.due).Days; $overRows += , @('Oldest (days)', $daysPast) }
    }
    Format-StyledTable -Headers @('Metric','Value') -DataRows $overRows -Title '‚è∞ OVERDUE ANALYSIS'

    # Productivity trends (last 30 days)
    $last30Days = $today.AddDays(-30)
    $recentCompletions = @($completedTasks | Where-Object { $_.completed -and [datetime]$_.completed -ge $last30Days })
    $trendRows = @(); $trendRows += , @('Recent Completions', $recentCompletions.Count); $trendRows += , @('Daily Average', [Math]::Round($recentCompletions.Count / 30, 1))
    Format-StyledTable -Headers @('Trend','Value') -DataRows $trendRows -Title 'üìà PRODUCTIVITY TRENDS (30 days)'

    # Time analysis
    $totalTimeMinutes = ($data.timelogs | Measure-Object minutes -Sum).Sum
    $totalTimeHours = [Math]::Round($totalTimeMinutes / 60, 1)
    $timeRows = @();
    $timeRows += , @('Total Logged', "${totalTimeHours} h")
    $timeRows += , @('Time Entries', ($data.timelogs ? $data.timelogs.Count : 0))
    if ($data.timelogs -and $data.timelogs.Count -gt 0) { $avgSession = [Math]::Round($totalTimeMinutes / $data.timelogs.Count, 1); $timeRows += , @('Avg Session', "$avgSession min") }
    Format-StyledTable -Headers @('Time','Value') -DataRows $timeRows -Title '‚è± TIME ANALYSIS'
}

function Show-Templates {
    Write-Host "`n  üìã Task Templates" -ForegroundColor Green
    Write-Host "  (Template system not implemented)" -ForegroundColor Gray
}

function Add-RecurringTask {
    param($context)
    $recurText = $context.GetText()
    
    Write-Host "`n  üîÑ Recurring task: '$recurText'" -ForegroundColor Magenta
    Write-Host "  (Recurring tasks not implemented)" -ForegroundColor Gray
}

function Show-RecurringTasks {
    Write-Host "`n  üîÑ Recurring Tasks" -ForegroundColor Magenta
    Write-Host "  (Recurring system not implemented)" -ForegroundColor Gray
}

function Add-SmartDependency {
    param($context)
    $text = $context.GetText()
    $ids = $text -split '\s+'
    if ($ids.Count -lt 2) { Write-Host "Usage: dep add <task> <depends-on>" -ForegroundColor Yellow; return }
    $data = Get-TaskData
    $a = (Resolve-TaskIds -inputString $ids[0]) | Select-Object -First 1
    $b = (Resolve-TaskIds -inputString $ids[1]) | Select-Object -First 1
    if (-not $a -or -not $b) { Write-Host "Invalid task IDs" -ForegroundColor Red; return }
    $task = $data.tasks | Where-Object { $_.id -eq $a } | Select-Object -First 1
    if (-not $task) { Write-Host "Task #$a not found" -ForegroundColor Red; return }
    if (-not $task.depends) { $task.depends = @() }
    # Prevent self-dependency and simple cycles
    if ($a -eq $b) { Write-Host "Cannot depend on itself" -ForegroundColor Red; return }
    # Detect cycle: if b (directly or indirectly) depends on a
    function _HasPath($start, $target, $visited) {
        if ($visited -contains $start) { return $false }
        $visited += $start
        $t = $data.tasks | Where-Object { $_.id -eq $start } | Select-Object -First 1
        if (-not $t -or -not $t.depends) { return $false }
        foreach ($n in $t.depends) {
            if ($n -eq $target) { return $true }
            if (_HasPath $n $target $visited) { return $true }
        }
        return $false
    }
    if (_HasPath $b $a @()) { Write-Host "Adding this dependency would create a cycle" -ForegroundColor Red; return }
    if ($task.depends -notcontains $b) { $task.depends += $b }
    Update-BlockedStatus -data $data
    Save-TaskData $data
    Write-Host "Added dependency: #$a depends on #$b" -ForegroundColor Green
}

function Remove-SmartDependency {
    param($context)
    $text = $context.GetText()
    $ids = $text -split '\s+'
    if ($ids.Count -lt 2) { Write-Host "Usage: dep remove <task> <depends-on>" -ForegroundColor Yellow; return }
    $data = Get-TaskData
    $a = (Resolve-TaskIds -inputString $ids[0]) | Select-Object -First 1
    $b = (Resolve-TaskIds -inputString $ids[1]) | Select-Object -First 1
    if (-not $a -or -not $b) { Write-Host "Invalid task IDs" -ForegroundColor Red; return }
    $task = $data.tasks | Where-Object { $_.id -eq $a } | Select-Object -First 1
    if (-not $task -or -not $task.depends) { Write-Host "No such dependency found" -ForegroundColor Yellow; return }
    $task.depends = @($task.depends | Where-Object { $_ -ne $b })
    Update-BlockedStatus -data $data
    Save-TaskData $data
    Write-Host "Removed dependency: #$a no longer depends on #$b" -ForegroundColor Green
}

function Show-Dependencies {
    param($context)
    $text = if ($context) { $context.GetText() } else { '' }
    if (-not $text) { Write-Host "Usage: dep show <task>" -ForegroundColor Yellow; return }
    $data = Get-TaskData
    $id = (Resolve-TaskIds -inputString $text) | Select-Object -First 1
    if (-not $id) { Write-Host "Invalid task ID" -ForegroundColor Red; return }
    $task = $data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1
    if (-not $task) { Write-Host "Task #$id not found" -ForegroundColor Red; return }
    $rows = @()
    $depends = if ($task.depends) { $task.depends } else { @() }
    foreach ($d in $depends) {
        $t = $data.tasks | Where-Object { $_.id -eq $d } | Select-Object -First 1
        $rows += , @($d, (if($t){$t.text}else{'(missing)'}))
    }
    if ($rows.Count -eq 0) { $rows = @(@('(none)','')) }
    Format-StyledTable -Headers @('Depends On','Text') -DataRows $rows -Title ("DEPENDENCIES FOR #" + $id)
}

function Show-DependencyGraph {
    $data = Get-TaskData
    $rows = @()
    foreach ($t in $data.tasks) {
        if ($t.depends -and $t.depends.Count -gt 0) {
            $rows += , @($t.id, ($t.depends -join ', '), $t.text)
        }
    }
    if ($rows.Count -eq 0) { $rows = @(@('(none)','', '')) }
    Format-StyledTable -Headers @('Task','# Depends','Text') -DataRows $rows -Title 'DEPENDENCY GRAPH (simple)'
}

function Set-SmartFocus {
    param($context)
    $focusText = $context.GetText()
    
    Write-Host "`n  üéØ Focus set: '$focusText'" -ForegroundColor Yellow
    Write-Host "  (Focus system not implemented)" -ForegroundColor Gray
}

function Show-ContextInfo {
    Write-Host "`n  ‚ÑπÔ∏è  Current Context" -ForegroundColor Cyan
    Write-Host "  (Context system not implemented)" -ForegroundColor Gray
}

function Show-BurndownChart {
    $data = Get-TaskData
    $today = (Get-Date).Date
    
    Write-Host "`nüìâ BURNDOWN CHART (Last 14 Days)" -ForegroundColor Green
    Write-Host "=" * 50 -ForegroundColor Gray
    
    # Calculate burndown data for last 14 days
    $burndownData = @()
    for ($i = 13; $i -ge 0; $i--) {
        $date = $today.AddDays(-$i)
        $dateStr = $date.ToString("yyyy-MM-dd")
        
        # Tasks remaining at end of day
        $remaining = @($data.tasks | Where-Object { 
            [datetime]$_.created -le $date.AddDays(1) -and
            (-not $_.done -or ($_.completed -and [datetime]$_.completed -gt $date.AddDays(1)))
        }).Count
        
        # Tasks completed on this day
        $completedToday = @($data.tasks | Where-Object {
            $_.done -and $_.completed -and
            [datetime]$_.completed -ge $date -and [datetime]$_.completed -lt $date.AddDays(1)
        }).Count
        
        $burndownData += [PSCustomObject]@{
            Date = $date
            DateStr = $date.ToString("MM-dd")
            Remaining = $remaining
            Completed = $completedToday
        }
    }
    
    # Find max for scaling
    $maxRemaining = ($burndownData | Measure-Object Remaining -Maximum).Maximum
    $maxCompleted = ($burndownData | Measure-Object Completed -Maximum).Maximum
    
    if ($maxRemaining -eq 0) {
        Write-Host "`nNo task data available for burndown chart" -ForegroundColor Yellow
        return
    }
    
    # Combined chart: Remaining + Completions on one line per date
    Write-Host "`nRemaining | Completions" -ForegroundColor Yellow
    foreach ($point in $burndownData) {
        $remLen = if ($maxRemaining -gt 0) { [Math]::Floor(($point.Remaining / $maxRemaining) * 30) } else { 0 }
        $remBar = "‚ñà" * $remLen + "‚ñë" * (30 - $remLen)
        $remColor = if ($point.Remaining -gt 20) { "Red" } elseif ($point.Remaining -gt 10) { "Yellow" } else { "Green" }

        $compLen = if ($maxCompleted -gt 0) { [Math]::Floor(($point.Completed / $maxCompleted) * 10) } else { 0 }
        $compBar = if ($compLen -gt 0) { "‚ñà" * $compLen } else { "" }

        # Print date, remaining bar+count, and completions bar+count inline
        Write-Host ("{0}: " -f $point.DateStr) -NoNewline -ForegroundColor Gray
        Write-Host $remBar -NoNewline -ForegroundColor $remColor
        Write-Host (" {0} | " -f $point.Remaining) -NoNewline -ForegroundColor Gray
        if ($compBar.Length -gt 0) { Write-Host $compBar -NoNewline -ForegroundColor Cyan }
        Write-Host (" {0}" -f $point.Completed) -ForegroundColor Cyan
    }
    
    # Summary stats
    $totalCompleted = ($burndownData | Measure-Object Completed -Sum).Sum
    $avgCompleted = [Math]::Round($totalCompleted / 14, 1)
    $currentRemaining = $burndownData[-1].Remaining
    
    Write-Host "`nSUMMARY:" -ForegroundColor White
    Write-Host "  Current Backlog: $currentRemaining tasks" -ForegroundColor Gray
    Write-Host "  Completed (14 days): $totalCompleted tasks" -ForegroundColor Green
    Write-Host "  Daily Average: $avgCompleted tasks/day" -ForegroundColor Cyan
    
    # Table summary for quick scan
    $summaryRows = @()
    $summaryRows += , @('Current Backlog', $currentRemaining)
    $summaryRows += , @('Completed (14d)', $totalCompleted)
    $summaryRows += , @('Avg/Day', $avgCompleted)
    Format-StyledTable -Headers @('Metric','Value') -DataRows $summaryRows -Title 'üìâ BURNDOWN SUMMARY'
    
    if ($avgCompleted -gt 0 -and $currentRemaining -gt 0) {
        $daysToComplete = [Math]::Ceiling($currentRemaining / $avgCompleted)
        Write-Host "  Est. completion: $daysToComplete days" -ForegroundColor Yellow
    }
    
    Write-Host "`n" + ("=" * 50) -ForegroundColor Gray
}

function Show-VelocityChart {
    $data = Get-TaskData
    $today = (Get-Date).Date
    
    Write-Host "`nüìà VELOCITY CHART (Last 8 Weeks)" -ForegroundColor Blue
    Write-Host "=" * 50 -ForegroundColor Gray
    
    # Calculate velocity data for last 8 weeks
    $velocityData = @()
    for ($i = 7; $i -ge 0; $i--) {
        $weekStart = $today.AddDays(-$i * 7 - [int]$today.DayOfWeek)
        $weekEnd = $weekStart.AddDays(7)
        
        # Tasks completed during this week
        $completed = @($data.tasks | Where-Object {
            $_.done -and $_.completed -and
            [datetime]$_.completed -ge $weekStart -and [datetime]$_.completed -lt $weekEnd
        }).Count
        
        # Tasks created during this week
        $created = @($data.tasks | Where-Object {
            [datetime]$_.created -ge $weekStart -and [datetime]$_.created -lt $weekEnd
        }).Count
        
        # Story points (using priority as proxy)
        $storyPoints = ($data.tasks | Where-Object {
            $_.done -and $_.completed -and $_.priority -and
            [datetime]$_.completed -ge $weekStart -and [datetime]$_.completed -lt $weekEnd
        } | Measure-Object { $_.priority } -Sum).Sum
        
        $velocityData += [PSCustomObject]@{
            WeekStart = $weekStart
            WeekLabel = "W$($weekStart.ToString('MM-dd'))"
            Completed = $completed
            Created = $created
            StoryPoints = if ($storyPoints) { $storyPoints } else { 0 }
            Net = $completed - $created
        }
    }
    
    # Find max for scaling
    $maxCompleted = ($velocityData | Measure-Object Completed -Maximum).Maximum
    $maxCreated = ($velocityData | Measure-Object Created -Maximum).Maximum
    $maxValue = [Math]::Max($maxCompleted, $maxCreated)
    
    if ($maxValue -eq 0) {
        Write-Host "`nNo velocity data available" -ForegroundColor Yellow
        return
    }
    
    # Display velocity chart
    Write-Host "`nWeekly Completion vs Creation:" -ForegroundColor Yellow
    foreach ($week in $velocityData) {
        $completedBar = if ($maxValue -gt 0) { "‚ñà" * [Math]::Floor(($week.Completed / $maxValue) * 20) } else { "" }
        $createdBar = if ($maxValue -gt 0) { "‚ñë" * [Math]::Floor(($week.Created / $maxValue) * 20) } else { "" }
        
        $netColor = if ($week.Net -gt 0) { "Green" } elseif ($week.Net -eq 0) { "Yellow" } else { "Red" }
        $netIndicator = if ($week.Net -gt 0) { "+" } elseif ($week.Net -eq 0) { "=" } else { "" }
        
        Write-Host "$($week.WeekLabel): " -NoNewline -ForegroundColor White
        Write-Host $completedBar -NoNewline -ForegroundColor Green
        Write-Host $createdBar -NoNewline -ForegroundColor Red
        Write-Host " $($week.Completed)‚úì/$($week.Created)+ " -NoNewline -ForegroundColor Gray
        Write-Host "($netIndicator$($week.Net))" -ForegroundColor $netColor
    }
    
    # Velocity metrics
    $avgCompleted = [Math]::Round(($velocityData | Measure-Object Completed -Average).Average, 1)
    $avgCreated = [Math]::Round(($velocityData | Measure-Object Created -Average).Average, 1)
    $totalStoryPoints = ($velocityData | Measure-Object StoryPoints -Sum).Sum
    $avgStoryPoints = [Math]::Round($totalStoryPoints / 8, 1)
    
    Write-Host "`nVELOCITY METRICS:" -ForegroundColor White
    Write-Host "  Avg Completed/week: $avgCompleted tasks" -ForegroundColor Green
    Write-Host "  Avg Created/week: $avgCreated tasks" -ForegroundColor Yellow
    Write-Host "  Net velocity: $([Math]::Round($avgCompleted - $avgCreated, 1)) tasks/week" -ForegroundColor Cyan
    
    if ($totalStoryPoints -gt 0) {
        Write-Host "  Avg Story Points: $avgStoryPoints points/week" -ForegroundColor Blue
    }
    
    # Table summary
    $velRows = @()
    $velRows += , @('Avg Completed/wk', $avgCompleted)
    $velRows += , @('Avg Created/wk', $avgCreated)
    $velRows += , @('Net Velocity', [Math]::Round($avgCompleted - $avgCreated, 1))
    if ($totalStoryPoints -gt 0) { $velRows += , @('Avg Story Points', $avgStoryPoints) }
    Format-StyledTable -Headers @('Metric','Value') -DataRows $velRows -Title 'üìà VELOCITY SUMMARY'
    
    # Trend analysis
    $recent4Weeks = $velocityData | Select-Object -Last 4
    $earlier4Weeks = $velocityData | Select-Object -First 4
    
    $recentAvg = [Math]::Round(($recent4Weeks | Measure-Object Completed -Average).Average, 1)
    $earlierAvg = [Math]::Round(($earlier4Weeks | Measure-Object Completed -Average).Average, 1)
    
    Write-Host "`nTREND ANALYSIS:" -ForegroundColor White
    if ($recentAvg -gt $earlierAvg) {
        Write-Host "  Velocity trending UP ‚ÜóÔ∏è ($earlierAvg ‚Üí $recentAvg)" -ForegroundColor Green
    } elseif ($recentAvg -eq $earlierAvg) {
        Write-Host "  Velocity stable ‚Üí ($recentAvg)" -ForegroundColor Yellow
    } else {
        Write-Host "  Velocity trending down ‚ÜòÔ∏è ($earlierAvg ‚Üí $recentAvg)" -ForegroundColor Red
    }
    
    Write-Host "`n" + ("=" * 50) -ForegroundColor Gray
}

# === ENHANCED PROJECT MANAGEMENT ===

function Find-Project {
    param(
        [string]$query, 
        [switch]$Interactive = $true,
        [switch]$AllowCreate = $false
    )
    
    if ([string]::IsNullOrWhiteSpace($query)) { 
        return $null 
    }
    
    $data = Get-TaskData
    $query_lower = $query.ToLower().Trim()
    
    # Fast exact match
    $exact = $data.projects | Where-Object { $_.name.ToLower() -eq $query_lower }
    if ($exact) { 
        return $exact[0] 
    }
    
    # Check aliases
    $aliasMatch = $data.projects | Where-Object { 
        $_.aliases -and ($_.aliases | Where-Object { $_.ToLower() -eq $query_lower })
    }
    if ($aliasMatch) { 
        return $aliasMatch[0] 
    }
    
    # Single unambiguous matches
    $startsWith = $data.projects | Where-Object { $_.name.ToLower().StartsWith($query_lower) }
    if ($startsWith.Count -eq 1) { 
        return $startsWith[0] 
    }
    
    $contains = $data.projects | Where-Object { $_.name.ToLower() -match "\b$query_lower" }
    if ($contains.Count -eq 1) { 
        return $contains[0] 
    }
    
    # Initials match
    $initials = $data.projects | Where-Object {
        $words = $_.name -split '\s+'
        $init = ($words | ForEach-Object { $_[0] }) -join ''
        $init.ToLower() -eq $query_lower
    }
    if ($initials.Count -eq 1) { 
        return $initials[0] 
    }
    
    # Special shortcuts
    if ($query_lower -eq '-' -or $query_lower -eq 'last') {
        $lastProj = $data.projects | Where-Object { $_.name -eq $data.lastUsedProject }
        if ($lastProj) { 
            return $lastProj[0] 
        }
    }
    
    # Handle multiple matches
    $allMatches = @()
    $allMatches += $startsWith
    $allMatches += $contains
    $allMatches = $allMatches | Select-Object -Unique | Select-Object -First 8
    
    if ($allMatches.Count -gt 1 -and $Interactive) {
        Write-Host "Multiple projects match '$query':" -ForegroundColor Yellow
        
        for ($i = 0; $i -lt $allMatches.Count; $i++) {
            Write-Host "  $($i+1). $($allMatches[$i].name)" -ForegroundColor Gray
        }
        
        do {
            $choice = Read-Host "Select project [1-$($allMatches.Count), N]"
            
            if ($choice -eq '' -or $choice.ToLower() -eq 'n') { 
                return $null 
            }
            
            if ($choice -match '^\d+$') {
                $index = [int]$choice - 1
                if ($index -ge 0 -and $index -lt $allMatches.Count) {
                    return $allMatches[$index]
                }
            }
            
            Write-Host "Invalid selection. Try again." -ForegroundColor Red
        } while ($true)
    }
    elseif ($allMatches.Count -gt 1 -and -not $Interactive) {
        Write-Host "Multiple projects match '$query':" -ForegroundColor Yellow
        foreach ($m in $allMatches) { Write-Host "  - $($m.name)" -ForegroundColor Gray }
        return $null
    }
    
    # Offer to create if allowed
    if ($AllowCreate -and $Interactive) {
        $response = Read-Host "Project '$query' not found. Create it? (Y/n)"
        if ($response -eq '' -or $response.ToLower() -eq 'y') {
            $newProj = @{ 
                Name = $query
                Fields = @{ description = "Auto-created" }
            }
            Add-Project -parsed $newProj
            return $data.projects | Where-Object { $_.name -eq $query }
        }
    }
    
    return $null
}

function Generate-ProjectAliases {
    param([string]$name, [array]$existingProjects)
    
    $aliases = @()
    $words = $name -split '\s+'
    
    # Collect all existing aliases to avoid conflicts
    $existingAliases = $existingProjects | ForEach-Object { 
        @($_.name.ToLower()) + $_.aliases 
    } | Select-Object -Unique
    
    # Generate potential aliases
    $candidates = @()
    
    # First letter of each word (for multi-word projects)
    if ($words.Count -gt 1) {
        $candidates += ($words | ForEach-Object { $_[0] }) -join ''
    }
    
    # First word
    $firstWord = $words[0].ToLower()
    $candidates += $firstWord
    
    # Progressive abbreviations (a, ac, acm, acme)
    for ($i = 1; $i -le [Math]::Min($firstWord.Length, 4); $i++) {
        $candidates += $firstWord.Substring(0, $i)
    }
    
    # Filter out conflicts and the project name itself
    $candidates = $candidates | Where-Object { 
        $_ -notin $existingAliases -and $_ -ne $name.ToLower() 
    } | Select-Object -Unique
    
    return $candidates
}

function Set-ProjectFocus {
    param([string]$projectQuery)
    
    $project = Find-Project -query $projectQuery -Interactive
    if (-not $project) {
        return
    }
    
    Set-CurrentContext -projectName $project.name
    Show-ProjectDetail -projectQuery $project.name
    
    Write-Host "`nContext set: $($project.name)" -ForegroundColor Green
    Write-Host "New tasks and time logs will default to this project" -ForegroundColor Gray
}

function Clear-ProjectFocus {
    Set-CurrentContext -projectName 'inbox'
    Write-Host "Context cleared - returned to inbox" -ForegroundColor Green
}

function Show-Projects {
    $data = Get-TaskData
    
    Write-Host "`n=== ALL PROJECTS ===" -ForegroundColor Cyan
    
    $data.projects | Sort-Object name | ForEach-Object {
        $contextMarker = if ($_.name -eq $global:CurrentContext) { "* " } else { "  " }
        
        Write-Host "$contextMarker$($_.name)" -NoNewline -ForegroundColor White
        
        if ($_.aliases) {
            Write-Host (" [{0}]" -f ($_.aliases -join ', ')) -NoNewline -ForegroundColor DarkGray
        }
        
        Write-Host
        
        # Show custom fields
        $_.PSObject.Properties | Where-Object { 
            $_.Name -notin @('name', 'description', 'aliases') 
        } | ForEach-Object {
            Write-Host ("     {0}: {1}" -f $_.Name, $_.Value) -ForegroundColor Gray
        }
        
        if ($_.description) {
            Write-Host ("     {0}" -f $_.description) -ForegroundColor Gray
        }
        
        # Show statistics
        $taskCount = @($data.tasks | Where-Object { 
            $_.project -eq $_.name -and $_.status -eq 'pending' 
        }).Count
        
        $timeLogged = ($data.timelogs | Where-Object { 
            $_.project -eq $_.name 
        } | Measure-Object minutes -Sum).Sum
        
        if ($taskCount -gt 0) {
            Write-Host "     Tasks: $taskCount pending" -ForegroundColor DarkYellow
        }
        
        if ($timeLogged -gt 0) {
            $hours = [Math]::Round($timeLogged / 60, 1)
            Write-Host "     Time: $hours hours total" -ForegroundColor DarkGreen
        }
        
        Write-Host
    }
}

function Show-ProjectDetail {
    param([string]$projectQuery)
    
    $project = Find-Project -query $projectQuery -Interactive
    if (-not $project) {
        return
    }
    
    $global:LastShownTaskMap.Clear()
    $localIdCounter = 1
    $data = Get-TaskData
    
    Write-Host "`n=== PROJECT: $($project.name) ===" -ForegroundColor Cyan
    
    # Project metadata
    $project.PSObject.Properties | Where-Object { $_.Name -ne 'name' } | ForEach-Object {
        Write-Host ("  {0}: {1}" -f $_.Name, $_.Value) -ForegroundColor Gray
    }
    
    # Active tasks
    $tasks = $data.tasks | Where-Object { 
        $_.project -eq $project.name -and $_.status -eq 'pending' 
    }
    
    if ($tasks) {
        Write-Host "`n  ACTIVE TASKS:" -ForegroundColor Yellow
        
        foreach ($task in ($tasks | Sort-Object priority, created)) {
            $pri = @("", "!", "!!", "!!!")[$task.priority]
            $priColor = @("White", "Red", "Yellow", "Cyan")[$task.priority]
            
            Write-Host ("    [{0,2}] (#{1}) " -f $localIdCounter, $task.id) -NoNewline -ForegroundColor Gray
            Write-Host "$pri " -NoNewline -ForegroundColor $priColor
            Write-Host $task.text -NoNewline
            
            if ($task.due) {
                $dueDate = [datetime]$task.due
                $days = ($dueDate - (Get-Date).Date).Days
                $dueText = if ($days -lt 0) { "OVERDUE" }
                          elseif ($days -eq 0) { "TODAY" }
                          elseif ($days -eq 1) { "Tomorrow" }
                          else { $dueDate.ToString("MMM d") }
                
                $dueColor = if ($days -lt 0) { "Red" }
                           elseif ($days -le 1) { "Yellow" }
                           else { "Gray" }
                
                Write-Host " [$dueText]" -NoNewline -ForegroundColor $dueColor
            }
            
            if ($task.estimatedMinutes) {
                $est = if ($task.estimatedMinutes -lt 60) { 
                    "$($task.estimatedMinutes)m" 
                } else { 
                    "$([Math]::Round($task.estimatedMinutes/60,1))h" 
                }
                Write-Host " ~$est" -NoNewline -ForegroundColor DarkGray
            }
            
            Write-Host
            Set-LastShownEntry -LocalId $localIdCounter -TaskId $task.id
            $localIdCounter++
        }
    }
    
    # Recent time logs
    $logs = $data.timelogs | Where-Object { 
        $_.project -eq $project.name 
    } | Sort-Object date, time | Select-Object -Last 5
    
    if ($logs) {
        Write-Host "`n  RECENT TIME:" -ForegroundColor Yellow
        foreach ($log in $logs) {
            $hours = [Math]::Round($log.minutes / 60, 1)
            Write-Host "    $($log.date) $($log.time): ${hours}h" -NoNewline -ForegroundColor Gray
            if ($log.notes) { 
                Write-Host " - $($log.notes)" -ForegroundColor DarkGray 
            } else { 
                Write-Host 
            }
        }
    }
    
    # Project statistics
    $totalTasks = @($tasks).Count
    $totalMinutes = ($data.timelogs | Where-Object { 
        $_.project -eq $project.name 
    } | Measure-Object minutes -Sum).Sum
    $totalHours = [Math]::Round($totalMinutes / 60, 1)
    
    $weekStart = (Get-Date).Date.AddDays(-[int](Get-Date).DayOfWeek)
    $weekMinutes = ($data.timelogs | Where-Object { 
        $_.project -eq $project.name -and [datetime]$_.date -ge $weekStart 
    } | Measure-Object minutes -Sum).Sum
    $weekHours = [Math]::Round($weekMinutes / 60, 1)
    
    Write-Host "`n  PROJECT SUMMARY:" -ForegroundColor Yellow
    Write-Host "    Active Tasks: $totalTasks" -ForegroundColor Gray
    Write-Host "    This Week: $weekHours hours" -ForegroundColor Gray
    Write-Host "    Total Time: $totalHours hours" -ForegroundColor Gray
}

function Add-ProjectGuided {
    param(
        [string]$projectName = ""
    )
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor DarkGray
    Write-Host "  ‚ïë                    NEW PROJECT WIZARD                      ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor DarkGray
    Write-Host ""
    
    # Gather project information with prompts and validation
    if ([string]::IsNullOrWhiteSpace($projectName)) {
        Write-Host "  üìù Project Name: " -NoNewline -ForegroundColor Cyan
        $projectName = Read-Host
        if ([string]::IsNullOrWhiteSpace($projectName)) {
            Write-Host "  ‚ùå Project name cannot be empty" -ForegroundColor Red
            Pause-Screen
            return
        }
    }
    
    # Check if project already exists
    $data = Get-TaskData
    if ($data.projects | Where-Object { $_.name -eq $projectName }) {
        Write-Host "  ‚ö†Ô∏è  Project '$projectName' already exists" -ForegroundColor Yellow
        Pause-Screen
        return
    }
    
    Write-Host "  üìÑ Description (optional): " -NoNewline -ForegroundColor Cyan
    $description = Read-Host
    
    Write-Host "  üéØ Icon/Emoji (optional): " -NoNewline -ForegroundColor Cyan
    $icon = Read-Host
    if ([string]::IsNullOrWhiteSpace($icon)) { $icon = "üìÅ" }
    
    # PMC Fields
    Write-Host "`n  === PMC INTEGRATION FIELDS ===" -ForegroundColor Yellow
    
    Write-Host "  üè∑Ô∏è  ID1 (Primary ID): " -NoNewline -ForegroundColor Cyan
    $id1 = Read-Host
    
    Write-Host "  üè∑Ô∏è  ID2 (Secondary ID): " -NoNewline -ForegroundColor Cyan
    $id2 = Read-Host
    
    Write-Host "  üìÅ Project Folder Path: " -NoNewline -ForegroundColor Cyan
    $projFolder = Read-Host
    
    Write-Host "  üìÖ Assigned Date (YYYY-MM-DD): " -NoNewline -ForegroundColor Cyan
    $assignedDate = Read-Host
    
    Write-Host "  ‚è∞ Due Date (YYYY-MM-DD): " -NoNewline -ForegroundColor Cyan
    $dueDate = Read-Host
    
    Write-Host "  üìä BF Date (YYYY-MM-DD): " -NoNewline -ForegroundColor Cyan
    $bfDate = Read-Host
    
    Write-Host "  üë§ CAA Name: " -NoNewline -ForegroundColor Cyan
    $caaName = Read-Host
    
    Write-Host "  üìã Request Name: " -NoNewline -ForegroundColor Cyan
    $requestName = Read-Host
    
    Write-Host "  üéØ T2020 Reference: " -NoNewline -ForegroundColor Cyan
    $t2020 = Read-Host
    
    # Create new project with full PMC integration
    $newProject = @{
        name = $projectName
        description = $description
        icon = $icon
        created = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        isArchived = $false
        sortOrder = ($data.projects.Count + 1)
        # PMC Fields
        ID1 = if ([string]::IsNullOrWhiteSpace($id1)) { '' } else { $id1 }
        ID2 = if ([string]::IsNullOrWhiteSpace($id2)) { '' } else { $id2 }
        ProjFolder = if ([string]::IsNullOrWhiteSpace($projFolder)) { '' } else { $projFolder }
        AssignedDate = if ([string]::IsNullOrWhiteSpace($assignedDate)) { '' } else { $assignedDate }
        DueDate = if ([string]::IsNullOrWhiteSpace($dueDate)) { '' } else { $dueDate }
        BFDate = if ([string]::IsNullOrWhiteSpace($bfDate)) { '' } else { $bfDate }
        CAAName = if ([string]::IsNullOrWhiteSpace($caaName)) { '' } else { $caaName }
        RequestName = if ([string]::IsNullOrWhiteSpace($requestName)) { '' } else { $requestName }
        T2020 = if ([string]::IsNullOrWhiteSpace($t2020)) { '' } else { $t2020 }
    }
    
    # Add to projects list
    $data.projects += $newProject
    
    # Save data
    Set-TaskData -data $data
    
    Write-Host "`n  ‚úÖ Project '$projectName' created successfully!" -ForegroundColor Green
    Write-Host "  üí° Use 'proj $projectName' to switch to this project" -ForegroundColor DarkCyan
    Write-Host "  üí° Use 'show project $projectName' to view details" -ForegroundColor DarkCyan
    
    Pause-Screen
}

function Show-ProjectDetails {
    param([string]$projectQuery = "")
    
    if ([string]::IsNullOrWhiteSpace($projectQuery)) {
        Write-Host "Usage: show project <name>" -ForegroundColor Yellow
        return
    }
    
    $project = Find-Project -query $projectQuery -Interactive
    if (-not $project) {
        Write-Host "Project not found: $projectQuery" -ForegroundColor Red
        return
    }
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor DarkGray
    Write-Host "  ‚ïë                    PROJECT DETAILS                         ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor DarkGray
    Write-Host ""
    
    # Enhanced project information display using Format-StyledTable
    $projectInfo = @()
    
    # Basic Info
    $projectInfo += [PSCustomObject]@{
        Field = "Name"
        Value = $project.name
        Category = "Basic"
    }
    $projectInfo += [PSCustomObject]@{
        Field = "Description"
        Value = if ($project.description) { $project.description } else { "(none)" }
        Category = "Basic"
    }
    $projectInfo += [PSCustomObject]@{
        Field = "Icon"
        Value = if ($project.icon) { $project.icon } else { "üìÅ" }
        Category = "Basic"
    }
    $projectInfo += [PSCustomObject]@{
        Field = "Created"
        Value = if ($project.created) { $project.created } else { "(unknown)" }
        Category = "Basic"
    }
    
    # PMC Fields
    if ($project.ID1 -or $project.ID2) {
        $projectInfo += [PSCustomObject]@{
            Field = "ID1 (Primary)"
            Value = if ($project.ID1) { $project.ID1 } else { "(not set)" }
            Category = "PMC"
        }
        $projectInfo += [PSCustomObject]@{
            Field = "ID2 (Secondary)"
            Value = if ($project.ID2) { $project.ID2 } else { "(not set)" }
            Category = "PMC"
        }
    }
    
    if ($project.ProjFolder) {
        $projectInfo += [PSCustomObject]@{
            Field = "Project Folder"
            Value = $project.ProjFolder
            Category = "PMC"
        }
    }
    
    if ($project.AssignedDate -or $project.DueDate -or $project.BFDate) {
        if ($project.AssignedDate) {
            $projectInfo += [PSCustomObject]@{
                Field = "Assigned Date"
                Value = $project.AssignedDate
                Category = "PMC Dates"
            }
        }
        if ($project.DueDate) {
            $projectInfo += [PSCustomObject]@{
                Field = "Due Date"
                Value = $project.DueDate
                Category = "PMC Dates"
            }
        }
        if ($project.BFDate) {
            $projectInfo += [PSCustomObject]@{
                Field = "BF Date"
                Value = $project.BFDate
                Category = "PMC Dates"
            }
        }
    }
    
    if ($project.CAAName -or $project.RequestName -or $project.T2020) {
        if ($project.CAAName) {
            $projectInfo += [PSCustomObject]@{
                Field = "CAA Name"
                Value = $project.CAAName
                Category = "PMC Personnel"
            }
        }
        if ($project.RequestName) {
            $projectInfo += [PSCustomObject]@{
                Field = "Request Name"
                Value = $project.RequestName
                Category = "PMC Personnel"
            }
        }
        if ($project.T2020) {
            $projectInfo += [PSCustomObject]@{
                Field = "T2020 Reference"
                Value = $project.T2020
                Category = "PMC Reference"
            }
        }
    }
    
    # Display project info using our new styled table
    Format-StyledTable -Headers @("Field", "Value") -DataRows ($projectInfo | ForEach-Object { @($_.Field, $_.Value) }) -Title "PROJECT INFORMATION"
    
    # Task Summary
    $data = Get-TaskData
    $allTasks = $data.tasks | Where-Object { $_.project -eq $project.name }
    $pendingTasks = $allTasks | Where-Object { $_.status -eq 'pending' }
    $completedTasks = $allTasks | Where-Object { $_.status -eq 'completed' }
    $overdueToday = $pendingTasks | Where-Object { $_.due -and $_.due -lt (Get-Date).ToString("yyyy-MM-dd") }
    
    # Time summary
    $totalMinutes = 0
    $weekMinutes = 0
    if ($data.timelogs) {
        $projectLogs = $data.timelogs | Where-Object { $_.project -eq $project.name }
        $totalMinutes = ($projectLogs | Measure-Object minutes -Sum).Sum
        
        $weekStart = (Get-Date).Date.AddDays(-[int](Get-Date).DayOfWeek)
        $thisWeekLogs = $projectLogs | Where-Object { [datetime]$_.date -ge $weekStart }
        $weekMinutes = ($thisWeekLogs | Measure-Object minutes -Sum).Sum
    }
    
    # Summary table
    $summaryData = @()
    $summaryData += @("Pending Tasks", $pendingTasks.Count)
    $summaryData += @("Completed Tasks", $completedTasks.Count)
    if ($overdueToday.Count -gt 0) {
        $summaryData += @("‚ö†Ô∏è OVERDUE Tasks", $overdueToday.Count)
    }
    $summaryData += @("Total Time Logged", "$([Math]::Round($totalMinutes / 60, 1))h")
    $summaryData += @("This Week", "$([Math]::Round($weekMinutes / 60, 1))h")
    
    Write-Host ""
    Format-StyledTable -Headers @("Metric", "Value") -DataRows $summaryData -Title "PROJECT SUMMARY"

    # Excel T2020 fields for this project (preferred), else fallback to latest import
    $excelRows = @()
    if ($project.PSObject.Properties['ExcelFields'] -and $project.ExcelFields) {
        foreach ($p in $project.ExcelFields.PSObject.Properties) { $excelRows += , @($p.Name, ($p.Value -as [string])) }
        if ($excelRows.Count -gt 0) {
            Format-StyledTable -Headers @("Field", "Value") -DataRows $excelRows -Title "EXCEL T2020 (project)"
        }
    } else {
        $imports = @($data.excelImports)
        if ($imports.Count -gt 0) {
            $latest = $imports[-1]
            foreach ($k in $latest.Fields.Keys) { $excelRows += , @($k, ($latest.Fields[$k] -as [string])) }
            if ($excelRows.Count -gt 0) {
                Format-StyledTable -Headers @("Field", "Value") -DataRows $excelRows -Title "EXCEL T2020 (latest import)"
            }
        } else {
            Format-StyledTable -Headers @('Info') -DataRows @(@('No Excel fields found for this project. Run "excel import" or configure Excel settings.')) -Title 'EXCEL T2020'
        }
    }
    
    # Show recent tasks if any
    if ($pendingTasks.Count -gt 0) {
        Write-Host ""
        $recentTasks = $pendingTasks | Sort-Object created -Descending | Select-Object -First 5
        $taskRows = @()
        foreach ($task in $recentTasks) {
            $priority = @("", "!", "!!", "!!!")[$task.priority]
            $dueText = if ($task.due) { $task.due } else { "" }
        $taskRows += , @($task.id, $priority, $task.text, $dueText)
        }
        
        Format-StyledTable -Headers @("ID", "Pri", "Task", "Due") -DataRows $taskRows -Title "RECENT PENDING TASKS"
    }
    
    Write-Host "`n  üí° Use 'list $($project.name)' to see all tasks" -ForegroundColor DarkCyan
    Write-Host "  üí° Use 'add @$($project.name) <task>' to add a task" -ForegroundColor DarkCyan
    Write-Host ""
    
    Pause-Screen
}

function Show-RecentProjects {
    $data = Get-TaskData
    
    # Get recent projects from time logs (last 20 entries)
    $recentFromLogs = @()
    if ($data.timelogs) {
        $recentLogs = $data.timelogs | Sort-Object timestamp -Descending | Select-Object -First 20
        foreach ($log in $recentLogs) {
            if ($log.project -and $log.project -notin $recentFromLogs) {
                $recentFromLogs += $log.project
            }
        }
    }
    
    # Get recent projects from current context and last used
    $contextProj = if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') { @($global:CurrentContext) } else { @() }
    $lastUsed = if ($data.lastUsedProject) { @($data.lastUsedProject) } else { @() }
    
    # Combine and deduplicate
    $allRecent = @($contextProj + $lastUsed + $recentFromLogs) | Select-Object -Unique | Select-Object -First 8
    
    Clear-Host
    Write-Host "`n  üìÇ RECENT PROJECTS" -ForegroundColor Cyan
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkCyan
    Write-Host ""
    
    if ($allRecent.Count -eq 0) {
        Write-Host "  üì≠ No recent projects found" -ForegroundColor Yellow
        Write-Host "  üí° Projects will appear here after you log time or work with tasks" -ForegroundColor Gray
    } else {
        for ($i = 0; $i -lt $allRecent.Count; $i++) {
            $projName = $allRecent[$i]
            $project = $data.projects | Where-Object { $_.name -eq $projName } | Select-Object -First 1
            
            if ($project) {
                $current = if ($projName -eq $global:CurrentContext) { " (current)" } else { "" }
                $taskCount = @($data.tasks | Where-Object { $_.project -eq $projName -and $_.status -eq 'pending' }).Count
                $taskText = if ($taskCount -gt 0) { " ($taskCount tasks)" } else { " (no tasks)" }
                
                Write-Host "    [$($i+1)] @$projName$current$taskText" -ForegroundColor White
            }
        }
        
        Write-Host ""
        Write-Host "  üí° Use 'focus @<project>' to switch context" -ForegroundColor Gray
        Write-Host "  üí° Use 'proj view <project>' for details" -ForegroundColor Gray
    }
    
    Write-Host ""
}

# === ENHANCED TASK MANAGEMENT ===

function Complete-Tasks {
    param([string]$idString)
    
    $data = Get-TaskData
    $ids = Resolve-TaskIds -inputString $idString
    
    if ($ids.Count -eq 0) {
        Write-Host "‚ùå No valid task IDs found for: '$idString'" -ForegroundColor Red
        Write-Host "   Make sure the task IDs exist and are pending" -ForegroundColor Yellow
        Show-RecentTasks
        return
    }
    
    $completedCount = 0
    foreach ($id in $ids) {
        $task = $data.tasks | Where-Object { $_.id -eq $id -and $_.status -eq 'pending' }
        if ($task) {
            $task.status = 'completed'
            $completedVal = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            if ($task.PSObject.Properties['completed']) { $task.completed = $completedVal }
            else { Add-Member -InputObject $task -MemberType NoteProperty -Name completed -Value $completedVal }
            Write-Host "‚úÖ [done] #$($task.id) $($task.text)" -ForegroundColor Green
            $completedCount++
        }
    }
    
    if ($completedCount -gt 0) {
        # Update blocked status for dependent tasks
        Update-BlockedStatus -data $data
        Save-TaskData $data
        Write-Host "‚úÖ Completed $completedCount task$(if($completedCount -ne 1){'s'})" -ForegroundColor Green
    } else {
        Write-Host "‚ùå No tasks were completed. Check that the IDs are correct and tasks are pending." -ForegroundColor Yellow
    }
}

function Complete-SmartTasks {
    param([CommandContext]$context)
    
    $idString = $context.GetText()
    if ([string]::IsNullOrWhiteSpace($idString)) {
        Write-Host "‚ùå Please specify task ID(s) to complete" -ForegroundColor Red
        Write-Host "   Usage: done <id> or done <id1,id2> or done <id1-id5>" -ForegroundColor Yellow
        Write-Host "   Example: done 3 or done 1,2,5 or done 1-5" -ForegroundColor Gray
        Show-RecentTasks
        return
    }
    
    Complete-Tasks -idString $idString
}

function Delete-Tasks {
    param([string]$idString)
    
    # Support --yes/-y flags in id string
    $yesFlag = $false
    if ($idString) {
        $clean = @()
        foreach ($tok in ($idString -split '[,\s]+' | Where-Object { $_ })) {
            if ($tok -eq '--yes' -or $tok -eq '-y') { $yesFlag = $true }
            else { $clean += $tok }
        }
        $idString = ($clean -join ' ')
    }

    $data = Get-TaskData
    $ids = Resolve-TaskIds -inputString $idString
    
    $tasksToDelete = $data.tasks | Where-Object { 
        $_.id -in $ids -and $_.status -eq 'pending' 
    }
    
    if ($tasksToDelete.Count -eq 0) {
        Write-Host "No pending tasks found for the given IDs." -ForegroundColor Yellow
        Show-RecentTasks
        return
    }
    
    # Show what will be deleted
    Write-Host "Tasks to delete:" -ForegroundColor Yellow
    $tasksToDelete | ForEach-Object {
        Write-Host "  [-] #$($_.id) $($_.text)" -ForegroundColor Gray
    }
    
    # Confirmation (honor config for non-interactive or warn bypass)
    try { [ConfigManager]::Load() } catch {}
    $cfg = $null; try { $cfg = [ConfigManager]::Config } catch {}
    $nonInteractive = $false; $warn = $true
    try { if ($cfg -and $cfg.Behavior) { $nonInteractive = [bool]$cfg.Behavior.NonInteractive; $warn = [bool]$cfg.Behavior.WarnBeforeDelete } } catch {}
    if ($yesFlag -or $nonInteractive -or -not $warn) {
        Write-Host "Auto-confirm delete ($($tasksToDelete.Count) item(s)) due to configuration." -ForegroundColor DarkGray
    } else {
        $confirm = Read-Host "Delete $($tasksToDelete.Count) task$(if($tasksToDelete.Count -ne 1){'s'})? (y/N)"
        if ($confirm.ToLower() -ne 'y') {
            Write-Host "Deletion cancelled." -ForegroundColor Gray
            return
        }
    }
    
    # Perform deletion
    foreach ($task in $tasksToDelete) {
        $data.deleted += $task
        $data.tasks = $data.tasks | Where-Object { $_.id -ne $task.id }
        Write-Host "[-] #$($task.id) $($task.text)" -ForegroundColor Red
    }
    
    Save-TaskData $data
}

function Delete-SmartTasks {
    param([CommandContext]$context)
    
    $idString = $context.GetText()
    if ([string]::IsNullOrWhiteSpace($idString)) {
        Write-Host "‚ùå Please specify task ID(s) to delete" -ForegroundColor Red
        Write-Host "   Usage: delete <id> [--yes] or delete <id1,id2> [--yes]" -ForegroundColor Yellow
        Write-Host "   Example: delete 3 --yes or delete 1,2,5" -ForegroundColor Gray
        Show-RecentTasks
        return
    }
    
    Delete-Tasks -idString $idString
}

function Update-Task {
    param($parsed)
    
    $data = Get-TaskData
    $ids = Resolve-TaskIds -inputString $parsed.Id
    if ($ids.Count -eq 0) { Write-Host "No valid task ID(s) found" -ForegroundColor Red; return }

    $text = if ($parsed.Text) { $parsed.Text } else { '' }
    $metadata = Extract-Metadata -text $text
    
    # Special directives within the free text
    $clearDue = $text -match '(?i)\bdue:none\b'
    $clearEst = $text -match '(?i)\best:none\b'
    $clearPri = $text -match '(?i)\bp0\b|\bpri:none\b'
    $removeTags = @()
    foreach ($tok in ($text -split '\s+')) {
        if ($tok -match '^-#?(.+)$') { $removeTags += $matches[1] }
    }
    # Include structured remove tags if provided
    $ctxRemove = $context.GetArg('removeTags', @())
    if ($ctxRemove -and $ctxRemove.Count -gt 0) {
        $removeTags = @($removeTags + $ctxRemove)
    }

    foreach ($taskId in $ids) {
        $task = $data.tasks | Where-Object { $_.id -eq $taskId } | Select-Object -First 1
        if (-not $task) { continue }
        
        if ($metadata.CleanText) { $task.text = $metadata.CleanText }
        
        if ($metadata.Project) {
            $newProject = Find-Project -query $metadata.Project -Interactive:$false
            if ($newProject) { $task.project = $newProject.name }
        }
        
        if ($clearPri) { $task.priority = 0 }
        elseif ($metadata.Priority) { $task.priority = $metadata.Priority }
        
        if ($clearDue) { $task.due = $null }
        elseif ($metadata.Due) { $task.due = Parse-NaturalDate -input $metadata.Due }
        
        if ($clearEst) { $task.estimatedMinutes = $null }
        elseif ($metadata.EstimatedTime) { $task.estimatedMinutes = Parse-DurationToMinutes $metadata.EstimatedTime }
        
        # Update custom fields
        foreach ($key in $metadata.CustomFields.Keys) {
            if ($task.PSObject.Properties[$key]) { $task.$key = $metadata.CustomFields[$key] }
            else { Add-Member -InputObject $task -MemberType NoteProperty -Name $key -Value $metadata.CustomFields[$key] }
        }
        
        # Update tags (add/remove)
        if (-not $task.tags) { $task.tags = @() }
        if ($metadata.Tags.Count -gt 0) {
            $task.tags = @($task.tags + $metadata.Tags | Select-Object -Unique)
        }
        if ($removeTags.Count -gt 0) {
            $task.tags = @($task.tags | Where-Object { $_ -notin $removeTags })
        }
        Write-Host "[updated] #$($task.id) $($task.text)" -ForegroundColor Yellow
    }
    Save-TaskData $data
}

function Show-RecentTasks {
    Write-Host "Recently shown task IDs:" -ForegroundColor Gray
    $global:LastShownTaskMap.GetEnumerator() | Sort-Object Key | ForEach-Object {
        Write-Host "  [$($_.Key)] -> #$($_.Value)" -ForegroundColor DarkGray
    }
}

function Complete-AllOverdue {
    $data = Get-TaskData
    $todayStr = (Get-Date).ToString("yyyy-MM-dd")
    
    $overdue = $data.tasks | Where-Object { 
        $_.status -eq 'pending' -and $_.due -and $_.due -lt $todayStr 
    }
    
    if (-not $overdue) {
        Write-Host "No overdue tasks found." -ForegroundColor Green
        return
    }
    
    Write-Host "Found $($overdue.Count) overdue task$(if($overdue.Count -ne 1){'s'}):" -ForegroundColor Yellow
    $overdue | ForEach-Object {
        Write-Host "  #$($_.id) $($_.text)" -ForegroundColor Gray
    }
    
    # Confirmation (honor NonInteractive / WarnBeforeDelete)
    try { [ConfigManager]::Load() } catch {}
    $cfg = $null; try { $cfg = [ConfigManager]::Config } catch {}
    $nonInteractive = $false; $warn = $true
    try { if ($cfg -and $cfg.Behavior) { $nonInteractive = [bool]$cfg.Behavior.NonInteractive; $warn = [bool]$cfg.Behavior.WarnBeforeDelete } } catch {}
    $proceed = $false
    if ($nonInteractive -or -not $warn) { $proceed = $true }
    else {
        $confirm = Read-Host "Mark all as complete? (y/N)"
        if ($confirm.ToLower() -eq 'y') { $proceed = $true }
    }
    if ($proceed) {
        $overdue | ForEach-Object {
            $_.status = 'completed'
            $_.completed = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            Write-Host "[done] #$($_.id) $($_.text)" -ForegroundColor Green
        }
        Update-BlockedStatus -data $data
        Save-TaskData $data
        Write-Host "Completed $($overdue.Count) overdue task$(if($overdue.Count -ne 1){'s'})" -ForegroundColor Green
    }
}

function Show-NextTask {
    $data = Get-TaskData
    $today = (Get-Date).Date
    $todayStr = $today.ToString("yyyy-MM-dd")
    
    # Priority order: overdue, due today, high priority, then rest
    $candidates = $data.tasks | Where-Object { $_.status -eq 'pending' }
    
    $nextTask = $candidates | Where-Object { $_.due -and $_.due -lt $todayStr } | 
                Sort-Object due, priority | Select-Object -First 1
    
    if (-not $nextTask) {
        $nextTask = $candidates | Where-Object { $_.due -eq $todayStr } |
                    Sort-Object priority | Select-Object -First 1
    }
    
    if (-not $nextTask) {
        $nextTask = $candidates | Where-Object { $_.priority -eq 1 } |
                    Sort-Object created | Select-Object -First 1
    }
    
    if (-not $nextTask) {
        $nextTask = $candidates | Sort-Object priority, due, created | Select-Object -First 1
    }
    
    if ($nextTask) {
        Write-Host "`n=== NEXT RECOMMENDED TASK ===" -ForegroundColor Cyan
        $global:LastShownTaskMap.Clear()
        Set-LastShownEntry -LocalId 1 -TaskId $nextTask.id
        
        $pri = @(" ", "!", "!!", "!!!")[$nextTask.priority]
        $priColor = @("Gray", "Red", "Yellow", "Cyan")[$nextTask.priority]
        
        Write-Host ("  [1] (#{0}) " -f $nextTask.id) -NoNewline -ForegroundColor Gray
        Write-Host "$pri " -NoNewline -ForegroundColor $priColor
        Write-Host $nextTask.text -NoNewline
        
        if ($nextTask.project -ne 'inbox') {
            Write-Host " @$($nextTask.project)" -NoNewline -ForegroundColor Cyan
        }
        
        if ($nextTask.due) {
            $dueDate = [datetime]$nextTask.due
            $days = ($dueDate - $today).Days
            $dueText = if ($days -lt 0) { "OVERDUE" }
                      elseif ($days -eq 0) { "TODAY" }
                      elseif ($days -eq 1) { "Tomorrow" }
                      else { $dueDate.ToString("MMM d") }
            
            $dueColor = if ($days -le 0) { "Red" }
                       elseif ($days -eq 1) { "Yellow" }
                       else { "Gray" }
            
            Write-Host " [$dueText]" -NoNewline -ForegroundColor $dueColor
        }
        
        Write-Host
        Write-Host "`nQuick complete: done 1" -ForegroundColor DarkGray
    } else {
        Write-Host "No pending tasks found." -ForegroundColor Gray
    }
}

# === DEPENDENCIES & BLOCKING ===

function Add-Dependency {
    param([int]$taskId, [int]$dependsOnId)
    
    if ($taskId -eq $dependsOnId) {
        Write-Host "Task cannot depend on itself" -ForegroundColor Red
        return
    }
    
    $data = Get-TaskData
    $task = $data.tasks | Where-Object { $_.id -eq $taskId }
    $dependency = $data.tasks | Where-Object { $_.id -eq $dependsOnId }
    
    if (-not $task) {
        Write-Host "Task #$taskId not found" -ForegroundColor Red
        return
    }
    
    if (-not $dependency) {
        Write-Host "Task #$dependsOnId not found" -ForegroundColor Red
        return
    }
    
    # Check for circular dependencies
    if (Test-CircularDependency -data $data -taskId $taskId -checkId $dependsOnId) {
        Write-Host "Cannot add dependency: would create circular reference" -ForegroundColor Red
        return
    }
    
    if (-not $task.depends) { $task.depends = @() }
    
    if ($dependsOnId -notin $task.depends) {
        $task.depends += $dependsOnId
        Update-BlockedStatus -data $data
        Save-TaskData $data
        Write-Host "Task #$taskId now depends on #$dependsOnId" -ForegroundColor Yellow
        Write-Host "  #$taskId`: $($task.text)" -ForegroundColor Gray
        Write-Host "  depends on -> #$dependsOnId`: $($dependency.text)" -ForegroundColor Gray
    } else {
        Write-Host "Dependency already exists" -ForegroundColor Gray
    }
}

function Remove-Dependency {
    param([int]$taskId, [int]$dependsOnId)
    
    $data = Get-TaskData
    $task = $data.tasks | Where-Object { $_.id -eq $taskId }
    
    if ($task -and $task.depends) {
        $task.depends = $task.depends | Where-Object { $_ -ne $dependsOnId }
        if ($task.depends.Count -eq 0) {
            $task.PSObject.Properties.Remove('depends')
        }
        Update-BlockedStatus -data $data
        Save-TaskData $data
        Write-Host "Removed dependency #$taskId ‚Üí #$dependsOnId" -ForegroundColor Green
    }
}

function Test-CircularDependency {
    param($data, [int]$taskId, [int]$checkId, [array]$visited = @(), [int]$depth = 0)
    
    if ($checkId -in $visited) { return $true }
    if ($checkId -eq $taskId) { return $true }
    
    if ($depth -gt 100) { Write-Warning "Dependency chain too deep (>$depth), possible cycle"; return $true }
    $visited += $checkId
    $checkTask = $data.tasks | Where-Object { $_.id -eq $checkId }
    
    if ($checkTask -and $checkTask.depends) {
        foreach ($depId in $checkTask.depends) {
            if (Test-CircularDependency -data $data -taskId $taskId -checkId $depId -visited $visited -depth ($depth+1)) {
                return $true
            }
        }
    }
    
    return $false
}

function Update-BlockedStatus {
    param($data = (Get-TaskData))
    
    foreach ($task in $data.tasks | Where-Object { $_.depends }) {
        $blockers = $data.tasks | Where-Object { 
            $_.id -in $task.depends -and $_.status -eq 'pending' 
        }
        $isBlocked = ($blockers.Count -gt 0)
        if ($task.PSObject.Properties['blocked']) { $task.blocked = $isBlocked }
        else { Add-Member -InputObject $task -MemberType NoteProperty -Name blocked -Value $isBlocked }
    }
    
    # Clear blocked status for tasks without dependencies
    foreach ($task in $data.tasks | Where-Object { -not $_.depends }) {
        if ($task.PSObject.Properties['blocked']) {
            $task.PSObject.Properties.Remove('blocked')
        }
    }
}

# === TEMPLATES ===

function Save-Template {
    param([string]$name, [string]$template)
    
    if ([string]::IsNullOrWhiteSpace($name)) {
        Write-Host "Template name cannot be empty" -ForegroundColor Red
        return $false
    }
    
    $templatePath = Join-Path $global:DataPath "templates.json"
    $templates = @{}
    
    if (Test-Path $templatePath) {
        try {
            $content = Get-Content $templatePath -Raw -ErrorAction SilentlyContinue
            if ($content) {
                $templates = $content | ConvertFrom-Json -AsHashtable -ErrorAction SilentlyContinue
                if (-not $templates) { $templates = @{} }
            }
        } catch {
            Write-Host "Error reading templates: $_" -ForegroundColor Yellow
            $templates = @{}
        }
    }
    
    $templates[$name] = @{
        Template = $template
        Created = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        UsageCount = if ($templates[$name]) { $templates[$name].UsageCount } else { 0 }
    }
    
    try {
        $templates | ConvertTo-Json -Depth 3 | Out-File $templatePath -Encoding UTF8
        Write-Host "Template '$name' saved successfully" -ForegroundColor Green
        return $true
    } catch {
        Write-Host "Error saving template: $_" -ForegroundColor Red
        return $false
    }
}

function Get-Templates {
    $templatePath = Join-Path $global:DataPath "templates.json"
    if (-not (Test-Path $templatePath)) {
        return @{}
    }
    
    try {
        $content = Get-Content $templatePath -Raw -ErrorAction SilentlyContinue
        if ($content) {
            $templates = $content | ConvertFrom-Json -AsHashtable -ErrorAction SilentlyContinue
            return if ($templates) { $templates } else { @{} }
        }
        return @{}
    } catch {
        Write-Host "Error reading templates: $_" -ForegroundColor Yellow
        return @{}
    }
}

function Use-Template {
    param([string]$name, [string]$project = $null)
    
    $templates = Get-Templates
    if (-not $templates[$name]) {
        Write-Host "Template '$name' not found" -ForegroundColor Red
        $availableTemplates = $templates.Keys | Sort-Object
        if ($availableTemplates.Count -gt 0) {
            Write-Host "Available templates: $($availableTemplates -join ', ')" -ForegroundColor Gray
        }
        return
    }
    
    $template = $templates[$name]
    $tasks = $template.Template -split ';' | Where-Object { $_.Trim() }
    
    if ($tasks.Count -eq 0) {
        Write-Host "Template '$name' is empty" -ForegroundColor Yellow
        return
    }
    
    Write-Host "Using template '$name' (creating $($tasks.Count) tasks)..." -ForegroundColor Cyan
    
    $data = Get-TaskData
    $addedTasks = @()
    
    foreach ($taskText in $tasks) {
        $taskText = $taskText.Trim()
        if (-not $taskText) { continue }
        
        if ($project -and $taskText -notmatch '@\w+') {
            $taskText = "$taskText @$project"
        }
        
        $metadata = Extract-Metadata $taskText
        $newTask = @{
            id = Get-NextTaskId $data
            text = $metadata.CleanText
            created = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            done = $false
        }
        
        if ($metadata.Project) { $newTask.project = $metadata.Project }
        if ($metadata.Priority -gt 0) { $newTask.priority = $metadata.Priority }
        if ($metadata.Due) { $newTask.due = $metadata.Due }
        if ($metadata.EstimatedTime) { $newTask.estimated = $metadata.EstimatedTime }
        if ($metadata.Tags.Count -gt 0) { $newTask.tags = $metadata.Tags }
        
        $data.tasks += $newTask
        $addedTasks += $newTask
        Write-Host "  + $($newTask.text)" -ForegroundColor Green
    }
    
    Save-TaskData $data
    
    $template.UsageCount++
    $templates[$name] = $template
    $templatePath = Join-Path $global:DataPath "templates.json"
    try {
        $templates | ConvertTo-Json -Depth 3 | Out-File $templatePath -Encoding UTF8
    } catch {
        Write-Host "Note: Could not update template usage count" -ForegroundColor Yellow
    }
    
    Write-Host "`nCreated $($addedTasks.Count) tasks from template '$name'" -ForegroundColor Green
}

function Remove-Template {
    param([string]$name)
    
    if ([string]::IsNullOrWhiteSpace($name)) {
        Write-Host "Template name cannot be empty" -ForegroundColor Red
        return $false
    }
    
    $templates = Get-Templates
    if (-not $templates[$name]) {
        Write-Host "Template '$name' not found" -ForegroundColor Red
        return $false
    }
    
    $templates.Remove($name)
    $templatePath = Join-Path $global:DataPath "templates.json"
    
    try {
        if ($templates.Count -eq 0) {
            if (Test-Path $templatePath) {
                Remove-Item $templatePath
            }
        } else {
            $templates | ConvertTo-Json -Depth 3 | Out-File $templatePath -Encoding UTF8
        }
        Write-Host "Template '$name' removed successfully" -ForegroundColor Green
        return $true
    } catch {
        Write-Host "Error removing template: $_" -ForegroundColor Red
        return $false
    }
}

function Show-Templates {
    $templates = Get-Templates
    
    if ($templates.Count -eq 0) {
        Write-Host "No templates found" -ForegroundColor Gray
        Write-Host "`nCreate templates with: template save <name> <tasks>" -ForegroundColor Yellow
        return
    }
    
    Write-Host "=== TEMPLATES ===" -ForegroundColor Cyan
    foreach ($templateName in ($templates.Keys | Sort-Object)) {
        $template = $templates[$templateName]
        $tasks = $template.Template -split ';' | Where-Object { $_.Trim() }
        
        Write-Host "`n$templateName" -ForegroundColor Yellow
        Write-Host "  Created: $($template.Created)" -ForegroundColor Gray
        Write-Host "  Usage: $($template.UsageCount) times" -ForegroundColor Gray
        Write-Host "  Tasks ($($tasks.Count)):" -ForegroundColor Gray
        
        foreach ($task in $tasks) {
            $task = $task.Trim()
            if ($task) {
                Write-Host "    - $task" -ForegroundColor White
            }
        }
    }
}

function Invoke-TemplateCommand {
    param([string[]]$args)
    
    if ($args.Count -eq 0) {
        Show-Templates
        return
    }
    
    $action = $args[0].ToLower()
    
    switch ($action) {
        'save' {
            if ($args.Count -lt 3) {
                Write-Host "Usage: template save <name> <tasks>" -ForegroundColor Yellow
                Write-Host "  Tasks separated by semicolons" -ForegroundColor Gray
                Write-Host "  Example: template save 'daily' 'Check emails; Review calendar; Plan day'" -ForegroundColor Gray
                return
            }
            $name = $args[1]
            $template = $args[2..($args.Count-1)] -join ' '
            Save-Template $name $template
        }
        
        'use' {
            if ($args.Count -lt 2) {
                Write-Host "Usage: template use <name> [project]" -ForegroundColor Yellow
                return
            }
            $name = $args[1]
            $project = if ($args.Count -gt 2) { $args[2] } else { $null }
            Use-Template $name $project
        }
        
        'remove' {
            if ($args.Count -lt 2) {
                Write-Host "Usage: template remove <name>" -ForegroundColor Yellow
                return
            }
            Remove-Template $args[1]
        }
        
        'delete' {
            if ($args.Count -lt 2) {
                Write-Host "Usage: template delete <name>" -ForegroundColor Yellow
                return
            }
            Remove-Template $args[1]
        }
        
        'list' {
            Show-Templates
        }
        
        'show' {
            Show-Templates
        }
        
        default {
            Write-Host "Unknown template command: $action" -ForegroundColor Red
            Write-Host "Available commands: save, use, remove, list" -ForegroundColor Yellow
        }
    }
}


# === TIME TRACKING ===

function Log-StructuredEntry {
    param($context)
    # Prefer structured args from CommandContext
    $text = if ($context) { $context.GetText() } else { '' }
    $text = ($text -replace "\s+", ' ').Trim()
    if (-not $text -and -not ($context -and ($context.HasArg('project') -or $context.HasArg('id1')))) {
        Write-Host "Usage:" -ForegroundColor Yellow
        Write-Host "  log @project YYYY-MM-DD <hours> [description]" -ForegroundColor White
        Write-Host "  log #<ID1>   YYYY-MM-DD <hours> [description]" -ForegroundColor White
        Write-Host "Hints:" -ForegroundColor Yellow
        Write-Host "  ‚Ä¢ @project supports Tab completion (existing projects only)" -ForegroundColor Gray
        Write-Host "  ‚Ä¢ #ID1 is a 2‚Äì5 digit numeric code when no project applies" -ForegroundColor Gray
        Write-Host "  ‚Ä¢ Date may be 'today' or 'yesterday' as shortcuts" -ForegroundColor Gray
        Write-Host "  ‚Ä¢ Hours are decimal: .25, 1.25, 2" -ForegroundColor Gray
        return
    }
    $projName = $null; $id1 = $null; $dateStr = $null; $hoursStr = $null; $desc = ''
    if ($context) {
        if ($context.HasArg('project')) { $projName = $context.GetArg('project', '') }
        if ($context.HasArg('id1')) { $id1 = ($context.GetArg('id1','') -replace '^#','') }
    }
    # Heal multi-word project if only first word captured and remaining text begins with tail words
    if ($projName -and $text) {
        $tokens = $text -split '\s+'
        $bestIndex = -1; $bestExact = $false; $bestName = ''
        for ($i = 0; $i -lt $tokens.Count; $i++) {
            $candidate = ($projName + ' ' + (($tokens[0..$i]) -join ' ')).Trim()
            $p = Find-Project -query $candidate -Interactive:$false
            if ($p) {
                $bestIndex = $i; $bestName = $candidate
                if ($p.name -and ($p.name.ToLower() -eq $candidate.ToLower())) { $bestExact = $true; break }
            }
        }
        if ($bestIndex -ge 0) {
            $projName = $bestName
            if ($bestIndex -lt ($tokens.Count - 1)) { $text = ($tokens[($bestIndex+1)..($tokens.Count-1)] -join ' ') } else { $text = '' }
        }
    }
    # Parse remaining text as: <date> <hours> [desc]
    if ($text) {
        $parts = $text -split '\s+', 3
        if ($parts.Count -ge 2) {
            $dateStr = $parts[0]
            $hoursStr = $parts[1]
            if ($parts.Count -ge 3) { $desc = $parts[2] }
        }
    }
    if (-not $projName -and -not $id1) {
        Write-Host "Invalid format." -ForegroundColor Red
        Write-Host "Use: log @project YYYY-MM-DD <hours> [desc] OR log #1234 YYYY-MM-DD <hours> [desc]" -ForegroundColor Gray
        Write-Host "Example: log @work today 1.25 Weekly sync" -ForegroundColor Gray
        return
    }

    # Validate date (supports 'today'/'yesterday')
    if ($dateStr -match '^(?i)today|yesterday$') {
        $today = (Get-Date).Date
        $date = if ($dateStr.ToLower() -eq 'today') { $today } else { $today.AddDays(-1) }
    } else {
        try { $date = [datetime]::ParseExact($dateStr, 'yyyy-MM-dd', $null) } catch { Write-Host "Invalid date: $dateStr" -ForegroundColor Red; return }
    }
    # Validate hours
    if (-not [double]::TryParse($hoursStr, [ref]([double]$null))) { Write-Host "Invalid hours: $hoursStr" -ForegroundColor Red; return }
    $hours = [double]$hoursStr
    if ($hours -lt 0.25) { Write-Host "Minimum 0.25 hours" -ForegroundColor Yellow; return }
    $minutes = [int][Math]::Round($hours * 60)

    $data = Get-TaskData
    $project = $null
    if ($projName) {
        $project = Find-Project -query $projName -Interactive:$false
        if (-not $project) {
            Write-Host "Unknown project: $projName" -ForegroundColor Red
            Write-Host "Tip: Use @ and press Tab to cycle through existing projects" -ForegroundColor Gray
            return
        }
    }

    # Build JSON log
    $jsonLog = @{
        project = $(if ($project) { $project.name } else { "(none)" })
        minutes = $minutes
        date = $date.ToString('yyyy-MM-dd')
        time = (Get-Date).ToString('HH:mm')
        notes = $desc
        id = [System.Guid]::NewGuid().ToString()
    }
    if ($id1) { $jsonLog.id1 = $id1 }
    $data.timelogs += $jsonLog
    Save-TaskData $data

    # Prepare project data for CSV
    $projData = $null
    if ($project) {
        $projData = @{
            ID1    = ($(if ($project.PSObject.Properties.Name -contains 'ID1') { $project.ID1 } else { '' }))
            ID2    = ($(if ($project.PSObject.Properties.Name -contains 'ID2') { $project.ID2 } else { '' }))
            CAAName= ($(if ($project.PSObject.Properties.Name -contains 'CAAName') { $project.CAAName } else { '' }))
            T2020  = ($(if ($project.PSObject.Properties.Name -contains 'T2020') { $project.T2020 } else { '' }))
        }
    } else {
        $projData = @{ ID1 = $id1; ID2 = ''; CAAName = ''; T2020 = '' }
    }
    Export-TimeToCsv -LogEntry $jsonLog -ProjectData $projData
    
    Write-Host ("‚úÖ Logged {0}h {1}" -f $hours, $(if ($project) {"to '" + $project.name + "'"} else {"with ID1 #$id1"})) -ForegroundColor Green
}

function Add-TimeLog {
    param($parsed)
    
    # Determine target project
    $projectQuery = $parsed.ProjectQuery
    if (-not $projectQuery -and $global:CurrentContext) {
        $projectQuery = $global:CurrentContext
    }
    
    $project = Find-Project -query $projectQuery -Interactive -AllowCreate
    if (-not $project) {
        Write-Host "Cannot determine project for time log." -ForegroundColor Red
        return
    }
    
    $data = Get-TaskData
    $minutes = Parse-DurationToMinutes $parsed.Duration
    
    if ($minutes -le 0) {
        Write-Host "Invalid duration: $($parsed.Duration)" -ForegroundColor Red
        Write-Host "Use format: 1.5h, 90m, 2h, 30m" -ForegroundColor Gray
        return
    }
    
    # Create time log entry
    $log = @{
        project = $project.name
        minutes = $minutes
        date = (Get-Date).ToString("yyyy-MM-dd")
        time = (Get-Date).ToString("HH:mm")
        notes = $parsed.Notes
    }
    
    $data.timelogs += $log
    $data.lastUsedProject = $project.name
    Save-TaskData $data
    
    # Display confirmation
    $hours = [Math]::Round($minutes / 60, 2)
    Write-Host "Logged $hours hours to '$($project.name)'" -ForegroundColor Green
    
    if ($parsed.Notes) {
        Write-Host "  Note: $($parsed.Notes)" -ForegroundColor Gray
    }
    
    # Show daily total for context
    $todayStr = (Get-Date).ToString("yyyy-MM-dd")
    $todayTotal = ($data.timelogs | Where-Object { 
        $_.date -eq $todayStr -and $_.project -eq $project.name 
    } | Measure-Object minutes -Sum).Sum
    
    if ($todayTotal -gt $minutes) {
        $totalHours = [Math]::Round($todayTotal / 60, 2)
        Write-Host "  Today's total for $($project.name): $totalHours hours" -ForegroundColor DarkGreen
    }
}

function Show-TimeReport {
    param($parsed)
    
    $data = Get-TaskData
    $dateRange = Parse-DateRange -range $parsed.DateRange
    
    # Get logs for date range
    $logs = $data.timelogs | Where-Object { 
        [datetime]$_.date -ge $dateRange.Start -and [datetime]$_.date -lt $dateRange.End 
    }
    
    # Filter by project if specified
    if ($parsed.ProjectFilter) {
        $project = Find-Project -query $parsed.ProjectFilter -Interactive
        if ($project) {
            $logs = $logs | Where-Object { $_.project -eq $project.name }
            $projDisplay = " for $($project.name)"
        } else {
            return
        }
    } else {
        $projDisplay = ""
    }
    
    if (-not $logs) {
        Write-Host "No time logged for $($dateRange.Display)$projDisplay" -ForegroundColor Gray
        return
    }
    
    Write-Host "`n=== TIME REPORT: $($dateRange.Display)$projDisplay ===" -ForegroundColor Cyan
    
    # Group by project and calculate totals
    $grouped = $logs | Group-Object project | Sort-Object Name
    $totalMinutes = 0
    
    foreach ($group in $grouped) {
        $projMinutes = ($group.Group | Measure-Object minutes -Sum).Sum
        $totalMinutes += $projMinutes
        $projHours = [Math]::Round($projMinutes / 60, 2)
        
        $contextMarker = if ($group.Name -eq $global:CurrentContext) { "* " } else { "  " }
        Write-Host ("$contextMarker{0,-25} {1,8} hours" -f $group.Name, $projHours)
        
        # Show daily breakdown for short periods
        if (($dateRange.End - $dateRange.Start).Days -le 7) {
            $daily = $group.Group | Group-Object date | Sort-Object Name
            
            foreach ($day in $daily) {
                $dayMinutes = ($day.Group | Measure-Object minutes -Sum).Sum
                $dayHours = [Math]::Round($dayMinutes / 60, 2)
                $dayDate = [datetime]$day.Name
                
                Write-Host ("    {0,-15} {1,6}h" -f $dayDate.ToString("ddd MM/dd"), $dayHours) -ForegroundColor Gray
                
                # Show individual entries for very detailed view
                if ($day.Group.Count -le 3) {
                    $day.Group | ForEach-Object {
                        if ($_.notes) {
                            $entryHours = [Math]::Round($_.minutes / 60, 2)
                            Write-Host ("      {0} {1}h - {2}" -f $_.time, $entryHours, $_.notes) -ForegroundColor DarkGray
                        }
                    }
                }
            }
        }
    }
    
    $totalHours = [Math]::Round($totalMinutes / 60, 2)
    Write-Host ("  {0}" -f ("-" * 40)) -ForegroundColor DarkGray
    Write-Host ("  {0,-25} {1,8} hours" -f "TOTAL", $totalHours) -ForegroundColor Yellow
}

function Log-Time {
    param(
        [string]$ProjectName = "",
        [string]$Duration = "",
        [string]$Description = "",
        [switch]$Interactive
    )
    
    # Interactive mode or missing parameters
    if ($Interactive -or [string]::IsNullOrWhiteSpace($ProjectName) -or [string]::IsNullOrWhiteSpace($Duration)) {
        Clear-Host
        Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor DarkGray
        Write-Host "  ‚ïë                    TIME LOGGING ENTRY                      ‚ïë" -ForegroundColor Cyan
        Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor DarkGray
        Write-Host ""
        
        if ([string]::IsNullOrWhiteSpace($ProjectName)) {
            Write-Host "  üìÅ Project: " -NoNewline -ForegroundColor Cyan
            $ProjectName = Read-Host
            if ([string]::IsNullOrWhiteSpace($ProjectName)) {
                Write-Host "  ‚ùå Project name required" -ForegroundColor Red
                Pause-Screen
                return
            }
        }
        
        if ([string]::IsNullOrWhiteSpace($Duration)) {
            Write-Host "  ‚è±Ô∏è  Duration (e.g., 2h, 90m, 1.5h): " -NoNewline -ForegroundColor Cyan
            $Duration = Read-Host
            if ([string]::IsNullOrWhiteSpace($Duration)) {
                Write-Host "  ‚ùå Duration required" -ForegroundColor Red
                Pause-Screen
                return
            }
        }
        
        if ([string]::IsNullOrWhiteSpace($Description)) {
            Write-Host "  üìù Description (optional): " -NoNewline -ForegroundColor Cyan
            $Description = Read-Host
        }
        
        # Optional date override
        Write-Host "  üìÖ Date (YYYY-MM-DD, blank for today): " -NoNewline -ForegroundColor Cyan
        $dateOverride = Read-Host
    }
    
    # Find or create project
    $project = Find-Project -query $ProjectName -Interactive -AllowCreate
    if (-not $project) {
        Write-Host "Cannot determine project for time log." -ForegroundColor Red
        return
    }
    
    # Parse duration
    $minutes = Parse-DurationToMinutes $Duration
    if ($minutes -le 0) {
        Write-Host "Invalid duration: $Duration" -ForegroundColor Red
        Write-Host "Use format: 1.5h, 90m, 2h, 30m" -ForegroundColor Gray
        Pause-Screen
        return
    }
    
    # Determine date
    $logDate = if ([string]::IsNullOrWhiteSpace($dateOverride)) { 
        Get-Date 
    } else { 
        try { 
            [datetime]::Parse($dateOverride) 
        } catch { 
            Write-Host "Invalid date format: $dateOverride" -ForegroundColor Red
            Pause-Screen
            return
        }
    }
    
    # Create log entry (both JSON and CSV)
    $data = Get-TaskData
    
    # Add to JSON structure (existing system)
    $log = @{
        project = $project.name
        minutes = $minutes
        date = $logDate.ToString("yyyy-MM-dd")
        time = $logDate.ToString("HH:mm")
        notes = $Description
        id = [System.Guid]::NewGuid().ToString()
    }
    
    $data.timelogs += $log
    Save-TaskData $data
    
    # Add to CSV ledger (new enhancement)
    Export-TimeToCsv -LogEntry $log -ProjectData $project
    
    # Display confirmation
    $hours = [Math]::Round($minutes / 60, 2)
    Write-Host "`n  ‚úÖ Logged $hours hours to '$($project.name)'" -ForegroundColor Green
    if ($Description) {
        Write-Host "  üìù $Description" -ForegroundColor Gray
    }
    Write-Host "  üìÖ Date: $($log.date) at $($log.time)" -ForegroundColor Gray
    
    if ($Interactive) {
        Pause-Screen
    }
}

function Export-TimeToCsv {
    param(
        [hashtable]$LogEntry,
        [hashtable]$ProjectData
    )
    
    
    # Determine CSV file path from Config
    try { [ConfigManager]::Load() } catch {}
    $csvPath = $null
    try { $cfg = [ConfigManager]::Config } catch {}
    $enabled = if ($cfg -and $cfg.Behavior -and $cfg.Behavior.EnableCsvLedger -ne $null) { [bool]$cfg.Behavior.EnableCsvLedger } else { $true }
    if (-not $enabled) { return }
    $pathSetting = if ($cfg -and $cfg.Paths) { $cfg.Paths.CsvLedgerPath } else { 'time_ledger.csv' }
    if ([string]::IsNullOrWhiteSpace($pathSetting)) { $pathSetting = 'time_ledger.csv' }
    $csvPath = Get-SafePath -Path $pathSetting -Base $PSScriptRoot
    Write-DebugLog ("Export-TimeToCsv resolved path: " + $csvPath)
    
    # Ensure directory exists
    $csvDir = Split-Path -Parent $csvPath
    if (-not (Test-Path $csvDir)) { New-Item -ItemType Directory -Path $csvDir -Force | Out-Null }

    # Create CSV headers if file doesn't exist
    if (-not (Test-Path $csvPath)) {
        $headers = @(
            "Date", "Time", "Project", "ProjectID1", "ProjectID2", 
            "Duration_Minutes", "Duration_Hours", "Description", 
            "CAAName", "T2020", "LogID"
        )
        try {
            $headers -join "," | Out-File -FilePath $csvPath -Encoding UTF8
            Write-DebugLog ("Export-TimeToCsv created CSV with headers at: " + $csvPath)
        } catch {
            Write-DebugLog ("Export-TimeToCsv header write failed: " + $_)
        }
    }
    
    # Create CSV row
    $hours = [Math]::Round($LogEntry.minutes / 60, 2)
    $desc = if ($LogEntry.ContainsKey('notes') -and $LogEntry.notes) { $LogEntry.notes } elseif ($LogEntry.ContainsKey('description') -and $LogEntry.description) { $LogEntry.description } else { "" }
    $id2Formatted = if ($ProjectData.ID2) { (Format-ProjectID2Csv $ProjectData.ID2) } else { "" }
    $csvRow = @(
        $LogEntry.date,
        $LogEntry.time,
        $LogEntry.project,
        $(if ($ProjectData.ID1) { $ProjectData.ID1 } else { "" }),
        $id2Formatted,
        $LogEntry.minutes,
        $hours,
        $(if ($desc) { "`"$($desc -replace '"', '""')`"" } else { "" }),
        $(if ($ProjectData.CAAName) { $ProjectData.CAAName } else { "" }),
        $(if ($ProjectData.T2020) { $ProjectData.T2020 } else { "" }),
        $LogEntry.id
    )
    
    try {
        $csvRow -join "," | Out-File -FilePath $csvPath -Append -Encoding UTF8
        Write-DebugLog ("Export-TimeToCsv appended row for date=" + $LogEntry.date + ", project=" + $LogEntry.project)
    } catch {
        Write-DebugLog ("Export-TimeToCsv append failed: " + $_)
    }
}

function Show-TimeReportEnhanced {
    param(
        [string]$DateRange = "week",
        [string]$ProjectFilter = "",
        [switch]$ExportCsv,
        [string]$OutputPath = "",
        [switch]$WithIDs,
        [string]$ByID2 = ""
    )
    
    $data = Get-TaskData
    $rangeInfo = Parse-DateRange -range $DateRange
    Write-DebugLog (("REPORT: Range='{0}' -> Start={1}, End={2}" -f $DateRange, $rangeInfo.Start, $rangeInfo.End))
    
    # Get logs for date range (array) and ignore zero-minute timer entries
    $logs = @($data.timelogs | Where-Object { 
        ([datetime]$_.date -ge $rangeInfo.Start) -and ([datetime]$_.date -lt $rangeInfo.End) -and ([double]$_.minutes -gt 0)
    })
    Write-DebugLog (("REPORT: Found logs in range: {0}" -f ($logs.Count)))
    
    # Filter by project if specified
    if ($ProjectFilter) {
        $project = Find-Project -query $ProjectFilter -Interactive
        if ($project) {
            $logs = $logs | Where-Object { $_.project -eq $project.name }
            $projDisplay = " for $($project.name)"
        } else {
            return
        }
    } else {
        $projDisplay = ""
    }

    # Filter by raw ID2 if specified
    if ($ByID2) {
        $raw = $ByID2.ToString().Trim()
        $logs = $logs | Where-Object {
            $p = ($data.projects | Where-Object { $_.name -eq $_.project } | Select-Object -First 1)
            $p -and $p.ID2 -and ($p.ID2 -eq $raw)
        }
        if (-not $logs) { Write-Host "No time logged for $($rangeInfo.Display) matching ID2=$raw" -ForegroundColor Gray; return }
        $projDisplay += " (ID2=$raw)"
    }
    
    if (-not $logs -or $logs.Count -eq 0) {
        Write-Host "No time logged for $($rangeInfo.Display)$projDisplay" -ForegroundColor Gray
        return
    }
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor DarkGray
    Write-Host "  ‚ïë                    ENHANCED TIME REPORT                    ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor DarkGray
    Write-Host ""
    
    # Create detailed report data
    $reportData = @()
    $totalMinutes = 0
    
    foreach ($log in ($logs | Sort-Object date, time)) {
        $project = $data.projects | Where-Object { $_.name -eq $log.project } | Select-Object -First 1
        $hours = [Math]::Round([double]$log.minutes / 60, 2)
        $totalMinutes += $log.minutes
        
        $reportData += [PSCustomObject]@{
            Date = $log.date
            Time = $(if ($log.PSObject.Properties['time'] -and $log.time) { $log.time } elseif ($log.PSObject.Properties['endTime'] -and $log.endTime) { (Get-Date $log.endTime).ToString('HH:mm') } else { '' })
            Project = $log.project
            Hours = $hours
            Description = if ($log.notes) { $log.notes } else { "(no description)" }
            ID1 = if ($project.ID1) { $project.ID1 } else { "" }
            ID2 = if ($project.ID2) { (Format-ProjectID2Csv $project.ID2) } else { "" }
            CAA = if ($project.CAAName) { $project.CAAName } else { "" }
        }
    }
    
    # Display report using Format-StyledTable
    $displayRows = @()
        if ($WithIDs) {
        foreach ($item in $reportData) { $displayRows += , @($item.Date, $item.Time, $item.Project, $item.ID1, $item.ID2, $item.Hours, $item.Description) }
        Format-StyledTable -Headers @("Date", "Time", "Project", "ID1", "ID2", "Hours", "Description") -DataRows $displayRows -Title "TIME LOG DETAILS - $($rangeInfo.Display)$projDisplay"
    } else {
        foreach ($item in $reportData) { $displayRows += , @($item.Date, $item.Time, $item.Project, $item.Hours, $item.Description) }
        Format-StyledTable -Headers @("Date", "Time", "Project", "Hours", "Description") -DataRows $displayRows -Title "TIME LOG DETAILS - $($rangeInfo.Display)$projDisplay"
    }
    
    # Summary by project
    Write-Host ""
    $grouped = $reportData | Group-Object Project
    $summaryRows = @()
    foreach ($group in $grouped) {
        $groupTotal = ($group.Group | Measure-Object Hours -Sum).Sum
        $summaryRows += , @($group.Name, $group.Count, [Math]::Round($groupTotal, 2))
    }
    
    Format-StyledTable -Headers @("Project", "Entries", "Total Hours") -DataRows $summaryRows -Title "PROJECT SUMMARY"
    
    # Grand total
    $totalHours = [Math]::Round([double]$totalMinutes / 60, 2)
    Write-Host "`n  üìä GRAND TOTAL: $totalHours hours across $($logs.Count) entries" -ForegroundColor Yellow
    
    # CSV Export option
    if ($ExportCsv) {
        if ([string]::IsNullOrWhiteSpace($OutputPath)) {
            $OutputPath = "time_report_$(Get-Date -Format 'yyyyMMdd_HHmm').csv"
        }
        $safeOut = Get-SafePath -Path $OutputPath -Base $PSScriptRoot
        try {
            $dir = [System.IO.Path]::GetDirectoryName($safeOut)
            if ($dir -and -not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null }
            $reportData | Export-Csv -Path $safeOut -NoTypeInformation -Encoding UTF8
            Write-Host "  üìÑ Report exported to: $safeOut" -ForegroundColor Green
        } catch {
            Write-Host "  ‚ùå Failed to export report: $_" -ForegroundColor Red
        }
    }
    
    Write-Host "`n  üí° Use 'log time' to add more time entries" -ForegroundColor DarkCyan
    Write-Host "  üí° Add -ExportCsv to export this report to CSV" -ForegroundColor DarkCyan
    Write-Host ""
    
    Pause-Screen
}

# === NATURAL DATE PARSING ===

function GetNextWeekday {
    param([datetime]$from, [DayOfWeek]$targetDay)
    
    $daysUntilTarget = ([int]$targetDay - [int]$from.DayOfWeek + 7) % 7
    if ($daysUntilTarget -eq 0) { $daysUntilTarget = 7 }
    return $from.Date.AddDays($daysUntilTarget)
}

function Parse-NaturalDate {
    param([Alias('input')][string]$text)
    
    if (-not $text) { return $null }
    
    $today = (Get-Date).Date
    $patterns = @{
        '^(\d+)d$' = { param($m) $today.AddDays([int]$m[1]) }
        '^(\d+)w$' = { param($m) $today.AddDays([int]$m[1] * 7) }
        '^(\d+)m$' = { param($m) $today.AddMonths([int]$m[1]) }
        '^(\d+)y$' = { param($m) $today.AddYears([int]$m[1]) }
        '^next (\w+)$' = { param($m) 
            try {
                $targetDay = [Enum]::Parse([DayOfWeek], $m[1], $true)
                $daysUntil = ($targetDay - $today.DayOfWeek + 7) % 7
                if ($daysUntil -eq 0) { $daysUntil = 7 }
                $today.AddDays($daysUntil)
            } catch { $null }
        }
        '^(eow|endofweek)$' = { 
            # End of week (Sunday)
            $daysUntilSunday = (7 - [int]$today.DayOfWeek) % 7
            if ($daysUntilSunday -eq 0) { $daysUntilSunday = 7 }
            $today.AddDays($daysUntilSunday)
        }
        '^(sow|startofweek)$' = { 
            # Start of week (Monday)
            $daysSinceMonday = ([int]$today.DayOfWeek + 6) % 7
            $today.AddDays(-$daysSinceMonday)
        }
        '^(eom|endofmonth)$' = { 
            # End of month
            $today.AddMonths(1).AddDays(-$today.AddMonths(1).Day) 
        }
        '^(som|startofmonth)$' = { 
            # Start of month
            $today.AddDays(-$today.Day + 1)
        }
        '^(eoy|endofyear)$' = {
            # End of year
            Get-Date -Month 12 -Day 31 -Year $today.Year
        }
        '^(soy|startofyear)$' = {
            # Start of year
            Get-Date -Month 1 -Day 1 -Year $today.Year
        }
        '^(mon|monday)$' = { GetNextWeekday $today ([DayOfWeek]::Monday) }
        '^(tue|tuesday)$' = { GetNextWeekday $today ([DayOfWeek]::Tuesday) }
        '^(wed|wednesday)$' = { GetNextWeekday $today ([DayOfWeek]::Wednesday) }
        '^(thu|thursday)$' = { GetNextWeekday $today ([DayOfWeek]::Thursday) }
        '^(fri|friday)$' = { GetNextWeekday $today ([DayOfWeek]::Friday) }
        '^(sat|saturday)$' = { GetNextWeekday $today ([DayOfWeek]::Saturday) }
        '^(sun|sunday)$' = { GetNextWeekday $today ([DayOfWeek]::Sunday) }
        '^(\d+)(?:st|nd|rd|th)$' = { param($m)
            $day = [int]$m[1]
            if ($day -ge 1 -and $day -le 31) {
                try {
                    $targetDate = Get-Date -Day $day
                    if ($targetDate -le $today) { 
                        $targetDate = $targetDate.AddMonths(1) 
                    }
                    $targetDate
                } catch { $null }
            }
        }
        '^(\w+) (\d+)$' = { param($m)
            # Month day format (Jan 15)
            try {
                $month = [datetime]::ParseExact($m[1], "MMM", $null).Month
                $day = [int]$m[2]
                $targetDate = Get-Date -Month $month -Day $day
                if ($targetDate -le $today) {
                    $targetDate = $targetDate.AddYears(1)
                }
                $targetDate
            } catch { $null }
        }
        '^today$' = { $today }
        '^tomorrow$' = { $today.AddDays(1) }
        '^yesterday$' = { $today.AddDays(-1) }
    }
    
    $lowerInput = $text.ToLower()
    
    foreach ($pattern in $patterns.GetEnumerator()) {
        if ($lowerInput -match $pattern.Key) {
            $result = & $pattern.Value $matches
            if ($result) {
                return $result.ToString("yyyy-MM-dd")
            }
        }
    }
    
    # Try parsing as standard date
    try {
        $date = [datetime]::Parse($text)
        return $date.ToString("yyyy-MM-dd")
    } catch {
        return $null
    }
}

# === ENHANCED AGENDA DISPLAY ===

function Show-EnhancedAgenda {
    $global:LastShownTaskMap.Clear()
    $localIdCounter = 1
    $data = Get-TaskData
    $prefs = $data.preferences
    $today = (Get-Date).Date
    $todayStr = $today.ToString("yyyy-MM-dd")
    
    Write-Host "`n=== DAILY AGENDA ===" -ForegroundColor Cyan
    
    # Show current context
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        Write-Host "Current focus: $global:CurrentContext" -ForegroundColor Yellow
    }
    
    Write-Host
    
    # Time logged today
    if ($prefs.agendaShowTimeToday) {
        $todayLogs = $data.timelogs | Where-Object { $_.date -eq $todayStr }
        $todayMinutes = ($todayLogs | Measure-Object minutes -Sum).Sum
        
        if ($todayMinutes -gt 0) {
            $todayHours = [Math]::Round($todayMinutes / 60, 2)
            Write-Host "Time logged today: $todayHours hours" -ForegroundColor Green
            Write-Host
        }
    }
    
    $foundUrgent = $false
    
    # Overdue tasks (highest priority)
    if ($prefs.agendaShowOverdue) {
        $overdue = $data.tasks | Where-Object { 
            $_.status -eq 'pending' -and $_.due -and $_.due -lt $todayStr 
        } | Sort-Object due, priority
        
        if ($overdue) {
            Write-Host "OVERDUE TASKS:" -ForegroundColor Red
            foreach ($task in $overdue) {
                $days = ([datetime]$todayStr - [datetime]$task.due).Days
                $pri = @("", "!", "!!", "!!!")[$task.priority]
                $priColor = @("Gray", "Red", "Yellow", "Cyan")[$task.priority]
                
                Write-Host ("  [{0,2}] (#{1}) " -f $localIdCounter, $task.id) -NoNewline -ForegroundColor DarkGray
                Write-Host "$pri " -NoNewline -ForegroundColor $priColor
                Write-Host $task.text -NoNewline
                Write-Host " ($days day$(if($days -ne 1){'s'}) late)" -ForegroundColor Red
                
                Set-LastShownEntry -LocalId $localIdCounter -TaskId $task.id
                $localIdCounter++
            }
            Write-Host
            $foundUrgent = $true
        }
    }
    
    # Today's tasks
    if ($prefs.agendaShowToday) {
        $todayTasks = $data.tasks | Where-Object { 
            $_.status -eq 'pending' -and $_.due -eq $todayStr 
        } | Sort-Object priority
        
        if ($todayTasks) {
            Write-Host "TODAY'S TASKS:" -ForegroundColor Yellow
            foreach ($task in $todayTasks) {
                $pri = @("", "!", "!!", "!!!")[$task.priority]
                $priColor = @("Gray", "Red", "Yellow", "Cyan")[$task.priority]
                
                Write-Host ("  [{0,2}] (#{1}) " -f $localIdCounter, $task.id) -NoNewline -ForegroundColor Gray
                Write-Host "$pri " -NoNewline -ForegroundColor $priColor
                Write-Host $task.text
                
                Set-LastShownEntry -LocalId $localIdCounter -TaskId $task.id
                $localIdCounter++
            }
            Write-Host
            $foundUrgent = $true
        }
    }
    
    # High priority tasks (if no urgent items)
    if (-not $foundUrgent) {
        $highPri = $data.tasks | Where-Object { 
            $_.status -eq 'pending' -and $_.priority -eq 1 
        } | Select-Object -First 3
        
        if ($highPri) {
            Write-Host "HIGH PRIORITY TASKS:" -ForegroundColor Red
            foreach ($task in $highPri) {
                Write-Host ("  [{0,2}] (#{1}) !!! {2}" -f $localIdCounter, $task.id, $task.text) -ForegroundColor Red
                Set-LastShownEntry -LocalId $localIdCounter -TaskId $task.id
                $localIdCounter++
            }
            Write-Host
        }
    }
    
    # Upcoming tasks
    if ($prefs.agendaShowUpcoming) {
        $upcoming = $data.tasks | Where-Object { 
            $_.status -eq 'pending' -and $_.due -and 
            $_.due -gt $todayStr -and 
            $_.due -le $today.AddDays($prefs.agendaDaysAhead).ToString("yyyy-MM-dd")
        } | Sort-Object due, priority
        
        if ($upcoming) {
            Write-Host "UPCOMING ($($prefs.agendaDaysAhead) days):" -ForegroundColor Cyan
            foreach ($task in $upcoming) {
                $dueDate = [datetime]$task.due
                $days = ($dueDate - $today).Days
                $dayText = if ($days -eq 1) { "Tomorrow" } else { $dueDate.ToString("ddd MMM d") }
                
                Write-Host ("  [{0,2}] (#{1}) {2} ({3})" -f $localIdCounter, $task.id, $task.text, $dayText) -ForegroundColor Gray
                Set-LastShownEntry -LocalId $localIdCounter -TaskId $task.id
                $localIdCounter++
            }
            Write-Host
        }
    }
    
    # Current context summary
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        $contextTasks = @($data.tasks | Where-Object { 
            $_.project -eq $global:CurrentContext -and $_.status -eq 'pending' 
        })
        
        if ($contextTasks.Count -gt 0) {
            Write-Host "FOCUSED PROJECT ($($global:CurrentContext)): $($contextTasks.Count) task$(if($contextTasks.Count -ne 1){'s'})" -ForegroundColor Cyan
        }
    }
    
    # Quick action suggestions
    if ($localIdCounter -gt 1) {
        Write-Host "Quick actions: done 1-3 (complete), rm 2 (delete), next (show next task)" -ForegroundColor DarkGray
    }
}

# === CONFIGURATION MENU ===

function Show-ConfigMenu {
    $data = Get-TaskData
    $prefs = $data.preferences
    
    Write-Host "`n=== PREFERENCES ===" -ForegroundColor Cyan
    Write-Host "1. Show overdue in agenda: $($prefs.agendaShowOverdue)" -ForegroundColor Gray
    Write-Host "2. Show today's tasks in agenda: $($prefs.agendaShowToday)" -ForegroundColor Gray
    Write-Host "3. Show upcoming tasks in agenda: $($prefs.agendaShowUpcoming)" -ForegroundColor Gray
    Write-Host "4. Show time logged today: $($prefs.agendaShowTimeToday)" -ForegroundColor Gray
    Write-Host "5. Days ahead for upcoming: $($prefs.agendaDaysAhead)" -ForegroundColor Gray
    Write-Host "6. Auto-backup: $($prefs.autoBackup)" -ForegroundColor Gray
    Write-Host "7. Default view: $($prefs.defaultView)" -ForegroundColor Gray
    Write-Host
    
    $choice = Read-Host "Toggle/change setting [1-7], or Enter to exit"
    
    switch ($choice) {
        '1' { 
            $prefs.agendaShowOverdue = -not $prefs.agendaShowOverdue
            Write-Host "Show overdue: $($prefs.agendaShowOverdue)" -ForegroundColor Green
        }
        '2' { 
            $prefs.agendaShowToday = -not $prefs.agendaShowToday
            Write-Host "Show today's tasks: $($prefs.agendaShowToday)" -ForegroundColor Green
        }
        '3' { 
            $prefs.agendaShowUpcoming = -not $prefs.agendaShowUpcoming
            Write-Host "Show upcoming: $($prefs.agendaShowUpcoming)" -ForegroundColor Green
        }
        '4' { 
            $prefs.agendaShowTimeToday = -not $prefs.agendaShowTimeToday
            Write-Host "Show daily time: $($prefs.agendaShowTimeToday)" -ForegroundColor Green
        }
        '5' {
            $days = Read-Host "Days ahead for upcoming tasks [current: $($prefs.agendaDaysAhead)]"
            if ($days -match '^\d+$' -and [int]$days -ge 0 -and [int]$days -le 14) {
                $prefs.agendaDaysAhead = [int]$days
                Write-Host "Days ahead set to: $days" -ForegroundColor Green
            } else {
                Write-Host "Invalid number (0-14)" -ForegroundColor Red
                return
            }
        }
        '6' {
            $prefs.autoBackup = -not $prefs.autoBackup
            Write-Host "Auto-backup: $($prefs.autoBackup)" -ForegroundColor Green
        }
        '7' {
            $view = Read-Host "Default view [agenda/all/today]"
            if ($view -in @('agenda', 'all', 'today')) {
                $prefs.defaultView = $view
                Write-Host "Default view: $view" -ForegroundColor Green
            } else {
                Write-Host "Invalid view option" -ForegroundColor Red
                return
            }
        }
        default { return }
    }
    
    Save-TaskData $data
}

# === STATISTICS ===

function Show-Statistics {
    $data = Get-TaskData
    $today = (Get-Date).Date
    
    Write-Host "`n=== PRODUCTIVITY STATISTICS ===" -ForegroundColor Cyan
    
    # Task counts
    $pendingCount = @($data.tasks | Where-Object { $_.status -eq 'pending' }).Count
    $completedCount = @($data.completed).Count + @($data.tasks | Where-Object { $_.status -eq 'completed' }).Count
    $totalTasks = $pendingCount + $completedCount
    
    Write-Host "`nTASKS:" -ForegroundColor Yellow
    Write-Host "  Pending: $pendingCount" -ForegroundColor Gray
    Write-Host "  Completed: $completedCount" -ForegroundColor Green
    Write-Host "  Total: $totalTasks" -ForegroundColor White
    
    if ($totalTasks -gt 0) {
        $completionRate = [Math]::Round(($completedCount / $totalTasks) * 100, 1)
        Write-Host "  Completion Rate: $completionRate%" -ForegroundColor Cyan
    }
    
    # Time statistics
    $totalMinutes = ($data.timelogs | Measure-Object minutes -Sum).Sum
    $totalHours = [Math]::Round($totalMinutes / 60, 1)
    
    Write-Host "`nTIME TRACKING:" -ForegroundColor Yellow
    Write-Host "  Total Logged: $totalHours hours" -ForegroundColor Gray
    
    # This week
    $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
    $weekMinutes = ($data.timelogs | Where-Object { 
        [datetime]$_.date -ge $weekStart 
    } | Measure-Object minutes -Sum).Sum
    $weekHours = [Math]::Round($weekMinutes / 60, 1)
    
    Write-Host "  This Week: $weekHours hours" -ForegroundColor Gray
    
    # Project statistics
    $projectCount = @($data.projects).Count
    $activeProjects = @($data.projects | Where-Object {
        $data.tasks | Where-Object { $_.project -eq $_.name -and $_.status -eq 'pending' }
    }).Count
    
    Write-Host "`nPROJECTS:" -ForegroundColor Yellow
    Write-Host "  Total: $projectCount" -ForegroundColor Gray
    Write-Host "  With Active Tasks: $activeProjects" -ForegroundColor Gray
    
    # Most productive project
    $projectTime = $data.timelogs | Group-Object project | 
                   ForEach-Object { 
                       [PSCustomObject]@{ 
                           Project = $_.Name
                           Hours = [Math]::Round(($_.Group | Measure-Object minutes -Sum).Sum / 60, 1)
                       }
                   } | Sort-Object Hours -Descending | Select-Object -First 1
    
    if ($projectTime) {
        Write-Host "  Most Time: $($projectTime.Project) ($($projectTime.Hours)h)" -ForegroundColor Green
    }
}

# === QUICK ENTRY MODE ===

function Start-QuickEntry {
    Write-Host "`n=== QUICK ENTRY MODE ===" -ForegroundColor Cyan
    Write-Host "Enter tasks quickly. Empty line to finish." -ForegroundColor Gray
    Write-Host "Format: task text @project #tag due:tomorrow p1" -ForegroundColor Gray
    Write-Host
    
    $tasks = @()
    $count = 0
    
    do {
        Write-Host "‚ûú " -NoNewline -ForegroundColor Green
        $input = Read-Host
        
        if ($input) {
            $metadata = Extract-Metadata -text $input
            $finalProject = if ($metadata.Project) { $metadata.Project } elseif ($global:CurrentContext) { $global:CurrentContext } else { 'inbox' }
            
            $parsed = @{
                Text = $metadata.CleanText
                Project = $finalProject
                Priority = $metadata.Priority
                Due = $metadata.Due
                EstimatedTime = $metadata.EstimatedTime
                Tags = $metadata.Tags
                CustomFields = $metadata.CustomFields
            }
            
            Add-SmartTask -parsed $parsed
            $tasks += $input
            $count++
            Write-Host "  ‚úì Added" -ForegroundColor DarkGreen
        }
    } while ($input)
    
    if ($count -gt 0) {
        Write-Host "`nAdded $count task$(if($count -ne 1){'s'})" -ForegroundColor Green
        Show-RichAgenda
    }
}

# === MISSING COMMAND IMPLEMENTATIONS ===

function Edit-Configuration {
    Show-ConfigMenu
}

function Clear-Focus {
    Set-CurrentContext -projectName 'inbox'
    Write-Host "Project focus cleared. Back to inbox." -ForegroundColor Green
}

function Show-ContextInfo {
    Write-Host "`n‚ÑπÔ∏è  CURRENT CONTEXT" -ForegroundColor Cyan
    
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        Write-Host "  Active Focus: $global:CurrentContext" -ForegroundColor Yellow
        
        $data = Get-TaskData
        $contextTasks = @($data.tasks | Where-Object { 
            $_.project -eq $global:CurrentContext -and -not $_.done 
        })
        
        Write-Host "  Pending Tasks: $($contextTasks.Count)" -ForegroundColor Gray
        
        if ($contextTasks.Count -gt 0) {
            $overdue = @($contextTasks | Where-Object { 
                $_.due -and [datetime]$_.due -lt (Get-Date).Date 
            }).Count
            $today = @($contextTasks | Where-Object { 
                $_.due -and [datetime]$_.due -eq (Get-Date).Date 
            }).Count
            
            if ($overdue -gt 0) {
                Write-Host "  Overdue: $overdue" -ForegroundColor Red
            }
            if ($today -gt 0) {
                Write-Host "  Due Today: $today" -ForegroundColor Yellow
            }
        }
    } else {
        Write-Host "  No active focus (showing all projects)" -ForegroundColor Gray
    }
    
    Write-Host "`n  Switch focus with: focus <project>" -ForegroundColor DarkGray
    Write-Host "  Clear focus with: focus clear" -ForegroundColor DarkGray
}

function Start-WeeklyReview {
    $data = Get-TaskData
    $today = (Get-Date).Date
    $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
    
    Write-Host "`nüìÖ WEEKLY REVIEW" -ForegroundColor Cyan
    Write-Host "Week of $($weekStart.ToString('yyyy-MM-dd'))" -ForegroundColor Gray
    Write-Host "=" * 50 -ForegroundColor Gray
    
    # This week's accomplishments
    $completedThisWeek = @($data.tasks | Where-Object {
        $_.done -and $_.completed -and
        [datetime]$_.completed -ge $weekStart -and [datetime]$_.completed -lt $weekStart.AddDays(7)
    })
    
    Write-Host "`n‚úÖ ACCOMPLISHMENTS ($($completedThisWeek.Count)):" -ForegroundColor Green
    if ($completedThisWeek.Count -gt 0) {
        $completedThisWeek | ForEach-Object {
            $projectLabel = if ($_.project) { "[$($_.project)]" } else { "[inbox]" }
            Write-Host "  ‚Ä¢ $($_.text) $projectLabel" -ForegroundColor Gray
        }
    } else {
        Write-Host "  No tasks completed this week" -ForegroundColor Yellow
    }
    
    # Incomplete tasks
    $incompleteTasks = @($data.tasks | Where-Object { -not $_.done })
    $overdueTasks = @($incompleteTasks | Where-Object { 
        $_.due -and [datetime]$_.due -lt $today 
    })
    
    Write-Host "`n‚è≥ REVIEW NEEDED:" -ForegroundColor Yellow
    if ($overdueTasks.Count -gt 0) {
        Write-Host "  Overdue Tasks: $($overdueTasks.Count)" -ForegroundColor Red
        $overdueTasks | Select-Object -First 5 | ForEach-Object {
            $daysOverdue = ($today - [datetime]$_.due).Days
            Write-Host "    ‚Ä¢ $($_.text) ($daysOverdue days overdue)" -ForegroundColor Red
        }
    }
    
    # Next week planning
    $nextWeekStart = $weekStart.AddDays(7)
    $nextWeekTasks = @($incompleteTasks | Where-Object {
        $_.due -and [datetime]$_.due -ge $nextWeekStart -and [datetime]$_.due -lt $nextWeekStart.AddDays(7)
    })
    
    Write-Host "`nüéØ NEXT WEEK PLANNING:" -ForegroundColor Blue
    Write-Host "  Scheduled Tasks: $($nextWeekTasks.Count)" -ForegroundColor Gray
    if ($nextWeekTasks.Count -gt 0) {
        $nextWeekTasks | Select-Object -First 5 | ForEach-Object {
            Write-Host "    ‚Ä¢ $($_.text) (due: $($_.due))" -ForegroundColor Gray
        }
    }
    
    # Time tracking summary
    $weekLogs = @($data.timelogs | Where-Object {
        [datetime]$_.date -ge $weekStart -and [datetime]$_.date -lt $weekStart.AddDays(7)
    })
    
    if ($weekLogs.Count -gt 0) {
        $totalHours = [Math]::Round(($weekLogs | Measure-Object minutes -Sum).Sum / 60, 1)
        Write-Host "`n‚è±Ô∏è  TIME SUMMARY:" -ForegroundColor Magenta
        Write-Host "  Total Logged: $totalHours hours" -ForegroundColor Gray
        Write-Host "  Sessions: $($weekLogs.Count)" -ForegroundColor Gray
    }
    
    Write-Host "`n" + ("=" * 50) -ForegroundColor Gray
    Write-Host "Review complete. Plan your next week!" -ForegroundColor Green
}

function Backup-Data {
    $data = Get-TaskData
    $timestamp = (Get-Date).ToString("yyyyMMdd-HHmmss")
    $backupPath = Join-Path $global:DataPath "backup-$timestamp.json"
    
    try {
        $data | ConvertTo-Json -Depth 10 | Out-File $backupPath -Encoding UTF8
        Write-Host "‚úÖ Data backed up to: $backupPath" -ForegroundColor Green
        
        # Keep only last 5 backups
        $backupFiles = Get-ChildItem (Join-Path $global:DataPath "backup-*.json") | 
                       Sort-Object LastWriteTime -Descending | 
                       Select-Object -Skip 5
        
        if ($backupFiles) {
            $backupFiles | Remove-Item
            Write-Host "   Cleaned up $($backupFiles.Count) old backup(s)" -ForegroundColor Gray
        }
    } catch {
        Write-Host "‚ùå Backup failed: $_" -ForegroundColor Red
    }
}

function Clean-CompletedTasks {
    $data = Get-TaskData
    $completedTasks = @($data.tasks | Where-Object { $_.done })
    
    if ($completedTasks.Count -eq 0) {
        Write-Host "No completed tasks to clean" -ForegroundColor Yellow
        return
    }
    
    Write-Host "Found $($completedTasks.Count) completed task(s)" -ForegroundColor Yellow
    Write-Host "Archive completed tasks? (y/N): " -NoNewline -ForegroundColor Red
    $confirm = Read-Host
    
    if ($confirm -eq 'y' -or $confirm -eq 'Y') {
        # Move completed tasks to archive
        if (-not $data.archive) { $data.archive = @() }
        
        $archived = 0
        $data.tasks = @($data.tasks | Where-Object { 
            if ($_.done) {
                $data.archive += $_
                $archived++
                $false
            } else {
                $true
            }
        })
        
        Save-TaskData $data
        Write-Host "‚úÖ Archived $archived completed task(s)" -ForegroundColor Green
        Write-Host "   Tasks moved to archive (use 'show archive' to view)" -ForegroundColor Gray
    } else {
        Write-Host "Cleanup cancelled" -ForegroundColor Yellow
    }
}

function Export-Tasks {
    param($context)
    
    $format = if ($context) { $context.GetArg('format', 'json') } else { 'json' }
    $data = Get-TaskData
    $timestamp = (Get-Date).ToString("yyyyMMdd-HHmmss")
    
    switch ($format.ToLower()) {
        'json' {
            $exportPath = Join-Path $global:DataPath "export-$timestamp.json"
            try {
                $data | ConvertTo-Json -Depth 10 | Out-File $exportPath -Encoding UTF8
                Write-Host "‚úÖ Tasks exported to: $exportPath" -ForegroundColor Green
            } catch {
                Write-Host "‚ùå Export failed: $_" -ForegroundColor Red
            }
        }
        
        'csv' {
            $exportPath = Join-Path $global:DataPath "export-$timestamp.csv"
            try {
                $exportData = $data.tasks | ForEach-Object {
                    [PSCustomObject]@{
                        ID = $_.id
                        Text = $_.text
                        Project = $_.project
                        Priority = $_.priority
                        Due = $_.due
                        Created = $_.created
                        Completed = $_.completed
                        Done = $_.done
                        Tags = ($_.tags -join ';')
                    }
                }
                $exportData | Export-Csv $exportPath -NoTypeInformation -Encoding UTF8
                Write-Host "‚úÖ Tasks exported to: $exportPath" -ForegroundColor Green
            } catch {
                Write-Host "‚ùå CSV export failed: $_" -ForegroundColor Red
            }
        }
        
        default {
            Write-Host "‚ùå Unknown format: $format" -ForegroundColor Red
            Write-Host "Available formats: json, csv" -ForegroundColor Gray
        }
    }
}

function Import-Tasks {
    param($context)
    
    $filePath = if ($context) { $context.GetArg('file', '') } else { '' }
    if (-not $filePath) {
        $filePath = Read-Host "Import file path"
    }
    
    if (-not (Test-Path $filePath)) {
        Write-Host "‚ùå File not found: $filePath" -ForegroundColor Red
        return
    }
    
    try {
        $importData = Get-Content $filePath -Raw | ConvertFrom-Json
        $data = Get-TaskData
        
        if ($importData.tasks) {
            $imported = 0
            $nextId = Get-NextTaskId $data
            
            foreach ($task in $importData.tasks) {
                if (-not $task.id) { $task.id = $nextId++ }
                $data.tasks += $task
                $imported++
            }
            
            Save-TaskData $data
            Write-Host "‚úÖ Imported $imported task(s)" -ForegroundColor Green
        } else {
            Write-Host "‚ùå No tasks found in import file" -ForegroundColor Red
        }
    } catch {
        Write-Host "‚ùå Import failed: $_" -ForegroundColor Red
    }
}

function Redo-Action {
    if (-not $global:RedoStack -or $global:RedoStack.Count -eq 0) {
        Write-Host "Nothing to redo" -ForegroundColor Gray
        return
    }
    $nextState = $global:RedoStack[-1] | ConvertFrom-Json
    if ($global:RedoStack.Count -gt 1) {
        $global:RedoStack = $global:RedoStack[0..($global:RedoStack.Count - 2)]
    } else {
        $global:RedoStack = @()
    }
    # Push current to undo stack then restore
    if ($global:DataCache) {
        $global:UndoStack += ($global:DataCache | ConvertTo-Json -Depth 10)
        $global:UndoStack | ConvertTo-Json -Depth 10 | Set-Content $global:UndoFile -Encoding UTF8
    }
    Save-TaskData -data $nextState -NoUndo
    Write-Host "Redid last action" -ForegroundColor Green
}

function Save-SmartTemplate {
    param($context)
    
    $name = if ($context) { $context.GetArg('name', '') } else { '' }
    $tasks = if ($context) { $context.GetText() } else { '' }
    
    if (-not $name) {
        $name = Read-Host "Template name"
    }
    if (-not $tasks) {
        $tasks = Read-Host "Task definitions (separate with semicolons)"
    }
    
    Save-Template $name $tasks
}

function Apply-SmartTemplate {
    param($context)
    
    $name = if ($context) { $context.GetArg('name', '') } else { '' }
    $project = if ($context) { $context.GetArg('project', $global:CurrentContext) } else { $global:CurrentContext }
    
    if (-not $name) {
        $templates = Get-Templates
        if ($templates.Count -gt 0) {
            Write-Host "Available templates:" -ForegroundColor Yellow
            $templates.Keys | Sort-Object | ForEach-Object {
                Write-Host "  - $_" -ForegroundColor Gray
            }
        }
        $name = Read-Host "Template name"
    }
    
    Use-Template $name $project
}

function Log-ProfessionalTime {
    param($context)
    
    $project = if ($context) { $context.GetArg('project', $global:CurrentContext) } else { $global:CurrentContext }
    $description = if ($context) { $context.GetArg('desc', '') } else { '' }
    $duration = if ($context) { $context.GetArg('duration', '') } else { '' }
    
    if (-not $project) { $project = 'inbox' }
    
    if (-not $description) {
        $description = Read-Host "Work description"
    }
    
    if (-not $duration) {
        $duration = Read-Host "Duration (e.g., 2h, 90m, 1.5h)"
    }
    
    $minutes = Parse-DurationToMinutes $duration
    if ($minutes -le 0) {
        Write-Host "‚ùå Invalid duration format" -ForegroundColor Red
        return
    }
    
    $data = Get-TaskData
    if (-not $data.timelogs) { $data.timelogs = @() }
    
    $timeLog = @{
        project = $project
        description = $description
        date = (Get-Date).ToString("yyyy-MM-dd")
        startTime = (Get-Date).AddMinutes(-$minutes).ToString("yyyy-MM-dd HH:mm:ss")
        endTime = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        minutes = $minutes
        duration = "$([Math]::Floor($minutes / 60))h $($minutes % 60)m"
    }
    
    $data.timelogs += $timeLog
    Save-TaskData $data -NoUndo
    
    Write-Host "‚è±Ô∏è  Time logged successfully" -ForegroundColor Green
    Write-Host "   Project: $project" -ForegroundColor Gray
    Write-Host "   Duration: $($timeLog.duration)" -ForegroundColor Gray
    Write-Host "   Description: $description" -ForegroundColor Gray
}

# Auto-start
if ($MyInvocation.InvocationName -ne '.') {
    Start-TodoistTUI
} else {
    Write-Host "Enhanced Todoist TUI loaded. Run 'Start-TodoistTUI' to begin." -ForegroundColor Cyan
}
