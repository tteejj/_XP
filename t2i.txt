# Enhanced PowerShell Todoist TUI - Professional Version
# Rich display, smart completions, full feature implementation

# === GLOBAL CONFIGURATION ===
$global:TaskFile = Join-Path $PSScriptRoot "tasks.json"
$global:BackupFile = Join-Path $PSScriptRoot "tasks.bak"
$global:UndoFile = Join-Path $PSScriptRoot "tasks.undo"
$global:ConfigFile = Join-Path $PSScriptRoot "config.json"
$global:LastShownTaskMap = @{}
$global:CurrentContext = "inbox"
$global:LastAction = $null
$global:SessionStats = @{
    TasksAdded = 0
    TasksCompleted = 0
    TimeLogged = 0
    CommandsRun = 0
    SessionStart = Get-Date
}

# === CONFIGURATION MANAGER ===
class ConfigManager {
    static [hashtable] $Config = @{
        Colors = @{
            Overdue = "Red"
            Today = "Yellow"
            Tomorrow = "Cyan"
            Upcoming = "Green"
            Priority1 = "Magenta"
            Priority2 = "Yellow"
            Priority3 = "Blue"
            Project = "DarkCyan"
            Context = "Cyan"
            TimeLog = "Blue"
        }
        Display = @{
            MaxTasksPerSection = 10
            ShowEmptyProjects = $false
            ShowCompletedInReports = $true
            DateFormat = "ddd MM/dd"
            Use24Hour = $false
            CompactMode = $false
        }
        Behavior = @{
            AutoArchiveAfterDays = 30
            DefaultDueDateDays = 7
            WarnBeforeDelete = $true
            ShowWelcome = $true
            EnableNotifications = $false
        }
        Shortcuts = @{
            't' = 'today'
            'tm' = 'tomorrow'
            'nd' = 'noduedate'
            'od' = 'overdue'
        }
    }
    
    static [void] Load() {
        if (Test-Path $global:ConfigFile) {
            $saved = Get-Content $global:ConfigFile -Raw | ConvertFrom-Json
            # Merge saved config with defaults
            foreach ($key in $saved.PSObject.Properties) {
                [ConfigManager]::Config[$key.Name] = $key.Value
            }
        }
    }
    
    static [void] Save() {
        [ConfigManager]::Config | ConvertTo-Json -Depth 10 | Set-Content $global:ConfigFile
    }
}

# === INITIALIZE DATA STORAGE ===
if (-not (Test-Path $global:TaskFile)) {
    @{
        tasks = @()
        lastId = 0
        deleted = @()
        completed = @()
        projects = @( 
            @{ 
                name = 'inbox'
                description = 'Default inbox for uncategorized tasks'
                color = 'Gray'
                icon = '📥'
                sortOrder = 0
                isArchived = $false
                settings = @{}
            },
            @{
                name = 'personal'
                description = 'Personal tasks and reminders'
                color = 'Green'
                icon = '🏠'
                sortOrder = 1
                isArchived = $false
            },
            @{
                name = 'work'
                description = 'Work-related tasks'
                color = 'Blue'
                icon = '💼'
                sortOrder = 2
                isArchived = $false
            }
        )
        timelogs = @()
        currentContext = 'inbox'
        templates = @{}
        labels = @('urgent', 'waiting', 'someday', 'reference')
        customFields = @{}
        recurringTemplates = @()
        blockedTasks = @()
        dependencies = @()
        notes = @{}
        attachments = @{}
        activityLog = @()
    } | ConvertTo-Json -Depth 10 | Set-Content $global:TaskFile
}

# === ENHANCED DATA FUNCTIONS WITH CACHING & UNDO ===

# Global state for caching, undo, and context
$global:DataCache = $null
$global:CacheTimestamp = 0
$global:UndoStack = @()
$global:MaxUndoLevels = 10
$global:LastShownTaskMap = @{}
$global:CurrentContext = 'inbox'

function Get-TaskData { 
    param([switch]$ForceRefresh)
    
    if (-not (Test-Path $global:TaskFile)) {
        return $null
    }
    
    $currentTimestamp = (Get-Item $global:TaskFile).LastWriteTime.Ticks
    
    if ($ForceRefresh -or -not $global:DataCache -or $global:CacheTimestamp -ne $currentTimestamp) {
        try {
            $global:DataCache = Get-Content $global:TaskFile -Raw | ConvertFrom-Json
            $global:CacheTimestamp = $currentTimestamp
            
            # Ensure all required properties exist
            $requiredProps = @{
                'activityLog' = @()
                'dependencies' = @()
                'projects' = @(@{
                    name = 'inbox'
                    description = 'Default project'
                    aliases = @('i', 'in')
                })
                'timelogs' = @()
                'currentContext' = 'inbox'
                'templates' = @{}
                'preferences' = @{
                    agendaShowOverdue = $true
                    agendaShowToday = $true  
                    agendaShowUpcoming = $true
                    agendaShowTimeToday = $true
                    agendaDaysAhead = 3
                    autoBackup = $true
                    defaultView = 'agenda'
                    generateRecurring = $true
                    maxSearchResults = 50
                }
                'deleted' = @()
                'completed' = @()
                'lastUsedProject' = $null
            }
            
            foreach ($prop in $requiredProps.GetEnumerator()) {
                if (-not $global:DataCache.PSObject.Properties[$prop.Key]) {
                    $global:DataCache | Add-Member -MemberType NoteProperty -Name $prop.Key -Value $prop.Value
                }
            }
            
            # Set global context from data
            if ($global:DataCache.currentContext) {
                $global:CurrentContext = $global:DataCache.currentContext
            }
            
        } catch {
            Write-Error "Failed to load data: $_"
            if (Test-Path $global:BackupFile) {
                Write-Host "Attempting to restore from backup..." -ForegroundColor Yellow
                Copy-Item $global:BackupFile $global:TaskFile -Force
                $global:DataCache = Get-Content $global:TaskFile -Raw | ConvertFrom-Json
            }
        }
    }
    
    return $global:DataCache
}

function Save-TaskData($data, [switch]$NoUndo) {
    # Save to undo stack unless explicitly told not to
    if (-not $NoUndo -and $global:DataCache) {
        $global:UndoStack += $global:DataCache | ConvertTo-Json -Depth 10
        if ($global:UndoStack.Count -gt $global:MaxUndoLevels) {
            $global:UndoStack = $global:UndoStack[-$global:MaxUndoLevels..-1]
        }
        
        # Persist undo stack
        if ($global:UndoStack.Count -gt 0) {
            $global:UndoStack | ConvertTo-Json -Depth 10 | Set-Content $global:UndoFile -Encoding UTF8
        }
    }
    
    # Add activity log entry
    if (-not $data.activityLog) {
        $data | Add-Member -MemberType NoteProperty -Name activityLog -Value @()
    }
    
    $data.activityLog += @{
        timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        action = $global:LastAction
        user = $env:USERNAME
    }
    
    # Keep only last 1000 activity entries
    if ($data.activityLog.Count -gt 1000) {
        $data.activityLog = $data.activityLog[-1000..-1]
    }
    
    $tempFile = "$($global:TaskFile).tmp"
    
    try {
        # Create backup before saving
        if ($data.preferences -and $data.preferences.autoBackup -and (Test-Path $global:TaskFile)) {
            Copy-Item $global:TaskFile $global:BackupFile -Force
        }
        
        $data | ConvertTo-Json -Depth 10 | Set-Content -Path $tempFile -Encoding UTF8
        Move-Item -Path $tempFile -Destination $global:TaskFile -Force
        
        # Update cache
        $global:DataCache = $data
        $global:CacheTimestamp = (Get-Item $global:TaskFile).LastWriteTime.Ticks
    }
    catch {
        Write-Error "Failed to save: $_"
    }
    finally {
        if (Test-Path $tempFile) { 
            Remove-Item $tempFile -ErrorAction SilentlyContinue 
        }
    }
}

# === CORE UTILITY FUNCTIONS ===

function Undo-LastAction {
    if (-not (Test-Path $global:UndoFile)) {
        $global:UndoStack = @()
    } else {
        $global:UndoStack = Get-Content $global:UndoFile -Raw | ConvertFrom-Json
    }
    
    if ($global:UndoStack.Count -eq 0) {
        Write-Host "Nothing to undo" -ForegroundColor Gray
        return
    }
    
    $previousState = $global:UndoStack[-1] | ConvertFrom-Json
    $global:UndoStack = $global:UndoStack[0..($global:UndoStack.Count - 2)]
    
    # Save without adding to undo stack
    Save-TaskData -data $previousState -NoUndo
    
    # Update undo file
    if ($global:UndoStack.Count -gt 0) {
        $global:UndoStack | ConvertTo-Json -Depth 10 | Set-Content $global:UndoFile -Encoding UTF8
    } else {
        Remove-Item $global:UndoFile -ErrorAction SilentlyContinue
    }
    
    Write-Host "Undid last action" -ForegroundColor Green
}

function Set-CurrentContext {
    param([string]$projectName)
    
    $global:CurrentContext = $projectName
    $data = Get-TaskData
    $data.currentContext = $projectName
    Save-TaskData $data
}

function Get-ContextPrompt {
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        return "Suite ($global:CurrentContext)> "
    }
    return "Suite> "
}

function Resolve-TaskIds {
    param([string]$inputString)
    
    $globalIds = @()
    $parts = $inputString -split '[,\s]+' | Where-Object { $_ }
    
    foreach ($part in $parts) {
        if ($part -match '^(\d+)-(\d+)$') {
            # Range support
            $start = [int]$matches[1]
            $end = [int]$matches[2]
            
            for ($i = $start; $i -le $end; $i++) {
                if ($global:LastShownTaskMap.ContainsKey($i)) {
                    $globalIds += $global:LastShownTaskMap[$i]
                } else {
                    $globalIds += $i  # Assume global ID
                }
            }
        }
        elseif ($part -match '^\d+$') {
            $localId = [int]$part
            
            # Check if it's a local ID from the last display
            if ($global:LastShownTaskMap.ContainsKey($localId)) {
                $globalIds += $global:LastShownTaskMap[$localId]
            } else {
                $globalIds += $localId  # Treat as global ID
            }
        }
    }
    
    return $globalIds | Select-Object -Unique
}

function Parse-DurationToMinutes {
    param([string]$duration)
    
    if ($duration -match '^(\d+(?:\.\d+)?)([mh])$') {
        $value = [double]$matches[1]
        if ($matches[2] -eq 'h') { 
            return [int]($value * 60) 
        } else { 
            return [int]$value 
        }
    }
    
    return 0
}

function Parse-DateRange {
    param([string]$range)
    
    $today = (Get-Date).Date
    $result = @{ Start = $null; End = $null; Display = "" }
    
    switch -Regex ($range.ToLower()) {
        '^today$' {
            $result.Start = $today
            $result.End = $today.AddDays(1)
            $result.Display = "today"
        }
        '^yesterday$' {
            $result.Start = $today.AddDays(-1)
            $result.End = $today
            $result.Display = "yesterday"
        }
        '^this week$|^week$' {
            $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
            $result.Start = $weekStart
            $result.End = $weekStart.AddDays(7)
            $result.Display = "this week"
        }
        '^last week$' {
            $lastWeekStart = $today.AddDays(-[int]$today.DayOfWeek - 7)
            $result.Start = $lastWeekStart
            $result.End = $lastWeekStart.AddDays(7)
            $result.Display = "last week"
        }
        '^this month$|^month$' {
            $result.Start = Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0
            $result.End = $result.Start.AddMonths(1)
            $result.Display = "this month"
        }
        '^last month$' {
            $firstOfMonth = Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0
            $result.Start = $firstOfMonth.AddMonths(-1)
            $result.End = $firstOfMonth
            $result.Display = "last month"
        }
        '(\d{4}-\d{2}-\d{2})\s+to\s+(\d{4}-\d{2}-\d{2})' {
            $result.Start = [datetime]$matches[1]
            $result.End = ([datetime]$matches[2]).AddDays(1)
            $result.Display = "$($matches[1]) to $($matches[2])"
        }
        '^\d{4}-\d{2}-\d{2}$' {
            $result.Start = [datetime]$range
            $result.End = $result.Start.AddDays(1)
            $result.Display = $range
        }
        default {
            $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
            $result.Start = $weekStart
            $result.End = $weekStart.AddDays(7)
            $result.Display = "this week (default)"
        }
    }
    
    return $result
}

function Extract-Metadata {
    param([string]$text)
    
    $result = @{
        CleanText = $text
        Project = $null
        Priority = 0
        Due = $null
        Duration = $null
        EstimatedTime = $null
        Tags = @()
        CustomFields = @{}
        Recur = $null
        RecurUntil = $null
        DependsOn = @()
    }
    
    $cleanText = $text
    
    # Extract @project (anywhere in string)
    if ($cleanText -match '@(\S+)') {
        $result.Project = $matches[1]
        $cleanText = $cleanText -replace '@\S+', ''
    }
    
    # Extract priority markers
    if ($cleanText -match '\s*(p1|!!!)(?:\s|$)') { 
        $result.Priority = 1
        $cleanText = $cleanText -replace '\s*(p1|!!!)(?:\s|$)', ' '
    }
    elseif ($cleanText -match '\s*(p2|!!)(?:\s|$)') { 
        $result.Priority = 2
        $cleanText = $cleanText -replace '\s*(p2|!!)(?:\s|$)', ' '
    }
    elseif ($cleanText -match '\s*(p3|!)(?:\s|$)') { 
        $result.Priority = 3
        $cleanText = $cleanText -replace '\s*(p3|!)(?:\s|$)', ' '
    }
    
    # Extract time duration (for logging)
    if ($cleanText -match '\s+(for|took):(\d+(?:\.\d+)?[hm])(?:\s|$)') {
        $result.Duration = $matches[2]
        $cleanText = $cleanText -replace '\s+(for|took):\d+(?:\.\d+)?[hm](?:\s|$)', ' '
    }
    
    # Extract estimated time
    if ($cleanText -match '\s+est:(\d+(?:\.\d+)?[hm])(?:\s|$)') {
        $result.EstimatedTime = $matches[1]
        $cleanText = $cleanText -replace '\s+est:\d+(?:\.\d+)?[hm](?:\s|$)', ' '
    }
    
    # Extract due date
    if ($cleanText -match '\s+due:(\S+)(?:\s|$)') {
        $result.Due = $matches[1]
        $cleanText = $cleanText -replace '\s+due:\S+(?:\s|$)', ' '
    }
    
    # Extract recurrence
    if ($cleanText -match '\s+recur:(\S+)(?:\s|$)') {
        $result.Recur = $matches[1]
        $cleanText = $cleanText -replace '\s+recur:\S+(?:\s|$)', ' '
    }
    
    # Extract recurrence end
    if ($cleanText -match '\s+until:(\S+)(?:\s|$)') {
        $result.RecurUntil = $matches[1]
        $cleanText = $cleanText -replace '\s+until:\S+(?:\s|$)', ' '
    }
    
    # Extract dependencies
    while ($cleanText -match '\s+depends:(\d+)(?:\s|$)') {
        $result.DependsOn += [int]$matches[1]
        $cleanText = $cleanText -replace '\s+depends:\d+(?:\s|$)', ' '
    }
    
    # Extract custom fields (key:value)
    while ($cleanText -match '\s+(\w+):([^\s:]+)(?:\s|$)') {
        $key = $matches[1]
        if ($key -notin @('for', 'took', 'est', 'due', 'recur', 'until', 'depends')) {
            $result.CustomFields[$key] = $matches[2]
            $cleanText = $cleanText -replace ("\s+$([regex]::Escape($key)):[^\s:]+(?:\s|$)"), ' '
        }
    }
    
    # Extract hashtags
    while ($cleanText -match '\s+#(\w+)(?:\s|$)') {
        $result.Tags += $matches[1]
        $cleanText = $cleanText -replace '\s+#\w+(?:\s|$)', ' '
    }
    
    # Clean up whitespace
    $result.CleanText = $cleanText.Trim() -replace '\s+', ' '
    
    return $result
}

# === ROBUST COMPLETION SYSTEM ===

# Completion modes - finite state machine
enum CompletionMode {
    Command          # Completing command names (add, done, proj)
    Subcommand      # Completing subcommands (proj add, timer start)
    SyntaxDiscovery # Showing argument syntax patterns (@, p1, due:)
    PrefixCompletion # Completing within a prefix (@projects, due:dates)
    FreeText        # No completions available
    Help           # Showing help/syntax guidance
}

# Comprehensive completion state
class CompletionState {
    # Current parsing state
    [string] $OriginalBuffer = ""
    [string] $CurrentCommand = ""          # Legacy - use FullCommandName instead
    [array] $CompletedArguments = @()      # Legacy - use ParsedArguments instead
    [string] $CurrentToken = ""
    [bool] $TokenComplete = $false
    [int] $CursorPosition = 0
    
    # Enhanced parsing state (Phase 2)
    [string] $FullCommandName = ""         # Complete resolved command name
    [array] $ArgumentTokens = @()          # Array of ParsedToken objects for arguments
    [ParsedToken] $TokenUnderCursor = $null   # Token at cursor position
    [bool] $IsOnNewWord = $false           # True if cursor is on a new word position
    [hashtable] $ParsedArguments = @{}     # Structured argument parsing
    
    # Completion mode and context
    [CompletionMode] $Mode = [CompletionMode]::Command
    [string] $PrefixBeingCompleted = ""
    [array] $AvailableCompletions = @()
    [hashtable] $ParsedContext = @{}
    
    # State management with deep copy support
    [CompletionState] Clone() {
        $clone = [CompletionState]::new()
        
        # Copy legacy properties
        $clone.OriginalBuffer = $this.OriginalBuffer
        $clone.CurrentCommand = $this.CurrentCommand
        $clone.CompletedArguments = @($this.CompletedArguments)  # New array, same references
        $clone.CurrentToken = $this.CurrentToken
        $clone.TokenComplete = $this.TokenComplete
        $clone.CursorPosition = $this.CursorPosition
        
        # Copy enhanced properties (Phase 2)
        $clone.FullCommandName = $this.FullCommandName
        $clone.ArgumentTokens = @($this.ArgumentTokens)  # New array, same token references
        $clone.TokenUnderCursor = $this.TokenUnderCursor  # Reference copy is fine for immutable tokens
        $clone.IsOnNewWord = $this.IsOnNewWord
        $clone.ParsedArguments = @{}  # Create new hashtable
        if ($this.ParsedArguments) {
            foreach ($key in $this.ParsedArguments.Keys) {
                $clone.ParsedArguments[$key] = $this.ParsedArguments[$key]
            }
        }
        
        # Copy completion context
        $clone.Mode = $this.Mode
        $clone.PrefixBeingCompleted = $this.PrefixBeingCompleted
        $clone.AvailableCompletions = @($this.AvailableCompletions)  # New array
        $clone.ParsedContext = @{}  # Create new hashtable
        if ($this.ParsedContext) {
            foreach ($key in $this.ParsedContext.Keys) {
                $clone.ParsedContext[$key] = $this.ParsedContext[$key]
            }
        }
        
        return $clone
    }
    
    [void] Reset() {
        # Reset legacy properties
        $this.OriginalBuffer = ""
        $this.CurrentCommand = ""
        $this.CompletedArguments = @()
        $this.CurrentToken = ""
        $this.TokenComplete = $false
        $this.CursorPosition = 0
        
        # Reset enhanced properties (Phase 2)
        $this.FullCommandName = ""
        $this.ArgumentTokens = @()
        $this.TokenUnderCursor = $null
        $this.IsOnNewWord = $false
        $this.ParsedArguments = @{}
        
        # Reset completion context
        $this.Mode = [CompletionMode]::Command
        $this.PrefixBeingCompleted = ""
        $this.AvailableCompletions = @()
        $this.ParsedContext = @{}
    }
}

# Token with position information
class ParsedToken {
    [string] $Text = ""
    [int] $StartPos = 0
    [int] $EndPos = 0
    [bool] $IsComplete = $true
    [string] $Type = "Unknown"  # Command, Argument, Prefix, etc.
    
    ParsedToken([string] $text, [int] $start, [int] $end) {
        $this.Text = $text
        $this.StartPos = $start
        $this.EndPos = $end
    }
}

# Completion item with rich metadata
class CompletionItem {
    [string] $Text = ""
    [string] $Description = ""
    [string] $Category = ""
    [string] $Type = ""
    [int] $Score = 0
    [hashtable] $Metadata = @{}
    
    CompletionItem([string] $text, [string] $description, [string] $category, [int] $score) {
        $this.Text = $text
        $this.Description = $description
        $this.Category = $category
        $this.Score = $score
    }
}

# Command execution context - wrapper around CompletionState for command handlers
class CommandContext {
    [string] $CommandName = ""           # The resolved command name (e.g., "add", "proj add")
    [hashtable] $Args = @{}              # Structured arguments (e.g., @{project="work"; priority=1})
    [string[]] $FreeText = @()           # Non-argument text tokens
    [string] $RawText = ""               # Clean remaining text after argument extraction
    [CompletionState] $State = $null     # Full parser state for advanced use cases
    [object] $Parser = $null             # Reference to parser for schema access
    
    # Validation properties
    [string[]] $ValidationErrors = @()   # List of validation error messages
    [string[]] $ValidationWarnings = @() # List of validation warnings
    [bool] $IsValid = $true              # True if no validation errors
    
    # Constructor from CompletionState and Parser
    CommandContext([CompletionState] $state, [object] $parser) {
        $this.State = $state
        $this.Parser = $parser
        $this.CommandName = $state.FullCommandName
        $this.ParseArguments()
        $this.ValidateCommand()  # Validate after parsing arguments
    }
    
    # Legacy constructor for backward compatibility
    CommandContext([CompletionState] $state) {
        $this.State = $state
        $this.CommandName = $state.FullCommandName
        $this.ParseArguments()
        $this.ValidateCommand()  # Validate after parsing arguments
    }
    
    # Parse ArgumentTokens into structured Args and FreeText
    [void] ParseArguments() {
        $this.Args = @{}
        $freeTextTokens = @()
        
        foreach ($token in $this.State.ArgumentTokens) {
            $text = $token.Text
            
            # Project arguments (@project)
            if ($text -match '^@(.+)$') {
                $this.Args['project'] = $matches[1]
            }
            # Priority arguments (p1, p2, p3, !, !!, !!!)
            elseif ($text -match '^p([123])$') {
                $this.Args['priority'] = [int]$matches[1]
            }
            elseif ($text -eq '!') {
                $this.Args['priority'] = 1
            }
            elseif ($text -eq '!!') {
                $this.Args['priority'] = 2
            }
            elseif ($text -eq '!!!') {
                $this.Args['priority'] = 3
            }
            # Due date arguments (due:date)
            elseif ($text -match '^due:(.+)$') {
                $this.Args['due'] = $matches[1]
            }
            # Estimate arguments (est:time)
            elseif ($text -match '^est:(.+)$') {
                $this.Args['estimate'] = $matches[1]
            }
            # Tag arguments (#tag)
            elseif ($text -match '^#(.+)$') {
                if (-not $this.Args.ContainsKey('tags')) {
                    $this.Args['tags'] = @()
                }
                $this.Args['tags'] += $matches[1]
            }
            # Recurrence arguments (recur:pattern)
            elseif ($text -match '^recur:(.+)$') {
                $this.Args['recur'] = $matches[1]
            }
            # Dependency arguments (dep:id)
            elseif ($text -match '^dep:(.+)$') {
                if (-not $this.Args.ContainsKey('dependencies')) {
                    $this.Args['dependencies'] = @()
                }
                $this.Args['dependencies'] += $matches[1]
            }
            # Everything else is free text
            else {
                $freeTextTokens += $text
            }
        }
        
        $this.FreeText = $freeTextTokens
        $this.RawText = ($freeTextTokens -join ' ').Trim()
    }
    
    # Helper methods for common operations
    [bool] HasArg([string] $name) {
        return $this.Args.ContainsKey($name)
    }
    
    [object] GetArg([string] $name, [object] $default = $null) {
        if ($this.Args.ContainsKey($name)) {
            return $this.Args[$name]
        }
        return $default
    }
    
    [string] GetProject() {
        return $this.GetArg('project', $global:CurrentContext)
    }
    
    [int] GetPriority() {
        return $this.GetArg('priority', 0)
    }
    
    [string[]] GetTags() {
        return $this.GetArg('tags', @())
    }
    
    [string] GetText() {
        return $this.RawText
    }
    
    # Validation methods
    [void] AddError([string] $message) {
        $this.ValidationErrors += $message
        $this.IsValid = $false
    }
    
    [void] AddWarning([string] $message) {
        $this.ValidationWarnings += $message
    }
    
    [void] ValidateCommand() {
        # Use schema-based validation if available
        if ($this.Parser -and $this.Parser.CommandSchemas -and $this.Parser.CommandSchemas.ContainsKey($this.CommandName)) {
            $this.ValidateWithSchema($this.Parser.CommandSchemas[$this.CommandName])
        } else {
            # Fall back to legacy validation
            $this.ValidateWithoutSchema()
        }
    }
    
    [void] ValidateWithSchema([CommandSchema] $schema) {
        # Validate required arguments
        foreach ($argSchema in $schema.Arguments) {
            if ($argSchema.Required) {
                if ($argSchema.Type -eq "text") {
                    # Text arguments are validated by checking FreeText
                    if ($this.FreeText.Count -eq 0 -or [string]::IsNullOrWhiteSpace($this.GetText())) {
                        $this.AddError("$($argSchema.Description) is required")
                    }
                } elseif (-not $this.HasArg($argSchema.Name)) {
                    $this.AddError("$($argSchema.Description) is required")
                }
            }
        }
        
        # Validate argument patterns and values
        foreach ($argName in $this.Args.Keys) {
            $argSchema = $schema.GetArgumentSchema($argName)
            if ($argSchema) {
                $value = $this.Args[$argName]
                
                # Pattern validation
                if ($argSchema.Pattern -and $value -notmatch $argSchema.Pattern) {
                    $this.AddError("Invalid format for $($argSchema.Name): '$value'. Expected format: $($argSchema.Example)")
                }
                
                # Valid values validation
                if ($argSchema.ValidValues.Count -gt 0 -and $value -notin $argSchema.ValidValues) {
                    $validStr = $argSchema.ValidValues -join ", "
                    $this.AddError("Invalid value for $($argSchema.Name): '$value'. Valid values: $validStr")
                }
            }
        }
    }
    
    [void] ValidateWithoutSchema() {
        # Legacy validation for backward compatibility
        switch ($this.CommandName) {
            'add' {
                # Add command validation
                if ([string]::IsNullOrWhiteSpace($this.GetText())) {
                    $this.AddError("Task description is required")
                }
                
                # Check for conflicting priority arguments
                if ($this.HasArg('priority')) {
                    $priority = $this.GetArg('priority', 0)
                    if ($priority -lt 0 -or $priority -gt 3) {
                        $this.AddError("Priority must be between 0 and 3 (p1=high, p2=med, p3=low)")
                    }
                }
                
                # Validate due date format if provided
                if ($this.HasArg('due')) {
                    $dueStr = $this.GetArg('due', '')
                    if (-not [string]::IsNullOrEmpty($dueStr)) {
                        # Try to parse the date to validate it
                        try {
                            $null = Parse-SmartDate $dueStr
                        } catch {
                            $this.AddError("Invalid due date format: '$dueStr'. Use formats like 'today', 'tomorrow', '+3d', or '2024-12-25'")
                        }
                    }
                }
                
                # Validate time estimate format
                if ($this.HasArg('estimate')) {
                    $estStr = $this.GetArg('estimate', '')
                    if (-not ($estStr -match '^\d+(\.\d+)?[hm]$')) {
                        $this.AddError("Invalid time estimate format: '$estStr'. Use formats like '2h', '30m', or '1.5h'")
                    }
                }
                
                # Check for empty project name
                if ($this.HasArg('project')) {
                    $proj = $this.GetArg('project', '')
                    if ([string]::IsNullOrWhiteSpace($proj)) {
                        $this.AddError("Project name cannot be empty")
                    }
                }
            }
            
            'proj add' {
                # Project creation validation
                if ([string]::IsNullOrWhiteSpace($this.GetText())) {
                    $this.AddError("Project name is required")
                }
            }
            
            'dep add' {
                # Dependency validation - need two task IDs
                $argCount = $this.FreeText.Count
                if ($argCount -lt 2) {
                    $this.AddError("Dependency requires two task IDs: dep add <task> <depends-on>")
                } elseif ($argCount -gt 2) {
                    $this.AddWarning("Extra arguments ignored. Usage: dep add <task> <depends-on>")
                }
            }
        }
    }
    
    [void] ShowValidationErrors() {
        if ($this.ValidationErrors.Count -gt 0) {
            Write-Host "  ❌ VALIDATION ERRORS:" -ForegroundColor Red
            foreach ($error in $this.ValidationErrors) {
                Write-Host "     • $error" -ForegroundColor Red
            }
            Write-Host ""
        }
        
        if ($this.ValidationWarnings.Count -gt 0) {
            Write-Host "  ⚠️  WARNINGS:" -ForegroundColor Yellow
            foreach ($warning in $this.ValidationWarnings) {
                Write-Host "     • $warning" -ForegroundColor Yellow
            }
            Write-Host ""
        }
    }
}

# Argument schema system for command validation and smart completions
class ArgumentSchema {
    [string] $Name = ""              # Argument name (e.g., "project", "priority", "due")
    [string] $Type = ""              # Argument type (e.g., "project", "priority", "date", "text")
    [string] $Prefix = ""            # Required prefix (e.g., "@", "due:", "#")
    [bool] $Required = $false        # Whether this argument is required
    [string[]] $ValidValues = @()    # Valid values for enum-type arguments
    [string] $Pattern = ""           # Regex pattern for validation
    [string] $Description = ""       # Human-readable description
    [string] $Example = ""           # Example usage
}

class CommandSchema {
    [string] $CommandName = ""       # The command this schema applies to
    [ArgumentSchema[]] $Arguments = @() # Array of argument schemas
    [string] $Description = ""       # Command description
    [string] $Syntax = ""           # Syntax example
    
    # Helper to get schema for a specific argument
    [ArgumentSchema] GetArgumentSchema([string] $argName) {
        return $this.Arguments | Where-Object { $_.Name -eq $argName } | Select-Object -First 1
    }
    
    # Get all argument schemas by type
    [ArgumentSchema[]] GetArgumentsByType([string] $type) {
        return $this.Arguments | Where-Object { $_.Type -eq $type }
    }
}

class SmartCommandParser {
    [hashtable] $Commands = @{}
    [hashtable] $Aliases = @{}
    [hashtable] $CommandSchemas = @{}     # Command argument schemas
    [CompletionState] $CurrentState = [CompletionState]::new()
    [object] $CachedData = $null
    [datetime] $CacheTime = [datetime]::MinValue
    
    SmartCommandParser() {
        $this.InitializeCommands()
        $this.InitializeAliases()
        $this.InitializeCommandSchemas()
    }
    
    [void] InitializeCommands() {
        $this.Commands = @{
            # === VIEW COMMANDS (Enhanced) ===
            'agenda' = @{
                Handler = { Show-RichAgenda }
                Description = "Smart agenda with calendar integration"
                Category = "View"
            }
            'today' = @{
                Handler = { Show-FilteredTasks @{Filter='today'} }
                Description = "Tasks due today"
                Category = "View"
            }
            'tomorrow' = @{
                Handler = { Show-FilteredTasks @{Filter='tomorrow'} }
                Description = "Tasks due tomorrow"
                Category = "View"
            }
            'week' = @{
                Handler = { Show-WeekView }
                Description = "Week calendar view"
                Category = "View"
            }
            'month' = @{
                Handler = { Show-MonthView }
                Description = "Month calendar view"
                Category = "View"
            }
            'overdue' = @{
                Handler = { Show-FilteredTasks @{Filter='overdue'} }
                Description = "Overdue tasks"
                Category = "View"
            }
            'upcoming' = @{
                Handler = { Show-FilteredTasks @{Filter='upcoming'} }
                Description = "Next 7 days"
                Category = "View"
            }
            'noduedate' = @{
                Handler = { Show-FilteredTasks @{Filter='noduedate'} }
                Description = "Tasks without due dates"
                Category = "View"
            }
            'priority' = @{
                Handler = { param($context) Show-FilteredTasks @{Priority=$context.GetText()} }
                Description = "Filter by priority (1-3)"
                Category = "View"
                NeedsArg = $true
            }
            'search' = @{
                Handler = { param($context) Show-FilteredTasks @{Search=$context.GetText()} }
                Description = "Search tasks"
                Category = "View"
                NeedsArg = $true
            }
            'blocked' = @{
                Handler = { Show-BlockedTasks }
                Description = "Tasks with unmet dependencies"
                Category = "View"
            }
            
            # === PROJECT COMMANDS (Enhanced) ===
            'proj' = @{
                Handler = { Show-ProjectDashboard }
                Description = "Project dashboard with stats"
                Category = "Project"
            }
            'proj add' = @{
                Handler = { param($context) Add-Project $context }
                Description = "Create new project"
                Category = "Project"
                NeedsArg = $true
            }
            'proj rename' = @{
                Handler = { param($context) Rename-Project $context }
                Description = "Rename project"
                Category = "Project"
                NeedsArg = $true
            }
            'proj archive' = @{
                Handler = { param($context) Archive-Project $context }
                Description = "Archive project"
                Category = "Project"
                NeedsArg = $true
            }
            'proj delete' = @{
                Handler = { param($context) Delete-Project $context }
                Description = "Delete project (requires confirmation)"
                Category = "Project"
                NeedsArg = $true
            }
            'proj stats' = @{
                Handler = { param($context) Show-ProjectStats $context }
                Description = "Detailed project statistics"
                Category = "Project"
            }
            
            # === TASK MANAGEMENT (Enhanced) ===
            'add' = @{
                Handler = { param($context) Add-SmartTask $context }
                Description = "Add task with natural language"
                Category = "Task"
                NeedsArg = $true
            }
            'done' = @{
                Handler = { param($context) Complete-SmartTasks $context }
                Description = "Complete tasks (supports ranges)"
                Category = "Task"
                NeedsArg = $true
            }
            'delete' = @{
                Handler = { param($context) Delete-SmartTasks $context }
                Description = "Delete tasks with confirmation"
                Category = "Task"
                NeedsArg = $true
            }
            'update' = @{
                Handler = { param($context) Update-SmartTask $context }
                Description = "Update task properties"
                Category = "Task"
                NeedsArg = $true
            }
            'postpone' = @{
                Handler = { param($context) Postpone-Task $context }
                Description = "Postpone task by N days"
                Category = "Task"
                NeedsArg = $true
            }
            'duplicate' = @{
                Handler = { param($context) Duplicate-Task $context }
                Description = "Duplicate existing task"
                Category = "Task"
                NeedsArg = $true
            }
            'move' = @{
                Handler = { param($context) Move-Task $context }
                Description = "Move task to different project"
                Category = "Task"
                NeedsArg = $true
            }
            'note' = @{
                Handler = { param($context) Add-TaskNote $context }
                Description = "Add note to task"
                Category = "Task"
                NeedsArg = $true
            }
            
            # === TIME TRACKING (Professional) ===
            'log' = @{
                Handler = { param($context) Log-ProfessionalTime $context }
                Description = "Log time with smart parsing"
                Category = "Time"
                NeedsArg = $true
            }
            'timer start' = @{
                Handler = { param($context) Start-Timer $context }
                Description = "Start time tracking"
                Category = "Time"
            }
            'timer stop' = @{
                Handler = { Stop-Timer }
                Description = "Stop and log current timer"
                Category = "Time"
            }
            'timer status' = @{
                Handler = { Show-TimerStatus }
                Description = "Show running timer"
                Category = "Time"
            }
            'report' = @{
                Handler = { param($context) Show-ProfessionalReport $context }
                Description = "Time report with charts"
                Category = "Time"
            }
            'report detailed' = @{
                Handler = { param($context) Show-DetailedReport $context }
                Description = "Detailed time breakdown"
                Category = "Time"
            }
            
            # === TEMPLATES & AUTOMATION ===
            'template save' = @{
                Handler = { param($context) Save-SmartTemplate $context }
                Description = "Save current view as template"
                Category = "Template"
                NeedsArg = $true
            }
            'template apply' = @{
                Handler = { param($context) Apply-SmartTemplate $context }
                Description = "Apply saved template"
                Category = "Template"
                NeedsArg = $true
            }
            'template list' = @{
                Handler = { Show-Templates }
                Description = "List all templates"
                Category = "Template"
            }
            'recurring add' = @{
                Handler = { param($context) Add-RecurringTask $context }
                Description = "Add recurring task"
                Category = "Template"
                NeedsArg = $true
            }
            'recurring list' = @{
                Handler = { Show-RecurringTasks }
                Description = "Show recurring tasks"
                Category = "Template"
            }
            
            # === DEPENDENCIES ===
            'dep add' = @{
                Handler = { param($context) Add-SmartDependency $context }
                Description = "Add task dependency"
                Category = "Dependency"
                NeedsArg = $true
            }
            'dep remove' = @{
                Handler = { param($context) Remove-SmartDependency $context }
                Description = "Remove dependency"
                Category = "Dependency"
                NeedsArg = $true
            }
            'dep show' = @{
                Handler = { param($context) Show-Dependencies $context }
                Description = "Show task dependencies"
                Category = "Dependency"
            }
            'dep graph' = @{
                Handler = { Show-DependencyGraph }
                Description = "Visual dependency graph"
                Category = "Dependency"
            }
            
            # === CONTEXT & FOCUS ===
            'focus' = @{
                Handler = { param($context) Set-SmartFocus $context }
                Description = "Set project context"
                Category = "Context"
                NeedsArg = $true
            }
            'unfocus' = @{
                Handler = { Clear-Focus }
                Description = "Clear context"
                Category = "Context"
            }
            'context' = @{
                Handler = { Show-ContextInfo }
                Description = "Show current context details"
                Category = "Context"
            }
            
            # === PRODUCTIVITY ===
            'next' = @{
                Handler = { Show-NextActions }
                Description = "AI-suggested next actions"
                Category = "Productivity"
            }
            'review' = @{
                Handler = { Start-WeeklyReview }
                Description = "Weekly review workflow"
                Category = "Productivity"
            }
            'stats' = @{
                Handler = { Show-ProductivityStats }
                Description = "Productivity analytics"
                Category = "Productivity"
            }
            'burndown' = @{
                Handler = { Show-BurndownChart }
                Description = "Sprint burndown chart"
                Category = "Productivity"
            }
            'velocity' = @{
                Handler = { Show-VelocityChart }
                Description = "Task completion velocity"
                Category = "Productivity"
            }
            
            # === UTILITIES ===
            'undo' = @{
                Handler = { Undo-LastAction }
                Description = "Undo last action"
                Category = "Utility"
            }
            'redo' = @{
                Handler = { Redo-Action }
                Description = "Redo undone action"
                Category = "Utility"
            }
            'export' = @{
                Handler = { param($context) Export-Tasks $context }
                Description = "Export to CSV/JSON/Markdown"
                Category = "Utility"
                NeedsArg = $true
            }
            'import' = @{
                Handler = { param($context) Import-Tasks $context }
                Description = "Import from file"
                Category = "Utility"
                NeedsArg = $true
            }
            'backup' = @{
                Handler = { Backup-Data }
                Description = "Create backup"
                Category = "Utility"
            }
            'clean' = @{
                Handler = { Clean-CompletedTasks }
                Description = "Archive old completed tasks"
                Category = "Utility"
            }
            'config' = @{
                Handler = { Edit-Configuration }
                Description = "Edit configuration"
                Category = "Utility"
            }
            'help' = @{
                Handler = { param($context) Show-SmartHelp $context }
                Description = "Context-aware help"
                Category = "Utility"
            }
            'quit' = @{
                Handler = { Exit-SmartTUI }
                Description = "Save and exit"
                Category = "Utility"
            }
        }
    }
    
    [void] InitializeAliases() {
        $this.Aliases = @{
            # Single letter aliases
            'a' = 'add'
            'd' = 'done'
            'u' = 'update'
            'p' = 'proj'
            'f' = 'focus'
            't' = 'today'
            'w' = 'week'
            'n' = 'next'
            's' = 'search'
            'r' = 'report'
            'h' = 'help'
            'q' = 'quit'
            
            # Common shortcuts
            'td' = 'today'
            'tm' = 'tomorrow'
            'od' = 'overdue'
            'nd' = 'noduedate'
            'del' = 'delete'
            'rm' = 'delete'
            'mv' = 'move'
            'ls' = 'agenda'
            'll' = 'proj'
            'x' = 'done'
            'xx' = 'delete'
            
            # Power user shortcuts
            'qa' = 'add'  # quick add
            'qd' = 'done' # quick done
            'ql' = 'log'  # quick log
            'qr' = 'report' # quick report
        }
    }
    
    [void] InitializeCommandSchemas() {
        # Schema for 'add' command
        $addSchema = [CommandSchema]::new()
        $addSchema.CommandName = "add"
        $addSchema.Description = "Add a new task with optional arguments"
        $addSchema.Syntax = "add [@project] [p1-3] [due:date] [est:time] [#tags] <description>"
        
        # Project argument
        $projectArg = [ArgumentSchema]::new()
        $projectArg.Name = "project"
        $projectArg.Type = "project"
        $projectArg.Prefix = "@"
        $projectArg.Required = $false
        $projectArg.Description = "Project to add task to"
        $projectArg.Example = "@work"
        
        # Priority argument
        $priorityArg = [ArgumentSchema]::new()
        $priorityArg.Name = "priority"
        $priorityArg.Type = "priority"
        $priorityArg.Prefix = "p"
        $priorityArg.Required = $false
        $priorityArg.ValidValues = @(1, 2, 3)
        $priorityArg.Description = "Task priority (p1=high, p2=medium, p3=low)"
        $priorityArg.Example = "p1"
        
        # Due date argument
        $dueArg = [ArgumentSchema]::new()
        $dueArg.Name = "due"
        $dueArg.Type = "date"
        $dueArg.Prefix = "due:"
        $dueArg.Required = $false
        $dueArg.Description = "Due date for the task"
        $dueArg.Example = "due:today"
        
        # Estimate argument
        $estArg = [ArgumentSchema]::new()
        $estArg.Name = "est"
        $estArg.Type = "duration"
        $estArg.Prefix = "est:"
        $estArg.Required = $false
        $estArg.Pattern = "^est:\d+[hm]$"
        $estArg.Description = "Time estimate for the task"
        $estArg.Example = "est:2h"
        
        # Tags argument
        $tagArg = [ArgumentSchema]::new()
        $tagArg.Name = "tags"
        $tagArg.Type = "tag"
        $tagArg.Prefix = "#"
        $tagArg.Required = $false
        $tagArg.Description = "Tags for the task"
        $tagArg.Example = "#urgent"
        
        # Description argument (free text)
        $descArg = [ArgumentSchema]::new()
        $descArg.Name = "description"
        $descArg.Type = "text"
        $descArg.Required = $true
        $descArg.Description = "Task description (required)"
        $descArg.Example = "Review project documentation"
        
        $addSchema.Arguments = @($projectArg, $priorityArg, $dueArg, $estArg, $tagArg, $descArg)
        $this.CommandSchemas["add"] = $addSchema
        
        # Schema for 'edit' command
        $editSchema = [CommandSchema]::new()
        $editSchema.CommandName = "edit"
        $editSchema.Description = "Edit an existing task"
        $editSchema.Syntax = "edit <task_id> [new_content]"
        
        $taskIdArg = [ArgumentSchema]::new()
        $taskIdArg.Name = "taskId"
        $taskIdArg.Type = "taskid"
        $taskIdArg.Required = $true
        $taskIdArg.Pattern = "^\d+$"
        $taskIdArg.Description = "ID of task to edit"
        $taskIdArg.Example = "123"
        
        $editContentArg = [ArgumentSchema]::new()
        $editContentArg.Name = "content"
        $editContentArg.Type = "text"
        $editContentArg.Required = $false
        $editContentArg.Description = "New task content"
        $editContentArg.Example = "Updated task description"
        
        $editSchema.Arguments = @($taskIdArg, $editContentArg)
        $this.CommandSchemas["edit"] = $editSchema
        
        # Schema for 'done' command  
        $doneSchema = [CommandSchema]::new()
        $doneSchema.CommandName = "done"
        $doneSchema.Description = "Mark task(s) as completed"
        $doneSchema.Syntax = "done <task_id> | done <range>"
        
        $doneTaskArg = [ArgumentSchema]::new()
        $doneTaskArg.Name = "taskRef"
        $doneTaskArg.Type = "taskref"
        $doneTaskArg.Required = $true
        $doneTaskArg.Pattern = "^\d+(-\d+)?$"
        $doneTaskArg.Description = "Task ID or range (e.g., 1-5)"
        $doneTaskArg.Example = "123"
        
        $doneSchema.Arguments = @($doneTaskArg)
        $this.CommandSchemas["done"] = $doneSchema
        
        # Schema for 'proj' command
        $projSchema = [CommandSchema]::new()
        $projSchema.CommandName = "proj"
        $projSchema.Description = "Project management commands"
        $projSchema.Syntax = "proj <subcommand> [args]"
        
        $subcmdArg = [ArgumentSchema]::new()
        $subcmdArg.Name = "subcommand"
        $subcmdArg.Type = "subcommand"
        $subcmdArg.Required = $true
        $subcmdArg.ValidValues = @("add", "list", "archive", "edit", "delete")
        $subcmdArg.Description = "Project subcommand"
        $subcmdArg.Example = "add"
        
        $projSchema.Arguments = @($subcmdArg)
        $this.CommandSchemas["proj"] = $projSchema
    }
    
    # Get schema for a command
    [CommandSchema] GetCommandSchema([string] $commandName) {
        return $this.CommandSchemas[$commandName]
    }
    
    # LEGACY PARSE METHOD REMOVED - Now using ParseBufferToState + CommandContext
    
    # === MAIN COMPLETION ENTRY POINT ===
    [array] GetSmartCompletions([string] $buffer, [int] $cursorPosition = -1) {
        try {
            $actualCursor = if ($cursorPosition -eq -1) { $buffer.Length } else { $cursorPosition }
            "=== GetSmartCompletions START: buffer='$buffer', cursor=$actualCursor ===" | Write-Debug
            # Ensure we have fresh data
            $this.RefreshDataCache()
            
            # Parse the buffer into completion state
            $state = $this.ParseBufferToState($buffer, $actualCursor)
            $this.CurrentState = $state
            "PARSED STATE: Mode=$($state.Mode), CurrentToken='$($state.CurrentToken)', CurrentCommand='$($state.CurrentCommand)'" | Write-Debug
            
            # Get completions based on state
            $completions = $this.GetCompletionsForState($state)
            "COMPLETIONS: Found $($completions.Count) items, Mode was $($state.Mode)" | Write-Debug
            
            # Convert to legacy format for existing UI
            $result = $this.ConvertToLegacyFormat($completions)
            "CONVERTED: Returning $($result.Count) legacy format items" | Write-Debug
            return $result
        }
        catch {
            # Never crash - return safe fallback
            return $this.GetErrorRecoveryCompletions($buffer, $_)
        }
    }
    
    # === ROBUST BUFFER PARSING ===
    # Overloaded method for backward compatibility (assumes cursor at end)
    [CompletionState] ParseBufferToState([string] $buffer) {
        return $this.ParseBufferToState($buffer, $buffer.Length)
    }
    
    # New cursor-aware method - the main implementation
    [CompletionState] ParseBufferToState([string] $buffer, [int] $cursorPosition) {
        "--- ParseBufferToState START (cursor-aware) ---" | Write-Debug
        $state = [CompletionState]::new()
        
        # Input validation and normalization
        if ($buffer -eq $null) { $buffer = "" }
        
        # Validate and clamp cursor position
        if ($cursorPosition -lt 0) { $cursorPosition = 0 }
        if ($cursorPosition -gt $buffer.Length) { $cursorPosition = $buffer.Length }
        
        $originalBuffer = $buffer
        # DON'T trim the buffer - we need exact positions for cursor logic
        "BUFFER: original='$originalBuffer', cursorPos=$cursorPosition" | Write-Debug
        $state.OriginalBuffer = $originalBuffer
        $state.CursorPosition = $cursorPosition
        
        # Handle truly empty buffer
        if ([string]::IsNullOrEmpty($buffer)) {
            $state.Mode = [CompletionMode]::Command
            return $state
        }
        
        # Handle whitespace-only buffer
        if ([string]::IsNullOrWhiteSpace($buffer)) {
            $state.Mode = [CompletionMode]::Command
            $state.IsOnNewWord = $true
            return $state
        }
        
        # Tokenize with position tracking
        $tokens = $this.TokenizeBuffer($buffer)
        "TOKENS: Found $($tokens.Count) tokens: $($tokens | ForEach-Object { "'$($_.Text)'" }) from buffer '$buffer'" | Write-Debug
        
        # Phase 2.3: Implement robust TokenUnderCursor logic
        # Find the token that contains the cursor position
        # Convention: Token.EndPos is exclusive (one character past the end)
        $state.TokenUnderCursor = $tokens | 
            Where-Object { $_.StartPos -le $cursorPosition -and $cursorPosition -lt $_.EndPos } | 
            Select-Object -Last 1
            
        # Determine if cursor is on a new word position
        $state.IsOnNewWord = ($cursorPosition -gt 0 -and $buffer[$cursorPosition - 1] -match '\s') -or 
                             ($buffer.EndsWith(' ') -and $cursorPosition -eq $buffer.Length)
        
        "CURSOR: TokenUnderCursor='$($state.TokenUnderCursor?.Text)', IsOnNewWord=$($state.IsOnNewWord)" | Write-Debug
        
        # Determine completion context with cursor awareness
        $this.AnalyzeTokensForCompletion($state, $tokens)
        "ANALYZE RESULT: Mode=$($state.Mode), CurrentToken='$($state.CurrentToken)', CurrentCommand='$($state.CurrentCommand)'" | Write-Debug
        
        return $state
    }
    
    [array] TokenizeBuffer([string] $buffer) {
        $tokens = @()
        
        # Handle edge case: empty or whitespace-only buffer
        if ([string]::IsNullOrWhiteSpace($buffer)) {
            return $tokens
        }
        
        # Phase 2.4: Enhanced tokenizer with quoted string support
        # Regex pattern: captures quoted strings OR non-whitespace sequences
        $pattern = '("[^"]*")|(\S+)'
        $matches = [regex]::Matches($buffer, $pattern)
        
        foreach ($match in $matches) {
            $tokenText = $match.Value
            $startPos = $match.Index
            $endPos = $startPos + $match.Length
            
            # Create ParsedToken with accurate position information
            $token = [ParsedToken]::new($tokenText, $startPos, $endPos)
            
            # Set token type based on what was matched
            if ($match.Groups[1].Success) {
                # Quoted string
                $token.Type = "QuotedString"
            } elseif ($match.Groups[2].Success) {
                # Regular token
                $token.Type = "Token"
            }
            
            $tokens += $token
        }
        
        return $tokens
    }
    
    [void] AnalyzeTokensForCompletion([CompletionState] $state, [array] $tokens) {
        "--- AnalyzeTokensForCompletion START ---" | Write-Debug
        if ($tokens.Count -eq 0) {
            "NO TOKENS: Setting Mode=Command" | Write-Debug
            $state.Mode = [CompletionMode]::Command
            return
        }
        
        # Check if buffer ends with space (indicates completed token)
        $endsWithSpace = $state.OriginalBuffer.EndsWith(' ')
        "SPACE DEBUG: buffer='$($state.OriginalBuffer)', length=$($state.OriginalBuffer.Length), endsWithSpace=$endsWithSpace" | Write-Debug
        
        # Determine command
        $firstToken = $tokens[0].Text.ToLower()
        $resolvedCommand = $this.ResolveAlias($firstToken)
        "COMMAND RESOLVE: firstToken='$firstToken' -> resolved='$resolvedCommand'" | Write-Debug
        
        # Check for multi-word commands
        if ($tokens.Count -ge 2 -and $this.IsMultiWordCommand($resolvedCommand, $tokens[1].Text)) {
            "MULTIWORD: $resolvedCommand $($tokens[1].Text.ToLower())" | Write-Debug
            
            # Populate both legacy and enhanced properties
            $fullCommandName = "$resolvedCommand $($tokens[1].Text.ToLower())"
            $state.CurrentCommand = $fullCommandName  # Legacy
            $state.FullCommandName = $fullCommandName  # Enhanced (Phase 2)
            
            # CRITICAL FIX: Multi-word commands are still commands, not arguments!
            $state.CompletedArguments = @()  # Legacy - Start with empty - arguments come after the full command
            "FIXED: Multi-word command CompletedArguments initialized as empty" | Write-Debug
            
            # Phase 2.5: Extract argument tokens for enhanced properties
            $argTokensOnly = @()
            if ($tokens.Count -gt 2) {
                $argTokensOnly = $tokens[2..($tokens.Count - 1)]
            }
            $state.ArgumentTokens = $argTokensOnly  # Enhanced (Phase 2)
            "FIXED: Extracted $($argTokensOnly.Count) argument tokens only (multi-word)" | Write-Debug
            
            # Pass the clean, safe array to the legacy function with startIndex=0
            $this.AnalyzeArgumentCompletion($state, $argTokensOnly, 0, $endsWithSpace)
        }
        elseif ($this.Commands.ContainsKey($resolvedCommand)) {
            "COMMAND MATCH: $resolvedCommand exists" | Write-Debug
            # Check if this is an exact command match, has trailing space, or has additional tokens
            if ($firstToken -eq $resolvedCommand -or $endsWithSpace -or $tokens.Count -gt 1) {
                # Exact command or completed with space - do argument completion
                "EXACT/SPACE: firstToken='$firstToken' == resolved='$resolvedCommand' OR endsWithSpace=$endsWithSpace -> ArgumentCompletion" | Write-Debug
                
                # Populate both legacy and enhanced properties  
                $state.CurrentCommand = $resolvedCommand  # Legacy
                $state.FullCommandName = $resolvedCommand  # Enhanced (Phase 2)
                
                # CRITICAL FIX: Don't add command to CompletedArguments - it's not an argument!
                $state.CompletedArguments = @()  # Legacy - Start with empty - arguments come after command
                "FIXED: CompletedArguments initialized as empty (command '$resolvedCommand' is not an argument)" | Write-Debug
                
                # Phase 2.5: Extract argument tokens for enhanced properties
                $argTokensOnly = @()
                if ($tokens.Count -gt 1) {
                    $argTokensOnly = $tokens[1..($tokens.Count - 1)]
                }
                $state.ArgumentTokens = $argTokensOnly  # Enhanced (Phase 2)
                "FIXED: Extracted $($argTokensOnly.Count) argument tokens only" | Write-Debug
                
                # Pass the clean, safe array to the legacy function with startIndex=0
                $this.AnalyzeArgumentCompletion($state, $argTokensOnly, 0, $endsWithSpace)
            } else {
                # Partial match like "a" -> "add" - still in command completion mode
                "PARTIAL: firstToken='$firstToken' != resolved='$resolvedCommand' -> Command mode" | Write-Debug
                $state.Mode = [CompletionMode]::Command
                $state.CurrentToken = $firstToken
            }
        }
        elseif ($this.CouldBeMultiWordCommand($resolvedCommand)) {
            # Partial multi-word command
            "COULD_BE_MULTIWORD: $resolvedCommand -> Subcommand mode" | Write-Debug
            $state.Mode = [CompletionMode]::Subcommand
            $state.CurrentCommand = $resolvedCommand
            # CRITICAL FIX: Even potential multi-word commands don't put command tokens in CompletedArguments
            $state.CompletedArguments = @()  # Commands are not arguments
            "FIXED: Partial multi-word command CompletedArguments initialized as empty" | Write-Debug
            
            if ($tokens.Count -gt 1 -and -not $endsWithSpace) {
                $state.CurrentToken = $tokens[-1].Text
            }
        }
        else {
            # First word completion
            "FALLBACK: No command match -> Command mode" | Write-Debug
            $state.Mode = [CompletionMode]::Command
            if (-not $endsWithSpace -and $tokens.Count -eq 1) {
                $state.CurrentToken = $tokens[0].Text
            }
        }
    }
    
    [void] AnalyzeArgumentCompletion([CompletionState] $state, [array] $tokens, [int] $startIndex, [bool] $endsWithSpace) {
        # We have a valid command, now determine what argument we're completing
        $argTokens = $tokens[$startIndex..($tokens.Count-1)]
        "ANALYZE ARG: === START === buffer='$($state.OriginalBuffer)', argTokens=$($argTokens.Count), endsWithSpace=$endsWithSpace" | Write-Debug
        "ANALYZE ARG: Current CompletedArguments: $($state.CompletedArguments -join ', ')" | Write-Debug
        
        # Log all argument tokens
        for ($i = 0; $i -lt $argTokens.Count; $i++) {
            "ANALYZE ARG: argTokens[$i]='$($argTokens[$i].Text)'" | Write-Debug
        }
        
        if ($argTokens.Count -eq 0) {
            # No arguments yet - show syntax discovery
            "ANALYZE ARG: NO ARGS -> SyntaxDiscovery" | Write-Debug
            $state.Mode = [CompletionMode]::SyntaxDiscovery
            $state.TokenComplete = $endsWithSpace
            return
        }
        
        if ($argTokens.Count -eq 1 -and $endsWithSpace) {
            # One argument with space - need to check what kind it is
            $lastToken = $argTokens[0].Text
            $isCompleted = $this.IsCompletedArgument($lastToken)
            $isPrefix = $this.IsArgumentPrefix($lastToken)
            "ANALYZE ARG: Single arg with space, lastToken='$lastToken', IsCompletedArgument=$isCompleted, IsArgumentPrefix=$isPrefix" | Write-Debug
            
            if ($isPrefix -and -not $isCompleted) {
                # Incomplete prefix like '@' followed by SPACE - user wants to complete VALUES  
                "ANALYZE ARG: INCOMPLETE PREFIX + SPACE -> PrefixCompletion" | Write-Debug
                $state.Mode = [CompletionMode]::PrefixCompletion
                $state.PrefixBeingCompleted = $this.ExtractPrefix($lastToken)
                $state.CurrentToken = $lastToken
                return
            } else {
                # Valid completed argument - show next syntax discovery
                "ANALYZE ARG: SINGLE COMPLETED ARG -> SyntaxDiscovery, adding '$lastToken' to CompletedArguments" | Write-Debug
                $state.Mode = [CompletionMode]::SyntaxDiscovery
                $state.CompletedArguments += $lastToken  # Add the completed argument!
                "ANALYZE ARG: CompletedArguments after adding: $($state.CompletedArguments -join ', ')" | Write-Debug
                $state.TokenComplete = $endsWithSpace
                return
            }
        }
        
        # Check if we're in the middle of a prefix completion
        $lastToken = $argTokens[-1].Text
        $isLastCompleted = $this.IsCompletedArgument($lastToken)
        "ANALYZE ARG: MULTI-TOKEN - lastToken='$lastToken', IsCompletedArgument=$isLastCompleted, endsWithSpace=$endsWithSpace" | Write-Debug
        
        if ($isLastCompleted -and $endsWithSpace) {
            # Completed an argument, show next syntax options
            "ANALYZE ARG: BRANCH 1 - Completed arg + space -> SyntaxDiscovery" | Write-Debug
            $state.Mode = [CompletionMode]::SyntaxDiscovery
            
            # Add ALL previous arguments INCLUDING the last one
            foreach ($argToken in $argTokens) {
                $state.CompletedArguments += $argToken.Text
                "ANALYZE ARG: Added '$($argToken.Text)' to CompletedArguments" | Write-Debug
            }
            
            "ANALYZE ARG: Final CompletedArguments: $($state.CompletedArguments -join ', ')" | Write-Debug
            $state.TokenComplete = $true
        }
        elseif ($isLastCompleted -and -not $endsWithSpace) {
            # Completed argument but no space yet - user might want to modify it or add space
            # Treat as if they want to continue with this argument type
            "ANALYZE ARG: BRANCH 2 - Completed arg no space -> PrefixCompletion" | Write-Debug
            $state.Mode = [CompletionMode]::PrefixCompletion
            $state.PrefixBeingCompleted = $this.ExtractPrefix($lastToken)
            $state.CurrentToken = $lastToken
            
            # Add all previous arguments EXCEPT the last one (which is being completed)
            for ($i = 0; $i -lt ($argTokens.Count - 1); $i++) {
                $state.CompletedArguments += $argTokens[$i].Text
                "ANALYZE ARG: Added previous arg '$($argTokens[$i].Text)' to CompletedArguments" | Write-Debug
            }
        }
        elseif ($this.IsArgumentPrefix($lastToken) -and -not $endsWithSpace) {
            # Completing within a prefix (e.g., "add @per" -> completing @projects)
            "ANALYZE ARG: BRANCH 3 - Prefix arg no space -> PrefixCompletion" | Write-Debug
            $state.Mode = [CompletionMode]::PrefixCompletion
            $state.PrefixBeingCompleted = $this.ExtractPrefix($lastToken)
            $state.CurrentToken = $lastToken
            "ANALYZE ARG: Set PrefixBeingCompleted='$($state.PrefixBeingCompleted)', CurrentToken='$($state.CurrentToken)'" | Write-Debug
            
            # Add all previous arguments EXCEPT the last one (which is being completed)
            for ($i = 0; $i -lt ($argTokens.Count - 1); $i++) {
                $state.CompletedArguments += $argTokens[$i].Text
                "ANALYZE ARG: Added previous prefix arg '$($argTokens[$i].Text)' to CompletedArguments" | Write-Debug
            }
        }
        else {
            # Check if this is for 'add' command which should show syntax discovery for any incomplete state
            "ANALYZE ARG: BRANCH 4 - Fallback case, lastToken='$lastToken', CurrentCommand='$($state.CurrentCommand)'" | Write-Debug
            if ($state.CurrentCommand -eq 'add') {
                "ANALYZE ARG: ADD command fallback -> SyntaxDiscovery" | Write-Debug
                $state.Mode = [CompletionMode]::SyntaxDiscovery
                $state.CurrentToken = $lastToken
                
                # Add all previous arguments EXCEPT the last one (which is being completed)
                for ($i = 0; $i -lt ($argTokens.Count - 1); $i++) {
                    $state.CompletedArguments += $argTokens[$i].Text
                    "ANALYZE ARG: Added fallback arg '$($argTokens[$i].Text)' to CompletedArguments" | Write-Debug
                }
            } else {
                # Free text or unknown - show help
                "ANALYZE ARG: Non-ADD command fallback -> Help" | Write-Debug
                $state.Mode = [CompletionMode]::Help
                $state.CurrentToken = $lastToken
            }
        }
        
        "ANALYZE ARG: === END === Final state - Mode=$($state.Mode), CompletedArguments=($($state.CompletedArguments -join ', '))" | Write-Debug
    }
    
    # === HELPER METHODS FOR ANALYSIS ===
    [string] ResolveAlias([string] $word) {
        if ($this.Aliases.ContainsKey($word)) {
            return $this.Aliases[$word]
        }
        return $word
    }
    
    [bool] IsMultiWordCommand([string] $firstWord, [string] $secondWord) {
        $twoWord = "$firstWord $($secondWord.ToLower())"
        return $this.Commands.ContainsKey($twoWord)
    }
    
    [bool] CouldBeMultiWordCommand([string] $firstWord) {
        $pattern = "$firstWord *"
        return ($this.Commands.Keys | Where-Object { $_ -like $pattern }).Count -gt 0
    }
    
    [bool] IsArgumentPrefix([string] $token) {
        return $token.StartsWith('@') -or $token.StartsWith('due:') -or $token.StartsWith('est:') -or $token.StartsWith('#')
    }
    
    [string] ExtractPrefix([string] $token) {
        if ($token.StartsWith('@')) { return '@' }
        if ($token.StartsWith('due:')) { return 'due:' }
        if ($token.StartsWith('est:')) { return 'est:' }
        if ($token.StartsWith('#')) { return '#' }
        return ''
    }
    
    [bool] IsCompletedArgument([string] $token) {
        # Check if this looks like a complete argument
        return ($token.StartsWith('@') -and $token.Length -gt 1) -or
               ($token.StartsWith('due:') -and $token.Length -gt 4) -or
               ($token.StartsWith('est:') -and $token.Length -gt 4) -or
               ($token.StartsWith('#') -and $token.Length -gt 1) -or
               ($token -match '^p[123]$')
    }
    
    # === COMPLETION ENGINE ===
    [array] GetCompletionsForState([CompletionState] $state) {
        # FIXED: Use the Mode-based completion that was set by parsing
        switch ($state.Mode) {
            ([CompletionMode]::Command) {
                return $this.GetCommandCompletions($state)
            }
            
            ([CompletionMode]::Subcommand) {
                return $this.GetSubcommandCompletions($state)
            }
            
            ([CompletionMode]::SyntaxDiscovery) {
                return $this.GetSyntaxDiscoveryCompletions($state)
            }
            
            ([CompletionMode]::PrefixCompletion) {
                return $this.GetPrefixCompletions($state)
            }
            
            ([CompletionMode]::Help) {
                return $this.GetHelpCompletions($state)
            }
            
            default {
                return $this.GetFallbackCompletions($state)
            }
        }
        # Explicit return for PowerShell compiler
        return @()
    }
    
    [array] GetSubcommandCompletions([CompletionState] $state) {
        $completions = @()
        $baseCmd = $state.CurrentCommand
        
        foreach ($cmd in $this.Commands.Keys | Where-Object { $_ -like "$baseCmd *" }) {
            $subCmd = $cmd.Substring($baseCmd.Length + 1)
            if ([string]::IsNullOrEmpty($state.CurrentToken) -or $subCmd.StartsWith($state.CurrentToken)) {
                $info = $this.Commands[$cmd]
                $completions += [CompletionItem]::new($subCmd, $info.Description, $info.Category, 100)
            }
        }
        
        return $completions
    }
    
    [array] GetSyntaxDiscoveryCompletions([CompletionState] $state) {
        $completions = @()
        
        if ($state.CurrentCommand -eq 'add') {
            # Show available argument prefixes that haven't been used
            $usedPrefixes = @()
            foreach ($arg in $state.CompletedArguments) {
                if ($arg.StartsWith('@')) { $usedPrefixes += '@' }
                if ($arg.StartsWith('due:')) { $usedPrefixes += 'due:' }
                if ($arg.StartsWith('est:')) { $usedPrefixes += 'est:' }
                if ($arg.StartsWith('#')) { $usedPrefixes += '#' }
                if ($arg -match '^p[123]$') { $usedPrefixes += 'p' }
            }
            
            if ('@' -notin $usedPrefixes) {
                $completions += [CompletionItem]::new("@", "Add project (@work, @home...)", "Argument", 100)
            }
            if ('p' -notin $usedPrefixes) {
                $completions += [CompletionItem]::new("p1", "High priority", "Argument", 95)
                $completions += [CompletionItem]::new("p2", "Medium priority", "Argument", 94)  
                $completions += [CompletionItem]::new("p3", "Low priority", "Argument", 93)
            }
            if ('due:' -notin $usedPrefixes) {
                $completions += [CompletionItem]::new("due:", "Set due date", "Argument", 90)
            }
            if ('est:' -notin $usedPrefixes) {
                $completions += [CompletionItem]::new("est:", "Set time estimate", "Argument", 85)
            }
            # Tags can be multiple, so always show
            $completions += [CompletionItem]::new("#", "Add tag", "Argument", 80)
        }
        
        return $completions
    }
    
    [array] GetPrefixCompletions([CompletionState] $state) {
        $partial = ""
        if ($state.CurrentToken.StartsWith($state.PrefixBeingCompleted)) {
            $partial = $state.CurrentToken.Substring($state.PrefixBeingCompleted.Length)
        }
        
        switch ($state.PrefixBeingCompleted) {
            '@' { return $this.GetProjectCompletions($partial, '@') }
            'due:' { return $this.GetDateCompletions($partial, 'due:') }
            'est:' { return $this.GetEstimateCompletions($partial, 'est:') }
            '#' { return $this.GetTagCompletions($partial, '#') }
            default { return @() }
        }
        # Explicit return for PowerShell
        return @()
    }
    
    [array] GetCommandCompletions([CompletionState] $state) {
        $completions = @()
        
        # Phase 3.2: Use enhanced properties - prefer TokenUnderCursor, fallback to CurrentToken
        $partial = ""
        if ($state.TokenUnderCursor) {
            $partial = $state.TokenUnderCursor.Text.ToLower()
            "ENHANCED: Using TokenUnderCursor='$partial' for command completion" | Write-Debug
        } elseif ($state.CurrentToken) {
            $partial = $state.CurrentToken.ToLower()
            "LEGACY FALLBACK: Using CurrentToken='$partial' for command completion" | Write-Debug
        }
        
        # Add all commands that match
        foreach ($cmd in $this.Commands.Keys | Sort-Object) {
            if ([string]::IsNullOrEmpty($partial) -or $cmd.StartsWith($partial)) {
                $info = $this.Commands[$cmd]
                $completions += [CompletionItem]::new($cmd, $info.Description, $info.Category, 100)
            }
        }
        
        # Add matching aliases
        foreach ($alias in $this.Aliases.Keys | Sort-Object) {
            if ([string]::IsNullOrEmpty($partial) -or $alias.StartsWith($partial)) {
                $target = $this.Aliases[$alias]
                if ($this.Commands.ContainsKey($target)) {
                    $completions += [CompletionItem]::new($alias, "→ $target", $this.Commands[$target].Category, 90)
                }
            }
        }
        
        # Boost common commands
        if ([string]::IsNullOrEmpty($partial)) {
            $topCommands = @('agenda', 'add', 'done', 'today', 'focus')
            foreach ($comp in $completions) {
                if ($comp.Text -in $topCommands) {
                    $comp.Score = 150
                }
            }
        }
        
        return $completions
    }
    
    
    
    [array] GetProjectCompletions([string] $partial, [string] $prefix = '@') {
        $completions = @()
        
        if ($this.CachedData -and $this.CachedData.projects) {
            foreach ($proj in $this.CachedData.projects | Where-Object { -not $_.isArchived }) {
                if ([string]::IsNullOrEmpty($partial) -or $proj.name.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                    $text = "$prefix$($proj.name)"
                    $desc = $proj.description
                    if ([string]::IsNullOrEmpty($desc)) { $desc = "Project: $($proj.name)" }
                    $completions += [CompletionItem]::new($text, $desc, 'Project', 90)
                }
            }
        }
        
        # Always provide at least the standard projects
        if ($completions.Count -eq 0) {
            $completions += [CompletionItem]::new("${prefix}inbox", 'Default inbox project', 'Project', 90)
            $completions += [CompletionItem]::new("${prefix}personal", 'Personal tasks', 'Project', 85)
            $completions += [CompletionItem]::new("${prefix}work", 'Work projects', 'Project', 85)
        }
        
        return $completions
    }
    
    [array] GetDateCompletions([string] $partial, [string] $prefix = 'due:') {
        $completions = @()
        $dates = @(
            @{Text='today'; Desc='Due today'},
            @{Text='tomorrow'; Desc='Due tomorrow'},
            @{Text='mon'; Desc='Next Monday'},
            @{Text='tue'; Desc='Next Tuesday'},
            @{Text='wed'; Desc='Next Wednesday'},
            @{Text='thu'; Desc='Next Thursday'},
            @{Text='fri'; Desc='Next Friday'},
            @{Text='sat'; Desc='Next Saturday'},
            @{Text='sun'; Desc='Next Sunday'},
            @{Text='nextweek'; Desc='Next week'},
            @{Text='eom'; Desc='End of month'}
        )
        
        foreach ($date in $dates) {
            if ([string]::IsNullOrEmpty($partial) -or $date.Text.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                $completions += [CompletionItem]::new("$prefix$($date.Text)", $date.Desc, 'Date', 85)
            }
        }
        
        return $completions
    }
    
    [array] GetEstimateCompletions([string] $partial, [string] $prefix = 'est:') {
        $completions = @()
        $estimates = @('15m', '30m', '1h', '2h', '4h', '8h')
        
        foreach ($est in $estimates) {
            if ([string]::IsNullOrEmpty($partial) -or $est.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                $completions += [CompletionItem]::new("$prefix$est", "Estimate: $est", 'Estimate', 80)
            }
        }
        
        return $completions
    }
    
    [array] GetTagCompletions([string] $partial, [string] $prefix = '#') {
        $completions = @()
        $tags = @('urgent', 'waiting', 'someday', 'reference', 'important', 'quick')
        
        foreach ($tag in $tags) {
            if ([string]::IsNullOrEmpty($partial) -or $tag.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                $completions += [CompletionItem]::new("$prefix$tag", "Tag: $tag", 'Tag', 75)
            }
        }
        
        return $completions
    }
    
    [array] GetTaskIdCompletions([string] $partial) {
        $completions = @()
        
        if ($global:LastShownTaskMap) {
            foreach ($localId in $global:LastShownTaskMap.Keys) {
                if ([string]::IsNullOrEmpty($partial) -or $localId.ToString().StartsWith($partial)) {
                    $taskId = $global:LastShownTaskMap[$localId]
                    if ($this.CachedData -and $this.CachedData.tasks) {
                        $task = $this.CachedData.tasks | Where-Object { $_.id -eq $taskId }
                        if ($task) {
                            $desc = $task.text
                            if ($desc.Length -gt 40) { $desc = $desc.Substring(0, 37) + "..." }
                            $completions += [CompletionItem]::new($localId.ToString(), $desc, 'Task', 95)
                        }
                    }
                }
            }
        }
        
        return $completions
    }
    
    # === UTILITY METHODS ===
    [void] RefreshDataCache() {
        if ((Get-Date) - $this.CacheTime -gt [TimeSpan]::FromSeconds(5)) {
            try {
                $this.CachedData = Get-TaskData
                $this.CacheTime = Get-Date
            }
            catch {
                # Don't crash on data load failure
                if ($this.CachedData -eq $null) {
                    $this.CachedData = @{ projects = @(); tasks = @() }
                }
            }
        }
    }
    
    [array] ConvertToLegacyFormat([array] $completions) {
        # Convert CompletionItem objects to legacy format for existing UI
        $legacy = @()
        foreach ($comp in $completions) {
            "CONVERT: comp.Text='$($comp.Text)', comp.Description='$($comp.Description)'" | Write-Debug
            $legacy += [PSCustomObject]@{
                Command = $comp.Text
                Description = $comp.Description
                Category = $comp.Category
                Score = $comp.Score
                Type = $comp.Type
            }
        }
        $sorted = $legacy | Sort-Object @{Expression='Score'; Descending=$true}, Command
        "CONVERT: Sorted $($sorted.Count) items, first Command='$($sorted[0].Command)'" | Write-Debug
        return $sorted
    }
    
    [array] GetErrorRecoveryCompletions([string] $buffer, [object] $error) {
        # Safe fallback that never crashes
        return @(
            [PSCustomObject]@{
                Command = ''
                Description = "Completion error: $($error.Message). Type 'help' for commands."
                Category = 'Error'
                Score = 0
                Type = 'Help'
            }
        )
    }
    
    [array] GetFallbackCompletions([CompletionState] $state) {
        return @(
            [PSCustomObject]@{
                Command = ''
                Description = 'Press Tab for completions, or type "help" for commands'
                Category = 'Help'
                Score = 0
                Type = 'Help'
            }
        )
    }
    
    [array] GetContextAwareCompletions([CommandContext] $context) {
        $completions = @()
        
        # Phase 4: Smart context-aware completions based on structured parsing
        $commandName = $context.CommandName.ToLower()
        
        switch ($commandName) {
            'add' {
                # OLD: return $this.GetAddCommandCompletions($context) - DELETED
                return @() # Will be handled by new schema-driven system
            }
            'edit' {
                return @() # OLD GetEditCommandCompletions DELETED
            }
            'proj' {
                return @() # OLD GetProjCommandCompletions DELETED
            }
            'due' {
                return $this.GetDueCommandCompletions($context)
            }
            'tag' {
                return $this.GetTagCommandCompletions($context)
            }
            default {
                # For commands without specific context-aware handlers, provide smart argument suggestions
                return $this.GetSmartArgumentCompletions($context)
            }
        }
        
        return $completions
    }
    
    # === CONTEXT-AWARE COMPLETION METHODS ===
    
# OLD GetAddCommandCompletions DELETED - using new schema-driven system
    
# OLD GetEditCommandCompletions DELETED
    
# OLD GetProjCommandCompletions, GetDueCommandCompletions, GetTagCommandCompletions DELETED
    
    
    [array] GetHelpCompletions([CompletionState] $state) {
        $completions = @()
        
        switch ($state.CurrentCommand) {
            'add' {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Syntax: add [@project] [p1-3] [due:date] [est:time] [#tags] <description>'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
            'done' {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Syntax: done <task_number> or done <range> (e.g., done 1-5)'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
            default {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = "Type arguments for '$($state.CurrentCommand)' or press Tab for options"
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
        }
        
        return $completions
    }
    
    # LEGACY ParseCommandContext REMOVED - Now using ParseBufferToState + CommandContext
    
    [hashtable] IdentifyCommandPattern([array]$words) {
        $result = @{
            IsComplete = $false
            IsPartial = $false
            Command = ''
            BaseCommand = ''
            CommandWords = @()
        }
        
        if ($words.Count -eq 0) {
            return $result
        }
        
        $firstWord = $words[0].ToLower()
        
        # Check aliases first
        if ($this.Aliases.ContainsKey($firstWord)) {
            $firstWord = $this.Aliases[$firstWord]
        }
        
        # Check for single-word commands
        if ($this.Commands.ContainsKey($firstWord)) {
            $result.IsComplete = $true
            $result.Command = $firstWord
            $result.CommandWords = @($words[0])
            return $result
        }
        
        # Check for two-word commands
        if ($words.Count -ge 2) {
            $twoWord = "$firstWord $($words[1].ToLower())"
            if ($this.Commands.ContainsKey($twoWord)) {
                $result.IsComplete = $true
                $result.Command = $twoWord
                $result.CommandWords = @($words[0], $words[1])
                return $result
            }
        }
        
        # Check if first word could be part of a multi-word command
        $possibleTwoWordCommands = $this.Commands.Keys | Where-Object { $_.StartsWith($firstWord + ' ') }
        if ($possibleTwoWordCommands.Count -gt 0) {
            $result.IsPartial = $true
            $result.BaseCommand = $firstWord
            $result.CommandWords = @($words[0])
            return $result
        }
        
        # Not a recognized command pattern
        return $result
    }
    
    
    [array] GetCommandCompletions([string]$partial) {
        $completions = @()
        
        # Add main commands
        foreach ($cmd in $this.Commands.Keys | Sort-Object) {
            if ([string]::IsNullOrEmpty($partial) -or $cmd.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                $info = $this.Commands[$cmd]
                $completions += [PSCustomObject]@{
                    Command = $cmd
                    Description = $info.Description
                    Category = $info.Category
                    Score = 100
                    Type = 'Command'
                }
            }
        }
        
        # Add aliases
        foreach ($alias in $this.Aliases.Keys) {
            if ([string]::IsNullOrEmpty($partial) -or $alias.StartsWith($partial, [StringComparison]::OrdinalIgnoreCase)) {
                $target = $this.Aliases[$alias]
                if ($this.Commands.ContainsKey($target)) {
                    $completions += [PSCustomObject]@{
                        Command = $alias
                        Description = "→ $target"
                        Category = $this.Commands[$target].Category
                        Score = 90
                        Type = 'Alias'
                    }
                }
            }
        }
        
        # Boost common commands when no partial
        if ([string]::IsNullOrEmpty($partial)) {
            $topCommands = @('agenda', 'add', 'done', 'today', 'focus')
            foreach ($tc in $topCommands) {
                $existing = $completions | Where-Object { $_.Command -eq $tc }
                if ($existing) { $existing.Score = 150 }
            }
        }
        
        return $completions
    }
    
    
    
    
    [array] GetHelpText([array]$words, $data) {
        $completions = @()
        
        if ($words.Count -eq 0) {
            return $completions  # Should not happen, but safe fallback
        }
        
        $command = $this.ResolveCommand($words)
        
        switch ($command) {
            'add' {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Syntax: add [@project] [p1-3] [due:date] [est:time] [#tags] <description>'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
            'done' {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Syntax: done <task_number> or done <range> (e.g., done 1-5)'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
            'focus' {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Syntax: focus <project_name> - Set current project context'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
            default {
                $completions += [PSCustomObject]@{
                    Command = ''
                    Description = 'Type command and press Tab for completions, or try "help"'
                    Category = 'Help'
                    Score = 0
                    Type = 'Help'
                }
            }
        }
        
        return $completions
    }
    
    [string] ResolveCommand([array]$words) {
        if ($words.Count -eq 0) { return '' }
        
        $firstWord = $words[0].ToLower()
        
        # Check if it's an alias
        if ($this.Aliases.ContainsKey($firstWord)) {
            return $this.Aliases[$firstWord]
        }
        
        # Check for two-word commands
        if ($words.Count -gt 1) {
            $twoWord = "$firstWord $($words[1].ToLower())"
            if ($this.Commands.ContainsKey($twoWord)) {
                return $twoWord
            }
        }
        
        # Single word command
        if ($this.Commands.ContainsKey($firstWord)) {
            return $firstWord
        }
        
        return $firstWord
    }
    
    
    # NEW: Execute using structured parsing - no more legacy!
    [void] ExecuteStructured([string]$input) {
        $global:SessionStats.CommandsRun++
        
        # Parse with structured parser
        $state = $this.ParseBufferToState($input.Trim())
        
        # Handle empty input = agenda
        if ([string]::IsNullOrWhiteSpace($input)) {
            $state.FullCommandName = 'agenda'
        }
        
        if ($state.FullCommandName -and $this.Commands.ContainsKey($state.FullCommandName)) {
            $global:LastAction = $state.FullCommandName
            $cmd = $this.Commands[$state.FullCommandName]
            
            try {
                # Always create CommandContext for consistency and smart features
                $context = [CommandContext]::new($state, $this)
                
                # Check validation before executing
                if (-not $context.IsValid) {
                    $context.ShowValidationErrors()
                    return
                }
                
                if ($cmd.NeedsArg) {
                    # Commands that expect arguments
                    & $cmd.Handler $context
                } else {
                    # No-argument commands - but still get context for optional smart features
                    & $cmd.Handler $context
                }
            }
            catch {
                Write-Host "Error executing $($state.FullCommandName): $_" -ForegroundColor Red
                Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
            }
        }
        else {
            if ($state.FullCommandName) {
                Write-Host "Unknown command: $($state.FullCommandName)" -ForegroundColor Red
            } else {
                Write-Host "Could not parse command from: '$input'" -ForegroundColor Red
            }
            Write-Host "Type 'help' for available commands" -ForegroundColor Gray
        }
    }
}

# === ENHANCED DISPLAY FUNCTIONS ===

function Show-RichAgenda {
    $data = Get-TaskData
    $today = (Get-Date).Date
    $todayStr = $today.ToString("yyyy-MM-dd")
    
    Clear-Host
    
    # Header with context
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor DarkGray
    Write-Host "  ║" -NoNewline -ForegroundColor DarkGray
    $header = "  AGENDA - $(Get-Date -Format 'dddd, MMMM d, yyyy')  "
    $padding = 60 - $header.Length
    Write-Host $header -NoNewline -ForegroundColor Cyan
    Write-Host (" " * $padding) -NoNewline
    Write-Host "║" -ForegroundColor DarkGray
    
    if ($global:CurrentContext -ne 'inbox') {
        Write-Host "  ║" -NoNewline -ForegroundColor DarkGray
        $ctx = "  Context: $($global:CurrentContext.ToUpper())  "
        Write-Host $ctx -NoNewline -ForegroundColor Yellow
        Write-Host (" " * (60 - $ctx.Length)) -NoNewline
        Write-Host "║" -ForegroundColor DarkGray
    }
    
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor DarkGray
    
    $localId = 1
    $global:LastShownTaskMap = @{}
    
    # Stats bar
    $pending = @($data.tasks | Where-Object { $_.status -eq 'pending' }).Count
    $todayCount = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.due -eq $todayStr }).Count
    $overdueCount = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.due -and $_.due -lt $todayStr }).Count
    
    Write-Host "`n  📊 " -NoNewline
    Write-Host "Total: $pending" -NoNewline -ForegroundColor White
    Write-Host " | " -NoNewline -ForegroundColor DarkGray
    Write-Host "Today: $todayCount" -NoNewline -ForegroundColor Yellow
    Write-Host " | " -NoNewline -ForegroundColor DarkGray
    Write-Host "Overdue: $overdueCount" -NoNewline -ForegroundColor Red
    
    # Time tracking status
    if ($global:ActiveTimer) {
        $elapsed = [Math]::Round(((Get-Date) - $global:ActiveTimer.Start).TotalMinutes)
        Write-Host " | " -NoNewline -ForegroundColor DarkGray
        Write-Host "⏱ Timer: ${elapsed}m" -NoNewline -ForegroundColor Cyan
    }
    
    Write-Host "`n"
    
    # OVERDUE Section
    $overdue = $data.tasks | Where-Object { 
        $_.status -eq 'pending' -and $_.due -and $_.due -lt $todayStr 
    } | Sort-Object due, priority -Descending
    
    if ($overdue) {
        Write-Host "  🔴 OVERDUE ($($overdue.Count))" -ForegroundColor Red
        Write-Host "  ─────────────" -ForegroundColor DarkRed
        
        foreach ($task in $overdue | Select-Object -First 5) {
            $global:LastShownTaskMap[$localId] = $task.id
            $daysSince = [Math]::Round(($today - [datetime]::Parse($task.due)).TotalDays)
            
            Write-Host "  " -NoNewline
            Write-Host "[$localId]" -NoNewline -ForegroundColor DarkGray
            Write-Host " " -NoNewline
            
            # Priority indicator
            $priSymbol = @("  ", "🔹", "🔸", "🔺")[$task.priority]
            Write-Host $priSymbol -NoNewline
            
            # Task text
            $taskText = if ($task.text.Length -gt 40) { 
                $task.text.Substring(0, 37) + "..." 
            } else { 
                $task.text.PadRight(40) 
            }
            Write-Host $taskText -NoNewline -ForegroundColor Red
            
            # Days overdue
            Write-Host " (${daysSince}d ago)" -NoNewline -ForegroundColor DarkRed
            
            # Project
            if ($task.project -ne 'inbox') {
                Write-Host " @$($task.project)" -NoNewline -ForegroundColor DarkGray
            }
            
            Write-Host ""
            $localId++
        }
        
        if ($overdue.Count -gt 5) {
            Write-Host "  ... and $($overdue.Count - 5) more" -ForegroundColor DarkRed
        }
        Write-Host ""
    }
    
    # TODAY Section  
    $todayTasks = $data.tasks | Where-Object { 
        $_.status -eq 'pending' -and $_.due -eq $todayStr 
    } | Sort-Object priority -Descending
    
    if ($todayTasks) {
        Write-Host "  📅 TODAY ($($todayTasks.Count))" -ForegroundColor Yellow
        Write-Host "  ─────────" -ForegroundColor DarkYellow
        
        foreach ($task in $todayTasks) {
            $global:LastShownTaskMap[$localId] = $task.id
            
            Write-Host "  " -NoNewline
            Write-Host "[$localId]" -NoNewline -ForegroundColor DarkGray
            Write-Host " " -NoNewline
            
            # Priority and estimated time
            $priSymbol = @("  ", "🔹", "🔸", "🔺")[$task.priority]
            Write-Host $priSymbol -NoNewline
            
            # Task with time estimate
            $taskDisplay = $task.text
            if ($task.estimatedMinutes) {
                $hrs = [Math]::Round($task.estimatedMinutes / 60, 1)
                $taskDisplay += " (${hrs}h)"
            }
            
            Write-Host $taskDisplay -NoNewline -ForegroundColor Yellow
            
            # Tags
            if ($task.tags -and $task.tags.Count -gt 0) {
                Write-Host " " -NoNewline
                foreach ($tag in $task.tags) {
                    Write-Host "#$tag" -NoNewline -ForegroundColor Blue
                    Write-Host " " -NoNewline
                }
            }
            
            Write-Host ""
            $localId++
        }
        Write-Host ""
    }
    
    # UPCOMING Section
    $upcoming = $data.tasks | Where-Object {
        $_.status -eq 'pending' -and $_.due -and 
        $_.due -gt $todayStr -and 
        $_.due -le $today.AddDays(7).ToString("yyyy-MM-dd")
    } | Sort-Object due, priority -Descending
    
    if ($upcoming) {
        Write-Host "  📆 UPCOMING ($($upcoming.Count))" -ForegroundColor Green
        Write-Host "  ────────────" -ForegroundColor DarkGreen
        
        foreach ($task in $upcoming | Select-Object -First 5) {
            $global:LastShownTaskMap[$localId] = $task.id
            $dueDate = [datetime]::Parse($task.due)
            $daysUntil = [Math]::Round(($dueDate - $today).TotalDays)
            
            Write-Host "  " -NoNewline
            Write-Host "[$localId]" -NoNewline -ForegroundColor DarkGray
            Write-Host " " -NoNewline
            
            # Day of week
            $dayStr = $dueDate.ToString("ddd")
            Write-Host $dayStr -NoNewline -ForegroundColor DarkGreen
            Write-Host " " -NoNewline
            
            # Task
            Write-Host $task.text -NoNewline -ForegroundColor Green
            
            # Days until
            if ($daysUntil -eq 1) {
                Write-Host " (tomorrow)" -NoNewline -ForegroundColor DarkGreen
            } else {
                Write-Host " (${daysUntil}d)" -NoNewline -ForegroundColor DarkGreen
            }
            
            Write-Host ""
            $localId++
        }
        Write-Host ""
    }
    
    # NO DUE DATE Section (from current context)
    $noDue = $data.tasks | Where-Object {
        $_.status -eq 'pending' -and -not $_.due -and
        ($_.project -eq $global:CurrentContext -or $global:CurrentContext -eq 'inbox')
    } | Sort-Object priority -Descending
    
    if ($noDue) {
        Write-Host "  📋 NO DUE DATE ($($noDue.Count))" -ForegroundColor Gray
        Write-Host "  ──────────────" -ForegroundColor DarkGray
        
        foreach ($task in $noDue | Select-Object -First 3) {
            $global:LastShownTaskMap[$localId] = $task.id
            
            Write-Host "  " -NoNewline
            Write-Host "[$localId]" -NoNewline -ForegroundColor DarkGray
            Write-Host " " -NoNewline
            
            $priSymbol = @("  ", "🔹", "🔸", "🔺")[$task.priority]
            Write-Host $priSymbol -NoNewline
            
            Write-Host $task.text -ForegroundColor Gray
            $localId++
        }
        
        if ($noDue.Count -gt 3) {
            Write-Host "  ... and $($noDue.Count - 3) more" -ForegroundColor DarkGray
        }
        Write-Host ""
    }
    
    # Quick stats footer
    Write-Host "  ────────────────────────────────────────────" -ForegroundColor DarkGray
    
    # Productivity tip
    $tips = @(
        "💡 Press Tab to see available commands",
        "💡 Use 'next' to see AI-suggested tasks",
        "💡 Try 'report' for time tracking insights",
        "💡 Use @project to quickly set context",
        "💡 Type '1-5' to complete multiple tasks"
    )
    $tip = $tips | Get-Random
    Write-Host "  $tip" -ForegroundColor DarkCyan
    Write-Host ""
}

function Show-ProjectDashboard {
    $data = Get-TaskData
    
    Clear-Host
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor DarkGray
    Write-Host "  ║                    PROJECT DASHBOARD                        ║" -ForegroundColor Cyan
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor DarkGray
    Write-Host ""
    
    $projects = $data.projects | Where-Object { -not $_.isArchived } | Sort-Object sortOrder
    
    foreach ($proj in $projects) {
        $tasks = @($data.tasks | Where-Object { 
            $_.project -eq $proj.name -and $_.status -eq 'pending' 
        })
        
        $completed = @($data.tasks | Where-Object { 
            $_.project -eq $proj.name -and $_.status -eq 'completed'
        }).Count
        
        $overdue = @($tasks | Where-Object {
            $_.due -and $_.due -lt (Get-Date).ToString("yyyy-MM-dd")
        }).Count
        
        # Time logged this week
        $weekStart = (Get-Date).Date.AddDays(-[int](Get-Date).DayOfWeek)
        $timeThisWeek = 0
        if ($data.timelogs) {
            $logs = $data.timelogs | Where-Object {
                $_.project -eq $proj.name -and
                [datetime]::Parse($_.date) -ge $weekStart
            }
            if ($logs) {
                $timeThisWeek = ($logs | Measure-Object minutes -Sum).Sum
            }
        }
        
        # Project header
        $icon = if ($proj.icon) { $proj.icon } else { "📁" }
        $marker = if ($proj.name -eq $global:CurrentContext) { "▶" } else { " " }
        
        Write-Host "  $marker " -NoNewline
        Write-Host "$icon $($proj.name.ToUpper())" -NoNewline -ForegroundColor $(
            if ($proj.name -eq $global:CurrentContext) { "Yellow" } else { "Green" }
        )
        
        # Stats on same line
        Write-Host " (" -NoNewline -ForegroundColor DarkGray
        Write-Host "$($tasks.Count)" -NoNewline -ForegroundColor White
        Write-Host " pending" -NoNewline -ForegroundColor DarkGray
        
        if ($overdue -gt 0) {
            Write-Host ", " -NoNewline -ForegroundColor DarkGray
            Write-Host "$overdue" -NoNewline -ForegroundColor Red
            Write-Host " overdue" -NoNewline -ForegroundColor DarkGray
        }
        
        if ($completed -gt 0) {
            Write-Host ", " -NoNewline -ForegroundColor DarkGray
            Write-Host "$completed" -NoNewline -ForegroundColor Green
            Write-Host " done" -NoNewline -ForegroundColor DarkGray
        }
        
        if ($timeThisWeek -gt 0) {
            $hours = [Math]::Round($timeThisWeek / 60, 1)
            Write-Host ", " -NoNewline -ForegroundColor DarkGray
            Write-Host "${hours}h" -NoNewline -ForegroundColor Cyan
            Write-Host " this week" -NoNewline -ForegroundColor DarkGray
        }
        
        Write-Host ")" -ForegroundColor DarkGray
        
        # Description
        if ($proj.description) {
            Write-Host "     $($proj.description)" -ForegroundColor Gray
        }
        
        # Progress bar
        if ($tasks.Count -gt 0 -or $completed -gt 0) {
            $total = $tasks.Count + $completed
            $percent = [Math]::Round(($completed / $total) * 100)
            $barWidth = 30
            $filled = [Math]::Round(($percent / 100) * $barWidth)
            $empty = $barWidth - $filled
            
            Write-Host "     " -NoNewline
            Write-Host "[" -NoNewline -ForegroundColor DarkGray
            Write-Host ("█" * $filled) -NoNewline -ForegroundColor Green
            Write-Host ("░" * $empty) -NoNewline -ForegroundColor DarkGray
            Write-Host "] $percent%" -ForegroundColor DarkGray
        }
        
        Write-Host ""
    }
    
    # Summary
    Write-Host "  ────────────────────────────────────────────" -ForegroundColor DarkGray
    $totalPending = @($data.tasks | Where-Object { $_.status -eq 'pending' }).Count
    $totalProjects = @($projects).Count
    
    Write-Host "  Total: " -NoNewline -ForegroundColor Gray
    Write-Host "$totalProjects projects" -NoNewline -ForegroundColor White
    Write-Host ", " -NoNewline -ForegroundColor Gray
    Write-Host "$totalPending pending tasks" -ForegroundColor White
    Write-Host ""
}

function Show-WeekView {
    $data = Get-TaskData
    $today = (Get-Date).Date
    $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
    
    Clear-Host
    Write-Host "`n  WEEK VIEW - $(Get-Date -Format 'MMMM yyyy')" -ForegroundColor Cyan
    Write-Host "  ═══════════════════════════════════════════" -ForegroundColor DarkCyan
    Write-Host ""
    
    for ($i = 0; $i -lt 7; $i++) {
        $currentDay = $weekStart.AddDays($i)
        $dayStr = $currentDay.ToString("yyyy-MM-dd")
        
        $dayTasks = $data.tasks | Where-Object {
            $_.status -eq 'pending' -and $_.due -eq $dayStr
        }
        
        # Day header
        $dayName = $currentDay.ToString("dddd, MMM d")
        $isToday = $currentDay.Date -eq $today
        
        Write-Host "  " -NoNewline
        if ($isToday) {
            Write-Host "▶ $dayName" -NoNewline -ForegroundColor Yellow
            Write-Host " (TODAY)" -ForegroundColor DarkYellow
        } else {
            Write-Host "  $dayName" -ForegroundColor $(
                if ($currentDay -lt $today) { "DarkGray" } else { "White" }
            )
        }
        
        # Tasks for this day
        if ($dayTasks) {
            foreach ($task in $dayTasks | Sort-Object priority -Descending) {
                Write-Host "    " -NoNewline
                
                $priSymbol = @("○", "◐", "◑", "●")[$task.priority]
                Write-Host $priSymbol -NoNewline -ForegroundColor $(
                    @("Gray", "Blue", "Yellow", "Red")[$task.priority]
                )
                
                Write-Host " $($task.text)" -ForegroundColor $(
                    if ($currentDay -lt $today) { "DarkRed" }
                    elseif ($isToday) { "Yellow" }
                    else { "Gray" }
                )
                
                if ($task.estimatedMinutes) {
                    $hrs = [Math]::Round($task.estimatedMinutes / 60, 1)
                    Write-Host "      ⏱ ${hrs}h" -ForegroundColor DarkGray
                }
            }
        } else {
            Write-Host "    (no tasks)" -ForegroundColor DarkGray
        }
        
        Write-Host ""
    }
}

# NEW: Refactored to use structured CommandContext instead of regex parsing
function Add-SmartTask {
    param([CommandContext]$context)
    
    # Validate we have some text to work with
    if ([string]::IsNullOrWhiteSpace($context.GetText())) {
        Write-Host "Usage: add [@project] [p1-3] [due:date] [est:time] [#tags] <description>" -ForegroundColor Yellow
        return
    }
    
    $data = Get-TaskData
    
    # Create task with structured parsing - no more regex!
    $task = @{
        id = ++$data.lastId
        text = $context.GetText()              # Clean text with arguments removed
        project = $context.GetProject()        # Handles @project or defaults to current context
        priority = $context.GetPriority()      # Handles p1-3, !, !!, !!!
        status = 'pending'
        created = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        due = $null
        estimatedMinutes = $null
        tags = $context.GetTags()              # Handles #tag1 #tag2
        depends = $context.GetArg('dependencies', @())  # Handles dep:id
        recur = $context.GetArg('recur', $null)       # Handles recur:pattern
        notes = @()
    }
    
    # Handle project creation if needed
    if ($context.HasArg('project')) {
        $projName = $context.GetArg('project', '')
        $proj = $data.projects | Where-Object { 
            $_.name -eq $projName -or $_.name -like "$projName*"
        } | Select-Object -First 1
        
        if (-not $proj) {
            # Offer to create new project
            Write-Host "Project '$projName' not found. Create it? (y/n): " -NoNewline -ForegroundColor Yellow
            if ((Read-Host) -eq 'y') {
                $newProj = @{
                    name = $projName
                    description = ""
                    color = "Gray"
                    sortOrder = $data.projects.Count
                    isArchived = $false
                }
                $data.projects += $newProj
                $task.project = $projName
            }
        } else {
            $task.project = $proj.name
        }
    }
    
    # Handle due date parsing
    if ($context.HasArg('due')) {
        $task.due = Parse-SmartDate $context.GetArg('due', '')
    }
    
    # Handle time estimates 
    if ($context.HasArg('estimate')) {
        $estStr = $context.GetArg('estimate', '')
        if ($estStr -match '(\d+(?:\.\d+)?)h') {
            $task.estimatedMinutes = [int]([float]$matches[1] * 60)
        } elseif ($estStr -match '(\d+)m') {
            $task.estimatedMinutes = [int]$matches[1]
        }
    }
    
    # Add to data
    $data.tasks += $task
    Save-TaskData $data
    $global:SessionStats.TasksAdded++
    
    # Display confirmation with rich formatting (unchanged)
    Write-Host "`n  ✅ " -NoNewline -ForegroundColor Green
    Write-Host "Task #$($task.id) created" -ForegroundColor White
    
    Write-Host "     " -NoNewline
    $priSymbol = @("", "🔹", "🔸", "🔺")[$task.priority]
    if ($priSymbol) { Write-Host "$priSymbol " -NoNewline }
    Write-Host $task.text -ForegroundColor White
    
    if ($task.project -ne 'inbox') {
        Write-Host "     📁 @$($task.project)" -ForegroundColor DarkCyan
    }
    
    if ($task.due) {
        $dueDate = [datetime]::Parse($task.due)
        $daysUntil = [Math]::Round(($dueDate - (Get-Date).Date).TotalDays)
        $dueDisplay = $dueDate.ToString("ddd, MMM d")
        
        Write-Host "     📅 Due: $dueDisplay" -NoNewline -ForegroundColor Yellow
        if ($daysUntil -eq 0) {
            Write-Host " (today)" -ForegroundColor Yellow
        } elseif ($daysUntil -eq 1) {
            Write-Host " (tomorrow)" -ForegroundColor Yellow
        } elseif ($daysUntil -gt 0) {
            Write-Host " (in $daysUntil days)" -ForegroundColor Gray
        }
    }
    
    if ($task.estimatedMinutes) {
        $hrs = [Math]::Round($task.estimatedMinutes / 60, 1)
        Write-Host "     ⏱ Estimated: ${hrs}h" -ForegroundColor Cyan
    }
    
    if ($task.tags.Count -gt 0) {
        Write-Host "     🏷 Tags: " -NoNewline -ForegroundColor Blue
        Write-Host ($task.tags | ForEach-Object { "#$_" }) -join ", " -ForegroundColor Blue
    }
    
    if ($task.recur) {
        Write-Host "     🔄 Recurs: $($task.recur)" -ForegroundColor Magenta
    }
    
    Write-Host ""
}

function Parse-SmartDate {
    param([string]$input)
    
    $today = (Get-Date).Date
    
    switch ($input.ToLower()) {
        'today' { return $today.ToString("yyyy-MM-dd") }
        'tomorrow' { return $today.AddDays(1).ToString("yyyy-MM-dd") }
        'yesterday' { return $today.AddDays(-1).ToString("yyyy-MM-dd") }
        
        # Weekdays
        { $_ -in @('mon', 'monday') } { 
            $target = [DayOfWeek]::Monday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('tue', 'tuesday') } {
            $target = [DayOfWeek]::Tuesday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('wed', 'wednesday') } {
            $target = [DayOfWeek]::Wednesday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('thu', 'thursday') } {
            $target = [DayOfWeek]::Thursday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('fri', 'friday') } {
            $target = [DayOfWeek]::Friday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('sat', 'saturday') } {
            $target = [DayOfWeek]::Saturday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        { $_ -in @('sun', 'sunday') } {
            $target = [DayOfWeek]::Sunday
            $daysUntil = (([int]$target - [int]$today.DayOfWeek + 7) % 7)
            if ($daysUntil -eq 0) { $daysUntil = 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        
        # Relative dates
        'nextweek' { return $today.AddDays(7).ToString("yyyy-MM-dd") }
        'nextmonth' { return $today.AddMonths(1).ToString("yyyy-MM-dd") }
        'eow' { # End of week (Friday)
            $friday = [DayOfWeek]::Friday
            $daysUntil = ([int]$friday - [int]$today.DayOfWeek)
            if ($daysUntil -lt 0) { $daysUntil += 7 }
            return $today.AddDays($daysUntil).ToString("yyyy-MM-dd")
        }
        'eom' { # End of month
            $lastDay = [DateTime]::DaysInMonth($today.Year, $today.Month)
            return (Get-Date -Year $today.Year -Month $today.Month -Day $lastDay).ToString("yyyy-MM-dd")
        }
        
        default {
            # Try parsing as date
            if ($input -match '^\d{4}-\d{2}-\d{2}$') {
                return $input
            }
            # Try parsing as +N days
            if ($input -match '^\+(\d+)$') {
                return $today.AddDays([int]$matches[1]).ToString("yyyy-MM-dd")
            }
            # Try parsing as N days
            if ($input -match '^(\d+)d$') {
                return $today.AddDays([int]$matches[1]).ToString("yyyy-MM-dd")
            }
            
            return $null
        }
    }
}

function Show-NextActions {
    $data = Get-TaskData
    $today = (Get-Date).Date
    $todayStr = $today.ToString("yyyy-MM-dd")
    
    Clear-Host
    Write-Host "`n  🎯 NEXT ACTIONS - AI Recommendations" -ForegroundColor Cyan
    Write-Host "  ════════════════════════════════════" -ForegroundColor DarkCyan
    Write-Host ""
    
    # Algorithm: Score tasks based on multiple factors
    $scoredTasks = @()
    
    foreach ($task in $data.tasks | Where-Object { $_.status -eq 'pending' }) {
        $score = 0
        
        # Priority weight (0-30 points)
        $score += $task.priority * 10
        
        # Due date urgency (0-50 points)
        if ($task.due) {
            $dueDate = [datetime]::Parse($task.due)
            $daysUntil = ($dueDate - $today).TotalDays
            
            if ($daysUntil -lt 0) {
                $score += 50 + [Math]::Min([Math]::Abs($daysUntil) * 2, 20)  # Overdue
            } elseif ($daysUntil -eq 0) {
                $score += 45  # Today
            } elseif ($daysUntil -eq 1) {
                $score += 35  # Tomorrow
            } elseif ($daysUntil -le 3) {
                $score += 25  # This week
            } elseif ($daysUntil -le 7) {
                $score += 15  # Next week
            }
        }
        
        # Context match (0-20 points)
        if ($task.project -eq $global:CurrentContext) {
            $score += 20
        }
        
        # Has estimate (0-10 points) - ready to work on
        if ($task.estimatedMinutes) {
            $score += 10
        }
        
        # Small tasks get bonus (0-10 points) - quick wins
        if ($task.estimatedMinutes -and $task.estimatedMinutes -le 30) {
            $score += 10
        }
        
        # Blocked tasks get penalty
        if ($task.depends -and $task.depends.Count -gt 0) {
            $blockedBy = $data.tasks | Where-Object { 
                $_.id -in $task.depends -and $_.status -eq 'pending' 
            }
            if ($blockedBy) {
                $score -= 30
            }
        }
        
        $scoredTasks += [PSCustomObject]@{
            Task = $task
            Score = $score
            Reason = ""
        }
    }
    
    # Sort by score and take top 5
    $recommendations = $scoredTasks | Sort-Object Score -Descending | Select-Object -First 5
    
    if ($recommendations.Count -eq 0) {
        Write-Host "  No pending tasks to recommend!" -ForegroundColor Green
        Write-Host ""
        return
    }
    
    Write-Host "  Based on priority, urgency, and context:" -ForegroundColor Gray
    Write-Host ""
    
    $num = 1
    foreach ($rec in $recommendations) {
        $task = $rec.Task
        
        # Determine why this was recommended
        $reasons = @()
        if ($task.due) {
            $dueDate = [datetime]::Parse($task.due)
            $daysUntil = ($dueDate - $today).TotalDays
            
            if ($daysUntil -lt 0) {
                $reasons += "⚠ OVERDUE"
            } elseif ($daysUntil -eq 0) {
                $reasons += "📅 Due today"
            } elseif ($daysUntil -eq 1) {
                $reasons += "⏰ Due tomorrow"
            }
        }
        
        if ($task.priority -eq 3) {
            $reasons += "🔺 High priority"
        }
        
        if ($task.project -eq $global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
            $reasons += "📍 In current context"
        }
        
        if ($task.estimatedMinutes -and $task.estimatedMinutes -le 30) {
            $reasons += "⚡ Quick win (${task.estimatedMinutes}m)"
        }
        
        # Display recommendation
        Write-Host "  $num. " -NoNewline -ForegroundColor Yellow
        Write-Host $task.text -ForegroundColor White
        
        if ($task.project -ne 'inbox') {
            Write-Host "     @$($task.project)" -ForegroundColor DarkCyan
        }
        
        if ($reasons.Count -gt 0) {
            Write-Host "     $($reasons -join ' | ')" -ForegroundColor Gray
        }
        
        Write-Host ""
        $num++
    }
    
    Write-Host "  ────────────────────────────────────────────" -ForegroundColor DarkGray
    Write-Host "  💡 Start with #1 for maximum productivity" -ForegroundColor DarkCyan
    Write-Host ""
}

function Show-ProductivityStats {
    $data = Get-TaskData
    
    Clear-Host
    Write-Host "`n  📊 PRODUCTIVITY ANALYTICS" -ForegroundColor Cyan
    Write-Host "  ════════════════════════════" -ForegroundColor DarkCyan
    Write-Host ""
    
    # Calculate stats
    $totalTasks = $data.tasks.Count
    $pending = @($data.tasks | Where-Object { $_.status -eq 'pending' }).Count
    $completed = @($data.tasks | Where-Object { $_.status -eq 'completed' }).Count
    
    # Add completed from archive
    if ($data.completed) {
        $completed += $data.completed.Count
    }
    
    $completionRate = if ($totalTasks -gt 0) { 
        [Math]::Round(($completed / ($completed + $pending)) * 100, 1) 
    } else { 0 }
    
    # This week stats
    $weekStart = (Get-Date).Date.AddDays(-[int](Get-Date).DayOfWeek)
    $weekTasks = @($data.tasks | Where-Object {
        $_.created -and [datetime]::Parse($_.created) -ge $weekStart
    })
    $weekCompleted = @($weekTasks | Where-Object { $_.status -eq 'completed' }).Count
    $weekAdded = $weekTasks.Count
    
    # Time tracking stats
    $totalMinutes = 0
    $weekMinutes = 0
    $todayMinutes = 0
    
    if ($data.timelogs) {
        $totalMinutes = ($data.timelogs | Measure-Object minutes -Sum).Sum
        
        $weekLogs = $data.timelogs | Where-Object {
            [datetime]::Parse($_.date) -ge $weekStart
        }
        if ($weekLogs) {
            $weekMinutes = ($weekLogs | Measure-Object minutes -Sum).Sum
        }
        
        $todayLogs = $data.timelogs | Where-Object {
            $_.date -eq (Get-Date).ToString("yyyy-MM-dd")
        }
        if ($todayLogs) {
            $todayMinutes = ($todayLogs | Measure-Object minutes -Sum).Sum
        }
    }
    
    # Display stats
    Write-Host "  📋 TASKS" -ForegroundColor Yellow
    Write-Host "  ────────" -ForegroundColor DarkYellow
    Write-Host "  Total Tasks:      $($pending + $completed)" -ForegroundColor White
    Write-Host "  Pending:          $pending" -ForegroundColor Yellow
    Write-Host "  Completed:        $completed" -ForegroundColor Green
    Write-Host "  Completion Rate:  $completionRate%" -ForegroundColor Cyan
    Write-Host ""
    
    Write-Host "  📅 THIS WEEK" -ForegroundColor Yellow
    Write-Host "  ────────────" -ForegroundColor DarkYellow
    Write-Host "  Added:            $weekAdded" -ForegroundColor White
    Write-Host "  Completed:        $weekCompleted" -ForegroundColor Green
    
    if ($weekMinutes -gt 0) {
        $weekHours = [Math]::Round($weekMinutes / 60, 1)
        Write-Host "  Time Logged:      ${weekHours}h" -ForegroundColor Cyan
    }
    Write-Host ""
    
    # Project breakdown
    Write-Host "  📁 BY PROJECT" -ForegroundColor Yellow
    Write-Host "  ─────────────" -ForegroundColor DarkYellow
    
    $projectStats = $data.tasks | Group-Object project | Sort-Object Count -Descending
    foreach ($proj in $projectStats | Select-Object -First 5) {
        $projPending = @($proj.Group | Where-Object { $_.status -eq 'pending' }).Count
        $projCompleted = @($proj.Group | Where-Object { $_.status -eq 'completed' }).Count
        
        Write-Host "  $($proj.Name):" -NoNewline -ForegroundColor White
        Write-Host " $projPending pending, $projCompleted done" -ForegroundColor Gray
    }
    Write-Host ""
    
    # Priority distribution
    Write-Host "  🎯 PRIORITY DISTRIBUTION" -ForegroundColor Yellow
    Write-Host "  ────────────────────────" -ForegroundColor DarkYellow
    
    $p0 = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.priority -eq 0 }).Count
    $p1 = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.priority -eq 1 }).Count
    $p2 = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.priority -eq 2 }).Count
    $p3 = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.priority -eq 3 }).Count
    
    Write-Host "  Normal:   $p0" -ForegroundColor Gray
    Write-Host "  Low (p3): $p1" -ForegroundColor Blue
    Write-Host "  Med (p2): $p2" -ForegroundColor Yellow
    Write-Host "  High (p1): $p3" -ForegroundColor Red
    Write-Host ""
    
    # Session stats
    $sessionTime = [Math]::Round(((Get-Date) - $global:SessionStats.SessionStart).TotalMinutes)
    
    Write-Host "  ⚡ THIS SESSION" -ForegroundColor Yellow
    Write-Host "  ───────────────" -ForegroundColor DarkYellow
    Write-Host "  Duration:         ${sessionTime}m" -ForegroundColor White
    Write-Host "  Commands Run:     $($global:SessionStats.CommandsRun)" -ForegroundColor White
    Write-Host "  Tasks Added:      $($global:SessionStats.TasksAdded)" -ForegroundColor Green
    Write-Host "  Tasks Completed:  $($global:SessionStats.TasksCompleted)" -ForegroundColor Green
    
    if ($global:SessionStats.TimeLogged -gt 0) {
        $loggedHours = [Math]::Round($global:SessionStats.TimeLogged / 60, 1)
        Write-Host "  Time Logged:      ${loggedHours}h" -ForegroundColor Cyan
    }
    Write-Host ""
}

# === SMART HELP SYSTEM ===
function Show-SmartHelp {
    param([CommandContext]$context)
    
    Clear-Host
    
    # Get the help topic from context
    $helpText = $context.GetText()
    $helpTopic = if ($helpText) { $helpText.Trim().ToLower() } else { "" }
    
    if ([string]::IsNullOrEmpty($helpTopic)) {
        # General help - show all commands organized by category
        Show-GeneralHelp
    } elseif ($helpTopic.StartsWith('proj')) {
        # Project-related help
        Show-ProjectHelp $helpTopic
    } elseif ($helpTopic.StartsWith('dep')) {
        # Dependency-related help  
        Show-DependencyHelp $helpTopic
    } elseif ($helpTopic -eq 'add' -or $helpTopic -eq 'a') {
        # Detailed help for add command
        Show-AddCommandHelp
    } else {
        # Specific command help
        Show-CommandHelp $helpTopic
    }
}

function Show-GeneralHelp {
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor Cyan
    Write-Host "  ║                    TODOIST TUI HELP                        ║" -ForegroundColor Cyan
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor Cyan
    Write-Host ""
    
    Write-Host "  📋 QUICK START" -ForegroundColor Yellow
    Write-Host "  ──────────────" -ForegroundColor DarkYellow
    Write-Host "  add @project p1 Task description     " -NoNewline -ForegroundColor White
    Write-Host "→ Add task with project & priority" -ForegroundColor Gray
    Write-Host "  a @work due:tomorrow Fix bug         " -NoNewline -ForegroundColor White
    Write-Host "→ Quick add with due date" -ForegroundColor Gray
    Write-Host "  done 1-3                             " -NoNewline -ForegroundColor White
    Write-Host "→ Complete multiple tasks" -ForegroundColor Gray
    Write-Host "  proj add @newproject                 " -NoNewline -ForegroundColor White
    Write-Host "→ Create new project" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  🔍 DETAILED HELP" -ForegroundColor Yellow  
    Write-Host "  ────────────────" -ForegroundColor DarkYellow
    Write-Host "  help add         " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Syntax & examples for add command" -ForegroundColor Gray
    Write-Host "  help proj        " -NoNewline -ForegroundColor Cyan
    Write-Host "→ All project commands" -ForegroundColor Gray
    Write-Host "  help [command]   " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Specific command syntax" -ForegroundColor Gray
    Write-Host ""
    
    # Show command categories
    $parser = [SmartCommandParser]::new()
    $categories = @{}
    
    foreach ($cmd in $parser.Commands.GetEnumerator()) {
        $category = $cmd.Value.Category
        if (-not $categories.ContainsKey($category)) {
            $categories[$category] = @()
        }
        $categories[$category] += @{
            Name = $cmd.Key
            Description = $cmd.Value.Description
        }
    }
    
    foreach ($category in $categories.Keys | Sort-Object) {
        $icon = switch ($category) {
            'Task' { '✅' }
            'Project' { '📁' }  
            'Time' { '⏱' }
            'View' { '👁' }
            'Utility' { '🔧' }
            default { '📌' }
        }
        
        Write-Host "  $icon $($category.ToUpper())" -ForegroundColor Yellow
        Write-Host "  $('-' * ($category.Length + 3))" -ForegroundColor DarkYellow
        
        foreach ($command in $categories[$category] | Sort-Object Name) {
            $cmdName = $command.Name.PadRight(12)
            Write-Host "  $cmdName " -NoNewline -ForegroundColor Cyan
            Write-Host "→ $($command.Description)" -ForegroundColor Gray
        }
        Write-Host ""
    }
}

function Show-AddCommandHelp {
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor Green
    Write-Host "  ║                    ADD COMMAND HELP                        ║" -ForegroundColor Green  
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor Green
    Write-Host ""
    
    Write-Host "  📝 SYNTAX" -ForegroundColor Yellow
    Write-Host "  ─────────" -ForegroundColor DarkYellow
    Write-Host "  add [@project] [p1-3] [due:date] [est:time] [#tags] <description>" -ForegroundColor White
    Write-Host ""
    
    Write-Host "  🎯 ARGUMENTS (can appear in any order)" -ForegroundColor Yellow
    Write-Host "  ─────────────────────────────────────────" -ForegroundColor DarkYellow
    Write-Host "  @project     " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Assign to project (e.g., @work, @home)" -ForegroundColor Gray
    Write-Host "  p1, p2, p3   " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Set priority (p1=high, p3=low)" -ForegroundColor Gray
    Write-Host "  !, !!, !!!   " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Alternative priority syntax" -ForegroundColor Gray
    Write-Host "  due:date     " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Set due date (today, tomorrow, +3d, 2024-12-25)" -ForegroundColor Gray
    Write-Host "  est:time     " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Time estimate (2h, 30m, 1.5h)" -ForegroundColor Gray
    Write-Host "  #tag         " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Add tags (e.g., #urgent, #meeting)" -ForegroundColor Gray
    Write-Host "  recur:pattern" -NoNewline -ForegroundColor Cyan
    Write-Host "→ Recurring task (daily, weekly, monthly)" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  💡 EXAMPLES" -ForegroundColor Yellow
    Write-Host "  ───────────" -ForegroundColor DarkYellow
    Write-Host "  add Write quarterly report" -ForegroundColor White
    Write-Host "  add @work p1 Review code before deadline" -ForegroundColor White
    Write-Host "  add @home due:tomorrow #shopping Buy groceries" -ForegroundColor White
    Write-Host "  add @project est:2h #meeting Prepare presentation" -ForegroundColor White
    Write-Host "  add p2 due:friday #urgent Complete tax filing" -ForegroundColor White
    Write-Host "  add recur:daily @personal Take vitamins" -ForegroundColor White
    Write-Host ""
    
    Write-Host "  🚀 QUICK ALIASES" -ForegroundColor Yellow
    Write-Host "  ────────────────" -ForegroundColor DarkYellow
    Write-Host "  a            " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Short alias for 'add'" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  📋 SMART FEATURES" -ForegroundColor Yellow
    Write-Host "  ─────────────────" -ForegroundColor DarkYellow
    Write-Host "  • Arguments can appear in ANY order" -ForegroundColor Gray
    Write-Host "  • Projects auto-created if they don't exist" -ForegroundColor Gray
    Write-Host "  • Smart date parsing (today, tomorrow, +1w)" -ForegroundColor Gray
    Write-Host "  • Multiple tags supported in one command" -ForegroundColor Gray
    Write-Host "  • Tab completion for projects and commands" -ForegroundColor Gray
    Write-Host ""
}

function Show-ProjectHelp {
    param([string]$helpTopic)
    
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor Blue
    Write-Host "  ║                   PROJECT COMMANDS                         ║" -ForegroundColor Blue
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor Blue
    Write-Host ""
    
    Write-Host "  📁 PROJECT MANAGEMENT" -ForegroundColor Yellow
    Write-Host "  ─────────────────────" -ForegroundColor DarkYellow
    Write-Host "  proj add <name>      " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Create new project" -ForegroundColor Gray
    Write-Host "  proj rename <old> <new>" -NoNewline -ForegroundColor Cyan  
    Write-Host "→ Rename existing project" -ForegroundColor Gray
    Write-Host "  proj archive <name>  " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Archive completed project" -ForegroundColor Gray
    Write-Host "  proj delete <name>   " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Delete project (with confirmation)" -ForegroundColor Gray
    Write-Host "  proj stats [name]    " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Show project statistics" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  🎯 PROJECT FOCUS" -ForegroundColor Yellow
    Write-Host "  ────────────────" -ForegroundColor DarkYellow
    Write-Host "  focus <project>      " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Set current project context" -ForegroundColor Gray
    Write-Host "  focus clear          " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Clear project context" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  💡 EXAMPLES" -ForegroundColor Yellow
    Write-Host "  ───────────" -ForegroundColor DarkYellow
    Write-Host "  proj add @website-redesign" -ForegroundColor White
    Write-Host "  focus @website-redesign" -ForegroundColor White
    Write-Host "  add p1 Design new homepage    (uses focused project)" -ForegroundColor White
    Write-Host ""
}

function Show-DependencyHelp {
    param([string]$helpTopic)
    
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor Magenta
    Write-Host "  ║                  DEPENDENCY COMMANDS                       ║" -ForegroundColor Magenta
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor Magenta
    Write-Host ""
    
    Write-Host "  🔗 TASK DEPENDENCIES" -ForegroundColor Yellow
    Write-Host "  ────────────────────" -ForegroundColor DarkYellow
    Write-Host "  dep add <task> <depends-on>" -NoNewline -ForegroundColor Cyan
    Write-Host "→ Create dependency" -ForegroundColor Gray
    Write-Host "  dep remove <task> <depends-on>" -NoNewline -ForegroundColor Cyan
    Write-Host "→ Remove dependency" -ForegroundColor Gray
    Write-Host "  dep show [task]      " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Show dependencies" -ForegroundColor Gray
    Write-Host "  blocked              " -NoNewline -ForegroundColor Cyan
    Write-Host "→ Show blocked tasks" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "  💡 EXAMPLES" -ForegroundColor Yellow
    Write-Host "  ───────────" -ForegroundColor DarkYellow
    Write-Host "  dep add 5 3          " -NoNewline -ForegroundColor White
    Write-Host "→ Task 5 depends on task 3" -ForegroundColor Gray
    Write-Host "  dep show 5           " -NoNewline -ForegroundColor White
    Write-Host "→ Show what task 5 depends on" -ForegroundColor Gray
    Write-Host ""
}

function Show-CommandHelp {
    param([string]$command)
    
    $parser = [SmartCommandParser]::new()
    
    if ($parser.Commands.ContainsKey($command)) {
        $cmd = $parser.Commands[$command]
        
        Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor Cyan
        Write-Host "  ║                   COMMAND: $($command.ToUpper().PadRight(40))║" -ForegroundColor Cyan
        Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor Cyan
        Write-Host ""
        
        Write-Host "  📝 DESCRIPTION" -ForegroundColor Yellow
        Write-Host "  ──────────────" -ForegroundColor DarkYellow
        Write-Host "  $($cmd.Description)" -ForegroundColor White
        Write-Host ""
        
        Write-Host "  📂 CATEGORY" -ForegroundColor Yellow
        Write-Host "  ───────────" -ForegroundColor DarkYellow
        Write-Host "  $($cmd.Category)" -ForegroundColor White
        Write-Host ""
        
        if ($cmd.NeedsArg) {
            Write-Host "  ⚙️  USAGE" -ForegroundColor Yellow
            Write-Host "  ─────────" -ForegroundColor DarkYellow
            Write-Host "  $command <arguments>" -ForegroundColor Cyan
            Write-Host ""
        }
        
        # Check for aliases
        $aliases = @()
        foreach ($alias in $parser.Aliases.GetEnumerator()) {
            if ($alias.Value -eq $command) {
                $aliases += $alias.Key
            }
        }
        
        if ($aliases.Count -gt 0) {
            Write-Host "  🚀 ALIASES" -ForegroundColor Yellow
            Write-Host "  ──────────" -ForegroundColor DarkYellow
            Write-Host "  $($aliases -join ', ')" -ForegroundColor Cyan
            Write-Host ""
        }
        
        Write-Host "  💡 TIP: Use 'help add' for detailed syntax help on complex commands" -ForegroundColor DarkCyan
    } else {
        Write-Host "`n  ❌ Unknown command: '$command'" -ForegroundColor Red
        Write-Host "  Type 'help' to see all available commands" -ForegroundColor Gray
    }
    Write-Host ""
}

# === ENHANCED INPUT HANDLER ===
class SmartInputHandler {
    [SmartCommandParser] $Parser
    [string] $Buffer = ""
    [int] $CursorPos = 0
    [array] $Completions = @()
    [array] $CompletionDetails = @()
    [int] $CompletionIndex = -1
    [bool] $InCompletion = $false
    [string] $OriginalInput = ""
    [array] $History = @()
    [int] $HistoryIndex = -1
    
    SmartInputHandler([SmartCommandParser]$parser) {
        $this.Parser = $parser
        $this.LoadHistory()
    }
    
    [void] LoadHistory() {
        $historyFile = Join-Path $PSScriptRoot "history.txt"
        if (Test-Path $historyFile) {
            $this.History = Get-Content $historyFile
        }
    }
    
    [void] SaveHistory() {
        $historyFile = Join-Path $PSScriptRoot "history.txt"
        $this.History[-100..-1] | Set-Content $historyFile
    }
    
    [string] ReadCommand() {
        $this.Buffer = ""
        $this.CursorPos = 0
        $this.InCompletion = $false
        $this.HistoryIndex = -1
        
        Write-Host -NoNewline (Get-Prompt)
        
        while ($true) {
            $key = [Console]::ReadKey($true)
            
            switch ($key.Key) {
                'Tab' {
                    $this.HandleTab()
                }
                'Enter' {
                    if ($this.InCompletion) {
                        $this.AcceptCompletion()
                        # Don't submit, just accept completion and continue editing
                    } else {
                        Write-Host ""
                        
                        # Add to history
                        if (-not [string]::IsNullOrWhiteSpace($this.Buffer)) {
                            $this.History += $this.Buffer
                            $this.SaveHistory()
                        }
                        
                        return $this.Buffer
                    }
                }
                'Escape' {
                    if ($this.InCompletion) {
                        $this.CancelCompletion()
                    } else {
                        $this.Buffer = ""
                        $this.CursorPos = 0
                        $this.RedrawLine()
                    }
                }
                'Backspace' {
                    if ($this.InCompletion) {
                        $this.CancelCompletion()
                    }
                    if ($this.CursorPos -gt 0) {
                        $this.Buffer = $this.Buffer.Remove($this.CursorPos - 1, 1)
                        $this.CursorPos--
                        $this.RedrawLine()
                    }
                }
                'UpArrow' {
                    if ($this.History.Count -gt 0) {
                        if ($this.HistoryIndex -eq -1) {
                            $this.HistoryIndex = $this.History.Count - 1
                        } elseif ($this.HistoryIndex -gt 0) {
                            $this.HistoryIndex--
                        }
                        
                        $this.Buffer = $this.History[$this.HistoryIndex]
                        $this.CursorPos = $this.Buffer.Length
                        $this.RedrawLine()
                    }
                }
                'DownArrow' {
                    if ($this.HistoryIndex -ge 0) {
                        if ($this.HistoryIndex -lt $this.History.Count - 1) {
                            $this.HistoryIndex++
                            $this.Buffer = $this.History[$this.HistoryIndex]
                        } else {
                            $this.HistoryIndex = -1
                            $this.Buffer = ""
                        }
                        $this.CursorPos = $this.Buffer.Length
                        $this.RedrawLine()
                    }
                }
                'LeftArrow' {
                    if ($this.CursorPos -gt 0) {
                        $this.CursorPos--
                        [Console]::SetCursorPosition(
                            (Get-Prompt).Length + $this.CursorPos,
                            [Console]::CursorTop
                        )
                    }
                }
                'RightArrow' {
                    if ($this.CursorPos -lt $this.Buffer.Length) {
                        $this.CursorPos++
                        [Console]::SetCursorPosition(
                            (Get-Prompt).Length + $this.CursorPos,
                            [Console]::CursorTop
                        )
                    }
                }
                'Home' {
                    $this.CursorPos = 0
                    [Console]::SetCursorPosition((Get-Prompt).Length, [Console]::CursorTop)
                }
                'End' {
                    $this.CursorPos = $this.Buffer.Length
                    [Console]::SetCursorPosition(
                        (Get-Prompt).Length + $this.CursorPos,
                        [Console]::CursorTop
                    )
                }
                default {
                    "INPUT: Processing key='$($key.KeyChar)' (KeyCode=$($key.Key)), InCompletion=$($this.InCompletion)" | Write-Debug
                    "INPUT: Before - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                    
                    if ($this.InCompletion -and $key.KeyChar -eq ' ') {
                        # Space accepts the current completion
                        "INPUT: Space pressed - accepting completion" | Write-Debug
                        
                        # Check what completion we're accepting to see if it needs immediate input
                        $selectedCompletion = ""
                        if ($this.Completions.Count -gt 0 -and $this.CompletionIndex -ge 0 -and $this.CompletionIndex -lt $this.Completions.Count) {
                            $selectedCompletion = $this.Completions[$this.CompletionIndex]
                        }
                        "INPUT: Selected completion='$selectedCompletion'" | Write-Debug
                        
                        $this.AcceptCompletion()
                        # Update OriginalInput to current buffer so next Tab works correctly
                        $this.OriginalInput = $this.Buffer
                        "INPUT: Updated OriginalInput to '$($this.OriginalInput)'" | Write-Debug
                        
                        # Only add space if:
                        # 1. Buffer doesn't already end with space (prevents double-space)
                        # 2. Completion is not a prefix that needs immediate input (@, #, due:, est:)
                        $needsImmediateInput = ($selectedCompletion -eq '@' -or $selectedCompletion -eq '#' -or 
                                              $selectedCompletion.EndsWith(':'))
                        
                        if (-not $this.Buffer.EndsWith(' ') -and -not $needsImmediateInput) {
                            $this.Buffer = $this.Buffer.Insert($this.CursorPos, ' ')
                            $this.CursorPos++
                            "INPUT: Added space - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                        } else {
                            if ($needsImmediateInput) {
                                "INPUT: Prefix needs immediate input, no space added - Buffer='$($this.Buffer)'" | Write-Debug
                            } else {
                                "INPUT: Buffer already ends with space, no space added - Buffer='$($this.Buffer)'" | Write-Debug
                            }
                        }
                        $this.RedrawLine()
                    } elseif ($this.InCompletion) {
                        "INPUT: Regular key while in completion - cancelling first" | Write-Debug
                        $this.CancelCompletion()
                        "INPUT: Completion cancelled, now processing key normally" | Write-Debug
                        # Then process the key normally
                        if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                            $this.Buffer = $this.Buffer.Insert($this.CursorPos, $key.KeyChar)
                            $this.CursorPos++
                            "INPUT: Added char - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                            $this.RedrawLine()
                        }
                    } else {
                        "INPUT: Normal key processing (not in completion)" | Write-Debug
                        if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                            $this.Buffer = $this.Buffer.Insert($this.CursorPos, $key.KeyChar)
                            $this.CursorPos++
                            "INPUT: Added char normally - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                            $this.RedrawLine()
                        }
                    }
                }
            }
        }
        # This line should never be reached, but satisfies PowerShell's static analysis
        return ""
    }
    
    [void] HandleTab() {
        "=== HANDLETAB START ===" | Write-Debug
        "HANDLETAB: InCompletion=$($this.InCompletion), Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
        "HANDLETAB: OriginalInput='$($this.OriginalInput)'" | Write-Debug
        
        if (-not $this.InCompletion) {
            $this.OriginalInput = $this.Buffer
            "HANDLETAB: Set OriginalInput to '$($this.OriginalInput)'" | Write-Debug
            "HANDLETAB: Getting completions for buffer '$($this.Buffer)'" | Write-Debug
            
            $smartCompletions = $this.Parser.GetSmartCompletions($this.Buffer, $this.CursorPos)
            "HANDLETAB: GetSmartCompletions returned $($smartCompletions.Count) items" | Write-Debug
            
            for ($i = 0; $i -lt $smartCompletions.Count; $i++) {
                $comp = $smartCompletions[$i]
                "HANDLETAB: Completion[$i]: Command='$($comp.Command)', Description='$($comp.Description)', Type='$($comp.Type)'" | Write-Debug
            }
            
            $this.Completions = @($smartCompletions | Select-Object -ExpandProperty Command)
            $this.CompletionDetails = $smartCompletions
            "HANDLETAB: Set Completions=$($this.Completions.Count), CompletionDetails=$($this.CompletionDetails.Count)" | Write-Debug
            "HANDLETAB: Completions array: $($this.Completions -join ', ')" | Write-Debug
            
            if ($this.Completions.Count -gt 0) {
                "HANDLETAB: Found completions, entering completion mode" | Write-Debug
                $this.InCompletion = $true
                $this.CompletionIndex = 0
                "HANDLETAB: About to call ApplyCompletion()" | Write-Debug
                $this.ApplyCompletion()
                "HANDLETAB: ApplyCompletion() returned" | Write-Debug
            } else {
                "HANDLETAB: No completions found" | Write-Debug
            }
        } else {
            # Cycle through
            "HANDLETAB: Cycling through completions, index was $($this.CompletionIndex)" | Write-Debug
            $oldIndex = $this.CompletionIndex
            $this.CompletionIndex = ($this.CompletionIndex + 1) % $this.Completions.Count
            "HANDLETAB: Changed index from $oldIndex to $($this.CompletionIndex)" | Write-Debug
            "HANDLETAB: About to call ApplyCompletion() for cycling" | Write-Debug
            $this.ApplyCompletion()
            "HANDLETAB: ApplyCompletion() for cycling returned" | Write-Debug
        }
        "HANDLETAB: COMPLETE - Buffer is now '$($this.Buffer)'" | Write-Debug
    }
    
    [void] ApplyCompletion() {
        "=== APPLYCOMPLETION START ===" | Write-Debug
        "APPLY: Buffer BEFORE='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
        "APPLY: OriginalInput='$($this.OriginalInput)'" | Write-Debug
        "APPLY: Completions.Count=$($this.Completions.Count), CompletionIndex=$($this.CompletionIndex)" | Write-Debug
        
        if ($this.Completions.Count -gt 0 -and $this.CompletionIndex -ge 0 -and $this.CompletionIndex -lt $this.Completions.Count) {
            $completion = $this.Completions[$this.CompletionIndex]
            "APPLY: Selected completion='$completion'" | Write-Debug
            
            # Use the robust parser's current state - BUT REANALYZE with original input
            "APPLY: About to get parser state for OriginalInput='$($this.OriginalInput)'" | Write-Debug
            # CRITICAL FIX: AnalyzeInput doesn't exist - we need to parse the original input to get the state
            $state = $this.Parser.ParseBufferToState($this.OriginalInput)
            $this.Parser.CurrentState = $state  # Update the parser's state
            "APPLY: Parser re-analyzed - Mode=$($state.Mode), CurrentToken='$($state.CurrentToken)', CurrentCommand='$($state.CurrentCommand)'" | Write-Debug
            "APPLY: State details - CompletedArguments.Count=$($state.CompletedArguments.Count), OriginalBuffer='$($state.OriginalBuffer)'" | Write-Debug
            
            # Log all completed arguments
            for ($i = 0; $i -lt $state.CompletedArguments.Count; $i++) {
                "APPLY: CompletedArguments[$i]='$($state.CompletedArguments[$i])'" | Write-Debug
            }
            
            # Apply completion based on robust state analysis
            "APPLY: About to call BuildNewBufferWithCompletion" | Write-Debug
            $newBuffer = $this.BuildNewBufferWithCompletion($completion, $state)
            "APPLY: BuildNewBufferWithCompletion returned '$newBuffer'" | Write-Debug
            
            if ($newBuffer -ne $null -and $newBuffer -ne $this.Buffer) {
                "APPLY: Changing buffer from '$($this.Buffer)' to '$newBuffer'" | Write-Debug
                $oldBuffer = $this.Buffer
                $this.Buffer = $newBuffer
                $this.CursorPos = $this.Buffer.Length
                "APPLY: Updated Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                $this.RedrawLine()
                "APPLY: RedrawLine() complete" | Write-Debug
            } else {
                "APPLY: Buffer unchanged (newBuffer='$newBuffer', current='$($this.Buffer)')" | Write-Debug
            }
            
            # Show completion indicators
            "APPLY: About to show completion indicators" | Write-Debug
            $this.ShowCompletionIndicators()
            "APPLY: ShowCompletionIndicators() complete" | Write-Debug
        } else {
            "APPLY: Cannot apply - invalid state (Count=$($this.Completions.Count), Index=$($this.CompletionIndex))" | Write-Debug
        }
        "APPLY: COMPLETE - Final buffer='$($this.Buffer)'" | Write-Debug
    }
    
    [void] ShowCompletionIndicators() {
        if ($this.Completions.Count -gt 0 -and $this.CompletionIndex -ge 0) {
            # Show count indicator
            $current = $this.CompletionIndex + 1
            $total = $this.Completions.Count
            Write-Host -NoNewline " [$current/$total]" -ForegroundColor DarkGray
            
            # Show description on second line if we have details
            if ($this.CompletionDetails.Count -gt 0 -and $this.CompletionIndex -lt $this.CompletionDetails.Count) {
                $detail = $this.CompletionDetails[$this.CompletionIndex]
                if ($detail -and $detail.Description) {
                    $cursorTop = [Console]::CursorTop
                    [Console]::SetCursorPosition(0, $cursorTop + 1)
                    Write-Host (" " * [Console]::WindowWidth) -NoNewline
                    [Console]::SetCursorPosition(0, $cursorTop + 1)
                    
                    Write-Host "  → $($detail.Description)" -ForegroundColor DarkCyan -NoNewline
                    
                    [Console]::SetCursorPosition(
                        (Get-Prompt).Length + $this.CursorPos,
                        $cursorTop
                    )
                }
            }
        }
    }
    
    [string] BuildNewBufferWithCompletion([string] $completion, [CompletionState] $state) {
        "=== BUILDNEWBUFFER START ===" | Write-Debug
        "BUILD: completion='$completion', state.Mode=$($state.Mode), state.OriginalBuffer='$($state.OriginalBuffer)'" | Write-Debug
        try {
            switch ($state.Mode) {
                ([CompletionMode]::Command) {
                    # First word completion - replace entire buffer
                    "BUILD COMMAND: Replacing entire buffer with '$completion'" | Write-Debug
                    return $completion
                }
                
                ([CompletionMode]::Subcommand) {
                    # Building multi-word command
                    "BUILD SUBCOMMAND: CompletedArguments=$($state.CompletedArguments.Count)" | Write-Debug
                    if ($state.CompletedArguments.Count -gt 0) {
                        $result = ($state.CompletedArguments -join ' ') + ' ' + $completion
                        "BUILD SUBCOMMAND: Result='$result'" | Write-Debug
                        return $result
                    }
                    "BUILD SUBCOMMAND: No completed args, returning '$completion'" | Write-Debug
                    return $completion
                }
                
                ([CompletionMode]::SyntaxDiscovery) {
                    # Adding syntax element to existing command
                    "BUILD SYNTAX: CompletedArguments=$($state.CompletedArguments.Count), CurrentCommand='$($state.CurrentCommand)'" | Write-Debug
                    
                    # CRITICAL FIX: Build command properly - CurrentCommand + arguments (not CompletedArguments which was wrong)
                    $commandPart = $state.CurrentCommand
                    "BUILD SYNTAX: Using CurrentCommand='$commandPart' as base" | Write-Debug
                    
                    if ($state.CompletedArguments.Count -gt 0) {
                        $argumentsPart = $state.CompletedArguments -join ' '
                        $baseCommand = "$commandPart $argumentsPart"
                        "BUILD SYNTAX: Combined base: '$commandPart' + '$argumentsPart' = '$baseCommand'" | Write-Debug
                    } else {
                        $baseCommand = $commandPart
                        "BUILD SYNTAX: No arguments, base is just command: '$baseCommand'" | Write-Debug
                    }
                    
                    # Check if this completion needs immediate input
                    if ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#') {
                        # Don't add space for prefixes that need immediate input
                        $result = "$baseCommand $completion"
                        "BUILD SYNTAX: Incomplete prefix, no trailing space: '$result'" | Write-Debug
                        return $result
                    } else {
                        # Add space for complete items (like p1, p2, p3)
                        $result = "$baseCommand $completion "
                        "BUILD SYNTAX: Complete item, with trailing space: '$result'" | Write-Debug
                        return $result
                    }
                }
                
                ([CompletionMode]::PrefixCompletion) {
                    # Replacing the partial prefix with complete one
                    $originalBuffer = $state.OriginalBuffer
                    $trimmedBuffer = $originalBuffer.TrimEnd()
                    $lastSpacePos = $trimmedBuffer.LastIndexOf(' ')
                    "BUILD PREFIX: originalBuffer='$originalBuffer', trimmedBuffer='$trimmedBuffer', lastSpacePos=$lastSpacePos, completion='$completion'" | Write-Debug
                    
                    if ($lastSpacePos -ge 0) {
                        # Replace the last token with the completion
                        $beforeLastToken = $trimmedBuffer.Substring(0, $lastSpacePos + 1)
                        
                        # Check if this completion needs immediate input (no trailing space)
                        if ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#') {
                            # Don't add space for prefixes that need immediate input
                            $result = $beforeLastToken + $completion
                            "BUILD PREFIX: Incomplete prefix, no trailing space: '$result'" | Write-Debug
                            return $result
                        } else {
                            # Add space for complete values (like due:today, @project)
                            $result = $beforeLastToken + $completion + ' '
                            "BUILD PREFIX: Complete value, with trailing space: '$result'" | Write-Debug
                            return $result
                        }
                    } else {
                        # Replace entire buffer - apply same logic
                        if ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#') {
                            "BUILD PREFIX: Replacing entire buffer (no space) -> '$completion'" | Write-Debug
                            return $completion
                        } else {
                            "BUILD PREFIX: Replacing entire buffer (with space) -> '$completion '" | Write-Debug
                            return $completion + ' '
                        }
                    }
                }
                
                default {
                    # Fallback - append to buffer
                    "BUILD DEFAULT: Fallback mode, OriginalBuffer='$($state.OriginalBuffer)'" | Write-Debug
                    
                    # Check if this completion needs immediate input (no trailing space)
                    $needsSpace = -not ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#')
                    
                    if ($state.OriginalBuffer.EndsWith(' ')) {
                        if ($needsSpace) {
                            $result = $state.OriginalBuffer + $completion + ' '
                            "BUILD DEFAULT: Buffer ends with space, adding completion with trailing space: '$result'" | Write-Debug
                        } else {
                            $result = $state.OriginalBuffer + $completion
                            "BUILD DEFAULT: Buffer ends with space, adding completion without trailing space: '$result'" | Write-Debug
                        }
                        return $result
                    } else {
                        if ($needsSpace) {
                            $result = $state.OriginalBuffer + ' ' + $completion + ' '
                            "BUILD DEFAULT: Buffer no space, adding completion with spaces: '$result'" | Write-Debug
                        } else {
                            $result = $state.OriginalBuffer + ' ' + $completion
                            "BUILD DEFAULT: Buffer no space, adding completion without trailing space: '$result'" | Write-Debug
                        }
                        return $result
                    }
                }
            }
        }
        catch {
            # Safe fallback - never crash
            "BUILD CATCH: Exception occurred, using fallback" | Write-Debug
            $fallback = $state.OriginalBuffer + ' ' + $completion
            "BUILD CATCH: Fallback result='$fallback'" | Write-Debug
            return $fallback
        }
        # This line should never be reached, but satisfies PowerShell's static analysis
        "BUILD: Reached unreachable code, returning '$completion'" | Write-Debug
        return $completion
    }
    
    [void] AcceptCompletion() {
        $this.InCompletion = $false
        $this.Completions = @()
        $this.CompletionDetails = @()
        $this.CompletionIndex = -1
        
        # Clear description line
        $cursorTop = [Console]::CursorTop
        [Console]::SetCursorPosition(0, $cursorTop + 1)
        Write-Host (" " * [Console]::WindowWidth) -NoNewline
        [Console]::SetCursorPosition(
            (Get-Prompt).Length + $this.CursorPos,
            $cursorTop
        )
    }
    
    [void] CancelCompletion() {
        "=== CANCELCOMPLETION START ===" | Write-Debug
        "CANCEL: Before - Buffer='$($this.Buffer)', OriginalInput='$($this.OriginalInput)'" | Write-Debug
        "CANCEL: InCompletion=$($this.InCompletion), CompletionIndex=$($this.CompletionIndex)" | Write-Debug
        
        $this.Buffer = $this.OriginalInput
        $this.CursorPos = $this.Buffer.Length
        $this.InCompletion = $false
        $this.Completions = @()
        $this.CompletionDetails = @()
        $this.CompletionIndex = -1
        
        "CANCEL: After reset - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
        "CANCEL: About to redraw line" | Write-Debug
        $this.RedrawLine()
        "CANCEL: COMPLETE" | Write-Debug
    }
    
    [void] RedrawLine() {
        # Clear line
        [Console]::SetCursorPosition(0, [Console]::CursorTop)
        Write-Host -NoNewline (" " * [Console]::WindowWidth)
        [Console]::SetCursorPosition(0, [Console]::CursorTop)
        
        # Redraw
        Write-Host -NoNewline (Get-Prompt)
        Write-Host -NoNewline $this.Buffer
        
        # Position cursor
        [Console]::SetCursorPosition(
            (Get-Prompt).Length + $this.CursorPos,
            [Console]::CursorTop
        )
    }
}

function Get-Prompt {
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        return "todo:$($global:CurrentContext)> "
    }
    return "todo> "
}

function Exit-SmartTUI {
    # Save session stats
    $duration = [Math]::Round(((Get-Date) - $global:SessionStats.SessionStart).TotalMinutes)
    
    Write-Host "`n  👋 SESSION SUMMARY" -ForegroundColor Cyan
    Write-Host "  ──────────────────" -ForegroundColor DarkCyan
    Write-Host "  Duration: ${duration}m" -ForegroundColor White
    Write-Host "  Tasks Added: $($global:SessionStats.TasksAdded)" -ForegroundColor Green
    Write-Host "  Tasks Completed: $($global:SessionStats.TasksCompleted)" -ForegroundColor Green
    Write-Host "  Commands Run: $($global:SessionStats.CommandsRun)" -ForegroundColor Gray
    Write-Host "`n  Goodbye! 🚀" -ForegroundColor Cyan
    Write-Host ""
    
    exit
}

# === MAIN ENTRY POINT ===
function Start-TodoistTUI {
    [ConfigManager]::Load()
    
    Clear-Host
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor Cyan
    Write-Host "  ║           TODOIST TUI PROFESSIONAL - v2.0                   ║" -ForegroundColor Cyan
    Write-Host "  ║                                                              ║" -ForegroundColor Cyan
    Write-Host "  ║  Tab: Complete  |  ↑↓: History  |  help: Commands           ║" -ForegroundColor DarkCyan
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor Cyan
    
    # Load context
    $data = Get-TaskData
    $global:CurrentContext = $data.currentContext
    
    # Show agenda
    Show-RichAgenda
    
    # Initialize
    $parser = [SmartCommandParser]::new()
    $inputHandler = [SmartInputHandler]::new($parser)
    
    # Main loop
    while ($true) {
        try {
            $command = $inputHandler.ReadCommand()
            
            if ($command -eq 'exit' -or $command -eq 'quit' -or $command -eq 'q') {
                Exit-SmartTUI
            }
            
            # NEW: Use structured parsing directly
            $parser.ExecuteStructured($command)
        }
        catch {
            Write-Host "Error: $_" -ForegroundColor Red
            Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
        }
    }
}

# === MISSING FUNCTION IMPLEMENTATIONS ===

function Show-FilteredTasks {
    param([hashtable]$params = @{})
    
    $data = Get-TaskData
    $tasks = @()
    
    # Apply filters
    if ($params.Filter) {
        switch ($params.Filter) {
            'today' {
                $today = (Get-Date).Date.ToString("yyyy-MM-dd")
                $tasks = $data.tasks | Where-Object { $_.due -eq $today -and -not $_.completed }
            }
            'tomorrow' {
                $tomorrow = (Get-Date).AddDays(1).Date.ToString("yyyy-MM-dd")
                $tasks = $data.tasks | Where-Object { $_.due -eq $tomorrow -and -not $_.completed }
            }
            'overdue' {
                $today = (Get-Date).Date
                $tasks = $data.tasks | Where-Object { 
                    $_.due -and -not $_.completed -and [DateTime]::Parse($_.due) -lt $today
                }
            }
            'upcoming' {
                $today = (Get-Date).Date
                $nextWeek = $today.AddDays(7)
                $tasks = $data.tasks | Where-Object { 
                    $_.due -and -not $_.completed -and 
                    [DateTime]::Parse($_.due) -gt $today -and [DateTime]::Parse($_.due) -le $nextWeek
                }
            }
            'noduedate' {
                $tasks = $data.tasks | Where-Object { -not $_.due -and -not $_.completed }
            }
        }
    }
    
    if ($params.Priority) {
        $priority = $params.Priority.ToString()
        $tasks = $data.tasks | Where-Object { $_.priority -eq $priority -and -not $_.completed }
    }
    
    if ($params.Search) {
        $search = $params.Search.ToLower()
        $tasks = $data.tasks | Where-Object { 
            $_.text.ToLower().Contains($search) -and -not $_.completed
        }
    }
    
    # Display results
    Clear-Host
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor DarkCyan
    
    $title = if ($params.Filter) { 
        "TASKS: $($params.Filter.ToUpper())" 
    } elseif ($params.Priority) { 
        "PRIORITY $($params.Priority) TASKS" 
    } elseif ($params.Search) { 
        "SEARCH: '$($params.Search)'" 
    } else { 
        "FILTERED TASKS" 
    }
    
    Write-Host "  ║$($title.PadLeft(32 + $title.Length/2).PadRight(60))║" -ForegroundColor DarkCyan
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor DarkCyan
    
    if ($tasks.Count -eq 0) {
        Write-Host "`n  📭 No tasks found matching criteria" -ForegroundColor Yellow
        return
    }
    
    Write-Host "`n  Found $($tasks.Count) task$(if($tasks.Count -ne 1){'s'}):`n" -ForegroundColor Green
    
    for ($i = 0; $i -lt $tasks.Count; $i++) {
        $task = $tasks[$i]
        $num = ($i + 1).ToString().PadLeft(2)
        $priority = if ($task.priority) { "$($task.priority) " } else { "" }
        $project = if ($task.project) { "@$($task.project) " } else { "" }
        $due = if ($task.due) { " (due: $($task.due))" } else { "" }
        
        $color = switch ($task.priority) {
            'p1' { 'Red' }
            'p2' { 'Yellow' }
            'p3' { 'Blue' }
            default { 'White' }
        }
        
        Write-Host "  $num. " -NoNewline -ForegroundColor Gray
        Write-Host "$priority$project" -NoNewline -ForegroundColor Cyan
        Write-Host "$($task.text)" -NoNewline -ForegroundColor $color
        Write-Host "$due" -ForegroundColor DarkGray
    }
    
    Write-Host ""
}

function Show-MonthView {
    Clear-Host
    $today = Get-Date
    $year = $today.Year
    $month = $today.Month
    
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor Magenta
    $header = (Get-Date -Month $month -Day 1 -Format 'MMMM yyyy').ToUpper()
    Write-Host "  ║$($header.PadLeft(32 + $header.Length/2).PadRight(60))║" -ForegroundColor Magenta
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor Magenta
    
    # Calendar header
    Write-Host "`n    Sun  Mon  Tue  Wed  Thu  Fri  Sat" -ForegroundColor Cyan
    Write-Host "    ─────────────────────────────────────" -ForegroundColor DarkCyan
    
    # Get first day of month and number of days
    $firstDay = Get-Date -Year $year -Month $month -Day 1
    $daysInMonth = [DateTime]::DaysInMonth($year, $month)
    $startDayOfWeek = [int]$firstDay.DayOfWeek
    
    # Get task data for highlighting days with tasks
    $data = Get-TaskData
    $taskDays = @{}
    foreach ($task in $data.tasks) {
        if ($task.due -and -not $task.completed) {
            try {
                $dueDate = [DateTime]::Parse($task.due)
                if ($dueDate.Year -eq $year -and $dueDate.Month -eq $month) {
                    $taskDays[$dueDate.Day] = $true
                }
            } catch {}
        }
    }
    
    Write-Host "   " -NoNewline
    
    # Add padding for first week
    for ($i = 0; $i -lt $startDayOfWeek; $i++) {
        Write-Host "     " -NoNewline
    }
    
    # Print calendar days
    for ($day = 1; $day -le $daysInMonth; $day++) {
        $dayOfWeek = ($startDayOfWeek + $day - 1) % 7
        
        # Highlight today
        if ($day -eq $today.Day -and $month -eq $today.Month -and $year -eq $today.Year) {
            Write-Host " [$($day.ToString().PadLeft(2))]" -NoNewline -ForegroundColor Yellow
        }
        # Highlight days with tasks
        elseif ($taskDays.ContainsKey($day)) {
            Write-Host "  $($day.ToString().PadLeft(2)) " -NoNewline -ForegroundColor Green
        }
        else {
            Write-Host "  $($day.ToString().PadLeft(2)) " -NoNewline -ForegroundColor White
        }
        
        # New line after Saturday
        if ($dayOfWeek -eq 6) {
            Write-Host ""
            if ($day -lt $daysInMonth) {
                Write-Host "   " -NoNewline
            }
        }
    }
    
    Write-Host "`n"
    Write-Host "  Legend: [Today] " -NoNewline -ForegroundColor Yellow
    Write-Host "Days with tasks " -ForegroundColor Green
    Write-Host ""
}

function Show-BlockedTasks {
    $data = Get-TaskData
    $blocked = $data.tasks | Where-Object { 
        $_.dependencies -and $_.dependencies.Count -gt 0 -and -not $_.completed
    }
    
    Clear-Host
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor Red
    Write-Host "  ║                      BLOCKED TASKS                         ║" -ForegroundColor Red
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor Red
    
    if ($blocked.Count -eq 0) {
        Write-Host "`n  🎉 No blocked tasks!" -ForegroundColor Green
        return
    }
    
    Write-Host "`n  Found $($blocked.Count) blocked task$(if($blocked.Count -ne 1){'s'}):`n" -ForegroundColor Yellow
    
    foreach ($task in $blocked) {
        Write-Host "  🚫 $($task.text)" -ForegroundColor Red
        Write-Host "     Waiting on: $($task.dependencies -join ', ')" -ForegroundColor DarkRed
        Write-Host ""
    }
}

function Add-Project {
    param($parsed)
    
    $data = Get-TaskData
    
    # Validate name
    if (-not $parsed.Name -or $parsed.Name.Length -eq 0) {
        Write-Host "Project name is required" -ForegroundColor Red
        return
    }
    
    # Check for duplicates
    if ($data.projects | Where-Object { $_.name -eq $parsed.Name }) {
        Write-Host "Project '$($parsed.Name)' already exists." -ForegroundColor Yellow
        return
    }
    
    # Generate smart aliases
    $aliases = Generate-ProjectAliases -name $parsed.Name -existingProjects $data.projects
    
    # Create project
    $newProject = [PSCustomObject]@{
        name = $parsed.Name
        description = if ($parsed.Fields.description) { $parsed.Fields.description } else { "Created $(Get-Date -Format 'yyyy-MM-dd')" }
        aliases = $aliases
        created = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    }
    
    # Add custom fields
    foreach ($key in $parsed.Fields.Keys) {
        if ($key -ne 'description') {
            Add-Member -InputObject $newProject -MemberType NoteProperty -Name $key -Value $parsed.Fields[$key]
        }
    }
    
    $data.projects += $newProject
    Save-TaskData $data
    
    Write-Host "Project '$($parsed.Name)' created." -ForegroundColor Green
    if ($aliases.Count -gt 0) {
        Write-Host "  Shortcuts: $($aliases -join ', ')" -ForegroundColor Gray
    }
}

function Show-ProjectStats {
    param($context)
    $projectName = $context.GetText()
    $data = Get-TaskData
    
    $projectTasks = $data.tasks | Where-Object { $_.project -eq $projectName }
    $completed = $projectTasks | Where-Object { $_.completed }
    $pending = $projectTasks | Where-Object { -not $_.completed }
    
    Clear-Host
    Write-Host "`n  ╔════════════════════════════════════════════════════════════╗" -ForegroundColor Blue
    Write-Host "  ║                   PROJECT: @$($projectName.ToUpper().PadRight(40))║" -ForegroundColor Blue
    Write-Host "  ╚════════════════════════════════════════════════════════════╝" -ForegroundColor Blue
    
    Write-Host "`n  📊 STATISTICS" -ForegroundColor Yellow
    Write-Host "  ─────────────" -ForegroundColor DarkYellow
    Write-Host "  Total tasks:     $($projectTasks.Count)" -ForegroundColor White
    Write-Host "  Completed:       $($completed.Count)" -ForegroundColor Green
    Write-Host "  Pending:         $($pending.Count)" -ForegroundColor Red
    
    if ($projectTasks.Count -gt 0) {
        $percent = [math]::Round(($completed.Count / $projectTasks.Count) * 100, 1)
        Write-Host "  Progress:        $percent%" -ForegroundColor Cyan
    }
    
    Write-Host ""
}

function Update-SmartTask {
    param($context)
    $updateText = $context.GetText()
    
    Write-Host "`n  ✏️ Task update: '$updateText'" -ForegroundColor Cyan
    Write-Host "  (Smart update parsing not fully implemented)" -ForegroundColor Yellow
}

function Add-TaskNote {
    param($context)
    $noteText = $context.GetText()
    
    Write-Host "`n  📝 Note added: '$noteText'" -ForegroundColor Cyan
    Write-Host "  (Note system not fully implemented)" -ForegroundColor Yellow
}

function Show-TimerStatus {
    Write-Host "`n  ⏱️  Timer Status" -ForegroundColor Yellow
    Write-Host "  (Timer system not implemented)" -ForegroundColor Gray
}

function Show-ProfessionalReport {
    param($context)
    Write-Host "`n  📈 Professional Report" -ForegroundColor Cyan
    Write-Host "  (Reporting system not implemented)" -ForegroundColor Gray
}

function Show-DetailedReport {
    param($context)
    Write-Host "`n  📊 Detailed Report" -ForegroundColor Cyan  
    Write-Host "  (Advanced reporting not implemented)" -ForegroundColor Gray
}

function Show-Templates {
    Write-Host "`n  📋 Task Templates" -ForegroundColor Green
    Write-Host "  (Template system not implemented)" -ForegroundColor Gray
}

function Add-RecurringTask {
    param($context)
    $recurText = $context.GetText()
    
    Write-Host "`n  🔄 Recurring task: '$recurText'" -ForegroundColor Magenta
    Write-Host "  (Recurring tasks not implemented)" -ForegroundColor Gray
}

function Show-RecurringTasks {
    Write-Host "`n  🔄 Recurring Tasks" -ForegroundColor Magenta
    Write-Host "  (Recurring system not implemented)" -ForegroundColor Gray
}

function Add-SmartDependency {
    param($context)
    $depText = $context.GetText()
    
    Write-Host "`n  🔗 Dependency: '$depText'" -ForegroundColor Blue
    Write-Host "  (Dependency system not implemented)" -ForegroundColor Gray
}

function Remove-SmartDependency {
    param($context)
    $depText = $context.GetText()
    
    Write-Host "`n  ❌ Remove dependency: '$depText'" -ForegroundColor Red
    Write-Host "  (Dependency system not implemented)" -ForegroundColor Gray
}

function Show-Dependencies {
    param($context)
    Write-Host "`n  🔗 Task Dependencies" -ForegroundColor Blue
    Write-Host "  (Dependency viewer not implemented)" -ForegroundColor Gray
}

function Show-DependencyGraph {
    Write-Host "`n  📊 Dependency Graph" -ForegroundColor Cyan
    Write-Host "  (Dependency visualization not implemented)" -ForegroundColor Gray
}

function Set-SmartFocus {
    param($context)
    $focusText = $context.GetText()
    
    Write-Host "`n  🎯 Focus set: '$focusText'" -ForegroundColor Yellow
    Write-Host "  (Focus system not implemented)" -ForegroundColor Gray
}

function Show-ContextInfo {
    Write-Host "`n  ℹ️  Current Context" -ForegroundColor Cyan
    Write-Host "  (Context system not implemented)" -ForegroundColor Gray
}

function Show-BurndownChart {
    Write-Host "`n  📉 Burndown Chart" -ForegroundColor Green
    Write-Host "  (Chart system not implemented)" -ForegroundColor Gray
}

function Show-VelocityChart {
    Write-Host "`n  📈 Velocity Chart" -ForegroundColor Blue
    Write-Host "  (Velocity tracking not implemented)" -ForegroundColor Gray
}

# === ENHANCED PROJECT MANAGEMENT ===

function Find-Project {
    param(
        [string]$query, 
        [switch]$Interactive = $true,
        [switch]$AllowCreate = $false
    )
    
    if ([string]::IsNullOrWhiteSpace($query)) { 
        return $null 
    }
    
    $data = Get-TaskData
    $query_lower = $query.ToLower().Trim()
    
    # Fast exact match
    $exact = $data.projects | Where-Object { $_.name.ToLower() -eq $query_lower }
    if ($exact) { 
        return $exact[0] 
    }
    
    # Check aliases
    $aliasMatch = $data.projects | Where-Object { 
        $_.aliases -and ($_.aliases | Where-Object { $_.ToLower() -eq $query_lower })
    }
    if ($aliasMatch) { 
        return $aliasMatch[0] 
    }
    
    # Single unambiguous matches
    $startsWith = $data.projects | Where-Object { $_.name.ToLower().StartsWith($query_lower) }
    if ($startsWith.Count -eq 1) { 
        return $startsWith[0] 
    }
    
    $contains = $data.projects | Where-Object { $_.name.ToLower() -match "\b$query_lower" }
    if ($contains.Count -eq 1) { 
        return $contains[0] 
    }
    
    # Initials match
    $initials = $data.projects | Where-Object {
        $words = $_.name -split '\s+'
        $init = ($words | ForEach-Object { $_[0] }) -join ''
        $init.ToLower() -eq $query_lower
    }
    if ($initials.Count -eq 1) { 
        return $initials[0] 
    }
    
    # Special shortcuts
    if ($query_lower -eq '-' -or $query_lower -eq 'last') {
        $lastProj = $data.projects | Where-Object { $_.name -eq $data.lastUsedProject }
        if ($lastProj) { 
            return $lastProj[0] 
        }
    }
    
    # Handle multiple matches
    $allMatches = @()
    $allMatches += $startsWith
    $allMatches += $contains
    $allMatches = $allMatches | Select-Object -Unique | Select-Object -First 8
    
    if ($allMatches.Count -gt 1 -and $Interactive) {
        Write-Host "Multiple projects match '$query':" -ForegroundColor Yellow
        
        for ($i = 0; $i -lt $allMatches.Count; $i++) {
            Write-Host "  $($i+1). $($allMatches[$i].name)" -ForegroundColor Gray
        }
        
        do {
            $choice = Read-Host "Select project [1-$($allMatches.Count), N]"
            
            if ($choice -eq '' -or $choice.ToLower() -eq 'n') { 
                return $null 
            }
            
            if ($choice -match '^\d+$') {
                $index = [int]$choice - 1
                if ($index -ge 0 -and $index -lt $allMatches.Count) {
                    return $allMatches[$index]
                }
            }
            
            Write-Host "Invalid selection. Try again." -ForegroundColor Red
        } while ($true)
    }
    
    # Offer to create if allowed
    if ($AllowCreate -and $Interactive) {
        $response = Read-Host "Project '$query' not found. Create it? (Y/n)"
        if ($response -eq '' -or $response.ToLower() -eq 'y') {
            $newProj = @{ 
                Name = $query
                Fields = @{ description = "Auto-created" }
            }
            Add-Project -parsed $newProj
            return $data.projects | Where-Object { $_.name -eq $query }
        }
    }
    
    return $null
}

function Generate-ProjectAliases {
    param([string]$name, [array]$existingProjects)
    
    $aliases = @()
    $words = $name -split '\s+'
    
    # Collect all existing aliases to avoid conflicts
    $existingAliases = $existingProjects | ForEach-Object { 
        @($_.name.ToLower()) + $_.aliases 
    } | Select-Object -Unique
    
    # Generate potential aliases
    $candidates = @()
    
    # First letter of each word (for multi-word projects)
    if ($words.Count -gt 1) {
        $candidates += ($words | ForEach-Object { $_[0] }) -join ''
    }
    
    # First word
    $firstWord = $words[0].ToLower()
    $candidates += $firstWord
    
    # Progressive abbreviations (a, ac, acm, acme)
    for ($i = 1; $i -le [Math]::Min($firstWord.Length, 4); $i++) {
        $candidates += $firstWord.Substring(0, $i)
    }
    
    # Filter out conflicts and the project name itself
    $candidates = $candidates | Where-Object { 
        $_ -notin $existingAliases -and $_ -ne $name.ToLower() 
    } | Select-Object -Unique
    
    return $candidates
}

function Set-ProjectFocus {
    param([string]$projectQuery)
    
    $project = Find-Project -query $projectQuery -Interactive
    if (-not $project) {
        return
    }
    
    Set-CurrentContext -projectName $project.name
    Show-ProjectDetail -projectQuery $project.name
    
    Write-Host "`nContext set: $($project.name)" -ForegroundColor Green
    Write-Host "New tasks and time logs will default to this project" -ForegroundColor Gray
}

function Clear-ProjectFocus {
    Set-CurrentContext -projectName 'inbox'
    Write-Host "Context cleared - returned to inbox" -ForegroundColor Green
}

function Show-Projects {
    $data = Get-TaskData
    
    Write-Host "`n=== ALL PROJECTS ===" -ForegroundColor Cyan
    
    $data.projects | Sort-Object name | ForEach-Object {
        $contextMarker = if ($_.name -eq $global:CurrentContext) { "* " } else { "  " }
        
        Write-Host "$contextMarker$($_.name)" -NoNewline -ForegroundColor White
        
        if ($_.aliases) {
            Write-Host (" [{0}]" -f ($_.aliases -join ', ')) -NoNewline -ForegroundColor DarkGray
        }
        
        Write-Host
        
        # Show custom fields
        $_.PSObject.Properties | Where-Object { 
            $_.Name -notin @('name', 'description', 'aliases') 
        } | ForEach-Object {
            Write-Host ("     {0}: {1}" -f $_.Name, $_.Value) -ForegroundColor Gray
        }
        
        if ($_.description) {
            Write-Host ("     {0}" -f $_.description) -ForegroundColor Gray
        }
        
        # Show statistics
        $taskCount = @($data.tasks | Where-Object { 
            $_.project -eq $_.name -and $_.status -eq 'pending' 
        }).Count
        
        $timeLogged = ($data.timelogs | Where-Object { 
            $_.project -eq $_.name 
        } | Measure-Object minutes -Sum).Sum
        
        if ($taskCount -gt 0) {
            Write-Host "     Tasks: $taskCount pending" -ForegroundColor DarkYellow
        }
        
        if ($timeLogged -gt 0) {
            $hours = [Math]::Round($timeLogged / 60, 1)
            Write-Host "     Time: $hours hours total" -ForegroundColor DarkGreen
        }
        
        Write-Host
    }
}

function Show-ProjectDetail {
    param([string]$projectQuery)
    
    $project = Find-Project -query $projectQuery -Interactive
    if (-not $project) {
        return
    }
    
    $global:LastShownTaskMap.Clear()
    $localIdCounter = 1
    $data = Get-TaskData
    
    Write-Host "`n=== PROJECT: $($project.name) ===" -ForegroundColor Cyan
    
    # Project metadata
    $project.PSObject.Properties | Where-Object { $_.Name -ne 'name' } | ForEach-Object {
        Write-Host ("  {0}: {1}" -f $_.Name, $_.Value) -ForegroundColor Gray
    }
    
    # Active tasks
    $tasks = $data.tasks | Where-Object { 
        $_.project -eq $project.name -and $_.status -eq 'pending' 
    }
    
    if ($tasks) {
        Write-Host "`n  ACTIVE TASKS:" -ForegroundColor Yellow
        
        foreach ($task in ($tasks | Sort-Object priority, created)) {
            $pri = @("", "!", "!!", "!!!")[$task.priority]
            $priColor = @("White", "Red", "Yellow", "Cyan")[$task.priority]
            
            Write-Host ("    [{0,2}] (#{1}) " -f $localIdCounter, $task.id) -NoNewline -ForegroundColor Gray
            Write-Host "$pri " -NoNewline -ForegroundColor $priColor
            Write-Host $task.text -NoNewline
            
            if ($task.due) {
                $dueDate = [datetime]$task.due
                $days = ($dueDate - (Get-Date).Date).Days
                $dueText = if ($days -lt 0) { "OVERDUE" }
                          elseif ($days -eq 0) { "TODAY" }
                          elseif ($days -eq 1) { "Tomorrow" }
                          else { $dueDate.ToString("MMM d") }
                
                $dueColor = if ($days -lt 0) { "Red" }
                           elseif ($days -le 1) { "Yellow" }
                           else { "Gray" }
                
                Write-Host " [$dueText]" -NoNewline -ForegroundColor $dueColor
            }
            
            if ($task.estimatedMinutes) {
                $est = if ($task.estimatedMinutes -lt 60) { 
                    "$($task.estimatedMinutes)m" 
                } else { 
                    "$([Math]::Round($task.estimatedMinutes/60,1))h" 
                }
                Write-Host " ~$est" -NoNewline -ForegroundColor DarkGray
            }
            
            Write-Host
            $global:LastShownTaskMap[$localIdCounter] = $task.id
            $localIdCounter++
        }
    }
    
    # Recent time logs
    $logs = $data.timelogs | Where-Object { 
        $_.project -eq $project.name 
    } | Sort-Object date, time | Select-Object -Last 5
    
    if ($logs) {
        Write-Host "`n  RECENT TIME:" -ForegroundColor Yellow
        foreach ($log in $logs) {
            $hours = [Math]::Round($log.minutes / 60, 1)
            Write-Host "    $($log.date) $($log.time): ${hours}h" -NoNewline -ForegroundColor Gray
            if ($log.notes) { 
                Write-Host " - $($log.notes)" -ForegroundColor DarkGray 
            } else { 
                Write-Host 
            }
        }
    }
    
    # Project statistics
    $totalTasks = @($tasks).Count
    $totalMinutes = ($data.timelogs | Where-Object { 
        $_.project -eq $project.name 
    } | Measure-Object minutes -Sum).Sum
    $totalHours = [Math]::Round($totalMinutes / 60, 1)
    
    $weekStart = (Get-Date).Date.AddDays(-[int](Get-Date).DayOfWeek)
    $weekMinutes = ($data.timelogs | Where-Object { 
        $_.project -eq $project.name -and [datetime]$_.date -ge $weekStart 
    } | Measure-Object minutes -Sum).Sum
    $weekHours = [Math]::Round($weekMinutes / 60, 1)
    
    Write-Host "`n  PROJECT SUMMARY:" -ForegroundColor Yellow
    Write-Host "    Active Tasks: $totalTasks" -ForegroundColor Gray
    Write-Host "    This Week: $weekHours hours" -ForegroundColor Gray
    Write-Host "    Total Time: $totalHours hours" -ForegroundColor Gray
}

# === TIME TRACKING ===

function Add-TimeLog {
    param($parsed)
    
    # Determine target project
    $projectQuery = $parsed.ProjectQuery
    if (-not $projectQuery -and $global:CurrentContext) {
        $projectQuery = $global:CurrentContext
    }
    
    $project = Find-Project -query $projectQuery -Interactive -AllowCreate
    if (-not $project) {
        Write-Host "Cannot determine project for time log." -ForegroundColor Red
        return
    }
    
    $data = Get-TaskData
    $minutes = Parse-DurationToMinutes $parsed.Duration
    
    if ($minutes -le 0) {
        Write-Host "Invalid duration: $($parsed.Duration)" -ForegroundColor Red
        Write-Host "Use format: 1.5h, 90m, 2h, 30m" -ForegroundColor Gray
        return
    }
    
    # Create time log entry
    $log = @{
        project = $project.name
        minutes = $minutes
        date = (Get-Date).ToString("yyyy-MM-dd")
        time = (Get-Date).ToString("HH:mm")
        notes = $parsed.Notes
    }
    
    $data.timelogs += $log
    $data.lastUsedProject = $project.name
    Save-TaskData $data
    
    # Display confirmation
    $hours = [Math]::Round($minutes / 60, 2)
    Write-Host "Logged $hours hours to '$($project.name)'" -ForegroundColor Green
    
    if ($parsed.Notes) {
        Write-Host "  Note: $($parsed.Notes)" -ForegroundColor Gray
    }
    
    # Show daily total for context
    $todayStr = (Get-Date).ToString("yyyy-MM-dd")
    $todayTotal = ($data.timelogs | Where-Object { 
        $_.date -eq $todayStr -and $_.project -eq $project.name 
    } | Measure-Object minutes -Sum).Sum
    
    if ($todayTotal -gt $minutes) {
        $totalHours = [Math]::Round($todayTotal / 60, 2)
        Write-Host "  Today's total for $($project.name): $totalHours hours" -ForegroundColor DarkGreen
    }
}

function Show-TimeReport {
    param($parsed)
    
    $data = Get-TaskData
    $dateRange = Parse-DateRange -range $parsed.DateRange
    
    # Get logs for date range
    $logs = $data.timelogs | Where-Object { 
        [datetime]$_.date -ge $dateRange.Start -and [datetime]$_.date -lt $dateRange.End 
    }
    
    # Filter by project if specified
    if ($parsed.ProjectFilter) {
        $project = Find-Project -query $parsed.ProjectFilter -Interactive
        if ($project) {
            $logs = $logs | Where-Object { $_.project -eq $project.name }
            $projDisplay = " for $($project.name)"
        } else {
            return
        }
    } else {
        $projDisplay = ""
    }
    
    if (-not $logs) {
        Write-Host "No time logged for $($dateRange.Display)$projDisplay" -ForegroundColor Gray
        return
    }
    
    Write-Host "`n=== TIME REPORT: $($dateRange.Display)$projDisplay ===" -ForegroundColor Cyan
    
    # Group by project and calculate totals
    $grouped = $logs | Group-Object project | Sort-Object Name
    $totalMinutes = 0
    
    foreach ($group in $grouped) {
        $projMinutes = ($group.Group | Measure-Object minutes -Sum).Sum
        $totalMinutes += $projMinutes
        $projHours = [Math]::Round($projMinutes / 60, 2)
        
        $contextMarker = if ($group.Name -eq $global:CurrentContext) { "* " } else { "  " }
        Write-Host ("$contextMarker{0,-25} {1,8} hours" -f $group.Name, $projHours)
        
        # Show daily breakdown for short periods
        if (($dateRange.End - $dateRange.Start).Days -le 7) {
            $daily = $group.Group | Group-Object date | Sort-Object Name
            
            foreach ($day in $daily) {
                $dayMinutes = ($day.Group | Measure-Object minutes -Sum).Sum
                $dayHours = [Math]::Round($dayMinutes / 60, 2)
                $dayDate = [datetime]$day.Name
                
                Write-Host ("    {0,-15} {1,6}h" -f $dayDate.ToString("ddd MM/dd"), $dayHours) -ForegroundColor Gray
                
                # Show individual entries for very detailed view
                if ($day.Group.Count -le 3) {
                    $day.Group | ForEach-Object {
                        if ($_.notes) {
                            $entryHours = [Math]::Round($_.minutes / 60, 2)
                            Write-Host ("      {0} {1}h - {2}" -f $_.time, $entryHours, $_.notes) -ForegroundColor DarkGray
                        }
                    }
                }
            }
        }
    }
    
    $totalHours = [Math]::Round($totalMinutes / 60, 2)
    Write-Host ("  {0}" -f ("-" * 40)) -ForegroundColor DarkGray
    Write-Host ("  {0,-25} {1,8} hours" -f "TOTAL", $totalHours) -ForegroundColor Yellow
}

# Auto-start
if ($MyInvocation.InvocationName -ne '.') {
    Start-TodoistTUI
} else {
    Write-Host "Enhanced Todoist TUI loaded. Run 'Start-TodoistTUI' to begin." -ForegroundColor Cyan
}
