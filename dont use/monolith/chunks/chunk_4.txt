# --- START OF REPLACEMENT BLOCK for modules\data-manager\data-manager.psm1 ---

# Data Manager Module
# Unified data persistence and CRUD operations with event integration.
# This file now contains the fully encapsulated DataManager class.
# CORRECTED (v2): Fixed $this scoping issue in event handlers.

# The factory function is now the only public function in the module.
function Initialize-DataManager {
    <#
    .SYNOPSIS
    Creates a new, fully initialized instance of the DataManager service.
    #>
    return [DataManager]::new()
}

# The DataManager class is the single, encapsulated source of truth for all
# application data. It handles loading from and saving to disk, provides
# strongly-typed CRUD methods, and integrates with the event system to
# notify other components of data changes. Direct access to its internal
# data store is prevented, enforcing predictable and safe data flow.
class DataManager {
    #region Private State
    hidden [hashtable] $_dataStore
    hidden [string] $_dataFilePath
    hidden [string] $_backupPath
    hidden [datetime] $_lastSaveTime
    hidden [bool] $_dataModified = $false
    #endregion

    #region Constructor and Initialization
    DataManager() {
        $this.{_dataStore} = @{
            Projects = [System.Collections.ArrayList]::new()
            Tasks = [System.Collections.ArrayList]::new()
            TimeEntries = @()
            ActiveTimers = @{}
            TodoTemplates = @{}
            Settings = @{
                DefaultView = "Dashboard"
                Theme = "Modern"
                AutoSave = $true
                BackupCount = 5
            }
            time_entries = @() # underscore format for action compatibility
            timers = @()       # for action compatibility
        }

        $this.{_dataFilePath} = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
        $this.{_backupPath} = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"

        Invoke-WithErrorHandling -Component "DataManager.Constructor" -Context "DataManager initialization" -ScriptBlock {
            $dataDirectory = Split-Path $this.{_dataFilePath} -Parent
            if (-not (Test-Path $dataDirectory)) {
                New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
                Write-Log -Level Info -Message "Created data directory: $dataDirectory"
            }
            
            if (-not (Test-Path $this.{_backupPath})) {
                New-Item -ItemType Directory -Path $this.{_backupPath} -Force | Out-Null
                Write-Log -Level Info -Message "Created backup directory: $($this.{_backupPath})"
            }
            
            $this.LoadData()
            $this.InitializeEventHandlers()
            
            Write-Log -Level Info -Message "DataManager initialized successfully"
        }
    }

    hidden [void] InitializeEventHandlers() {
        # Capture the current instance ($this) into a local variable so the
        # scriptblocks below can access it.
        $local:self = $this
        Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -Context "Initializing data event handlers" -ScriptBlock {
            # The handler scriptblock captures $local:self from its parent scope.
            Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
                param($EventData)
                Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Refreshed"; Tasks = @($local:self.{_dataStore}.Tasks) }
            }
            Write-Log -Level Debug -Message "Data event handlers initialized"
        }
    }
    #endregion

    #region Data Persistence
    hidden [void] LoadData() {
        Invoke-WithErrorHandling -Component "DataManager.LoadData" -Context "Loading unified data from disk" -ScriptBlock {
            if (Test-Path $this.{_dataFilePath}) {
                try {
                    $loadedData = Get-Content -Path $this.{_dataFilePath} -Raw | ConvertFrom-Json -AsHashtable
                    
                    if ($loadedData -is [hashtable]) {
                        if ($loadedData.Tasks) {
                            $this.{_dataStore}.Tasks.Clear()
                            foreach ($taskData in $loadedData.Tasks) {
                                if ($taskData -is [hashtable]) { 
                                    try {
                                        $task = [PmcTask]::FromLegacyFormat($taskData)
                                        $this.{_dataStore}.Tasks.Add($task) | Out-Null
                                    } catch {
                                        Write-Log -Level Warning -Message "Failed to load task: $_"
                                    }
                                }
                            }
                            Write-Log -Level Debug -Message "Loaded $($this.{_dataStore}.Tasks.Count) tasks as PmcTask objects"
                        }
                        
                        if ($loadedData.Projects -is [hashtable]) {
                            $this.{_dataStore}.Projects.Clear()
                            foreach ($projectKey in $loadedData.Projects.Keys) {
                                $projectData = $loadedData.Projects[$projectKey]
                                if ($projectData -is [hashtable]) { $this.{_dataStore}.Projects.Add([PmcProject]::FromLegacyFormat($projectData)) }
                            }
                            Write-Log -Level Debug -Message "Re-hydrated $($this.{_dataStore}.Projects.Count) projects as PmcProject objects"
                        }
                        
                        foreach ($key in 'TimeEntries', 'ActiveTimers', 'TodoTemplates', 'Settings', 'time_entries', 'timers') {
                            if ($loadedData.ContainsKey($key)) { $this.{_dataStore}[$key] = $loadedData[$key] }
                        }
                        
                        Write-Log -Level Info -Message "Data loaded successfully from disk"
                    } else {
                        Write-Log -Level Warning -Message "Invalid data format in file, using defaults"
                    }
                } catch {
                    Write-Log -Level Error -Message "Failed to parse data file: $_"
                }
            } else {
                Write-Log -Level Info -Message "No existing data file found, creating sample data"
                
                $defaultProject = [PmcProject]::new("GENERAL", "General Tasks")
                $this.{_dataStore}.Projects.Add($defaultProject)
                
                $sampleTasks = @(
                    [PmcTask]::new("Welcome to PMC Terminal!", "This is your task management system", [TaskPriority]::High, "GENERAL"),
                    [PmcTask]::new("Review the documentation", "Check out the help files to learn more", [TaskPriority]::Medium, "GENERAL"),
                    [PmcTask]::new("Create your first project", "Use the project management features", [TaskPriority]::Low, "GENERAL")
                )
                
                foreach ($task in $sampleTasks) { $this.{_dataStore}.Tasks.Add($task) }
                
                Write-Log -Level Info -Message "Created $($sampleTasks.Count) sample tasks"
                $this.SaveData()
            }
            
            $this.{_lastSaveTime} = Get-Date
        }
    }

    hidden [void] SaveData() {
        Invoke-WithErrorHandling -Component "DataManager.SaveData" -Context "Saving unified data to disk" -ScriptBlock {
            if (Test-Path $this.{_dataFilePath}) {
                $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
                Copy-Item -Path $this.{_dataFilePath} -Destination (Join-Path $this.{_backupPath} $backupName) -Force
                
                $backups = Get-ChildItem -Path $this.{_backupPath} -Filter "pmc-data_*.json" | Sort-Object LastWriteTime -Descending
                if ($backups.Count -gt $this.{_dataStore}.Settings.BackupCount) {
                    $backups | Select-Object -Skip $this.{_dataStore}.Settings.BackupCount | Remove-Item -Force
                }
            }
            
            $dataToSave = @{
                Tasks = @($this.{_dataStore}.Tasks | ForEach-Object { $_.ToLegacyFormat() })
                Projects = @{}
                TimeEntries = $this.{_dataStore}.TimeEntries
                ActiveTimers = $this.{_dataStore}.ActiveTimers
                TodoTemplates = $this.{_dataStore}.TodoTemplates
                Settings = $this.{_dataStore}.Settings
                time_entries = $this.{_dataStore}.time_entries
                timers = $this.{_dataStore}.timers
            }
            
            foreach ($project in $this.{_dataStore}.Projects) { $dataToSave.Projects[$project.Key] = $project.ToLegacyFormat() }
            
            $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $this.{_dataFilePath} -Encoding UTF8
            $this.{_lastSaveTime} = Get-Date; $this.{_dataModified} = $false
            Write-Log -Level Debug -Message "Data saved successfully"
        }
    }
    #endregion

    #region Task Management Methods
    [PmcTask] AddTask([string]$Title, [string]$Description, [string]$Priority, [string]$ProjectKey, [string]$DueDate = "") {
        return Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($Title)) { 
                throw "Task title cannot be empty"
            }
            $taskPriority = [TaskPriority]::$Priority
            $newTask = [PmcTask]::new($Title, $Description, $taskPriority, $ProjectKey)
            if ($DueDate -and $DueDate -ne "N/A") {
                try { $newTask.DueDate = [datetime]::Parse($DueDate) } catch { }
            }
            $this.{_dataStore}.Tasks.Add($newTask); $this.{_dataModified} = $true
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Created"; TaskId = $newTask.Id; Task = $newTask }
            return $newTask
        }
    }

    [PmcTask] UpdateTask([hashtable]$UpdateParameters) {
        return Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating task" -ScriptBlock {
            if (-not $UpdateParameters.ContainsKey('Task')) {
                throw "The 'UpdateParameters' hashtable must contain a 'Task' key with the task object to update."
            }
            $Task = $UpdateParameters.Task
            $managedTask = $this.{_dataStore}.Tasks.Find({$_.Id -eq $Task.Id})
            if (-not $managedTask) { throw "Task not found in data store" }
            
            $updatedFields = @()
            if ($UpdateParameters.ContainsKey('Title')) { $managedTask.Title = $UpdateParameters.Title.Trim(); $updatedFields += "Title" }
            if ($UpdateParameters.ContainsKey('Description')) { $managedTask.Description = $UpdateParameters.Description; $updatedFields += "Description" }
            if ($UpdateParameters.ContainsKey('Priority')) { $managedTask.Priority = [TaskPriority]::$($UpdateParameters.Priority); $updatedFields += "Priority" }
            if ($UpdateParameters.ContainsKey('Category')) { $managedTask.ProjectKey = $UpdateParameters.Category; $managedTask.Category = $UpdateParameters.Category; $updatedFields += "Category" }
            if ($UpdateParameters.ContainsKey('DueDate')) {
                try { $managedTask.DueDate = ($UpdateParameters.DueDate -and $UpdateParameters.DueDate -ne "N/A") ? [datetime]::Parse($UpdateParameters.DueDate) : $null } catch { Write-Log -Level Warning -Message "Invalid due date format: $($UpdateParameters.DueDate)" }
                $updatedFields += "DueDate"
            }
            if ($UpdateParameters.ContainsKey('Progress')) { $managedTask.UpdateProgress($UpdateParameters.Progress); $updatedFields += "Progress" }
            if ($UpdateParameters.ContainsKey('Completed')) {
                if ($UpdateParameters.Completed) { $managedTask.Complete() } else { $managedTask.Status = [TaskStatus]::Pending; $managedTask.Completed = $false; $managedTask.Progress = 0 }
                $updatedFields += "Completed"
            }
            
            $managedTask.UpdatedAt = [datetime]::Now; $this.{_dataModified} = $true
            Write-Log -Level Info -Message "Updated task $($managedTask.Id) - Fields: $($updatedFields -join ', ')"
            
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Updated"; TaskId = $managedTask.Id; Task = $managedTask; UpdatedFields = $updatedFields }
            return $managedTask
        }
    }

    [bool] RemoveTask([PmcTask]$Task) {
        return Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task" -ScriptBlock {
            $taskToRemove = $this.{_dataStore}.Tasks.Find({param($t) $t.Id -eq $Task.Id})
            if ($taskToRemove) {
                [void]$this.{_dataStore}.Tasks.Remove($taskToRemove)
                $this.{_dataModified} = $true
                Write-Log -Level Info -Message "Deleted task $($Task.Id)"
                if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
                Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Deleted"; TaskId = $Task.Id; Task = $Task }
                return $true
            }
            Write-Log -Level Warning -Message "Task not found with ID $($Task.Id)"; return $false
        }
    }

    [PmcTask[]] GetTasks([bool]$Completed, [string]$Priority, [string]$Category) {
        return Invoke-WithErrorHandling -Component "DataManager.GetTasks" -Context "Retrieving tasks" -ScriptBlock {
            $tasks = $this.{_dataStore}.Tasks
            if ($PSBoundParameters.ContainsKey('Completed')) { $tasks = $tasks | Where-Object { $_.Completed -eq $Completed } }
            if ($Priority) { $priorityEnum = [TaskPriority]::$Priority; $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum } }
            if ($Category) { $tasks = $tasks | Where-Object { $_.ProjectKey -eq $Category -or $_.Category -eq $Category } }
            return @($tasks)
        }
    }
    #endregion

    #region Project Management Methods
    [PmcProject[]] GetProjects() { return @($this.{_dataStore}.Projects) }
    [PmcProject] GetProject([string]$Key) { return $this.{_dataStore}.Projects.Find({$_.Key -eq $Key}) }

    [PmcProject] AddProject([PmcProject]$Project) {
        return Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding project" -ScriptBlock {
            if ($this.{_dataStore}.Projects.Exists({$_.Key -eq $Project.Key})) { 
                throw "Project with key '$($Project.Key)' already exists"
            }
            $this.{_dataStore}.Projects.Add($Project); $this.{_dataModified} = $true
            Write-Log -Level Info -Message "Created project '$($Project.Name)' with key $($Project.Key)"
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Created"; ProjectKey = $Project.Key; Project = $Project }
            return $Project
        }
    }
    #endregion
}

# --- END OF REPLACEMENT BLOCK ---


# --- START OF ORIGINAL FILE: services\keybinding-service\keybinding-service.psm1 ---
# keybinding-service.psm1
# Contains only the factory function for creating KeybindingService instances.



function New-KeybindingService {
    <#
    .SYNOPSIS
    Creates a new instance of the KeybindingService class.
    #>
    [CmdletBinding()]
    param(
        [switch]$EnableChords
    )
    
    if ($EnableChords) {
        return [KeybindingService]::new($true)
    }
    else {
        return [KeybindingService]::new()
    }
}
# --- END OF ORIGINAL FILE: services\keybinding-service\keybinding-service.psm1 ---


# --- START OF ORIGINAL FILE: services\navigation-service\navigation-service.psm1 ---
# navigation-service-functions.psm1
# Contains only the factory function for the NavigationService.



function Initialize-NavigationService {
    param([hashtable]$Services)
    if (-not $Services) { throw [System.ArgumentNullException]::new("Services") }
    return [NavigationService]::new($Services)
}
# --- END OF ORIGINAL FILE: services\navigation-service\navigation-service.psm1 ---


# --- START OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---
# TUI Engine v5.2 - Pure Compositor Edition
# Implements a pure NCurses-style compositor loop. The engine's core responsibilities
# are: running the main application loop, processing the input queue, and orchestrating
# the compositor pipeline (Screen -> Overlays -> Console). All rendering is handled
# via TuiBuffer objects, ensuring a flicker-free, layered UI.

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    CompositorBuffer = $null    # The master compositor buffer (TuiBuffer) that gets drawn to the console.
    PreviousCompositorBuffer = $null # A copy of the last frame's compositor buffer, used for optimized diff-rendering.
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    OverlayStack    = [System.Collections.Generic.List[UIElement]]::new() # A list to hold modal elements like dialogs.
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.2 (Pure Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        $global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new($Width, $Height, "PreviousCompositor")
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        Subscribe-Event -EventName "TUI.RefreshRequested" -Handler {
            Request-TuiRefresh
        } -Source "TuiEngine"

        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }
        Write-Log -Level Info -Message "TUI Engine v5.2 initialized successfully"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    
    # 1. Give the topmost overlay (e.g., a dialog) exclusive input priority.
    if ($global:TuiState.OverlayStack.Count -gt 0) {
        $topOverlay = $global:TuiState.OverlayStack[-1]
        if ($topOverlay.HandleInput($keyInfo)) {
            return # Overlay handled the input, stop processing.
        }
    }

    # 2. If no overlay handled it, check for global tab navigation.
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    # 3. Give the currently focused component a chance to handle the input.
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent -and $focusedComponent.HandleInput($keyInfo)) {
        return
    }
    
    # 4. Finally, let the current screen handle the input.
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            $currentScreen.HandleInput($keyInfo)
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([UIElement]$InitialScreen)
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        Render-FrameCompositor
        
        # After rendering, copy the current compositor state to the previous state buffer for the next frame's diff.
        $global:TuiState.PreviousCompositorBuffer.Clear()
        $global:TuiState.PreviousCompositorBuffer.BlendBuffer($global:TuiState.CompositorBuffer, 0, 0)
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
                $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                if ($null -ne $screenBuffer) {
                    $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                }
            }
        }
        
        # 3. Render overlays (e.g., dialogs) on top of the screen
        foreach ($overlay in $global:TuiState.OverlayStack) {
            Invoke-WithErrorHandling -Component ($overlay.Name ?? "Overlay") -Context "Overlay Render" -ScriptBlock {
                $overlay.Render()
                $overlayBuffer = $overlay.GetBuffer()
                if ($null -ne $overlayBuffer) {
                    $pos = $overlay.GetAbsolutePosition()
                    $global:TuiState.CompositorBuffer.BlendBuffer($overlayBuffer, $pos.X, $pos.Y)
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
    }
}

function Render-CompositorToConsole {
    $outputBuilder = [System.Text.StringBuilder]::new(20000)
    $currentBuffer = $global:TuiState.CompositorBuffer
    $previousBuffer = $global:TuiState.PreviousCompositorBuffer
    $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1

    try {
        for ($y = 0; $y -lt $currentBuffer.Height; $y++) {
            $rowChanged = $false
            for ($x = 0; $x -lt $currentBuffer.Width; $x++) {
                $newCell = $currentBuffer.GetCell($x, $y)
                $oldCell = $previousBuffer.GetCell($x, $y)
                
                if ($forceFullRender -or $newCell.DiffersFrom($oldCell)) {
                    if (-not $rowChanged) {
                        [void]$outputBuilder.Append("`e[$($y + 1);1H")
                        if ($x > 0) { [void]$outputBuilder.Append("`e[$($y + 1);$($x + 1)H") }
                        $rowChanged = $true
                    }

                    if ($newCell.ForegroundColor -ne $lastFG -or $newCell.BackgroundColor -ne $lastBG) {
                        $fgCode = Get-AnsiColorCode $newCell.ForegroundColor
                        $bgCode = Get-AnsiColorCode $newCell.BackgroundColor -IsBackground $true
                        [void]$outputBuilder.Append("`e[${fgCode};${bgCode}m")
                        $lastFG = $newCell.ForegroundColor
                        $lastBG = $newCell.BackgroundColor
                    }
                    [void]$outputBuilder.Append($newCell.Char)
                } elseif ($rowChanged) {
                    [void]$outputBuilder.Append("`e[$($y + 1);$($x + 2)H")
                }
            }
        }
        
        if ($lastFG -ne -1) { [void]$outputBuilder.Append("`e[0m") }
        
        if ($outputBuilder.Length -gt 10) {
            [Console]::Write($outputBuilder.ToString())
        }
    } catch {
        Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen & Overlay Management
function Push-Screen {
    param([UIElement]$Screen)
    if (-not $Screen) { return }
    
    Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur()
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.OnExit()
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) { # Default size
            $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
        }
        $Screen.RequestRedraw()
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $Screen.Name }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$($Screen.Name)': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit()
        $global:TuiState.CurrentScreen?.OnResume()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}

function Show-TuiOverlay {
    param([UIElement]$Element)
    $global:TuiState.OverlayStack.Add($Element)
    Request-TuiRefresh
}

function Close-TopTuiOverlay {
    if ($global:TuiState.OverlayStack.Count > 0) {
        $global:TuiState.OverlayStack.RemoveAt($global:TuiState.OverlayStack.Count - 1)
        Request-TuiRefresh
    }
}
#endregion

#region Component System
function Set-ComponentFocus { 
    param([UIElement]$Component)
    if ($Component -and (-not $Component.Enabled)) { return }
    
    $global:TuiState.FocusedComponent?.OnBlur()
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    $Component?.OnFocus()
    
    Request-TuiRefresh 
}

function Get-NextFocusableComponent { 
    param([UIElement]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = [System.Collections.Generic.List[UIElement]]::new()
    
    function Find-Focusable([UIElement]$Comp) {
        if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
            $focusableComponents.Add($Comp)
        }
        foreach ($child in $Comp.Children) { Find-Focusable $child }
    }
    
    Find-Focusable $global:TuiState.CurrentScreen
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    $sorted = $focusableComponents | Sort-Object { $_.TabIndex * 10000 + $_.Y * 100 + $_.X }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Move-Focus { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Stop-AllTuiAsyncJobs { Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)" }
#endregion

#region Utilities
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }
#endregion
# --- END OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---


# --- START OF ORIGINAL FILE: modules\tui-framework\tui-framework.psm1 ---
# TUI Framework Integration Module
# Contains utility functions for interacting with the TUI engine and components.
# AI: FIX - Added all missing dependencies.




$script:TuiAsyncJobs = @()

function Invoke-TuiMethod {
    <# .SYNOPSIS Safely invokes a method on a TUI component. #>
    param(
        [Parameter(Mandatory)] [hashtable]$Component,
        [Parameter(Mandatory)] [string]$MethodName,
        [Parameter()] [hashtable]$Arguments = @{}
    )
    if (-not $Component) { return }
    $method = $Component[$MethodName]
    if (-not ($method -is [scriptblock])) { return }

    $Arguments['self'] = $Component
    Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock { & $method @Arguments }
}

function Initialize-TuiFramework {
    Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {
        if (-not $global:TuiState) { throw "TUI Engine must be initialized before the TUI Framework." }
        Write-Log -Level Info -Message "TUI Framework initialized."
    }
}

function Invoke-TuiAsync {
    <# .SYNOPSIS Executes a script block asynchronously with job management. #>
    param(
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [string]$JobName = "TuiAsyncJob_$(Get-Random)",
        [hashtable]$ArgumentList = @{}
    )
    Invoke-WithErrorHandling -Component "TuiFramework.Async" -Context "Starting async job: $JobName" -ScriptBlock {
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList -Name $JobName
        $script:TuiAsyncJobs += $job
        Write-Log -Level Debug -Message "Started async job: $JobName" -Data @{ JobId = $job.Id }
        return $job
    }
}

function Get-TuiAsyncResults {
    <# .SYNOPSIS Checks for completed async jobs and returns their results. #>
    param([switch]$RemoveCompleted = $true)
    Invoke-WithErrorHandling -Component "TuiFramework.AsyncResults" -Context "Checking async job results" -ScriptBlock {
        $results = @()
        $completedJobs = $script:TuiAsyncJobs | Where-Object { $_.State -in @('Completed', 'Failed', 'Stopped') }
        
        foreach ($job in $completedJobs) {
            $results += @{
                JobId = $job.Id; JobName = $job.Name; State = $job.State
                Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job } else { $null }
                Error = if ($job.State -eq 'Failed') { $job.ChildJobs[0].JobStateInfo.Reason } else { $null }
            }
            Write-Log -Level Debug -Message "Async job completed: $($job.Name)" -Data @{ JobId = $job.Id; State = $job.State }
        }
        
        if ($RemoveCompleted -and $completedJobs.Count -gt 0) {
            foreach ($job in $completedJobs) {
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                $script:TuiAsyncJobs = $script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id }
            }
        }
        return $results
    }
}

function Stop-AllTuiAsyncJobs {
    Invoke-WithErrorHandling -Component "TuiFramework.StopAsync" -Context "Stopping all async jobs" -ScriptBlock {
        foreach ($job in $script:TuiAsyncJobs) {
            try {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                Write-Log -Level Debug -Message "Stopped async job: $($job.Name)"
            } catch {
                Write-Log -Level Warning -Message "Failed to stop job $($job.Name): $_"
            }
        }
        $script:TuiAsyncJobs = @()
        Write-Log -Level Info -Message "All TUI async jobs stopped."
    }
}



function Get-TuiState { return $global:TuiState }

function Test-TuiState {
    param([switch]$ThrowOnError)
    $isValid = $global:TuiState -and $global:TuiState.Running -and $global:TuiState.CurrentScreen
    if (-not $isValid -and $ThrowOnError) { throw "TUI state is not properly initialized. Call Initialize-TuiEngine first." }
    return $isValid
}

try {
    Write-Host "`n=== PMC Terminal v5 - Starting (Classy Loader) ===" -ForegroundColor Cyan
    Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)" -ForegroundColor DarkGray
    
    # Initialize core services that have no dependencies
    Write-Host "`nInitializing services..." -ForegroundColor Yellow
    Initialize-Logger -Level $(if ($Debug) { "Debug" } else { "Info" })
    Initialize-EventSystem
    Initialize-ThemeManager
    
    # Create the service container
    $services = @{}
    
    # Initialize services that depend on others, passing the container
    $services.KeybindingService = New-KeybindingService
    $services.DataManager = Initialize-DataManager
    
    # Create sample tasks for testing
    Write-Host "Creating sample tasks..." -ForegroundColor Yellow
    try {
        $sampleTasks = @(
            @{Title = "Review project documentation"; Description = "Review and update project documentation"; Priority = "High"; Project = "ProjectA"},
            @{Title = "Fix critical bug in login system"; Description = "Address authentication issues"; Priority = "Medium"; Project = "ProjectB"},
            @{Title = "Implement new feature"; Description = "Add user profile management"; Priority = "Medium"; Project = "ProjectA"},
            @{Title = "Update dependencies"; Description = "Update all NPM packages"; Priority = "Low"; Project = "ProjectC"},
            @{Title = "Write unit tests"; Description = "Increase test coverage"; Priority = "Medium"; Project = "ProjectB"}
        )
        
        foreach ($taskData in $sampleTasks) {
            # CORRECTED: Call the method with all 5 parameters positionally,
            # providing an empty string for the optional 'DueDate'.
            $services.DataManager.AddTask($taskData.Title, $taskData.Description, $taskData.Priority, $taskData.Project, "")
        }
        Write-Host "Sample tasks created successfully!" -ForegroundColor Green
    } catch {
        Write-Host "Warning: Could not create sample tasks: $_" -ForegroundColor Yellow
    }
    
    # NavigationService needs the $services container to pass to screens
    $services.Navigation = Initialize-NavigationService -Services $services
    
    # Register screen classes with the navigation service
    $services.Navigation.RegisterScreenClass("DashboardScreen", [DashboardScreen])
    $services.Navigation.RegisterScreenClass("TaskListScreen", [TaskListScreen])
    
    # Initialize the dialog system
    Initialize-DialogSystem
    
    Write-Host "All services initialized!" -ForegroundColor Green
    
    if (-not $SkipLogo) {
        Write-Host @"
    
    ╔═══════════════════════════════════════╗
    ║      PMC Terminal v5.0                ║
    ║      PowerShell Management Console    ║
    ╚═══════════════════════════════════════╝
    
"@ -ForegroundColor Cyan
    }
    
    # Initialize the TUI Engine which orchestrates the UI
    Write-Host "Starting TUI Engine..." -ForegroundColor Yellow
    Initialize-TuiEngine
    Write-Host "TUI Engine initialized successfully" -ForegroundColor Green
    
    # Create and initialize the first screen
    Write-Host "Creating DashboardScreen..." -ForegroundColor Yellow
    $dashboard = [DashboardScreen]::new($services)
    Write-Host "DashboardScreen created, initializing..." -ForegroundColor Yellow
    $dashboard.Initialize()
    Write-Host "DashboardScreen initialized successfully" -ForegroundColor Green
    
    # Push the screen to the engine and start the main loop
    Write-Host "Pushing screen to TUI engine..." -ForegroundColor Yellow
    Push-Screen -Screen $dashboard
    Write-Host "Screen pushed, starting main loop..." -ForegroundColor Yellow
    
    # Force an initial refresh to ensure rendering
    $global:TuiState.IsDirty = $true
    
    Start-TuiLoop
    
} catch {
    Write-Host "`n=== FATAL ERROR ===" -ForegroundColor Red
    Write-Host "An error occurred during application startup."
    Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack Trace:" -ForegroundColor DarkRed
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
    
    Write-Host "`nPress any key to exit..." -ForegroundColor Yellow
    if ($Host.UI.RawUI) {
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    }
    exit 1
} finally {
    # Cleanup logic if needed
    Pop-Location -ErrorAction SilentlyContinue
   
}
# --- END OF MAIN EXECUTION LOGIC ---
