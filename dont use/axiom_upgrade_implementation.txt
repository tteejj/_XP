Excellent. A full mandate. We burn the ships. There is no going back.

This plan is the blueprint for that evolution. We will proceed with surgical precision, replacing foundational components with their more powerful, modern successors. The objective is not just to add features, but to build a more resilient, performant, and maintainable architecture for the future.

This document outlines the first, foundational pillar of the upgrade: **The Phoenix Rendering & Theming Engine**. Every subsequent pillar builds upon the successful completion of this one.

### **Upgrade Plan: Axiom-Phoenix**

**Mandate:** Full architectural replacement. Backwards compatibility is not a design goal. All legacy functional code will be replaced with modern, class-based, component-oriented equivalents.

**Target:** This plan is a set of precise instructions for a Large Language Model to execute against the provided `axiom.txt` monolithic script. Each step is atomic and must be completed in order.

---

### **Pillar 1: The Phoenix Rendering & Theming Engine**

**Objective:** To completely replace the core rendering pipeline. We will excise the `[ConsoleColor]`-based system and replace it with a Truecolor (24-bit hex) capable engine. We will replace the hardcoded `ThemeManager` with a flexible, file-based `ThemeEngine`. The result will be a visually rich, fully customizable, and significantly more performant user interface foundation.

#### **Prerequisite: Correcting a Parse-Time Dependency**

The original code defines `TuiAnsiHelper` *after* `TuiCell`, which uses it. This creates a parse-time error in PowerShell, as the type `[TuiAnsiHelper]` is not yet known when `TuiCell` is being defined. Our plan corrects this by replacing `TuiAnsiHelper` first, ensuring the dependency is available when we redefine `TuiCell`.

---

#### **Step 1.1: Replace `TuiAnsiHelper` with a Truecolor-Aware ANSI Generator**

**File:** `axiom.txt`
**Location:** The `TuiAnsiHelper` class definition within the `--- START OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---` section.
**Action:** The existing `TuiAnsiHelper` is obsolete. It only understands the 16-color `[ConsoleColor]` palette. We will replace it entirely.

**Instruction:** **DELETE** the entire `class TuiAnsiHelper { ... }` block and **REPLACE** it with the following complete definition.

```powershell
# In components\tui-primitives\tui-primitives.psm1

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    # Helper to convert a Hex string like "#FF8700" to an RGB hashtable
    static [hashtable] HexToRgb([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor) -or -not $hexColor.StartsWith("#") -or $hexColor.Length -ne 7) {
            return $null # Return null for invalid format or transparency
        }
        try {
            # Use Convert with base 16 to parse hex components. This is fast and robust.
            return @{
                R = [System.Convert]::ToInt32($hexColor.Substring(1, 2), 16)
                G = [System.Convert]::ToInt32($hexColor.Substring(3, 2), 16)
                B = [System.Convert]::ToInt32($hexColor.Substring(5, 2), 16)
            }
        } catch {
            Write-Log -Level Warning -Message "Failed to parse hex color: $hexColor. Returning null."
            return $null # Return null if parsing fails
        }
    }

    # The new core method to generate a full ANSI sequence for Truecolor and styling.
    static [string] GetAnsiSequence([string]$fgHex, [string]$bgHex, [hashtable]$attributes) {
        $sequences = [System.Collections.Generic.List[string]]::new()

        # Foreground color (Truecolor - SGR 38;2)
        if ($fgHex) {
            $rgb = [TuiAnsiHelper]::HexToRgb($fgHex)
            if ($rgb) {
                $sequences.Add("38;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Background color (Truecolor - SGR 48;2)
        if ($bgHex) {
            $rgb = [TuiAnsiHelper]::HexToRgb($bgHex)
            if ($rgb) {
                $sequences.Add("48;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Style attributes
        if ($attributes) {
            if ($attributes.Bold) { $sequences.Add("1") }
            if ($attributes.Italic) { $sequences.Add("3") }
            if ($attributes.Underline) { $sequences.Add("4") }
            if ($attributes.Strikethrough) { $sequences.Add("9") }
        }

        # If no styles, return empty string. Otherwise, build the full escape sequence.
        if ($sequences.Count -eq 0) { return "" }
        return "`e[$($sequences -join ';')m"
    }

    # A single, universal reset sequence (SGR 0)
    static [string] Reset() {
        return "`e[0m"
    }
}
#endregion
```

**Rationale:** This new class is the cornerstone of Truecolor support. The `HexToRgb` static method provides a single, safe point of conversion. The `GetAnsiSequence` method correctly constructs the `SGR 38;2` and `48;2` escape codes required by modern terminals for 24-bit color. It is stateless and highly performant.

---

#### **Step 1.2: Evolve `TuiCell` for Truecolor and Rich Styling**

**File:** `axiom.txt`
**Location:** The `TuiCell` class definition, which directly follows the `TuiAnsiHelper` we just replaced.
**Action:** The current `TuiCell` is insufficient. We will replace it with an evolved version that stores colors as strings and has discrete properties for all text styles.

**Instruction:** **DELETE** the entire existing `class TuiCell { ... }` block and **REPLACE** it with the following definition.

```powershell
# In components\tui-primitives\tui-primitives.psm1

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    
    # HARDENING: ValidatePattern ensures that any attempt to assign an invalid hex string
    # fails immediately at the point of assignment, rather than causing a cryptic error
    # deep within the rendering loop. This is the 'fail fast' principle.
    [ValidatePattern('^#[0-9A-Fa-f]{6}$')]
    [string] $ForegroundColor = "#C0C0C0" # Default: light gray
    
    [ValidatePattern('^#[0-9A-Fa-f]{6}$')]
    [string] $BackgroundColor = $null      # Default: null for transparency (compositing)
    
    # ADDED: Explicit boolean style attributes for clarity and performance.
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [bool] $Strikethrough = $false

    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() { }

    # Character constructor - updated for string colors
    TuiCell([char]$char) {
        $this.Char = $char
    }

    # Full constructor - accepts string colors and all style attributes. Replaces multiple obsolete constructors.
    TuiCell([char]$char, [string]$fg, [string]$bg, [bool]$bold=$false, [bool]$italic=$false, [bool]$underline=$false, [bool]$strikethrough=$false) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Italic = $italic
        $this.Underline = $underline
        $this.Strikethrough = $strikethrough
    }
    
    # Copy constructor - updated to copy all new properties.
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.Strikethrough = $other.Strikethrough
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # WithStyle and WithChar methods are no longer primary but can be kept for utility.

    # Check if this cell differs from another - UPDATED for new properties. This is critical for render optimization.
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic -or
                $this.Strikethrough -ne $other.Strikethrough)
    }

    # ToAnsiString() will now be a simple wrapper. The core logic is in the renderer.
    [string] ToAnsiString() {
        $attributes = @{ Bold = $this.Bold; Italic = $this.Italic; Underline = $this.Underline; Strikethrough = $this.Strikethrough }
        $sequence = [TuiAnsiHelper]::GetAnsiSequence($this.ForegroundColor, $this.BackgroundColor, $attributes)
        return "$sequence$($this.Char)$([TuiAnsiHelper]::Reset())"
    }
}
#endregion
```

**Rationale:** The `TuiCell` is the atomic unit of our display. Switching `ForegroundColor` and `BackgroundColor` to `[string]` is the breaking change that enables Truecolor. Adding `[ValidatePattern()]` is a crucial hardening step. The `DiffersFrom()` method is expanded to include all style attributes, which is essential for the optimized rendering logic we will implement later. Obsolete constructors have been removed to simplify the class API.

---

#### **Step 1.3: Replace `ThemeManager` with `ThemeEngine`**

**File:** `axiom.txt`
**Location:** The entire `--- START OF ORIGINAL FILE: modules\theme-manager\theme-manager.psm1 ---` section.
**Action:** The existing `ThemeManager` is a hardcoded, inflexible system. It must be completely removed and replaced with a dynamic, file-based engine that loads themes from external JSON files.

**Instruction:** **DELETE** the entire section from `--- START OF ORIGINAL FILE: modules\theme-manager\theme-manager.psm1 ---` to its corresponding `--- END OF ORIGINAL FILE ---` tag. **REPLACE** the deleted section with the following powerful, file-based theme engine.

```powershell
# --- START OF ORIGINAL FILE: modules\theme-engine\theme-engine.psm1 ---
# MODULE: ThemeEngine
# PURPOSE: Loads and serves theme styles from JSON files, enabling full user customization.

class ThemeEngine {
    hidden [hashtable] $_themes
    hidden [string] $_currentThemeKey
    hidden [hashtable] $_currentThemeObject

    ThemeEngine([string]$themesDirectory) {
        $this._themes = @{}
        $this.LoadThemesFromDirectory($themesDirectory)

        # HARDENING: Ensure there is at least a fallback theme in case none are found or loadable.
        # This prevents the application from crashing on first run or with a bad configuration.
        if ($this._themes.Count -eq 0) {
            Write-Log -Level Warning -Message "No valid themes found. Loading internal default fallback."
            $this._themes['Default'] = @{
                Name = 'Default Fallback'
                Palette = @{ 
                    background = '#0d1117'; foreground = '#c9d1d9'; accent1 = '#58a6ff'; accent2 = '#f78166';
                    border = '#30363d'; borderFocus = '#58a6ff'; success = '#3fb950'; error = '#f85149';
                    errorHighlight = '#FF00FF'
                }
                Components = @{ 
                    Default = @{ FG = '$Palette.foreground'; BG = '$Palette.background' }
                    Panel = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.foreground' }
                    PanelFocus = @{ BorderFG = '$Palette.borderFocus' }
                    Table = @{ Header = @{ FG = '$Palette.accent1'; Bold = $true } }
                    FileBrowser = @{
                        Default = @{ FG = '$Palette.foreground' }
                        Directory = @{ FG = '$Palette.accent1'; Bold = $true }
                        Selected = @{ BG = '#2ea043'; FG = '#ffffff' }
                    }
                    Kanban = @{
                        Column = @{ BorderFG = '$Palette.border' }
                        Card = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent2' }
                        CardSelected = @{ BorderFG = '$Palette.borderFocus'; BG = '#30363d' }
                    }
                    Widget = @{
                        UpNext = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent1' }
                        Stats = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent2' }
                        Text = @{ Default = @{ FG = '$Palette.foreground' }; Overdue = @{ FG = '$Palette.error'; Bold = $true } }
                    }
                }
            }
        }

        # Set the first available theme as the current one.
        $this.SetTheme(($this._themes.Keys | Select-Object -First 1))
    }

    [void] LoadThemesFromDirectory([string]$dir) {
        if (-not (Test-Path $dir)) { Write-Log -Level Warning -Message "Themes directory not found: $dir"; return }
        $themeFiles = Get-ChildItem -Path $dir -Filter "*.theme.json" -File
        foreach ($file in $themeFiles) {
            try {
                $themeKey = ($file.BaseName -replace '\.theme$', '')
                $themeObject = Get-Content -Path $file.FullName -Raw | ConvertFrom-Json -AsHashtable
                $this._themes[$themeKey] = $themeObject
                Write-Log -Level Info -Message "Loaded theme '$themeKey' from $($file.Name)"
            } catch {
                # HARDENING: Resiliently handles corrupted or malformed theme files without crashing.
                Write-Log -Level Error -Message "Failed to load theme file '$($file.Name)': $_"
            }
        }
    }

    [void] SetTheme([string]$themeKey) {
        if ($this._themes.ContainsKey($themeKey)) {
            $this._currentThemeKey = $themeKey
            $this._currentThemeObject = $this._themes[$themeKey]
            Publish-Event -EventName "Theme.Changed" -Data @{ Name = $themeKey }
            Write-Log -Level Info -Message "Theme changed to: $themeKey"
        } else {
            Write-Log -Level Warning -Message "Attempted to set non-existent theme: $themeKey"
        }
    }

    # The core method for retrieving a fully resolved style object for a component.
    [hashtable] GetStyle([string]$componentPath) {
        $pathSegments = $componentPath.Split('.')
        $currentValue = $this._currentThemeObject
        
        # Traverse the path in the theme file (e.g., Components.Table.Header)
        foreach($segment in $pathSegments) {
            if ($currentValue -is [hashtable] -and $currentValue.ContainsKey($segment)) {
                $currentValue = $currentValue[$segment]
            } else {
                # Path not found, return an empty style to avoid errors in the calling code.
                return @{}
            }
        }
        
        # Now, resolve all palette references (e.g., '$Palette.accent1') in the retrieved style object.
        $resolvedStyle = @{}
        if ($currentValue -is [hashtable]) {
            foreach ($key in $currentValue.Keys) {
                $val = $currentValue[$key]
                $depth = 0 # HARDENING: Introduce depth counter to prevent infinite loops from circular references.
                
                while ($val -is [string] -and $val.StartsWith('$Palette.') -and $depth -lt 10) {
                    $paletteKey = $val.Substring(9)
                    # HARDENING: Check if the palette key actually exists to prevent errors.
                    if ($this._currentThemeObject.Palette.ContainsKey($paletteKey)) {
                        $val = $this._currentThemeObject.Palette[$paletteKey]
                    } else {
                        # Key not found, break loop and assign a visible error color for easy debugging.
                        Write-Log -Level Warning -Message "Theme '$($this._currentThemeKey)' is missing palette key: '$paletteKey' requested by '$componentPath'"
                        $val = $this._currentThemeObject.Palette.errorHighlight ?? '#FF00FF'
                        break
                    }
                    $depth++
                }
                # If it's still a variable after max depth, it's a circular reference.
                if ($val -is [string] -and $val.StartsWith('$Palette.')) {
                    Write-Log -Level Error -Message "Circular or unresolved palette reference detected at '$componentPath' for value '$val'"
                    $val = $this._currentThemeObject.Palette.errorHighlight ?? '#FF00FF'
                }
                $resolvedStyle[$key] = $val
            }
        }
        
        return $resolvedStyle
    }

    [string[]] GetThemeKeys() {
        return @($this._themes.Keys)
    }

    [hashtable] GetCurrentTheme() {
        return $this._currentThemeObject
    }
}

# Factory function to create the engine instance.
function Initialize-ThemeEngine {
    param([string]$themesDirectory)
    return [ThemeEngine]::new($themesDirectory)
}
# --- END OF REPLACEMENT for modules\theme-manager\theme-manager.psm1 ---
```

**Rationale:** This new `ThemeEngine` completely decouples visual styling from application logic. It allows for:
1.  **User Theming:** Users can create and drop in `.json` files to skin the entire application.
2.  **Centralized Palettes:** Colors are defined once in a `Palette` and reused via variables (`$Palette.accent1`), making theme maintenance trivial.
3.  **Resilience:** The engine includes a robust internal fallback theme and handles errors in external theme files gracefully.
4.  **Debugging:** The variable resolver is hardened against missing keys and circular references, applying a highly visible error color (`#FF00FF`) to make theme errors obvious.

---

This completes the first three foundational steps. In the next response, we will continue with Pillar 1 by refactoring the drawing primitives and the main render loop to consume these new, powerful components.
Understood. We continue the refactoring. The foundation is laid; now we rebuild the structures upon it. The following steps will integrate our new `TuiCell` and `ThemeEngine` into the application's drawing primitives and main render loop, completing the Phoenix Engine upgrade.

---

#### **Step 1.4: Refactor Drawing Primitives to be Style-Driven**

**File:** `axiom.txt`
**Location:** The `Write-TuiText` and `Write-TuiBox` functions within the `--- START OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---` section.
**Action:** The current drawing functions accept numerous individual parameters for styling (e.g., `-ForegroundColor`, `-BackgroundColor`, `-Bold`). This is verbose and contrary to a theme-driven architecture. We will refactor them to accept a single `-Style [hashtable]` parameter, which is the direct output of our `ThemeEngine`.

**Instruction:** **DELETE** the existing `function Write-TuiText { ... }` and `function Write-TuiBox { ... }` blocks and **REPLACE** them with the following refactored versions.

```powershell
# In components\tui-primitives\tui-primitives.psm1

function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        # MODIFIED: A single -Style parameter replaces all individual style flags.
        [hashtable]$Style = @{} 
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }

    # Extract properties from the style object, providing safe defaults using the null-coalescing operator.
    # This makes the function resilient to incomplete style definitions.
    $fg = $Style.FG ?? "#C0C0C0"
    $bg = $Style.BG ?? $null
    $bold = [bool]($Style.Bold ?? $false)
    $italic = [bool]($Style.Italic ?? $false)
    $underline = [bool]($Style.Underline ?? $false)
    $strikethrough = [bool]($Style.Strikethrough ?? $false)

    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0 -and $Y -ge 0 -and $Y -lt $Buffer.Height) {
            # Use the powerful new TuiCell constructor with all attributes.
            $charCell = [TuiCell]::new($char, $fg, $bg, $bold, $italic, $underline, $strikethrough)
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$Title = "",
        # MODIFIED: The -Style parameter now drives all visual aspects of the box.
        [hashtable]$Style = @{}
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }

    # Extract properties from the style object with safe fallbacks.
    $borderStyleName = $Style.BorderStyle ?? "Single"
    $borderColor = $Style.BorderFG ?? "#808080" # Default border color: medium gray
    $bgColor = $Style.BG ?? $null               # Default background: transparent
    $titleColor = $Style.TitleFG ?? $borderColor # Title defaults to border color if not specified.
    $titleStyleOverrides = $Style.TitleStyle ?? @{} # Allow specific overrides for title, e.g., Bold = $true

    $borders = Get-TuiBorderChars -Style $borderStyleName
    
    # Define style objects for child calls to Write-TuiText.
    $borderStyle = @{ FG = $borderColor; BG = $bgColor }
    $titleStyle = @{ FG = $titleColor; BG = $bgColor }
    # Merge title overrides
    foreach($key in $titleStyleOverrides.Keys) { $titleStyle[$key] = $titleStyleOverrides[$key] }
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -Style $borderStyle
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -lt ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -Style $titleStyle
        }
    }
    
    # Side borders and fill
    if ($Height -gt 1) {
        $fillNeeded = ($bgColor -ne $null)
        $fillText = if ($fillNeeded) { ' ' * ($Width - 2) } else { '' }
        $fillStyle = @{ BG = $bgColor }

        for ($i = 1; $i -lt ($Height - 1); $i++) {
            $currentY = $Y + $i
            if ($currentY -ge 0 -and $currentY -lt $Buffer.Height) {
                Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -Style $borderStyle
                if ($fillNeeded) { Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -Style $fillStyle }
                Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -Style $borderStyle
            }
        }
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomY = $Y + $Height - 1
        if ($bottomY -ge 0 -and $bottomY -lt $Buffer.Height) {
            $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
            Write-TuiText -Buffer $Buffer -X $X -Y $bottomY -Text $bottomLine -Style $borderStyle
        }
    }
}
```

**Rationale:** This change is fundamental to enforcing a theme-driven design. Components no longer decide their own colors; they request a style from the `ThemeEngine` and pass it to the drawing primitives. This aligns with the "Don't Repeat Yourself" (DRY) principle and makes global visual changes possible by editing a single theme file instead of dozens of component files.

---

#### **Step 1.5: Revolutionize the Main Engine Renderer**

**File:** `axiom.txt`
**Location:** The `Render-CompositorToConsole` function within the `--- START OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---` section.
**Action:** The current renderer is inefficient and does not support Truecolor. It will be replaced with a highly optimized version that performs differential rendering, minimizes ANSI escape code output, and uses our new Truecolor helpers. This is the most significant performance upgrade in the entire plan.

**Instruction:** **DELETE** the entire existing `function Render-CompositorToConsole { ... }` block and **REPLACE** it with the following. Also, **DELETE** the now obsolete `function Get-AnsiColorCode { ... }` from the same file section.

```powershell
# In modules\tui-engine\tui-engine.psm1

function Render-CompositorToConsole {
    # This buffer is increased to accommodate potentially longer Truecolor escape sequences.
    $outputBuilder = [System.Text.StringBuilder]::new(40000)
    $currentBuffer = $global:TuiState.CompositorBuffer
    $previousBuffer = $global:TuiState.PreviousCompositorBuffer
    
    # OPTIMIZATION: Track the last used style sequence as a string.
    # If the next cell has the same style, we don't need to send any new ANSI codes.
    $lastSequence = "RESET" # A unique sentinel value to ensure the first sequence is always sent.
    
    # On the very first frame, we must render everything. No diffing is possible.
    $forceFullRender = ($global:TuiState.RenderStats.FrameCount -eq 1)

    try {
        # Move cursor to home position once at the beginning of the entire render operation.
        [void]$outputBuilder.Append("`e[1;1H")

        for ($y = 0; $y -lt $currentBuffer.Height; $y++) {
            # Since we're doing a diff, we can't just skip whole lines. We must check cell by cell.
            # A variable to track if we've written anything to this line yet.
            $cursorMovedOnLine = $false
            
            for ($x = 0; $x -lt $currentBuffer.Width; $x++) {
                $newCell = $currentBuffer.GetCell($x, $y)
                
                # OPTIMIZATION 1: Differential Rendering
                # If not forcing a full render, compare the new cell to the one from the previous frame.
                if (-not $forceFullRender) {
                    $oldCell = $previousBuffer.GetCell($x, $y)
                    # If cells are identical, we don't need to draw it. We just need to ensure the cursor is in the right place.
                    if (-not $newCell.DiffersFrom($oldCell)) {
                        continue
                    }
                }
                
                # If we are here, the cell needs to be redrawn.
                # Move the cursor to the correct position for this cell.
                if (-not $cursorMovedOnLine) {
                    [void]$outputBuilder.Append("`e[$($y + 1);1H") # Move to start of line
                    if ($x > 0) { [void]$outputBuilder.Append("`e[$($x)C") } # Move right X columns
                    $cursorMovedOnLine = $true
                } else {
                    [void]$outputBuilder.Append("`e[$($y + 1);$($x + 1)H") # Absolute cursor move
                }
                
                # Generate the full style sequence for the new cell using our Truecolor helper.
                $attributes = @{ Bold=$newCell.Bold; Italic=$newCell.Italic; Underline=$newCell.Underline; Strikethrough=$newCell.Strikethrough }
                $currentSequence = [TuiAnsiHelper]::GetAnsiSequence($newCell.ForegroundColor, $newCell.BackgroundColor, $attributes)

                # OPTIMIZATION 2: State Change Minimization
                # Only append the style sequence if it's different from the last one used.
                if ($currentSequence -ne $lastSequence) {
                    # To ensure a clean state, we combine a reset with the new style.
                    # This prevents style attributes from "leaking" between cells.
                    [void]$outputBuilder.Append([TuiAnsiHelper]::Reset()).Append($currentSequence)
                    $lastSequence = $currentSequence
                }
                
                # Finally, append the character itself.
                [void]$outputBuilder.Append($newCell.Char)
            }
        }
        
        # Append a final reset to ensure the terminal is clean after the application exits or rendering stops.
        [void]$outputBuilder.Append([TuiAnsiHelper]::Reset())
        
        # Write the entire frame's changes in one single, atomic operation to the console.
        if ($outputBuilder.Length -gt 0) {
            [Console]::Write($outputBuilder.ToString())
        }
    } catch {
        # Log any catastrophic rendering failure.
        Write-Log -Level Fatal -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}
```

**Rationale:** This new function is the heart of a modern TUI.
1.  **Differential Rendering:** By comparing the current buffer (`$currentBuffer`) to the last frame's (`$previousBuffer`), it only redraws pixels that have actually changed. This is the difference between rendering 80x25=2000 cells per frame and rendering maybe only 50 cells for a blinking cursor. The performance gain is monumental.
2.  **State Minimization:** By tracking `$lastSequence`, it avoids sending redundant ANSI escape codes. If ten consecutive cells are red with a black background, it sends the ANSI code for that style *once*, not ten times. This dramatically reduces the amount of data sent to the terminal, improving responsiveness, especially over SSH.
3.  **Atomic Write:** The entire frame is built in a `StringBuilder` and written to `[Console]::Write()` in a single call. This prevents the screen tearing that can occur from many small `Write-Host` calls.

---

#### **Step 1.6: Finalize the Startup Sequence**

**File:** `axiom.txt`
**Location:** The main `try/catch/finally` execution block at the very end of the script.
**Action:** We must replace the old `Initialize-ThemeManager` call with our new `Initialize-ThemeEngine`, create the necessary `themes` directory, and add the engine to the global services container.

**Instruction:** **MODIFY** the startup block to integrate the `ThemeEngine`.

```powershell
# In axiom.txt, near the end of the file

try {
    # ... (existing startup messages)
    
    # 1. Initialize core services that have no dependencies
    Write-Host "`nInitializing services..." -ForegroundColor Yellow
    Initialize-Logger -Level $(if ($Debug) { "Debug" } else { "Info" })
    Initialize-EventSystem
    
    # --- MODIFICATION START ---
    # NEW: Create the themes directory if it doesn't exist. This ensures the app
    # can run out-of-the-box without manual folder creation.
    $themesDir = Join-Path $PSScriptRoot "themes"
    if (-not (Test-Path $themesDir)) { 
        Write-Log -Level Info -Message "Themes directory not found, creating at: $themesDir"
        New-Item -Path $themesDir -ItemType Directory | Out-Null 
        # In a real distribution, you would also create a default.theme.json file here.
    }
    
    # REPLACE the old Initialize-ThemeManager call.
    $global:ThemeEngine = Initialize-ThemeEngine -themesDirectory $themesDir
    # --- MODIFICATION END ---
    
    Initialize-DialogSystem
    
    # 2. Create the service container
    $services = @{
        # ADD the ThemeEngine to the services container so all screens can access it.
        ThemeEngine = $global:ThemeEngine
    }
    
    # 3. Initialize services that depend on others...
    $services.KeybindingService = New-KeybindingService
    $services.DataManager = Initialize-DataManager
    
    # 4. NavigationService needs the full $services container...
    $services.Navigation = Initialize-NavigationService -Services $services
    
    # ... (rest of the startup sequence remains the same) ...
    
} catch {
    # ...
} finally {
    # ...
}
```

**Rationale:** This finalizes the integration. The application now correctly initializes the `ThemeEngine`, makes it available to all other parts of the application via the `$services` container, and ensures the necessary directory structure exists for users to add their own themes.

---

### **Pillar 1 Complete**

We have successfully burned the ships. The old rendering and theming system is gone. In its place stands the Phoenix Engine: a Truecolor-capable, fully themeable, and highly performant rendering foundation. Every visual element from this point forward will be built upon this superior architecture. The application is now ready for the integration of modern, component-based UI in Pillar 2.

Of course. The foundation is stable. We now proceed to Pillar 2, where we transform the application's user experience from a static, menu-driven model to a fluid, command-driven one. We will tear out the old, disconnected utilities and re-forge them as integrated, first-class components of the application.

---

### **Pillar 2: Integrated Components & Command-Driven Architecture**

**Objective:** To replace the rigid numeric menu system with a modern, searchable command palette and to convert the standalone file browser utility into a fully integrated screen within the application. This pillar focuses on creating a seamless and efficient user workflow.

#### **Prerequisite: Deleting Obsolete Code**

The old, procedural file browser (likely functions prefixed with `FB_` or `Start-TerminalFileBrowser`) and any standalone fuzzy-search functions are now entirely obsolete. They are being replaced by the `FileListComponent` and `CommandPalette` respectively.

**Instruction:** Before proceeding, locate any standalone function definitions related to file browsing or fuzzy searching in the monolith and **DELETE** them. They are incompatible with the new architecture.

---

#### **Step 2.1: Refactor the File Browser into an Integrated Component**

**Action:** We will create a new `FileListComponent` class to encapsulate file system browsing logic. Then, we will create a new `ExplorerScreen` to host this component, providing a full-featured, navigable file explorer inside the application.

**Instruction 1:** Add the new `FileListComponent` class. This is a reusable, data-driven component. It should be placed in the `--- START OF ORIGINAL FILE: components\advanced-data-components\advanced-data-components.psm1 ---` section, after the `Table` class definition.

```powershell
# In components\advanced-data-components\advanced-data-components.psm1

# A reusable component that displays and handles navigation of a file system directory.
class FileListComponent : UIElement {
    [string]$Path
    [System.IO.FileSystemInfo[]]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollTop = 0
    [bool]$ShowHidden = $false
    [hashtable]$SelectedItems = @{}

    FileListComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Name = $name
    }

    [void] SetPath([string]$newPath) {
        # Resolve the path to its full, canonical form.
        try {
            $this.Path = (Get-Item -LiteralPath $newPath).FullName
            $this.Refresh()
        } catch {
            Write-Log -Level Error -Message "Failed to set path for FileListComponent: $_"
            # Optionally, show an alert dialog to the user.
            Show-AlertDialog -Title "Path Error" -Message "The path '$newPath' could not be found or accessed."
        }
    }

    [void] Refresh() {
        # HARDENING: The Get-ChildItem call is synchronous and WILL block the UI thread
        # if browsing a large directory or a slow network share. For a truly responsive UI,
        # this operation should be made asynchronous (e.g., using Start-Job or a runspace).
        # The component would then display a "Loading..." state and update once the job completes.
        
        # Always add ".." entry for parent directory navigation, unless at a drive root.
        $parentEntry = $null
        try {
            $parent = (Get-Item $this.Path).Parent
            if ($parent) {
                $parentEntry = [PSCustomObject]@{ Name = '..'; FullName = $parent.FullName; PSIsContainer = $true; LastWriteTime = $parent.LastWriteTime }
            }
        } catch { /* Suppress errors for roots that have no parent */ }

        $childItems = @(Get-ChildItem -LiteralPath $this.Path -Force:$this.ShowHidden -ErrorAction SilentlyContinue | Sort-Object PSIsContainer -Descending, Name)
        
        $this.Items = if ($parentEntry) { @($parentEntry) + $childItems } else { $childItems }

        # Clamp the selected index to valid bounds after refresh.
        if ($this.SelectedIndex -ge $this.Items.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
        }
        $this.RequestRedraw()
    }
    
    hidden [void] UpdateScrolling() {
        # Ensure the selected item is always visible within the component's viewport.
        if ($this.SelectedIndex < $this.ScrollTop) {
            $this.ScrollTop = $this.SelectedIndex
        }
        if ($this.SelectedIndex >= ($this.ScrollTop + $this.Height)) {
            $this.ScrollTop = $this.SelectedIndex - $this.Height + 1
        }
    }

    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        $this._private_buffer.Clear()
        
        # Retrieve styles from the theme engine. This component knows nothing about colors.
        $styleDefault = $Global:ThemeEngine.GetStyle("Components.FileBrowser.Default")
        $styleDir = $Global:ThemeEngine.GetStyle("Components.FileBrowser.Directory")
        $styleSelected = $Global:ThemeEngine.GetStyle("Components.FileBrowser.Selected")

        $visibleCount = [Math]::Min($this.Items.Count - $this.ScrollTop, $this.Height)
        
        for ($i = 0; $i -lt $visibleCount; $i++) {
            $itemIndex = $this.ScrollTop + $i
            if ($itemIndex -ge $this.Items.Count) { break }
            
            $item = $this.Items[$itemIndex]
            $isCurrent = ($itemIndex -eq $this.SelectedIndex)
            
            $icon = if ($item.PSIsContainer) { "ðŸ“" } else { "ðŸ“„" }
            # Truncate line to fit component width.
            $line = "$icon $($item.Name)"
            if ($line.Length -gt $this.Width) { $line = $line.Substring(0, $this.Width - 1) + "â€¦" }
            $line = $line.PadRight($this.Width)

            $currentStyle = if ($item.PSIsContainer) { $styleDir } else { $styleDefault }
            if ($isCurrent -and $this.IsFocused) {
                # Merge the 'Selected' style over the top of the item's base style.
                foreach($key in $styleSelected.Keys) { $currentStyle[$key] = $styleSelected[$key] }
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y $i -Text $line -Style $currentStyle
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # This component only handles navigational input.
        switch ($keyInfo.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex > 0) { $this.SelectedIndex-- }
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex < ($this.Items.Count - 1)) { $this.SelectedIndex++ }
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::PageUp) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this.Height)
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::PageDown) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this.Height)
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
        }
        return $false # Did not handle the input.
    }
}
```

**Instruction 2:** Create the `ExplorerScreen` that uses this component. This is a new screen, so it requires a new file section in the monolith.

**Instruction:** **ADD** the following new section to the monolith script, preferably grouped with other screen definitions.

```powershell
# --- START OF ORIGINAL FILE for screens\explorer-screen\explorer-screen.psm1 ---
class ExplorerScreen : Screen {
    [Panel]$mainPanel
    [FileListComponent]$fileList
    [Panel]$previewPanel
    [Panel]$statusBar

    ExplorerScreen([hashtable]$services) : base("ExplorerScreen", $services) { }

    [void] Initialize() {
        $this.Width = $global:TuiState.BufferWidth
        $this.Height = $global:TuiState.BufferHeight

        # Layout the panels for the screen
        $listWidth = [Math]::Floor($this.Width * 0.5)
        
        $listPanel = [Panel]::new(1, 1, $listWidth, $this.Height - 4, "Files")
        $listPanel.Style = $Global:ThemeEngine.GetStyle("Components.Panel")
        $this.AddChild($listPanel)
        
        $this.previewPanel = [Panel]::new($listPanel.X + $listPanel.Width, 1, $this.Width - $listPanel.Width - 2, $this.Height - 4, "Preview")
        $this.previewPanel.Style = $Global:ThemeEngine.GetStyle("Components.Panel")
        $this.AddChild($this.previewPanel)
        
        $this.statusBar = [Panel]::new(1, $this.Height - 2, $this.Width - 2, 1)
        $this.statusBar.HasBorder = $false
        $this.AddChild($this.statusBar)

        # Create the file list component and add it to its containing panel.
        $this.fileList = [FileListComponent]::new("ExplorerFileList")
        # The component must be sized to fit within the panel's content area.
        $this.fileList.Resize($listPanel.ContentWidth, $listPanel.ContentHeight)
        $listPanel.AddChild($this.fileList)
    }

    [void] OnEnter() {
        # Set a starting path when the screen is entered.
        $this.fileList.SetPath((Get-Location).Path)
        Set-ComponentFocus -Component $this.fileList
        $this.UpdateStatusBar("Ctrl+P for commands | Enter to navigate/open")
        $this.fileList.add_RequestRedraw({ $this.OnSelectionChange() })
    }
    
    # This screen handles the "Enter" key, which has meaning outside the FileListComponent.
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($keyInfo.Key -eq [ConsoleKey]::Enter) {
            $selectedItem = $this.fileList.Items[$this.fileList.SelectedIndex]
            if ($selectedItem.PSIsContainer) {
                # If it's a directory, navigate the component into it.
                $this.fileList.SetPath($selectedItem.FullName)
            } else {
                # If it's a file, perhaps open it externally or show a full-screen preview.
                Show-AlertDialog -Title "Action" -Message "Action for file '$($selectedItem.Name)' is not yet implemented."
            }
            return $true # We handled the 'Enter' key.
        }
        # Let the TUI engine pass input to the focused component (the file list) for navigation.
        return $false
    }
    
    # Event handler for when the file list selection changes.
    [void] OnSelectionChange() {
        $selectedItem = $this.fileList.Items[$this.fileList.SelectedIndex]
        $this.UpdateStatusBar("Path: $($this.fileList.Path)")
        $this.ShowFilePreview($selectedItem)
    }
    
    [void] UpdateStatusBar([string]$text) {
        $this.statusBar.GetBuffer().Clear()
        Write-TuiText -Buffer $this.statusBar.GetBuffer() -X 0 -Y 0 -Text $text -Style @{ FG = "#a0a0a0" }
        $this.statusBar.RequestRedraw()
    }
    
    [void] ShowFilePreview([System.IO.FileSystemInfo]$file) {
        $this.previewPanel.SetTitle("Preview: $($file.Name)")
        $this.previewPanel.ClearContent()
        
        if ($file.PSIsContainer) { return } # No preview for directories.

        # HARDENING: Reading large files synchronously will block the UI.
        # This preview should be limited to a few KB or made asynchronous.
        try {
            $content = Get-Content -Path $file.FullName -TotalCount $this.previewPanel.ContentHeight -ErrorAction Stop
            for ($i = 0; $i -lt $content.Count; $i++) {
                $line = $content[$i].Replace("`t", '    ') # Expand tabs
                Write-TuiText -Buffer $this.previewPanel.GetBuffer() -X $this.previewPanel.ContentX -Y ($this.previewPanel.ContentY + $i) -Text $line -Style @{ FG = "#D4D4D4" }
            }
        } catch {
            Write-TuiText -Buffer $this.previewPanel.GetBuffer() -X $this.previewPanel.ContentX -Y $this.previewPanel.ContentY -Text "Error reading file: Not a text file or access denied." -Style @{ FG = "#f85149" }
        }
        $this.previewPanel.RequestRedraw()
    }
}
# --- END OF ORIGINAL FILE for screens\explorer-screen\explorer-screen.psm1 ---
```

**Rationale:** The file browser is no longer a monolithic function but a clean composition of a reusable `FileListComponent` hosted within a purpose-built `ExplorerScreen`. The screen manages layout and high-level actions (`Enter` key), while the component manages its own state and rendering. This separation of concerns is the core tenet of the new architecture.

---

This is a significant step. We have taken a piece of standalone functionality and woven it into the very fabric of the application as a navigable, themeable, first-class citizen. We will now apply the same principle to the application's entire command structure by implementing the Command Palette. I will continue in the next response.

Acknowledged. We are proceeding. The `FileListComponent` is integrated, providing the "what." Now we build the "how"â€”the command-driven nervous system of the application.

---

### **Step 2.2: Implement the Command Palette**

**Action:** We will now implement the command palette, a special dialog that provides a fast, searchable interface to all application "Actions." This completely replaces the need for static, numbered menus and becomes the primary method of user interaction beyond direct content manipulation. This system is composed of four parts: a way to mark functions as actions (`ActionAttribute`), a service to find them (`ActionService`), the UI itself (`CommandPalette`), and a global trigger.

**Instruction 1:** First, we must define the custom attribute that will be used to "decorate" functions, marking them as discoverable commands. This type definition must exist before any other code attempts to use it.

**Instruction:** **ADD** the following `Add-Type` block to the very top of the `axiom.txt` script, before the `using` statements.

```powershell
# This must be at the top of the script, before any `using` statements or class definitions.
Add-Type -TypeDefinition @"
    using System;
    // An attribute to decorate functions that should appear in the command palette.
    // It allows us to attach metadata (Name, Group) directly to a function definition.
    [AttributeUsage(AttributeTargets.Function)]
    public class ActionAttribute : Attribute {
        public string Name { get; set; }
        public string Group { get; set; }
        public ActionAttribute(string name) { this.Name = name; }
    }
"@ -ErrorAction Stop
```

**Rationale:** This custom attribute is the contract. It provides a clean, declarative way to register a function with the command system without needing a central registration file. PowerShell's reflection capabilities will allow us to discover these at runtime.

**Instruction 2:** Create the `ActionService` responsible for discovering and caching all decorated functions at startup.

**Instruction:** **ADD** the following new section to the monolith, preferably grouped with other service definitions.

```powershell
# --- START OF ORIGINAL FILE for services/action-service.psm1 ---
class ActionService {
    [System.Collections.Generic.List[object]]$Actions

    ActionService() {
        $this.Actions = [System.Collections.Generic.List[object]]::new()
        $this.DiscoverActions()
    }

    [void] DiscoverActions() {
        # HARDENING: This "magic" discovery relies on reflection (Get-Command) to find functions
        # in the global scope of the session. It assumes no third-party modules will use an
        # attribute named [ActionAttribute]. For a more robust, large-scale system, an
        # "Inversion of Control" pattern where modules explicitly *register* their actions
        # with the ActionService (`$actionService.RegisterAction($functionObject)`) would provide
        # a more explicit and less fragile contract. For this project's scope, reflection is
        # a powerful and pragmatic solution.
        
        # Get all functions in the current session's global scope.
        $functions = Get-Command -CommandType Function -Scope Global
        foreach ($func in $functions) {
            # Find functions decorated with our custom ActionAttribute.
            $attribute = $func.Attributes | Where-Object { $_.TypeId.Name -eq 'ActionAttribute' }
            if ($attribute) {
                $this.Actions.Add([PSCustomObject]@{
                    Name = $attribute.Name
                    Group = $attribute.Group ?? "General"
                    Function = $func
                })
            }
        }
        # Sort the discovered actions for a clean presentation in the UI.
        $this.Actions = $this.Actions | Sort-Object Group, Name
        Write-Log -Level Info -Message "Discovered $($this.Actions.Count) commands for the palette."
    }
}

function Initialize-ActionService {
    return [ActionService]::new()
}
# --- END OF ORIGINAL FILE for services/action-service.psm1 ---
```

**Rationale:** The `ActionService` centralizes the discovery logic. It runs once at startup, using `Get-Command` to find all functions and inspects their attributes. This is far more maintainable than a manually curated list of commands.

**Instruction 3:** Implement the `CommandPalette` dialog UI itself.

**Instruction:** **ADD** the following `CommandPalette` class definition to the `--- START OF FULL REPLACEMENT for modules\dialog-system-class\dialog-system-class.psm1 ---` section.

```powershell
# In modules\dialog-system-class\dialog-system-class.psm1

class CommandPalette : Dialog {
    [TextBoxComponent]$inputBox
    [Table]$resultsTable
    [object[]]$allActions
    [object[]]$filteredActions

    CommandPalette() : base("CommandPalette") {
        $this.Title = "Command Palette"
        # Dynamically size the palette to be a large portion of the screen.
        $this.Width = [Math]::Floor($global:TuiState.BufferWidth * 0.6)
        $this.Height = [Math]::Floor($global:TuiState.BufferHeight * 0.7)
        
        # Get the master list of actions from the service.
        $this.allActions = @($Global:Services.ActionService.Actions)
        $this.filteredActions = $this.allActions
        
        # Create the input box for filtering.
        $this.inputBox = New-TuiTextBox -Props @{ Name = "PaletteInput"; Width = $this.Width - 4; Height = 3 }
        $this.inputBox.Move(2, 1)
        # Wire up the text box's OnChange event to our filtering method.
        $this.inputBox.OnChange = { param($NewValue) $this.FilterActions($NewValue) }
        $this.AddChild($this.inputBox)

        # Create the table to display results.
        $this.resultsTable = New-TuiTable -Props @{ Name = "PaletteResults"; Width = $this.Width - 4; Height = $this.Height - 5 }
        $this.resultsTable.Move(2, 4)
        $this.resultsTable.ShowBorder = $false
        $this.resultsTable.SetColumns(@(
            [TableColumn]::new('Name', 'Action', [Math]::Floor(($this.Width-6)*0.7)),
            [TableColumn]::new('Group', 'Group', [Math]::Floor(($this.Width-6)*0.3))
        ))
        $this.resultsTable.SetData($this.filteredActions)
        $this.AddChild($this.resultsTable)
        
        # Immediately focus the input box when the dialog is shown.
        Set-ComponentFocus -Component $this.inputBox
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # First, let the input box handle typing, backspace, etc.
        if ($this.inputBox.HandleInput($key)) {
            # The input box's OnChange event handles filtering, so we just return.
            return $true
        }
        
        # If the input box didn't handle it, we process navigation keys.
        switch ($key.Key) {
            ([ConsoleKey]::DownArrow) { $this.resultsTable.SelectNext(); return $true }
            ([ConsoleKey]::UpArrow) { $this.resultsTable.SelectPrevious(); return $true }
            ([ConsoleKey]::Enter) {
                $selectedAction = $this.resultsTable.GetSelectedItem()
                if ($selectedAction) {
                    $this.Close() # Close the palette first.
                    # Execute the ScriptBlock associated with the selected action.
                    & $selectedAction.Function.ScriptBlock
                }
                return $true
            }
        }
        # Finally, pass to the base Dialog handler for Escape key, etc.
        return ([Dialog]$this).HandleInput($key)
    }
    
    [void] FilterActions([string]$filterText) {
        if ([string]::IsNullOrWhiteSpace($filterText)) {
            $this.filteredActions = $this.allActions
        } else {
            # A simple "contains" filter. This can be upgraded to a more advanced
            # fuzzy-matching algorithm later if desired.
            $this.filteredActions = $this.allActions | Where-Object { $_.Name -like "*$filterText*" -or $_.Group -like "*$filterText*" }
        }
        $this.resultsTable.SetData($this.filteredActions)
        $this.RequestRedraw()
    }
}
```

**Instruction 4:** Wire up the global keybinding (`Ctrl+P`) to trigger the palette and define a few sample actions to populate it.

**Instruction:** **MODIFY** the `Process-SingleKeyInput` function in `modules\tui-engine\tui-engine.psm1`.

```powershell
# In modules\tui-engine\tui-engine.psm1

function Process-SingleKeyInput {
    param($keyInfo)
    
    # NEW: Check for global command palette keybind (Ctrl+P) at the highest priority.
    if (($keyInfo.Modifiers -band [ConsoleModifiers]::Control) -and $keyInfo.Key -eq 'P') {
        $palette = [CommandPalette]::new()
        $palette.Show()
        return # Input is handled.
    }

    # ... (rest of the function for overlays, tab, focused component, etc.)
}
```

**Instruction:** **ADD** the following new file section to define the global commands. This ensures the command logic is organized and separate from other code.

```powershell
# --- START OF ORIGINAL FILE for commands/global-commands.psm1 ---
# This file contains globally available actions for the Command Palette.
# Each function is decorated with the [Action] attribute to make it discoverable.

[Action("Application: Quit", Group="Application")]
function Request-AppQuit {
    $Global:Services.Navigation.RequestExit()
}

[Action("Application: Force UI Refresh", Group="Application")]
function Request-UIRefresh {
    # This forces a full, non-differential render of the entire screen.
    $global:TuiState.RenderStats.FrameCount = 1
    Request-TuiRefresh
}

[Action("Navigation: Go to Dashboard", Group="Navigation")]
function Navigate-ToDashboard {
    $Global:Services.Navigation.GoTo("/dashboard")
}

[Action("Navigation: Go to File Explorer", Group="Navigation")]
function Navigate-ToFileExplorer {
    $Global:Services.Navigation.GoTo("/explorer")
}

[Action("Theme: Cycle to Next Theme", Group="Theme")]
function Cycle-Theme {
    $engine = $Global:Services.ThemeEngine
    $themes = $engine.GetThemeKeys()
    if ($themes.Count -lt 2) { return } # No cycling if only one theme.
    
    $currentIndex = [array]::IndexOf($themes, $engine._currentThemeKey)
    $nextIndex = ($currentIndex + 1) % $themes.Count
    $engine.SetTheme($themes[$nextIndex])
    
    # Force a full redraw to apply the new theme everywhere.
    $global:TuiState.RenderStats.FrameCount = 1
    Request-TuiRefresh
}
# --- END OF ORIGINAL FILE for commands/global-commands.psm1 ---
```

**Final step for this section:** Ensure this new `commands/global-commands.psm1` block is included in the monolith build process so the functions are defined in the global scope before `Initialize-ActionService` is called.

---

### **Pillar 2 Complete**

The application's interaction model has been fundamentally transformed. The rigid, hardcoded menu is gone. In its place is a dynamic, searchable, and extensible command system. Users can now discover and execute any registered action from anywhere in the application with a single key chord. We have built a modern user experience foundation. The next pillar will leverage this by re-imagining the application's screens as dynamic, data-driven workspaces.

Excellent. With the command-driven architecture in place, we are now positioned to revolutionize the application's primary workspaces. We will dismantle the old, static screens and replace them with dynamic, component-based layouts that are more informative and interactive. This is where the user will truly feel the power of the Phoenix upgrade.

---

### **Pillar 3: Re-imagining the Screens**

**Objective:** To replace the outdated `DashboardScreen` and `TaskListScreen` with modern, powerful equivalents. The dashboard will become a "widget-based" container for at-a-glance information. The task list will transform into a "Kanban-style" `TaskFlowScreen` for visual workflow management. This involves a complete deletion and replacement of the existing screen code.

---

#### **Step 3.1: Refactor `DashboardScreen` to be Widget-Based**

**Action:** The old `DashboardScreen` with its static panels and integrated `NavigationMenu` is obsolete. The command palette now handles navigation. This screen will be simplified into a layout container that hosts various self-contained "widget" components. Each widget is a specialized `Panel` responsible for fetching and rendering its own data.

**Instruction:** **DELETE** the entire existing `screens\dashboard-screen\dashboard-screen.psm1` section from the monolith. **REPLACE** it with the following new definition, which includes the screen itself and two new widget component classes.

```powershell
# --- START OF ORIGINAL FILE for screens\dashboard-screen\dashboard-screen.psm1 ---
# ==============================================================================
# PMC Terminal v5 - Widget-Based Dashboard Screen
# A modern dashboard that hosts various informational widgets. Each widget is a
# self-contained component that pulls its own data and renders into its area.
# ==============================================================================

# First, define the new widget components. These are specialized, data-aware panels.
class UpcomingTasksWidget : Panel {
    UpcomingTasksWidget([string]$name) : base() { 
        $this.Name = $name; 
        $this.Title = "Up Next" 
    }

    [void] OnRender() {
        # First, apply the theme style and call the base Panel's OnRender to draw our box and title.
        $this.Style = $Global:ThemeEngine.GetStyle("Components.Widget.UpNext")
        ([Panel]$this).OnRender()

        # Get data via the parent screen's services container.
        $tasks = $this.Parent.Services.DataManager.GetTasks($false) # Get only pending tasks
        $upcoming = $tasks | Sort-Object { $_.DueDate ?? [datetime]::MaxValue } | Select-Object -First ($this.ContentHeight)
        
        $style = $Global:ThemeEngine.GetStyle("Components.Widget.Text.Default")
        $overdueStyle = $Global:ThemeEngine.GetStyle("Components.Widget.Text.Overdue")
        
        $y = 0
        foreach($task in $upcoming) {
            $currentStyle = $style
            $dateText = if ($task.DueDate) { $task.DueDate.Value.ToString("yyyy-MM-dd") } else { "No Date" }
            if ($task.DueDate -and $task.DueDate.Value.Date -lt (Get-Date).Date) {
                $currentStyle = $overdueStyle
                $dateText += " (OVERDUE)"
            }
            # Construct a clean, padded line for display.
            $titlePadded = $task.Title.PadRight($this.ContentWidth - 25)
            $priorityPadded = "[$($task.Priority.ToString().PadRight(6))]"
            $line = "$titlePadded $priorityPadded $dateText"
            
            Write-TuiText -Buffer $this._private_buffer -X $this.ContentX -Y ($this.ContentY + $y) -Text $line -Style $currentStyle
            $y++
        }
    }
}

class StatsWidget : Panel {
    StatsWidget([string]$name) : base() { 
        $this.Name = $name; 
        $this.Title = "Project Stats" 
    }

    [void] OnRender() {
        $this.Style = $Global:ThemeEngine.GetStyle("Components.Widget.Stats")
        ([Panel]$this).OnRender()
        
        $tasks = $this.Parent.Services.DataManager.GetTasks()
        if ($tasks.Count -eq 0) {
            Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 1) -Text "No task data available."
            return
        }

        $completed = ($tasks | Where-Object { $_.Completed }).Count
        $percentage = [Math]::Round(($completed / $tasks.Count) * 100)
        
        $barLength = $this.ContentWidth - 4
        $filledLength = [Math]::Round(($percentage / 100) * $barLength)
        $bar = ("â–ˆ" * $filledLength) + ("â–‘" * ($barLength - $filledLength))

        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 1) -Text "Overall Progress: $percentage%" -Style $this.Style
        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 3) -Text $bar -Style @{ FG = '#3fb950' }
        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 5) -Text "Total Tasks: $($tasks.Count)" -Style $this.Style
        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 6) -Text "Completed:   $completed" -Style $this.Style
    }
}

# The main screen class itself is now a simple layout container for widgets.
class DashboardScreen : Screen {
    [System.Collections.Generic.List[UIElement]]$Widgets
    
    DashboardScreen([hashtable]$services) : base("DashboardScreen", $services) { }

    [void] Initialize() {
        $this.Width = $global:TuiState.BufferWidth
        $this.Height = $global:TuiState.BufferHeight
        $this.Widgets = [System.Collections.Generic.List[UIElement]]::new()
        
        # Create and add widgets to the screen's children for rendering.
        # The layout is declarative.
        $upNextWidget = [UpcomingTasksWidget]::new("UpNext")
        $upNextWidget.Move(1, 1); $upNextWidget.Resize([Math]::Floor($this.Width * 0.6), 12)
        $this.AddChild($upNextWidget)
        $this.Widgets.Add($upNextWidget)
        
        $statsWidget = [StatsWidget]::new("QuickStats")
        $statsWidget.Move($upNextWidget.X + $upNextWidget.Width + 1, 1); $statsWidget.Resize($this.Width - $upNextWidget.Width - 4, 12)
        $this.AddChild($statsWidget)
        $this.Widgets.Add($statsWidget)
        
        # Add a placeholder for a future log widget.
        $logPanel = [Panel]::new(1, 14, $this.Width - 2, $this.Height - 15, "Recent Log Entries")
        $logPanel.Style = $Global:ThemeEngine.GetStyle("Components.Panel")
        $this.AddChild($logPanel)
    }
    
    [void] OnEnter() {
        # Widgets automatically pull data on render, so OnEnter is simplified.
        # We simply request a redraw to ensure they update when the screen becomes active.
        $this.RequestRedraw()
    }

    # Input is now handled by the command palette (Ctrl+P), so this method is empty.
    # The screen itself doesn't need to handle any keys.
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) { 
        return $false 
    }
}
# --- END OF ORIGINAL FILE for screens\dashboard-screen\dashboard-screen.psm1 ---
```

**Rationale:** This new `DashboardScreen` embodies the component-based philosophy. The screen's only job is layout. All the logic for displaying upcoming tasks or statistics is encapsulated within the `UpcomingTasksWidget` and `StatsWidget` classes. This makes the dashboard easily extensible: adding a new widget is as simple as defining a new class and adding it to the screen's `Initialize` method.

---

#### **Step 3.2: Implement the `TaskFlowScreen` and `KanbanBoardComponent`**

**Action:** This is a completely new feature that replaces the old, simplistic `TaskListScreen`. We will create a `KanbanBoardComponent` that visually organizes tasks into columns by their status. This component will be hosted by the new `TaskFlowScreen`.

**Instruction:** **DELETE** the entire existing `screens\task-list-screen\task-list-screen.psm1` section from the monolith. **ADD** the following new file section in its place.

```powershell
# --- START OF ORIGINAL FILE for screens\task-flow-screen\task-flow-screen.psm1 ---
# ==============================================================================
# PMC Terminal v5 - Task Flow (Kanban) Screen
# Visual, interactive task board for managing workflow. This screen provides a
# more intuitive way to view and manage task progression than a simple list.
# ==============================================================================

# Define simple data models for the board's structure. These are view-models,
# not the core PmcTask model.
class KanbanCard { [string]$Id; [string]$Title; [string]$Priority; [object]$Data }
class KanbanColumn { [string]$Title; [System.Collections.Generic.List[KanbanCard]]$Cards }

# This is a complex, interactive component that renders a horizontally scrollable Kanban board.
class KanbanBoardComponent : ScrollablePanel {
    [KanbanColumn[]]$Columns
    [int]$SelectedColumn = 0
    [int]$SelectedCard = 0

    KanbanBoardComponent([string]$name) : base() {
        $this.Name = $name
        $this.Columns = @()
        $this.IsFocusable = $true
    }

    # Populates the component with data transformed from the DataManager.
    [void] SetData([PmcTask[]]$tasks) {
        $columns = @{
            "Pending" = [System.Collections.Generic.List[KanbanCard]]::new();
            "InProgress" = [System.Collections.Generic.List[KanbanCard]]::new();
            "Completed" = [System.Collections.Generic.List[KanbanCard]]::new();
            "Cancelled" = [System.Collections.Generic.List[KanbanCard]]::new();
        }

        foreach ($task in $tasks) {
            $card = [KanbanCard]@{ Id = $task.Id; Title = $task.Title; Priority = $task.Priority.ToString(); Data = $task }
            $statusString = $task.Status.ToString()
            if ($columns.ContainsKey($statusString)) {
                $columns[$statusString].Add($card)
            }
        }

        $kanbanColumns = @(
            [KanbanColumn]@{ Title="Pending"; Cards = $columns.Pending };
            [KanbanColumn]@{ Title="In Progress"; Cards = $columns.InProgress };
            [KanbanColumn]@{ Title="Completed"; Cards = $columns.Completed };
            [KanbanColumn]@{ Title="Cancelled"; Cards = $columns.Cancelled };
        )
        
        $this.Columns = $kanbanColumns
        $this.VirtualWidth = $this.Columns.Count * 31 # 30 for column width, 1 for margin
        $this.VirtualHeight = 30 # An arbitrary large virtual height
        $this.RequestRedraw()
    }
    
    [void] OnRender() {
        # This component renders to the virtual buffer provided by its parent ScrollablePanel class.
        $buffer = $this.GetVirtualBuffer()
        if ($null -eq $buffer) { return }
        $buffer.Clear()
        
        $colStyle = $Global:ThemeEngine.GetStyle("Components.Kanban.Column")
        $cardStyle = $Global:ThemeEngine.GetStyle("Components.Kanban.Card")
        $cardSelectedStyle = $Global:ThemeEngine.GetStyle("Components.Kanban.CardSelected")

        $xOffset = 0
        for ($c = 0; $c -lt $this.Columns.Count; $c++) {
            $column = $this.Columns[$c]
            # Draw the column container box.
            Write-TuiBox -Buffer $buffer -X $xOffset -Y 0 -Width 30 -Height ($this.VirtualHeight -1) -Title "$($column.Title) ($($column.Cards.Count))" -Style $colStyle

            $yOffset = 1
            for ($r = 0; $r -lt $column.Cards.Count; $r++) {
                if ($yOffset + 4 > $this.VirtualHeight) { break } # Don't draw past virtual height
                $card = $column.Cards[$r]
                
                # Determine the style based on focus and selection state.
                $styleToUse = if($c -eq $this.SelectedColumn -and $r -eq $this.SelectedCard -and $this.IsFocused) { $cardSelectedStyle } else { $cardStyle }
                
                # Draw the card as a smaller box within the column.
                $cardTitle = "$($card.Title) [$($card.Priority)]".PadRight(26).Substring(0, 26)
                Write-TuiBox -Buffer $buffer -X ($xOffset+1) -Y $yOffset -Width 28 -Height 3 -Title $cardTitle -Style $styleToUse
                $yOffset += 4
            }
            $xOffset += 31 # Move to the next column position.
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        $colCount = $this.Columns.Count
        if ($colCount -eq 0) { return $false }
        $cardCount = $this.Columns[$this.SelectedColumn].Cards.Count
        
        $navigated = $true
        switch ($keyInfo.Key) {
            ([ConsoleKey]::RightArrow) {
                if ($this.SelectedColumn < $colCount - 1) { $this.SelectedColumn++; $this.SelectedCard = 0 }
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this.SelectedColumn > 0) { $this.SelectedColumn--; $this.SelectedCard = 0 }
            }
            ([ConsoleKey]::DownArrow) {
                if ($cardCount > 0 -and $this.SelectedCard < $cardCount - 1) { $this.SelectedCard++ }
            }
            ([ConsoleKey]::UpArrow) {
                if ($cardCount > 0 -and $this.SelectedCard > 0) { $this.SelectedCard-- }
            }
            default { $navigated = $false }
        }
        
        if ($navigated) { $this.RequestRedraw(); return $true }
        
        # Pass unhandled keys (like PageUp/Down) to the parent ScrollablePanel for scrolling.
        return ([ScrollablePanel]$this).HandleInput($keyInfo)
    }
}

# The screen class is a simple host for the Kanban board.
class TaskFlowScreen : Screen {
    [KanbanBoardComponent]$kanbanBoard

    TaskFlowScreen([hashtable]$services) : base("TaskFlowScreen", $services) { }

    [void] Initialize() {
        $this.kanbanBoard = [KanbanBoardComponent]::new("TaskKanban")
        $this.AddChild($this.kanbanBoard)
        $this.kanbanBoard.Resize($this.Width, $this.Height)
        $this.kanbanBoard.HasBorder = $false # The screen is the main container.
    }
    
    [void] OnEnter() {
        # When the screen is entered, fetch fresh data and populate the component.
        $tasks = $this.Services.DataManager.GetTasks()
        $this.kanbanBoard.SetData($tasks)
        Set-ComponentFocus -Component $this.kanbanBoard
    }
}
# --- END OF ORIGINAL FILE for screens\task-flow-screen\task-flow-screen.psm1 ---
```

**Rationale:** The `TaskFlowScreen` and `KanbanBoardComponent` are a prime example of the new architecture's power.
1.  **Visual Interaction:** It provides a far more intuitive "at a glance" view of project status than a simple list.
2.  **Component Reusability:** The `KanbanBoardComponent` is self-contained. It could be reused on the dashboard as a smaller widget or in other screens with different data sources.
3.  **Inheritance:** It inherits from `ScrollablePanel`, gaining horizontal and vertical scrolling capabilities for free, without duplicating that logic.
4.  **Decoupling:** The screen's only job is to fetch the data and give it to the component. The component handles all rendering and interaction logic.

---

### **Pillar 3 Complete**

The application's core user-facing screens have been reborn. The static dashboard is now a dynamic, extensible widget container. The linear task list is now a visual, interactive Kanban board. The application is not just more feature-rich; its architecture is now fundamentally more modular, maintainable, and prepared for future expansion. The final pillar will solidify this by formalizing the separation of backend business logic from the UI.
Understood. We have rebuilt the user interface. Now, we will formalize the separation of concerns by creating dedicated, UI-agnostic services for business logic. This final pillar ensures that the application's "brain" is fully decoupled from its "face," making the entire system more robust, testable, and reusable.

---

### **Pillar 4: Decoupled Backend Services**

**Objective:** To extract business logic that has no direct UI representation into dedicated service classes. This plan will demonstrate the pattern by creating a `TimeSheetService` to handle time-tracking logic, which is currently mixed into other components or non-existent. We will then create a UI screen that is purely a consumer of this service.

---

#### **Step 4.1: Create the `TimeSheetService`**

**Action:** We will create a new `TimeSheetService` class. This service will contain all logic for starting and stopping timers against tasks and for calculating time summaries. It will interact with the `DataManager` but will have no knowledge of any UI components like screens or panels.

**Instruction:** **ADD** the following new section to the monolith, grouped with other service definitions.

```powershell
# --- START OF ORIGINAL FILE for services/timesheet-service.psm1 ---
class TimeSheetService {
    hidden [DataManager]$_dataManager

    TimeSheetService([DataManager]$dm) {
        if ($null -eq $dm) { throw [System.ArgumentNullException]::new("DataManager cannot be null.") }
        $this._dataManager = $dm
    }

    [void] StartTimer([PmcTask]$task) {
        if (-not $task) { throw "Task cannot be null." }
        $activeTimers = $this._dataManager._dataStore.ActiveTimers
        if ($activeTimers.ContainsKey($task.Id)) {
            Write-Log -Level Warning -Message "Timer for task $($task.Id) is already running."
            return
        }
        $activeTimers[$task.Id] = @{ StartTime = [datetime]::Now; ProjectKey = $task.ProjectKey }
        Write-Log -Level Info -Message "Started timer for task: $($task.Title)"
        # Publish a generic event that UI components can subscribe to.
        Publish-Event -EventName "Timers.Changed" -Data @{ TaskId = $task.Id; Status = "Started" }
    }

    [void] StopTimer([PmcTask]$task) {
        if (-not $task) { throw "Task cannot be null." }
        $activeTimers = $this._dataManager._dataStore.ActiveTimers
        if (-not $activeTimers.ContainsKey($task.Id)) { return }
        
        $timerData = $activeTimers[$task.Id]
        $endTime = [datetime]::Now
        $duration = ($endTime - $timerData.StartTime)
        
        # Add a new time entry to the data store.
        $this._dataManager._dataStore.time_entries.Add(@{
            EntryId = [Guid]::NewGuid().ToString()
            TaskId = $task.Id
            ProjectKey = $timerData.ProjectKey
            StartTime = $timerData.StartTime
            EndTime = $endTime
            DurationSeconds = $duration.TotalSeconds
        })
        
        [void]$activeTimers.Remove($task.Id)
        Write-Log -Level Info -Message "Stopped timer for task: $($task.Title). Duration: $($duration.ToString('hh\:mm\:ss'))"
        Publish-Event -EventName "Timers.Changed" -Data @{ TaskId = $task.Id; Status = "Stopped" }
    }

    # This method returns pure data, not formatted strings.
    [object[]] GetWeeklySummary() {
        $entries = $this._dataManager._dataStore.time_entries | Where-Object { $_.StartTime -ge (Get-Date).Date.AddDays(-7) }
        $summary = $entries | Group-Object ProjectKey | ForEach-Object {
            [PSCustomObject]@{
                Project = $_.Name
                TotalHours = [Math]::Round(($_.Group | Measure-Object DurationSeconds -Sum).Sum / 3600, 2)
            }
        }
        return $summary
    }

    # HARDENING: This service method returns raw data (a string). It does not
    # interact with the filesystem. The calling UI component is responsible for
    # handling the file I/O, which maintains a clean separation of concerns.
    [string] GetWeeklySummaryAsTsv() {
        $summaryData = $this.GetWeeklySummary()
        if ($summaryData.Count -eq 0) { return "" }
        
        # Convert the data to a TSV string in memory.
        return ($summaryData | ConvertTo-Csv -Delimiter "`t" -NoTypeInformation | Out-String)
    }
}

function Initialize-TimeSheetService {
    param([DataManager]$DataManager)
    return [TimeSheetService]::new($DataManager)
}
# --- END OF ORIGINAL FILE for services/timesheet-service.psm1 ---
```

**Rationale:** The `TimeSheetService` is a perfect example of a decoupled backend service. It encapsulates a specific domain of business logic (time tracking). It depends on another service (`DataManager`) for data persistence but knows nothing about how its data will be displayed. Its methods return pure data objects (`[object[]]`) or raw data (`[string]`), not formatted UI strings.

---

#### **Step 4.2: Create the `TimeSheetScreen` to Consume the Service**

**Action:** We will now create a new UI screen that is a pure consumer of the `TimeSheetService`. This screen's only job is to ask the service for data and display it in a table. We will also add a Command Palette action that uses the service to export data.

**Instruction:** **ADD** the following new file section to the monolith.

```powershell
# --- START OF ORIGINAL FILE for screens/timesheet-screen.psm1 ---
class TimeSheetScreen : Screen {
    [Table]$summaryTable

    TimeSheetScreen([hashtable]$services) : base("TimeSheetScreen", $services) {}

    [void] Initialize() {
        $this.summaryTable = New-TuiTable -Props @{ 
            Name = "TimeSheetSummary"
            Width = $this.Width
            Height = $this.Height
            ShowHeader = $true
            ShowBorder = $true
        }
        $this.summaryTable.Title = "Weekly Time Summary by Project"
        
        $this.summaryTable.SetColumns(@(
            [TableColumn]::new('Project', 'Project', 40),
            [TableColumn]::new('TotalHours', 'Total Hours (This Week)', 25)
        ))
        $this.AddChild($this.summaryTable)
    }

    [void] OnEnter() {
        # The screen asks the service for data and passes it to the UI component.
        # The screen itself does not understand the data's structure.
        $summary = $this.Services.TimeSheetService.GetWeeklySummary()
        $this.summaryTable.SetData($summary)
        $this.RequestRedraw()
    }
}

# Add an action to the Command Palette that uses the TimeSheetService.
[Action("TimeSheet: Export Weekly Summary to Desktop", Group="TimeSheet")]
function Export-WeeklyTimeSheet {
    # This action is pure logic; it knows nothing about the current screen.
    $timeSheetService = $Global:Services.TimeSheetService
    
    $tsvContent = $timeSheetService.GetWeeklySummaryAsTsv()
    
    if ([string]::IsNullOrWhiteSpace($tsvContent)) {
        Show-AlertDialog -Title "Export" -Message "No data available to export for the past 7 days."
        return
    }

    try {
        $desktopPath = [Environment]::GetFolderPath('Desktop')
        $fileName = "Axiom-TimeSheet-$(Get-Date -Format 'yyyyMMdd').tsv"
        $filePath = Join-Path $desktopPath $fileName
        
        Set-Content -Path $filePath -Value $tsvContent -Encoding UTF8
        
        Show-AlertDialog -Title "Export Complete" -Message "Weekly summary has been exported to:`n$filePath"
    } catch {
        Write-Log -Level Error -Message "Failed to export timesheet: $_"
        Show-AlertDialog -Title "Export Error" -Message "Could not write the export file to the desktop.`nPlease check permissions."
    }
}
# --- END OF ORIGINAL FILE for screens/timesheet-screen.psm1 ---
```

**Rationale:** This demonstrates the complete pattern. The `TimeSheetScreen` is "dumb"â€”it just hosts a `Table` component. In its `OnEnter` method, it calls the `TimeSheetService` to get data and hands that data to the table. The `Export-WeeklyTimeSheet` action also uses the service, gets back raw TSV data as a string, and is responsible for the UI-related task of writing it to a file and showing a confirmation dialog. The service remains pure and unaware of the filesystem or dialogs.

---

#### **Step 4.3: Final Integration in the Startup Logic**

**Action:** We must initialize our new service and register our new screens and routes in the main application startup block. This makes them "live" in the application.

**Instruction:** **MODIFY** the final `try/catch` block at the end of `axiom.txt` to include all new services and screens from Pillars 2, 3, and 4.

```powershell
# In axiom.txt, near the end of the file

try {
    Write-Host "`n=== PMC Terminal v5 - Phoenix Edition ===" -ForegroundColor Cyan
    
    # 1. Initialize core services
    # ... (Logger, EventSystem, ThemeEngine, DialogSystem remain the same) ...

    # 2. Create the service container
    $services = @{
        ThemeEngine = $global:ThemeEngine
    }
    
    # 3. Initialize services that depend on others
    $services.DataManager = Initialize-DataManager
    # NEW: Initialize the new services and add them to the container.
    $services.TimeSheetService = Initialize-TimeSheetService -DataManager $services.DataManager
    $services.ActionService = Initialize-ActionService 
    $services.KeybindingService = New-KeybindingService
    
    # 4. NavigationService needs the full $services container
    $services.Navigation = Initialize-NavigationService -Services $services
    
    # 5. Register ALL screen classes with the navigation factory
    $nav = $services.Navigation
    $nav.RegisterScreenClass("DashboardScreen", [DashboardScreen])
    $nav.RegisterScreenClass("TaskFlowScreen", [TaskFlowScreen])   # NEW from Pillar 3
    $nav.RegisterScreenClass("ExplorerScreen", [ExplorerScreen])   # NEW from Pillar 2
    $nav.RegisterScreenClass("TimeSheetScreen", [TimeSheetScreen]) # NEW from Pillar 4
    
    Write-Host "All services initialized!" -ForegroundColor Green
    
    # ... (logo can remain) ...
    
    # 6. Initialize TUI Engine
    Initialize-TuiEngine
    
    # 7. Add routes for all the new screens
    # The old /tasks route is now pointed to the new TaskFlowScreen
    $nav.RouteMap["/tasks"] = "TaskFlowScreen" 
    $nav.RouteMap["/explorer"] = "ExplorerScreen"
    $nav.RouteMap["/timesheet"] = "TimeSheetScreen"
    
    # 8. Start the application by navigating to the root path
    Write-Host "Starting main application loop..." -ForegroundColor Yellow
    # GoTo now correctly pushes the initial DashboardScreen and the loop takes over.
    $services.Navigation.GoTo("/") 
    Start-TuiLoop
    
} catch {
    # ... (error handling remains the same) ...
} finally {
    # ... (cleanup remains the same) ...
}
```

---

### **Upgrade Complete**

The plan is executed. We have systematically replaced every major subsystem of the original application.

-   **Pillar 1:** Replaced the rendering core with the **Phoenix Engine**, enabling Truecolor, themeability, and massive performance gains through differential rendering.
-   **Pillar 2:** Replaced static menus with a dynamic **Command Palette** and integrated the file browser as a first-class **ExplorerScreen**.
-   **Pillar 3:** Replaced static screens with a component-based **DashboardScreen** and a visual **TaskFlowScreen**, revolutionizing the user workspace.
-   **Pillar 4:** Formalized the separation of concerns by creating a UI-agnostic **TimeSheetService**, ensuring the application logic is modular, testable, and reusable.

The original script has been transformed into Axiom-Phoenix: a modern, powerful, and maintainable PowerShell TUI framework. The "ships" have been burned. There is only the new shore.
