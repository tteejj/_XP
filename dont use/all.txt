# ==================================================================================
# PMC Terminal v5 - MONOLITHIC SCRIPT (Generated by Create-Monolith.ps1)
# DO NOT EDIT THIS FILE DIRECTLY.
# ==================================================================================
#Requires -Version 7.0
using namespace System.Text
using namespace System.Management.Automation
using namespace System
param(
    [switch]$Debug,
    [switch]$SkipLogo
)
# HARDENING: Check if the type already exists before attempting to add it.
# This prevents terminating errors when re-running the script during development.
# Define the ActionAttribute class using native PowerShell syntax.
# This is a parse-time construct, making the attribute available to the parser
# immediately as it reads the script file, resolving the ParserError.


# Global script settings
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"


# --- START OF ORIGINAL FILE: modules\logger\logger.psm1 ---
# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------
$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------
function ConvertTo-SerializableObject {
    param([object]$Object)
    if ($null -eq $Object) { return $null }
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'
    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)
        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) { [void]$visited.Add($InputObject) }
        switch ($InputObject.GetType().Name) {
            'Hashtable' { $r = @{}; foreach ($k in $InputObject.Keys) { try { $r[$k] = Convert-Internal $InputObject[$k] ($Depth+1) } catch { $r[$k] = "<Err>" } }; return $r }
            'PSCustomObject' { $r = @{}; foreach ($p in $InputObject.PSObject.Properties) { try { if ($p.MemberType -ne 'ScriptMethod') { $r[$p.Name] = Convert-Internal $p.Value ($Depth+1) } } catch { $r[$p.Name] = "<Err>" } }; return $r }
            'Object[]' { $r = @(); for ($i=0; $i -lt [Math]::Min($InputObject.Count,10); $i++) { try { $r += Convert-Internal $InputObject[$i] ($Depth+1) } catch { $r += "<Err>" } }; if($InputObject.Count -gt 10) { $r += "<...>" }; return $r }
            default { try { if ($InputObject -is [ValueType] -or $InputObject -is [string] -or $InputObject -is [datetime]) { return $InputObject } else { return $InputObject.ToString() } } catch { return "<Err>" } }
        }
    }
    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------
function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Debug"
    )
    if ([string]::IsNullOrWhiteSpace($LogDirectory) -or [string]::IsNullOrWhiteSpace($LogFileName)) { Write-Warning "Invalid logger parameters."; return }
    try {
        if (-not (Test-Path $LogDirectory)) { New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null }
        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true
        Write-Log -Level Info -Message "Logger initialized" -Data @{ LogPath = $script:LogPath; PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS; PID = $PID } -Force
    } catch { Write-Warning "Failed to initialize logger: $_"; $script:LogInitialized = $false }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")] [string]$Level = "Info",
        [Parameter(Mandatory)] [string]$Message,
        [object]$Data,
        [switch]$Force
    )
    if (-not $script:LogInitialized -and -not $Force) { return }
    $levelPriority = @{ Debug=0; Trace=0; Verbose=1; Info=2; Warning=3; Error=4; Fatal=5 }
    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }
    try {
        $caller = (Get-PSCallStack)[1]
        $logContext = @{
            Timestamp = (Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"); Level = $Level; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
            CallDepth = $script:CallDepth; Message = $Message; Caller = @{ Command = $caller.Command; Location = $caller.Location; ScriptName = $caller.ScriptName; LineNumber = $caller.ScriptLineNumber }
        }
        if ($PSBoundParameters.ContainsKey('Data')) { $logContext.UserData = if ($Data -is [Exception]) { @{ Type="Exception"; Message=$Data.Message; StackTrace=$Data.StackTrace; InnerException=$Data.InnerException.Message } } else { ConvertTo-SerializableObject -Object $Data } }
        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) { "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)" } else { $caller.Command }
        $logEntry = "$($logContext.Timestamp) [$($Level.PadRight(7))] $indent [$callerInfo] $Message"
        if ($PSBoundParameters.ContainsKey('Data')) { $logEntry += if ($Data -is [Exception]) { "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)" } else { try { "`n${indent}  Data: $(ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue)" } catch { "`n${indent}  Data: $($Data.ToString())" } } }
        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) { $script:LogQueue.RemoveRange(0, 1000) }
        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) { Move-Item $script:LogPath ($script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log") -Force }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch { Write-Host "LOG WRITE FAILED: $logEntry`nError: $_" -ForegroundColor Yellow }
        }
        if ($Level -in @('Error', 'Fatal', 'Warning')) { Write-Host $logEntry -ForegroundColor ($Level -in @('Error', 'Fatal') ? 'Red' : 'Yellow') }
    } catch { try { $errorEntry = "$(Get-Date -Format 'o') [LOGGER ERROR] Failed to log: $_"; if ($script:LogPath) { Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8 }; Write-Host $errorEntry -ForegroundColor Red } catch { Write-Host "CRITICAL: Logger failed: $_" -ForegroundColor Red } }
}

function Trace-FunctionEntry { [CmdletBinding()] param([string]$FunctionName, [object]$Parameters); if (-not $script:TraceAllCalls) { return }; $script:CallDepth++; Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{ Parameters=$Parameters; Action="FunctionEntry" } }
function Trace-FunctionExit { [CmdletBinding()] param([string]$FunctionName, [object]$ReturnValue, [switch]$WithError); if (-not $script:TraceAllCalls) { return }; Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{ ReturnValue=$ReturnValue; Action=($WithError ? "FunctionExitWithError" : "FunctionExit"); HasError=$WithError.IsPresent }; $script:CallDepth = [Math]::Max(0, $script:CallDepth - 1) }
function Trace-Step { [CmdletBinding()] param([string]$StepName, [object]$StepData, [string]$Module); $caller = (Get-PSCallStack)[1]; $moduleInfo = $Module ?? ($caller.ScriptName ? [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) : "Unknown"); Write-Log -Level Debug -Message "STEP: $StepName" -Data @{ StepData=$StepData; Module=$moduleInfo; Action="Step" } }
function Trace-StateChange { [CmdletBinding()] param([string]$StateType, [object]$OldValue, [object]$NewValue, [string]$PropertyPath); Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{ StateType=$StateType; PropertyPath=$PropertyPath; OldValue=$OldValue; NewValue=$NewValue; Action="StateChange" } }
function Trace-ComponentLifecycle { [CmdletBinding()] param([string]$ComponentType, [string]$ComponentId, [ValidateSet('Create','Initialize','Render','Update','Destroy')] [string]$Phase, [object]$ComponentData); Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{ ComponentType=$ComponentType; ComponentId=$ComponentId; Phase=$Phase; ComponentData=$ComponentData; Action="ComponentLifecycle" } }
function Trace-ServiceCall { [CmdletBinding()] param([string]$ServiceName, [string]$MethodName, [object]$Parameters, [object]$Result, [switch]$IsError); Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{ ServiceName=$ServiceName; MethodName=$MethodName; Parameters=$Parameters; Result=$Result; Action=($IsError ? "ServiceCallError" : "ServiceCall"); IsError=$IsError.IsPresent } }

function Get-LogEntries {
    [CmdletBinding()]
    param([int]$Count = 100, [string]$Level, [string]$Module, [string]$Action)
    try {
        $entries = $script:LogQueue.ToArray()
        if ($Level) { $entries = $entries | Where-Object { $_.Level -eq $Level } }
        if ($Module) { $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") } }
        if ($Action) { $entries = $entries | Where-Object { $_.UserData.Action -eq $Action } }
        return $entries | Select-Object -Last $Count
    } catch { Write-Warning "Error getting log entries: $_"; return @() }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)
    try {
        $callStack = Get-PSCallStack; $trace = @()
        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { $call = $callStack[$i]; $trace += @{ Level=$i-1; Command=$call.Command; Location=$call.Location; ScriptName=$call.ScriptName; LineNumber=$call.ScriptLineNumber } }
        return $trace
    } catch { Write-Warning "Error getting call trace: $_"; return @() }
}

function Clear-LogQueue { try { $script:LogQueue.Clear(); Write-Log -Level Info -Message "In-memory log queue cleared" } catch { Write-Warning "Error clearing log queue: $_" } }
function Set-LogLevel { [CmdletBinding()] param([Parameter(Mandatory)] [ValidateSet("Debug","Verbose","Info","Warning","Error","Fatal","Trace")] [string]$Level); try { $oldLevel = $script:LogLevel; $script:LogLevel = $Level; Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force } catch { Write-Warning "Error setting log level to '$Level': $_" } }
function Enable-CallTracing { $script:TraceAllCalls = $true; Write-Log -Level Info -Message "Call tracing enabled" -Force }
function Disable-CallTracing { $script:TraceAllCalls = $false; Write-Log -Level Info -Message "Call tracing disabled" -Force }
function Get-LogPath { return $script:LogPath }

function Get-LogStatistics {
    [CmdletBinding()]
    param()
    try {
        $stats = [PSCustomObject]@{ TotalEntries=$script:LogQueue.Count; LogPath=$script:LogPath; LogLevel=$script:LogLevel; CallTracingEnabled=$script:TraceAllCalls; LogFileSize=($script:LogPath -and (Test-Path $script:LogPath) ? (Get-Item $script:LogPath).Length : 0); EntriesByLevel=@{}; EntriesByModule=@{}; EntriesByAction=@{} }
        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level; if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level]=0 }; $stats.EntriesByLevel[$level]++
            if ($entry.Caller.ScriptName) { $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName); if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module]=0 }; $stats.EntriesByModule[$module]++ }
            if ($entry.UserData.Action) { $action = $entry.UserData.Action; if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action]=0 }; $stats.EntriesByAction[$action]++ }
        }
        return $stats
    } catch { Write-Warning "Error getting log statistics: $_"; return [PSCustomObject]@{} }
}
# --- END OF ORIGINAL FILE: modules\logger\logger.psm1 ---


# --- START OF ORIGINAL FILE: modules\exceptions\exceptions.psm1 ---
# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

try {
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException) {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
    }
} catch {
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}

# ------------------------------------------------------------------------------
# Error Handling Wrapper
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Component,
        
        [Parameter(Mandatory)]
        [string]$Context,
        
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock
    )
    
    try {
        return & $ScriptBlock
    }
    catch {
        Write-Log -Level Error -Message "$Context failed: $_" -Component $Component
        throw
    }
}

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

function _Identify-HeliosComponent {
    param([System.Management.Automation.ErrorRecord]$ErrorRecord)
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName ?? (Get-PSCallStack | Where-Object ScriptName | Select-Object -First 1).ScriptName
        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        $componentMap = @{
            'tui-engine' = 'TUI Engine'; 'navigation' = 'Navigation Service'; 'keybindings' = 'Keybinding Service'
            'task-service' = 'Task Service'; 'helios-components' = 'Helios UI Components'; 'helios-panels' = 'Helios UI Panels'
            'dashboard-screen' = 'Dashboard Screen'; 'task-screen' = 'Task Screen'; 'exceptions' = 'Exception Module'
            'logger' = 'Logger Module'; 'Start-PMCTerminal' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") { return $componentMap[$pattern] }
        }
        return "Unknown ($fileName)"
    } catch { return "Component Identification Failed" }
}

function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp = Get-Date -Format "o"; Summary = $ErrorRecord.Exception.Message; Type = $ErrorRecord.Exception.GetType().FullName
            Category = $ErrorRecord.CategoryInfo.Category.ToString(); TargetObject = $ErrorRecord.TargetObject
            ScriptName = $ErrorRecord.InvocationInfo.ScriptName; LineNumber = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line = $ErrorRecord.InvocationInfo.Line; PositionMessage = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace = $ErrorRecord.Exception.StackTrace; InnerExceptions = @(); AdditionalContext = $AdditionalContext
            SystemContext = @{
                ProcessId = $PID; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{ Message = $innerEx.Message; Type = $innerEx.GetType().FullName; StackTrace = $innerEx.StackTrace }
            $innerEx = $innerEx.InnerException
        }
        return $errorInfo
    } catch {
        return [PSCustomObject]@{ Timestamp = Get-Date -Format "o"; Summary = "CRITICAL: Error analysis failed."; OriginalError = $ErrorRecord.Exception.Message; AnalysisError = $_.Exception.Message; Type = "ErrorAnalysisFailure" }
    }
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$Component,
        [Parameter(Mandatory)] [string]$Context,
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [hashtable]$AdditionalData = @{}
    )

    if (-not $ScriptBlock) { throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null." }
    $Component = [string]::IsNullOrWhiteSpace($Component) ? "Unknown Component" : $Component
    $Context = [string]::IsNullOrWhiteSpace($Context) ? "Unknown Operation" : $Context

    try {
        return (& $ScriptBlock)
    }
    catch {
        $originalErrorRecord = $_
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = ($Component -ne "Unknown Component") ? $Component : $identifiedComponent

        $errorContext = @{ Operation = $Context }
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)" -Data $detailedError
        }

        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) { $script:ErrorHistory.RemoveAt(0) }

        $contextHashtable = @{
            Operation = $Context; Timestamp = $detailedError.Timestamp; LineNumber = $detailedError.LineNumber
            ScriptName = $detailedError.ScriptName ?? "Unknown"
        }
        
        foreach ($key in $AdditionalData.Keys) {
            $value = $AdditionalData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) { $contextHashtable[$key] = $value }
        }
        
        $heliosException = New-Object Helios.HeliosException($originalErrorRecord.Exception.Message, $finalComponent, $contextHashtable, $originalErrorRecord.Exception)
        throw $heliosException
    }
}

function Get-ErrorHistory {
    [CmdletBinding()]
    param([int]$Count = 25)
    
    $total = $script:ErrorHistory.Count
    if ($Count -ge $total) { return $script:ErrorHistory }
    $start = $total - $Count
    return $script:ErrorHistory.GetRange($start, $Count)
}
# --- END OF ORIGINAL FILE: modules\exceptions\exceptions.psm1 ---




# --- START OF ORIGINAL FILE: modules\models\models.psm1 ---
# ==============================================================================
# PMC Terminal v5 - Core Data Models
# Defines all core business entity classes with built-in validation.
# ==============================================================================



#region Enums

enum TaskStatus { Pending; InProgress; Completed; Cancelled }
enum TaskPriority { Low; Medium; High }
enum BillingType { Billable; NonBillable }

#endregion

#region Base Validation Class
class ValidationBase {
    static [void] ValidateNotEmpty([string]$value, [string]$parameterName) {
        if ([string]::IsNullOrWhiteSpace($value)) {
            throw [System.ArgumentException]::new("Parameter '$($parameterName)' cannot be null or empty.")
        }
    }
}
#endregion

#region Core Model Classes

class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()
    [string]$Title
    [string]$Description
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [string]$ProjectKey = "General"
    [string]$Category
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now
    [Nullable[datetime]]$DueDate
    [string[]]$Tags = @()
    [int]$Progress = 0
    [bool]$Completed = $false

    PmcTask() {}
    PmcTask([string]$title) { [ValidationBase]::ValidateNotEmpty($title, "Title"); $this.Title = $title }
    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title; $this.Description = $description; $this.Priority = $priority
        $this.ProjectKey = $projectKey; $this.Category = $projectKey
    }
    PmcTask([string]$title, [string]$projectKey, [string]$priority, [datetime]$dueDate, [string]$status) {
        $this.Title = $title
        $this.ProjectKey = $projectKey
        $this.Priority = [TaskPriority]::$priority
        $this.DueDate = $dueDate
        $this.Status = [TaskStatus]::$status
    }

    [void] Complete() {
        $this.Status = [TaskStatus]::Completed; $this.Completed = $true
        $this.Progress = 100; $this.UpdatedAt = [datetime]::Now
    }

    [void] UpdateProgress([int]$newProgress) {
        if ($newProgress -lt 0 -or $newProgress -gt 100) { throw "Progress must be between 0 and 100." }
        $this.Progress = $newProgress
        $this.Status = $newProgress -eq 100 ? [TaskStatus]::Completed : $newProgress -gt 0 ? [TaskStatus]::InProgress : [TaskStatus]::Pending
        $this.Completed = ($this.Status -eq [TaskStatus]::Completed)
        $this.UpdatedAt = [datetime]::Now
    }
    
    [string] GetDueDateString() { return $this.DueDate ? $this.DueDate.Value.ToString("yyyy-MM-dd") : "N/A" }

    [hashtable] ToLegacyFormat() {
        return @{
            id = $this.Id; title = $this.Title; description = $this.Description
            completed = $this.Completed; priority = $this.Priority.ToString().ToLower()
            project = $this.ProjectKey; due_date = $this.DueDate ? $this.GetDueDateString() : $null
            created_at = $this.CreatedAt.ToString("o"); updated_at = $this.UpdatedAt.ToString("o")
        }
    }

    static [PmcTask] FromLegacyFormat([hashtable]$legacyData) {
        $task = [PmcTask]::new()
        $task.Id = $legacyData.id ?? $task.Id
        $task.Title = $legacyData.title
        $task.Description = $legacyData.description
        if ($legacyData.priority) { try { $task.Priority = [TaskPriority]::$($legacyData.priority) } catch {} }
        $task.ProjectKey = $legacyData.project ?? $legacyData.Category ?? "General"
        $task.Category = $task.ProjectKey
        if ($legacyData.created_at) { try { $task.CreatedAt = [datetime]::Parse($legacyData.created_at) } catch {} }
        if ($legacyData.updated_at) { try { $task.UpdatedAt = [datetime]::Parse($legacyData.updated_at) } catch {} }
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") { try { $task.DueDate = [datetime]::Parse($legacyData.due_date) } catch {} }
        if ($legacyData.completed -is [bool] -and $legacyData.completed) { $task.Complete() }
        return $task
    }
}

class PmcProject : ValidationBase {
    [string]$Key = ([Guid]::NewGuid().ToString().Split('-')[0]).ToUpper()
    [string]$Name
    [string]$Client
    [BillingType]$BillingType = [BillingType]::NonBillable
    [double]$Rate = 0.0
    [double]$Budget = 0.0
    [bool]$Active = $true
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now

    PmcProject() {}
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key"); [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key; $this.Name = $name
    }
    PmcProject([string]$name, [string]$description) {
        $this.Name = $name
    }

    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key; Name = $this.Name; Client = $this.Client
            BillingType = $this.BillingType.ToString(); Rate = $this.Rate; Budget = $this.Budget
            Active = $this.Active; CreatedAt = $this.CreatedAt.ToString("o")
        }
    }

    static [PmcProject] FromLegacyFormat([hashtable]$legacyData) {
        $project = [PmcProject]::new()
        $project.Key = $legacyData.Key ?? $project.Key
        $project.Name = $legacyData.Name
        $project.Client = $legacyData.Client
        if ($legacyData.Rate) { $project.Rate = [double]$legacyData.Rate }
        if ($legacyData.Budget) { $project.Budget = [double]$legacyData.Budget }
        if ($legacyData.Active -is [bool]) { $project.Active = $legacyData.Active }
        if ($legacyData.BillingType) { try { $project.BillingType = [BillingType]::$($legacyData.BillingType) } catch {} }
        if ($legacyData.CreatedAt) { try { $project.CreatedAt = [datetime]::Parse($legacyData.CreatedAt) } catch {} }
        $project.UpdatedAt = $project.CreatedAt
        return $project
    }
}

#endregion

# AI: Export everything including enums for PowerShell 7+
# --- END OF ORIGINAL FILE: modules\models\models.psm1 ---


# --- START OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---
# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations
# CORRECTED ORDERING: TuiAnsiHelper is defined BEFORE TuiCell to resolve parse-time dependency.



# In components\tui-primitives\tui-primitives.psm1

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    # Helper to convert a Hex string like "#FF8700" to an RGB hashtable
    static [hashtable] HexToRgb([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor) -or -not $hexColor.StartsWith("#") -or $hexColor.Length -ne 7) {
            return $null # Return null for invalid format or transparency
        }
        try {
            # Use Convert with base 16 to parse hex components. This is fast and robust.
            return @{
                R = [System.Convert]::ToInt32($hexColor.Substring(1, 2), 16)
                G = [System.Convert]::ToInt32($hexColor.Substring(3, 2), 16)
                B = [System.Convert]::ToInt32($hexColor.Substring(5, 2), 16)
            }
        } catch {
            Write-Log -Level Warning -Message "Failed to parse hex color: $hexColor. Returning null."
            return $null # Return null if parsing fails
        }
    }

    # The new core method to generate a full ANSI sequence for Truecolor and styling.
    static [string] GetAnsiSequence([string]$fgHex, [string]$bgHex, [hashtable]$attributes) {
        $sequences = [System.Collections.Generic.List[string]]::new()

        # Foreground color (Truecolor - SGR 38;2)
        if ($fgHex) {
            $rgb = [TuiAnsiHelper]::HexToRgb($fgHex)
            if ($rgb) {
                $sequences.Add("38;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Background color (Truecolor - SGR 48;2)
        if ($bgHex) {
            $rgb = [TuiAnsiHelper]::HexToRgb($bgHex)
            if ($rgb) {
                $sequences.Add("48;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Style attributes
        if ($attributes) {
            if ($attributes.Bold) { $sequences.Add("1") }
            if ($attributes.Italic) { $sequences.Add("3") }
            if ($attributes.Underline) { $sequences.Add("4") }
            if ($attributes.Strikethrough) { $sequences.Add("9") }
        }

        # If no styles, return empty string. Otherwise, build the full escape sequence.
        if ($sequences.Count -eq 0) { return "" }
        return "`e[$($sequences -join ';')m"
    }

    # A single, universal reset sequence (SGR 0)
    static [string] Reset() {
        return "`e[0m"
    }
}
#endregion

# In components\tui-primitives\tui-primitives.psm1
class TuiCell {
    [char] $Char = ' '
    
    # --- HARDENING: Resilient Property Setters ---
    hidden [string] $_foregroundColor = "#C0C0C0"
    hidden [string] $_backgroundColor = $null

    [string] get_ForegroundColor() { return $this._foregroundColor }
    [void] set_ForegroundColor([string]$value) {
        # If the value is valid, set it. Otherwise, log and keep the default.
        if ($value -match '^#[0-9A-Fa-f]{6}$') {
            $this._foregroundColor = $value
        } elseif ($null -ne $value) {
            Write-Log -Level Warning -Message "Invalid foreground color format: '$value'. Using last known value."
        }
    }

    [string] get_BackgroundColor() { return $this._backgroundColor }
    [void] set_BackgroundColor([string]$value) {
        # Allow null for transparency.
        if ($null -eq $value) {
            $this._backgroundColor = $null
        } elseif ($value -match '^#[0-9A-Fa-f]{6}$') {
            $this._backgroundColor = $value
        } else {
            Write-Log -Level Warning -Message "Invalid background color format: '$value'. Using last known value."
        }
    }
    # --- END HARDENING ---

    [bool] $Bold = $false; [bool] $Underline = $false; [bool] $Italic = $false; [bool] $Strikethrough = $false
    [int] $ZIndex = 0; [object] $Metadata = $null

    TuiCell() {}
    TuiCell([char]$char) { $this.Char = $char }

    TuiCell([char]$char, [string]$fg, [string]$bg, [bool]$bold=$false, [bool]$italic=$false, [bool]$underline=$false, [bool]$strikethrough=$false) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold; $this.Italic = $italic; $this.Underline = $underline; $this.Strikethrough = $strikethrough
    }
    
    # ... (Copy constructor and DiffersFrom must be updated to use the new properties) ...
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char; $this.ForegroundColor = $other.ForegroundColor; $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold; $this.Underline = $other.Underline; $this.Italic = $other.Italic; $this.Strikethrough = $other.Strikethrough
            $this.ZIndex = $other.ZIndex; $this.Metadata = $other.Metadata
        }
    }

    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or $this.ForegroundColor -ne $other.ForegroundColor -or $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or $this.Underline -ne $other.Underline -or $this.Italic -ne $other.Italic -or $this.Strikethrough -ne $other.Strikethrough)
    }
}

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

# In components\tui-primitives\tui-primitives.psm1

function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        # MODIFIED: A single -Style parameter replaces all individual style flags.
        [hashtable]$Style = @{} 
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }

    # Extract properties from the style object, providing safe defaults using the null-coalescing operator.
    # This makes the function resilient to incomplete style definitions.
    $fg = $Style.FG ?? "#C0C0C0"
    $bg = $Style.BG ?? $null
    $bold = [bool]($Style.Bold ?? $false)
    $italic = [bool]($Style.Italic ?? $false)
    $underline = [bool]($Style.Underline ?? $false)
    $strikethrough = [bool]($Style.Strikethrough ?? $false)

    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0 -and $Y -ge 0 -and $Y -lt $Buffer.Height) {
            # Use the powerful new TuiCell constructor with all attributes.
            $charCell = [TuiCell]::new($char, $fg, $bg, $bold, $italic, $underline, $strikethrough)
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$Title = "",
        # MODIFIED: The -Style parameter now drives all visual aspects of the box.
        [hashtable]$Style = @{}
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }

    # Extract properties from the style object with safe fallbacks.
    $borderStyleName = $Style.BorderStyle ?? "Single"
    $borderColor = $Style.BorderFG ?? "#808080" # Default border color: medium gray
    $bgColor = $Style.BG ?? $null               # Default background: transparent
    $titleColor = $Style.TitleFG ?? $borderColor # Title defaults to border color if not specified.
    $titleStyleOverrides = $Style.TitleStyle ?? @{} # Allow specific overrides for title, e.g., Bold = $true

    $borders = Get-TuiBorderChars -Style $borderStyleName
    
    # Define style objects for child calls to Write-TuiText.
    $borderStyle = @{ FG = $borderColor; BG = $bgColor }
    $titleStyle = @{ FG = $titleColor; BG = $bgColor }
    # Merge title overrides
    foreach($key in $titleStyleOverrides.Keys) { $titleStyle[$key] = $titleStyleOverrides[$key] }
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -Style $borderStyle
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -lt ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -Style $titleStyle
        }
    }
    
    # Side borders and fill
    if ($Height -gt 1) {
        $fillNeeded = ($bgColor -ne $null)
        $fillText = if ($fillNeeded) { ' ' * ($Width - 2) } else { '' }
        $fillStyle = @{ BG = $bgColor }

        for ($i = 1; $i -lt ($Height - 1); $i++) {
            $currentY = $Y + $i
            if ($currentY -ge 0 -and $currentY -lt $Buffer.Height) {
                Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -Style $borderStyle
                if ($fillNeeded) { Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -Style $fillStyle }
                Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -Style $borderStyle
            }
        }
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomY = $Y + $Height - 1
        if ($bottomY -ge 0 -and $bottomY -lt $Buffer.Height) {
            $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
            Write-TuiText -Buffer $Buffer -X $X -Y $bottomY -Text $bottomLine -Style $borderStyle
        }
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all functions
# --- END OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---


# --- START OF ORIGINAL FILE: modules\event-system\event-system.psm1 ---
# Event System Module
# Provides pub/sub event functionality for decoupled communication

# AI: FIX - Corrected relative paths for all dependencies.



$script:EventHandlers = @{}
$script:EventHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxEventHistory = 100

function Initialize-EventSystem {
    <# .SYNOPSIS Initializes the event system for the application #>
    Invoke-WithErrorHandling -Component "EventSystem.Initialize" -Context "Initializing event system" -ScriptBlock {
        $script:EventHandlers = @{}
        $script:EventHistory = [System.Collections.Generic.List[object]]::new()
        Write-Verbose "Event system initialized"
    }
}

function Publish-Event {
    <#
    .SYNOPSIS Publishes an event to all registered handlers
    .PARAMETER EventName The name of the event to publish
    .PARAMETER Data Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter()] [hashtable]$Data = @{}
    )
    Invoke-WithErrorHandling -Component "EventSystem.PublishEvent" -Context "Publishing event '$EventName'" -ScriptBlock {
        $eventRecord = @{ EventName = $EventName; Data = $Data; Timestamp = Get-Date }
        
        $script:EventHistory.Add($eventRecord)
        if ($script:EventHistory.Count -gt $script:MaxEventHistory) { $script:EventHistory.RemoveAt(0) }
        
        if ($script:EventHandlers.ContainsKey($EventName)) {
            foreach ($handler in $script:EventHandlers[$EventName]) {
                try {
                    $eventData = @{ EventName = $EventName; Data = $Data; Timestamp = $eventRecord.Timestamp }
                    & $handler.ScriptBlock -EventData $eventData
                } catch {
                    Write-Log -Level Warning -Message "Error in event handler for '$EventName' (ID: $($handler.HandlerId)): $_"
                }
            }
        }
        Write-Verbose "Published event: $EventName"
    } -AdditionalData @{ EventName = $EventName; EventData = $Data }
}

function Subscribe-Event {
    <#
    .SYNOPSIS Subscribes to an event with a handler
    .PARAMETER EventName The name of the event to subscribe to
    .PARAMETER Handler The script block to execute
    .PARAMETER HandlerId Optional unique identifier for the handler
    .PARAMETER Source Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter(Mandatory)] [scriptblock]$Handler,
        [Parameter()] [string]$HandlerId = [Guid]::NewGuid().ToString(),
        [Parameter()] [string]$Source
    )
    return Invoke-WithErrorHandling -Component "EventSystem.SubscribeEvent" -Context "Subscribing to event '$EventName'" -ScriptBlock {
        if (-not $script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers[$EventName] = @() }
        
        $handlerInfo = @{ HandlerId = $HandlerId; ScriptBlock = $Handler; SubscribedAt = Get-Date; Source = $Source }
        $script:EventHandlers[$EventName] += $handlerInfo
        
        Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
        return $HandlerId
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId; Source = $Source }
}

function Unsubscribe-Event {
    <#
    .SYNOPSIS Unsubscribes from an event
    .PARAMETER EventName The name of the event (optional if HandlerId is provided)
    .PARAMETER HandlerId The unique identifier of the handler to remove
    #>
    param(
        [Parameter()] [string]$EventName,
        [Parameter(Mandatory)] [string]$HandlerId
    )
    Invoke-WithErrorHandling -Component "EventSystem.UnsubscribeEvent" -Context "Unsubscribing from event '$EventName' (Handler: $HandlerId)" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($script:EventHandlers[$EventName].Count -eq 0) { $script:EventHandlers.Remove($EventName) }
                Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
            }
        } else {
            $found = $false
            foreach ($eventKey in @($script:EventHandlers.Keys)) {
                $handlers = $script:EventHandlers[$eventKey]
                $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($newHandlers.Count -lt $handlers.Count) {
                    $found = $true
                    $script:EventHandlers[$eventKey] = if ($newHandlers.Count -eq 0) { $script:EventHandlers.Remove($eventKey) } else { $newHandlers }
                    Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"; break
                }
            }
            if (-not $found) { Write-Warning "Handler ID not found: $HandlerId" }
        }
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId }
}

function Get-EventHandlers {
    <# .SYNOPSIS Gets all registered event handlers #>
    param([Parameter()] [string]$EventName)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHandlers" -Context "Getting event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { return $script:EventHandlers[$EventName] ?? @() }
        else { return $script:EventHandlers }
    }
}

function Clear-EventHandlers {
    <# .SYNOPSIS Clears all event handlers for a specific event or all events #>
    param([Parameter()] [string]$EventName)
    Invoke-WithErrorHandling -Component "EventSystem.ClearEventHandlers" -Context "Clearing event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { if ($script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers.Remove($EventName); Write-Verbose "Cleared handlers for event: $EventName" } } 
        else { $script:EventHandlers = @{}; Write-Verbose "Cleared all event handlers" }
    }
}

function Get-EventHistory {
    <# .SYNOPSIS Gets the event history #>
    param([Parameter()] [string]$EventName, [Parameter()] [int]$Last = 0)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHistory" -Context "Getting event history for '$EventName'" -ScriptBlock {
        $history = $script:EventHistory
        if ($EventName) { $history = $history | Where-Object { $_.EventName -eq $EventName } }
        if ($Last -gt 0) { $history = $history | Select-Object -Last $Last }
        return $history
    }
}

function Remove-ComponentEventHandlers {
    <# .SYNOPSIS Removes all event handlers associated with a specific component #>
    param([Parameter(Mandatory)] [string]$ComponentId)
    Invoke-WithErrorHandling -Component "EventSystem.RemoveComponentEventHandlers" -Context "Removing event handlers for component '$ComponentId'" -ScriptBlock {
        $removedCount = 0
        foreach ($eventName in @($script:EventHandlers.Keys)) {
            $initialCount = $script:EventHandlers[$eventName].Count
            $script:EventHandlers[$eventName] = @($script:EventHandlers[$eventName] | Where-Object { $_.Source -ne $ComponentId })
            $removedCount += $initialCount - $script:EventHandlers[$eventName].Count
            if ($script:EventHandlers[$eventName].Count -eq 0) { $script:EventHandlers.Remove($eventName) }
        }
        Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
    }
}
# --- END OF ORIGINAL FILE: modules\event-system\event-system.psm1 ---


# --- START OF ORIGINAL FILE: modules\theme-engine\theme-engine.psm1 ---
# MODULE: ThemeEngine
# PURPOSE: Loads and serves theme styles from JSON files, enabling full user customization.

class ThemeEngine {
    hidden [hashtable] $_themes
    hidden [string] $_currentThemeKey
    hidden [hashtable] $_currentThemeObject

    ThemeEngine([string]$themesDirectory) {
        $this._themes = @{}
        $this.LoadThemesFromDirectory($themesDirectory)

        # HARDENING: Ensure there is at least a fallback theme in case none are found or loadable.
        # This prevents the application from crashing on first run or with a bad configuration.
        if ($this._themes.Count -eq 0) {
            Write-Log -Level Warning -Message "No valid themes found. Loading internal default fallback."
            $this._themes['Default'] = @{
                Name = 'Default Fallback'
                Palette = @{ 
                    background = '#0d1117'; foreground = '#c9d1d9'; accent1 = '#58a6ff'; accent2 = '#f78166';
                    border = '#30363d'; borderFocus = '#58a6ff'; success = '#3fb950'; error = '#f85149';
                    errorHighlight = '#FF00FF'
                }
                Components = @{ 
                    Default = @{ FG = '$Palette.foreground'; BG = '$Palette.background' }
                    Panel = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.foreground' }
                    PanelFocus = @{ BorderFG = '$Palette.borderFocus' }
                    Table = @{ Header = @{ FG = '$Palette.accent1'; Bold = $true } }
                    FileBrowser = @{
                        Default = @{ FG = '$Palette.foreground' }
                        Directory = @{ FG = '$Palette.accent1'; Bold = $true }
                        Selected = @{ BG = '#2ea043'; FG = '#ffffff' }
                    }
                    Kanban = @{
                        Column = @{ BorderFG = '$Palette.border' }
                        Card = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent2' }
                        CardSelected = @{ BorderFG = '$Palette.borderFocus'; BG = '#30363d' }
                    }
                    Widget = @{
                        UpNext = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent1' }
                        Stats = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent2' }
                        Text = @{ Default = @{ FG = '$Palette.foreground' }; Overdue = @{ FG = '$Palette.error'; Bold = $true } }
                    }
                }
            }
        }

        # Set the first available theme as the current one.
        $this.SetTheme(($this._themes.Keys | Select-Object -First 1))
    }

    [void] LoadThemesFromDirectory([string]$dir) {
        if (-not (Test-Path $dir)) { Write-Log -Level Warning -Message "Themes directory not found: $dir"; return }
        $themeFiles = Get-ChildItem -Path $dir -Filter "*.theme.json" -File
        foreach ($file in $themeFiles) {
            try {
                $themeKey = ($file.BaseName -replace '\.theme$', '')
                $themeObject = Get-Content -Path $file.FullName -Raw | ConvertFrom-Json -AsHashtable
                $this._themes[$themeKey] = $themeObject
                Write-Log -Level Info -Message "Loaded theme '$themeKey' from $($file.Name)"
            } catch {
                # HARDENING: Resiliently handles corrupted or malformed theme files without crashing.
                Write-Log -Level Error -Message "Failed to load theme file '$($file.Name)': $_"
            }
        }
    }

    [void] SetTheme([string]$themeKey) {
        if ($this._themes.ContainsKey($themeKey)) {
            $this._currentThemeKey = $themeKey
            $this._currentThemeObject = $this._themes[$themeKey]
            Publish-Event -EventName "Theme.Changed" -Data @{ Name = $themeKey }
            Write-Log -Level Info -Message "Theme changed to: $themeKey"
        } else {
            Write-Log -Level Warning -Message "Attempted to set non-existent theme: $themeKey"
        }
    }

    # The core method for retrieving a fully resolved style object for a component.
    [hashtable] GetStyle([string]$componentPath) {
        $pathSegments = $componentPath.Split('.')
        $currentValue = $this._currentThemeObject
        
        # Traverse the path in the theme file (e.g., Components.Table.Header)
        foreach($segment in $pathSegments) {
            if ($currentValue -is [hashtable] -and $currentValue.ContainsKey($segment)) {
                $currentValue = $currentValue[$segment]
            } else {
                # Path not found, return an empty style to avoid errors in the calling code.
                return @{}
            }
        }
        
        # Now, resolve all palette references (e.g., '$Palette.accent1') in the retrieved style object.
        $resolvedStyle = @{}
        if ($currentValue -is [hashtable]) {
            foreach ($key in $currentValue.Keys) {
                $val = $currentValue[$key]
                $depth = 0 # HARDENING: Introduce depth counter to prevent infinite loops from circular references.
                
                while ($val -is [string] -and $val.StartsWith('$Palette.') -and $depth -lt 10) {
                    $paletteKey = $val.Substring(9)
                    # HARDENING: Check if the palette key actually exists to prevent errors.
                    if ($this._currentThemeObject.Palette.ContainsKey($paletteKey)) {
                        $val = $this._currentThemeObject.Palette[$paletteKey]
                    } else {
                        # Key not found, break loop and assign a visible error color for easy debugging.
                        Write-Log -Level Warning -Message "Theme '$($this._currentThemeKey)' is missing palette key: '$paletteKey' requested by '$componentPath'"
                        $val = $this._currentThemeObject.Palette.errorHighlight ?? '#FF00FF'
                        break
                    }
                    $depth++
                }
                # If it's still a variable after max depth, it's a circular reference.
                if ($val -is [string] -and $val.StartsWith('$Palette.')) {
                    Write-Log -Level Error -Message "Circular or unresolved palette reference detected at '$componentPath' for value '$val'"
                    $val = $this._currentThemeObject.Palette.errorHighlight ?? '#FF00FF'
                }
                $resolvedStyle[$key] = $val
            }
        }
        
        return $resolvedStyle
    }

    [string[]] GetThemeKeys() {
        return @($this._themes.Keys)
    }

    [hashtable] GetCurrentTheme() {
        return $this._currentThemeObject
    }
}

# Factory function to create the engine instance.
function Initialize-ThemeEngine {
    param([string]$themesDirectory)
    return [ThemeEngine]::new($themesDirectory)
}
# --- END OF REPLACEMENT for modules\theme-manager\theme-manager.psm1 ---


# In components\ui-classes\ui-classes.psm1
class UIElement {
    [string] $Name = ""
    [int] $X = 0; [int] $Y = 0; [int] $Width = 10; [int] $Height = 3
    [bool] $Visible = $true; [bool] $Enabled = $true
    [bool] $IsFocusable = $false; [bool] $IsFocused = $false
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer
    [bool] $_needs_redraw = $true

    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
    }
    UIElement([string]$name) : base() { $this.Name = $name }

    # GetAbsolutePosition, AddChild, RemoveChild, RequestRedraw (assume these are already defined correctly)

    # NEW: Base Resize method. It updates the component's dimensions,
    # resizes its private buffer, and then calls a virtual OnResize method
    # for subclasses to implement custom resizing logic (like re-laying out children).
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        # Recreate buffer to match new dimensions
        $this.{_private_buffer} = [TuiBuffer]::new($newWidth, $newHeight, "$($this.Name).Buffer")
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # NEW: Base Cleanup method. This will be called to ensure resources
    # (like event subscriptions) are released when a component is destroyed.
    # It automatically cascades to all children.
    [void] Cleanup() {
        # Call the specific cleanup logic for this component.
        $this.OnCleanup()
        # Cascade the cleanup call to all children.
        foreach ($child in $this.Children) {
            $child.Cleanup()
        }
    }
    
    # Virtual methods for subclasses to override.
    [void] OnRender() { }
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) { return $false }
    [void] OnFocus() { $this.IsFocused = $true }
    [void] OnBlur() { $this.IsFocused = $false }
    [void] OnResize([int]$newWidth, [int]$newHeight) { /* Override in subclasses */ }
    [void] OnCleanup() { /* Override in subclasses to unsubscribe from events, etc. */ }

    # Main Render method (assuming existing implementation is correct and uses _private_buffer)
    [void] Render() {
        if (-not $this.Visible) { return }
        # ... (rest of Render method remains the same)
    }

    # GetBuffer, ToString (assuming these are already defined correctly)
}

# --- Base Component (can contain children) ---
class Component : UIElement {
    Component([string]$name) : base($name) {
    }

    # AI: Default implementation renders all visible children to buffer
    hidden [void] _RenderContent() {
        # Call parent implementation for buffer management
        ([UIElement]$this)._RenderContent()
    }
}

# Note: Panel class is now defined in layout\panels-class.psm1

# --- Base Screen (top-level container) ---
class Screen : UIElement {
    [hashtable]$Services
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[UIElement]]$Panels
    [UIElement]$LastFocusedComponent # <<< ADD THIS LINE
    hidden [System.Collections.Generic.Dictionary[string, string]]$EventSubscriptions

    Screen([string]$name, [hashtable]$services) : base($name) {
        if (-not $services) { throw [ArgumentNullException]::new("services") }
        
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
    }
    
    [void] Initialize() { }
    [void] OnEnter() { }
    [void] OnExit() { }
    [void] OnResume() { }
    [void] HandleInput([System.ConsoleKeyInfo]$key) { }

    [void] Cleanup() {
        foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -SubscriberId $kvp.Value
            }
            catch {
                Write-Log -Level Warning -Message "Failed to unregister event '$($kvp.Key)' for screen '$($this.Name)'."
            }
        }
        $this.EventSubscriptions.Clear()
        $this.Panels.Clear()
        Write-Log -Level Debug -Message "Cleaned up screen: $($this.Name)"
    }
    
    [void] AddPanel([UIElement]$panel) {
        if (-not $panel) { throw [ArgumentNullException]::new("panel") }
        $this.Panels.Add($panel)
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($eventName)) { throw [ArgumentException]::new("Event name cannot be null or empty.") }
        if (-not $action) { throw [ArgumentNullException]::new("action") }
        
        # AI: Fixed parameter name from -Action to -Handler to match event-system.psm1 function signature
        $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
        $this.EventSubscriptions[$eventName] = $subscriptionId
    }
    
    # AI: Override _RenderContent to render all panels to buffer
    hidden [void] _RenderContent() {
        # Call base implementation for buffer management
        ([UIElement]$this)._RenderContent()
        
        # Render all panels in the screen to the back-buffer
        foreach ($panel in $this.Panels) {
            if ($panel.Visible) {
                $panel.Render()
            }
        }
    }
}
# --- END OF FULL REPLACEMENT for components\ui-classes\ui-classes.psm1 ---


# --- START OF FULL REPLACEMENT for layout\panels-class\panels-class.psm1 ---
# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

# Panel Class - A specialized UIElement that acts as a container.
# It can draw a border and title, and it intelligently manages child elements,
# positioning them correctly within its bordered "content area".
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid
    [hashtable] $Style = @{}

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # When a panel is resized, it must update its internal content bounds
        # and then re-calculate the layout of all its children.
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $this.ContentX
            $child.Y = $currentY
            
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $currentX
            $child.Y = $this.ContentY
            
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            $width = if ($col -eq ($cols - 1)) { $this.ContentX + $this.ContentWidth - $x } else { $cellWidth }
            $height = if ($row -eq ($rows - 1)) { $this.ContentY + $this.ContentHeight - $y } else { $cellHeight }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    [hashtable] GetContentBounds() {
        return @{ X = $this.ContentX; Y = $this.ContentY; Width = $this.ContentWidth; Height = $this.ContentHeight }
    }
    
    [hashtable] GetContentArea() {
        return $this.GetContentBounds()
    }
    
    [void] WriteToBuffer([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ($null -eq $this.{_private_buffer}) { return }
        Write-TuiText -Buffer $this.{_private_buffer} -X $x -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
    }
    
    [void] DrawBoxToBuffer([int]$x, [int]$y, [int]$width, [int]$height, [ConsoleColor]$borderColor, [ConsoleColor]$bgColor) {
        if ($null -eq $this.{_private_buffer}) { return }
        Write-TuiBox -Buffer $this.{_private_buffer} -X $x -Y $y -Width $width -Height $height `
            -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
    }

    [void] ClearContent() {
        if ($null -eq $this.{_private_buffer}) { return }
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this.{_private_buffer}.SetCell($x, $y, $clearCell)
            }
        }
    }

    [void] OnRender() {
        if ($null -eq $this.{_private_buffer}) { return }
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this.{_private_buffer}.Clear($bgCell)
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this.{_private_buffer} -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }
    }

    hidden [void] _RenderContent() {
        $this.OnRender()
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                if ($null -ne $child.{_private_buffer}) {
                    $this.{_private_buffer}.BlendBuffer($child.{_private_buffer}, ($child.X + $this.ContentX), ($child.Y + $this.ContentY))
                }
            }
        }
    }

    [void] OnFocus() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Cyan
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Gray
            $this.RequestRedraw()
        }
    }

    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        return $focusable
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.CanFocus -and $this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
            }
        }
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }
        return $false
    }

    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}

#region Specialized Panel Types

class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        if ($width -gt 0 -and $height -gt 0) {
            $this.{_virtual_buffer} = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        $this.RequestRedraw()
    }

    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        $this.RequestRedraw()
    }

    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }
        return ([Panel]$this).HandleInput($keyInfo)
    }

    [void] OnRender() {
        ([Panel]$this).OnRender()
        if ($null -ne $this.{_virtual_buffer}) {
            $visibleBuffer = $this.{_virtual_buffer}.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            $this.{_private_buffer}.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    [void] DrawScrollbars() {
        if ($null -eq $this.{_private_buffer}) { return }
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this.{_private_buffer}.SetCell($scrollbarX, $y, $cell)
            }
        }
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this.{_private_buffer}.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    [TuiBuffer] GetVirtualBuffer() {
        return $this.{_virtual_buffer}
    }
}

class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        $this.RequestRedraw()
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }
        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        return $false
    }

    [void] OnRender() {
        ([Panel]$this).OnRender()
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            $this.{_private_buffer}.SetCell(2, 0, $indicatorCell)
        }
    }
}
#endregion

# --- END OF FULL REPLACEMENT for layout\panels-class\panels-class.psm1 ---


# --- START OF ORIGINAL FILE: components\navigation-class\navigation-class.psm1 ---
# Navigation Component Classes Module for PMC Terminal v5
# Phase 1 Migration Complete - Proper UIElement inheritance and Panel integration
# CORRECTED (v2): Removed unused and confusing `BuildContextMenu` method.

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        $display = "[$($this.Key)] "
        
        if ($this.Enabled) {
            $display += $this.Label
        }
        else {
            $display += "$($this.Label) (Disabled)"
        }
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            $display += " - $($this.Description)"
        }
        
        return $display
    }
}

# AI: REFACTORED - NavigationMenu now properly inherits from UIElement
class NavigationMenu : UIElement {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    [bool] $IsFocused = $false
    
    NavigationMenu([string]$name) : base() {
        $this.Name = $name
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.SelectedIndex = 0
        $this.Width = 30
        $this.Height = 10
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base() {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Name = $name
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.SelectedIndex = 0
        $this.Width = 30
        $this.Height = 10
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) { 
            throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") 
        }
        $this.Items.Add($item)
        $this.RequestRedraw()
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { 
            [void]$this.Items.Remove($item)
            $this.RequestRedraw()
        }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { 
                $item.Execute() 
            }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
        $this.RequestRedraw()
    }
    
    # AI: REFACTORED - Now uses Panel buffer integration
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear our buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Get visible items
            $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
            if ($visibleItems.Count -eq 0) { return }
            
            if ($this.Orientation -eq "Horizontal") { 
                $this.RenderHorizontal($visibleItems) 
            }
            else { 
                $this.RenderVertical($visibleItems) 
            }
            
        } catch { 
            Write-Log -Level Error -Message "NavigationMenu render error for '$($this.Name)': $_" 
        }
    }
    
    hidden [void] RenderHorizontal([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) { return }
        
        $menuText = ""
        $isFirst = $true
        foreach ($item in $items) {
            if ($null -eq $item) { continue }
            
            if (-not $isFirst) {
                $menuText += $this.Separator
            }
            $menuText += "[$($item.Key)] $($item.Label)"
            $isFirst = $false
        }
        
        # Write to our private buffer
        $this._private_buffer.WriteString(0, 0, $menuText, [ConsoleColor]::White, [ConsoleColor]::Black)
    }
    
    hidden [void] RenderVertical([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) { return }
        
        # Ensure SelectedIndex is within bounds
        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {
            $this.SelectedIndex = 0
        }
        
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($null -eq $item) { continue }
            
            $prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }
            $menuText = "$prefix[$($item.Key)] $($item.Label)"
            
            # Pad text to clear the full line width
            if ($menuText.Length -lt $this.Width) {
                $menuText = $menuText.PadRight($this.Width)
            }
            
            $fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                [ConsoleColor]::Black 
            } else { 
                [ConsoleColor]::White 
            }
            $bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                [ConsoleColor]::White 
            } else { 
                [ConsoleColor]::Black 
            }
            
            # Write to our private buffer
            $this._private_buffer.WriteString(0, $i, $menuText, $fg, $bg)
        }
    }
    
    # AI: REFACTORED - Updated input handling for new architecture
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
            if ($visibleItems.Count -eq 0) { return $false }
            
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt ($visibleItems.Count - 1)) {
                        $this.SelectedIndex++
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $visibleItems.Count) {
                        $selectedItem = $visibleItems[$this.SelectedIndex]
                        if ($selectedItem.Enabled -and $selectedItem.Key -ne "-") {
                            $selectedItem.Execute()
                        }
                    }
                    return $true
                }
                default {
                    # Check for direct key matches
                    $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
                    $matchingItem = $this.Items.Find({param($x) $x.Key -eq $keyChar})
                    if ($matchingItem -and $matchingItem.Enabled -and $matchingItem.Visible) {
                        $matchingItem.Execute()
                        return $true
                    }
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "NavigationMenu input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    # AI: NEW - Focus management
    [void] OnFocus() {
        $this.IsFocused = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        $this.IsFocused = $false
        $this.RequestRedraw()
    }
}
# --- END OF ORIGINAL FILE: components\navigation-class\navigation-class.psm1 ---

# --- START OF ORIGINAL FILE: components\tui-components\tui-components.psm1 ---
####\components\tui-components.psm1
# TUI Component Library - Phase 1 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering





#region Core UI Components

# AI: REFACTORED - LabelComponent now properly inherits from UIElement
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor
    
    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $this.Text -ForegroundColor $fg

        } catch { 
            Write-Log -Level Error -Message "Label render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false # Labels don't handle input
    }
}

# AI: REFACTORED - ButtonComponent updated for buffer-based rendering
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick
    
    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
        $this.Text = "Button"
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer, not the parent's.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))

            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            $bgColor = $this.IsPressed ? [ConsoleColor]::Yellow : [ConsoleColor]::Black
            $fgColor = $this.IsPressed ? [ConsoleColor]::Black : $borderColor
            
            # Render border to own buffer
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
            
            # Render text centered in own buffer
            $textX = [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = [Math]::Floor(($this.Height - 1) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -ForegroundColor $fgColor -BackgroundColor $bgColor

        } catch { 
            Write-Log -Level Error -Message "Button render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsPressed = $true
                $this.RequestRedraw()
                
                if ($this.OnClick) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock { & $this.OnClick }
                }
                
                Start-Sleep -Milliseconds 50 # Visual feedback for press
                $this.IsPressed = $false
                $this.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "Button input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: REFACTORED - TextBoxComponent with buffer-based rendering
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.MaxLength = 100
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)

            # Display text or placeholder
            $displayText = $this.Text ?? ""
            $textColor = [ConsoleColor]::White
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = $this.Placeholder ?? "" 
                $textColor = [ConsoleColor]::DarkGray
            }
            
            $maxDisplayLength = $this.Width - 2
            if ($displayText.Length-gt $maxDisplayLength) { 
                $displayText = $displayText.Substring(0, $maxDisplayLength) 
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayText -ForegroundColor $textColor
            
            # Draw cursor if focused
            if ($this.IsFocused -and ($this.CursorPosition -le $displayText.Length)) {
                $cursorX = 1 + $this.CursorPosition
                # Only draw cursor if it's within the visible area
                # AI: FIX - Changed '<' to '-lt' to avoid PowerShell parser ambiguity
                if ($cursorX -lt ($this.Width - 1)) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" -ForegroundColor [ConsoleColor]::Yellow
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "TextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition ?? 0
            $originalText = $currentText
            $handled = $true
            
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $currentText = $currentText.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    } 
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $currentText.Length) { 
                        $currentText = $currentText.Remove($cursorPos, 1) 
                    } 
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- } 
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $currentText.Length) { $cursorPos++ } 
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $currentText.Length }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) { 
                        $currentText = $currentText.Insert($cursorPos, $key.KeyChar)
                        $cursorPos++ 
                    } else { 
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                if ($currentText -ne $originalText -or $cursorPos -ne $this.CursorPosition) {
                    $this.Text = $currentText
                    $this.CursorPosition = $cursorPos
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $currentText 
                        }
                    }
                    $this.RequestRedraw()
                }
            }
            return $handled
        } catch { 
            Write-Log -Level Error -Message "TextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
}

# AI: NEW - CheckBoxComponent converted from functional to class-based
class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange
    
    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $checkbox = $this.Checked ? "[X]" : "[ ]"
            $displayText = "$checkbox $($this.Text)"
            
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $displayText -ForegroundColor $fg
            
        } catch { 
            Write-Log -Level Error -Message "CheckBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Checked = -not $this.Checked
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $this.Checked 
                    } 
                }
                $this.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "CheckBox input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: NEW - RadioButtonComponent converted from functional to class-based
class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange
    
    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $radio = $this.Selected ? "(●)" : "( )"
            $displayText = "$radio $($this.Text)"

            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $displayText -ForegroundColor $fg

        } catch { 
            Write-Log -Level Error -Message "RadioButton render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if (-not $this.Selected) {
                    # AI: Unselect other radio buttons in the same group
                    if ($this.Parent -and $this.GroupName) {
                        $siblingRadios = $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        }
                        foreach ($radio in $siblingRadios) {
                            $radio.Selected = $false
                        }
                    }
                    
                    $this.Selected = $true
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $this.Selected 
                        } 
                    }
                    $this.Parent.RequestRedraw()
                }
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "RadioButton input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $label = [LabelComponent]::new($name)
    
    $label.X = $Props.X ?? $label.X
    $label.Y = $Props.Y ?? $label.Y
    $label.Width = $Props.Width ?? $label.Width
    $label.Height = $Props.Height ?? $label.Height
    $label.Visible = $Props.Visible ?? $label.Visible
    $label.ZIndex = $Props.ZIndex ?? $label.ZIndex
    $label.Text = $Props.Text ?? $label.Text
    $label.ForegroundColor = $Props.ForegroundColor ?? $label.ForegroundColor
    
    return $label
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $button = [ButtonComponent]::new($name)
    
    $button.X = $Props.X ?? $button.X
    $button.Y = $Props.Y ?? $button.Y
    $button.Width = $Props.Width ?? $button.Width
    $button.Height = $Props.Height ?? $button.Height
    $button.Visible = $Props.Visible ?? $button.Visible
    $button.ZIndex = $Props.ZIndex ?? $button.ZIndex
    $button.Text = $Props.Text ?? $button.Text
    $button.OnClick = $Props.OnClick ?? $button.OnClick
    
    return $button
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [TextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Text = $Props.Text ?? $textBox.Text
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLength = $Props.MaxLength ?? $textBox.MaxLength
    $textBox.CursorPosition = $Props.CursorPosition ?? $textBox.CursorPosition
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    return $textBox
}

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $checkBox = [CheckBoxComponent]::new($name)
    
    $checkBox.X = $Props.X ?? $checkBox.X
    $checkBox.Y = $Props.Y ?? $checkBox.Y
    $checkBox.Width = $Props.Width ?? $checkBox.Width
    $checkBox.Height = $Props.Height ?? $checkBox.Height
    $checkBox.Visible = $Props.Visible ?? $checkBox.Visible
    $checkBox.ZIndex = $Props.ZIndex ?? $checkBox.ZIndex
    $checkBox.Text = $Props.Text ?? $checkBox.Text
    $checkBox.Checked = $Props.Checked ?? $checkBox.Checked
    $checkBox.OnChange = $Props.OnChange ?? $checkBox.OnChange
    
    return $checkBox
}

function New-TuiRadioButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $radioButton = [RadioButtonComponent]::new($name)
    
    $radioButton.X = $Props.X ?? $radioButton.X
    $radioButton.Y = $Props.Y ?? $radioButton.Y
    $radioButton.Width = $Props.Width ?? $radioButton.Width
    $radioButton.Height = $Props.Height ?? $radioButton.Height
    $radioButton.Visible = $Props.Visible ?? $radioButton.Visible
    $radioButton.ZIndex = $Props.ZIndex ?? $radioButton.ZIndex
    $radioButton.Text = $Props.Text ?? $radioButton.Text
    $radioButton.Selected = $Props.Selected ?? $radioButton.Selected
    $radioButton.GroupName = $Props.GroupName ?? $radioButton.GroupName
    $radioButton.OnChange = $Props.OnChange ?? $radioButton.OnChange
    
    return $radioButton
}

#endregion
# --- END OF ORIGINAL FILE: components\tui-components\tui-components.psm1 ---


# --- START OF ORIGINAL FILE: components\advanced-data-components\advanced-data-components.psm1 ---
# Advanced Data Components Module for PMC Terminal v5
# Phase 1 Migration Complete - Enhanced data display with proper UIElement inheritance








#region Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

# AI: REFACTORED - Table now properly inherits from UIElement
class Table : UIElement {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    [bool]$IsFocused = $false
    
    Table([string]$name) : base() {
        $this.Name = $name
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        $this.Data = @()
        $this.SelectedIndex = 0
        $this.IsFocusable = $true
        $this.Width = 60
        $this.Height = 15
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
        $this.RequestRedraw()
    }
    
    [void] SetData([object[]]$data) {
        $this.Data = if ($null -eq $data) { @() } else { @($data) }
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -ge $dataCount) {
            $this.SelectedIndex = [Math]::Max(0, $dataCount - 1)
        }
        $this.RequestRedraw()
    }
    
    [void] SelectNext() {
        $dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -lt ($dataCount - 1)) {
            $this.SelectedIndex++
            $this.RequestRedraw()
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
            $this.RequestRedraw()
        }
    }
    
    [object] GetSelectedItem() {
        if ($null -eq $this.Data) { return $null }
        
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        
        if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {
            return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }
        }
        return $null
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Draw border if enabled
            if ($this.ShowBorder) {
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                    -BorderStyle "Single" -BorderColor ([ConsoleColor]::Gray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            $currentY = if ($this.ShowBorder) { 1 } else { 0 }
            $contentWidth = if ($this.ShowBorder) { $this.Width - 2 } else { $this.Width }
            $renderX = if ($this.ShowBorder) { 1 } else { 0 }
            
            # Header
            if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
                $headerLine = ""
                foreach ($col in $this.Columns) {
                    $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                    $headerLine += $headerText + " "
                }
                
                if ($headerLine.TrimEnd().Length -gt $contentWidth) {
                    $headerLine = $headerLine.Substring(0, $contentWidth)
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $headerLine.TrimEnd() `
                    -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
                $currentY++
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY `
                    -Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $contentWidth)) `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
                $currentY++
            }
            
            # Data rows
            $dataToRender = @()
            if ($null -ne $this.Data) {
                $dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }
            }
            
            for ($i = 0; $i -lt $dataToRender.Count; $i++) {
                $row = $dataToRender[$i]
                if ($null -eq $row) { continue }
                
                $rowLine = ""
                $isSelected = ($i -eq $this.SelectedIndex)
                
                foreach ($col in $this.Columns) {
                    $cellValue = ""
                    if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                        $cellValue = $row[$col.Key]?.ToString() ?? ""
                    } elseif ($row.PSObject.Properties[$col.Key]) {
                        $propValue = $row.($col.Key)
                        if ($col.Key -eq 'DueDate' -and $propValue -is [DateTime]) {
                            $cellValue = $propValue.ToString('yyyy-MM-dd')
                        } else {
                            $cellValue = if ($null -ne $propValue) { $propValue.ToString() } else { "" }
                        }
                    }
                    
                    $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                    $rowLine += $cellText + " "
                }
                
                $finalLine = $rowLine.TrimEnd()
                if ($isSelected) {
                    $finalLine = "> $finalLine"
                } else {
                    $finalLine = "  $finalLine"
                }
                
                $fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
                $bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
                
                if ($finalLine.Length -gt $contentWidth) {
                    $finalLine = $finalLine.Substring(0, $contentWidth)
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $finalLine `
                    -ForegroundColor $fg -BackgroundColor $bg
                $currentY++
                
                # Don't exceed available space
                if ($currentY -ge ($this.Height - 1)) { break }
            }
            
            if ($dataToRender.Count -eq 0) {
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text "  No data to display" `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
        } catch { 
            Write-Log -Level Error -Message "Table render error for '$($this.Name)': $_" 
        }
    }
    
    # AI: REFACTORED - Updated input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this.SelectPrevious()
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $this.SelectNext()
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $selectedItem = $this.GetSelectedItem()
                    if ($null -ne $selectedItem) {
                        # Trigger selection event or action
                        Write-Log -Level Debug -Message "Table item selected: $($selectedItem)"
                    }
                    return $true
                }
            }
        } catch { 
            Write-Log -Level Error -Message "Table input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    [void] OnFocus() {
        $this.IsFocused = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        $this.IsFocused = $false
        $this.RequestRedraw()
    }
}

# AI: DELETED - Obsolete DataTableComponent class was here and has been removed.

#endregion
# In components\advanced-data-components\advanced-data-components.psm1

# A reusable component that displays and handles navigation of a file system directory.
class FileListComponent : UIElement {
    [string]$Path
    [System.IO.FileSystemInfo[]]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollTop = 0
    [bool]$ShowHidden = $false
    [hashtable]$SelectedItems = @{}

    FileListComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Name = $name
    }

    [void] SetPath([string]$newPath) {
        # Resolve the path to its full, canonical form.
        try {
            $this.Path = (Get-Item -LiteralPath $newPath).FullName
            $this.Refresh()
        } catch {
            Write-Log -Level Error -Message "Failed to set path for FileListComponent: $_"
            # Optionally, show an alert dialog to the user.
            Show-AlertDialog -Title "Path Error" -Message "The path '$newPath' could not be found or accessed."
        }
    }

    [void] Refresh() {
        # HARDENING: The Get-ChildItem call is synchronous and WILL block the UI thread
        # if browsing a large directory or a slow network share. For a truly responsive UI,
        # this operation should be made asynchronous (e.g., using Start-Job or a runspace).
        # The component would then display a "Loading..." state and update once the job completes.
        
        # Always add ".." entry for parent directory navigation, unless at a drive root.
        $parentEntry = $null
        try {
            $parent = (Get-Item $this.Path).Parent
            if ($parent) {
                $parentEntry = [PSCustomObject]@{ Name = '..'; FullName = $parent.FullName; PSIsContainer = $true; LastWriteTime = $parent.LastWriteTime }
            }
        } catch { /* Suppress errors for roots that have no parent */ }

        $childItems = @(Get-ChildItem -LiteralPath $this.Path -Force:$this.ShowHidden -ErrorAction SilentlyContinue | Sort-Object @{ Expression = 'PSIsContainer'; Descending = $true }, Name)
        
        $this.Items = if ($parentEntry) { @($parentEntry) + $childItems } else { $childItems }

        # Clamp the selected index to valid bounds after refresh.
        if ($this.SelectedIndex -ge $this.Items.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
        }
        $this.RequestRedraw()
    }
    
    hidden [void] UpdateScrolling() {
        # Ensure the selected item is always visible within the component's viewport.
        if ($this.SelectedIndex -lt $this.ScrollTop) {
            $this.ScrollTop = $this.SelectedIndex
        }
        if ($this.SelectedIndex -ge ($this.ScrollTop + $this.Height)) {
            $this.ScrollTop = $this.SelectedIndex - $this.Height + 1
        }
    }

    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        $this._private_buffer.Clear()
        
        # Retrieve styles from the theme engine. This component knows nothing about colors.
        $styleDefault = $Global:AxiomServices.ThemeEngine.GetStyle("Components.FileBrowser.Default")
        $styleDir = $Global:AxiomServices.ThemeEngine.GetStyle("Components.FileBrowser.Directory")
        $styleSelected = $Global:AxiomServices.ThemeEngine.GetStyle("Components.FileBrowser.Selected")

        $visibleCount = [Math]::Min($this.Items.Count - $this.ScrollTop, $this.Height)
        
        for ($i = 0; $i -lt $visibleCount; $i++) {
            $itemIndex = $this.ScrollTop + $i
            if ($itemIndex -ge $this.Items.Count) { break }
            
            $item = $this.Items[$itemIndex]
            $isCurrent = ($itemIndex -eq $this.SelectedIndex)
            
            $icon = if ($item.PSIsContainer) { "📁" } else { "📄" }
            # Truncate line to fit component width.
            $line = "$icon $($item.Name)"
            if ($line.Length -gt $this.Width) { $line = $line.Substring(0, $this.Width - 1) + "…" }
            $line = $line.PadRight($this.Width)

            $currentStyle = if ($item.PSIsContainer) { $styleDir } else { $styleDefault }
            if ($isCurrent -and $this.IsFocused) {
                # Merge the 'Selected' style over the top of the item's base style.
                foreach($key in $styleSelected.Keys) { $currentStyle[$key] = $styleSelected[$key] }
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y $i -Text $line -Style $currentStyle
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # This component only handles navigational input.
        switch ($keyInfo.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex-gt 0) { $this.SelectedIndex-- }
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt ($this.Items.Count - 1)) { $this.SelectedIndex++ }
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::PageUp) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this.Height)
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::PageDown) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this.Height)
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
        }
        return $false # Did not handle the input.
    }
}

#region Factory Functions

function New-TuiTable {
    # AI: REFACTORED - Creates a proper Table instance
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Table_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $table = [Table]::new($name)
    
    if ($Props.Columns) {
        $table.SetColumns($Props.Columns)
    }
    if ($Props.Data) {
        $table.SetData($Props.Data)
    }

    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader
    $table.Visible = $Props.Visible ?? $table.Visible
    
    return $table
}

#endregion
# --- END OF ORIGINAL FILE: components\advanced-data-components\advanced-data-components.psm1 ---


# --- START OF ORIGINAL FILE: components\advanced-input-components\advanced-input-components.psm1 ---
# Advanced Input Components - Phase 2 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering





#region Advanced Input Classes

# AI: REFACTORED - MultilineTextBox converted from functional to class-based
class MultilineTextBoxComponent : UIElement {
    [string[]]$Lines = @("")
    [string]$Placeholder = "Enter text..."
    [int]$MaxLines = 10
    [int]$MaxLineLength = 100
    [int]$CurrentLine = 0
    [int]$CursorPosition = 0
    [int]$ScrollOffsetY = 0
    [bool]$WordWrap = $true
    [scriptblock]$OnChange
    
    MultilineTextBoxComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 40
        $this.Height = 10
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Calculate visible area
            $textAreaHeight = $this.Height - 2
            $textAreaWidth = $this.Width - 2
            $startLine = $this.ScrollOffsetY
            $endLine = [Math]::Min($this.Lines.Count - 1, $startLine + $textAreaHeight - 1)
            
            # AI: Render text lines
            for ($i = $startLine; $i -le $endLine; $i++) {
                if ($i -ge $this.Lines.Count) { break }
                
                $line = $this.Lines[$i] ?? ""
                $displayLine = $line
                if ($displayLine.Length -gt $textAreaWidth) {
                    $displayLine = $displayLine.Substring(0, $textAreaWidth)
                }
                
                $lineY = 1 + ($i - $startLine)
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y $lineY -Text $displayLine `
                    -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            # AI: Show placeholder if empty and not focused
            if ($this.Lines.Count -eq 1 -and [string]::IsNullOrEmpty($this.Lines[0]) -and -not $this.IsFocused) {
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $this.Placeholder `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            # AI: Draw cursor if focused
            if ($this.IsFocused) {
                $cursorLine = $this.CurrentLine - $this.ScrollOffsetY
                if ($cursorLine -ge 0 -and $cursorLine -lt $textAreaHeight) {
                    $cursorX = 1 + $this.CursorPosition
                    $cursorY = 1 + $cursorLine
                    if ($cursorX -lt $this.Width - 1) {
                        Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y $cursorY -Text "_" `
                            -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                    }
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentLineText = $this.Lines[$this.CurrentLine] ?? ""
            $originalLines = $this.Lines.Clone()
            $handled = $true
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = $this.Lines[$this.CurrentLine].Length
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.CursorPosition++
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $currentLineText.Length }
                ([ConsoleKey]::Enter) {
                    if ($this.Lines.Count -lt $this.MaxLines) {
                        $beforeCursor = $currentLineText.Substring(0, $this.CursorPosition)
                        $afterCursor = $currentLineText.Substring($this.CursorPosition)
                        
                        $this.Lines[$this.CurrentLine] = $beforeCursor
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($afterCursor) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0 -and $this.Lines.Count -gt 1) {
                        $previousLine = $this.Lines[$this.CurrentLine - 1]
                        $this.CursorPosition = $previousLine.Length
                        $this.Lines[$this.CurrentLine - 1] = $previousLine + $currentLineText
                        $this.Lines = @($this.Lines[0..($this.CurrentLine - 1)]) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        $this.CurrentLine--
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition, 1)
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $nextLine = $this.Lines[$this.CurrentLine + 1]
                        $this.Lines[$this.CurrentLine] = $currentLineText + $nextLine
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($this.Lines[($this.CurrentLine + 2)..($this.Lines.Count - 1)])
                    }
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentLineText.Length -lt $this.MaxLineLength) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.OnChange -and -not $this._ArraysEqual($originalLines, $this.Lines)) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Lines 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _UpdateScrolling() {
        $textAreaHeight = $this.Height - 2
        if ($this.CurrentLine -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CurrentLine
        } elseif ($this.CurrentLine -ge ($this.ScrollOffsetY + $textAreaHeight)) {
            $this.ScrollOffsetY = $this.CurrentLine - $textAreaHeight + 1
        }
    }
    
    hidden [bool] _ArraysEqual([string[]]$array1, [string[]]$array2) {
        if ($array1.Count -ne $array2.Count) { return $false }
        for ($i = 0; $i -lt $array1.Count; $i++) {
            if ($array1[$i] -ne $array2[$i]) { return $false }
        }
        return $true
    }
    
    [string] GetText() {
        return $this.Lines -join "`n"
    }
    
    [void] SetText([string]$text) {
        $this.Lines = if ([string]::IsNullOrEmpty($text)) { @("") } else { $text -split "`n" }
        $this.CurrentLine = 0
        $this.CursorPosition = 0
        $this.ScrollOffsetY = 0
        $this.RequestRedraw()
    }
}

# AI: REFACTORED - NumericInput converted from functional to class-based
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$Min = [double]::MinValue
    [double]$Max = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [string]$TextValue = "0"
    [int]$CursorPosition = 0
    [string]$Suffix = ""
    [scriptblock]$OnChange
    
    NumericInputComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display value with suffix
            $displayText = $this.TextValue + $this.Suffix
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw spinner arrows
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 0 -Text "▲" `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 2 -Text "▼" `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt $this.Width - 4) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" `
                        -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "NumericInput render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this._IncrementValue()
                }
                ([ConsoleKey]::DownArrow) {
                    $this._DecrementValue()
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) { 
                        $this.CursorPosition-- 
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) { 
                        $this.CursorPosition++ 
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this._ValidateAndUpdate()
                }
                default {
                    if ($key.KeyChar -and ($key.KeyChar -match '[\d\.\-]' -or 
                        ($key.KeyChar -eq '.' -and $this.DecimalPlaces -gt 0 -and -not $this.TextValue.Contains('.')))) {
                        $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "NumericInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _IncrementValue() {
        $newValue = [Math]::Min($this.Max, $this.Value + $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _DecrementValue() {
        $newValue = [Math]::Max($this.Min, $this.Value - $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _SetValue([double]$value) {
        $this.Value = $value
        $this.TextValue = $value.ToString("F$($this.DecimalPlaces)")
        $this.CursorPosition = $this.TextValue.Length
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newValue = [double]$this.TextValue
            $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
            $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
            
            $this._SetValue($newValue)
            return $true
        } catch {
            $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
            Write-Log -Level Warning -Message "NumericInput validation failed for '$($this.Name)': $_"
            return $false
        }
    }
}

# AI: REFACTORED - DateInput converted from functional to class-based
class DateInputComponent : UIElement {
    [DateTime]$Value = (Get-Date)
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [string]$Format = "yyyy-MM-dd"
    [string]$TextValue = ""
    [int]$CursorPosition = 0
    [bool]$ShowCalendar = $false
    [scriptblock]$OnChange
    
    DateInputComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.TextValue = $this.Value.ToString($this.Format)
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display date value
            $displayText = $this.TextValue
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw calendar icon
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text "📅" `
                -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt $this.Width - 4) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" `
                        -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "DateInput render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            if ($this.ShowCalendar) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) { $this.ShowCalendar = $false }
                    ([ConsoleKey]::LeftArrow) { $this.Value = $this.Value.AddDays(-1) }
                    ([ConsoleKey]::RightArrow) { $this.Value = $this.Value.AddDays(1) }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(-7) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(7) }
                    ([ConsoleKey]::Enter) { 
                        $this.ShowCalendar = $false
                        $this.TextValue = $this.Value.ToString($this.Format)
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::F4) { $this.ShowCalendar = $true }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(-1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::LeftArrow) {
                        if ($this.CursorPosition -gt 0) { $this.CursorPosition-- }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) { $this.CursorPosition++ }
                    }
                    ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                    ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                    ([ConsoleKey]::Backspace) {
                        if ($this.CursorPosition -gt 0) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                            $this.CursorPosition--
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                        }
                    }
                    ([ConsoleKey]::Enter) {
                        $this._ValidateAndUpdate()
                    }
                    default {
                        if ($key.KeyChar -and ($key.KeyChar -match '[\d\-\/]')) {
                            $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                            $this.CursorPosition++
                        } else {
                            $handled = $false
                        }
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "DateInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newDate = [DateTime]::ParseExact($this.TextValue, $this.Format, $null)
            if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                $this.Value = $newDate
                $this.TextValue = $newDate.ToString($this.Format)
                return $true
            }
        } catch {
            # Reset to current value on parse error
            $this.TextValue = $this.Value.ToString($this.Format)
            Write-Log -Level Warning -Message "DateInput validation failed for '$($this.Name)': $_"
        }
        return $false
    }
}

# AI: REFACTORED - ComboBox converted from functional to class-based
class ComboBoxComponent : UIElement {
    [object[]]$Items = @()
    [object]$SelectedItem = $null
    [int]$SelectedIndex = -1
    [string]$DisplayMember = "Display"
    [string]$ValueMember = "Value"
    [string]$Placeholder = "Select an item..."
    [bool]$IsDropDownOpen = $false
    [int]$MaxDropDownHeight = 6
    [int]$ScrollOffset = 0
    [scriptblock]$OnSelectionChanged
    
    ComboBoxComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 30
        $this.Height = 3
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }

        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw main combobox
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display selected item or placeholder
            $displayText = ""
            if ($this.SelectedItem) {
                if ($this.SelectedItem -is [string]) {
                    $displayText = $this.SelectedItem
                } elseif ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.DisplayMember)) {
                    $displayText = $this.SelectedItem[$this.DisplayMember]
                } else {
                    $displayText = $this.SelectedItem.ToString()
                }
            } else {
                $displayText = $this.Placeholder
            }
            
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength - 3) + "..."
            }
            
            $textColor = $this.SelectedItem ? [ConsoleColor]::White : [ConsoleColor]::DarkGray
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor $textColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw dropdown arrow
            $arrow = $this.IsDropDownOpen ? "▲" : "▼"
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text $arrow `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "ComboBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalSelection = $this.SelectedItem
            
            if ($this.IsDropDownOpen) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) {
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::Enter) {
                        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
                            $this.SelectedItem = $this.Items[$this.SelectedIndex]
                        }
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($this.SelectedIndex -gt 0) {
                            $this.SelectedIndex--
                            $this._UpdateScrolling()
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                            $this.SelectedIndex++
                            $this._UpdateScrolling()
                        }
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::Enter) { $this._OpenDropDown() }
                    ([ConsoleKey]::Spacebar) { $this._OpenDropDown() }
                    ([ConsoleKey]::DownArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::UpArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::F4) { $this._OpenDropDown() }
                    default { $handled = $false }
                }
            }
            
            if ($handled -and $this.SelectedItem -ne $originalSelection -and $this.OnSelectionChanged) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnSelectionChanged" -Context "Selection Change" -ScriptBlock { 
                    & $this.OnSelectionChanged -SelectedItem $this.SelectedItem 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "ComboBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _OpenDropDown() {
        if ($this.Items.Count -gt 0) {
            $this.IsDropDownOpen = $true
            $this._FindCurrentSelection()
        }
    }
    
    hidden [void] _FindCurrentSelection() {
        $this.SelectedIndex = -1
        if ($this.SelectedItem) {
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                if ($this._ItemsEqual($this.Items[$i], $this.SelectedItem)) {
                    $this.SelectedIndex = $i
                    break
                }
            }
        }
        if ($this.SelectedIndex -eq -1) { $this.SelectedIndex = 0 }
        $this._UpdateScrolling()
    }
    
    hidden [void] _UpdateScrolling() {
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $this.MaxDropDownHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $this.MaxDropDownHeight + 1
        }
    }
    
    hidden [bool] _ItemsEqual([object]$item1, [object]$item2) {
        if ($item1 -is [string] -and $item2 -is [string]) {
            return $item1 -eq $item2
        } elseif ($item1 -is [hashtable] -and $item2 -is [hashtable]) {
            return $item1[$this.ValueMember] -eq $item2[$this.ValueMember]
        } else {
            return $item1 -eq $item2
        }
    }
    
    [void] SetItems([object[]]$items) {
        $this.Items = $items
        $this.SelectedItem = $null
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.IsDropDownOpen = $false
        $this.RequestRedraw()
    }
    
    [object] GetSelectedValue() {
        if ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.ValueMember)) {
            return $this.SelectedItem[$this.ValueMember]
        }
        return $this.SelectedItem
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiMultilineTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "MultilineTextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [MultilineTextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLines = $Props.MaxLines ?? $textBox.MaxLines
    $textBox.MaxLineLength = $Props.MaxLineLength ?? $textBox.MaxLineLength
    $textBox.WordWrap = $Props.WordWrap ?? $textBox.WordWrap
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    if ($Props.Text) {
        $textBox.SetText($Props.Text)
    }
    
    return $textBox
}

function New-TuiNumericInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "NumericInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $numericInput = [NumericInputComponent]::new($name)
    
    $numericInput.X = $Props.X ?? $numericInput.X
    $numericInput.Y = $Props.Y ?? $numericInput.Y
    $numericInput.Width = $Props.Width ?? $numericInput.Width
    $numericInput.Height = $Props.Height ?? $numericInput.Height
    $numericInput.Visible = $Props.Visible ?? $numericInput.Visible
    $numericInput.ZIndex = $Props.ZIndex ?? $numericInput.ZIndex
    $numericInput.Value = $Props.Value ?? $numericInput.Value
    $numericInput.Min = $Props.Min ?? $numericInput.Min
    $numericInput.Max = $Props.Max ?? $numericInput.Max
    $numericInput.Step = $Props.Step ?? $numericInput.Step
    $numericInput.DecimalPlaces = $Props.DecimalPlaces ?? $numericInput.DecimalPlaces
    $numericInput.Suffix = $Props.Suffix ?? $numericInput.Suffix
    $numericInput.OnChange = $Props.OnChange ?? $numericInput.OnChange
    
    # Update text value based on initial value
    $numericInput.TextValue = $numericInput.Value.ToString("F$($numericInput.DecimalPlaces)")
    
    return $numericInput
}

function New-TuiDateInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DateInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $dateInput = [DateInputComponent]::new($name)
    
    $dateInput.X = $Props.X ?? $dateInput.X
    $dateInput.Y = $Props.Y ?? $dateInput.Y
    $dateInput.Width = $Props.Width ?? $dateInput.Width
    $dateInput.Height = $Props.Height ?? $dateInput.Height
    $dateInput.Visible = $Props.Visible ?? $dateInput.Visible
    $dateInput.ZIndex = $Props.ZIndex ?? $dateInput.ZIndex
    $dateInput.Value = $Props.Value ?? $dateInput.Value
    $dateInput.MinDate = $Props.MinDate ?? $dateInput.MinDate
    $dateInput.MaxDate = $Props.MaxDate ?? $dateInput.MaxDate
    $dateInput.Format = $Props.Format ?? $dateInput.Format
    $dateInput.OnChange = $Props.OnChange ?? $dateInput.OnChange
    
    # Update text value based on initial value
    $dateInput.TextValue = $dateInput.Value.ToString($dateInput.Format)
    
    return $dateInput
}

function New-TuiComboBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "ComboBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $comboBox = [ComboBoxComponent]::new($name)
    
    $comboBox.X = $Props.X ?? $comboBox.X
    $comboBox.Y = $Props.Y ?? $comboBox.Y
    $comboBox.Width = $Props.Width ?? $comboBox.Width
    $comboBox.Height = $Props.Height ?? $comboBox.Height
    $comboBox.Visible = $Props.Visible ?? $comboBox.Visible
    $comboBox.ZIndex = $Props.ZIndex ?? $comboBox.ZIndex
    $comboBox.DisplayMember = $Props.DisplayMember ?? $comboBox.DisplayMember
    $comboBox.ValueMember = $Props.ValueMember ?? $comboBox.ValueMember
    $comboBox.Placeholder = $Props.Placeholder ?? $comboBox.Placeholder
    $comboBox.MaxDropDownHeight = $Props.MaxDropDownHeight ?? $comboBox.MaxDropDownHeight
    $comboBox.OnSelectionChanged = $Props.OnSelectionChanged ?? $comboBox.OnSelectionChanged
    
    if ($Props.Items) {
        $comboBox.SetItems($Props.Items)
    }
    
    if ($Props.SelectedItem) {
        $comboBox.SelectedItem = $Props.SelectedItem
    }
    
    return $comboBox
}

#endregion
# --- END OF ORIGINAL FILE: components\advanced-input-components\advanced-input-components.psm1 ---


# --- START OF ORIGINAL FILE: modules\data-manager-class\data-manager-class.psm1 ---
# DELETED - This file's contents have been merged into modules\data-manager\data-manager.psm1
# --- END OF ORIGINAL FILE: modules\data-manager-class\data-manager-class.psm1 ---


# --- START OF ORIGINAL FILE for services/action-service.psm1 ---
class ActionService {
    [System.Collections.Generic.List[object]]$Actions

    ActionService() {
        $this.Actions = [System.Collections.Generic.List[object]]::new()
    }

    [void] RegisterAction([string]$name, [string]$group, [scriptblock]$scriptBlock) {
        $this.Actions.Add([PSCustomObject]@{
            Name = $name
            Group = $group
            Function = $scriptBlock
        })
    }

    [void] FinalizeActions() {
        $this.Actions = $this.Actions | Sort-Object Group, Name
        Write-Log -Level Info -Message "Registered $($this.Actions.Count) commands for the palette."
    }
}

function Initialize-ActionService {
    return [ActionService]::new()
}
# --- END OF ORIGINAL FILE for services/action-service.psm1 ---


# --- START OF ORIGINAL FILE for services/timesheet-service.psm1 ---
class TimeSheetService {
    hidden [DataManager]$_dataManager

    TimeSheetService([DataManager]$dm) {
        if ($null -eq $dm) { throw [System.ArgumentNullException]::new("DataManager cannot be null.") }
        $this._dataManager = $dm
    }

    [void] StartTimer([PmcTask]$task) {
        if (-not $task) { throw "Task cannot be null." }
        $activeTimers = $this._dataManager._dataStore.ActiveTimers
        if ($activeTimers.ContainsKey($task.Id)) {
            Write-Log -Level Warning -Message "Timer for task $($task.Id) is already running."
            return
        }
        $activeTimers[$task.Id] = @{ StartTime = [datetime]::Now; ProjectKey = $task.ProjectKey }
        Write-Log -Level Info -Message "Started timer for task: $($task.Title)"
        # Publish a generic event that UI components can subscribe to.
        Publish-Event -EventName "Timers.Changed" -Data @{ TaskId = $task.Id; Status = "Started" }
    }

    [void] StopTimer([PmcTask]$task) {
        if (-not $task) { throw "Task cannot be null." }
        $activeTimers = $this._dataManager._dataStore.ActiveTimers
        if (-not $activeTimers.ContainsKey($task.Id)) { return }
        
        $timerData = $activeTimers[$task.Id]
        $endTime = [datetime]::Now
        $duration = ($endTime - $timerData.StartTime)
        
        # Add a new time entry to the data store.
        $this._dataManager._dataStore.time_entries.Add(@{
            EntryId = [Guid]::NewGuid().ToString()
            TaskId = $task.Id
            ProjectKey = $timerData.ProjectKey
            StartTime = $timerData.StartTime
            EndTime = $endTime
            DurationSeconds = $duration.TotalSeconds
        })
        
        [void]$activeTimers.Remove($task.Id)
        Write-Log -Level Info -Message "Stopped timer for task: $($task.Title). Duration: $($duration.ToString('hh\:mm\:ss'))"
        Publish-Event -EventName "Timers.Changed" -Data @{ TaskId = $task.Id; Status = "Stopped" }
    }

    # This method returns pure data, not formatted strings.
    [object[]] GetWeeklySummary() {
        $entries = $this._dataManager._dataStore.time_entries | Where-Object { $_.StartTime -ge (Get-Date).Date.AddDays(-7) }
        $summary = $entries | Group-Object ProjectKey | ForEach-Object {
            [PSCustomObject]@{
                Project = $_.Name
                TotalHours = [Math]::Round(($_.Group | Measure-Object DurationSeconds -Sum).Sum / 3600, 2)
            }
        }
        return $summary
    }

    # HARDENING: This service method returns raw data (a string). It does not
    # interact with the filesystem. The calling UI component is responsible for
    # handling the file I/O, which maintains a clean separation of concerns.
    [string] GetWeeklySummaryAsTsv() {
        $summaryData = $this.GetWeeklySummary()
        if ($summaryData.Count -eq 0) { return "" }
        
        # Convert the data to a TSV string in memory.
        return ($summaryData | ConvertTo-Csv -Delimiter "`t" -NoTypeInformation | Out-String)
    }
}

function Initialize-TimeSheetService {
    param([DataManager]$DataManager)
    return [TimeSheetService]::new($DataManager)
}
# --- END OF ORIGINAL FILE for services/timesheet-service.psm1 ---


# --- START OF ORIGINAL FILE: services\keybinding-service-class\keybinding-service-class.psm1 ---
# keybinding-service-class.psm1
# Contains only the KeybindingService class definition.



class KeybindingService {
    [hashtable] $KeyMap = @{}
    [hashtable] $GlobalHandlers = @{}
    [System.Collections.Generic.List[string]] $ContextStack
    [bool] $EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized"
    }
    
    KeybindingService([bool]$enableChords) {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.EnableChords = $enableChords
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized with chords: $enableChords"
    }
    
    hidden [void] InitializeDefaultBindings() {
        # AI: Standard application keybindings
        $this.KeyMap = @{
            "app.exit" = @{ Key = "Q"; Modifiers = @("Ctrl") }
            "app.help" = @{ Key = [System.ConsoleKey]::F1; Modifiers = @() }
            "nav.back" = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }
            "nav.up" = @{ Key = [System.ConsoleKey]::UpArrow; Modifiers = @() }
            "nav.down" = @{ Key = [System.ConsoleKey]::DownArrow; Modifiers = @() }
            "nav.left" = @{ Key = [System.ConsoleKey]::LeftArrow; Modifiers = @() }
            "nav.right" = @{ Key = [System.ConsoleKey]::RightArrow; Modifiers = @() }
            "nav.select" = @{ Key = [System.ConsoleKey]::Enter; Modifiers = @() }
            "nav.pageup" = @{ Key = [System.ConsoleKey]::PageUp; Modifiers = @() }
            "nav.pagedown" = @{ Key = [System.ConsoleKey]::PageDown; Modifiers = @() }
            "nav.home" = @{ Key = [System.ConsoleKey]::Home; Modifiers = @() }
            "nav.end" = @{ Key = [System.ConsoleKey]::End; Modifiers = @() }
            "nav.tab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @() }
            "nav.shifttab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @("Shift") }
            "edit.delete" = @{ Key = [System.ConsoleKey]::Delete; Modifiers = @() }
            "edit.backspace" = @{ Key = [System.ConsoleKey]::Backspace; Modifiers = @() }
            "edit.new" = @{ Key = "n"; Modifiers = @() }
            "edit.save" = @{ Key = "s"; Modifiers = @("Ctrl") }
            "app.refresh" = @{ Key = [System.ConsoleKey]::F5; Modifiers = @() }
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKey]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [char]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
        }
        
        $modifiers = @()
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) { $modifiers += "Ctrl" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) { $modifiers += "Alt" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) { $modifiers += "Shift" }

        $this.KeyMap[$actionName.ToLower()] = @{
            Key = $keyInfo.Key
            KeyChar = $keyInfo.KeyChar
            Modifiers = $modifiers
        }
        Write-Log -Level Debug -Message "Set keybinding for '$actionName': $($this.GetBindingDescription($actionName))"
    }
    
    [void] RemoveBinding([string]$actionName) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RemoveBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return
            }
            
            $normalizedName = $actionName.ToLower()
            if ($this.KeyMap.ContainsKey($normalizedName)) {
                $this.KeyMap.Remove($normalizedName)
                Write-Log -Level Debug -Message "Removed keybinding: $actionName"
            }
        }
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        return $this.IsAction($actionName, $keyInfo, $null)
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "IsAction:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return $false
            }
            
            $normalizedName = $actionName.ToLower()
            if (-not $this.KeyMap.ContainsKey($normalizedName)) {
                return $false
            }
            
            $binding = $this.KeyMap[$normalizedName]
            
            # Check if the key matches
            $keyMatches = $false
            if ($binding.Key -is [System.ConsoleKey]) {
                $keyMatches = ($keyInfo.Key -eq $binding.Key)
            }
            elseif ($binding.Key -is [char]) {
                $keyMatches = ($keyInfo.KeyChar -eq $binding.Key)
            }
            elseif ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
                # Character-based binding (case-insensitive)
                $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.KeyChar.ToString(), [System.StringComparison]::OrdinalIgnoreCase)
            }
            else {
                # Try string comparison for backward compatibility
                $keyString = $binding.Key.ToString()
                if ($keyString.Length -eq 1) {
                    $keyMatches = ($keyInfo.KeyChar.ToString().ToUpper() -eq $keyString.ToUpper())
                }
                else {
                    # Try to match against ConsoleKey enum
                    try {
                        $consoleKey = [System.ConsoleKey]::Parse([System.ConsoleKey], $keyString, $true)
                        $keyMatches = ($keyInfo.Key -eq $consoleKey)
                    }
                    catch {
                        $keyMatches = $false
                    }
                }
            }
            
            if (-not $keyMatches) {
                return $false
            }
            
            # Check modifiers
            $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
            $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
            $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
            
            $expectedCtrl = $binding.Modifiers -contains "Ctrl"
            $expectedAlt = $binding.Modifiers -contains "Alt"
            $expectedShift = $binding.Modifiers -contains "Shift"
            
            return ($hasCtrl -eq $expectedCtrl) -and ($hasAlt -eq $expectedAlt) -and ($hasShift -eq $expectedShift)
        }
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "GetAction" -ScriptBlock {
            foreach ($actionName in $this.KeyMap.Keys) {
                if ($this.IsAction($actionName, $keyInfo)) {
                    return $actionName
                }
            }
            return $null
        }
    }
    
    [void] RegisterGlobalHandler([string]$actionName, [scriptblock]$handler) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RegisterGlobalHandler:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            if ($null -eq $handler) {
                throw [System.ArgumentNullException]::new("handler", "Handler cannot be null")
            }
            
            $this.GlobalHandlers[$actionName.ToLower()] = $handler
            Write-Log -Level Debug -Message "Registered global handler: $actionName"
        }
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo) {
        return $this.HandleKey($keyInfo, $null)
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "HandleKey" -ScriptBlock {
            # Check all registered actions
            foreach ($action in $this.KeyMap.Keys) {
                if ($this.IsAction($action, $keyInfo, $context)) {
                    # Execute global handler if registered
                    if ($this.GlobalHandlers.ContainsKey($action)) {
                        Write-Log -Level Debug -Message "Executing global handler: $action"
                        try {
                            return & $this.GlobalHandlers[$action] -KeyInfo $keyInfo -Context $context
                        }
                        catch {
                            Write-Log -Level Error -Message "Global handler failed for '$action': $_"
                            return $null
                        }
                    }
                    
                    # Return the action name for the caller to handle
                    return $action
                }
            }
            
            return $null
        }
    }
    
    [void] PushContext([string]$context) {
        if (-not [string]::IsNullOrWhiteSpace($context)) {
            $this.ContextStack.Add($context)
            Write-Log -Level Debug -Message "Pushed keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
        }
    }
    
    [string] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $context = $this.ContextStack[-1]
            $this.ContextStack.RemoveAt($this.ContextStack.Count - 1)
            Write-Log -Level Debug -Message "Popped keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
            return $context
        }
        return $null
    }
    
    [string] GetCurrentContext() {
        if ($this.ContextStack.Count -gt 0) {
            return $this.ContextStack[-1]
        }
        return "global"
    }
    
    [string] GetBindingDescription([string]$actionName) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            return $null
        }
        
        $normalizedName = $actionName.ToLower()
        if (-not $this.KeyMap.ContainsKey($normalizedName)) {
            return "Unbound"
        }
        
        $binding = $this.KeyMap[$normalizedName]
        $keyStr = if ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
            $binding.KeyChar.ToString().ToUpper()
        } elseif ($binding.Key -is [System.ConsoleKey]) {
            $binding.Key.ToString()
        } else {
            $binding.Key.ToString().ToUpper()
        }
        
        if ($binding.Modifiers.Count -gt 0) {
            return "$($binding.Modifiers -join '+') + $keyStr"
        }
        
        return $keyStr
    }
    
    [hashtable] GetAllBindings() {
        return $this.GetAllBindings($false)
    }
    
    [hashtable] GetAllBindings([bool]$groupByCategory) {
        if (-not $groupByCategory) {
            return $this.KeyMap.Clone()
        }
        
        # Group by category (part before the dot)
        $grouped = @{}
        foreach ($action in $this.KeyMap.Keys) {
            $parts = $action.Split('.')
            $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
            if (-not $grouped.ContainsKey($category)) {
                $grouped[$category] = @{}
            }
            $grouped[$category][$action] = $this.KeyMap[$action]
        }
        
        return $grouped
    }
    
    [void] ExportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ExportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            $this.KeyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $path -Encoding UTF8
            Write-Log -Level Info -Message "Exported keybindings to: $path"
        }
    }
    
    [void] ImportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ImportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            if (-not (Test-Path $path)) {
                Write-Log -Level Warning -Message "Keybindings file not found: $path"
                return
            }
            
            try {
                $imported = Get-Content $path -Raw | ConvertFrom-Json
                foreach ($prop in $imported.PSObject.Properties) {
                    $bindingData = @{
                        Key = $prop.Value.Key
                        Modifiers = $prop.Value.Modifiers
                    }
                    if ($prop.Value.PSObject.Properties.Name -contains 'KeyChar') {
                        $bindingData['KeyChar'] = $prop.Value.KeyChar
                    }
                    $this.KeyMap[$prop.Name] = $bindingData
                }
                Write-Log -Level Info -Message "Imported keybindings from: $path"
            }
            catch {
                Write-Log -Level Error -Message "Failed to import keybindings from '$path': $_"
                throw
            }
        }
    }
}
# --- END OF ORIGINAL FILE: services\keybinding-service-class\keybinding-service-class.psm1 ---


# In modules\dialog-system-class\dialog-system-class.psm1

class CommandPalette : Dialog {
    [TextBoxComponent]$inputBox
    [Table]$resultsTable
    [object[]]$allActions
    [object[]]$filteredActions

    CommandPalette() : base("CommandPalette") {
        $this.Title = "Command Palette"
        # Dynamically size the palette to be a large portion of the screen.
        $this.Width = [Math]::Floor($global:TuiState.BufferWidth * 0.6)
        $this.Height = [Math]::Floor($global:TuiState.BufferHeight * 0.7)
        
        # Get the master list of actions from the service.
        $this.allActions = @($Global:AxiomServices.ActionService.Actions)
        $this.filteredActions = $this.allActions
        
        # Create the input box for filtering.
        $this.inputBox = New-TuiTextBox -Props @{ Name = "PaletteInput"; Width = $this.Width - 4; Height = 3 }
        $this.inputBox.Move(2, 1)
        # Wire up the text box's OnChange event to our filtering method.
        $this.inputBox.OnChange = { param($NewValue) $this.FilterActions($NewValue) }
        $this.AddChild($this.inputBox)

        # Create the table to display results.
        $this.resultsTable = New-TuiTable -Props @{ Name = "PaletteResults"; Width = $this.Width - 4; Height = $this.Height - 5 }
        $this.resultsTable.Move(2, 4)
        $this.resultsTable.ShowBorder = $false
        $this.resultsTable.SetColumns(@(
            [TableColumn]::new('Name', 'Action', [Math]::Floor(($this.Width-6)*0.7)),
            [TableColumn]::new('Group', 'Group', [Math]::Floor(($this.Width-6)*0.3))
        ))
        $this.resultsTable.SetData($this.filteredActions)
        $this.AddChild($this.resultsTable)
        
        # Immediately focus the input box when the dialog is shown.
        Set-ComponentFocus -Component $this.inputBox
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # First, let the input box handle typing, backspace, etc.
        if ($this.inputBox.HandleInput($key)) {
            # The input box's OnChange event handles filtering, so we just return.
            return $true
        }
        
        # If the input box didn't handle it, we process navigation keys.
        switch ($key.Key) {
            ([ConsoleKey]::DownArrow) { $this.resultsTable.SelectNext(); return $true }
            ([ConsoleKey]::UpArrow) { $this.resultsTable.SelectPrevious(); return $true }
            ([ConsoleKey]::Enter) {
                $selectedAction = $this.resultsTable.GetSelectedItem()
                if ($selectedAction) {
                    $this.Close() # Close the palette first.
                    # Execute the ScriptBlock associated with the selected action.
                    & $selectedAction.Function.ScriptBlock
                }
                return $true
            }
        }
        # Finally, pass to the base Dialog handler for Escape key, etc.
        return ([Dialog]$this).HandleInput($key)
    }
    
    [void] FilterActions([string]$filterText) {
        if ([string]::IsNullOrWhiteSpace($filterText)) {
            $this.filteredActions = $this.allActions
        } else {
            # A simple "contains" filter. This can be upgraded to a more advanced
            # fuzzy-matching algorithm later if desired.
            $this.filteredActions = $this.allActions | Where-Object { $_.Name -like "*$filterText*" -or $_.Group -like "*$filterText*" }
        }
        $this.resultsTable.SetData($this.filteredActions)
        $this.RequestRedraw()
    }
}
# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================

# A UIElement designed to be displayed modally over other content using the
# TUI Engine's overlay system. It handles its own rendering and input,
# and uses Show-TuiOverlay/Close-TopTuiOverlay to manage its lifecycle.
class CommandPalette : Dialog {
    [TextBoxComponent]$inputBox
    [Table]$resultsTable
    [object[]]$allActions
    [object[]]$filteredActions

    CommandPalette() : base("CommandPalette") {
        $this.Title = "Command Palette"
        # Dynamically size the palette to be a large portion of the screen.
        $this.Width = [Math]::Floor($global:TuiState.BufferWidth * 0.6)
        $this.Height = [Math]::Floor($global:TuiState.BufferHeight * 0.7)
        
        # Get the master list of actions from the service.
        $this.allActions = @($Global:AxiomServices.ActionService.Actions)
        $this.filteredActions = $this.allActions
        
        # Create the input box for filtering.
        $this.inputBox = New-TuiTextBox -Props @{ Name = "PaletteInput"; Width = $this.Width - 4; Height = 3 }
        $this.inputBox.Move(2, 1)
        # Wire up the text box's OnChange event to our filtering method.
        $this.inputBox.OnChange = { param($NewValue) $this.FilterActions($NewValue) }
        $this.AddChild($this.inputBox)

        # Create the table to display results.
        $this.resultsTable = New-TuiTable -Props @{ Name = "PaletteResults"; Width = $this.Width - 4; Height = $this.Height - 5 }
        $this.resultsTable.Move(2, 4)
        $this.resultsTable.ShowBorder = $false
        $this.resultsTable.SetColumns(@(
            [TableColumn]::new('Name', 'Action', [Math]::Floor(($this.Width-6)*0.7)),
            [TableColumn]::new('Group', 'Group', [Math]::Floor(($this.Width-6)*0.3))
        ))
    }

    [void] FilterActions([string]$searchText) {
        if ([string]::IsNullOrWhiteSpace($searchText)) {
            $this.filteredActions = $this.allActions
        } else {
            $this.filteredActions = $this.allActions | Where-Object { $_.Name -like "*$searchText*" -or $_.Group -like "*$searchText*" }
        }
        $this.resultsTable.SetData($this.filteredActions)
        $this.RequestRedraw()
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender() # Call base dialog render to draw box and title
        # Render children (input box and results table)
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                if ($null -ne $child.{_private_buffer}) {
                    $this.{_private_buffer}.BlendBuffer($child.{_private_buffer}, $child.X, $child.Y)
                }
            }
        }
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # Pass input to focused child first (inputBox or resultsTable)
        foreach ($child in $this.Children) {
            if ($child.IsFocused -and $child.HandleInput($key)) {
                return $true
            }
        }

        switch ($key.Key) {
            ([ConsoleKey]::Escape) { $this.OnCancel(); return $true }
            ([ConsoleKey]::Enter) { $this.ExecuteSelectedAction(); return $true }
            ([ConsoleKey]::DownArrow) { $this.resultsTable.SelectNext(); return $true }
            ([ConsoleKey]::UpArrow) { $this.resultsTable.SelectPrevious(); return $true }
        }
        return ([Dialog]$this).HandleInput($key) # Fallback to base dialog handling
    }

    [void] ExecuteSelectedAction() {
        $selectedAction = $this.resultsTable.GetSelectedItem()
        if ($selectedAction) {
            $this.Close()
            Invoke-WithErrorHandling -Component "CommandPalette" -Context "ExecuteAction" -ScriptBlock {
                & $selectedAction.Function.ScriptBlock
            } -AdditionalData @{ ActionName = $selectedAction.Name }
        }
    }
}

# In modules\dialog-system-class\dialog-system-class.psm1



# --- END OF FULL REPLACEMENT for modules\dialog-system-class\dialog-system-class.psm1 ---

# --- START OF ORIGINAL FILE: modules/panic-handler.psm1 ---
class PanicHandler {
    static [void] Panic([Exception]$exception) {
        $crashDir = ""
        try {
            $dumpPath = Join-Path $env:TEMP "ProjectActa_Crash"
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $crashDir = Join-Path $dumpPath $timestamp
            New-Item -ItemType Directory -Path $crashDir -Force | Out-Null

            $stateDump = @{
                Reason = $exception.Message
                ExceptionType = $exception.GetType().FullName
                StackTrace = $exception.StackTrace
                Timestamp = $timestamp
                PSVersion = (Get-Host).Version.ToString()
                CurrentScreen = $global:TuiState.CurrentScreen.Name
            }
            $stateDump | ConvertTo-Json -Depth 5 | Set-Content (Join-Path $crashDir "crash.json")

            # Attempt to take a screenshot of the last valid buffer state
            if ($global:TuiState.CompositorBuffer) {
                $sb = [System.Text.StringBuilder]::new()
                for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
                    for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                        $sb.Append($global:TuiState.CompositorBuffer.GetCell($x, $y).Char)
                    }
                    $sb.AppendLine()
                }
                $sb.ToString() | Set-Content (Join-Path $crashDir "screen.txt")
            }
        } catch { /* Suppress errors during panic */ }
        finally {
            # Attempt to restore the terminal to a usable state.
            [Console]::Write("`e[0m`e[2J`e[H")
            [Console]::ResetColor()
            [Console]::CursorVisible = $true
            Write-Host "FATAL ERROR: A critical, unhandled exception occurred." -ForegroundColor Red
            Write-Host "A crash dump has been saved to: $crashDir" -ForegroundColor Yellow
            exit 1
        }
    }
}
# --- END OF ORIGINAL FILE ---


# --- START OF ORIGINAL FILE for screens\dashboard-screen\dashboard-screen.psm1 ---
# ==============================================================================
# Project Acta - Widget-Based Dashboard Screen
# A modern dashboard that hosts various informational widgets. Each widget is a
# self-contained component that pulls its own data and renders into its area.
# ==============================================================================

# First, define the new widget components. These are specialized, data-aware panels.
class UpcomingTasksWidget : Panel {
    hidden [object[]] $_cachedTasks = @()
    hidden [string] $_eventSubscriptionId

    UpcomingTasksWidget([string]$name) : base($name) { 
        $this.Title = "Up Next"
        $self = $this
        $this._eventSubscriptionId = Subscribe-Event -EventName "Tasks.Changed" -Handler { $self.RefreshData() } -Source $this.Name
    }

    [void] OnCleanup() {
        # On cleanup, unsubscribe from the event to prevent memory leaks.
        if ($this._eventSubscriptionId) { Unsubscribe-Event -HandlerId $this._eventSubscriptionId }
    }

    [void] RefreshData() {
        if ($null -eq $this.Parent) { return }
        $tasks = $this.Parent.Services.DataManager.GetTasks($false) # Get only pending tasks
        $this._cachedTasks = $tasks | Sort-Object { $_.DueDate ?? [datetime]::MaxValue } | Select-Object -First ($this.ContentHeight)
        $this.RequestRedraw()
    }
    
    [void] OnRender() {
        # First, apply the theme style and call the base Panel's OnRender to draw our box and title.
        $this.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.UpNext")
        ([Panel]$this).OnRender()

        $style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Text.Default")
        $overdueStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Text.Overdue")
        
        $y = 0
        foreach($task in $this._cachedTasks) {
            $currentStyle = $style
            $dateText = if ($task.DueDate) { $task.DueDate.Value.ToString("yyyy-MM-dd") } else { "No Date" }
            if ($task.DueDate -and $task.DueDate.Value.Date -lt (Get-Date).Date) {
                $currentStyle = $overdueStyle
                $dateText += " (OVERDUE)"
            }
            # Construct a clean, padded line for display.
            $titlePadded = $task.Title.PadRight($this.ContentWidth - 25)
            $priorityPadded = "[$($task.Priority.ToString().PadRight(6))]"
            $line = "$titlePadded $priorityPadded $dateText"
            
            Write-TuiText -Buffer $this._private_buffer -X $this.ContentX -Y ($this.ContentY + $y) -Text $line -Style $currentStyle
            $y++
        }
    }
}

class StatsWidget : Panel {
    hidden [hashtable] $_cachedStats = @{}
    hidden [string] $_eventSubscriptionId

    StatsWidget([string]$name) : base($name) { 
        $this.Title = "Project Stats"
        $self = $this
        $this._eventSubscriptionId = Subscribe-Event -EventName "Tasks.Changed" -Handler { $self.RefreshData() } -Source $this.Name
    }

    [void] OnCleanup() {
        if ($this._eventSubscriptionId) { Unsubscribe-Event -HandlerId $this._eventSubscriptionId }
    }

    [void] RefreshData() {
        if ($null -eq $this.Parent) { return }
        $tasks = $this.Parent.Services.DataManager.GetTasks()
        if ($tasks.Count -eq 0) { $this._cachedStats = @{ Total = 0; Completed = 0 } }
        else {
            $completed = ($tasks | Where-Object { $_.Completed }).Count
            $this._cachedStats = @{ Total = $tasks.Count; Completed = $completed }
        }
        $this.RequestRedraw()
    }

    [void] OnRender() {
        $this.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Stats")
        ([Panel]$this).OnRender()
        
        $tasks = $this._cachedStats
        if ($tasks.Total -eq 0) {
            Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 1) -Text "No task data available."
            return
        }

        $completed = $tasks.Completed
        $percentage = [Math]::Round(($completed / $tasks.Total) * 100)
        
        $barLength = $this.ContentWidth - 4
        $filledLength = [Math]::Round(($percentage / 100) * $barLength)
        $bar = ("█" * $filledLength) + ("░" * ($barLength - $filledLength))

        Write-TuiText -Buffer $this.{_private_buffer} -X ($this.ContentX + 1) -Y ($this.ContentY + 1) -Text "Overall Progress: $percentage%" -Style $this.Style
        Write-TuiText -Buffer $this.{_private_buffer} -X ($this.ContentX + 1) -Y ($this.ContentY + 3) -Text $bar -Style @{ FG = '#3fb950' }
        Write-TuiText -Buffer $this.{_private_buffer} -X ($this.ContentX + 1) -Y ($this.ContentY + 5) -Text "Total Tasks: $($tasks.Total)" -Style $this.Style
        Write-TuiText -Buffer $this.{_private_buffer} -X ($this.ContentX + 1) -Y ($this.ContentY + 6) -Text "Completed:   $completed" -Style $this.Style
    }
}

# The main screen class itself is now a simple layout container for widgets.
class DashboardScreen : Screen {
    [System.Collections.Generic.List[UIElement]]$Widgets
    
    DashboardScreen([hashtable]$services) : base("DashboardScreen", $services) { }

    [void] Initialize() {
        $this.Width = $global:TuiState.BufferWidth
        $this.Height = $global:TuiState.BufferHeight
        $this.Widgets = [System.Collections.Generic.List[UIElement]]::new()
        
        # Create and add widgets to the screen's children for rendering.
        # The layout is declarative.
        $upNextWidget = [UpcomingTasksWidget]::new("UpNext")
        $upNextWidget.Move(1, 1); $upNextWidget.Resize([Math]::Floor($this.Width * 0.6), 12)
        $this.AddChild($upNextWidget)
        $this.Widgets.Add($upNextWidget)
        
        $statsWidget = [StatsWidget]::new("QuickStats")
        $statsWidget.Move($upNextWidget.X + $upNextWidget.Width + 1, 1); $statsWidget.Resize($this.Width - $upNextWidget.Width - 4, 12)
        $this.AddChild($statsWidget)


function Get-WordWrappedLines {
    param([string]$Text, [int]$MaxWidth)
    $lines = @(); $words = $Text -split '\s+'; $currentLine = ""
    foreach ($word in $words) {
        if ($currentLine.Length -eq 0) { $currentLine = $word } 
        elseif (($currentLine.Length + 1 + $word.Length) -le $MaxWidth) { $currentLine += " " + $word } 
        else { $lines += $currentLine; $currentLine = $word }
    }
    if ($currentLine.Length -gt 0) { $lines += $currentLine }
    return $lines
}

function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        Subscribe-Event -EventName "Confirm.Request" -Handler { param($EventData) $params = $EventData.Data; Show-ConfirmDialog @params }
        Subscribe-Event -EventName "Alert.Show" -Handler { param($EventData) $params = $EventData.Data; Show-AlertDialog @params }
        Subscribe-Event -EventName "Input.Request" -Handler { param($EventData) $params = $EventData.Data; Show-InputDialog @params }
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

function Show-AlertDialog { param([string]$Title="Alert", [string]$Message); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock { ([AlertDialog]::new($Title, $Message)).Show() } }
function Show-ConfirmDialog { param([string]$Title="Confirm", [string]$Message, [scriptblock]$OnConfirm, [scriptblock]$OnCancel={}); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock { ([ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)).Show() } }
function Show-InputDialog { param([string]$Title="Input", [string]$Prompt, [string]$DefaultValue="", [scriptblock]$OnSubmit, [scriptblock]$OnCancel={}); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock { $d = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel); if ($DefaultValue) { $d.SetDefaultValue($DefaultValue) }; $d.Show() } }
function Show-ProgressDialog { param([string]$Title="Progress", [string]$Message="Processing...", [int]$PercentComplete=0, [switch]$ShowCancel); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock { $d = [ProgressDialog]::new($Title, $Message); $d.PercentComplete = $PercentComplete; $d.ShowCancel = $ShowCancel; $d.Show(); return $d } }
function Show-ListDialog { param([string]$Title="Select Item", [string]$Prompt="Choose an item:", [string[]]$Items, [scriptblock]$OnSelect, [scriptblock]$OnCancel={}, [switch]$AllowMultiple); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock { $d = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel); $d.AllowMultiple = $AllowMultiple; $d.Show() } }
function Close-TuiDialog { Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock { Close-TopTuiOverlay } }

# --- END OF FULL REPLACEMENT for modules\dialog-system-class\dialog-system-class.psm1 ---

# --- START OF ORIGINAL FILE: modules/panic-handler.psm1 ---
class PanicHandler {
    static [void] Panic([Exception]$exception) {
        $crashDir = ""
        try {
            $dumpPath = Join-Path $env:TEMP "ProjectActa_Crash"
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $crashDir = Join-Path $dumpPath $timestamp
            New-Item -ItemType Directory -Path $crashDir -Force | Out-Null

            $stateDump = @{
                Reason = $exception.Message
                ExceptionType = $exception.GetType().FullName
                StackTrace = $exception.StackTrace
                Timestamp = $timestamp
                PSVersion = (Get-Host).Version.ToString()
                CurrentScreen = $global:TuiState.CurrentScreen.Name
            }
            $stateDump | ConvertTo-Json -Depth 5 | Set-Content (Join-Path $crashDir "crash.json")

            # Attempt to take a screenshot of the last valid buffer state
            if ($global:TuiState.CompositorBuffer) {
                $sb = [System.Text.StringBuilder]::new()
                for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
                    for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                        $sb.Append($global:TuiState.CompositorBuffer.GetCell($x, $y).Char)
                    }
                    $sb.AppendLine()
                }
                $sb.ToString() | Set-Content (Join-Path $crashDir "screen.txt")
            }
        } catch { /* Suppress errors during panic */ }
        finally {
            # Attempt to restore the terminal to a usable state.
            [Console]::Write("`e[0m`e[2J`e[H")
            [Console]::ResetColor()
            [Console]::CursorVisible = $true
            Write-Host "FATAL ERROR: A critical, unhandled exception occurred." -ForegroundColor Red
            Write-Host "A crash dump has been saved to: $crashDir" -ForegroundColor Yellow
            exit 1
        }
    }
}
# --- END OF ORIGINAL FILE ---


# --- START OF ORIGINAL FILE for screens\dashboard-screen\dashboard-screen.psm1 ---
# ==============================================================================
# Project Acta - Widget-Based Dashboard Screen
# A modern dashboard that hosts various informational widgets. Each widget is a
# self-contained component that pulls its own data and renders into its area.
# ==============================================================================

# First, define the new widget components. These are specialized, data-aware panels.
class UpcomingTasksWidget : Panel {
    hidden [object[]] $_cachedTasks = @()
    hidden [string] $_eventSubscriptionId

    UpcomingTasksWidget([string]$name) : base($name) { 
        $this.Title = "Up Next"
        $self = $this
        $this._eventSubscriptionId = Subscribe-Event -EventName "Tasks.Changed" -Handler { $self.RefreshData() } -Source $this.Name
    }

    [void] OnCleanup() {
        # On cleanup, unsubscribe from the event to prevent memory leaks.
        if ($this._eventSubscriptionId) { Unsubscribe-Event -HandlerId $this._eventSubscriptionId }
    }

    [void] RefreshData() {
        if ($null -eq $this.Parent) { return }
        $tasks = $this.Parent.Services.DataManager.GetTasks($false) # Get only pending tasks
        $this._cachedTasks = $tasks | Sort-Object { $_.DueDate ?? [datetime]::MaxValue } | Select-Object -First ($this.ContentHeight)
        $this.RequestRedraw()
    }
    
    [void] OnRender() {
        # First, apply the theme style and call the base Panel's OnRender to draw our box and title.
        $this.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.UpNext")
        ([Panel]$this).OnRender()

        $style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Text.Default")
        $overdueStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Text.Overdue")
        
        $y = 0
        foreach($task in $this._cachedTasks) {
            $currentStyle = $style
            $dateText = if ($task.DueDate) { $task.DueDate.Value.ToString("yyyy-MM-dd") } else { "No Date" }
            if ($task.DueDate -and $task.DueDate.Value.Date -lt (Get-Date).Date) {
                $currentStyle = $overdueStyle
                $dateText += " (OVERDUE)"
            }
            # Construct a clean, padded line for display.
            $titlePadded = $task.Title.PadRight($this.ContentWidth - 25)
            $priorityPadded = "[$($task.Priority.ToString().PadRight(6))]"
            $line = "$titlePadded $priorityPadded $dateText"
            
            Write-TuiText -Buffer $this._private_buffer -X $this.ContentX -Y ($this.ContentY + $y) -Text $line -Style $currentStyle
            $y++
        }
    }
}

class StatsWidget : Panel {
    hidden [hashtable] $_cachedStats = @{}
    hidden [string] $_eventSubscriptionId

    StatsWidget([string]$name) : base($name) { 
        $this.Title = "Project Stats"
        $self = $this
        $this._eventSubscriptionId = Subscribe-Event -EventName "Tasks.Changed" -Handler { $self.RefreshData() } -Source $this.Name
    }

    [void] OnCleanup() {
        if ($this._eventSubscriptionId) { Unsubscribe-Event -HandlerId $this._eventSubscriptionId }
    }

    [void] RefreshData() {
        if ($null -eq $this.Parent) { return }
        $tasks = $this.Parent.Services.DataManager.GetTasks()
        if ($tasks.Count -eq 0) { $this._cachedStats = @{ Total = 0; Completed = 0 } }
        else {
            $completed = ($tasks | Where-Object { $_.Completed }).Count
            $this._cachedStats = @{ Total = $tasks.Count; Completed = $completed }
        }
        $this.RequestRedraw()
    }

    [void] OnRender() {
        $this.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Stats")
        ([Panel]$this).OnRender()
        
        $tasks = $this._cachedStats
        if ($tasks.Total -eq 0) {
            Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 1) -Text "No task data available."
            return
        }

        $completed = $tasks.Completed
        $percentage = [Math]::Round(($completed / $tasks.Total) * 100)
        
        $barLength = $this.ContentWidth - 4
        $filledLength = [Math]::Round(($percentage / 100) * $barLength)
        $bar = ("█" * $filledLength) + ("░" * ($barLength - $filledLength))

        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 1) -Text "Overall Progress: $percentage%" -Style $this.Style
        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 3) -Text $bar -Style @{ FG = '#3fb950' }
        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 5) -Text "Total Tasks: $($tasks.Total)" -Style $this.Style
        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 6) -Text "Completed:   $completed" -Style $this.Style
    }
}

# The main screen class itself is now a simple layout container for widgets.
class DashboardScreen : Screen {
    [System.Collections.Generic.List[UIElement]]$Widgets
    
    DashboardScreen([hashtable]$services) : base("DashboardScreen", $services) { }

    [void] Initialize() {
        $this.Width = $global:TuiState.BufferWidth
        $this.Height = $global:TuiState.BufferHeight
        $this.Widgets = [System.Collections.Generic.List[UIElement]]::new()
        
        # Create and add widgets to the screen's children for rendering.
        # The layout is declarative.
        $upNextWidget = [UpcomingTasksWidget]::new("UpNext")
        $upNextWidget.Move(1, 1); $upNextWidget.Resize([Math]::Floor($this.Width * 0.6), 12)
        $this.AddChild($upNextWidget)
        $this.Widgets.Add($upNextWidget)
        
        $statsWidget = [StatsWidget]::new("QuickStats")
        $statsWidget.Move($upNextWidget.X + $upNextWidget.Width + 1, 1); $statsWidget.Resize($this.Width - $upNextWidget.Width - 4, 12)
        $this.AddChild($statsWidget)
        $this.Widgets.Add($statsWidget)
        
        # Add a placeholder for a future log widget.
        $logPanel = [Panel]::new(1, 14, $this.Width - 2, $this.Height - 15, "Recent Log Entries")
        $logPanel.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Panel")
        $this.AddChild($logPanel)
    }
    
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # When the screen resizes, recalculate the layout of its children.
        $upNext = $this.Children.Find({$_.Name -eq 'UpNext'})
        $stats = $this.Children.Find({$_.Name -eq 'QuickStats'})
        
        $upNextWidth = [Math]::Floor($newWidth * 0.6)
        $upNext.Resize($upNextWidth, 12)
        
        $stats.Move($upNext.X + $upNext.Width + 1, 1)
        $stats.Resize($newWidth - $upNext.Width - 4, 12)
    }

    [void] OnEnter() {
        # Manually trigger a refresh the first time the screen is shown.
        foreach($child in $this.Children) {
            if ($child.GetType().GetMethod("RefreshData")) { $child.RefreshData() }
        }
    }

    # Input is now handled by the command palette (Ctrl+P), so this method is empty.
    # The screen itself doesn't need to handle any keys.
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) { 
        return $false 
    }
}
# --- END OF ORIGINAL FILE for screens\dashboard-screen\dashboard-screen.psm1 ---

# --- START OF ORIGINAL FILE for screens\task-flow-screen\task-flow-screen.psm1 ---
# ==============================================================================
# Project Acta - Task Flow (Kanban) Screen
# Visual, interactive task board for managing workflow. This screen provides a
# more intuitive way to view and manage task progression than a simple list.
# ==============================================================================

# Define simple data models for the board's structure. These are view-models,
# not the core PmcTask model.
class KanbanCard { [string]$Id; [string]$Title; [string]$Priority; [object]$Data }
class KanbanColumn { [string]$Title; [System.Collections.Generic.List[KanbanCard]]$Cards }

# This is a complex, interactive component that renders a horizontally scrollable Kanban board.
class KanbanBoardComponent : ScrollablePanel {
    [KanbanColumn[]]$Columns
    [int]$SelectedColumn = 0
    [int]$SelectedCard = 0

    KanbanBoardComponent([string]$name) : base($name) {
        $this.Name = $name
        $this.Columns = @()
        $this.IsFocusable = $true
    }

    # Populates the component with data transformed from the DataManager.
    [void] SetData([PmcTask[]]$tasks) {
        # Initialize columns with empty card lists
        $this.Columns = @(
            [KanbanColumn]@{ Title="Pending"; Cards = [System.Collections.Generic.List[KanbanCard]]::new() };
            [KanbanColumn]@{ Title="In Progress"; Cards = [System.Collections.Generic.List[KanbanCard]]::new() };
            [KanbanColumn]@{ Title="Completed"; Cards = [System.Collections.Generic.List[KanbanCard]]::new() };
            [KanbanColumn]@{ Title="Cancelled"; Cards = [System.Collections.Generic.List[KanbanCard]]::new() }
        )

        # Create a lookup for columns by title for efficient card assignment
        $columnLookup = @{}
        foreach ($col in $this.Columns) {
            $columnLookup[$col.Title.Replace(" ", "")] = $col.Cards # Use title without spaces for lookup
        }

        foreach ($task in $tasks) {
            $card = [KanbanCard]@{ Id = $task.Id; Title = $task.Title; Priority = $task.Priority.ToString(); Data = $task }
            $statusString = $task.Status.ToString() # e.g., "Pending", "InProgress"

            if ($columnLookup.ContainsKey($statusString)) {
                $columnLookup[$statusString].Add($card)
            } else {
                Write-Log -Level Warning -Message "Task status '$statusString' does not map to a Kanban column."
            }
        }
        
        $this.VirtualWidth = $this.Columns.Count * 31 # 30 for column width, 1 for margin
        $this.VirtualHeight = 30 # An arbitrary large virtual height
        $this.RequestRedraw()
    }
    
    [void] OnRender() {
        # This component renders to the virtual buffer provided by its parent ScrollablePanel class.
        $buffer = $this.GetVirtualBuffer()
        if ($null -eq $buffer) { return }
        $buffer.Clear()
        
        $colStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Kanban.Column")
        $cardStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Kanban.Card")
        $cardSelectedStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Kanban.CardSelected")

        $xOffset = 0
        for ($c = 0; $c -lt $this.Columns.Count; $c++) {
            $column = $this.Columns[$c]
            # Draw the column container box.
            Write-TuiBox -Buffer $buffer -X $xOffset -Y 0 -Width 30 -Height ($this.VirtualHeight -1) -Title "$($column.Title) ($($column.Cards.Count))" -Style $colStyle

            $yOffset = 1
            for ($r = 0; $r -lt $column.Cards.Count; $r++) {
                if ($yOffset + 4-gt $this.VirtualHeight) { break } # Don't draw past virtual height
                $card = $column.Cards[$r]
                
                # Determine the style based on focus and selection state.
                $styleToUse = if($c -eq $this.SelectedColumn -and $r -eq $this.SelectedCard -and $this.IsFocused) { $cardSelectedStyle } else { $cardStyle }
                
                # Draw the card as a smaller box within the column.
                $cardTitle = "$($card.Title) [$($card.Priority)]".PadRight(26).Substring(0, 26)
                Write-TuiBox -Buffer $buffer -X ($xOffset+1) -Y $yOffset -Width 28 -Height 3 -Title $cardTitle -Style $styleToUse
                $yOffset += 4
            }
            $xOffset += 31 # Move to the next column position.
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        $colCount = $this.Columns.Count
        if ($colCount -eq 0) { return $false }
        $cardCount = $this.Columns[$this.SelectedColumn].Cards.Count
        
        $navigated = $true
        switch ($keyInfo.Key) {
            ([ConsoleKey]::RightArrow) {
                if ($this.SelectedColumn -lt $colCount - 1) { $this.SelectedColumn++; $this.SelectedCard = 0 }
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this.SelectedColumn-gt 0) { $this.SelectedColumn--; $this.SelectedCard = 0 }
            }
            ([ConsoleKey]::DownArrow) {
                if ($cardCount-gt 0 -and $this.SelectedCard -lt $cardCount - 1) { $this.SelectedCard++ }
            }
            ([ConsoleKey]::UpArrow) {
                if ($cardCount-gt 0 -and $this.SelectedCard-gt 0) { $this.SelectedCard-- }
            }
            default { $navigated = $false }
        }
        
        if ($navigated) { $this.RequestRedraw(); return $true }
        
        # Pass unhandled keys (like PageUp/Down) to the parent ScrollablePanel for scrolling.
        return ([ScrollablePanel]$this).HandleInput($keyInfo)
    }
}

# The screen class is a simple host for the Kanban board.
class TaskFlowScreen : Screen {
    [KanbanBoardComponent]$kanbanBoard

    TaskFlowScreen([hashtable]$services) : base("TaskFlowScreen", $services) { }

    [void] Initialize() {
        $this.kanbanBoard = [KanbanBoardComponent]::new("TaskKanban")
        $this.AddChild($this.kanbanBoard)
        $this.kanbanBoard.Resize($this.Width, $this.Height)
        $this.kanbanBoard.HasBorder = $false # The screen is the main container.
    }
    
    [void] OnEnter() {
        # When the screen is entered, fetch fresh data and populate the component.
        $tasks = $this.Services.DataManager.GetTasks()
        $this.kanbanBoard.SetData($tasks)
        Set-ComponentFocus -Component $this.kanbanBoard
    }
}
# --- END OF ORIGINAL FILE for screens\task-flow-screen\task-flow-screen.psm1 ---

# --- START OF ORIGINAL FILE for screens\explorer-screen\explorer-screen.psm1 ---
class ExplorerScreen : Screen {
    [Panel]$mainPanel
    [FileListComponent]$fileList
    [Panel]$previewPanel
    [Panel]$statusBar

    ExplorerScreen([hashtable]$services) : base("ExplorerScreen", $services) { }

    [void] Initialize() {
        $this.Width = $global:TuiState.BufferWidth
        $this.Height = $global:TuiState.BufferHeight

        # Layout the panels for the screen
        $listWidth = [Math]::Floor($this.Width * 0.5)
        
        $listPanel = [Panel]::new(1, 1, $listWidth, $this.Height - 4, "Files")
        $listPanel.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Panel")
        $this.AddChild($listPanel)
        
        $this.previewPanel = [Panel]::new($listPanel.X + $listPanel.Width, 1, $this.Width - $listPanel.Width - 2, $this.Height - 4, "Preview")
        $this.previewPanel.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Panel")
        $this.AddChild($this.previewPanel)
        
        $this.statusBar = [Panel]::new(1, $this.Height - 2, $this.Width - 2, 1)
        $this.statusBar.HasBorder = $false
        $this.AddChild($this.statusBar)

        # Create the file list component and add it to its containing panel.
        $this.fileList = [FileListComponent]::new("ExplorerFileList")
        # The component must be sized to fit within the panel's content area.
        $this.fileList.Resize($listPanel.ContentWidth, $listPanel.ContentHeight)
        $listPanel.AddChild($this.fileList)
    }

    [void] OnEnter() {
        # Set a starting path when the screen is entered.
        $this.fileList.SetPath((Get-Location).Path)
        Set-ComponentFocus -Component $this.fileList
        $this.UpdateStatusBar("Ctrl+P for commands | Enter to navigate/open")
        $this.fileList.add_RequestRedraw({ $this.OnSelectionChange() })
    }
    
    # This screen handles the "Enter" key, which has meaning outside the FileListComponent.
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($keyInfo.Key -eq [ConsoleKey]::Enter) {
            $selectedItem = $this.fileList.Items[$this.fileList.SelectedIndex]
            if ($selectedItem.PSIsContainer) {
                # If it's a directory, navigate the component into it.
                $this.fileList.SetPath($selectedItem.FullName)
            } else {
                # If it's a file, perhaps open it externally or show a full-screen preview.
                Show-AlertDialog -Title "Action" -Message "Action for file '$($selectedItem.Name)' is not yet implemented."
            }
            return $true # We handled the 'Enter' key.
        }
        # Let the TUI engine pass input to the focused component (the file list) for navigation.
        return $false
    }
    
    # Event handler for when the file list selection changes.
    [void] OnSelectionChange() {
        $selectedItem = $this.fileList.Items[$this.fileList.SelectedIndex]
        $this.UpdateStatusBar("Path: $($this.fileList.Path)")
        $this.ShowFilePreview($selectedItem)
    }
    
    [void] UpdateStatusBar([string]$text) {
        $this.statusBar.GetBuffer().Clear()
        Write-TuiText -Buffer $this.statusBar.GetBuffer() -X 0 -Y 0 -Text $text -Style @{ FG = "#a0a0a0" }
        $this.statusBar.RequestRedraw()
    }
    
    [void] ShowFilePreview([System.IO.FileSystemInfo]$file) {
        $this.previewPanel.SetTitle("Preview: $($file.Name)")
        $this.previewPanel.ClearContent()
        
        if ($file.PSIsContainer) { return } # No preview for directories.

        # HARDENING: Reading large files synchronously will block the UI.
        # This preview should be limited to a few KB or made asynchronous.
        try {
            $content = Get-Content -Path $file.FullName -TotalCount $this.previewPanel.ContentHeight -ErrorAction Stop
            for ($i = 0; $i -lt $content.Count; $i++) {
                $line = $content[$i].Replace("`t", '    ') # Expand tabs
                Write-TuiText -Buffer $this.previewPanel.GetBuffer() -X $this.previewPanel.ContentX -Y ($this.previewPanel.ContentY + $i) -Text $line -Style @{ FG = "#D4D4D4" }
            }
        } catch {
            Write-TuiText -Buffer $this.previewPanel.GetBuffer() -X $this.previewPanel.ContentX -Y $this.previewPanel.ContentY -Text "Error reading file: Not a text file or access denied." -Style @{ FG = "#f85149" }
        }
        $this.previewPanel.RequestRedraw()
    }
}
# --- END OF ORIGINAL FILE for screens\explorer-screen\explorer-screen.psm1 ---


# --- START OF ORIGINAL FILE for screens/timesheet-screen.psm1 ---
class TimeSheetScreen : Screen {
    [Table]$summaryTable

    TimeSheetScreen([hashtable]$services) : base("TimeSheetScreen", $services) {}

    [void] Initialize() {
        $this.summaryTable = New-TuiTable -Props @{ 
            Name = "TimeSheetSummary"
            Width = $this.Width
            Height = $this.Height
            ShowHeader = $true
            ShowBorder = $true
        }
        $this.summaryTable.Title = "Weekly Time Summary by Project"
        
        $this.summaryTable.SetColumns(@(
            [TableColumn]::new('Project', 'Project', 40),
            [TableColumn]::new('TotalHours', 'Total Hours (This Week)', 25)
        ))
        $this.AddChild($this.summaryTable)
    }

    [void] OnEnter() {
        # The screen asks the service for data and passes it to the UI component.
        # The screen itself does not understand the data's structure.
        $summary = $this.Services.TimeSheetService.GetWeeklySummary()
        $this.summaryTable.SetData($summary)
        $this.RequestRedraw()
    }
}

# Add an action to the Command Palette that uses the TimeSheetService.

function Export-WeeklyTimeSheet {
    # This action is pure logic; it knows nothing about the current screen.
    $timeSheetService = $Global:AxiomServices.TimeSheetService
    
    $tsvContent = $timeSheetService.GetWeeklySummaryAsTsv()
    
    if ([string]::IsNullOrWhiteSpace($tsvContent)) {
        Show-AlertDialog -Title "Export" -Message "No data available to export for the past 7 days."
        return
    }

    try {
        $desktopPath = [Environment]::GetFolderPath('Desktop')
        $fileName = "ProjectActa-TimeSheet-$(Get-Date -Format 'yyyyMMdd').tsv"
        $filePath = Join-Path $desktopPath $fileName
        
        Set-Content -Path $filePath -Value $tsvContent -Encoding UTF8
        
        Show-AlertDialog -Title "Export Complete" -Message "Weekly summary has been exported to:`n$filePath"
    } catch {
        Write-Log -Level Error -Message "Failed to export timesheet: $_"
        Show-AlertDialog -Title "Export Error" -Message "Could not write the export file to the desktop.`nPlease check permissions."
    }
}
# --- END OF ORIGINAL FILE for screens/timesheet-screen.psm1 ---


# --- START OF ORIGINAL FILE for commands/global-commands.psm1 ---
# This file contains globally available actions for the Command Palette.
# Each function is decorated with the [Action] attribute to make it discoverable.

function Request-AppQuit {
    $Global:AxiomServices.Navigation.RequestExit()
}

function Request-UIRefresh {
    # This forces a full, non-differential render of the entire screen.
    $global:TuiState.RenderStats.FrameCount = 1
    Request-TuiRefresh
}

function Navigate-ToDashboard {
    $Global:AxiomServices.Navigation.GoTo("/dashboard")
}

function Navigate-ToFileExplorer {
    $Global:AxiomServices.Navigation.GoTo("/explorer")
}

function Cycle-Theme {
    $engine = $Global:AxiomServices.ThemeEngine
    $themes = $engine.GetThemeKeys()
    if ($themes.Count -lt 2) { return } # No cycling if only one theme.
    
    $currentIndex = [array]::IndexOf($themes, $engine._currentThemeKey)
    $nextIndex = ($currentIndex + 1) % $themes.Count
    $engine.SetTheme($themes[$nextIndex])
    
    # Force a full redraw to apply the new theme everywhere.
    $global:TuiState.RenderStats.FrameCount = 1
    Request-TuiRefresh
}
# --- END OF ORIGINAL FILE for commands/global-commands.psm1 ---


# --- START OF ORIGINAL FILE: services\navigation-service-class\navigation-service-class.psm1 ---
# navigation-service-class.psm1
# Contains only the NavigationService and ScreenFactory class definitions.



class ScreenFactory {
    hidden [hashtable] $Services
    hidden [hashtable] $ScreenTypes = @{}
    
    ScreenFactory([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        Write-Log -Level Debug -Message "ScreenFactory initialized"
    }
    
    [void] RegisterScreen([string]$name, [type]$screenType) {
        if (-not ($screenType -eq [Screen] -or $screenType.IsSubclassOf([Screen]))) { 
            throw "Screen type '$($screenType.Name)' must inherit from the Screen class." 
        }
        $this.ScreenTypes[$name] = $screenType
        Write-Log -Level Info -Message "Registered screen factory: $name -> $($screenType.Name)"
    }
    
    [Screen] CreateScreen([string]$screenName, [hashtable]$parameters) {
        $screenType = $this.ScreenTypes[$screenName]
        if (-not $screenType) {
            throw "Unknown screen type: '$screenName'. Available screens: $($this.ScreenTypes.Keys -join ', ')"
        }
        
        try {
            $screen = $screenType::new($this.Services)
            if ($parameters) {
                foreach ($key in $parameters.Keys) { 
                    $screen.State[$key] = $parameters[$key] 
                }
            }
            Write-Log -Level Info -Message "Created screen: $screenName"
            return $screen
        } catch {
            Write-Log -Level Error -Message "Failed to create screen '$screenName': $($_.Exception.Message)"
            throw
        }
    }
    
    [string[]] GetRegisteredScreens() {
        return @($this.ScreenTypes.Keys)
    }
}

class NavigationService {
    [System.Collections.Generic.Stack[Screen]] $ScreenStack
    [ScreenFactory] $ScreenFactory
    [Screen] $CurrentScreen
    [hashtable] $Services
    [hashtable] $RouteMap = @{}
    
    NavigationService([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        $this.ScreenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.ScreenFactory = [ScreenFactory]::new($services)
        $this.InitializeRoutes()
        Write-Log -Level Info -Message "NavigationService initialized"
    }
    
    hidden [void] InitializeRoutes() {
        $this.RouteMap = @{
            "/" = "DashboardScreen"
            "/dashboard" = "DashboardScreen"
            "/tasks" = "TaskListScreen"
        }
        Write-Log -Level Debug -Message "Routes initialized: $($this.RouteMap.Keys -join ', ')"
    }
    
    [void] RegisterScreenClass([string]$name, [type]$screenType) {
        $this.ScreenFactory.RegisterScreen($name, $screenType)
    }
    
    [void] GoTo([string]$path, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "GoTo:$path" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) { 
                throw [System.ArgumentException]::new("Path cannot be empty.") 
            }
            if ($path -eq "/exit") { 
                $this.RequestExit()
                return 
            }
            
            $screenName = $this.RouteMap[$path]
            if (-not $screenName) {
                $availableRoutes = $this.RouteMap.Keys -join ', '
                throw "Unknown route: '$path'. Available routes: $availableRoutes"
            }
            
            Write-Log -Level Info -Message "Navigating to: $path ->  $screenName"
            $this.PushScreen($screenName, $parameters)
        }
    }
    
    [void] PushScreen([string]$screenName, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "PushScreen:$screenName" -ScriptBlock {
            Write-Log -Level Info -Message "Pushing screen: $screenName"
            
            if ($this.CurrentScreen) {
                Write-Log -Level Debug -Message "Exiting current screen: $($this.CurrentScreen.Name)"
                $this.CurrentScreen.OnExit()
                $this.ScreenStack.Push($this.CurrentScreen)
            }
            
            Write-Log -Level Debug -Message "Creating new screen: $screenName"
            $newScreen = $this.ScreenFactory.CreateScreen($screenName, $parameters)
            $this.CurrentScreen = $newScreen
            
            Write-Log -Level Debug -Message "Initializing screen: $screenName"
            $newScreen.Initialize()
            $newScreen.OnEnter()
            
            if (Get-Command "Push-Screen" -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Pushing screen to TUI engine"
                Push-Screen -Screen $newScreen
            } else {
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $newScreen
                    Request-TuiRefresh
                }
            }
            
            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{ Screen = $screenName; Action = "Push" }
            Write-Log -Level Info -Message "Successfully pushed screen: $screenName"
        }
    }
    
    [bool] PopScreen() {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "PopScreen" -ScriptBlock {
            if ($this.ScreenStack.Count -eq 0) { 
                Write-Log -Level Warning -Message "Cannot pop screen: stack is empty"
                return $false 
            }
            
            Write-Log -Level Info -Message "Popping screen"
            $this.CurrentScreen?.OnExit()
            $this.CurrentScreen = $this.ScreenStack.Pop()
            $this.CurrentScreen?.OnResume()
            
            if (Get-Command "Pop-Screen" -ErrorAction SilentlyContinue) {
                Pop-Screen
            } else {
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $this.CurrentScreen
                    Request-TuiRefresh
                }
            }
            
            Publish-Event -EventName "Navigation.ScreenPopped" -Data @{ Screen = $this.CurrentScreen.Name }
            return $true
        }
    }
    
    [void] RequestExit() {
        Write-Log -Level Info -Message "Exit requested"
        while ($this.PopScreen()) {} # Pop all screens
        $this.CurrentScreen?.OnExit()
        if (Get-Command "Stop-TuiEngine" -ErrorAction SilentlyContinue) {
            Stop-TuiEngine
        }
        Publish-Event -EventName "Application.Exit"
    }
    
    [Screen] GetCurrentScreen() { return $this.CurrentScreen }
    [bool] IsValidRoute([string]$path) { return $this.RouteMap.ContainsKey($path) }
    
    [void] ListRegisteredScreens() {
        $screens = $this.ScreenFactory.GetRegisteredScreens()
        Write-Log -Level Info -Message "Registered screens: $($screens -join ', ')"
        Write-Host "Registered screens: $($screens -join ', ')" -ForegroundColor Green
    }
    
    [void] ListAvailableRoutes() {
        $routes = $this.RouteMap.Keys
        Write-Log -Level Info -Message "Available routes: $($routes -join ', ')"
        Write-Host "Available routes: $($routes -join ', ')" -ForegroundColor Green
    }
}
# --- END OF ORIGINAL FILE: services\navigation-service-class\navigation-service-class.psm1 ---


# --- START OF REPLACEMENT BLOCK for modules\data-manager\data-manager.psm1 ---

# Data Manager Module
# Unified data persistence and CRUD operations with event integration.
# This file now contains the fully encapsulated DataManager class.
# CORRECTED (v2): Fixed $this scoping issue in event handlers.

# The factory function is now the only public function in the module.
function Initialize-DataManager {
    <#
    .SYNOPSIS
    Creates a new, fully initialized instance of the DataManager service.
    #>
    return [DataManager]::new()
}

# The DataManager class is the single, encapsulated source of truth for all
# application data. It handles loading from and saving to disk, provides
# strongly-typed CRUD methods, and integrates with the event system to
# notify other components of data changes. Direct access to its internal
# data store is prevented, enforcing predictable and safe data flow.
class DataManager {
    #region Private State
    hidden [hashtable] $_dataStore
    hidden [string] $_dataFilePath
    hidden [string] $_backupPath
    hidden [datetime] $_lastSaveTime
    hidden [bool] $_dataModified = $false
    #endregion

    #region Constructor and Initialization
    DataManager() {
        $this.{_dataStore} = @{
            Projects = [System.Collections.ArrayList]::new()
            Tasks = [System.Collections.ArrayList]::new()
            TimeEntries = @()
            ActiveTimers = @{}
            TodoTemplates = @{}
            Settings = @{
                DefaultView = "Dashboard"
                Theme = "Modern"
                AutoSave = $true
                BackupCount = 5
            }
            time_entries = @() # underscore format for action compatibility
            timers = @()       # for action compatibility
        }

        $this.{_dataFilePath} = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
        $this.{_backupPath} = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"

        Invoke-WithErrorHandling -Component "DataManager.Constructor" -Context "DataManager initialization" -ScriptBlock {
            $dataDirectory = Split-Path $this.{_dataFilePath} -Parent
            if (-not (Test-Path $dataDirectory)) {
                New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
                Write-Log -Level Info -Message "Created data directory: $dataDirectory"
            }
            
            if (-not (Test-Path $this.{_backupPath})) {
                New-Item -ItemType Directory -Path $this.{_backupPath} -Force | Out-Null
                Write-Log -Level Info -Message "Created backup directory: $($this.{_backupPath})"
            }
            
            $this.LoadData()
            $this.InitializeEventHandlers()
            
            Write-Log -Level Info -Message "DataManager initialized successfully"
        }
    }

    hidden [void] InitializeEventHandlers() {
        # Capture the current instance ($this) into a local variable so the
        # scriptblocks below can access it.
        $local:self = $this
        Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -Context "Initializing data event handlers" -ScriptBlock {
            # The handler scriptblock captures $local:self from its parent scope.
            Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
                param($EventData)
                Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Refreshed"; Tasks = @($local:self.{_dataStore}.Tasks) }
            }
            Write-Log -Level Debug -Message "Data event handlers initialized"
        }
    }
    #endregion

    #region Data Persistence
    # Inside the DataManager class
    hidden [void] LoadData() {
        Invoke-WithErrorHandling -Component "DataManager.LoadData" -Context "Loading data" -ScriptBlock {
            if (Test-Path $this.{_dataFilePath}) {
                try {
                    $loadedData = Get-Content -Path $this.{_dataFilePath} -Raw | ConvertFrom-Json -AsHashtable
                    if ($loadedData.Tasks) {
                        $this.{_dataStore}.Tasks.Clear()
                        $taskIndex = 0
                        foreach ($taskData in $loadedData.Tasks) {
                            # --- HARDENING: Resilient Deserialization ---
                            # Wrap the conversion of each individual record in its own try/catch.
                            try {
                                if ($taskData -isnot [hashtable]) { throw "Task record is not a valid hashtable." }
                                $task = [PmcTask]::FromLegacyFormat($taskData)
                                $this.{_dataStore}.Tasks.Add($task) | Out-Null
                            } catch {
                                # If one record fails, log it and continue to the next.
                                Write-Log -Level Warning -Message "Skipping corrupted task record at index $taskIndex in data file. Error: $_"
                            }
                            # --- END HARDENING ---
                            $taskIndex++
                        }
                    }
                    if ($loadedData.Projects) {
                        $this.{_dataStore}.Projects.Clear()
                        $projectIndex = 0
                        foreach ($projectData in $loadedData.Projects) {
                            try {
                                if ($projectData -isnot [hashtable]) { throw "Project record is not a valid hashtable." }
                                $project = [PmcProject]::FromLegacyFormat($projectData)
                                $this.{_dataStore}.Projects.Add($project) | Out-Null
                            } catch {
                                Write-Log -Level Warning -Message "Skipping corrupted project record at index $projectIndex in data file. Error: $_"
                            }
                            $projectIndex++
                        }
                    }
                    if ($loadedData.Settings) {
                        $this.{_dataStore}.Settings.Clear()
                        foreach($key in $loadedData.Settings.Keys) {
                            $this.{_dataStore}.Settings[$key] = $loadedData.Settings[$key]
                        }
                    }
                    if ($loadedData.ActiveTimers) {
                        $this.{_dataStore}.ActiveTimers.Clear()
                        foreach($key in $loadedData.ActiveTimers.Keys) {
                            $this.{_dataStore}.ActiveTimers[$key] = $loadedData.ActiveTimers[$key]
                        }
                    }
                    if ($loadedData.time_entries) {
                        $this.{_dataStore}.time_entries.Clear()
                        $entryIndex = 0
                        foreach ($entryData in $loadedData.time_entries) {
                            try {
                                if ($entryData -isnot [hashtable]) { throw "Time entry record is not a valid hashtable." }
                                $this.{_dataStore}.time_entries.Add($entryData) | Out-Null
                            } catch {
                                Write-Log -Level Warning -Message "Skipping corrupted time entry record at index $entryIndex in data file. Error: $_"
                            }
                            $entryIndex++
                        }
                    }
    
                } catch {
                    Write-Log -Level Error -Message "Failed to parse main data file: $_. Loading will be skipped."
                }
            } else {
                # Initialize with default data if file doesn't exist
                $this.{_dataStore}.Tasks.Add([PmcTask]::new("Sample Task 1", "Default Project", "High", (Get-Date).AddDays(1), "Pending")) | Out-Null
                $this.{_dataStore}.Tasks.Add([PmcTask]::new("Sample Task 2", "Default Project", "Medium", (Get-Date).AddDays(3), "InProgress")) | Out-Null
                $this.{_dataStore}.Tasks.Add([PmcTask]::new("Completed Task", "Default Project", "Low", (Get-Date).AddDays(-5), "Completed")) | Out-Null
                $this.{_dataStore}.Projects.Add([PmcProject]::new("Default Project", "This is the default project.")) | Out-Null
                Write-Log -Level Info -Message "Data file not found. Initialized with default data."
            }
        }
    }

    hidden [void] SaveData() {
        Invoke-WithErrorHandling -Component "DataManager.SaveData" -Context "Saving unified data to disk" -ScriptBlock {
            if (Test-Path $this.{_dataFilePath}) {
                $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
                Copy-Item -Path $this.{_dataFilePath} -Destination (Join-Path $this.{_backupPath} $backupName) -Force
                
                $backups = Get-ChildItem -Path $this.{_backupPath} -Filter "pmc-data_*.json" | Sort-Object LastWriteTime -Descending
                if ($backups.Count -gt $this.{_dataStore}.Settings.BackupCount) {
                    $backups | Select-Object -Skip $this.{_dataStore}.Settings.BackupCount | Remove-Item -Force
                }
            }
            
            $dataToSave = @{
                Tasks = @($this.{_dataStore}.Tasks | ForEach-Object { $_.ToLegacyFormat() })
                Projects = @{}
                TimeEntries = $this.{_dataStore}.TimeEntries
                ActiveTimers = $this.{_dataStore}.ActiveTimers
                TodoTemplates = $this.{_dataStore}.TodoTemplates
                Settings = $this.{_dataStore}.Settings
                time_entries = $this.{_dataStore}.time_entries
                timers = $this.{_dataStore}.timers
            }
            
            foreach ($project in $this.{_dataStore}.Projects) { $dataToSave.Projects[$project.Key] = $project.ToLegacyFormat() }
            
            $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $this.{_dataFilePath} -Encoding UTF8
            $this.{_lastSaveTime} = Get-Date; $this.{_dataModified} = $false
            Write-Log -Level Debug -Message "Data saved successfully"
        }
    }
    #endregion

    #region Task Management Methods
    [PmcTask] AddTask([string]$Title, [string]$Description, [string]$Priority, [string]$ProjectKey, [string]$DueDate = "") {
        return Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($Title)) { 
                throw "Task title cannot be empty"
            }
            $taskPriority = [TaskPriority]::$Priority
            $newTask = [PmcTask]::new($Title, $Description, $taskPriority, $ProjectKey)
            if ($DueDate -and $DueDate -ne "N/A") {
                try { $newTask.DueDate = [datetime]::Parse($DueDate) } catch { }
            }
            $this.{_dataStore}.Tasks.Add($newTask); $this.{_dataModified} = $true
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Created"; TaskId = $newTask.Id; Task = $newTask }
            return $newTask
        }
    }

    [PmcTask] UpdateTask([hashtable]$UpdateParameters) {
        return Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating task" -ScriptBlock {
            if (-not $UpdateParameters.ContainsKey('Task')) {
                throw "The 'UpdateParameters' hashtable must contain a 'Task' key with the task object to update."
            }
            $Task = $UpdateParameters.Task
            $managedTask = $this.{_dataStore}.Tasks.Find({$_.Id -eq $Task.Id})
            if (-not $managedTask) { throw "Task not found in data store" }
            
            $updatedFields = @()
            if ($UpdateParameters.ContainsKey('Title')) { $managedTask.Title = $UpdateParameters.Title.Trim(); $updatedFields += "Title" }
            if ($UpdateParameters.ContainsKey('Description')) { $managedTask.Description = $UpdateParameters.Description; $updatedFields += "Description" }
            if ($UpdateParameters.ContainsKey('Priority')) { $managedTask.Priority = [TaskPriority]::$($UpdateParameters.Priority); $updatedFields += "Priority" }
            if ($UpdateParameters.ContainsKey('Category')) { $managedTask.ProjectKey = $UpdateParameters.Category; $managedTask.Category = $UpdateParameters.Category; $updatedFields += "Category" }
            if ($UpdateParameters.ContainsKey('DueDate')) {
                try { $managedTask.DueDate = ($UpdateParameters.DueDate -and $UpdateParameters.DueDate -ne "N/A") ? [datetime]::Parse($UpdateParameters.DueDate) : $null } catch { Write-Log -Level Warning -Message "Invalid due date format: $($UpdateParameters.DueDate)" }
                $updatedFields += "DueDate"
            }
            if ($UpdateParameters.ContainsKey('Progress')) { $managedTask.UpdateProgress($UpdateParameters.Progress); $updatedFields += "Progress" }
            if ($UpdateParameters.ContainsKey('Completed')) {
                if ($UpdateParameters.Completed) { $managedTask.Complete() } else { $managedTask.Status = [TaskStatus]::Pending; $managedTask.Completed = $false; $managedTask.Progress = 0 }
                $updatedFields += "Completed"
            }
            
            $managedTask.UpdatedAt = [datetime]::Now; $this.{_dataModified} = $true
            Write-Log -Level Info -Message "Updated task $($managedTask.Id) - Fields: $($updatedFields -join ', ')"
            
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Updated"; TaskId = $managedTask.Id; Task = $managedTask; UpdatedFields = $updatedFields }
            return $managedTask
        }
    }

    [bool] RemoveTask([PmcTask]$Task) {
        return Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task" -ScriptBlock {
            $taskToRemove = $this.{_dataStore}.Tasks.Find({param($t) $t.Id -eq $Task.Id})
            if ($taskToRemove) {
                [void]$this.{_dataStore}.Tasks.Remove($taskToRemove)
                $this.{_dataModified} = $true
                Write-Log -Level Info -Message "Deleted task $($Task.Id)"
                if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
                Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Deleted"; TaskId = $Task.Id; Task = $Task }
                return $true
            }
            Write-Log -Level Warning -Message "Task not found with ID $($Task.Id)"; return $false
        }
    }

        [PmcTask[]] GetTasks([bool]$Completed = $null, [string]$Priority = $null, [string]$Category = $null) {
        return Invoke-WithErrorHandling -Component "DataManager.GetTasks" -Context "Retrieving tasks" -ScriptBlock {
            $tasks = $this.{_dataStore}.Tasks
                        if ($null -ne $Completed) { $tasks = $tasks | Where-Object { $_.Completed -eq $Completed } }
            if ($Priority) { $priorityEnum = [TaskPriority]::$Priority; $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum } }
            if ($Category) { $tasks = $tasks | Where-Object { $_.ProjectKey -eq $Category -or $_.Category -eq $Category } }
            return @($tasks)
        }
    }
    #endregion

    #region Project Management Methods
    [PmcProject[]] GetProjects() { return @($this.{_dataStore}.Projects) }
    [PmcProject] GetProject([string]$Key) { return $this.{_dataStore}.Projects.Find({$_.Key -eq $Key}) }

    [PmcProject] AddProject([PmcProject]$Project) {
        return Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding project" -ScriptBlock {
            if ($this.{_dataStore}.Projects.Exists({$_.Key -eq $Project.Key})) { 
                throw "Project with key '$($Project.Key)' already exists"
            }
            $this.{_dataStore}.Projects.Add($Project); $this.{_dataModified} = $true
            Write-Log -Level Info -Message "Created project '$($Project.Name)' with key $($Project.Key)"
            if ($this.{_dataStore}.Settings.AutoSave) { $this.SaveData() }
            Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Created"; ProjectKey = $Project.Key; Project = $Project }
            return $Project
        }
    }
    #endregion
}

# --- END OF REPLACEMENT BLOCK ---


# --- START OF ORIGINAL FILE: services\keybinding-service\keybinding-service.psm1 ---
# keybinding-service.psm1
# Contains only the factory function for creating KeybindingService instances.



function New-KeybindingService {
    <#
    .SYNOPSIS
    Creates a new instance of the KeybindingService class.
    #>
    [CmdletBinding()]
    param(
        [switch]$EnableChords
    )
    
    if ($EnableChords) {
        return [KeybindingService]::new($true)
    }
    else {
        return [KeybindingService]::new()
    }
}
# --- END OF ORIGINAL FILE: services\keybinding-service\keybinding-service.psm1 ---


# --- START OF ORIGINAL FILE: services\navigation-service\navigation-service.psm1 ---
# navigation-service-functions.psm1
# Contains only the factory function for the NavigationService.



function Initialize-NavigationService {
    param([hashtable]$Services)
    if (-not $Services) { throw [System.ArgumentNullException]::new("Services") }
    return [NavigationService]::new($Services)
}
# --- END OF ORIGINAL FILE: services\navigation-service\navigation-service.psm1 ---


# --- START OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---
# TUI Engine v5.2 - Pure Compositor Edition
# Implements a pure NCurses-style compositor loop. The engine's core responsibilities
# are: running the main application loop, processing the input queue, and orchestrating
# the compositor pipeline (Screen -> Overlays -> Console). All rendering is handled
# via TuiBuffer objects, ensuring a flicker-free, layered UI.

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    CompositorBuffer = $null    # The master compositor buffer (TuiBuffer) that gets drawn to the console.
    PreviousCompositorBuffer = $null # A copy of the last frame's compositor buffer, used for optimized diff-rendering.
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    OverlayStack    = [System.Collections.Generic.List[UIElement]]::new() # A list to hold modal elements like dialogs.
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.2 (Pure Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        $global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new($Width, $Height, "PreviousCompositor")
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        Subscribe-Event -EventName "TUI.RefreshRequested" -Handler {
            Request-TuiRefresh
        } -Source "TuiEngine"

        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }
        Write-Log -Level Info -Message "TUI Engine v5.2 initialized successfully"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

# In modules\tui-engine\tui-engine.psm1

function Process-SingleKeyInput {
    param($keyInfo)
    
    # --- HARDENING: Focus Validation ---
    $focusedComponent = $global:TuiState.FocusedComponent
    if ($null -eq $focusedComponent -or -not $focusedComponent.Visible -or -not $focusedComponent.Enabled) {
        # The current component with focus is invalid. Find a new one.
        Write-Log -Level Debug -Message "Focused component is invalid. Attempting to move focus."
        Move-Focus
        $focusedComponent = $global:TuiState.FocusedComponent
    }
    # --- END HARDENING ---
    
    # NEW: Check for global command palette keybind (Ctrl+P) at the highest priority.
    if (($keyInfo.Modifiers -band [ConsoleModifiers]::Control) -and $keyInfo.Key -eq 'P') {
        $palette = [CommandPalette]::new()
        $palette.Show()
        return # Input is handled.
    }

    # If there's an active overlay, give it priority.
    if ($global:TuiState.OverlayStack.Count -gt 0) {
        $overlay = $global:TuiState.OverlayStack[-1]
        if ($overlay.HandleInput($keyInfo)) { return }
    }

    # Handle Tab for focus navigation
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus
        return
    }

    # Give the currently focused component a chance to handle the input.
    if ($focusedComponent -and $focusedComponent.HandleInput($keyInfo)) {
        return
    }

    # Finally, give the current screen a chance to handle the input.
    if ($global:TuiState.CurrentScreen -and $global:TuiState.CurrentScreen.HandleInput($keyInfo)) {
        return
    }
}

# In tui-engine.psm1
function Start-TuiLoop {
    # ... (initial setup) ...
    $global:TuiState.Running = $true
    while ($global:TuiState.Running) {
        try {
            # --- HARDENING: Window Resize Detection ---
            $consoleWidth = [Console]::WindowWidth
            $consoleHeight = [Console]::WindowHeight - 1
            if (($consoleWidth -ne $global:TuiState.BufferWidth -or $consoleHeight -ne $global:TuiState.BufferHeight) -and $consoleWidth -gt 0 -and $consoleHeight -gt 0) {
                Write-Log -Level Info -Message "Window resized to $($consoleWidth)x$($consoleHeight)."
                # Update global state and core buffers
                $global:TuiState.BufferWidth = $consoleWidth
                $global:TuiState.BufferHeight = $consoleHeight
                $global:TuiState.CompositorBuffer.Resize($consoleWidth, $consoleHeight)
                $global:TuiState.PreviousCompositorBuffer.Resize($consoleWidth, $consoleHeight)
                # Cascade the resize call down the entire UI tree, starting with the screen.
                $global:TuiState.CurrentScreen?.Resize($consoleWidth, $consoleHeight)
                # Force a full, non-differential render to repaint everything correctly.
                $global:TuiState.RenderStats.FrameCount = 1
                Request-TuiRefresh
            }
            # --- END HARDENING ---
            
            # ... (main loop logic: resize check, input, render) ...
        }
        catch [Helios.HeliosException] { # Handle known application exceptions gracefully
            # ... (show alert dialog) ...
        }
        catch { # Catch ALL other unexpected exceptions
            $global:TuiState.Running = $false
            [PanicHandler]::Panic($_) # Trigger the panic handler
        }
    }
}

function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        Render-FrameCompositor
        
        # After rendering, copy the current compositor state to the previous state buffer for the next frame's diff.
        $global:TuiState.PreviousCompositorBuffer.Clear()
        $global:TuiState.PreviousCompositorBuffer.BlendBuffer($global:TuiState.CompositorBuffer, 0, 0)
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
                $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                if ($null -ne $screenBuffer) {
                    $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                }
            }
        }
        
        # 3. Render overlays (e.g., dialogs) on top of the screen
        foreach ($overlay in $global:TuiState.OverlayStack) {
            Invoke-WithErrorHandling -Component ($overlay.Name ?? "Overlay") -Context "Overlay Render" -ScriptBlock {
                $overlay.Render()
                $overlayBuffer = $overlay.GetBuffer()
                if ($null -ne $overlayBuffer) {
                    $pos = $overlay.GetAbsolutePosition()
                    $global:TuiState.CompositorBuffer.BlendBuffer($overlayBuffer, $pos.X, $pos.Y)
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
    }
}

# In modules\tui-engine\tui-engine.psm1

function Render-CompositorToConsole {
    # This buffer is increased to accommodate potentially longer Truecolor escape sequences.
    $outputBuilder = [System.Text.StringBuilder]::new(40000)
    $currentBuffer = $global:TuiState.CompositorBuffer
    $previousBuffer = $global:TuiState.PreviousCompositorBuffer
    
    # OPTIMIZATION: Track the last used style sequence as a string.
    # If the next cell has the same style, we don't need to send any new ANSI codes.
    $lastSequence = "RESET" # A unique sentinel value to ensure the first sequence is always sent.
    
    # On the very first frame, we must render everything. No diffing is possible.
    $forceFullRender = ($global:TuiState.RenderStats.FrameCount -eq 1)

    try {
        # Move cursor to home position once at the beginning of the entire render operation.
        [void]$outputBuilder.Append("`e[1;1H")

        for ($y = 0; $y -lt $currentBuffer.Height; $y++) {
            # Since we're doing a diff, we can't just skip whole lines. We must check cell by cell.
            # A variable to track if we've written anything to this line yet.
            $cursorMovedOnLine = $false
            
            for ($x = 0; $x -lt $currentBuffer.Width; $x++) {
                $newCell = $currentBuffer.GetCell($x, $y)
                
                # OPTIMIZATION 1: Differential Rendering
                # If not forcing a full render, compare the new cell to the one from the previous frame.
                if (-not $forceFullRender) {
                    $oldCell = $previousBuffer.GetCell($x, $y)
                    # If cells are identical, we don't need to draw it. We just need to ensure the cursor is in the right place.
                    if (-not $newCell.DiffersFrom($oldCell)) {
                        continue
                    }
                }
                
                # If we are here, the cell needs to be redrawn.
                # Move the cursor to the correct position for this cell.
                if (-not $cursorMovedOnLine) {
                    [void]$outputBuilder.Append("`e[$($y + 1);1H") # Move to start of line
                    if ($x-gt 0) { [void]$outputBuilder.Append("`e[$($x)C") } # Move right X columns
                    $cursorMovedOnLine = $true
                } else {
                    [void]$outputBuilder.Append("`e[$($y + 1);$($x + 1)H") # Absolute cursor move
                }
                
                # Generate the full style sequence for the new cell using our Truecolor helper.
                $attributes = @{ Bold=$newCell.Bold; Italic=$newCell.Italic; Underline=$newCell.Underline; Strikethrough=$newCell.Strikethrough }
                $currentSequence = [TuiAnsiHelper]::GetAnsiSequence($newCell.ForegroundColor, $newCell.BackgroundColor, $attributes)

                # OPTIMIZATION 2: State Change Minimization
                # Only append the style sequence if it's different from the last one used.
                if ($currentSequence -ne $lastSequence) {
                    # To ensure a clean state, we combine a reset with the new style.
                    # This prevents style attributes from "leaking" between cells.
                    [void]$outputBuilder.Append([TuiAnsiHelper]::Reset()).Append($currentSequence)
                    $lastSequence = $currentSequence
                }
                
                # Finally, append the character itself.
                [void]$outputBuilder.Append($newCell.Char)
            }
        }
        
        # Append a final reset to ensure the terminal is clean after the application exits or rendering stops.
        [void]$outputBuilder.Append([TuiAnsiHelper]::Reset())
        
        # Write the entire frame's changes in one single, atomic operation to the console.
        if ($outputBuilder.Length -gt 0) {
            [Console]::Write($outputBuilder.ToString())
        }
    } catch {
        # Log any catastrophic rendering failure.
        Write-Log -Level Fatal -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen & Overlay Management
function Push-Screen {
    param([UIElement]$Screen)
    if (-not $Screen) { return }
    
    Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur()
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.OnExit()
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) { # Default size
            $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
        }
        
        # Call OnEnter lifecycle method
        if ($Screen -is [Screen] -or $Screen.GetType().GetMethod("OnEnter")) {
            $Screen.OnEnter()
        }
        
        $Screen.RequestRedraw()
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $Screen.Name }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$($Screen.Name)': $_"
    }
}

# In modules\tui-engine\tui-engine.psm1

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $screenToExit = $global:TuiState.CurrentScreen
        
        # --- HARDENING: Cascading Resource Cleanup ---
        # Explicitly call the Cleanup method on the screen being removed.
        # This will cascade down and clean up all children, unsubscribing from events.
        $screenToExit?.Cleanup()
        # --- END HARDENING ---
        
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.CurrentScreen?.OnResume()
        
        # Clear focus if the popped screen held it.
        if ($global:TuiState.FocusedComponent -and $global:TuiState.FocusedComponent.Parent -eq $screenToExit) {
            Set-ComponentFocus -Component $null # Clear focus, it will be re-established on next render/input
        }
        
        Request-TuiRefresh
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}

function Show-TuiOverlay {
    param([UIElement]$Element)
    $global:TuiState.OverlayStack.Add($Element)
    Request-TuiRefresh
}

function Close-TopTuiOverlay {
    if ($global:TuiState.OverlayStack.Count-gt 0) {
        $global:TuiState.OverlayStack.RemoveAt($global:TuiState.OverlayStack.Count - 1)
        Request-TuiRefresh
    }
}
#endregion

#region Component System
function Set-ComponentFocus { 
    param([UIElement]$Component)
    if ($Component -and (-not $Component.Enabled)) { return }
    
    $global:TuiState.FocusedComponent?.OnBlur()
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    $Component?.OnFocus()
    
    Request-TuiRefresh 
}

function Get-NextFocusableComponent { 
    param([UIElement]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = [System.Collections.Generic.List[UIElement]]::new()
    
    function Find-Focusable([UIElement]$Comp) {
        if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
            $focusableComponents.Add($Comp)
        }
        foreach ($child in $Comp.Children) { Find-Focusable $child }
    }
    
    Find-Focusable $global:TuiState.CurrentScreen
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    $sorted = $focusableComponents | Sort-Object { $_.TabIndex * 10000 + $_.Y * 100 + $_.X }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Move-Focus { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Stop-AllTuiAsyncJobs { Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)" }
#endregion

#region Utilities
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }
function Stop-TuiLoop { Stop-TuiEngine }
#endregion
# --- END OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---


# --- START OF ORIGINAL FILE: modules\tui-framework\tui-framework.psm1 ---
# TUI Framework Integration Module
# Contains utility functions for interacting with the TUI engine and components.
# AI: FIX - Added all missing dependencies.




$script:TuiAsyncJobs = @()

function Invoke-TuiMethod {
    <# .SYNOPSIS Safely invokes a method on a TUI component. #>
    param(
        [Parameter(Mandatory)] [hashtable]$Component,
        [Parameter(Mandatory)] [string]$MethodName,
        [Parameter()] [hashtable]$Arguments = @{}
    )
    if (-not $Component) { return }
    $method = $Component[$MethodName]
    if (-not ($method -is [scriptblock])) { return }

    $Arguments['self'] = $Component
    Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock { & $method @Arguments }
}

function Initialize-TuiFramework {
    Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {
        if (-not $global:TuiState) { throw "TUI Engine must be initialized before the TUI Framework." }
        Write-Log -Level Info -Message "TUI Framework initialized."
    }
}

function Invoke-TuiAsync {
    <# .SYNOPSIS Executes a script block asynchronously with job management. #>
    param(
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [string]$JobName = "TuiAsyncJob_$(Get-Random)",
        [hashtable]$ArgumentList = @{}
    )
    Invoke-WithErrorHandling -Component "TuiFramework.Async" -Context "Starting async job: $JobName" -ScriptBlock {
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList -Name $JobName
        $script:TuiAsyncJobs += $job
        Write-Log -Level Debug -Message "Started async job: $JobName" -Data @{ JobId = $job.Id }
        return $job
    }
}

function Get-TuiAsyncResults {
    <# .SYNOPSIS Checks for completed async jobs and returns their results. #>
    param([switch]$RemoveCompleted = $true)
    Invoke-WithErrorHandling -Component "TuiFramework.AsyncResults" -Context "Checking async job results" -ScriptBlock {
        $results = @()
        $completedJobs = $script:TuiAsyncJobs | Where-Object { $_.State -in @('Completed', 'Failed', 'Stopped') }
        
        foreach ($job in $completedJobs) {
            $results += @{
                JobId = $job.Id; JobName = $job.Name; State = $job.State
                Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job } else { $null }
                Error = if ($job.State -eq 'Failed') { $job.ChildJobs[0].JobStateInfo.Reason } else { $null }
            }
            Write-Log -Level Debug -Message "Async job completed: $($job.Name)" -Data @{ JobId = $job.Id; State = $job.State }
        }
        
        if ($RemoveCompleted -and $completedJobs.Count -gt 0) {
            foreach ($job in $completedJobs) {
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                $script:TuiAsyncJobs = $script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id }
            }
        }
        return $results
    }
}

function Stop-AllTuiAsyncJobs {
    Invoke-WithErrorHandling -Component "TuiFramework.StopAsync" -Context "Stopping all async jobs" -ScriptBlock {
        foreach ($job in $script:TuiAsyncJobs) {
            try {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                Write-Log -Level Debug -Message "Stopped async job: $($job.Name)"
            } catch {
                Write-Log -Level Warning -Message "Failed to stop job $($job.Name): $_"
            }
        }
        $script:TuiAsyncJobs = @()
        Write-Log -Level Info -Message "All TUI async jobs stopped."
    }
}



function Get-TuiState { return $global:TuiState }

function Test-TuiState {
    param([switch]$ThrowOnError)
    $isValid = $global:TuiState -and $global:TuiState.Running -and $global:TuiState.CurrentScreen
    if (-not $isValid -and $ThrowOnError) { throw "TUI state is not properly initialized. Call Initialize-TuiEngine first." }
    return $isValid
}

# FINAL STARTUP BLOCK
try {
    # 1. Initialize core services that have no dependencies
    Write-Host "`n=== Project Acta - Phoenix Edition ===" -ForegroundColor Cyan
    Write-Host "`nInitializing core services..." -ForegroundColor Yellow
    Initialize-Logger -Level $(if ($Debug) { "Debug" } else { "Info" })
    Initialize-EventSystem
    Initialize-DialogSystem
    
    # Ensure themes directory exists
    $themesDir = Join-Path $PSScriptRoot "themes"
    if (-not (Test-Path $themesDir)) { 
        Write-Log -Level Info -Message "Themes directory not found, creating at: $themesDir"
        New-Item -Path $themesDir -ItemType Directory | Out-Null 
        # In a real distribution, you would also create a default.theme.json file here.
    }
    $themeEngine = Initialize-ThemeEngine -themesDirectory $themesDir

    # 2. Create the service container and add initial services
    $services = @{
        ThemeEngine = $themeEngine
    }
    
    # 3. Initialize services that depend on others and add them to the container
    $services.DataManager = Initialize-DataManager
    $services.TimeSheetService = Initialize-TimeSheetService -DataManager $services.DataManager
    $services.ActionService = Initialize-ActionService

    # Register all actions
    $actionService = $services.ActionService
    $actionService.RegisterAction("TimeSheet: Export Weekly Summary to Desktop", "TimeSheet", ${function:Export-WeeklyTimeSheet})
    $actionService.RegisterAction("Application: Quit", "Application", ${function:Request-AppQuit})
    $actionService.RegisterAction("Application: Force UI Refresh", "Application", ${function:Request-UIRefresh})
    $actionService.RegisterAction("Navigation: Go to Dashboard", "Navigation", ${function:Navigate-ToDashboard})
    $actionService.RegisterAction("Navigation: Go to File Explorer", "Navigation", ${function:Navigate-ToFileExplorer})
    $actionService.RegisterAction("Theme: Cycle to Next Theme", "Theme", ${function:Cycle-Theme})
    $actionService.FinalizeActions() 
    $services.KeybindingService = New-KeybindingService
    
    # 4. NavigationService needs the full $services container
    $services.Navigation = Initialize-NavigationService -Services $services
    
    # Assign the fully constructed services container to a global variable for easy access
    $global:AxiomServices = $services
    
    # 5. Register ALL screen classes with the navigation factory
    $nav = $services.Navigation
    $nav.RegisterScreenClass("DashboardScreen", [DashboardScreen])
    $nav.RegisterScreenClass("TaskFlowScreen", [TaskFlowScreen])
    $nav.RegisterScreenClass("ExplorerScreen", [ExplorerScreen])
    $nav.RegisterScreenClass("TimeSheetScreen", [TimeSheetScreen])
    
    Write-Host "All services initialized!" -ForegroundColor Green
    
    # Optional: Display a splash screen or logo
    # Write-Host @"
    #    _   _                      _     
    #   /_\ | |__  _ __ __ _  ___| | __ 
    #  //_\\| '_ \| '__/ _` |/ __| |/ / 
    # /  _  \ |_) | | | (_| | (__|   <  
    # \_/ \_/_.__/|_|  \__,_|\___|_|\_\ 
    # "@ -ForegroundColor DarkCyan
    
    # 6. Initialize TUI Engine
    Initialize-TuiEngine
    
    # 7. Add routes for all the new screens
    $nav.RouteMap["/"] = "DashboardScreen" # Default route
    $nav.RouteMap["/dashboard"] = "DashboardScreen"
    $nav.RouteMap["/tasks"] = "TaskFlowScreen" 
    $nav.RouteMap["/explorer"] = "ExplorerScreen"
    $nav.RouteMap["/timesheet"] = "TimeSheetScreen"
    
    # 8. Start the application by navigating to the root path
    Write-Host "Starting main application loop..." -ForegroundColor Yellow
    $services.Navigation.GoTo("/") 
    Start-TuiLoop
    
} catch {
    Write-Host "`n[FATAL ERROR] Project Acta encountered a critical error during startup:" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "StackTrace:" -ForegroundColor DarkRed
    Write-Host "$($_.ScriptStackTrace)" -ForegroundColor DarkRed
    Write-Host "`nPress any key to exit." -ForegroundColor Red
    [void][Console]::ReadKey($true)
} finally {
    # Ensure the console is reset and cursor is visible on exit
    Write-Host "`e[0m`e[?25h" # Reset SGR and show cursor
    Write-Host "`nProject Acta application terminated." -ForegroundColor DarkGray
}
# --- END OF MAIN EXECUTION LOGIC ---