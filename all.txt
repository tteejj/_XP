####\components\advanced-data-components.psm1
# Advanced Data Components Module for PMC Terminal v5
# Phase 1 Migration Complete - Enhanced data display with proper UIElement inheritance

using namespace System.Text
using namespace System.Management.Automation
using module ..\components\tui-primitives.psm1
using module ..\layout\panels-class.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

# AI: REFACTORED - Table now properly inherits from UIElement
class Table : UIElement {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    [bool]$IsFocused = $false
    
    Table([string]$name) : base() {
        $this.Name = $name
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        $this.Data = @()
        $this.SelectedIndex = 0
        $this.IsFocusable = $true
        $this.Width = 60
        $this.Height = 15
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
        $this.RequestRedraw()
    }
    
    [void] SetData([object[]]$data) {
        $this.Data = if ($null -eq $data) { @() } else { @($data) }
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -ge $dataCount) {
            $this.SelectedIndex = [Math]::Max(0, $dataCount - 1)
        }
        $this.RequestRedraw()
    }
    
    [void] SelectNext() {
        $dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -lt ($dataCount - 1)) {
            $this.SelectedIndex++
            $this.RequestRedraw()
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
            $this.RequestRedraw()
        }
    }
    
    [object] GetSelectedItem() {
        if ($null -eq $this.Data) { return $null }
        
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        
        if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {
            return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }
        }
        return $null
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Draw border if enabled
            if ($this.ShowBorder) {
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                    -BorderStyle "Single" -BorderColor ([ConsoleColor]::Gray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            $currentY = if ($this.ShowBorder) { 1 } else { 0 }
            $contentWidth = if ($this.ShowBorder) { $this.Width - 2 } else { $this.Width }
            $renderX = if ($this.ShowBorder) { 1 } else { 0 }
            
            # Header
            if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
                $headerLine = ""
                foreach ($col in $this.Columns) {
                    $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                    $headerLine += $headerText + " "
                }
                
                if ($headerLine.TrimEnd().Length -gt $contentWidth) {
                    $headerLine = $headerLine.Substring(0, $contentWidth)
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $headerLine.TrimEnd() `
                    -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
                $currentY++
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY `
                    -Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $contentWidth)) `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
                $currentY++
            }
            
            # Data rows
            $dataToRender = @()
            if ($null -ne $this.Data) {
                $dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }
            }
            
            for ($i = 0; $i -lt $dataToRender.Count; $i++) {
                $row = $dataToRender[$i]
                if ($null -eq $row) { continue }
                
                $rowLine = ""
                $isSelected = ($i -eq $this.SelectedIndex)
                
                foreach ($col in $this.Columns) {
                    $cellValue = ""
                    if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                        $cellValue = $row[$col.Key]?.ToString() ?? ""
                    } elseif ($row.PSObject.Properties[$col.Key]) {
                        $cellValue = $row.($col.Key)?.ToString() ?? ""
                    }
                    
                    $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                    $rowLine += $cellText + " "
                }
                
                $finalLine = $rowLine.TrimEnd()
                if ($isSelected) {
                    $finalLine = "> $finalLine"
                } else {
                    $finalLine = "  $finalLine"
                }
                
                $fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
                $bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
                
                if ($finalLine.Length -gt $contentWidth) {
                    $finalLine = $finalLine.Substring(0, $contentWidth)
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $finalLine `
                    -ForegroundColor $fg -BackgroundColor $bg
                $currentY++
                
                # Don't exceed available space
                if ($currentY -ge ($this.Height - 1)) { break }
            }
            
            if ($dataToRender.Count -eq 0) {
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text "  No data to display" `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
        } catch { 
            Write-Log -Level Error -Message "Table render error for '$($this.Name)': $_" 
        }
    }
    
    # AI: REFACTORED - Updated input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this.SelectPrevious()
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $this.SelectNext()
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $selectedItem = $this.GetSelectedItem()
                    if ($null -ne $selectedItem) {
                        # Trigger selection event or action
                        Write-Log -Level Debug -Message "Table item selected: $($selectedItem)"
                    }
                    return $true
                }
            }
        } catch { 
            Write-Log -Level Error -Message "Table input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    [void] OnFocus() {
        $this.IsFocused = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        $this.IsFocused = $false
        $this.RequestRedraw()
    }
}

# AI: REFACTORED - DataTableComponent simplified for Phase 1
class DataTableComponent : UIElement {
    [hashtable[]] $Data = @()
    [hashtable[]] $Columns = @()
    [string] $Title = "Data Table"
    [bool] $ShowBorder = $true
    [int] $SelectedRow = 0
    [scriptblock] $OnRowSelect
    
    DataTableComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 80
        $this.Height = 20
    }
    
    DataTableComponent([string]$name, [hashtable[]]$data, [hashtable[]]$columns) : base() {
        $this.Name = $name
        $this.Data = $data ?? @()
        $this.Columns = $columns ?? @()
        $this.IsFocusable = $true
        $this.Width = 80
        $this.Height = 20
    }
    
    # AI: REFACTORED - Simplified rendering for Phase 1
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Draw border
            if ($this.ShowBorder) {
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                    -BorderStyle "Single" -BorderColor ([ConsoleColor]::Gray) -BackgroundColor ([ConsoleColor]::Black) -Title $this.Title
            }
            
            # Simple placeholder rendering for Phase 1
            $statusText = "DataTable: $($this.Data.Count) rows, $($this.Columns.Count) columns"
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 2 -Text $statusText `
                -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
            
            if ($this.Data.Count -gt 0) {
                Write-TuiText -Buffer $this._private_buffer -X 2 -Y 3 -Text "Selected: Row $($this.SelectedRow + 1)" `
                    -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
            }
            
        } catch { 
            Write-Log -Level Error -Message "DataTableComponent render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedRow -gt 0) {
                        $this.SelectedRow--
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedRow -lt ($this.Data.Count - 1)) {
                        $this.SelectedRow++
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($this.OnRowSelect -and $this.Data.Count -gt 0) {
                        & $this.OnRowSelect $this.Data[$this.SelectedRow] $this.SelectedRow
                    }
                    return $true
                }
            }
        } catch { 
            Write-Log -Level Error -Message "DataTableComponent input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    [void] SetData([hashtable[]]$data) {
        $this.Data = $data ?? @()
        $this.SelectedRow = 0
        $this.RequestRedraw()
    }
    
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns ?? @()
        $this.RequestRedraw()
    }
}

#endregion

#region Factory Functions

function New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DataTable_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $data = $Props.Data ?? @()
    $columns = $Props.Columns ?? @()
    
    $table = [DataTableComponent]::new($name, $data, $columns)
    
    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.Title = $Props.Title ?? $table.Title
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.Visible = $Props.Visible ?? $table.Visible
    $table.OnRowSelect = $Props.OnRowSelect ?? $table.OnRowSelect
    
    return $table
}

#endregion

Export-ModuleMember -Function 'New-TuiDataTable'


####\components\advanced-input-components.psm1
# Advanced Input Components - Phase 2 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

using module ..\components\tui-primitives.psm1

#region Advanced Input Classes

# AI: REFACTORED - MultilineTextBox converted from functional to class-based
class MultilineTextBoxComponent : UIElement {
    [string[]]$Lines = @("")
    [string]$Placeholder = "Enter text..."
    [int]$MaxLines = 10
    [int]$MaxLineLength = 100
    [int]$CurrentLine = 0
    [int]$CursorPosition = 0
    [int]$ScrollOffsetY = 0
    [bool]$WordWrap = $true
    [scriptblock]$OnChange
    
    MultilineTextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 40
        $this.Height = 10
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Buffer-based rendering with parent Panel integration
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Calculate visible area
            $textAreaHeight = $this.Height - 2
            $textAreaWidth = $this.Width - 2
            $startLine = $this.ScrollOffsetY
            $endLine = [Math]::Min($this.Lines.Count - 1, $startLine + $textAreaHeight - 1)
            
            # AI: Render text lines
            for ($i = $startLine; $i -le $endLine; $i++) {
                if ($i -ge $this.Lines.Count) { break }
                
                $line = $this.Lines[$i] ?? ""
                $displayLine = $line
                if ($displayLine.Length -gt $textAreaWidth) {
                    $displayLine = $displayLine.Substring(0, $textAreaWidth)
                }
                
                $lineY = $renderY + 1 + ($i - $startLine)
                $parentPanel.WriteToBuffer($renderX + 1, $lineY, $displayLine, [ConsoleColor]::White, [ConsoleColor]::Black)
            }
            
            # AI: Show placeholder if empty and not focused
            if ($this.Lines.Count -eq 1 -and [string]::IsNullOrEmpty($this.Lines[0]) -and -not $this.IsFocused) {
                $parentPanel.WriteToBuffer($renderX + 1, $renderY + 1, $this.Placeholder, [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
            }
            
            # AI: Draw cursor if focused
            if ($this.IsFocused) {
                $cursorLine = $this.CurrentLine - $this.ScrollOffsetY
                if ($cursorLine -ge 0 -and $cursorLine -lt $textAreaHeight) {
                    $cursorX = $renderX + 1 + $this.CursorPosition
                    $cursorY = $renderY + 1 + $cursorLine
                    if ($cursorX -lt $renderX + $this.Width - 1) {
                        $parentPanel.WriteToBuffer($cursorX, $cursorY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                    }
                }
            }
            
            # AI: Draw scrollbar if needed
            if ($this.Lines.Count -gt $textAreaHeight) {
                $scrollbarX = $renderX + $this.Width - 1
                $scrollHeight = $textAreaHeight
                $thumbSize = [Math]::Max(1, [Math]::Floor($scrollHeight * $textAreaHeight / $this.Lines.Count))
                $thumbPos = [Math]::Floor($scrollHeight * $this.ScrollOffsetY / ($this.Lines.Count - $textAreaHeight))
                
                for ($i = 0; $i -lt $scrollHeight; $i++) {
                    $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                    $parentPanel.WriteToBuffer($scrollbarX, $renderY + 1 + $i, $char, [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentLine = $this.Lines[$this.CurrentLine] ?? ""
            $originalLines = $this.Lines.Clone()
            $handled = $true
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = $this.Lines[$this.CurrentLine].Length
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $currentLine.Length) {
                        $this.CursorPosition++
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $currentLine.Length }
                ([ConsoleKey]::Enter) {
                    if ($this.Lines.Count -lt $this.MaxLines) {
                        $beforeCursor = $currentLine.Substring(0, $this.CursorPosition)
                        $afterCursor = $currentLine.Substring($this.CursorPosition)
                        
                        $this.Lines[$this.CurrentLine] = $beforeCursor
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($afterCursor) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.Lines[$this.CurrentLine] = $currentLine.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0 -and $this.Lines.Count -gt 1) {
                        $previousLine = $this.Lines[$this.CurrentLine - 1]
                        $this.CursorPosition = $previousLine.Length
                        $this.Lines[$this.CurrentLine - 1] = $previousLine + $currentLine
                        $this.Lines = @($this.Lines[0..($this.CurrentLine - 1)]) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        $this.CurrentLine--
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $currentLine.Length) {
                        $this.Lines[$this.CurrentLine] = $currentLine.Remove($this.CursorPosition, 1)
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $nextLine = $this.Lines[$this.CurrentLine + 1]
                        $this.Lines[$this.CurrentLine] = $currentLine + $nextLine
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($this.Lines[($this.CurrentLine + 2)..($this.Lines.Count - 1)])
                    }
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentLine.Length -lt $this.MaxLineLength) {
                        $this.Lines[$this.CurrentLine] = $currentLine.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.OnChange -and -not $this._ArraysEqual($originalLines, $this.Lines)) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Lines 
                }
                $this.Parent.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _UpdateScrolling() {
        $textAreaHeight = $this.Height - 2
        if ($this.CurrentLine -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CurrentLine
        } elseif ($this.CurrentLine -ge ($this.ScrollOffsetY + $textAreaHeight)) {
            $this.ScrollOffsetY = $this.CurrentLine - $textAreaHeight + 1
        }
    }
    
    hidden [bool] _ArraysEqual([string[]]$array1, [string[]]$array2) {
        if ($array1.Count -ne $array2.Count) { return $false }
        for ($i = 0; $i -lt $array1.Count; $i++) {
            if ($array1[$i] -ne $array2[$i]) { return $false }
        }
        return $true
    }
    
    [string] GetText() {
        return $this.Lines -join "`n"
    }
    
    [void] SetText([string]$text) {
        $this.Lines = if ([string]::IsNullOrEmpty($text)) { @("") } else { $text -split "`n" }
        $this.CurrentLine = 0
        $this.CursorPosition = 0
        $this.ScrollOffsetY = 0
    }
}

# AI: REFACTORED - NumericInput converted from functional to class-based
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$Min = [double]::MinValue
    [double]$Max = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [string]$TextValue = "0"
    [int]$CursorPosition = 0
    [string]$Suffix = ""
    [scriptblock]$OnChange
    
    NumericInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display value with suffix
            $displayText = $this.TextValue + $this.Suffix
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, [ConsoleColor]::White, [ConsoleColor]::Black)
            
            # AI: Draw spinner arrows
            $parentPanel.WriteToBuffer($renderX + $this.Width - 3, $renderY, "▲", $borderColor, [ConsoleCore]::Black)
            $parentPanel.WriteToBuffer($renderX + $this.Width - 3, $renderY + 2, "▼", $borderColor, [ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = $textX + $this.CursorPosition
                if ($cursorX -lt $renderX + $this.Width - 4) {
                    $parentPanel.WriteToBuffer($cursorX, $textY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                }
            }
            
            # AI: Show min/max indicators
            if ($this.Value -le $this.Min) {
                $parentPanel.WriteToBuffer($renderX + 1, $textY, "⊥", [ConsoleColor]::Red, [ConsoleColor]::Black)
            }
            if ($this.Value -ge $this.Max) {
                $parentPanel.WriteToBuffer($renderX + $this.Width - 2, $textY, "⊤", [ConsoleColor]::Red, [ConsoleColor]::Black)
            }
            
        } catch { 
            Write-Log -Level Error -Message "NumericInput render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this._IncrementValue()
                }
                ([ConsoleKey]::DownArrow) {
                    $this._DecrementValue()
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) { 
                        $this.CursorPosition-- 
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) { 
                        $this.CursorPosition++ 
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this._ValidateAndUpdate()
                }
                default {
                    if ($key.KeyChar -and ($key.KeyChar -match '[\d\.\-]' -or 
                        ($key.KeyChar -eq '.' -and $this.DecimalPlaces -gt 0 -and -not $this.TextValue.Contains('.')))) {
                        $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.Parent.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "NumericInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _IncrementValue() {
        $newValue = [Math]::Min($this.Max, $this.Value + $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _DecrementValue() {
        $newValue = [Math]::Max($this.Min, $this.Value - $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _SetValue([double]$value) {
        $this.Value = $value
        $this.TextValue = $value.ToString("F$($this.DecimalPlaces)")
        $this.CursorPosition = $this.TextValue.Length
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newValue = [double]$this.TextValue
            $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
            $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
            
            $this._SetValue($newValue)
            return $true
        } catch {
            $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
            Write-Log -Level Warning -Message "NumericInput validation failed for '$($this.Name)': $_"
            return $false
        }
    }
}

# AI: REFACTORED - DateInput converted from functional to class-based
class DateInputComponent : UIElement {
    [DateTime]$Value = (Get-Date)
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [string]$Format = "yyyy-MM-dd"
    [string]$TextValue = ""
    [int]$CursorPosition = 0
    [bool]$ShowCalendar = $false
    [scriptblock]$OnChange
    
    DateInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.TextValue = $this.Value.ToString($this.Format)
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display date value
            $displayText = $this.TextValue
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, [ConsoleColor]::White, [ConsoleColor]::Black)
            
            # AI: Draw calendar icon
            $parentPanel.WriteToBuffer($renderX + $this.Width - 3, $textY, "📅", [ConsoleColor]::Cyan, [ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = $textX + $this.CursorPosition
                if ($cursorX -lt $renderX + $this.Width - 4) {
                    $parentPanel.WriteToBuffer($cursorX, $textY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                }
            }
            
            # AI: Show calendar popup if requested
            if ($this.ShowCalendar) {
                $this._RenderCalendar()
            }
            
        } catch { 
            Write-Log -Level Error -Message "DateInput render error for '$($this.Name)': $_" 
        }
    }
    
    hidden [void] _RenderCalendar() {
        if (-not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $calX = $contentArea.X + $this.X
            $calY = $contentArea.Y + $this.Y + $this.Height
            $calWidth = 22
            $calHeight = 8
            
            # AI: Draw calendar background
            $parentPanel.DrawBoxToBuffer($calX, $calY, $calWidth, $calHeight, [ConsoleColor]::Cyan, [ConsoleColor]::DarkBlue)
            
            # AI: Draw month/year header
            $monthYear = $this.Value.ToString("MMMM yyyy")
            $headerX = $calX + [Math]::Floor(($calWidth - $monthYear.Length) / 2)
            $parentPanel.WriteToBuffer($headerX, $calY + 1, $monthYear, [ConsoleColor]::White, [ConsoleColor]::DarkBlue)
            
            # AI: Draw day headers
            $dayHeaders = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
            $dayY = $calY + 2
            for ($i = 0; $i -lt $dayHeaders.Count; $i++) {
                $dayX = $calX + 2 + ($i * 3)
                $parentPanel.WriteToBuffer($dayX, $dayY, $dayHeaders[$i], [ConsoleColor]::Yellow, [ConsoleColor]::DarkBlue)
            }
            
            # AI: Draw calendar days (simplified)
            $firstDay = Get-Date -Year $this.Value.Year -Month $this.Value.Month -Day 1
            $daysInMonth = [DateTime]::DaysInMonth($this.Value.Year, $this.Value.Month)
            $startDayOfWeek = [int]$firstDay.DayOfWeek
            
            $currentDay = 1
            for ($week = 0; $week -lt 4 -and $currentDay -le $daysInMonth; $week++) {
                for ($dayOfWeek = 0; $dayOfWeek -lt 7 -and $currentDay -le $daysInMonth; $dayOfWeek++) {
                    if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                    
                    $dayX = $calX + 2 + ($dayOfWeek * 3)
                    $dayY = $calY + 3 + $week
                    
                    $isToday = ($currentDay -eq $this.Value.Day)
                    $fg = $isToday ? [ConsoleColor]::Black : [ConsoleColor]::White
                    $bg = $isToday ? [ConsoleColor]::Yellow : [ConsoleColor]::DarkBlue
                    
                    $parentPanel.WriteToBuffer($dayX, $dayY, $currentDay.ToString().PadLeft(2), $fg, $bg)
                    $currentDay++
                }
            }
            
        } catch {
            Write-Log -Level Error -Message "DateInput calendar render error for '$($this.Name)': $_"
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            if ($this.ShowCalendar) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) { $this.ShowCalendar = $false }
                    ([ConsoleKey]::LeftArrow) { $this.Value = $this.Value.AddDays(-1) }
                    ([ConsoleKey]::RightArrow) { $this.Value = $this.Value.AddDays(1) }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(-7) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(7) }
                    ([ConsoleKey]::Enter) { 
                        $this.ShowCalendar = $false
                        $this.TextValue = $this.Value.ToString($this.Format)
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::F4) { $this.ShowCalendar = $true }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(-1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::LeftArrow) {
                        if ($this.CursorPosition -gt 0) { $this.CursorPosition-- }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) { $this.CursorPosition++ }
                    }
                    ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                    ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                    ([ConsoleKey]::Backspace) {
                        if ($this.CursorPosition -gt 0) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                            $this.CursorPosition--
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                        }
                    }
                    ([ConsoleKey]::Enter) {
                        $this._ValidateAndUpdate()
                    }
                    default {
                        if ($key.KeyChar -and ($key.KeyChar -match '[\d\-\/]')) {
                            $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                            $this.CursorPosition++
                        } else {
                            $handled = $false
                        }
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.Parent.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "DateInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newDate = [DateTime]::ParseExact($this.TextValue, $this.Format, $null)
            if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                $this.Value = $newDate
                $this.TextValue = $newDate.ToString($this.Format)
                return $true
            }
        } catch {
            # Reset to current value on parse error
            $this.TextValue = $this.Value.ToString($this.Format)
            Write-Log -Level Warning -Message "DateInput validation failed for '$($this.Name)': $_"
        }
        return $false
    }
}

# AI: REFACTORED - ComboBox converted from functional to class-based
class ComboBoxComponent : UIElement {
    [object[]]$Items = @()
    [object]$SelectedItem = $null
    [int]$SelectedIndex = -1
    [string]$DisplayMember = "Display"
    [string]$ValueMember = "Value"
    [string]$Placeholder = "Select an item..."
    [bool]$IsDropDownOpen = $false
    [int]$MaxDropDownHeight = 6
    [int]$ScrollOffset = 0
    [scriptblock]$OnSelectionChanged
    
    ComboBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 30
        $this.Height = 3
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw main combobox
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display selected item or placeholder
            $displayText = ""
            if ($this.SelectedItem) {
                if ($this.SelectedItem -is [string]) {
                    $displayText = $this.SelectedItem
                } elseif ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.DisplayMember)) {
                    $displayText = $this.SelectedItem[$this.DisplayMember]
                } else {
                    $displayText = $this.SelectedItem.ToString()
                }
            } else {
                $displayText = $this.Placeholder
            }
            
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength - 3) + "..."
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $textColor = $this.SelectedItem ? [ConsoleColor]::White : [ConsoleColor]::DarkGray
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, $textColor, [ConsoleColor]::Black)
            
            # AI: Draw dropdown arrow
            $arrow = $this.IsDropDownOpen ? "▲" : "▼"
            $parentPanel.WriteToBuffer($renderX + $this.Width - 3, $textY, $arrow, $borderColor, [ConsoleColor]::Black)
            
            # AI: Draw dropdown if open
            if ($this.IsDropDownOpen -and $this.Items.Count -gt 0) {
                $this._RenderDropDown()
            }
            
        } catch { 
            Write-Log -Level Error -Message "ComboBox render error for '$($this.Name)': $_" 
        }
    }
    
    hidden [void] _RenderDropDown() {
        if (-not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $dropX = $contentArea.X + $this.X
            $dropY = $contentArea.Y + $this.Y + $this.Height
            $dropHeight = [Math]::Min($this.MaxDropDownHeight, $this.Items.Count) + 2
            
            # AI: Draw dropdown background
            $parentPanel.DrawBoxToBuffer($dropX, $dropY, $this.Width, $dropHeight, [ConsoleColor]::Gray, [ConsoleColor]::DarkBlue)
            
            # AI: Calculate visible items
            $visibleCount = [Math]::Min($this.MaxDropDownHeight, $this.Items.Count)
            $startIndex = $this.ScrollOffset
            $endIndex = [Math]::Min($this.Items.Count - 1, $startIndex + $visibleCount - 1)
            
            # AI: Render visible items
            for ($i = $startIndex; $i -le $endIndex; $i++) {
                $item = $this.Items[$i]
                $itemY = $dropY + 1 + ($i - $startIndex)
                
                $displayText = ""
                if ($item -is [string]) {
                    $displayText = $item
                } elseif ($item -is [hashtable] -and $item.ContainsKey($this.DisplayMember)) {
                    $displayText = $item[$this.DisplayMember]
                } else {
                    $displayText = $item.ToString()
                }
                
                if ($displayText.Length -gt ($this.Width - 4)) {
                    $displayText = $displayText.Substring(0, $this.Width - 7) + "..."
                }
                
                $isHighlighted = ($i -eq $this.SelectedIndex)
                $fg = $isHighlighted ? [ConsoleColor]::Black : [ConsoleColor]::White
                $bg = $isHighlighted ? [ConsoleColor]::Yellow : [ConsoleColor]::DarkBlue
                
                # AI: Clear line first
                $parentPanel.WriteToBuffer($dropX + 1, $itemY, (" " * ($this.Width - 2)), $fg, $bg)
                $parentPanel.WriteToBuffer($dropX + 2, $itemY, $displayText, $fg, $bg)
            }
            
            # AI: Draw scrollbar if needed
            if ($this.Items.Count -gt $this.MaxDropDownHeight) {
                $scrollbarX = $dropX + $this.Width - 1
                $scrollHeight = $visibleCount
                $thumbSize = [Math]::Max(1, [Math]::Floor($scrollHeight * $visibleCount / $this.Items.Count))
                $thumbPos = [Math]::Floor($scrollHeight * $this.ScrollOffset / ($this.Items.Count - $visibleCount))
                
                for ($i = 0; $i -lt $scrollHeight; $i++) {
                    $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                    $parentPanel.WriteToBuffer($scrollbarX, $dropY + 1 + $i, $char, [ConsoleColor]::Gray, [ConsoleColor]::DarkBlue)
                }
            }
            
        } catch {
            Write-Log -Level Error -Message "ComboBox dropdown render error for '$($this.Name)': $_"
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalSelection = $this.SelectedItem
            
            if ($this.IsDropDownOpen) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) {
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::Enter) {
                        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
                            $this.SelectedItem = $this.Items[$this.SelectedIndex]
                        }
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($this.SelectedIndex -gt 0) {
                            $this.SelectedIndex--
                            $this._UpdateScrolling()
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                            $this.SelectedIndex++
                            $this._UpdateScrolling()
                        }
                    }
                    ([ConsoleKey]::PageUp) {
                        $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this.MaxDropDownHeight)
                        $this._UpdateScrolling()
                    }
                    ([ConsoleKey]::PageDown) {
                        $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this.MaxDropDownHeight)
                        $this._UpdateScrolling()
                    }
                    ([ConsoleKey]::Home) {
                        $this.SelectedIndex = 0
                        $this._UpdateScrolling()
                    }
                    ([ConsoleKey]::End) {
                        $this.SelectedIndex = $this.Items.Count - 1
                        $this._UpdateScrolling()
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::Enter) { $this._OpenDropDown() }
                    ([ConsoleKey]::Spacebar) { $this._OpenDropDown() }
                    ([ConsoleKey]::DownArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::UpArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::F4) { $this._OpenDropDown() }
                    default { $handled = $false }
                }
            }
            
            if ($handled -and $this.SelectedItem -ne $originalSelection -and $this.OnSelectionChanged) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnSelectionChanged" -ScriptBlock { 
                    & $this.OnSelectionChanged -SelectedItem $this.SelectedItem 
                }
                $this.Parent.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "ComboBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _OpenDropDown() {
        if ($this.Items.Count -gt 0) {
            $this.IsDropDownOpen = $true
            $this._FindCurrentSelection()
        }
    }
    
    hidden [void] _FindCurrentSelection() {
        $this.SelectedIndex = -1
        if ($this.SelectedItem) {
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                if ($this._ItemsEqual($this.Items[$i], $this.SelectedItem)) {
                    $this.SelectedIndex = $i
                    break
                }
            }
        }
        if ($this.SelectedIndex -eq -1) { $this.SelectedIndex = 0 }
        $this._UpdateScrolling()
    }
    
    hidden [void] _UpdateScrolling() {
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $this.MaxDropDownHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $this.MaxDropDownHeight + 1
        }
    }
    
    hidden [bool] _ItemsEqual([object]$item1, [object]$item2) {
        if ($item1 -is [string] -and $item2 -is [string]) {
            return $item1 -eq $item2
        } elseif ($item1 -is [hashtable] -and $item2 -is [hashtable]) {
            return $item1[$this.ValueMember] -eq $item2[$this.ValueMember]
        } else {
            return $item1 -eq $item2
        }
    }
    
    [void] SetItems([object[]]$items) {
        $this.Items = $items
        $this.SelectedItem = $null
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.IsDropDownOpen = $false
    }
    
    [object] GetSelectedValue() {
        if ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.ValueMember)) {
            return $this.SelectedItem[$this.ValueMember]
        }
        return $this.SelectedItem
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiMultilineTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "MultilineTextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [MultilineTextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLines = $Props.MaxLines ?? $textBox.MaxLines
    $textBox.MaxLineLength = $Props.MaxLineLength ?? $textBox.MaxLineLength
    $textBox.WordWrap = $Props.WordWrap ?? $textBox.WordWrap
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    if ($Props.Text) {
        $textBox.SetText($Props.Text)
    }
    
    return $textBox
}

function New-TuiNumericInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "NumericInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $numericInput = [NumericInputComponent]::new($name)
    
    $numericInput.X = $Props.X ?? $numericInput.X
    $numericInput.Y = $Props.Y ?? $numericInput.Y
    $numericInput.Width = $Props.Width ?? $numericInput.Width
    $numericInput.Height = $Props.Height ?? $numericInput.Height
    $numericInput.Visible = $Props.Visible ?? $numericInput.Visible
    $numericInput.ZIndex = $Props.ZIndex ?? $numericInput.ZIndex
    $numericInput.Value = $Props.Value ?? $numericInput.Value
    $numericInput.Min = $Props.Min ?? $numericInput.Min
    $numericInput.Max = $Props.Max ?? $numericInput.Max
    $numericInput.Step = $Props.Step ?? $numericInput.Step
    $numericInput.DecimalPlaces = $Props.DecimalPlaces ?? $numericInput.DecimalPlaces
    $numericInput.Suffix = $Props.Suffix ?? $numericInput.Suffix
    $numericInput.OnChange = $Props.OnChange ?? $numericInput.OnChange
    
    # Update text value based on initial value
    $numericInput.TextValue = $numericInput.Value.ToString("F$($numericInput.DecimalPlaces)")
    
    return $numericInput
}

function New-TuiDateInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DateInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $dateInput = [DateInputComponent]::new($name)
    
    $dateInput.X = $Props.X ?? $dateInput.X
    $dateInput.Y = $Props.Y ?? $dateInput.Y
    $dateInput.Width = $Props.Width ?? $dateInput.Width
    $dateInput.Height = $Props.Height ?? $dateInput.Height
    $dateInput.Visible = $Props.Visible ?? $dateInput.Visible
    $dateInput.ZIndex = $Props.ZIndex ?? $dateInput.ZIndex
    $dateInput.Value = $Props.Value ?? $dateInput.Value
    $dateInput.MinDate = $Props.MinDate ?? $dateInput.MinDate
    $dateInput.MaxDate = $Props.MaxDate ?? $dateInput.MaxDate
    $dateInput.Format = $Props.Format ?? $dateInput.Format
    $dateInput.OnChange = $Props.OnChange ?? $dateInput.OnChange
    
    # Update text value based on initial value
    $dateInput.TextValue = $dateInput.Value.ToString($dateInput.Format)
    
    return $dateInput
}

function New-TuiComboBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "ComboBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $comboBox = [ComboBoxComponent]::new($name)
    
    $comboBox.X = $Props.X ?? $comboBox.X
    $comboBox.Y = $Props.Y ?? $comboBox.Y
    $comboBox.Width = $Props.Width ?? $comboBox.Width
    $comboBox.Height = $Props.Height ?? $comboBox.Height
    $comboBox.Visible = $Props.Visible ?? $comboBox.Visible
    $comboBox.ZIndex = $Props.ZIndex ?? $comboBox.ZIndex
    $comboBox.DisplayMember = $Props.DisplayMember ?? $comboBox.DisplayMember
    $comboBox.ValueMember = $Props.ValueMember ?? $comboBox.ValueMember
    $comboBox.Placeholder = $Props.Placeholder ?? $comboBox.Placeholder
    $comboBox.MaxDropDownHeight = $Props.MaxDropDownHeight ?? $comboBox.MaxDropDownHeight
    $comboBox.OnSelectionChanged = $Props.OnSelectionChanged ?? $comboBox.OnSelectionChanged
    
    if ($Props.Items) {
        $comboBox.SetItems($Props.Items)
    }
    
    if ($Props.SelectedItem) {
        $comboBox.SelectedItem = $Props.SelectedItem
    }
    
    return $comboBox
}

#endregion

Export-ModuleMember -Function 'New-TuiMultilineTextBox', 'New-TuiNumericInput', 'New-TuiDateInput', 'New-TuiComboBox'


####\components\navigation-class.psm1
# Navigation Component Classes Module for PMC Terminal v5
# Phase 1 Migration Complete - Proper UIElement inheritance and Panel integration

using namespace System.Management.Automation
using module .\tui-primitives.psm1
using module .\ui-classes.psm1
using module ..\modules\exceptions.psm1
using module ..\modules\logger.psm1
using module ..\layout\panels-class.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        $display = "[$($this.Key)] "
        
        if ($this.Enabled) {
            $display += $this.Label
        }
        else {
            $display += "$($this.Label) (Disabled)"
        }
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            $display += " - $($this.Description)"
        }
        
        return $display
    }
}

# AI: REFACTORED - NavigationMenu now properly inherits from UIElement
class NavigationMenu : UIElement {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    [bool] $IsFocused = $false
    
    NavigationMenu([string]$name) : base() {
        $this.Name = $name
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.SelectedIndex = 0
        $this.Width = 30
        $this.Height = 10
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base() {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Name = $name
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.SelectedIndex = 0
        $this.Width = 30
        $this.Height = 10
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) { 
            throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") 
        }
        $this.Items.Add($item)
        $this.RequestRedraw()
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { 
            [void]$this.Items.Remove($item)
            $this.RequestRedraw()
        }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { 
                $item.Execute() 
            }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
        $this.RequestRedraw()
    }

    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", { 
                    $this.Services.Navigation.GoTo("/tasks", @{mode="new"}) 
                }))
                $this.AddItem([NavigationItem]::new("P", "Projects", { 
                    $this.Services.Navigation.GoTo("/projects", @{}) 
                }))
                $this.AddItem([NavigationItem]::new("S", "Settings", { 
                    $this.Services.Navigation.GoTo("/settings", @{}) 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("Q", "Quit", { 
                    $this.Services.Navigation.RequestExit() 
                }))
            }
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", { 
                    Write-Host "New task not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("E", "Edit", { 
                    Write-Host "Edit not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("D", "Delete", { 
                    Write-Host "Delete not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("F", "Filter", { 
                    Write-Host "Filter not implemented" 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
            }
            default {
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
                $this.AddItem([NavigationItem]::new("H", "Home", { 
                    $this.Services.Navigation.GoTo("/dashboard", @{}) 
                }))
            }
        }
    }
    
    # AI: REFACTORED - Now uses Panel buffer integration
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear our buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Get visible items
            $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
            if ($visibleItems.Count -eq 0) { return }
            
            if ($this.Orientation -eq "Horizontal") { 
                $this.RenderHorizontal($visibleItems) 
            }
            else { 
                $this.RenderVertical($visibleItems) 
            }
            
        } catch { 
            Write-Log -Level Error -Message "NavigationMenu render error for '$($this.Name)': $_" 
        }
    }
    
    hidden [void] RenderHorizontal([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) { return }
        
        $menuText = ""
        $isFirst = $true
        foreach ($item in $items) {
            if ($null -eq $item) { continue }
            
            if (-not $isFirst) {
                $menuText += $this.Separator
            }
            $menuText += "[$($item.Key)] $($item.Label)"
            $isFirst = $false
        }
        
        # Write to our private buffer
        $this._private_buffer.WriteString(0, 0, $menuText, [ConsoleColor]::White, [ConsoleColor]::Black)
    }
    
    hidden [void] RenderVertical([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) { return }
        
        # Ensure SelectedIndex is within bounds
        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {
            $this.SelectedIndex = 0
        }
        
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($null -eq $item) { continue }
            
            $prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }
            $menuText = "$prefix[$($item.Key)] $($item.Label)"
            
            # Pad text to clear the full line width
            if ($menuText.Length -lt $this.Width) {
                $menuText = $menuText.PadRight($this.Width)
            }
            
            $fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                [ConsoleColor]::Black 
            } else { 
                [ConsoleColor]::White 
            }
            $bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                [ConsoleColor]::White 
            } else { 
                [ConsoleColor]::Black 
            }
            
            # Write to our private buffer
            $this._private_buffer.WriteString(0, $i, $menuText, $fg, $bg)
        }
    }
    
    # AI: REFACTORED - Updated input handling for new architecture
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
            if ($visibleItems.Count -eq 0) { return $false }
            
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt ($visibleItems.Count - 1)) {
                        $this.SelectedIndex++
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $visibleItems.Count) {
                        $selectedItem = $visibleItems[$this.SelectedIndex]
                        if ($selectedItem.Enabled -and $selectedItem.Key -ne "-") {
                            $selectedItem.Execute()
                        }
                    }
                    return $true
                }
                default {
                    # Check for direct key matches
                    $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
                    $matchingItem = $this.Items.Find({param($x) $x.Key -eq $keyChar})
                    if ($matchingItem -and $matchingItem.Enabled -and $matchingItem.Visible) {
                        $matchingItem.Execute()
                        return $true
                    }
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "NavigationMenu input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    # AI: NEW - Focus management
    [void] OnFocus() {
        $this.IsFocused = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        $this.IsFocused = $false
        $this.RequestRedraw()
    }
}

Export-ModuleMember -Function @()


####\components\tui-components.psm1
# TUI Component Library - Phase 1 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

using module ..\components\tui-primitives.psm1

#region Core UI Components

# AI: REFACTORED - LabelComponent now properly inherits from UIElement
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor
    
    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Now renders to parent Panel's buffer instead of direct output
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            $parentPanel = [Panel]$this.Parent
            
            # AI: Calculate position relative to parent's content area
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            # AI: Render to parent's buffer
            $parentPanel.WriteToBuffer($renderX, $renderY, $this.Text, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "Label render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false # Labels don't handle input
    }
}

# AI: REFACTORED - ButtonComponent updated for buffer-based rendering
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick
    
    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
        $this.Text = "Button"
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Buffer-based rendering with parent Panel integration
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            $bgColor = $this.IsPressed ? [ConsoleColor]::Yellow : [ConsoleColor]::Black
            $fgColor = $this.IsPressed ? [ConsoleColor]::Black : $borderColor
            
            # AI: Render border to parent buffer
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, $bgColor)
            
            # AI: Render text centered
            $textX = $renderX + [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = $renderY + [Math]::Floor($this.Height / 2)
            $parentPanel.WriteToBuffer($textX, $textY, $this.Text, $fgColor, $bgColor)
            
        } catch { 
            Write-Log -Level Error -Message "Button render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsPressed = $true
                $this.Parent.RequestRedraw()
                
                if ($this.OnClick) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock { & $this.OnClick }
                }
                
                $this.IsPressed = $false
                $this.Parent.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "Button input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: REFACTORED - TextBoxComponent with buffer-based rendering
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.MaxLength = 100
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Renders to parent Panel buffer
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display text or placeholder
            $displayText = $this.Text ?? ""
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = $this.Placeholder ?? "" 
            }
            
            $maxDisplayLength = $this.Width - 4
            if ($displayText.Length -gt $maxDisplayLength) { 
                $displayText = $displayText.Substring(0, $maxDisplayLength) 
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, [ConsoleColor]::White, [ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $displayText.Length) {
                $cursorX = $textX + $this.CursorPosition
                if ($cursorX < $renderX + $this.Width - 2) {
                    $parentPanel.WriteToBuffer($cursorX, $textY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "TextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition ?? 0
            $originalText = $currentText
            
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $currentText = $currentText.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    } 
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $currentText.Length) { 
                        $currentText = $currentText.Remove($cursorPos, 1) 
                    } 
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- } 
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $currentText.Length) { $cursorPos++ } 
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $currentText.Length }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) { 
                        $currentText = $currentText.Insert($cursorPos, $key.KeyChar)
                        $cursorPos++ 
                    } else { 
                        return $false 
                    }
                }
            }
            
            if ($currentText -ne $originalText -or $cursorPos -ne $this.CursorPosition) {
                $this.Text = $currentText
                $this.CursorPosition = $cursorPos
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $currentText 
                    }
                }
                $this.Parent.RequestRedraw()
            }
            return $true
        } catch { 
            Write-Log -Level Error -Message "TextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
}

# AI: NEW - CheckBoxComponent converted from functional to class-based
class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange
    
    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $checkbox = $this.Checked ? "[X]" : "[ ]"
            $displayText = "$checkbox $($this.Text)"
            
            $parentPanel.WriteToBuffer($renderX, $renderY, $displayText, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "CheckBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Checked = -not $this.Checked
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $this.Checked 
                    } 
                }
                $this.Parent.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "CheckBox input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: NEW - RadioButtonComponent converted from functional to class-based
class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange
    
    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $radio = $this.Selected ? "(●)" : "( )"
            $displayText = "$radio $($this.Text)"
            
            $parentPanel.WriteToBuffer($renderX, $renderY, $displayText, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "RadioButton render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if (-not $this.Selected) {
                    # AI: Unselect other radio buttons in the same group
                    if ($this.Parent -and $this.GroupName) {
                        $siblingRadios = $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        }
                        foreach ($radio in $siblingRadios) {
                            $radio.Selected = $false
                        }
                    }
                    
                    $this.Selected = $true
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $this.Selected 
                        } 
                    }
                    $this.Parent.RequestRedraw()
                }
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "RadioButton input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $label = [LabelComponent]::new($name)
    
    $label.X = $Props.X ?? $label.X
    $label.Y = $Props.Y ?? $label.Y
    $label.Width = $Props.Width ?? $label.Width
    $label.Height = $Props.Height ?? $label.Height
    $label.Visible = $Props.Visible ?? $label.Visible
    $label.ZIndex = $Props.ZIndex ?? $label.ZIndex
    $label.Text = $Props.Text ?? $label.Text
    $label.ForegroundColor = $Props.ForegroundColor ?? $label.ForegroundColor
    
    return $label
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $button = [ButtonComponent]::new($name)
    
    $button.X = $Props.X ?? $button.X
    $button.Y = $Props.Y ?? $button.Y
    $button.Width = $Props.Width ?? $button.Width
    $button.Height = $Props.Height ?? $button.Height
    $button.Visible = $Props.Visible ?? $button.Visible
    $button.ZIndex = $Props.ZIndex ?? $button.ZIndex
    $button.Text = $Props.Text ?? $button.Text
    $button.OnClick = $Props.OnClick ?? $button.OnClick
    
    return $button
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [TextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Text = $Props.Text ?? $textBox.Text
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLength = $Props.MaxLength ?? $textBox.MaxLength
    $textBox.CursorPosition = $Props.CursorPosition ?? $textBox.CursorPosition
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    return $textBox
}

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $checkBox = [CheckBoxComponent]::new($name)
    
    $checkBox.X = $Props.X ?? $checkBox.X
    $checkBox.Y = $Props.Y ?? $checkBox.Y
    $checkBox.Width = $Props.Width ?? $checkBox.Width
    $checkBox.Height = $Props.Height ?? $checkBox.Height
    $checkBox.Visible = $Props.Visible ?? $checkBox.Visible
    $checkBox.ZIndex = $Props.ZIndex ?? $checkBox.ZIndex
    $checkBox.Text = $Props.Text ?? $checkBox.Text
    $checkBox.Checked = $Props.Checked ?? $checkBox.Checked
    $checkBox.OnChange = $Props.OnChange ?? $checkBox.OnChange
    
    return $checkBox
}

function New-TuiRadioButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $radioButton = [RadioButtonComponent]::new($name)
    
    $radioButton.X = $Props.X ?? $radioButton.X
    $radioButton.Y = $Props.Y ?? $radioButton.Y
    $radioButton.Width = $Props.Width ?? $radioButton.Width
    $radioButton.Height = $Props.Height ?? $radioButton.Height
    $radioButton.Visible = $Props.Visible ?? $radioButton.Visible
    $radioButton.ZIndex = $Props.ZIndex ?? $radioButton.ZIndex
    $radioButton.Text = $Props.Text ?? $radioButton.Text
    $radioButton.Selected = $Props.Selected ?? $radioButton.Selected
    $radioButton.GroupName = $Props.GroupName ?? $radioButton.GroupName
    $radioButton.OnChange = $Props.OnChange ?? $radioButton.OnChange
    
    return $radioButton
}

#endregion

Export-ModuleMember -Function 'New-TuiLabel', 'New-TuiButton', 'New-TuiTextBox', 'New-TuiCheckBox', 'New-TuiRadioButton'


####\components\tui-primitives.psm1
# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations

using namespace System
using namespace System.Management.Automation

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    [ConsoleColor] $ForegroundColor = [ConsoleColor]::White
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = ""
    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() {
        $this.Char = ' '
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Character constructor
    TuiCell([char]$char) {
        $this.Char = $char
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Full constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }

    # Style constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }

    # Copy constructor
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.StyleFlags = $other.StyleFlags
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Create a styled copy
    [TuiCell] WithStyle([ConsoleColor]$fg, [ConsoleColor]$bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    # Create a character copy
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blend this cell with another (higher Z-index wins)
    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return $other }
        if ($other.ZIndex -eq $this.ZIndex -and $other.Char -ne ' ') { return $other }
        return $this
    }

    # Check if this cell differs from another
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic)
    }

    # Generate ANSI escape sequence for this cell
    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Color codes
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append("`e[${fgCode};${bgCode}")
        
        # Style codes
        if ($this.Bold) { [void]$sb.Append(";1") }
        if ($this.Underline) { [void]$sb.Append(";4") }
        if ($this.Italic) { [void]$sb.Append(";3") }
        
        [void]$sb.Append("m").Append($this.Char)
        return $sb.ToString()
    }

    # Convert to legacy buffer format for compatibility
    [hashtable] ToLegacyFormat() {
        return @{
            Char = $this.Char
            FG = $this.ForegroundColor
            BG = $this.BackgroundColor
        }
    }

    # String representation
    [string] ToString() {
        return "TuiCell($($this.Char), $($this.ForegroundColor), $($this.BackgroundColor))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int] GetForegroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()]
    }

    static [int] GetBackgroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()] + 10
    }

    static [string] Reset() {
        return "`e[0m"
    }

    static [string] Bold() {
        return "`e[1m"
    }

    static [string] Underline() {
        return "`e[4m"
    }

    static [string] Italic() {
        return "`e[3m"
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions
function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    
    $cell = [TuiCell]::new(' ', $ForegroundColor, $BackgroundColor)
    $cell.Bold = $Bold
    $cell.Underline = $Underline
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0) {
            $charCell = [TuiCell]::new($cell)
            $charCell.Char = $char
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$BorderStyle = "Single",
        [ConsoleColor]$BorderColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }
    
    $borders = Get-TuiBorderChars -Style $BorderStyle
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Side borders and fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        $currentY = $Y + $i
        
        # Left border
        Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill
        $fillText = ' ' * ($Width - 2)
        Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -BackgroundColor $BackgroundColor
        
        # Right border
        Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $bottomLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all functions
Export-ModuleMember -Function 'Write-TuiText', 'Write-TuiBox', 'Get-TuiBorderChars'


####\components\ui-classes.psm1
# ==============================================================================
# PMC Terminal v5 - Base UI Class Hierarchy
# Provides the foundational classes for all UI components with NCurses compositor support.
# ==============================================================================

using namespace System.Text
using namespace System.Management.Automation
using module '.\tui-primitives.psm1'
using module '..\modules\exceptions.psm1'

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# --- Enhanced UI Element with Buffer Management ---
class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [bool] $IsFocused = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer = $null
    [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{}

    # Constructor
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with name
    UIElement([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [ArgumentException]::new("UIElement name cannot be null or empty.")
        }
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with position and size
    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Buffer")
    }

    # Get absolute screen position
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # Add child component
    [void] AddChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
        }
    }

    # Remove child component
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
            $this.RequestRedraw()
        }
    }

    # Request redraw for this component and parents
    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
    }

    # Resize the component and its buffer
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Resize($newWidth, $newHeight)
        }
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # Move the component
    [void] Move([int]$newX, [int]$newY) {
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
    }

    # Check if point is within component bounds
    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge $this.X -and $x -lt ($this.X + $this.Width) -and 
                $y -ge $this.Y -and $y -lt ($this.Y + $this.Height))
    }

    # Get child at specific point (relative to this component)
    [UIElement] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $this.X, $y - $this.Y)) {
                return $child
            }
        }
        return $null
    }

    # Virtual methods for subclasses to override
    [void] OnRender() {
        # Default implementation - clear buffer
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Override in subclasses
    }

    [void] OnMove([int]$newX, [int]$newY) {
        # Override in subclasses
    }

    [void] OnFocus() {
        # Override in subclasses
    }

    [void] OnBlur() {
        # Override in subclasses
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Override in subclasses - return true if input was handled
        return $false
    }

    # Main render method with error handling - calls _RenderContent and renders children
    [void] Render() {
        Invoke-WithErrorHandling -Component $this.Name -Context "Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            $this._RenderContent()
        } -AdditionalData @{ ComponentType = $this.GetType().Name }
    }

    # Protected render implementation - can be overridden by subclasses
    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }

        # Render this component to its private buffer
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer) {
                $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }
            
            $this.OnRender()
            $this._needs_redraw = $false
        }

        # Render children to their buffers, then composite onto parent
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
    }

    # Get the final rendered buffer
    [TuiBuffer] GetBuffer() {
        return $this._private_buffer
    }
    
    [string] ToString() {
        return "$($this.GetType().Name): $($this.Name)"
    }
}

# --- Base Component (can contain children) ---
class Component : UIElement {
    Component([string]$name) : base($name) {
    }

    # AI: Default implementation renders all visible children to buffer
    hidden [void] _RenderContent() {
        # Call parent implementation for buffer management
        ([UIElement]$this)._RenderContent()
    }
}

# --- Base Panel (rectangular area) ---
class Panel : Component {
    [string]$Title = ""
    [bool]$ShowBorder = $true

    Panel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name) {
        if ($width -le 0 -or $height -le 0) { throw [ArgumentOutOfRangeException]::new("Panel dimensions must be positive.") }
        
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Resize($width, $height)  # Initialize buffer with correct size
    }

    [hashtable] GetContentArea() {
        $borderOffset = $this.ShowBorder ? 1 : 0
        return @{
            X      = $this.X + $borderOffset
            Y      = $this.Y + $borderOffset
            Width  = $this.Width - (2 * $borderOffset)
            Height = $this.Height - (2 * $borderOffset)
        }
    }
    
    # AI: Panel renders its children but doesn't draw borders (subclasses like BorderPanel handle that)
    hidden [void] _RenderContent() {
        # Default panel just renders children using parent implementation
        ([Component]$this)._RenderContent()
    }
}

# --- Base Screen (top-level container) ---
class Screen : UIElement {
    [hashtable]$Services
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[Panel]]$Panels
    hidden [System.Collections.Generic.Dictionary[string, string]]$EventSubscriptions

    Screen([string]$name, [hashtable]$services) : base($name) {
        if (-not $services) { throw [ArgumentNullException]::new("services") }
        
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[Panel]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
    }
    
    [void] Initialize() { }
    [void] OnEnter() { }
    [void] OnExit() { }
    [void] OnResume() { }
    [void] HandleInput([System.ConsoleKeyInfo]$key) { }

    [void] Cleanup() {
        foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -SubscriberId $kvp.Value
            }
            catch {
                Write-Log -Level Warning -Message "Failed to unregister event '$($kvp.Key)' for screen '$($this.Name)'."
            }
        }
        $this.EventSubscriptions.Clear()
        $this.Panels.Clear()
        Write-Log -Level Debug -Message "Cleaned up screen: $($this.Name)"
    }
    
    [void] AddPanel([Panel]$panel) {
        if (-not $panel) { throw [ArgumentNullException]::new("panel") }
        $this.Panels.Add($panel)
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($eventName)) { throw [ArgumentException]::new("Event name cannot be null or empty.") }
        if (-not $action) { throw [ArgumentNullException]::new("action") }
        
        # AI: Fixed parameter name from -Action to -Handler to match event-system.psm1 function signature
        $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
        $this.EventSubscriptions[$eventName] = $subscriptionId
    }
    
    # AI: Override _RenderContent to render all panels to buffer
    hidden [void] _RenderContent() {
        # Call base implementation for buffer management
        ([UIElement]$this)._RenderContent()
        
        # Render all panels in the screen to the back-buffer
        foreach ($panel in $this.Panels) {
            if ($panel.Visible) {
                $panel.Render()
            }
        }
    }
}


####\layout\panels-class.psm1
# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

# Import TUI primitives and base classes
using namespace System
using namespace System.Management.Automation
using module ..\components\tui-primitives.psm1
using module ..\components\ui-classes.psm1

#region Panel Class - Basic Layout Container
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $this.ContentX
            $child.Y = $currentY
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $currentX
            $child.Y = $this.ContentY
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        # Calculate grid dimensions
        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            # Adjust size for last column/row
            $width = if ($col -eq ($cols - 1)) { 
                $this.ContentX + $this.ContentWidth - $x 
            } else { 
                $cellWidth 
            }
            $height = if ($row -eq ($rows - 1)) { 
                $this.ContentY + $this.ContentHeight - $y 
            } else { 
                $cellHeight 
            }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    # Set border style and update content bounds
    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    # Enable/disable border
    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    # Set title
    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    # Check if point is within content area
    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    # Get content bounds as hashtable
    [hashtable] GetContentBounds() {
        return @{
            X = $this.ContentX
            Y = $this.ContentY
            Width = $this.ContentWidth
            Height = $this.ContentHeight
        }
    }

    # Clear content area only
    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return }

        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    # Main render implementation - override from UIElement
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }

        # Clear entire buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this._private_buffer.Clear($bgCell)

        # Draw border if enabled
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }

        # Fill content area
        $this.ClearContent()
    }

    # Handle focus for focusable panels
    [void] OnFocus() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Cyan
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Gray
            $this.RequestRedraw()
        }
    }

    # Find first focusable child
    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    # Get all focusable children (recursive)
    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        
        return $focusable
    }

    # Basic input handling - delegate to focused child
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # If this panel can focus and is focused, handle some basic navigation
        if ($this.CanFocus -and $this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
            }
        }

        # Delegate to children
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }

        return $false
    }

    # String representation
    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}
#endregion

#region Specialized Panel Types

# Scrollable Panel - supports content larger than visible area
class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    # Constructor
    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    # Set virtual content size
    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        
        # Create virtual buffer if needed
        if ($width -gt 0 -and $height -gt 0) {
            $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        
        $this.RequestRedraw()
    }

    # Scroll to position
    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        
        $this.RequestRedraw()
    }

    # Scroll by delta
    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    # Handle scrolling input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }

        return ([Panel]$this).HandleInput($keyInfo)
    }

    # Render with scrolling support
    [void] OnRender() {
        # Render base panel
        ([Panel]$this).OnRender()

        # Render virtual content if available
        if ($null -ne $this._virtual_buffer) {
            # Create a sub-buffer view of the virtual content
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            
            # Blend visible content onto our buffer
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }

        # Draw scrollbars if enabled and needed
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    # Draw scrollbar indicators
    [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return }

        # Vertical scrollbar
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
        }

        # Horizontal scrollbar
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    # Get virtual content buffer for external drawing
    [TuiBuffer] GetVirtualBuffer() {
        return $this._virtual_buffer
    }
}

# Group Panel - collapsible panel with header
class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    # Toggle collapsed state
    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)  # Just header + border
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        
        # Update child visibility
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        
        $this.RequestRedraw()
    }

    # Handle collapse/expand input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }

        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        
        return $false
    }

    # Render with collapse indicator
    [void] OnRender() {
        ([Panel]$this).OnRender()

        # Draw collapse/expand indicator in title area
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            $this._private_buffer.SetCell(2, 0, $indicatorCell)
        }
    }
}
#endregion

# Export the Panel classes
Export-ModuleMember -Function @()



####\modules\data-manager.psm1

# Data Manager Module
# Unified data persistence and CRUD operations with event integration

using module ..\modules\models.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Module-level state variables
$script:Data = @{
    Projects = [System.Collections.Generic.List[PmcProject]]::new()
    Tasks = [System.Collections.Generic.List[PmcTask]]::new()
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    time_entries = @() # underscore format for action compatibility
    timers = @()       # for action compatibility
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system, loads data, and returns a service instance.
    #>
    [CmdletBinding()]
    param()
    
    return Invoke-WithErrorHandling -Component "DataManager.Initialize" -Context "DataManager initialization" -ScriptBlock {
        $dataDirectory = Split-Path $script:DataPath -Parent
        if (-not (Test-Path $dataDirectory)) {
            New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
            Write-Log -Level Info -Message "Created data directory: $dataDirectory"
        }
        
        if (-not (Test-Path $script:BackupPath)) {
            New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
            Write-Log -Level Info -Message "Created backup directory: $script:BackupPath"
        }
        
        Load-UnifiedData
        Initialize-DataEventHandlers
        
        Write-Log -Level Info -Message "DataManager initialized successfully"
        return [DataManager]::new()
    }
}

function Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads application data from disk into strongly-typed objects.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.LoadData" -Context "Loading unified data from disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            try {
                $loadedData = Get-Content -Path $script:DataPath -Raw | ConvertFrom-Json -AsHashtable
                
                if ($loadedData -is [hashtable]) {
                    if ($loadedData.Tasks) {
                        $script:Data.Tasks.Clear()
                        foreach ($taskData in $loadedData.Tasks) {
                            if ($taskData -is [hashtable]) { $script:Data.Tasks.Add([PmcTask]::FromLegacyFormat($taskData)) }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Tasks.Count) tasks as PmcTask objects"
                    }
                    
                    if ($loadedData.Projects -is [hashtable]) {
                        $script:Data.Projects.Clear()
                        foreach ($projectKey in $loadedData.Projects.Keys) {
                            $projectData = $loadedData.Projects[$projectKey]
                            if ($projectData -is [hashtable]) { $script:Data.Projects.Add([PmcProject]::FromLegacyFormat($projectData)) }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Projects.Count) projects as PmcProject objects"
                    }
                    
                    foreach ($key in 'TimeEntries', 'ActiveTimers', 'TodoTemplates', 'Settings', 'time_entries', 'timers') {
                        if ($loadedData.ContainsKey($key)) { $script:Data[$key] = $loadedData[$key] }
                    }
                    
                    $global:Data = $script:Data
                    Write-Log -Level Info -Message "Data loaded successfully from disk"
                } else {
                    Write-Log -Level Warning -Message "Invalid data format in file, using defaults"
                    $global:Data = $script:Data
                }
            } catch {
                Write-Log -Level Error -Message "Failed to parse data file: $_"
                $global:Data = $script:Data
            }
        } else {
            Write-Log -Level Info -Message "No existing data file found, using defaults"
            $global:Data = $script:Data
        }
        
        $script:LastSaveTime = Get-Date
    }
}

function Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves application data to disk with backup rotation.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.SaveData" -Context "Saving unified data to disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
            Copy-Item -Path $script:DataPath -Destination (Join-Path $script:BackupPath $backupName) -Force
            
            $backups = Get-ChildItem -Path $script:BackupPath -Filter "pmc-data_*.json" | Sort-Object LastWriteTime -Descending
            if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                $backups | Select-Object -Skip $script:Data.Settings.BackupCount | Remove-Item -Force
            }
        }
        
        $dataToSave = @{
            Tasks = @($script:Data.Tasks | ForEach-Object { $_.ToLegacyFormat() })
            Projects = @{}
            TimeEntries = $script:Data.TimeEntries
            ActiveTimers = $script:Data.ActiveTimers
            TodoTemplates = $script:Data.TodoTemplates
            Settings = $script:Data.Settings
            time_entries = $script:Data.time_entries
            timers = $script:Data.timers
        }
        
        foreach ($project in $script:Data.Projects) { $dataToSave.Projects[$project.Key] = $project.ToLegacyFormat() }
        
        $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $script:DataPath -Encoding UTF8
        $script:LastSaveTime = Get-Date; $script:DataModified = $false
        Write-Log -Level Debug -Message "Data saved successfully"
    }
}

#region Task Management Functions

function Add-PmcTask {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [ValidateNotNullOrEmpty()] [string]$Title,
        [string]$Description = "",
        [ValidateSet("low", "medium", "high")] [string]$Priority = "medium",
        [string]$Category = "General",
        [string]$DueDate = ""
    )
    
    return Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task" -ScriptBlock {
        if ([string]::IsNullOrWhiteSpace($Title)) { throw [StateMutationException]::new("Task title cannot be empty", @{ Title = $Title }) }
        
        $taskPriority = [TaskPriority]::$Priority
        $newTask = [PmcTask]::new($Title, $Description, $taskPriority, $Category)
        
        if ($DueDate -and $DueDate -ne "N/A") {
            try { $newTask.DueDate = [datetime]::Parse($DueDate) } catch { Write-Log -Level Warning -Message "Invalid due date format: $DueDate" }
        }
        
        $script:Data.Tasks.Add($newTask); $script:DataModified = $true
        Write-Log -Level Info -Message "Created task '$($newTask.Title)' with ID $($newTask.Id)"
        
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        
        Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Created"; TaskId = $newTask.Id; Task = $newTask }
        return $newTask
    }
}

function Update-PmcTask {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [PmcTask]$Task,
        [string]$Title, [string]$Description, [ValidateSet("low", "medium", "high")] [string]$Priority,
        [string]$Category, [string]$DueDate, [bool]$Completed, [ValidateRange(0, 100)] [int]$Progress
    )
    
    return Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating task" -ScriptBlock {
        $managedTask = $script:Data.Tasks.Find({$_.Id -eq $Task.Id})
        if (-not $managedTask) { throw [StateMutationException]::new("Task not found in data store", @{ TaskId = $Task.Id }) }
        
        $updatedFields = @()
        if ($PSBoundParameters.ContainsKey('Title')) { $managedTask.Title = $Title.Trim(); $updatedFields += "Title" }
        if ($PSBoundParameters.ContainsKey('Description')) { $managedTask.Description = $Description; $updatedFields += "Description" }
        if ($PSBoundParameters.ContainsKey('Priority')) { $managedTask.Priority = [TaskPriority]::$Priority; $updatedFields += "Priority" }
        if ($PSBoundParameters.ContainsKey('Category')) { $managedTask.ProjectKey = $Category; $managedTask.Category = $Category; $updatedFields += "Category" }
        if ($PSBoundParameters.ContainsKey('DueDate')) {
            try { $managedTask.DueDate = ($DueDate -and $DueDate -ne "N/A") ? [datetime]::Parse($DueDate) : $null } catch { Write-Log -Level Warning -Message "Invalid due date format: $DueDate" }
            $updatedFields += "DueDate"
        }
        if ($PSBoundParameters.ContainsKey('Progress')) { $managedTask.UpdateProgress($Progress); $updatedFields += "Progress" }
        if ($PSBoundParameters.ContainsKey('Completed')) {
            if ($Completed) { $managedTask.Complete() } else { $managedTask.Status = [TaskStatus]::Pending; $managedTask.Completed = $false; $managedTask.Progress = 0 }
            $updatedFields += "Completed"
        }
        
        $managedTask.UpdatedAt = [datetime]::Now; $script:DataModified = $true
        Write-Log -Level Info -Message "Updated task $($managedTask.Id) - Fields: $($updatedFields -join ', ')"
        
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        
        Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Updated"; TaskId = $managedTask.Id; Task = $managedTask; UpdatedFields = $updatedFields }
        return $managedTask
    }
}

function Remove-PmcTask {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [PmcTask]$Task)
    
    return Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task" -ScriptBlock {
        $taskToRemove = $script:Data.Tasks.Find({$_.Id -eq $Task.Id})
        if ($taskToRemove) {
            $script:Data.Tasks.Remove($taskToRemove) | Out-Null; $script:DataModified = $true
            Write-Log -Level Info -Message "Deleted task $($Task.Id)"
            if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Deleted"; TaskId = $Task.Id; Task = $Task }
            return $true
        }
        Write-Log -Level Warning -Message "Task not found with ID $($Task.Id)"; return $false
    }
}

function Get-PmcTasks {
    [CmdletBinding()]
    param([bool]$Completed, [ValidateSet("low", "medium", "high")] [string]$Priority, [string]$Category)
    
    return Invoke-WithErrorHandling -Component "DataManager.GetTasks" -Context "Retrieving tasks" -ScriptBlock {
        $tasks = $script:Data.Tasks
        if ($PSBoundParameters.ContainsKey('Completed')) { $tasks = $tasks | Where-Object { $_.Completed -eq $Completed } }
        if ($Priority) { $priorityEnum = [TaskPriority]::$Priority; $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum } }
        if ($Category) { $tasks = $tasks | Where-Object { $_.ProjectKey -eq $Category -or $_.Category -eq $Category } }
        return @($tasks)
    }
}

#endregion

#region Project Management Functions

function Get-PmcProjects { [CmdletBinding()] param() return @($script:Data.Projects) }
function Get-PmcProject { [CmdletBinding()] param([Parameter(Mandatory)] [string]$Key) return $script:Data.Projects.Find({$_.Key -eq $Key}) }

function Add-PmcProject {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [PmcProject]$Project)
    
    return Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding project" -ScriptBlock {
        if ($script:Data.Projects.Exists({$_.Key -eq $Project.Key})) { throw [StateMutationException]::new("Project with key '$($Project.Key)' already exists", @{ ProjectKey = $Project.Key }) }
        
        $script:Data.Projects.Add($Project); $script:DataModified = $true
        Write-Log -Level Info -Message "Created project '$($Project.Name)' with key $($Project.Key)"
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Created"; ProjectKey = $Project.Key; Project = $Project }
        return $Project
    }
}

#endregion

#region DataManager Class Definition

class DataManager {
    hidden [hashtable] $DataStore
    hidden [string] $DataFilePath
    hidden [bool] $AutoSaveEnabled = $true
    
    DataManager() {
        $this.DataStore = $script:Data
        $global:Data = $script:Data
        $this.DataFilePath = $script:DataPath
        $this.AutoSaveEnabled = $this.DataStore.Settings.AutoSave
    }

    [void] LoadData() { Load-UnifiedData }
    [void] SaveData() { Save-UnifiedData }
    [PmcTask] AddTask([string]$Title, [string]$Description, [TaskPriority]$Priority, [string]$ProjectKey) { return Add-PmcTask -Title $Title -Description $Description -Priority $Priority.ToString() -Category $ProjectKey }
    [PmcTask[]] GetTasks() { return @($this.DataStore.Tasks) }
    [PmcProject[]] GetProjects() { return @($this.DataStore.Projects) }
}

#endregion

#region Private Helper Functions

function Initialize-DataEventHandlers {
    Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -Context "Initializing data event handlers" -ScriptBlock {
        $null = Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Refreshed"; Tasks = @($script:Data.Tasks) }
        }
        Write-Log -Level Debug -Message "Data event handlers initialized"
    }
}

#endregion

Export-ModuleMember -Function 'Initialize-DataManager', 'Add-PmcTask', 'Update-PmcTask', 'Remove-PmcTask', 'Get-PmcTasks', 'Get-PmcProjects', 'Get-PmcProject', 'Add-PmcProject', 'Save-UnifiedData', 'Load-UnifiedData'



####\modules\dialog-system-class.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Base Dialog Class
class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    [int] $Width = 50
    [int] $Height = 10
    [int] $X
    [int] $Y
    [ConsoleColor] $BorderColor = [ConsoleColor]::Cyan
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [ConsoleColor] $MessageColor = [ConsoleColor]::Gray
    
    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    [void] Show() {
        # Calculate centered position
        $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
        $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 2)
        
        # Register with dialog manager
        $script:DialogState.CurrentDialog = $this
        Request-TuiRefresh
    }
    
    [void] Close() {
        $script:DialogState.CurrentDialog = $null
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        }
        Request-TuiRefresh
    }
    
    # Base render draws dialog frame
    hidden [void] _RenderContent() {
        # Draw dialog box
        Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height `
            -Title " $($this.Title) " -BorderColor $this.BorderColor
        
        # Draw message if present
        if (-not [string]::IsNullOrWhiteSpace($this.Message)) {
            $this.RenderMessage()
        }
        
        # Let derived classes render their specific content
        $this._RenderDialogContent()
    }
    
    hidden [void] RenderMessage() {
        $messageY = $this.Y + 2
        $messageX = $this.X + 2
        $maxWidth = $this.Width - 4
        
        $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
        foreach ($line in $wrappedLines) {
            if ($messageY -ge ($this.Y + $this.Height - 3)) { break }
            Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor $this.MessageColor
            $messageY++
        }
    }
    
    # Override in derived classes
    hidden [void] _RenderDialogContent() { }
    
    # Base input handling - ESC closes dialog
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.OnCancel()
        }
    }
    
    # Virtual methods for derived classes
    [void] OnConfirm() { $this.Close() }
    [void] OnCancel() { $this.Close() }
}

# Alert Dialog - Simple OK dialog
class AlertDialog : Dialog {
    [string] $ButtonText = "OK"
    
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 10
        $this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))
    }
    
    hidden [void] _RenderDialogContent() {
        # Render OK button
        $buttonY = $this.Y + $this.Height - 2
        $buttonText = "[ $($this.ButtonText) ]"
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
        
        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) { $this.OnConfirm() }
            ([ConsoleKey]::Spacebar) { $this.OnConfirm() }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
}

# Confirm Dialog - Yes/No dialog
class ConfirmDialog : Dialog {
    [scriptblock] $OnConfirmAction
    [scriptblock] $OnCancelAction
    [string[]] $Buttons = @("Yes", "No")
    [int] $SelectedButton = 0
    
    ConfirmDialog([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) : base("ConfirmDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.OnConfirmAction = $onConfirm
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render buttons
        $buttonY = $this.Y + $this.Height - 3
        $totalButtonWidth = ($this.Buttons.Count * 12) + (($this.Buttons.Count - 1) * 2)
        $buttonX = $this.X + [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        
        for ($i = 0; $i -lt $this.Buttons.Count; $i++) {
            $button = $this.Buttons[$i]
            $isSelected = ($i -eq $this.SelectedButton)
            $buttonText = if ($isSelected) { "[ $button ]" } else { "  $button  " }
            $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
            $buttonX += 14
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) { 
                $this.SelectedButton = [Math]::Max(0, $this.SelectedButton - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::RightArrow) { 
                $this.SelectedButton = [Math]::Min($this.Buttons.Count - 1, $this.SelectedButton + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Tab) { 
                $this.SelectedButton = ($this.SelectedButton + 1) % $this.Buttons.Count
                Request-TuiRefresh
            }
            ([ConsoleKey]::Enter) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Spacebar) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnConfirmAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnConfirm" -ScriptBlock $this.OnConfirmAction
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Input Dialog - Text input dialog
class InputDialog : Dialog {
    [string] $Prompt = ""
    [string] $InputValue = ""
    [string] $DefaultValue = ""
    [scriptblock] $OnSubmitAction
    [scriptblock] $OnCancelAction
    [int] $FocusedElement = 0  # 0=TextBox, 1=OK, 2=Cancel
    [int] $CursorPosition = 0
    
    InputDialog([string]$title, [string]$prompt, [scriptblock]$onSubmit, [scriptblock]$onCancel) : base("InputDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.OnSubmitAction = $onSubmit
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(70, [Math]::Max(50, $prompt.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render prompt
        $promptX = $this.X + 2
        $promptY = $this.Y + 2
        Write-BufferString -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor ([ConsoleColor]::White)
        
        # Render input box
        $inputY = $promptY + 2
        $inputWidth = $this.Width - 4
        $isFocused = ($this.FocusedElement -eq 0)
        $borderColor = if ($isFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::DarkGray }
        
        Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 -BorderColor $borderColor
        
        # Render input text
        $displayText = $this.InputValue
        if ($displayText.Length -gt ($inputWidth - 3)) {
            $displayText = $displayText.Substring(0, $inputWidth - 3)
        }
        Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText -ForegroundColor ([ConsoleColor]::White)
        
        # Show cursor when focused
        if ($isFocused -and $this.CursorPosition -le $displayText.Length) {
            Write-BufferString -X ($promptX + 1 + $this.CursorPosition) -Y ($inputY + 1) `
                -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
        }
        
        # Render buttons
        $buttonY = $this.Y + $this.Height - 2
        $buttonSpacing = 15
        $buttonsWidth = $buttonSpacing * 2
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonsWidth) / 2)
        
        # OK button
        $okFocused = ($this.FocusedElement -eq 1)
        $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
        $okColor = if ($okFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
        
        # Cancel button
        $cancelFocused = ($this.FocusedElement -eq 2)
        $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
        $cancelColor = if ($cancelFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Tab) {
                $direction = if ($key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                $this.FocusedElement = ($this.FocusedElement + $direction + 3) % 3
                Request-TuiRefresh
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
            default {
                switch ($this.FocusedElement) {
                    0 { # TextBox
                        switch ($key.Key) {
                            ([ConsoleKey]::Enter) { $this.OnConfirm() }
                            ([ConsoleKey]::Backspace) {
                                if ($this.InputValue.Length -gt 0 -and $this.CursorPosition -gt 0) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition - 1, 1)
                                    $this.CursorPosition--
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::Delete) {
                                if ($this.CursorPosition -lt $this.InputValue.Length) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition, 1)
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::LeftArrow) {
                                $this.CursorPosition = [Math]::Max(0, $this.CursorPosition - 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::RightArrow) {
                                $this.CursorPosition = [Math]::Min($this.InputValue.Length, $this.CursorPosition + 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::Home) {
                                $this.CursorPosition = 0
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::End) {
                                $this.CursorPosition = $this.InputValue.Length
                                Request-TuiRefresh
                            }
                            default {
                                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                                    $this.InputValue = $this.InputValue.Insert($this.CursorPosition, $key.KeyChar)
                                    $this.CursorPosition++
                                    Request-TuiRefresh
                                }
                            }
                        }
                    }
                    1 { # OK Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnConfirm()
                        }
                    }
                    2 { # Cancel Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnCancel()
                        }
                    }
                }
            }
        }
    }
    
    [void] SetDefaultValue([string]$value) {
        $this.InputValue = $value
        $this.DefaultValue = $value
        $this.CursorPosition = $value.Length
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSubmitAction) {
            $value = $this.InputValue
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnSubmit" -ScriptBlock {
                & $this.OnSubmitAction -Value $value
            }.GetNewClosure()
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Progress Dialog
class ProgressDialog : Dialog {
    [int] $PercentComplete = 0
    [bool] $ShowCancel = $false
    [bool] $IsCancelled = $false
    
    ProgressDialog([string]$title, [string]$message) : base("ProgressDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Width = 60
        $this.Height = 8
    }
    
    hidden [void] _RenderDialogContent() {
        # Render progress bar
        $barY = $this.Y + 4
        $barWidth = $this.Width - 4
        $filledWidth = [Math]::Floor($barWidth * ($this.PercentComplete / 100.0))
        
        # Draw bar background
        Write-BufferString -X ($this.X + 2) -Y $barY -Text ("─" * $barWidth) -ForegroundColor ([ConsoleColor]::DarkGray)
        
        # Draw filled portion
        if ($filledWidth -gt 0) {
            Write-BufferString -X ($this.X + 2) -Y $barY -Text ("█" * $filledWidth) -ForegroundColor ([ConsoleColor]::Green)
        }
        
        # Draw percentage
        $percentText = "$($this.PercentComplete)%"
        $percentX = $this.X + [Math]::Floor(($this.Width - $percentText.Length) / 2)
        Write-BufferString -X $percentX -Y $barY -Text $percentText -ForegroundColor ([ConsoleColor]::White)
        
        # Draw cancel button if enabled
        if ($this.ShowCancel) {
            $buttonY = $this.Y + $this.Height - 2
            $buttonText = if ($this.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
            $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
        }
    }
    
    [void] UpdateProgress([int]$percent, [string]$message) {
        $this.PercentComplete = [Math]::Min(100, [Math]::Max(0, $percent))
        if (-not [string]::IsNullOrWhiteSpace($message)) {
            $this.Message = $message
        }
        Request-TuiRefresh
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($this.ShowCancel -and -not $this.IsCancelled) {
            if ($key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsCancelled = $true
                Request-TuiRefresh
            }
        }
    }
}

# List Dialog
class ListDialog : Dialog {
    [string[]] $Items = @()
    [int] $SelectedIndex = 0
    [bool] $AllowMultiple = $false
    [System.Collections.Generic.HashSet[int]] $SelectedItems
    [scriptblock] $OnSelectAction
    [scriptblock] $OnCancelAction
    
    ListDialog([string]$title, [string]$prompt, [string[]]$items, [scriptblock]$onSelect, [scriptblock]$onCancel) : base("ListDialog") {
        $this.Title = $title
        $this.Message = $prompt
        $this.Items = $items
        $this.OnSelectAction = $onSelect
        $this.OnCancelAction = $onCancel
        $this.Width = 60
        $this.Height = [Math]::Min(20, $items.Count + 8)
        $this.SelectedItems = [System.Collections.Generic.HashSet[int]]::new()
    }
    
    hidden [void] _RenderDialogContent() {
        $listY = $this.Y + 4
        $listHeight = $this.Height - 7
        $listWidth = $this.Width - 4
        
        # Calculate visible range with scrolling
        $startIndex = [Math]::Max(0, $this.SelectedIndex - [Math]::Floor($listHeight / 2))
        $endIndex = [Math]::Min($this.Items.Count - 1, $startIndex + $listHeight - 1)
        
        # Render items
        for ($i = $startIndex; $i -le $endIndex; $i++) {
            $itemY = $listY + ($i - $startIndex)
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex)
            $isChecked = $this.SelectedItems.Contains($i)
            
            $prefix = if ($this.AllowMultiple) {
                if ($isChecked) { "[X] " } else { "[ ] " }
            } else { "" }
            
            $itemText = "$prefix$item"
            if ($itemText.Length -gt $listWidth - 2) {
                $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
            }
            
            $bgColor = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            $fgColor = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::Gray }
            
            # Clear the line first
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text (" " * ($listWidth - 2)) -BackgroundColor $bgColor
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text $itemText -ForegroundColor $fgColor -BackgroundColor $bgColor
        }
        
        # Render scrollbar if needed
        if ($this.Items.Count -gt $listHeight) {
            $scrollbarX = $this.X + $this.Width - 2
            $scrollbarHeight = $listHeight
            $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $this.Items.Count))
            $thumbPos = [Math]::Floor($scrollbarHeight * $this.SelectedIndex / $this.Items.Count)
            
            for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char -ForegroundColor ([ConsoleColor]::DarkGray)
            }
        }
        
        # Render buttons for multi-select
        if ($this.AllowMultiple) {
            $buttonY = $this.Y + $this.Height - 2
            $okText = "[ OK ]"
            $cancelText = "[ Cancel ]"
            $buttonSpacing = 15
            $totalWidth = 30
            $startX = $this.X + [Math]::Floor(($this.Width - $totalWidth) / 2)
            
            Write-BufferString -X $startX -Y $buttonY -Text $okText -ForegroundColor ([ConsoleColor]::Green)
            Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor ([ConsoleColor]::Gray)
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::DownArrow) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Spacebar) {
                if ($this.AllowMultiple) {
                    if ($this.SelectedItems.Contains($this.SelectedIndex)) {
                        [void]$this.SelectedItems.Remove($this.SelectedIndex)
                    } else {
                        [void]$this.SelectedItems.Add($this.SelectedIndex)
                    }
                    Request-TuiRefresh
                }
            }
            ([ConsoleKey]::Enter) {
                $this.OnConfirm()
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
            }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSelectAction) {
            if ($this.AllowMultiple) {
                $selectedValues = @($this.SelectedItems | ForEach-Object { $this.Items[$_] })
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selectedValues
                }.GetNewClosure()
            } else {
                $selected = $this.Items[$this.SelectedIndex]
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selected
                }.GetNewClosure()
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ListDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Dialog State Management
$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

# Public API Functions
function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        # Subscribe to dialog events
        Subscribe-Event -EventName "Confirm.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-ConfirmDialog -Title $params.Title -Message $params.Message `
                -OnConfirm $params.OnConfirm -OnCancel $params.OnCancel
        }
        
        Subscribe-Event -EventName "Alert.Show" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-AlertDialog -Title $params.Title -Message $params.Message
        }
        
        Subscribe-Event -EventName "Input.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-InputDialog -Title $params.Title -Prompt $params.Prompt `
                -DefaultValue $params.DefaultValue -OnSubmit $params.OnSubmit -OnCancel $params.OnCancel
        }
        
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

function Show-AlertDialog {
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock {
        $dialog = [AlertDialog]::new($Title, $Message)
        $dialog.Show()
    }
}

function Show-ConfirmDialog {
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock {
        $dialog = [ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)
        $dialog.Show()
    }
}

function Show-InputDialog {
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock {
        $dialog = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel)
        if ($DefaultValue) {
            $dialog.SetDefaultValue($DefaultValue)
        }
        $dialog.Show()
    }
}

function Show-ProgressDialog {
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock {
        $dialog = [ProgressDialog]::new($Title, $Message)
        $dialog.PercentComplete = $PercentComplete
        $dialog.ShowCancel = $ShowCancel
        $dialog.Show()
        return $dialog
    }
}

function Show-ListDialog {
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [string[]]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock {
        $dialog = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel)
        $dialog.AllowMultiple = $AllowMultiple
        $dialog.Show()
    }
}

function Close-TuiDialog {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.CurrentDialog.Close()
        }
    }
}

Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-AlertDialog',
    'Show-ConfirmDialog', 
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Close-TuiDialog'
) -Variable @()



####\modules\dialog-system.psm1
# Dialog System Module
# Uses engine's word wrap helper and respects the framework

$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

#region --- Public API & Factory Functions ---

function Show-TuiDialog {
    <# .SYNOPSIS Internal function to display a dialog component. #>
    param([hashtable]$DialogComponent)
    Invoke-WithErrorHandling -Component "DialogSystem.ShowDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.DialogStack.Push($script:DialogState.CurrentDialog)
        }
        $script:DialogState.CurrentDialog = $DialogComponent
        Request-TuiRefresh
    } -Context "Showing dialog: $($DialogComponent.Title)"
}

function Close-TuiDialog {
    <# .SYNOPSIS Closes the current dialog and restores the previous one, if any. #>
    Invoke-WithErrorHandling -Component "DialogSystem.CloseDialog" -ScriptBlock {
        $script:DialogState.CurrentDialog = ($script:DialogState.DialogStack.Count -gt 0) ? $script:DialogState.DialogStack.Pop() : $null
        Request-TuiRefresh
    } -Context "Closing current dialog"
}

function Show-ConfirmDialog {
    <# .SYNOPSIS Displays a standard Yes/No confirmation dialog. #>
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowConfirmDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("Yes", "No")
            Width         = [Math]::Min(80, [Math]::Max(50, $Message.Length + 10))
            Height        = 10
            OnButtonClick = {
                param($Button, $Index)
                Invoke-WithErrorHandling -Component "ConfirmDialog.OnButtonClick" -ScriptBlock {
                    Close-TuiDialog
                    if ($Index -eq 0) { & $OnConfirm } else { & $OnCancel }
                }
            }
            OnCancel      = { Invoke-WithErrorHandling -Component "ConfirmDialog.OnCancel" -ScriptBlock { Close-TuiDialog; & $OnCancel } }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context "Creating confirm dialog: $Title"
}

function Show-AlertDialog {
    <# .SYNOPSIS Displays a simple alert with an OK button. #>
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowAlertDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("OK")
            Width         = [Math]::Min(80, [Math]::Max(40, $Message.Length + 10))
            Height        = 10
            OnButtonClick = { Invoke-WithErrorHandling -Component "AlertDialog.OnButtonClick" -ScriptBlock { Close-TuiDialog } }
            OnCancel      = { Invoke-WithErrorHandling -Component "AlertDialog.OnCancel" -ScriptBlock { Close-TuiDialog } }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context "Creating alert dialog: $Title"
}

function Show-InputDialog {
    <# .SYNOPSIS Displays a dialog to get text input from the user. #>
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowInputDialog" -ScriptBlock {
        $inputScreen = @{
            Name = "InputDialog"
            State = @{ InputValue = $DefaultValue; FocusedIndex = 0 }
            _focusedIndex = 0
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Name).Render" -ScriptBlock {
                    $dialogWidth = [Math]::Min(70, [Math]::Max(50, $Prompt.Length + 10))
                    $dialogHeight = 10
                    $dialogX = [Math]::Floor(($global:TuiState.BufferWidth - $dialogWidth) / 2)
                    $dialogY = [Math]::Floor(($global:TuiState.BufferHeight - $dialogHeight) / 2)
                    
                    Write-BufferBox -X $dialogX -Y $dialogY -Width $dialogWidth -Height $dialogHeight -Title " $Title " -BorderColor (Get-ThemeColor "Accent")
                    
                    $promptX = $dialogX + 2; $promptY = $dialogY + 2
                    Write-BufferString -X $promptX -Y $promptY -Text $Prompt
                    
                    $inputY = $promptY + 2; $inputWidth = $dialogWidth - 4
                    $isFocused = ($self._focusedIndex -eq 0)
                    $borderColor = $isFocused ? (Get-ThemeColor "Warning") : (Get-ThemeColor "Primary")
                    
                    Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 -BorderColor $borderColor
                    
                    $displayText = $self.State.InputValue
                    if ($displayText.Length -gt ($inputWidth - 3)) { $displayText = $displayText.Substring(0, $inputWidth - 3) }
                    Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText
                    
                    if ($isFocused) {
                        $cursorPos = [Math]::Min($self.State.InputValue.Length, $inputWidth - 3)
                        Write-BufferString -X ($promptX + 1 + $cursorPos) -Y ($inputY + 1) -Text "_" -ForegroundColor (Get-ThemeColor "Warning")
                    }
                    
                    $buttonY = $dialogY + $dialogHeight - 2; $buttonSpacing = 15; $buttonsWidth = $buttonSpacing * 2
                    $buttonX = $dialogX + [Math]::Floor(($dialogWidth - $buttonsWidth) / 2)
                    
                    $okFocused = ($self._focusedIndex -eq 1)
                    $okText = $okFocused ? "[ OK ]" : "  OK  "
                    $okColor = $okFocused ? (Get-ThemeColor "Warning") : (Get-ThemeColor "Primary")
                    Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
                    
                    $cancelFocused = ($self._focusedIndex -eq 2)
                    $cancelText = $cancelFocused ? "[ Cancel ]" : "  Cancel  "
                    $cancelColor = $cancelFocused ? (Get-ThemeColor "Warning") : (Get-ThemeColor "Primary")
                    Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Name).HandleInput" -ScriptBlock {
                    if ($Key.Key -eq [ConsoleKey]::Tab) {
                        $direction = $Key.Modifiers -band [ConsoleModifiers]::Shift ? -1 : 1
                        $self._focusedIndex = ($self._focusedIndex + $direction + 3) % 3
                        Request-TuiRefresh; return $true
                    }
                    if ($Key.Key -eq [ConsoleKey]::Escape) { Close-TuiDialog; Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock { & $OnCancel }; return $true }
                    
                    switch ($self._focusedIndex) {
                        0 { # TextBox
                            switch ($Key.Key) {
                                ([ConsoleKey]::Enter) { Close-TuiDialog; Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock { & $OnSubmit -Value $self.State.InputValue }; return $true }
                                ([ConsoleKey]::Backspace) { if ($self.State.InputValue.Length -gt 0) { $self.State.InputValue = $self.State.InputValue.Substring(0, $self.State.InputValue.Length - 1); Request-TuiRefresh }; return $true }
                                default { if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) { $self.State.InputValue += $Key.KeyChar; Request-TuiRefresh; return $true } }
                            }
                        }
                        1 { # OK Button
                            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) { Close-TuiDialog; Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock { & $OnSubmit -Value $self.State.InputValue }; return $true }
                        }
                        2 { # Cancel Button
                            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) { Close-TuiDialog; Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock { & $OnCancel }; return $true }
                        }
                    }
                    return $false
                }
            }
        }
        $script:DialogState.CurrentDialog = $inputScreen
        Request-TuiRefresh
    } -Context "Creating input dialog: $Title"
}

#endregion

#region --- Engine Integration & Initialization ---

function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem.Initialize" -ScriptBlock {
        Subscribe-Event -EventName "Confirm.Request" -Handler { param($EventData) Invoke-WithErrorHandling -Component "DialogSystem.ConfirmEventHandler" -ScriptBlock { Show-ConfirmDialog @$EventData.Data } }
        Subscribe-Event -EventName "Alert.Show" -Handler { param($EventData) Invoke-WithErrorHandling -Component "DialogSystem.AlertEventHandler" -ScriptBlock { Show-AlertDialog @$EventData.Data } }
        Subscribe-Event -EventName "Input.Request" -Handler { param($EventData) Invoke-WithErrorHandling -Component "DialogSystem.InputEventHandler" -ScriptBlock { Show-InputDialog @$EventData.Data } }
        Write-Verbose "Dialog System initialized and event handlers registered."
    } -Context "Initializing Dialog System"
}

function Render-Dialogs {
    Invoke-WithErrorHandling -Component "DialogSystem.RenderDialogs" -ScriptBlock {
        if ($script:DialogState.CurrentDialog -and $script:DialogState.CurrentDialog.Render) {
            & $script:DialogState.CurrentDialog.Render -self $script:DialogState.CurrentDialog
        }
    } -Context "Rendering current dialog"
}

function Handle-DialogInput {
    param($Key)
    return Invoke-WithErrorHandling -Component "DialogSystem.HandleDialogInput" -ScriptBlock {
        if ($script:DialogState.CurrentDialog -and $script:DialogState.CurrentDialog.HandleInput) {
            return & $script:DialogState.CurrentDialog.HandleInput -self $script:DialogState.CurrentDialog -Key $Key
        }
        return $false
    } -Context "Handling dialog input"
}

function Update-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem.UpdateDialogSystem" -ScriptBlock {
        # Placeholder for periodic updates
    } -Context "Updating dialog system"
}

function New-TuiDialog {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "Dialog"
        Title = $Props.Title ?? "Dialog"
        Message = $Props.Message ?? ""
        Buttons = $Props.Buttons ?? @("OK")
        SelectedButton = 0
        Width = $Props.Width ?? 50
        Height = $Props.Height ?? 10
        X = 0; Y = 0
        OnButtonClick = $Props.OnButtonClick ?? {}
        OnCancel = $Props.OnCancel ?? {}
        
        Render = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                $self.X = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                $self.Y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -Title $self.Title -BorderColor (Get-ThemeColor "Accent")
                
                $messageY = $self.Y + 2; $messageX = $self.X + 2; $maxWidth = $self.Width - 4
                $wrappedLines = Get-WordWrappedLines -Text $self.Message -MaxWidth $maxWidth
                
                foreach ($line in $wrappedLines) {
                    if ($messageY -ge ($self.Y + $self.Height - 3)) { break }
                    Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor (Get-ThemeColor "Primary")
                    $messageY++
                }
                
                $buttonY = $self.Y + $self.Height - 3
                $totalButtonWidth = ($self.Buttons.Count * 12) + (($self.Buttons.Count - 1) * 2)
                $buttonX = $self.X + [Math]::Floor(($self.Width - $totalButtonWidth) / 2)
                
                for ($i = 0; $i -lt $self.Buttons.Count; $i++) {
                    $button = $self.Buttons[$i]
                    $isSelected = ($i -eq $self.SelectedButton)
                    $buttonText = $isSelected ? "[ $($button) ]" : "  $($button)  "
                    $color = $isSelected ? (Get-ThemeColor "Warning") : (Get-ThemeColor "Primary")
                    Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
                    $buttonX += 14
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) { $self.SelectedButton = [Math]::Max(0, $self.SelectedButton - 1); Request-TuiRefresh; return $true }
                    ([ConsoleKey]::RightArrow) { $self.SelectedButton = [Math]::Min($self.Buttons.Count - 1, $self.SelectedButton + 1); Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Tab) { $self.SelectedButton = ($self.SelectedButton + 1) % $self.Buttons.Count; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Enter) { & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton; return $true }
                    ([ConsoleKey]::Spacebar) { & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton; return $true }
                    ([ConsoleKey]::Escape) { & $self.OnCancel; return $true }
                }
                return $false
            }
        }
    }
}

function Show-ProgressDialog {
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowProgressDialog" -ScriptBlock {
        $dialog = @{
            Type = "ProgressDialog"; Title = $Title; Message = $Message; PercentComplete = $PercentComplete
            Width = 60; Height = 8; ShowCancel = $ShowCancel; IsCancelled = $false
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2); $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Message
                    
                    $barY = $y + 4; $barWidth = $self.Width - 4; $filledWidth = [Math]::Floor($barWidth * ($self.PercentComplete / 100))
                    Write-BufferString -X ($x + 2) -Y $barY -Text ("─" * $barWidth) -ForegroundColor (Get-ThemeColor "Border")
                    if ($filledWidth -gt 0) { Write-BufferString -X ($x + 2) -Y $barY -Text ("█" * $filledWidth) -ForegroundColor (Get-ThemeColor "Success") }
                    
                    $percentText = "$($self.PercentComplete)%"; $percentX = $x + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $percentX -Y $barY -Text $percentText
                    
                    if ($self.ShowCancel) {
                        $buttonY = $y + $self.Height - 2; $buttonText = $self.IsCancelled ? "[ Cancelling... ]" : "[ Cancel ]"
                        $buttonX = $x + [Math]::Floor(($self.Width - $buttonText.Length) / 2)
                        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor (Get-ThemeColor "Warning")
                    }
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    if ($self.ShowCancel -and -not $self.IsCancelled -and $Key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                        $self.IsCancelled = $true; Request-TuiRefresh; return $true
                    }
                    return $false
                }
            }
            
            UpdateProgress = {
                param($self, [int]$PercentComplete, [string]$Message = $null)
                Invoke-WithErrorHandling -Component "$($self.Type).UpdateProgress" -ScriptBlock {
                    $self.PercentComplete = [Math]::Min(100, [Math]::Max(0, $PercentComplete))
                    if ($Message) { $self.Message = $Message }
                    Request-TuiRefresh
                }
            }
        }
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
        return $dialog
    } -Context "Creating progress dialog: $Title"
}

function Show-ListDialog {
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [array]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowListDialog" -ScriptBlock {
        $dialog = @{
            Type = "ListDialog"; Title = $Title; Prompt = $Prompt; Items = $Items; SelectedIndex = 0; SelectedItems = @()
            Width = 60; Height = [Math]::Min(20, $Items.Count + 8); AllowMultiple = $AllowMultiple
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2); $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Prompt
                    
                    $listY = $y + 4; $listHeight = $self.Height - 7; $listWidth = $self.Width - 4
                    $startIndex = [Math]::Max(0, $self.SelectedIndex - [Math]::Floor($listHeight / 2))
                    $endIndex = [Math]::Min($self.Items.Count - 1, $startIndex + $listHeight - 1)
                    
                    for ($i = $startIndex; $i -le $endIndex; $i++) {
                        $itemY = $listY + ($i - $startIndex); $item = $self.Items[$i]
                        $isSelected = ($i -eq $self.SelectedIndex); $isChecked = $self.SelectedItems -contains $i
                        $prefix = $self.AllowMultiple ? ($isChecked ? "[X] " : "[ ] ") : ""
                        $itemText = "$prefix$item"
                        if ($itemText.Length -gt $listWidth - 2) { $itemText = $itemText.Substring(0, $listWidth - 5) + "..." }
                        
                        $bgColor = $isSelected ? (Get-ThemeColor "Selection") : $null
                        $fgColor = $isSelected ? (Get-ThemeColor "Background") : (Get-ThemeColor "Primary")
                        Write-BufferString -X ($x + 2) -Y $itemY -Text $itemText -ForegroundColor $fgColor -BackgroundColor $bgColor
                    }
                    
                    if ($self.Items.Count -gt $listHeight) {
                        $scrollbarX = $x + $self.Width - 2; $scrollbarHeight = $listHeight
                        $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $self.Items.Count))
                        $thumbPos = [Math]::Floor($scrollbarHeight * $self.SelectedIndex / $self.Items.Count)
                        for ($i = 0; $i -lt $scrollbarHeight; $i++) { $char = ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) ? "█" : "│"; Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char -ForegroundColor (Get-ThemeColor "Border") }
                    }
                    
                    if ($self.AllowMultiple) {
                        $buttonY = $y + $self.Height - 2; $okText = "[ OK ]"; $cancelText = "[ Cancel ]"; $buttonSpacing = 15; $totalWidth = 30; $startX = $x + [Math]::Floor(($self.Width - $totalWidth) / 2)
                        Write-BufferString -X $startX -Y $buttonY -Text $okText -ForegroundColor (Get-ThemeColor "Success")
                        Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor (Get-ThemeColor "Primary")
                    }
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) { $self.SelectedIndex = [Math]::Max(0, $self.SelectedIndex - 1); Request-TuiRefresh; return $true }
                        ([ConsoleKey]::DownArrow) { $self.SelectedIndex = [Math]::Min($self.Items.Count - 1, $self.SelectedIndex + 1); Request-TuiRefresh; return $true }
                        ([ConsoleKey]::Spacebar) { if ($self.AllowMultiple) { if ($self.SelectedItems -contains $self.SelectedIndex) { $self.SelectedItems = $self.SelectedItems | Where-Object { $_ -ne $self.SelectedIndex } } else { $self.SelectedItems += $self.SelectedIndex }; Request-TuiRefresh; return $true } }
                        ([ConsoleKey]::Enter) {
                            Close-TuiDialog
                            if ($self.AllowMultiple) { $selectedValues = $self.SelectedItems | ForEach-Object { $self.Items[$_] }; & $OnSelect -Selected $selectedValues } 
                            else { & $OnSelect -Selected $self.Items[$self.SelectedIndex] }
                            return $true
                        }
                        ([ConsoleKey]::Escape) { Close-TuiDialog; & $OnCancel; return $true }
                    }
                    return $false
                }
            }
        }
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
    } -Context "Creating list dialog: $Title"
}

#endregion

Export-ModuleMember -Function 'Initialize-DialogSystem', 'Show-TuiDialog', 'Close-TuiDialog', 'Show-ConfirmDialog', 'Show-AlertDialog', 'Show-InputDialog', 'Show-ProgressDialog', 'Show-ListDialog', 'Render-Dialogs', 'Handle-DialogInput', 'Update-DialogSystem', 'New-TuiDialog'



####\modules\event-system.psm1
# Event System Module
# Provides pub/sub event functionality for decoupled communication

$script:EventHandlers = @{}
$script:EventHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxEventHistory = 100

function Initialize-EventSystem {
    <# .SYNOPSIS Initializes the event system for the application #>
    Invoke-WithErrorHandling -Component "EventSystem.Initialize" -Context "Initializing event system" -ScriptBlock {
        $script:EventHandlers = @{}
        $script:EventHistory = [System.Collections.Generic.List[object]]::new()
        Write-Verbose "Event system initialized"
    }
}

function Publish-Event {
    <#
    .SYNOPSIS Publishes an event to all registered handlers
    .PARAMETER EventName The name of the event to publish
    .PARAMETER Data Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter()] [hashtable]$Data = @{}
    )
    Invoke-WithErrorHandling -Component "EventSystem.PublishEvent" -Context "Publishing event '$EventName'" -ScriptBlock {
        $eventRecord = @{ EventName = $EventName; Data = $Data; Timestamp = Get-Date }
        
        $script:EventHistory.Add($eventRecord)
        if ($script:EventHistory.Count -gt $script:MaxEventHistory) { $script:EventHistory.RemoveAt(0) }
        
        if ($script:EventHandlers.ContainsKey($EventName)) {
            foreach ($handler in $script:EventHandlers[$EventName]) {
                try {
                    $eventData = @{ EventName = $EventName; Data = $Data; Timestamp = $eventRecord.Timestamp }
                    & $handler.ScriptBlock -EventData $eventData
                } catch {
                    Write-Log -Level Warning -Message "Error in event handler for '$EventName' (ID: $($handler.HandlerId)): $_"
                }
            }
        }
        Write-Verbose "Published event: $EventName"
    } -AdditionalData @{ EventName = $EventName; EventData = $Data }
}

function Subscribe-Event {
    <#
    .SYNOPSIS Subscribes to an event with a handler
    .PARAMETER EventName The name of the event to subscribe to
    .PARAMETER Handler The script block to execute
    .PARAMETER HandlerId Optional unique identifier for the handler
    .PARAMETER Source Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter(Mandatory)] [scriptblock]$Handler,
        [Parameter()] [string]$HandlerId = [Guid]::NewGuid().ToString(),
        [Parameter()] [string]$Source
    )
    return Invoke-WithErrorHandling -Component "EventSystem.SubscribeEvent" -Context "Subscribing to event '$EventName'" -ScriptBlock {
        if (-not $script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers[$EventName] = @() }
        
        $handlerInfo = @{ HandlerId = $HandlerId; ScriptBlock = $Handler; SubscribedAt = Get-Date; Source = $Source }
        $script:EventHandlers[$EventName] += $handlerInfo
        
        Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
        return $HandlerId
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId; Source = $Source }
}

function Unsubscribe-Event {
    <#
    .SYNOPSIS Unsubscribes from an event
    .PARAMETER EventName The name of the event (optional if HandlerId is provided)
    .PARAMETER HandlerId The unique identifier of the handler to remove
    #>
    param(
        [Parameter()] [string]$EventName,
        [Parameter(Mandatory)] [string]$HandlerId
    )
    Invoke-WithErrorHandling -Component "EventSystem.UnsubscribeEvent" -Context "Unsubscribing from event '$EventName' (Handler: $HandlerId)" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($script:EventHandlers[$EventName].Count -eq 0) { $script:EventHandlers.Remove($EventName) }
                Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
            }
        } else {
            $found = $false
            foreach ($eventKey in @($script:EventHandlers.Keys)) {
                $handlers = $script:EventHandlers[$eventKey]
                $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($newHandlers.Count -lt $handlers.Count) {
                    $found = $true
                    $script:EventHandlers[$eventKey] = if ($newHandlers.Count -eq 0) { $script:EventHandlers.Remove($eventKey) } else { $newHandlers }
                    Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"; break
                }
            }
            if (-not $found) { Write-Warning "Handler ID not found: $HandlerId" }
        }
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId }
}

function Get-EventHandlers {
    <# .SYNOPSIS Gets all registered event handlers #>
    param([Parameter()] [string]$EventName)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHandlers" -Context "Getting event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { return $script:EventHandlers[$EventName] ?? @() }
        else { return $script:EventHandlers }
    }
}

function Clear-EventHandlers {
    <# .SYNOPSIS Clears all event handlers for a specific event or all events #>
    param([Parameter()] [string]$EventName)
    Invoke-WithErrorHandling -Component "EventSystem.ClearEventHandlers" -Context "Clearing event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { if ($script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers.Remove($EventName); Write-Verbose "Cleared handlers for event: $EventName" } } 
        else { $script:EventHandlers = @{}; Write-Verbose "Cleared all event handlers" }
    }
}

function Get-EventHistory {
    <# .SYNOPSIS Gets the event history #>
    param([Parameter()] [string]$EventName, [Parameter()] [int]$Last = 0)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHistory" -Context "Getting event history for '$EventName'" -ScriptBlock {
        $history = $script:EventHistory
        if ($EventName) { $history = $history | Where-Object { $_.EventName -eq $EventName } }
        if ($Last -gt 0) { $history = $history | Select-Object -Last $Last }
        return $history
    }
}

function Remove-ComponentEventHandlers {
    <# .SYNOPSIS Removes all event handlers associated with a specific component #>
    param([Parameter(Mandatory)] [string]$ComponentId)
    Invoke-WithErrorHandling -Component "EventSystem.RemoveComponentEventHandlers" -Context "Removing event handlers for component '$ComponentId'" -ScriptBlock {
        $removedCount = 0
        foreach ($eventName in @($script:EventHandlers.Keys)) {
            $initialCount = $script:EventHandlers[$eventName].Count
            $script:EventHandlers[$eventName] = @($script:EventHandlers[$eventName] | Where-Object { $_.Source -ne $ComponentId })
            $removedCount += $initialCount - $script:EventHandlers[$eventName].Count
            if ($script:EventHandlers[$eventName].Count -eq 0) { $script:EventHandlers.Remove($eventName) }
        }
        Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
    }
}

Export-ModuleMember -Function 'Initialize-EventSystem', 'Publish-Event', 'Subscribe-Event', 'Unsubscribe-Event', 'Get-EventHandlers', 'Clear-EventHandlers', 'Get-EventHistory', 'Remove-ComponentEventHandlers'


####\modules\exceptions.psm1

# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

try {
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException) {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
    }
} catch {
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

function _Identify-HeliosComponent {
    param([System.Management.Automation.ErrorRecord]$ErrorRecord)
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName ?? (Get-PSCallStack | Where-Object ScriptName | Select-Object -First 1).ScriptName
        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        $componentMap = @{
            'tui-engine' = 'TUI Engine'; 'navigation' = 'Navigation Service'; 'keybindings' = 'Keybinding Service'
            'task-service' = 'Task Service'; 'helios-components' = 'Helios UI Components'; 'helios-panels' = 'Helios UI Panels'
            'dashboard-screen' = 'Dashboard Screen'; 'task-screen' = 'Task Screen'; 'exceptions' = 'Exception Module'
            'logger' = 'Logger Module'; 'Start-PMCTerminal' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") { return $componentMap[$pattern] }
        }
        return "Unknown ($fileName)"
    } catch { return "Component Identification Failed" }
}

function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp = Get-Date -Format "o"; Summary = $ErrorRecord.Exception.Message; Type = $ErrorRecord.Exception.GetType().FullName
            Category = $ErrorRecord.CategoryInfo.Category.ToString(); TargetObject = $ErrorRecord.TargetObject
            ScriptName = $ErrorRecord.InvocationInfo.ScriptName; LineNumber = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line = $ErrorRecord.InvocationInfo.Line; PositionMessage = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace = $ErrorRecord.Exception.StackTrace; InnerExceptions = @(); AdditionalContext = $AdditionalContext
            SystemContext = @{
                ProcessId = $PID; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{ Message = $innerEx.Message; Type = $innerEx.GetType().FullName; StackTrace = $innerEx.StackTrace }
            $innerEx = $innerEx.InnerException
        }
        return $errorInfo
    } catch {
        return [PSCustomObject]@{ Timestamp = Get-Date -Format "o"; Summary = "CRITICAL: Error analysis failed."; OriginalError = $ErrorRecord.Exception.Message; AnalysisError = $_.Exception.Message; Type = "ErrorAnalysisFailure" }
    }
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$Component,
        [Parameter(Mandatory)] [string]$Context,
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [hashtable]$AdditionalData = @{}
    )

    if (-not $ScriptBlock) { throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null." }
    $Component = [string]::IsNullOrWhiteSpace($Component) ? "Unknown Component" : $Component
    $Context = [string]::IsNullOrWhiteSpace($Context) ? "Unknown Operation" : $Context

    try {
        return (& $ScriptBlock)
    }
    catch {
        $originalErrorRecord = $_
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = ($Component -ne "Unknown Component") ? $Component : $identifiedComponent

        $errorContext = @{ Operation = $Context }
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)" -Data $detailedError
        }

        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) { $script:ErrorHistory.RemoveAt(0) }

        $contextHashtable = @{
            Operation = $Context; Timestamp = $detailedError.Timestamp; LineNumber = $detailedError.LineNumber
            ScriptName = $detailedError.ScriptName ?? "Unknown"
        }
        
        foreach ($key in $AdditionalData.Keys) {
            $value = $AdditionalData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) { $contextHashtable[$key] = $value }
        }
        
        $heliosException = New-Object Helios.HeliosException($originalErrorRecord.Exception.Message, $finalComponent, $contextHashtable, $originalErrorRecord.Exception)
        throw $heliosException
    }
}

function Get-ErrorHistory {
    [CmdletBinding()]
    param([int]$Count = 25)
    
    $total = $script:ErrorHistory.Count
    if ($Count -ge $total) { return $script:ErrorHistory }
    $start = $total - $Count
    return $script:ErrorHistory.GetRange($start, $Count)
}

Export-ModuleMember -Function 'Invoke-WithErrorHandling', 'Get-ErrorHistory'


####\modules\logger.psm1

# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------
$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------
function ConvertTo-SerializableObject {
    param([object]$Object)
    if ($null -eq $Object) { return $null }
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'
    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)
        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) { [void]$visited.Add($InputObject) }
        switch ($InputObject.GetType().Name) {
            'Hashtable' { $r = @{}; foreach ($k in $InputObject.Keys) { try { $r[$k] = Convert-Internal $InputObject[$k] ($Depth+1) } catch { $r[$k] = "<Err>" } }; return $r }
            'PSCustomObject' { $r = @{}; foreach ($p in $InputObject.PSObject.Properties) { try { if ($p.MemberType -ne 'ScriptMethod') { $r[$p.Name] = Convert-Internal $p.Value ($Depth+1) } } catch { $r[$p.Name] = "<Err>" } }; return $r }
            'Object[]' { $r = @(); for ($i=0; $i -lt [Math]::Min($InputObject.Count,10); $i++) { try { $r += Convert-Internal $InputObject[$i] ($Depth+1) } catch { $r += "<Err>" } }; if($InputObject.Count -gt 10) { $r += "<...>" }; return $r }
            default { try { if ($InputObject -is [ValueType] -or $InputObject -is [string] -or $InputObject -is [datetime]) { return $InputObject } else { return $InputObject.ToString() } } catch { return "<Err>" } }
        }
    }
    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------
function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Debug"
    )
    if ([string]::IsNullOrWhiteSpace($LogDirectory) -or [string]::IsNullOrWhiteSpace($LogFileName)) { Write-Warning "Invalid logger parameters."; return }
    try {
        if (-not (Test-Path $LogDirectory)) { New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null }
        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true
        Write-Log -Level Info -Message "Logger initialized" -Data @{ LogPath = $script:LogPath; PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS; PID = $PID } -Force
    } catch { Write-Warning "Failed to initialize logger: $_"; $script:LogInitialized = $false }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")] [string]$Level = "Info",
        [Parameter(Mandatory)] [string]$Message,
        [object]$Data,
        [switch]$Force
    )
    if (-not $script:LogInitialized -and -not $Force) { return }
    $levelPriority = @{ Debug=0; Trace=0; Verbose=1; Info=2; Warning=3; Error=4; Fatal=5 }
    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }
    try {
        $caller = (Get-PSCallStack)[1]
        $logContext = @{
            Timestamp = (Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"); Level = $Level; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
            CallDepth = $script:CallDepth; Message = $Message; Caller = @{ Command = $caller.Command; Location = $caller.Location; ScriptName = $caller.ScriptName; LineNumber = $caller.ScriptLineNumber }
        }
        if ($PSBoundParameters.ContainsKey('Data')) { $logContext.UserData = if ($Data -is [Exception]) { @{ Type="Exception"; Message=$Data.Message; StackTrace=$Data.StackTrace; InnerException=$Data.InnerException.Message } } else { ConvertTo-SerializableObject -Object $Data } }
        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) { "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)" } else { $caller.Command }
        $logEntry = "$($logContext.Timestamp) [$($Level.PadRight(7))] $indent [$callerInfo] $Message"
        if ($PSBoundParameters.ContainsKey('Data')) { $logEntry += if ($Data -is [Exception]) { "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)" } else { try { "`n${indent}  Data: $(ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue)" } catch { "`n${indent}  Data: $($Data.ToString())" } } }
        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) { $script:LogQueue.RemoveRange(0, 1000) }
        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) { Move-Item $script:LogPath ($script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log") -Force }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch { Write-Host "LOG WRITE FAILED: $logEntry`nError: $_" -ForegroundColor Yellow }
        }
        if ($Level -in @('Error', 'Fatal', 'Warning')) { Write-Host $logEntry -ForegroundColor ($Level -in @('Error', 'Fatal') ? 'Red' : 'Yellow') }
    } catch { try { $errorEntry = "$(Get-Date -Format 'o') [LOGGER ERROR] Failed to log: $_"; if ($script:LogPath) { Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8 }; Write-Host $errorEntry -ForegroundColor Red } catch { Write-Host "CRITICAL: Logger failed: $_" -ForegroundColor Red } }
}

function Trace-FunctionEntry { [CmdletBinding()] param([string]$FunctionName, [object]$Parameters); if (-not $script:TraceAllCalls) { return }; $script:CallDepth++; Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{ Parameters=$Parameters; Action="FunctionEntry" } }
function Trace-FunctionExit { [CmdletBinding()] param([string]$FunctionName, [object]$ReturnValue, [switch]$WithError); if (-not $script:TraceAllCalls) { return }; Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{ ReturnValue=$ReturnValue; Action=($WithError ? "FunctionExitWithError" : "FunctionExit"); HasError=$WithError.IsPresent }; $script:CallDepth = [Math]::Max(0, $script:CallDepth - 1) }
function Trace-Step { [CmdletBinding()] param([string]$StepName, [object]$StepData, [string]$Module); $caller = (Get-PSCallStack)[1]; $moduleInfo = $Module ?? ($caller.ScriptName ? [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) : "Unknown"); Write-Log -Level Debug -Message "STEP: $StepName" -Data @{ StepData=$StepData; Module=$moduleInfo; Action="Step" } }
function Trace-StateChange { [CmdletBinding()] param([string]$StateType, [object]$OldValue, [object]$NewValue, [string]$PropertyPath); Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{ StateType=$StateType; PropertyPath=$PropertyPath; OldValue=$OldValue; NewValue=$NewValue; Action="StateChange" } }
function Trace-ComponentLifecycle { [CmdletBinding()] param([string]$ComponentType, [string]$ComponentId, [ValidateSet('Create','Initialize','Render','Update','Destroy')] [string]$Phase, [object]$ComponentData); Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{ ComponentType=$ComponentType; ComponentId=$ComponentId; Phase=$Phase; ComponentData=$ComponentData; Action="ComponentLifecycle" } }
function Trace-ServiceCall { [CmdletBinding()] param([string]$ServiceName, [string]$MethodName, [object]$Parameters, [object]$Result, [switch]$IsError); Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{ ServiceName=$ServiceName; MethodName=$MethodName; Parameters=$Parameters; Result=$Result; Action=($IsError ? "ServiceCallError" : "ServiceCall"); IsError=$IsError.IsPresent } }

function Get-LogEntries {
    [CmdletBinding()]
    param([int]$Count = 100, [string]$Level, [string]$Module, [string]$Action)
    try {
        $entries = $script:LogQueue.ToArray()
        if ($Level) { $entries = $entries | Where-Object { $_.Level -eq $Level } }
        if ($Module) { $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") } }
        if ($Action) { $entries = $entries | Where-Object { $_.UserData.Action -eq $Action } }
        return $entries | Select-Object -Last $Count
    } catch { Write-Warning "Error getting log entries: $_"; return @() }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)
    try {
        $callStack = Get-PSCallStack; $trace = @()
        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { $call = $callStack[$i]; $trace += @{ Level=$i-1; Command=$call.Command; Location=$call.Location; ScriptName=$call.ScriptName; LineNumber=$call.ScriptLineNumber } }
        return $trace
    } catch { Write-Warning "Error getting call trace: $_"; return @() }
}

function Clear-LogQueue { try { $script:LogQueue.Clear(); Write-Log -Level Info -Message "In-memory log queue cleared" } catch { Write-Warning "Error clearing log queue: $_" } }
function Set-LogLevel { [CmdletBinding()] param([Parameter(Mandatory)] [ValidateSet("Debug","Verbose","Info","Warning","Error","Fatal","Trace")] [string]$Level); try { $oldLevel = $script:LogLevel; $script:LogLevel = $Level; Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force } catch { Write-Warning "Error setting log level to '$Level': $_" } }
function Enable-CallTracing { $script:TraceAllCalls = $true; Write-Log -Level Info -Message "Call tracing enabled" -Force }
function Disable-CallTracing { $script:TraceAllCalls = $false; Write-Log -Level Info -Message "Call tracing disabled" -Force }
function Get-LogPath { return $script:LogPath }

function Get-LogStatistics {
    [CmdletBinding()]
    param()
    try {
        $stats = [PSCustomObject]@{ TotalEntries=$script:LogQueue.Count; LogPath=$script:LogPath; LogLevel=$script:LogLevel; CallTracingEnabled=$script:TraceAllCalls; LogFileSize=($script:LogPath -and (Test-Path $script:LogPath) ? (Get-Item $script:LogPath).Length : 0); EntriesByLevel=@{}; EntriesByModule=@{}; EntriesByAction=@{} }
        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level; if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level]=0 }; $stats.EntriesByLevel[$level]++
            if ($entry.Caller.ScriptName) { $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName); if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module]=0 }; $stats.EntriesByModule[$module]++ }
            if ($entry.UserData.Action) { $action = $entry.UserData.Action; if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action]=0 }; $stats.EntriesByAction[$action]++ }
        }
        return $stats
    } catch { Write-Warning "Error getting log statistics: $_"; return [PSCustomObject]@{} }
}

Export-ModuleMember -Function 'Initialize-Logger', 'Write-Log', 'Trace-FunctionEntry', 'Trace-FunctionExit', 'Trace-Step', 'Trace-StateChange', 'Trace-ComponentLifecycle', 'Trace-ServiceCall', 'Get-LogEntries', 'Get-CallTrace', 'Clear-LogQueue', 'Set-LogLevel', 'Enable-CallTracing', 'Disable-CallTracing', 'Get-LogPath', 'Get-LogStatistics'



####\modules\models.psm1
# ==============================================================================
# PMC Terminal v5 - Core Data Models
# Defines all core business entity classes with built-in validation.
# ==============================================================================

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Enums

enum TaskStatus { Pending; InProgress; Completed; Cancelled }
enum TaskPriority { Low; Medium; High }
enum BillingType { Billable; NonBillable }

#endregion

#region Base Validation Class
class ValidationBase {
    static [void] ValidateNotEmpty([string]$value, [string]$parameterName) {
        if ([string]::IsNullOrWhiteSpace($value)) {
            throw [System.ArgumentException]::new("Parameter '$($parameterName)' cannot be null or empty.")
        }
    }
}
#endregion

#region Core Model Classes

class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()
    [string]$Title
    [string]$Description
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [string]$ProjectKey = "General"
    [string]$Category
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now
    [Nullable[datetime]]$DueDate
    [string[]]$Tags = @()
    [int]$Progress = 0
    [bool]$Completed = $false

    PmcTask() {}
    PmcTask([string]$title) { [ValidationBase]::ValidateNotEmpty($title, "Title"); $this.Title = $title }
    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title; $this.Description = $description; $this.Priority = $priority
        $this.ProjectKey = $projectKey; $this.Category = $projectKey
    }

    [void] Complete() {
        $this.Status = [TaskStatus]::Completed; $this.Completed = $true
        $this.Progress = 100; $this.UpdatedAt = [datetime]::Now
    }

    [void] UpdateProgress([int]$newProgress) {
        if ($newProgress -lt 0 -or $newProgress -gt 100) { throw "Progress must be between 0 and 100." }
        $this.Progress = $newProgress
        $this.Status = $newProgress -eq 100 ? [TaskStatus]::Completed : $newProgress -gt 0 ? [TaskStatus]::InProgress : [TaskStatus]::Pending
        $this.Completed = ($this.Status -eq [TaskStatus]::Completed)
        $this.UpdatedAt = [datetime]::Now
    }
    
    [string] GetDueDateString() { return $this.DueDate ? $this.DueDate.Value.ToString("yyyy-MM-dd") : "N/A" }

    [hashtable] ToLegacyFormat() {
        return @{
            id = $this.Id; title = $this.Title; description = $this.Description
            completed = $this.Completed; priority = $this.Priority.ToString().ToLower()
            project = $this.ProjectKey; due_date = $this.DueDate ? $this.GetDueDateString() : $null
            created_at = $this.CreatedAt.ToString("o"); updated_at = $this.UpdatedAt.ToString("o")
        }
    }

    static [PmcTask] FromLegacyFormat([hashtable]$legacyData) {
        $task = [PmcTask]::new()
        $task.Id = $legacyData.id ?? $task.Id
        $task.Title = $legacyData.title
        $task.Description = $legacyData.description
        if ($legacyData.priority) { try { $task.Priority = [TaskPriority]::$($legacyData.priority) } catch {} }
        $task.ProjectKey = $legacyData.project ?? $legacyData.Category ?? "General"
        $task.Category = $task.ProjectKey
        if ($legacyData.created_at) { try { $task.CreatedAt = [datetime]::Parse($legacyData.created_at) } catch {} }
        if ($legacyData.updated_at) { try { $task.UpdatedAt = [datetime]::Parse($legacyData.updated_at) } catch {} }
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") { try { $task.DueDate = [datetime]::Parse($legacyData.due_date) } catch {} }
        if ($legacyData.completed -is [bool] -and $legacyData.completed) { $task.Complete() }
        return $task
    }
}

class PmcProject : ValidationBase {
    [string]$Key = ([Guid]::NewGuid().ToString().Split('-')[0]).ToUpper()
    [string]$Name
    [string]$Client
    [BillingType]$BillingType = [BillingType]::NonBillable
    [double]$Rate = 0.0
    [double]$Budget = 0.0
    [bool]$Active = $true
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now

    PmcProject() {}
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key"); [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key; $this.Name = $name
    }

    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key; Name = $this.Name; Client = $this.Client
            BillingType = $this.BillingType.ToString(); Rate = $this.Rate; Budget = $this.Budget
            Active = $this.Active; CreatedAt = $this.CreatedAt.ToString("o")
        }
    }

    static [PmcProject] FromLegacyFormat([hashtable]$legacyData) {
        $project = [PmcProject]::new()
        $project.Key = $legacyData.Key ?? $project.Key
        $project.Name = $legacyData.Name
        $project.Client = $legacyData.Client
        if ($legacyData.Rate) { $project.Rate = [double]$legacyData.Rate }
        if ($legacyData.Budget) { $project.Budget = [double]$legacyData.Budget }
        if ($legacyData.Active -is [bool]) { $project.Active = $legacyData.Active }
        if ($legacyData.BillingType) { try { $project.BillingType = [BillingType]::$($legacyData.BillingType) } catch {} }
        if ($legacyData.CreatedAt) { try { $project.CreatedAt = [datetime]::Parse($legacyData.CreatedAt) } catch {} }
        $project.UpdatedAt = $project.CreatedAt
        return $project
    }
}

#endregion

# AI: Export everything including enums for PowerShell 7+
Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\modules\theme-manager.psm1
# FILE: modules/theme-manager.psm1
# PURPOSE: Provides theming and color management for the TUI.
#

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{ Name="Modern"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::White; Primary=[ConsoleColor]::White; Secondary=[ConsoleColor]::Gray; Accent=[ConsoleColor]::Cyan; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::Yellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Blue; Header=[ConsoleColor]::Cyan; Border=[ConsoleColor]::DarkGray; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::Cyan; Subtle=[ConsoleColor]::DarkGray; Keyword=[ConsoleColor]::Blue; String=[ConsoleColor]::Green; Number=[ConsoleColor]::Magenta; Comment=[ConsoleColor]::DarkGray } }
    Dark   = @{ Name="Dark"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::Gray; Primary=[ConsoleColor]::Gray; Secondary=[ConsoleColor]::DarkGray; Accent=[ConsoleColor]::DarkCyan; Success=[ConsoleColor]::DarkGreen; Warning=[ConsoleColor]::DarkYellow; Error=[ConsoleColor]::DarkRed; Info=[ConsoleColor]::DarkBlue; Header=[ConsoleColor]::DarkCyan; Border=[ConsoleColor]::DarkGray; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::Cyan; Subtle=[ConsoleColor]::DarkGray; Keyword=[ConsoleColor]::DarkBlue; String=[ConsoleColor]::DarkGreen; Number=[ConsoleColor]::DarkMagenta; Comment=[ConsoleColor]::DarkGray } }
    Light  = @{ Name="Light"; Colors=@{ Background=[ConsoleColor]::White; Foreground=[ConsoleColor]::Black; Primary=[ConsoleColor]::Black; Secondary=[ConsoleColor]::DarkGray; Accent=[ConsoleColor]::Blue; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::DarkYellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Blue; Header=[ConsoleColor]::Blue; Border=[ConsoleColor]::Gray; Selection=[ConsoleColor]::Cyan; Highlight=[ConsoleColor]::Yellow; Subtle=[ConsoleColor]::Gray; Keyword=[ConsoleColor]::Blue; String=[ConsoleColor]::Green; Number=[ConsoleColor]::Magenta; Comment=[ConsoleColor]::Gray } }
    Retro  = @{ Name="Retro"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::Green; Primary=[ConsoleColor]::Green; Secondary=[ConsoleColor]::DarkGreen; Accent=[ConsoleColor]::Yellow; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::Yellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Cyan; Header=[ConsoleColor]::Yellow; Border=[ConsoleColor]::DarkGreen; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::White; Subtle=[ConsoleColor]::DarkGreen; Keyword=[ConsoleColor]::Yellow; String=[ConsoleColor]::Cyan; Number=[ConsoleColor]::White; Comment=[ConsoleColor]::DarkGreen } }
}

function Initialize-ThemeManager {
    Invoke-WithErrorHandling -Component "ThemeManager.Initialize" -Context "Initializing theme service" -ScriptBlock {
        Set-TuiTheme -ThemeName "Modern"
        Write-Log -Level Info -Message "Theme manager initialized."
    }
}

function Set-TuiTheme {
    param([Parameter(Mandatory)] [string]$ThemeName)
    Invoke-WithErrorHandling -Component "ThemeManager.SetTheme" -Context "Setting active TUI theme" -AdditionalData @{ ThemeName = $ThemeName } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $script:CurrentTheme = $script:Themes[$ThemeName]
            if ($Host.UI.RawUI) {
                $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
                $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
            }
            Write-Log -Level Debug -Message "Theme set to: $ThemeName"
            Publish-Event -EventName "Theme.Changed" -Data @{ ThemeName = $ThemeName; Theme = $script:CurrentTheme }
        } else {
            Write-Log -Level Warning -Message "Theme not found: $ThemeName"
        }
    }
}

function Get-ThemeColor {
    param([Parameter(Mandatory)] [string]$ColorName, [ConsoleColor]$Default = [ConsoleColor]::Gray)
    try {
        return $script:CurrentTheme.Colors[$ColorName] ?? $Default
    } catch {
        Write-Log -Level Warning -Message "Error in Get-ThemeColor for '$ColorName'. Returning default. Error: $_"
        return $Default
    }
}

function Get-TuiTheme {
    Invoke-WithErrorHandling -Component "ThemeManager.GetTheme" -Context "Retrieving current theme" -ScriptBlock {
        return $script:CurrentTheme
    }
}

function Get-AvailableThemes {
    Invoke-WithErrorHandling -Component "ThemeManager.GetAvailableThemes" -Context "Retrieving available themes" -ScriptBlock {
        return $script:Themes.Keys | Sort-Object
    }
}

function New-TuiTheme {
    param([Parameter(Mandatory)] [string]$Name, [string]$BaseTheme = "Modern", [hashtable]$Colors = @{})
    Invoke-WithErrorHandling -Component "ThemeManager.NewTheme" -Context "Creating new theme" -AdditionalData @{ ThemeName = $Name } -ScriptBlock {
        $newTheme = @{ Name = $Name; Colors = @{} }
        if ($script:Themes.ContainsKey($BaseTheme)) { $newTheme.Colors = $script:Themes[$BaseTheme].Colors.Clone() }
        foreach ($colorKey in $Colors.Keys) { $newTheme.Colors[$colorKey] = $Colors[$colorKey] }
        $script:Themes[$Name] = $newTheme
        Write-Log -Level Info -Message "Created new theme: $Name"
        return $newTheme
    }
}

function Export-TuiTheme {
    param([Parameter(Mandatory)] [string]$ThemeName, [Parameter(Mandatory)] [string]$Path)
    Invoke-WithErrorHandling -Component "ThemeManager.ExportTheme" -Context "Exporting theme to JSON" -AdditionalData @{ ThemeName = $ThemeName; FilePath = $Path } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $theme = $script:Themes[$ThemeName]
            $exportTheme = @{ Name = $theme.Name; Colors = @{} }
            foreach ($colorKey in $theme.Colors.Keys) { $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString() }
            $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
            Write-Log -Level Info -Message "Exported theme '$ThemeName' to: $Path"
        } else {
            Write-Log -Level Warning -Message "Cannot export theme. Theme not found: $ThemeName"
        }
    }
}

function Import-TuiTheme {
    param([Parameter(Mandatory)] [string]$Path)
    Invoke-WithErrorHandling -Component "ThemeManager.ImportTheme" -Context "Importing theme from JSON" -AdditionalData @{ FilePath = $Path } -ScriptBlock {
        if (Test-Path $Path) {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
            $theme = @{ Name = $importedTheme.Name; Colors = @{} }
            foreach ($colorKey in $importedTheme.Colors.Keys) {
                $theme.Colors[$colorKey] = [System.Enum]::Parse([System.ConsoleColor], $importedTheme.Colors[$colorKey], $true)
            }
            $script:Themes[$theme.Name] = $theme
            Write-Log -Level Info -Message "Imported theme: $($theme.Name)"
            return $theme
        } else {
            Write-Log -Level Warning -Message "Cannot import theme. File not found: $Path"
            return $null
        }
    }
}

Export-ModuleMember -Function 'Initialize-ThemeManager', 'Set-TuiTheme', 'Get-ThemeColor', 'Get-TuiTheme', 'Get-AvailableThemes', 'New-TuiTheme', 'Export-TuiTheme', 'Import-TuiTheme'


####\modules\tui-engine.psm1
# TUI Engine v5.1 - NCurses Compositor Edition
# Implements NCurses-style compositor with private buffers and TuiCell rendering

using module .\components\tui-primitives.psm1

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    CompositorBuffer = $null    # AI: NEW - Master compositor buffer (TuiBuffer)
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
    CompositorMode  = $true     # AI: NEW - Enable NCurses-style rendering
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.1 (NCurses Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        # AI: ENHANCED - Create both legacy buffers and new TuiBuffer compositor
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        
        # Initialize legacy buffers for compatibility
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height; CompositorMode = $global:TuiState.CompositorMode }
        Write-Log -Level Info -Message "TUI Engine v5.1 initialized successfully (Compositor Mode: $($global:TuiState.CompositorMode))"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent) {
        try { 
            # AI: ENHANCED - Better class detection for UIElement-based components
            if ($focusedComponent -is [UIElement]) {
                # New UIElement-based component
                $focusedComponent.HandleInput($keyInfo)
            }
            elseif ($focusedComponent.PSObject.TypeNames -contains 'UIElement' -or $focusedComponent.GetType().IsSubclassOf([UIElement])) {
                # Class-based component (legacy detection)
                if ($focusedComponent.PSObject.Methods.Name -contains 'HandleInput') {
                    $focusedComponent.HandleInput($keyInfo)
                }
            }
            elseif ($focusedComponent.HandleInput) {
                # Functional component with HandleInput scriptblock
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return }
            }
        } catch { 
            Write-Warning "Component input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for component '$($focusedComponent.Name)': $_"
        }
    }
    
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            # AI: ENHANCED - Support for UIElement-based screens
            if ($currentScreen -is [UIElement]) {
                # New UIElement-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen -is [Screen]) {
                # Legacy class-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen.HandleInput) {
                # Hashtable/functional screen - use scriptblock invocation
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { Stop-TuiEngine }
                }
            }
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([object]$InitialScreen)  # AI: Accept both UIElement and hashtable screens
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

# AI: REWRITTEN - NCurses Compositor Render-Frame
function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        if ($global:TuiState.CompositorMode -and $null -ne $global:TuiState.CompositorBuffer) {
            # AI: NEW - NCurses-style compositor rendering
            Render-FrameCompositor
        } else {
            # AI: LEGACY - Fall back to old rendering for compatibility
            Render-FrameLegacy
        }
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    # AI: NEW - NCurses-style compositor rendering pipeline
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                if ($global:TuiState.CurrentScreen -is [UIElement]) {
                    # New UIElement-based screen - render to its private buffer
                    $global:TuiState.CurrentScreen.Render()
                    
                    # Composite screen buffer onto master compositor
                    $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                    if ($null -ne $screenBuffer) {
                        $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                    }
                } else {
                    # Legacy screen - render directly (will be deprecated)
                    $global:TuiState.CurrentScreen.Render()
                }
            }
        }
        
        # 3. Render dialogs on top
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog -is [UIElement]) {
                    # New UIElement-based dialog
                    $dialog.Render()
                    $dialogBuffer = $dialog.GetBuffer()
                    if ($null -ne $dialogBuffer) {
                        $pos = $dialog.GetAbsolutePosition()
                        $global:TuiState.CompositorBuffer.BlendBuffer($dialogBuffer, $pos.X, $pos.Y)
                    }
                } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                    # Class-based dialog with Render() method
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    # Functional/hashtable dialog with Render scriptblock
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
        # Fall back to legacy rendering
        Render-FrameLegacy
    }
}

function Render-CompositorToConsole {
    # AI: NEW - Convert TuiBuffer to optimized console output
    $outputBuilder = [System.Text.StringBuilder]::new(20000)
    $lastFG = -1
    $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1
    
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $rowChanged = $false
            $rowOutput = [System.Text.StringBuilder]::new()
            
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $newCell = $global:TuiState.CompositorBuffer.GetCell($x, $y)
                $oldLegacyCell = $global:TuiState.FrontBuffer[$y, $x]
                
                # Convert TuiCell to legacy format for comparison
                $newLegacyCell = $newCell.ToLegacyFormat()
                
                # Check if cell changed
                if ($forceFullRender -or 
                    $newLegacyCell.Char -ne $oldLegacyCell.Char -or
                    $newLegacyCell.FG -ne $oldLegacyCell.FG -or
                    $newLegacyCell.BG -ne $oldLegacyCell.BG) {
                    
                    $rowChanged = $true
                    
                    # Update front buffer
                    $global:TuiState.FrontBuffer[$y, $x] = $newLegacyCell
                    
                    # Add color codes if needed
                    if ($newLegacyCell.FG -ne $lastFG -or $newLegacyCell.BG -ne $lastBG) {
                        $fgCode = Get-AnsiColorCode $newLegacyCell.FG
                        $bgCode = Get-AnsiColorCode $newLegacyCell.BG -IsBackground $true
                        [void]$rowOutput.Append("`e[${fgCode};${bgCode}m")
                        $lastFG = $newLegacyCell.FG
                        $lastBG = $newLegacyCell.BG
                    }
                    
                    [void]$rowOutput.Append($newLegacyCell.Char)
                } else {
                    # Cell unchanged - add placeholder for position tracking
                    [void]$rowOutput.Append($null)
                }
            }
            
            # Output the row if it changed
            if ($rowChanged) {
                [void]$outputBuilder.Append("`e[$($y + 1);1H")
                $rowStr = $rowOutput.ToString() -replace [char]0, ''
                [void]$outputBuilder.Append($rowStr)
            }
        }
        
        [void]$outputBuilder.Append("`e[0m")
        
        if ($outputBuilder.Length -gt 10) {  # Only output if there are substantial changes
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Render-FrameLegacy {
    # AI: LEGACY - Original rendering code for compatibility
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component $global:TuiState.CurrentScreen.Name -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
            }
        }
        
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog.GetType().IsSubclassOf([UIElement]) -or $dialog -is [UIElement]) {
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        Render-BufferOptimized
        
    } catch {
        Write-Log -Level Error -Message "Legacy rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    # AI: ENHANCED - Accept both UIElement and legacy screen objects
    param([object]$Screen)
    if (-not $Screen) { return }
    
    $screenName = if ($Screen -is [UIElement]) { $Screen.Name } elseif ($Screen -is [Screen]) { $Screen.Name } else { $Screen.Name }
    Write-Log -Level Debug -Message "Pushing screen: $screenName"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($global:TuiState.CurrentScreen) {
            # Handle exit for current screen
            if ($global:TuiState.CurrentScreen -is [UIElement]) {
                # New UIElement-based screen
                # No explicit OnExit method - handled by framework
            } elseif ($global:TuiState.CurrentScreen -is [Screen]) {
                # Legacy class-based screen
                $global:TuiState.CurrentScreen.OnExit()
            } elseif ($global:TuiState.CurrentScreen.OnExit) {
                # Functional screen
                $global:TuiState.CurrentScreen.OnExit.Invoke()
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # Initialize new screen
        if ($Screen -is [UIElement]) {
            # New UIElement-based screen - ensure it's sized to fit screen
            if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) {  # Default size
                $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            }
            # Trigger initial render
            $Screen.RequestRedraw()
        } elseif ($Screen -is [Screen]) {
            # Legacy class-based screen
            $Screen.OnEnter()
        } elseif ($Screen.Init) { 
            # Functional screen
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $screenName }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$screenName': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $global:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering - Legacy Support
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:TuiState.BufferWidth) { break }
        if ($currentX -ge 0) { $global:TuiState.BackBuffer[$Y, $currentX] = @{ Char = $char; FG = $ForegroundColor; BG = $BackgroundColor } }
        $currentX++
    }
}

function Write-BufferBox {
    param([int]$X, [int]$Y, [int]$Width, [int]$Height, [string]$BorderStyle = "Single", [ConsoleColor]$BorderColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, [string]$Title = "")
    $borders = Get-BorderChars -Style $BorderStyle
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    if ($Title) {
        $titleText = " $Title "; if ($titleText.Length -gt ($Width-2)) { $titleText = " $($Title.Substring(0,[Math]::Max(0,$Width-5)))... " }
        Write-BufferString -X ($X + [Math]::Floor(($Width - $titleText.Length) / 2)) -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function Render-BufferOptimized {
    $outputBuilder = [System.Text.StringBuilder]::new(20000); $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 0
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $backCell = $global:TuiState.BackBuffer[$y, $x]; $frontCell = $global:TuiState.FrontBuffer[$y, $x]
                if (-not $forceFullRender -and $backCell.Char -eq $frontCell.Char -and $backCell.FG -eq $frontCell.FG -and $backCell.BG -eq $frontCell.BG) { continue }
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) { $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null }
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG; $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null; $lastFG = $backCell.FG; $lastBG = $backCell.BG
                }
                $outputBuilder.Append($backCell.Char) | Out-Null
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = $backCell.Char; FG = $backCell.FG; BG = $backCell.BG }
            }
        }
        $outputBuilder.Append("`e[0m") | Out-Null
        if ($outputBuilder.Length -gt 0) { [Console]::Write($outputBuilder.ToString()) }
    } catch { Write-Warning "Render error: $_" }
}
#endregion

#region Component System - Enhanced for UIElement
function Initialize-ComponentSystem { $global:TuiState.Components = @(); $global:TuiState.FocusedComponent = $null }

function Register-Component { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    $global:TuiState.Components += $Component
    
    # Initialize component based on type
    if ($Component -is [UIElement]) {
        # New UIElement-based component - no explicit init needed
        Write-Log -Level Debug -Message "Registered UIElement component: $($Component.Name)"
    } elseif ($Component.Init) { 
        try { & $Component.Init -self $Component } catch { Write-Warning "Component init error: $_" } 
    }
    return $Component 
}

function Set-ComponentFocus { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) { return }
    
    # Blur current component
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    
    # Set new focused component
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    
    # Focus new component
    if ($null -ne $Component) {
        if ($Component -is [UIElement]) {
            $Component.OnFocus()
        } else {
            $Component.OnFocus?.Invoke()
        }
    }
    
    Request-TuiRefresh 
}

function Clear-ComponentFocus { 
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    $global:TuiState.FocusedComponent = $null
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $null }
    Request-TuiRefresh 
}

# AI: ENHANCED - Support UIElement focusable detection
function Get-NextFocusableComponent { 
    param([object]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = @()
    
    function Find-Focusable([object]$Comp) { 
        if ($Comp -is [UIElement]) {
            # New UIElement-based component
            if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
                $focusableComponents += $Comp
            }
            # Check children
            foreach ($child in $Comp.Children) {
                Find-Focusable $child
            }
        } else {
            # Legacy component
            if ($Comp.IsFocusable -eq $true -and $Comp.Visible -ne $false) { 
                $focusableComponents += $Comp 
            }
            if ($Comp.Children) { 
                foreach ($c in $Comp.Children) { Find-Focusable $c } 
            }
        }
    }
    
    # Find focusable components in current screen
    if ($global:TuiState.CurrentScreen -is [UIElement]) {
        Find-Focusable $global:TuiState.CurrentScreen
    } elseif ($global:TuiState.CurrentScreen.Components) { 
        foreach ($c in $global:TuiState.CurrentScreen.Components.Values) { Find-Focusable $c } 
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by tab index and position
    $sorted = $focusableComponents | Sort-Object { 
        if ($_ -is [UIElement]) {
            $_.TabIndex * 10000 + $_.Y * 100 + $_.X
        } else {
            ($_.TabIndex ?? 0) * 10000 + ($_.Y ?? 0) * 100 + ($_.X ?? 0)
        }
    }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Handle-TabNavigation { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

# AI: LEGACY - Helper functions maintained for compatibility
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Move-Focus { param([bool]$Reverse = $false); Handle-TabNavigation -Reverse $Reverse }

function Get-CurrentDialog {
    try {
        if (Get-Module -Name 'dialog-system-class' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system-class') { $script:DialogState.CurrentDialog }
        } elseif (Get-Module -Name 'dialog-system' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system') { $script:DialogState.CurrentDialog }
        }
    } catch {
        Write-Log -Level Warning -Message "Error accessing dialog system: $_"
    }
    return $null
}

function Handle-DialogInput {
    param([System.ConsoleKeyInfo]$Key)
    try {
        $dialog = Get-CurrentDialog
        if ($dialog) {
            if ($dialog -is [UIElement]) {
                # New UIElement-based dialog
                return $dialog.HandleInput($Key)
            } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                # Legacy class-based dialog
                $dialog.HandleInput($Key)
                return $true
            } elseif ($dialog -is [hashtable] -and $dialog.HandleInput) {
                # Functional dialog
                return & $dialog.HandleInput -self $dialog -Key $Key
            }
        }
    } catch {
        Write-Log -Level Warning -Message "Error handling dialog input: $_"
    }
    return $false
}

function Update-DialogSystem {
    # Dialog system handles its own updates if loaded
}

function Stop-AllTuiAsyncJobs {
    Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)"
}
#endregion

#region Layout Management & Utilities
function Initialize-LayoutEngines { $global:TuiState.Layouts = @{} }
function Get-BorderChars { param([string]$Style); $styles = @{ Single=@{TopLeft='┌';TopRight='┐';BottomLeft='└';BottomRight='┘';Horizontal='─';Vertical='│'}; Double=@{TopLeft='╔';TopRight='╗';BottomLeft='╚';BottomRight='╝';Horizontal='═';Vertical='║'}; Rounded=@{TopLeft='╭';TopRight='╮';BottomLeft='╰';BottomRight='╯';Horizontal='─';Vertical='│'} }; return $styles[$Style] ?? $styles.Single }
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Get-WordWrappedLines { param([string]$Text, [int]$MaxWidth); if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }; $lines = @(); $words = $Text -split '\s+'; $sb = [System.Text.StringBuilder]::new(); foreach ($word in $words) { if ($sb.Length -eq 0) { [void]$sb.Append($word) } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) { [void]$sb.Append(' ').Append($word) } else { $lines += $sb.ToString(); [void]$sb.Clear().Append($word) } }; if ($sb.Length -gt 0) { $lines += $sb.ToString() }; return $lines }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }

# AI: NEW - Compositor helper functions
function Get-ThemeColor {
    param([string]$ColorName)
    # Simple theme color mapping - can be enhanced later
    $themeColors = @{
        Background = [ConsoleColor]::Black
        Foreground = [ConsoleColor]::White
        Border = [ConsoleColor]::Gray
        Focus = [ConsoleColor]::Cyan
        Highlight = [ConsoleColor]::Yellow
    }
    return $themeColors[$ColorName] ?? [ConsoleColor]::Black
}
#endregion

Export-ModuleMember -Function 'Initialize-TuiEngine', 'Start-TuiLoop', 'Stop-TuiEngine', 'Push-Screen', 'Pop-Screen', 'Request-TuiRefresh', 'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer', 'Get-BorderChars', 'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 'Get-NextFocusableComponent', 'Handle-TabNavigation', 'Get-WordWrappedLines', 'Get-FocusedComponent', 'Move-Focus', 'Get-CurrentDialog', 'Handle-DialogInput', 'Update-DialogSystem', 'Stop-AllTuiAsyncJobs', 'Get-ThemeColor' -Variable 'TuiState'


####\modules\tui-framework.psm1
# TUI Framework Integration Module
# Contains utility functions for interacting with the TUI engine and components.

$script:TuiAsyncJobs = @()

function Invoke-TuiMethod {
    <# .SYNOPSIS Safely invokes a method on a TUI component. #>
    param(
        [Parameter(Mandatory)] [hashtable]$Component,
        [Parameter(Mandatory)] [string]$MethodName,
        [Parameter()] [hashtable]$Arguments = @{}
    )
    if (-not $Component) { return }
    $method = $Component[$MethodName]
    if (-not ($method -is [scriptblock])) { return }

    $Arguments['self'] = $Component
    Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock { & $method @Arguments }
}

function Initialize-TuiFramework {
    Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {
        if (-not $global:TuiState) { throw "TUI Engine must be initialized before the TUI Framework." }
        Write-Log -Level Info -Message "TUI Framework initialized."
    }
}

function Invoke-TuiAsync {
    <# .SYNOPSIS Executes a script block asynchronously with job management. #>
    param(
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [string]$JobName = "TuiAsyncJob_$(Get-Random)",
        [hashtable]$ArgumentList = @{}
    )
    Invoke-WithErrorHandling -Component "TuiFramework.Async" -Context "Starting async job: $JobName" -ScriptBlock {
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList -Name $JobName
        $script:TuiAsyncJobs += $job
        Write-Log -Level Debug -Message "Started async job: $JobName" -Data @{ JobId = $job.Id }
        return $job
    }
}

function Get-TuiAsyncResults {
    <# .SYNOPSIS Checks for completed async jobs and returns their results. #>
    param([switch]$RemoveCompleted = $true)
    Invoke-WithErrorHandling -Component "TuiFramework.AsyncResults" -Context "Checking async job results" -ScriptBlock {
        $results = @()
        $completedJobs = $script:TuiAsyncJobs | Where-Object { $_.State -in @('Completed', 'Failed', 'Stopped') }
        
        foreach ($job in $completedJobs) {
            $results += @{
                JobId = $job.Id; JobName = $job.Name; State = $job.State
                Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job } else { $null }
                Error = if ($job.State -eq 'Failed') { $job.ChildJobs[0].JobStateInfo.Reason } else { $null }
            }
            Write-Log -Level Debug -Message "Async job completed: $($job.Name)" -Data @{ JobId = $job.Id; State = $job.State }
        }
        
        if ($RemoveCompleted -and $completedJobs.Count -gt 0) {
            foreach ($job in $completedJobs) {
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                $script:TuiAsyncJobs = $script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id }
            }
        }
        return $results
    }
}

function Stop-AllTuiAsyncJobs {
    Invoke-WithErrorHandling -Component "TuiFramework.StopAsync" -Context "Stopping all async jobs" -ScriptBlock {
        foreach ($job in $script:TuiAsyncJobs) {
            try {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                Write-Log -Level Debug -Message "Stopped async job: $($job.Name)"
            } catch {
                Write-Log -Level Warning -Message "Failed to stop job $($job.Name): $_"
            }
        }
        $script:TuiAsyncJobs = @()
        Write-Log -Level Info -Message "All TUI async jobs stopped."
    }
}

function Request-TuiRefresh {
    if ($global:TuiState.RequestRefresh) { & $global:TuiState.RequestRefresh }
    else { Publish-Event -EventName "TUI.RefreshRequested" }
}

function Get-TuiState { return $global:TuiState }

function Test-TuiState {
    param([switch]$ThrowOnError)
    $isValid = $global:TuiState -and $global:TuiState.Running -and $global:TuiState.CurrentScreen
    if (-not $isValid -and $ThrowOnError) { throw "TUI state is not properly initialized. Call Initialize-TuiEngine first." }
    return $isValid
}

Export-ModuleMember -Function 'Invoke-TuiMethod', 'Initialize-TuiFramework', 'Invoke-TuiAsync', 'Get-TuiAsyncResults', 'Stop-AllTuiAsyncJobs', 'Request-TuiRefresh', 'Get-TuiState', 'Test-TuiState'


####\refactor_checkpoints\checkpoint_20250629_204807_pre-phase-a-complete\components\advanced-data-components.psm1
# Advanced Data Components Module for PMC Terminal v5
# Enhanced data display components with sorting, filtering, and pagination

using namespace System.Text
using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Simple Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

class Table : Component {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    
    Table([string]$name) : base($name) {
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        # AI: FIX - Explicit array initialization
        $this.Data = @()
        $this.SelectedIndex = 0
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
    }
    
    [void] SetData([object[]]$data) {
        # AI: FIX - Defensive array initialization
        $this.Data = if ($null -eq $data) { @() } else { @($data) }
        # AI: FIX - Safe array count check
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -ge $dataCount) {
            $this.SelectedIndex = [Math]::Max(0, $dataCount - 1)
        }
    }
    
    [void] SelectNext() {
        # AI: FIX - Safe array count check
        $dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -lt ($dataCount - 1)) {
            $this.SelectedIndex++
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
        }
    }
    
    [object] GetSelectedItem() {
        # AI: FIX - Safe array access with null checking
        if ($null -eq $this.Data) { return $null }
        
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        
        if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {
            return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }
        }
        return $null
    }
    
    hidden [void] _RenderContent() {
        # AI: Render table to buffer using Write-BufferString
        if (-not (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue)) {
            return # Buffer functions not available
        }
        
        # AI: FIX - Get render position from parent panel if available
        $renderX = 0
        $renderY = 0
        $maxWidth = 120  # Default max width
        
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X
            $renderY = $contentArea.Y
            $maxWidth = $contentArea.Width
        }
        
        $currentY = $renderY
        
        # Header
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            $headerLine = ""
            foreach ($col in $this.Columns) {
                $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                $headerLine += $headerText + " "
            }
            # AI: FIX - Trim header to max width
            if ($headerLine.TrimEnd().Length -gt $maxWidth) {
                $headerLine = $headerLine.Substring(0, $maxWidth)
            }
            Write-BufferString -X $renderX -Y $currentY -Text $headerLine.TrimEnd() -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
            $currentY++
            Write-BufferString -X $renderX -Y $currentY -Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $maxWidth)) -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            $currentY++
        }
        
        # AI: FIX - Safe data array handling
        $dataToRender = @()
        if ($null -ne $this.Data) {
            $dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }
        }
        
        # Data rows
        for ($i = 0; $i -lt $dataToRender.Count; $i++) {
            $row = $dataToRender[$i]
            if ($null -eq $row) { continue }
            
            $rowLine = ""
            $isSelected = ($i -eq $this.SelectedIndex)
            
            foreach ($col in $this.Columns) {
                $cellValue = ""
                if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                    $cellValue = $row[$col.Key]?.ToString() ?? ""
                } elseif ($row.PSObject.Properties[$col.Key]) {
                    $cellValue = $row.($col.Key)?.ToString() ?? ""
                }
                
                $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                $rowLine += $cellText + " "
            }
            
            $finalLine = $rowLine.TrimEnd()
            if ($isSelected) {
                $finalLine = "> $finalLine"
            } else {
                $finalLine = "  $finalLine"
            }
            
            $fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
            $bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            # AI: FIX - Ensure line doesn't exceed parent bounds
            if ($finalLine.Length -gt $maxWidth) {
                $finalLine = $finalLine.Substring(0, $maxWidth)
            }
            Write-BufferString -X $renderX -Y $currentY -Text $finalLine -ForegroundColor $fg -BackgroundColor $bg
            $currentY++
        }
        
        if ($dataToRender.Count -eq 0) {
            Write-BufferString -X $renderX -Y $currentY -Text "  No data to display" -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
        }
    }
}

#endregion

#region Advanced Data Table Class

class DataTableComponent : UIElement {
    # ... (class content is unchanged) ...
    [hashtable[]] $Data = @()
    [hashtable[]] $Columns = @()
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 80
    [int] $Height = 20
    [string] $Title = "Data Table"
    [bool] $ShowBorder = $true
    [bool] $IsFocusable = $true
    [int] $SelectedRow = 0
    [int] $ScrollOffset = 0
    [string] $SortColumn
    [string] $SortDirection = "Ascending"
    [string] $FilterText = ""
    [string] $FilterColumn
    [int] $PageSize = 0  # 0 = auto-calculate
    [int] $CurrentPage = 0
    [bool] $ShowHeader = $true
    [bool] $ShowFooter = $true
    [bool] $ShowRowNumbers = $false
    [bool] $AllowSort = $true
    [bool] $AllowFilter = $true
    [bool] $AllowSelection = $true
    [bool] $MultiSelect = $false
    [int[]] $SelectedRows = @()
    [hashtable[]] $FilteredData = @()
    [hashtable[]] $ProcessedData = @()
    [bool] $FilterMode = $false
    hidden [int] $_lastRenderedWidth = 0
    hidden [int] $_lastRenderedHeight = 0
    
    # Event handlers
    [scriptblock] $OnRowSelect
    [scriptblock] $OnSelectionChange
    
    DataTableComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    DataTableComponent([string]$name, [hashtable[]]$data, [hashtable[]]$columns) : base($name) {
        $this.IsFocusable = $true
        $this.Data = $data
        $this.Columns = $columns
        $this.ProcessData()
    }
    
    [void] ProcessData() {
        Invoke-WithErrorHandling -Component "$($this.Name).ProcessData" -Context "Processing table data" -ScriptBlock {
            # Filter data
            if ([string]::IsNullOrWhiteSpace($this.FilterText)) {
                $this.FilteredData = $this.Data
            } else {
                if ($this.FilterColumn) {
                    # Filter specific column
                    $this.FilteredData = @($this.Data | Where-Object {
                        $value = $_."$($this.FilterColumn)"
                        $value -and $value.ToString() -like "*$($this.FilterText)*"
                    })
                } else {
                    # Filter all columns
                    $this.FilteredData = @($this.Data | Where-Object {
                        $row = $_
                        $matched = $false
                        foreach ($col in $this.Columns) {
                            if ($col.Filterable -ne $false) {
                                $value = $row."$($col.Name)"
                                if ($value -and $value.ToString() -like "*$($this.FilterText)*") {
                                    $matched = $true
                                    break
                                }
                            }
                        }
                        $matched
                    })
                }
            }
            
            # Sort data
            if ($this.SortColumn -and $this.AllowSort) {
                $this.ProcessedData = $this.FilteredData | Sort-Object -Property $this.SortColumn -Descending:($this.SortDirection -eq "Descending")
            } else {
                $this.ProcessedData = $this.FilteredData
            }
            
            # Reset selection if needed
            if ($this.SelectedRow -ge $this.ProcessedData.Count) {
                $this.SelectedRow = [Math]::Max(0, $this.ProcessedData.Count - 1)
            }
            
            # Calculate page size if auto
            if ($this.PageSize -eq 0) {
                $headerLines = $this.ShowHeader ? 3 : 0
                $footerLines = $this.ShowFooter ? 2 : 0
                $filterLines = $this.AllowFilter ? 2 : 0
                $borderAdjust = $this.ShowBorder ? 2 : 0
                $calculatedPageSize = $this.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
                $this.PageSize = [Math]::Max(1, $calculatedPageSize)
            }
            
            # Adjust current page
            $totalPages = [Math]::Ceiling($this.ProcessedData.Count / [Math]::Max(1, $this.PageSize))
            if ($this.CurrentPage -ge $totalPages) {
                $this.CurrentPage = [Math]::Max(0, $totalPages - 1)
            }
        }
    }
    
    [hashtable] GetContentBounds() {
        $borderOffset = $this.ShowBorder ? 1 : 0
        return @{
            X = $this.X + $borderOffset
            Y = $this.Y + $borderOffset
            Width = $this.Width - (2 * $borderOffset)
            Height = $this.Height - (2 * $borderOffset)
        }
    }
    
    hidden [void] _RenderContent() {
        # AI: TEMPORARY - Complex table rendering needs to be rewritten for buffer-based system
        # This is a placeholder until proper buffer rendering is implemented
        if (-not (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue)) {
            return # Buffer functions not available
        }
        
        # Simple placeholder rendering
        Write-BufferString -X ($this.X + 1) -Y ($this.Y + 1) -Text "[DataTable: $($this.Title)]" -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
        
        return # TODO: Implement full buffer-based table rendering
        
        # ORIGINAL COMPLEX RENDERING CODE (commented out for now):
        $renderedContent = [StringBuilder]::new()
        
        # Force ProcessData if dimensions changed
        if ($this._lastRenderedWidth -ne $this.Width -or $this._lastRenderedHeight -ne $this.Height) {
            $this.ProcessData()
            $this._lastRenderedWidth = $this.Width
            $this._lastRenderedHeight = $this.Height
        }
        
        # Calculate content area based on border settings
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        $contentHeight = $this.Height

        if ($this.ShowBorder) {
            $borderColor = ($this.IsFocusable -and $this.IsFocused) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
            
            [void]$renderedContent.Append($this.MoveCursor($this.X, $this.Y))
            [void]$renderedContent.Append($this.SetColor($borderColor))
            [void]$renderedContent.Append($this.RenderBorder($this.Title))
            
            # Adjust content area for border
            $contentX = $this.X + 1
            $contentY = $this.Y + 1
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
        }
        
        $currentY = $contentY
        
        # Filter bar
        if ($this.AllowFilter) {
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::White))
            [void]$renderedContent.Append("Filter: ")
            
            $filterDisplayText = $this.FilterText ? $this.FilterText : "Type to filter..."
            $filterColor = $this.FilterText ? [ConsoleColor]::Yellow : [ConsoleColor]::DarkGray
            [void]$renderedContent.Append($this.SetColor($filterColor))
            [void]$renderedContent.Append($filterDisplayText)
            
            $currentY += 2
        }
        
        # Calculate column widths
        $totalDefinedWidth = ($this.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum ?? 0
        $flexColumns = @($this.Columns | Where-Object { -not $_.Width })
        $columnSeparators = $this.Columns.Count -gt 1 ? $this.Columns.Count - 1 : 0
        $rowNumberWidth = $this.ShowRowNumbers ? 5 : 0
        $remainingWidth = $contentWidth - $totalDefinedWidth - $rowNumberWidth - $columnSeparators
        
        $flexWidth = ($flexColumns.Count -gt 0) ? [Math]::Floor($remainingWidth / $flexColumns.Count) : 0
        
        # Assign calculated widths
        foreach ($col in $this.Columns) {
            $col.CalculatedWidth = $col.Width ?? [Math]::Max(5, $flexWidth)
        }
        
        # Header
        if ($this.ShowHeader) {
            $headerX = $contentX
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append("#".PadRight(4))
                $headerX += 5
            }
            
            foreach ($col in $this.Columns) {
                $headerText = $col.Header ?? $col.Name
                $columnWidth = $col.CalculatedWidth
                
                if ($this.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $this.SortColumn) {
                    $sortIndicator = ($this.SortDirection -eq "Ascending") ? "▲" : "▼"
                    $headerText = "$headerText $sortIndicator"
                }
                
                if ($headerText.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $headerText = $headerText.Substring(0, $maxLength) + "..."
                }
                
                $alignedText = switch ($col.Align) {
                    "Right" { $headerText.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $headerText.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $headerText + " " * $rightPad
                    }
                    default { $headerText.PadRight($columnWidth) }
                }
                
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append($alignedText)
                
                $headerX += $columnWidth + 1
            }
            
            $currentY++
            
            [void]$renderedContent.Append($this.MoveCursor($contentX, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append("─" * $contentWidth)
            $currentY++
        }
        
        # Data rows
        $dataToRender = ($this.ProcessedData.Count -eq 0 -and $this.Data.Count -gt 0) ? $this.Data : $this.ProcessedData
        
        $startIdx = $this.CurrentPage * $this.PageSize
        $endIdx = [Math]::Min($startIdx + $this.PageSize - 1, $dataToRender.Count - 1)
        
        for ($i = $startIdx; $i -le $endIdx; $i++) {
            $row = $dataToRender[$i]
            $rowX = $contentX
            
            $isSelected = $this.MultiSelect ? ($this.SelectedRows -contains $i) : ($i -eq $this.SelectedRow)
            
            $rowBg = $isSelected ? [ConsoleColor]::Cyan : [ConsoleColor]::Black
            $rowFg = $isSelected ? [ConsoleColor]::Black : [ConsoleColor]::White
            
            if ($isSelected) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(" " * $contentWidth)
            }
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(($i + 1).ToString().PadRight(4))
                $rowX += 5
            }
            
            foreach ($col in $this.Columns) {
                $value = $row."$($col.Name)"
                $columnWidth = $col.CalculatedWidth
                
                $displayValue = if ($col.Format -and $value) { & $col.Format $value } else { "$($value)" }
                
                if ($displayValue.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $displayValue = ($maxLength -le 0) ? "..." : ($displayValue.Substring(0, $maxLength) + "...")
                }
                
                $alignedValue = switch ($col.Align) {
                    "Right" { $displayValue.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $displayValue.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $displayValue + " " * $rightPad
                    }
                    default { $displayValue.PadRight($columnWidth) }
                }
                
                $cellFg = if ($col.Color -and -not $isSelected) {
                    Get-ThemeColor (& $col.Color $value $row)
                } else {
                    $rowFg
                }
                
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor($cellFg))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append($alignedValue)
                
                $rowX += $columnWidth + 1
            }
            
            $currentY++
        }
        
        # Empty state
        if ($dataToRender.Count -eq 0) {
            $emptyMessage = $this.FilterText ? "No results match the filter" : "No data to display"
            $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
            $msgY = $contentY + [Math]::Floor($contentHeight / 2)
            [void]$renderedContent.Append($this.MoveCursor($msgX, $msgY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($emptyMessage)
        }
        
        # Footer
        if ($this.ShowFooter) {
            $footerY = $contentY + $contentHeight - 1
            
            $statusText = "$($dataToRender.Count) rows"
            if ($this.FilterText) { $statusText += " (filtered from $($this.Data.Count))" }
            if ($this.MultiSelect) { $statusText += " | $($this.SelectedRows.Count) selected" }
            
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $footerY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($statusText)
            
            if ($dataToRender.Count -gt $this.PageSize) {
                $totalPages = [Math]::Ceiling($dataToRender.Count / [Math]::Max(1, $this.PageSize))
                $pageText = "Page $($this.CurrentPage + 1)/$totalPages"
                [void]$renderedContent.Append($this.MoveCursor($contentX + $contentWidth - $pageText.Length - 1, $footerY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Blue))
                [void]$renderedContent.Append($pageText)
            }
        }
        
        # [void]$renderedContent.Append($this.ResetColor())
        # return $renderedContent.ToString()
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # Filter mode
        if ($key.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($key.Key) {
                ([ConsoleKey]::F) {
                    $this.FilterMode = -not $this.FilterMode
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::S) {
                    if ($this.AllowSort) {
                        $sortableCols = @($this.Columns | Where-Object { $_.Sortable -ne $false })
                        if ($sortableCols.Count -gt 0) {
                            $currentIdx = [array]::IndexOf($sortableCols.Name, $this.SortColumn)
                            $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                            $this.SortColumn = $sortableCols[$nextIdx].Name
                            $this.ProcessData()
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
            }
        }
        
        # Filter text input
        if ($this.FilterMode) {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.FilterMode = $false
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $this.FilterMode = $false
                    $this.ProcessData()
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.FilterText.Length -gt 0) {
                        $this.FilterText = $this.FilterText.Substring(0, $this.FilterText.Length - 1)
                        $this.ProcessData()
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                        $this.FilterText += $key.KeyChar
                        $this.ProcessData()
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            return $false
        }
        
        # Normal navigation
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedRow -gt 0) {
                    $this.SelectedRow--
                    if ($this.SelectedRow -lt ($this.CurrentPage * $this.PageSize)) {
                        $this.CurrentPage--
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedRow -lt ($this.ProcessedData.Count - 1)) {
                    $this.SelectedRow++
                    if ($this.SelectedRow -ge (($this.CurrentPage + 1) * $this.PageSize)) {
                        $this.CurrentPage++
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                if ($this.OnRowSelect -and $this.ProcessedData.Count -gt 0) {
                    $selectedData = $this.MultiSelect ? @($this.SelectedRows | ForEach-Object { $this.ProcessedData[$_] }) : $this.ProcessedData[$this.SelectedRow]
                    & $this.OnRowSelect $selectedData $this.SelectedRow
                }
                return $true
            }
        }
        
        return $false
    }
    
    # AI: Helper methods removed - using buffer-based rendering instead of ANSI
    
    # Public methods
    [void] RefreshData() {
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetData([hashtable[]]$data) {
        $this.Data = $data
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this.ProcessData()
        Request-TuiRefresh
    }
}
#endregion

#region Factory Functions for Backward Compatibility

function New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DataTable_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $data = $Props.Data ?? @()
    $columns = $Props.Columns ?? @()
    
    $table = [DataTableComponent]::new($name, $data, $columns)
    
    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.Title = $Props.Title ?? $table.Title
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader
    $table.ShowFooter = $Props.ShowFooter ?? $table.ShowFooter
    $table.ShowRowNumbers = $Props.ShowRowNumbers ?? $table.ShowRowNumbers
    $table.AllowSort = $Props.AllowSort ?? $table.AllowSort
    $table.AllowFilter = $Props.AllowFilter ?? $table.AllowFilter
    $table.AllowSelection = $Props.AllowSelection ?? $table.AllowSelection
    $table.MultiSelect = $Props.MultiSelect ?? $table.MultiSelect
    $table.Visible = $Props.Visible ?? $table.Visible
    $table.OnRowSelect = $Props.OnRowSelect ?? $table.OnRowSelect
    $table.OnSelectionChange = $Props.OnSelectionChange ?? $table.OnSelectionChange
    
    return $table
}
#endregion

Export-ModuleMember -Function 'New-TuiDataTable'



####\refactor_checkpoints\checkpoint_20250629_204807_pre-phase-a-complete\components\advanced-input-components.psm1
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Value = $Props.Value ?? (Get-Date)
        Mode = $Props.Mode ?? "Date" # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = $Props.Value ?? (Get-Date)
        ViewDate = $Props.Value ?? (Get-Date)
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSelect = $Props.OnSelect
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                # Main container
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Calendar "
                
                # Header with navigation
                $headerY = $self.Y + 1
                $monthYear = $self.ViewDate.ToString("MMMM yyyy")
                $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
                
                Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
                Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
                Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
                
                # Day headers
                $dayHeaderY = $headerY + 2
                $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
                $dayWidth = 4
                $startX = $self.X + 2
                
                for ($i = 0; $i -lt $days.Count; $i++) {
                    Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                        -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
                }
                
                # Calendar grid
                $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
                $startDayOfWeek = [int]$firstDay.DayOfWeek
                $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
                
                $currentDay = 1
                $calendarY = $dayHeaderY + 1
                
                for ($week = 0; $week -lt 6; $week++) {
                    if ($currentDay -gt $daysInMonth) { break }
                    
                    for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                        $x = $startX + ($dayOfWeek * $dayWidth)
                        
                        if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                        
                        if ($currentDay -le $daysInMonth) {
                            $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                         $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                         $self.ViewDate.Year -eq $self.SelectedDate.Year)
                            
                            $isToday = ($currentDay -eq (Get-Date).Day -and 
                                      $self.ViewDate.Month -eq (Get-Date).Month -and 
                                      $self.ViewDate.Year -eq (Get-Date).Year)
                            
                            $fg = if ($isSelected) { Get-ThemeColor "Background" } elseif ($isToday) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                            $bg = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                            
                            $dayText = $currentDay.ToString().PadLeft(2)
                            Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText -ForegroundColor $fg -BackgroundColor $bg
                            
                            $currentDay++
                        }
                    }
                }
                
                # Time picker if in DateTime mode
                if ($self.Mode -eq "DateTime") {
                    $timeY = $self.Y + $self.Height - 2
                    $timeStr = $self.SelectedDate.ToString("HH:mm")
                    Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "CalendarPicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $date = $self.SelectedDate
                $viewDate = $self.ViewDate
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $self.ViewDate = $viewDate.AddMonths(-1) } # Previous month
                        else { $date = $date.AddDays(-1); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } } # Previous day
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $self.ViewDate = $viewDate.AddMonths(1) } # Next month
                        else { $date = $date.AddDays(1); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } } # Next day
                    }
                    ([ConsoleKey]::UpArrow) { $date = $date.AddDays(-7); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(7); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } }
                    ([ConsoleKey]::PageUp) {
                        $self.ViewDate = $viewDate.AddMonths(-1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::PageDown) {
                        $self.ViewDate = $viewDate.AddMonths(1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::Home) { $date = Get-Date; $self.ViewDate = $date }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSelect) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSelect" -ScriptBlock { & $self.OnSelect -Date $date } -AdditionalData @{ Component = $self.Name; SelectedDate = $date }
                        }
                    }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.SelectedDate = $date
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $date } -AdditionalData @{ Component = $self.Name; NewValue = $date }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "CalendarPicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 3
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Type to search..."
        MaxDisplayItems = $Props.MaxDisplayItems ?? 5
        AllowCustomValue = $Props.AllowCustomValue ?? $false
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                # Main dropdown box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                # Display text
                $displayText = ""
                if ($self.IsOpen) {
                    $displayText = $self.SearchText
                    if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                        $displayText = $self.Placeholder
                    }
                } else {
                    if ($self.Value) {
                        $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                        $displayText = $selected ? $selected.Display : $self.Value.ToString()
                    } else {
                        $displayText = "Select..."
                    }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                # Dropdown indicator
                $indicator = $self.IsOpen ? "▲" : "▼"
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator -ForegroundColor $borderColor
                
                # Cursor for search mode
                if ($self.IsOpen -and $self.IsFocused) {
                    $cursorX = $self.X + 2 + $self.SearchText.Length
                    if ($cursorX -lt ($self.X + $self.Width - 3)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Options dropdown
                if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                    $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                    Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $startIdx = ($self.SelectedIndex -ge $self.MaxDisplayItems) ? ($self.SelectedIndex - $self.MaxDisplayItems + 1) : 0
                    $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                    
                    for ($i = $startIdx; $i -le $endIdx; $i++) {
                        $option = $self.FilteredOptions[$i]
                        $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                        
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $fg = $isSelected ? (Get-ThemeColor "Background") : (Get-ThemeColor "Primary")
                        $bg = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                        
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) {
                            $text = $text.Substring(0, $self.Width - 7) + "..."
                        }
                        
                        # Highlight matching text
                        if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                            $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                            if ($matchIndex -ge 0) {
                                if ($matchIndex -gt 0) { Write-BufferString -X ($self.X + 2) -Y $y -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg }
                                Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y -Text $text.Substring($matchIndex, $self.SearchText.Length) -ForegroundColor (Get-ThemeColor "Warning")
                                $afterMatch = $matchIndex + $self.SearchText.Length
                                if ($afterMatch -lt $text.Length) { Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y -Text $text.Substring($afterMatch) -ForegroundColor $fg }
                                continue
                            }
                        }
                        
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                    
                    # Scrollbar if needed
                    if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                        $scrollHeight = $self.MaxDisplayItems
                        $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $char = ($i -eq $scrollPos) ? "█" : "│"
                            $color = ($i -eq $scrollPos) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Subtle")
                            Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        FilterOptions = {
            try {
                $this.FilteredOptions = if ([string]::IsNullOrEmpty($this.SearchText)) {
                    $this.Options
                } else {
                    @($this.Options | Where-Object { $_.Display -like "*$($this.SearchText)*" })
                }
                
                if ($this.AllowCustomValue -and $this.SearchText -and -not ($this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText })) {
                    $this.FilteredOptions = @(@{ Display = $this.SearchText; Value = $this.SearchText; IsCustom = $true }) + $this.FilteredOptions
                }
                
                $this.SelectedIndex = 0
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown FilterOptions error for '$($this.Name)': $_" -Data @{ Component = $this.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        $self.SearchText = ""
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                    return $false
                }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) { $self.IsOpen = $false; $self.SearchText = ""; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Enter) {
                        if ($self.FilteredOptions.Count -gt 0) {
                            $selected = $self.FilteredOptions[$self.SelectedIndex]
                            if ($self.OnChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $selected.Value -Option $selected } -AdditionalData @{ Component = $self.Name; NewValue = $selected.Value; Option = $selected }
                            }
                            $self.Value = $selected.Value
                            $self.IsOpen = $false
                            $self.SearchText = ""
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::UpArrow) { if ($self.SelectedIndex -gt 0) { $self.SelectedIndex--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::DownArrow) { if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) { $self.SelectedIndex++; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Backspace) {
                        if ($self.SearchText.Length -gt 0) {
                            $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                            & $self.FilterOptions
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.SearchText += $Key.KeyChar
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Options = $Props.Options ?? @()
        SelectedValues = $Props.SelectedValues ?? @()
        Title = $Props.Title ?? "Select items"
        AllowSelectAll = $Props.AllowSelectAll ?? $true
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSubmit = $Props.OnSubmit
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor -Title " $($self.Title) "
                
                $currentY = $self.Y + 1
                if ($self.AllowSelectAll) {
                    $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                    $checkbox = $allSelected ? "[X]" : "[ ]"
                    $fg = ($self.SelectedIndex -eq -1) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" -ForegroundColor $fg
                    $currentY += 2
                }
                
                $visibleHeight = $self.Height - 4 - ($self.AllowSelectAll ? 2 : 0)
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.Options[$i]
                    $isChecked = $self.SelectedValues -contains $option.Value
                    $isHighlighted = ($i -eq $self.SelectedIndex)
                    
                    $checkbox = $isChecked ? "[X]" : "[ ]"
                    $fg = $isHighlighted ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                    
                    $text = "$checkbox $($option.Display)"
                    if ($text.Length -gt ($self.Width - 4)) { $text = $text.Substring(0, $self.Width - 7) + "..." }
                    
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                    $currentY++
                }
                
                $statusY = $self.Y + $self.Height - 2
                $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
                Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText -ForegroundColor (Get-ThemeColor "Subtle")
            } catch {
                Write-Log -Level Error -Message "MultiSelect Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) { $self.SelectedIndex = -1 } 
                        elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                            $self.SelectedIndex--
                            if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) { $self.ScrollOffset = $self.SelectedIndex }
                        }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                            $self.SelectedIndex++
                            $visibleHeight = $self.Height - 4 - ($self.AllowSelectAll ? 2 : 0)
                            if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) { $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1 }
                        }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                            $self.SelectedValues = ($self.SelectedValues.Count -eq $self.Options.Count) ? @() : @($self.Options.Value)
                        } elseif ($self.SelectedIndex -ge 0) {
                            $optionValue = $self.Options[$self.SelectedIndex].Value
                            if ($self.SelectedValues -contains $optionValue) {
                                $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $optionValue })
                            } else {
                                $self.SelectedValues += $optionValue
                            }
                        }
                        
                        if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -SelectedValues $self.SelectedValues } }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSubmit) { Invoke-WithErrorHandling -Component "$($self.Name).OnSubmit" -ScriptBlock { & $self.OnSubmit -SelectedValues $self.SelectedValues } }
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "MultiSelect HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Value = $Props.Value ?? 0
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        DecimalPlaces = $Props.DecimalPlaces ?? 0
        IsFocusable = $true
        TextValue = ($Props.Value ?? 0).ToString()
        CursorPosition = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $displayValue = $self.TextValue
                if ($displayValue.Length -gt ($self.Width - 6)) { $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..." }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
                
                if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    if ($cursorX -lt ($self.X + $self.Width - 4)) { Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent") }
                }
                
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" -ForegroundColor $borderColor
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" -ForegroundColor $borderColor
                
                if ($self.Value -le $self.Min) { Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" -ForegroundColor (Get-ThemeColor "Warning") }
                if ($self.Value -ge $self.Max) { Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" -ForegroundColor (Get-ThemeColor "Warning") }
            } catch { Write-Log -Level Error -Message "NumberInput Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ } }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                $newValue = ($this.DecimalPlaces -eq 0) ? [Math]::Floor($newValue) : [Math]::Round($newValue, $this.DecimalPlaces)
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) { Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { & $this.OnChange -NewValue $newValue } }
                return $true
            } catch {
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                Write-Log -Level Warning -Message "NumberInput ValidateAndUpdate error for '$($this.Name)': $_" -Data @{ Component = $this.Name; InputText = $this.TextValue; Exception = $_ }
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step); $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)"); $self.CursorPosition = $self.TextValue.Length; if ($self.OnChange) { & $self.OnChange -NewValue $self.Value }; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::DownArrow) { $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step); $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)"); $self.CursorPosition = $self.TextValue.Length; if ($self.OnChange) { & $self.OnChange -NewValue $self.Value }; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::LeftArrow) { if ($self.CursorPosition -gt 0) { $self.CursorPosition--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::RightArrow) { if ($self.CursorPosition -lt $self.TextValue.Length) { $self.CursorPosition++; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Home) { $self.CursorPosition = 0; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::End) { $self.CursorPosition = $self.TextValue.Length; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Backspace) { if ($self.CursorPosition -gt 0) { $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1); $self.CursorPosition--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Delete) { if ($self.CursorPosition -lt $self.TextValue.Length) { $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1); Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Enter) { & $self.ValidateAndUpdate -self $self; Request-TuiRefresh; return $true }
                    default {
                        if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                            $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch { Write-Log -Level Error -Message "NumberInput HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ } }
            return $false
        }
    }
    
    return $component
}

function New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 1
        Value = $Props.Value ?? 50
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        ShowValue = $Props.ShowValue ?? $true
        IsFocusable = $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $fg = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                
                $range = $self.Max - $self.Min
                $percent = ($self.Value - $self.Min) / $range
                $trackWidth = $self.Width - 2
                $thumbPos = [Math]::Floor($trackWidth * $percent)
                
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text ("─" * $trackWidth) -ForegroundColor (Get-ThemeColor "Subtle")
                if ($thumbPos -gt 0) { Write-BufferString -X ($self.X + 1) -Y $self.Y -Text ("═" * $thumbPos) -ForegroundColor $fg }
                
                Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
                Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
                Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
                
                if ($self.ShowValue) {
                    $valueText = $self.Value.ToString()
                    $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                    Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
                }
            } catch { Write-Log -Level Error -Message "Slider Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ } }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $oldValue = $self.Value
                $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) { $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step) }
                    ([ConsoleKey]::RightArrow) { $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step) }
                    ([ConsoleKey]::Home) { $self.Value = $self.Min }
                    ([ConsoleKey]::End) { $self.Value = $self.Max }
                    ([ConsoleKey]::PageDown) { $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep) }
                    ([ConsoleKey]::PageUp) { $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep) }
                    default { $handled = $false }
                }
                
                if ($handled -and $self.Value -ne $oldValue) {
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $self.Value } }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch { Write-Log -Level Error -Message "Slider HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ } }
            return $false
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function 'New-TuiCalendarPicker', 'New-TuiSearchableDropdown', 'New-TuiMultiSelect', 'New-TuiNumberInput', 'New-TuiSlider'


####\refactor_checkpoints\checkpoint_20250629_204807_pre-phase-a-complete\components\navigation-class.psm1
# Navigation Component Classes Module for PMC Terminal v5
# Implements navigation menu functionality with keyboard shortcuts

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        # Simplified format display without ANSI escape codes
        $display = "[$($this.Key)] "
        
        if ($this.Enabled) {
            $display += $this.Label
        }
        else {
            $display += "$($this.Label) (Disabled)"
        }
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            $display += " - $($this.Description)"
        }
        
        return $display
    }
}

# NavigationMenu - Component for displaying and handling navigation options
class NavigationMenu : Component {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    
    NavigationMenu([string]$name) : base($name) {
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.SelectedIndex = 0
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base($name) {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.SelectedIndex = 0
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) { 
            throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") 
        }
        $this.Items.Add($item)
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { [void]$this.Items.Remove($item) }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { 
                $item.Execute() 
            }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
    }

    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", { 
                    $this.Services.Navigation.GoTo("/tasks", @{mode="new"}) 
                }))
                $this.AddItem([NavigationItem]::new("P", "Projects", { 
                    $this.Services.Navigation.GoTo("/projects", @{}) 
                }))
                $this.AddItem([NavigationItem]::new("S", "Settings", { 
                    $this.Services.Navigation.GoTo("/settings", @{}) 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("Q", "Quit", { 
                    $this.Services.Navigation.RequestExit() 
                }))
            }
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", { 
                    Write-Host "New task not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("E", "Edit", { 
                    Write-Host "Edit not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("D", "Delete", { 
                    Write-Host "Delete not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("F", "Filter", { 
                    Write-Host "Filter not implemented" 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
            }
            default {
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
                $this.AddItem([NavigationItem]::new("H", "Home", { 
                    $this.Services.Navigation.GoTo("/dashboard", @{}) 
                }))
            }
        }
    }
    
    # AI: FIX - Get render coordinates from parent panel
    hidden [hashtable] GetRenderPosition() {
        # Default position if no parent
        $x = 0
        $y = 0
        
        # AI: FIX - If we have a parent Panel, use its content area
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $x = $contentArea.X
            $y = $contentArea.Y
        }
        
        return @{ X = $x; Y = $y }
    }
    
    hidden [void] _RenderContent() {
        # Get visible items
        if ($null -eq $this.Items -or $this.Items.Count -eq 0) {
            return
        }
        
        $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
        if ($visibleItems.Count -eq 0) { return }
        
        if ($this.Orientation -eq "Horizontal") { 
            $this.RenderHorizontal($visibleItems) 
        }
        else { 
            $this.RenderVertical($visibleItems) 
        }
    }
    
    hidden [void] RenderHorizontal([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) {
            return
        }
        
        # AI: FIX - Get proper render position from parent
        $pos = $this.GetRenderPosition()
        
        $menuText = ""
        $isFirst = $true
        foreach ($item in $items) {
            if ($null -eq $item) { continue }
            
            if (-not $isFirst) {
                $menuText += $this.Separator
            }
            $menuText += "[$($item.Key)] $($item.Label)"
            $isFirst = $false
        }
        
        if (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue) {
            Write-BufferString -X $pos.X -Y $pos.Y -Text $menuText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
        }
    }
    
    hidden [void] RenderVertical([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) {
            return
        }
        
        # AI: FIX - Get proper render position from parent
        $pos = $this.GetRenderPosition()
        
        # Ensure SelectedIndex is within bounds
        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {
            $this.SelectedIndex = 0
        }
        
        # AI: FIX - Calculate max width for proper clearing
        $maxWidth = 0
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $maxWidth = $contentArea.Width
        }
        
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($null -eq $item) { continue }
            
            $prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }
            $menuText = "$prefix[$($item.Key)] $($item.Label)"
            
            # AI: FIX - Pad text to clear the full line width
            if ($maxWidth -gt 0 -and $menuText.Length -lt $maxWidth) {
                $menuText = $menuText.PadRight($maxWidth)
            }
            
            if (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue) {
                $fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                    [ConsoleColor]::Black 
                } else { 
                    [ConsoleColor]::White 
                }
                $bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                    [ConsoleColor]::White 
                } else { 
                    [ConsoleColor]::Black 
                }
                
                Write-BufferString -X $pos.X -Y ($pos.Y + $i) -Text $menuText `
                    -ForegroundColor $fg -BackgroundColor $bg
            }
        }
    }
}

Export-ModuleMember -Function @()



####\refactor_checkpoints\checkpoint_20250629_204807_pre-phase-a-complete\components\tui-components.psm1
# TUI Component Library
# Stateful component factories following the canonical architecture

using module .\ui-classes.psm1

#region Component Classes

# AI: LabelComponent - converts functional New-TuiLabel to class-based
class LabelComponent : UIElement {
    [int]$X = 0
    [int]$Y = 0
    [int]$Width = 10
    [int]$Height = 1
    [int]$ZIndex = 0
    [string]$Text = ""
    [object]$ForegroundColor
    
    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }
        try {
            $fg = $this.ForegroundColor ?? (Get-ThemeColor "Primary")
            Write-BufferString -X $this.X -Y $this.Y -Text $this.Text -ForegroundColor $fg
        } catch { 
            Write-Log -Level Error -Message "Label Render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}

# AI: ButtonComponent - converts functional New-TuiButton to class-based  
class ButtonComponent : UIElement {
    [int]$X = 0
    [int]$Y = 0
    [int]$Width = 10
    [int]$Height = 3
    [int]$ZIndex = 0
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick
    
    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Text = "Button"
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }
        try {
            $borderColor = $this.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
            $bgColor = $this.IsPressed ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
            $fgColor = $this.IsPressed ? (Get-ThemeColor "Background") : $borderColor
            
            Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height -BorderColor $borderColor -BackgroundColor $bgColor
            $textX = $this.X + [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            Write-BufferString -X $textX -Y ($this.Y + 1) -Text $this.Text -ForegroundColor $fgColor -BackgroundColor $bgColor
        } catch { 
            Write-Log -Level Error -Message "Button Render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if ($this.OnClick) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock { & $this.OnClick }
                }
                Request-TuiRefresh
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "Button HandleInput error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: TextBoxComponent - converts functional New-TuiTextBox to class-based
class TextBoxComponent : UIElement {
    [int]$X = 0
    [int]$Y = 0
    [int]$Width = 20
    [int]$Height = 3
    [int]$ZIndex = 0
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.MaxLength = 100
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }
        try {
            $borderColor = $this.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
            Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height 3 -BorderColor $borderColor
            
            $displayText = $this.Text ?? ""
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = $this.Placeholder ?? "" 
            }
            
            $maxDisplayLength = $this.Width - 4
            if ($displayText.Length -gt $maxDisplayLength) { 
                $displayText = $displayText.Substring(0, $maxDisplayLength) 
            }
            
            Write-BufferString -X ($this.X + 2) -Y ($this.Y + 1) -Text $displayText
            
            if ($this.IsFocused -and $this.CursorPosition -le $displayText.Length) {
                $cursorX = $this.X + 2 + $this.CursorPosition
                Write-BufferString -X $cursorX -Y ($this.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent")
            }
        } catch { 
            Write-Log -Level Error -Message "TextBox Render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            # AI: Fixed variable naming conflict - use $currentText instead of $text to avoid clash with $this.Text property
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition ?? 0
            $originalText = $currentText
            
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $currentText = $currentText.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    } 
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $currentText.Length) { 
                        $currentText = $currentText.Remove($cursorPos, 1) 
                    } 
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- } 
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $currentText.Length) { $cursorPos++ } 
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $currentText.Length }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) { 
                        $currentText = $currentText.Insert($cursorPos, $key.KeyChar)
                        $cursorPos++ 
                    } else { 
                        return $false 
                    }
                }
            }
            
            if ($currentText -ne $originalText -or $cursorPos -ne $this.CursorPosition) {
                $this.Text = $currentText
                $this.CursorPosition = $cursorPos
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $currentText 
                    }
                }
                Request-TuiRefresh
            }
            return $true
        } catch { 
            Write-Log -Level Error -Message "TextBox HandleInput error for '$($this.Name)': $_"
            return $false 
        }
    }
}

#endregion

#region Factory Functions (Updated to use Classes)

# AI: Updated to return class instances instead of hashtables

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $label = [LabelComponent]::new($name)
    
    $label.X = $Props.X ?? $label.X
    $label.Y = $Props.Y ?? $label.Y
    $label.Width = $Props.Width ?? $label.Width
    $label.Height = $Props.Height ?? $label.Height
    $label.Visible = $Props.Visible ?? $label.Visible
    $label.ZIndex = $Props.ZIndex ?? $label.ZIndex
    $label.Text = $Props.Text ?? $label.Text
    $label.ForegroundColor = $Props.ForegroundColor ?? $label.ForegroundColor
    
    return $label
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $button = [ButtonComponent]::new($name)
    
    $button.X = $Props.X ?? $button.X
    $button.Y = $Props.Y ?? $button.Y
    $button.Width = $Props.Width ?? $button.Width
    $button.Height = $Props.Height ?? $button.Height
    $button.Visible = $Props.Visible ?? $button.Visible
    $button.ZIndex = $Props.ZIndex ?? $button.ZIndex
    $button.Text = $Props.Text ?? $button.Text
    $button.OnClick = $Props.OnClick ?? $button.OnClick
    
    return $button
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [TextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Text = $Props.Text ?? $textBox.Text
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLength = $Props.MaxLength ?? $textBox.MaxLength
    $textBox.CursorPosition = $Props.CursorPosition ?? $textBox.CursorPosition
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    return $textBox
}

# AI: REMAINING FACTORY FUNCTIONS TO CONVERT TO CLASSES
# The following functions need to be converted using the same pattern:
# 1. Create a class that inherits from UIElement or Component
# 2. Add properties from the hashtable
# 3. Convert Render scriptblock to _RenderContent() method returning [void]
# 4. Convert HandleInput scriptblock to HandleInput() method
# 5. Update factory function to return class instance
#
# Functions to convert:
# - New-TuiCheckBox -> CheckBoxComponent
# - New-TuiDropdown -> DropdownComponent  
# - New-TuiProgressBar -> ProgressBarComponent
# - New-TuiTextArea -> TextAreaComponent
# - New-TuiDatePicker -> DatePickerComponent
# - New-TuiTimePicker -> TimePickerComponent
# - New-TuiTable -> TableComponent
# - New-TuiChart -> ChartComponent
#
# For now, these remain as functional components for compatibility

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "CheckBox"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Text = $Props.Text ?? "Checkbox"
        Checked = $Props.Checked ?? $false
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                $fg = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                $checkbox = $self.Checked ? "[X]" : "[ ]"
                Write-BufferString -X $self.X -Y $self.Y -Text "$checkbox $($self.Text)" -ForegroundColor $fg
            } catch { Write-Log -Level Error -Message "CheckBox Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    $self.Checked = -not $self.Checked
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $self.Checked } }
                    Request-TuiRefresh
                    return $true
                }
            } catch { Write-Log -Level Error -Message "CheckBox HandleInput error for '$($self.Name)': $_" }
            return $false
        }
    }
}

function New-TuiDropdown {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "Dropdown"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 10
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Select..."
        Name = $Props.Name
        IsOpen = $false
        SelectedIndex = 0
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = $self.Placeholder
                if ($self.Value -and $self.Options) {
                    $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                    if ($selected) { $displayText = $selected.Display }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                $indicator = $self.IsOpen ? "▲" : "▼"
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator
                
                if ($self.IsOpen -and $self.Options.Count -gt 0) {
                    $listHeight = [Math]::Min($self.Options.Count + 2, 8)
                    Write-BufferBox -X $self.X -Y ($self.Y + 3) -Width $self.Width -Height $listHeight -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $displayCount = [Math]::Min($self.Options.Count, 6)
                    for ($i = 0; $i -lt $displayCount; $i++) {
                        $option = $self.Options[$i]
                        $y = $self.Y + 4 + $i
                        $fg = ($i -eq $self.SelectedIndex) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                        $bg = ($i -eq $self.SelectedIndex) ? (Get-ThemeColor "Secondary") : (Get-ThemeColor "Background")
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) { $text = $text.Substring(0, $self.Width - 7) + "..." }
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                }
            } catch { Write-Log -Level Error -Message "Dropdown Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        Request-TuiRefresh
                        return $true
                    }
                } else {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) { if ($self.SelectedIndex -gt 0) { $self.SelectedIndex--; Request-TuiRefresh }; return $true }
                        ([ConsoleKey]::DownArrow) { if ($self.SelectedIndex -lt ($self.Options.Count - 1)) { $self.SelectedIndex++; Request-TuiRefresh }; return $true }
                        ([ConsoleKey]::Enter) {
                            if ($self.Options.Count -gt 0) {
                                $selected = $self.Options[$self.SelectedIndex]
                                $self.Value = $selected.Value
                                if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $selected.Value } }
                            }
                            $self.IsOpen = $false
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Escape) { $self.IsOpen = $false; Request-TuiRefresh; return $true }
                    }
                }
            } catch { Write-Log -Level Error -Message "Dropdown HandleInput error for '$($self.Name)': $_" }
            return $false
        }
    }
}

function New-TuiProgressBar {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "ProgressBar"
        IsFocusable = $false
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Value = $Props.Value ?? 0
        Max = $Props.Max ?? 100
        ShowPercent = $Props.ShowPercent ?? $false
        Name = $Props.Name
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $percent = [Math]::Min(100, [Math]::Max(0, ($self.Value / $self.Max) * 100))
                $filled = [Math]::Floor(($self.Width - 2) * ($percent / 100))
                $empty = ($self.Width - 2) - $filled
                
                $bar = "█" * $filled + "░" * $empty
                Write-BufferString -X $self.X -Y $self.Y -Text "[$bar]" -ForegroundColor (Get-ThemeColor "Accent")
                
                if ($self.ShowPercent) {
                    $percentText = "$([Math]::Round($percent))%"
                    $textX = $self.X + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $textX -Y $self.Y -Text $percentText -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch { Write-Log -Level Error -Message "ProgressBar Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = { param($self, $Key) return $false }
    }
}

function New-TuiTextArea {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "TextArea"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 6
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Text = $Props.Text ?? ""
        Placeholder = $Props.Placeholder ?? "Enter text..."
        WrapText = $Props.WrapText ?? $true
        Name = $Props.Name
        Lines = ($Props.Text ?? "") -split "`n"
        CursorX = 0
        CursorY = 0
        ScrollOffset = 0
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $innerWidth = $self.Width - 4
                $innerHeight = $self.Height - 2
                $displayLines = if ($self.WrapText) {
                    $self.Lines | ForEach-Object { Get-WordWrappedLines -Text $_ -MaxWidth $innerWidth }
                } else {
                    $self.Lines
                }
                
                if ($displayLines.Count -eq 1 -and $displayLines[0] -eq "" -and -not $self.IsFocused) {
                    Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $self.Placeholder
                    return
                }
                
                $startLine = $self.ScrollOffset
                $endLine = [Math]::Min($displayLines.Count - 1, $startLine + $innerHeight - 1)
                
                for ($i = $startLine; $i -le $endLine; $i++) {
                    $y = $self.Y + 1 + ($i - $startLine)
                    $line = $displayLines[$i]
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $line
                }
                
                if ($self.IsFocused -and $self.CursorY -ge $startLine -and $self.CursorY -le $endLine) {
                    $cursorScreenY = $self.Y + 1 + ($self.CursorY - $startLine)
                    $cursorX = [Math]::Min($self.CursorX, $displayLines[$self.CursorY].Length)
                    Write-BufferString -X ($self.X + 2 + $cursorX) -Y $cursorScreenY -Text "_" -BackgroundColor (Get-ThemeColor "Accent")
                }
                
                if ($displayLines.Count -gt $innerHeight) {
                    $scrollbarHeight = $innerHeight
                    $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($displayLines.Count - $innerHeight)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = ($i -eq $scrollPosition) ? "█" : "│"
                        $color = ($i -eq $scrollPosition) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Subtle")
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch { Write-Log -Level Error -Message "TextArea Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $lines = $self.Lines
                $cursorY = $self.CursorY
                $cursorX = $self.CursorX
                $innerHeight = $self.Height - 2
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { if ($cursorY -gt 0) { $cursorY--; $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length); if ($cursorY -lt $self.ScrollOffset) { $self.ScrollOffset = $cursorY } } }
                    ([ConsoleKey]::DownArrow) { if ($cursorY -lt $lines.Count - 1) { $cursorY++; $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length); if ($cursorY -ge $self.ScrollOffset + $innerHeight) { $self.ScrollOffset = $cursorY - $innerHeight + 1 } } }
                    ([ConsoleKey]::LeftArrow) { if ($cursorX -gt 0) { $cursorX-- } elseif ($cursorY -gt 0) { $cursorY--; $cursorX = $lines[$cursorY].Length } }
                    ([ConsoleKey]::RightArrow) { if ($cursorX -lt $lines[$cursorY].Length) { $cursorX++ } elseif ($cursorY -lt $lines.Count - 1) { $cursorY++; $cursorX = 0 } }
                    ([ConsoleKey]::Home) { $cursorX = 0 }
                    ([ConsoleKey]::End) { $cursorX = $lines[$cursorY].Length }
                    ([ConsoleKey]::Enter) {
                        $currentLine = $lines[$cursorY]
                        $beforeCursor = $currentLine.Substring(0, $cursorX)
                        $afterCursor = $currentLine.Substring($cursorX)
                        $lines[$cursorY] = $beforeCursor
                        $lines = @($lines[0..$cursorY]) + @($afterCursor) + @($lines[($cursorY + 1)..($lines.Count - 1)])
                        $cursorY++; $cursorX = 0
                        if ($cursorY -ge $self.ScrollOffset + $innerHeight) { $self.ScrollOffset = $cursorY - $innerHeight + 1 }
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($cursorX -gt 0) { $lines[$cursorY] = $lines[$cursorY].Remove($cursorX - 1, 1); $cursorX-- } 
                        elseif ($cursorY -gt 0) {
                            $prevLineLength = $lines[$cursorY - 1].Length; $lines[$cursorY - 1] += $lines[$cursorY]
                            $lines = @($lines | Where-Object { $_ -ne $lines[$cursorY] }); $cursorY--; $cursorX = $prevLineLength
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($cursorX -lt $lines[$cursorY].Length) { $lines[$cursorY] = $lines[$cursorY].Remove($cursorX, 1) } 
                        elseif ($cursorY -lt $lines.Count - 1) {
                            $lines[$cursorY] += $lines[$cursorY + 1]; $lines = @($lines | Where-Object { $_ -ne $lines[$cursorY + 1] })
                        }
                    }
                    ([ConsoleKey]::V) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                $clipboardText = Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                if ($clipboardText) {
                                    $clipboardLines = $clipboardText -split '[\r\n]+'
                                    if ($clipboardLines.Count -eq 1) {
                                        $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $clipboardLines[0]); $cursorX += $clipboardLines[0].Length
                                    } else {
                                        $currentLine = $lines[$cursorY]; $beforeCursor = $currentLine.Substring(0, $cursorX); $afterCursor = $currentLine.Substring($cursorX)
                                        $lines[$cursorY] = $beforeCursor + $clipboardLines[0]
                                        $insertLines = $clipboardLines[1..($clipboardLines.Count - 2)] + ($clipboardLines[-1] + $afterCursor)
                                        $newLines = @($lines[0..$cursorY]) + $insertLines + @($lines[($cursorY + 1)..($lines.Count - 1)])
                                        $lines = $newLines; $cursorY += $clipboardLines.Count - 1; $cursorX = $clipboardLines[-1].Length
                                    }
                                    if ($cursorY -ge $self.ScrollOffset + $innerHeight) { $self.ScrollOffset = $cursorY - $innerHeight + 1 }
                                }
                            } catch { Write-Log -Level Warning -Message "TextArea clipboard paste error for '$($self.Name)': $_" }
                        } else {
                            if (-not [char]::IsControl($Key.KeyChar)) { $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar); $cursorX++ } 
                            else { return $false }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) { $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar); $cursorX++ } 
                        else { return $false }
                    }
                }
                
                $self.Lines = $lines; $self.CursorX = $cursorX; $self.CursorY = $cursorY; $self.Text = $lines -join "`n"
                if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $self.Text } }
                Request-TuiRefresh
                return $true
            } catch { Write-Log -Level Error -Message "TextArea HandleInput error for '$($self.Name)': $_"; return $false }
        }
    }
    
    return $component
}

#endregion

#region DateTime Components

function New-TuiDatePicker {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "DatePicker"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Value = $Props.Value ?? (Get-Date)
        Format = $Props.Format ?? "yyyy-MM-dd"
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                $dateStr = $self.Value.ToString($self.Format)
                
                $maxLength = $self.Width - 6
                if ($dateStr.Length -gt $maxLength) { $dateStr = $dateStr.Substring(0, $maxLength) }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $dateStr
                if ($self.IsFocused -and $self.Width -ge 6) { Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "📅" -ForegroundColor $borderColor }
            } catch { Write-Log -Level Error -Message "DatePicker Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $date = $self.Value
                $handled = $true
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow)   { $date = $date.AddDays(1) }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(-1) }
                    ([ConsoleKey]::PageUp)    { $date = $date.AddMonths(1) }
                    ([ConsoleKey]::PageDown)  { $date = $date.AddMonths(-1) }
                    ([ConsoleKey]::Home)      { $date = Get-Date }
                    ([ConsoleKey]::T) { if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $date = Get-Date } else { $handled = $false } }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.Value = $date
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $date } }
                    Request-TuiRefresh
                }
                return $handled
            } catch { Write-Log -Level Error -Message "DatePicker HandleInput error for '$($self.Name)': $_"; return $false }
        }
    }
}

function New-TuiTimePicker {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "TimePicker"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 15
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Hour = $Props.Hour ?? 0
        Minute = $Props.Minute ?? 0
        Format24H = $Props.Format24H ?? $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $timeStr = if ($self.Format24H) { 
                    "{0:D2}:{1:D2}" -f $self.Hour, $self.Minute 
                } else {
                    $displayHour = if ($self.Hour -eq 0) { 12 } elseif ($self.Hour -gt 12) { $self.Hour - 12 } else { $self.Hour }
                    $ampm = ($self.Hour -lt 12) ? "AM" : "PM"
                    "{0:D2}:{1:D2} {2}" -f $displayHour, $self.Minute, $ampm
                }
                
                $maxLength = $self.Width - 6
                if ($timeStr.Length -gt $maxLength) { $timeStr = $timeStr.Substring(0, $maxLength) }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $timeStr
                if ($self.IsFocused -and $self.Width -ge 6) { Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "⏰" -ForegroundColor $borderColor }
            } catch { Write-Log -Level Error -Message "TimePicker Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true; $hour = $self.Hour; $minute = $self.Minute
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { $minute = ($minute + 15) % 60; if ($minute -eq 0) { $hour = ($hour + 1) % 24 } }
                    ([ConsoleKey]::DownArrow) { $minute = ($minute - 15 + 60) % 60; if ($minute -eq 45) { $hour = ($hour - 1 + 24) % 24 } }
                    ([ConsoleKey]::LeftArrow)  { $hour = ($hour - 1 + 24) % 24 }
                    ([ConsoleKey]::RightArrow) { $hour = ($hour + 1) % 24 }
                    default { $handled = $false }
                }
                if ($handled) {
                    $self.Hour = $hour; $self.Minute = $minute
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewHour $hour -NewMinute $minute } }
                    Request-TuiRefresh
                }
                return $handled
            } catch { Write-Log -Level Error -Message "TimePicker HandleInput error for '$($self.Name)': $_"; return $false }
        }
    }
}

#endregion

#region Data Display Components

function New-TuiTable {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "Table"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 60
        Height = $Props.Height ?? 15
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Columns = $Props.Columns ?? @()
        Rows = $Props.Rows ?? @()
        Name = $Props.Name
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortAscending = $true
        OnRowSelect = $Props.OnRowSelect
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Columns.Count -eq 0) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $totalWidth = $self.Width - 4; $colWidth = [Math]::Floor($totalWidth / $self.Columns.Count); $headerY = $self.Y + 1; $currentX = $self.X + 2
                
                foreach ($col in $self.Columns) {
                    $header = $col.Header
                    if ($col.Name -eq $self.SortColumn) { $header += $self.SortAscending ? " ▲" : " ▼" }
                    if ($header.Length -gt $colWidth - 1) { $header = $header.Substring(0, $colWidth - 4) + "..." }
                    Write-BufferString -X $currentX -Y $headerY -Text $header -ForegroundColor (Get-ThemeColor "Header"); $currentX += $colWidth
                }
                
                Write-BufferString -X ($self.X + 1) -Y ($headerY + 1) -Text ("─" * ($self.Width - 2)) -ForegroundColor $borderColor
                
                $visibleRows = $self.Height - 5; $startIdx = $self.ScrollOffset; $endIdx = [Math]::Min($self.Rows.Count - 1, $startIdx + $visibleRows - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $row = $self.Rows[$i]; $rowY = ($headerY + 2) + ($i - $startIdx); $currentX = $self.X + 2
                    $isSelected = ($i -eq $self.SelectedRow -and $self.IsFocused)
                    $bgColor = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                    $fgColor = $isSelected ? (Get-ThemeColor "Background") : (Get-ThemeColor "Primary")
                    
                    if ($isSelected) { Write-BufferString -X ($self.X + 1) -Y $rowY -Text (" " * ($self.Width - 2)) -BackgroundColor $bgColor }
                    
                    foreach ($col in $self.Columns) {
                        $value = $row.($col.Name) ?? ""; $text = $value.ToString()
                        if ($text.Length -gt $colWidth - 1) { $text = $text.Substring(0, $colWidth - 4) + "..." }
                        Write-BufferString -X $currentX -Y $rowY -Text $text -ForegroundColor $fgColor -BackgroundColor $bgColor; $currentX += $colWidth
                    }
                }
                
                if ($self.Rows.Count -gt $visibleRows) {
                    $scrollbarHeight = $visibleRows; $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($self.Rows.Count - $visibleRows)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = ($i -eq $scrollPosition) ? "█" : "│"
                        $color = ($i -eq $scrollPosition) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Subtle")
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($headerY + 2 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch { Write-Log -Level Error -Message "Table Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($self.Rows.Count -eq 0) { return $false }
                $visibleRows = $self.Height - 5; $handled = $true
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { if ($self.SelectedRow -gt 0) { $self.SelectedRow--; if ($self.SelectedRow -lt $self.ScrollOffset) { $self.ScrollOffset = $self.SelectedRow }; Request-TuiRefresh } }
                    ([ConsoleKey]::DownArrow) { if ($self.SelectedRow -lt $self.Rows.Count - 1) { $self.SelectedRow++; if ($self.SelectedRow -ge $self.ScrollOffset + $visibleRows) { $self.ScrollOffset = $self.SelectedRow - $visibleRows + 1 }; Request-TuiRefresh } }
                    ([ConsoleKey]::PageUp) { $self.SelectedRow = [Math]::Max(0, $self.SelectedRow - $visibleRows); $self.ScrollOffset = [Math]::Max(0, $self.ScrollOffset - $visibleRows); Request-TuiRefresh }
                    ([ConsoleKey]::PageDown) { $self.SelectedRow = [Math]::Min($self.Rows.Count - 1, $self.SelectedRow + $visibleRows); $maxScroll = [Math]::Max(0, $self.Rows.Count - $visibleRows); $self.ScrollOffset = [Math]::Min($maxScroll, $self.ScrollOffset + $visibleRows); Request-TuiRefresh }
                    ([ConsoleKey]::Home) { $self.SelectedRow = 0; $self.ScrollOffset = 0; Request-TuiRefresh }
                    ([ConsoleKey]::End) { $self.SelectedRow = $self.Rows.Count - 1; $self.ScrollOffset = [Math]::Max(0, $self.Rows.Count - $visibleRows); Request-TuiRefresh }
                    ([ConsoleKey]::Enter) { if ($self.OnRowSelect) { Invoke-WithErrorHandling -Component "$($self.Name).OnRowSelect" -ScriptBlock { & $self.OnRowSelect -Row $self.Rows[$self.SelectedRow] -Index $self.SelectedRow } } }
                    default {
                        if ($Key.KeyChar -match '\d') {
                            $colIndex = [int]$Key.KeyChar.ToString() - 1
                            if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                                $colName = $self.Columns[$colIndex].Name
                                if ($self.SortColumn -eq $colName) { $self.SortAscending = -not $self.SortAscending } 
                                else { $self.SortColumn = $colName; $self.SortAscending = $true }
                                $self.Rows = $self.Rows | Sort-Object -Property $colName -Descending:(-not $self.SortAscending)
                                Request-TuiRefresh
                            }
                        } else { $handled = $false }
                    }
                }
            } catch { Write-Log -Level Error -Message "Table HandleInput error for '$($self.Name)': $_" }
            return $handled
        }
    }
}

function New-TuiChart {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "Chart"
        IsFocusable = $false
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 10
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        ChartType = $Props.ChartType ?? "Bar"
        Data = $Props.Data ?? @()
        ShowValues = $Props.ShowValues ?? $true
        Name = $Props.Name
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Data.Count -eq 0) { return }
                
                switch ($self.ChartType) {
    		   # "Bar" {
                                            "Bar" {
                        $maxValue = ($self.Data.Value | Measure-Object -Maximum).Maximum ?? 1
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        $chartHeight = $self.Height - 2
                        $barWidth = [Math]::Floor(($self.Width - 4) / $self.Data.Count)
                        
                        for ($i = 0; $i -lt $self.Data.Count; $i++) {
                            $item = $self.Data[$i]
                            $barHeight = [Math]::Floor(($item.Value / $maxValue) * $chartHeight)
                            $barX = $self.X + 2 + ($i * $barWidth)
                            
                            for ($y = 0; $y -lt $barHeight; $y++) { 
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 2 - $y) -Text ("█" * ($barWidth - 1)) -ForegroundColor (Get-ThemeColor "Accent") 
                            }
                            if ($item.Label -and $barWidth -gt 3) { 
                                $label = $item.Label
                                if ($label.Length -gt $barWidth - 1) { $label = $label.Substring(0, $barWidth - 2) }
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 1) -Text $label -ForegroundColor (Get-ThemeColor "Subtle") 
                            }
                            if ($self.ShowValues -and $barHeight -gt 0) { 
                                $valueText = $item.Value.ToString()
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 3 - $barHeight) -Text $valueText -ForegroundColor (Get-ThemeColor "Primary") 
                            }
                        }
                    }
                    "Sparkline" {
                        $width = $self.Width - 2; $height = $self.Height - 1; $maxValue = ($self.Data | Measure-Object -Maximum).Maximum ?? 1
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        $sparkChars = " ", " ", "▂", "▃", "▄", "▅", "▆", "▇", "█"
                        $sparkline = ""
                        foreach ($value in $self.Data) { $normalized = $value / $maxValue; $charIndex = [Math]::Floor($normalized * ($sparkChars.Count - 1)); $sparkline += $sparkChars[$charIndex] }
                        if ($sparkline.Length -gt $width) { $sparkline = $sparkline.Substring($sparkline.Length - $width) } else { $sparkline = $sparkline.PadLeft($width) }
                        Write-BufferString -X ($self.X + 1) -Y ($self.Y + [Math]::Floor($height / 2)) -Text $sparkline -ForegroundColor (Get-ThemeColor "Accent")
                    }
                }
            } catch { Write-Log -Level Error -Message "Chart Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = { param($self, $Key) return $false }
    }
}

#endregion

Export-ModuleMember -Function 'New-TuiLabel', 'New-TuiButton', 'New-TuiTextBox', 'New-TuiCheckBox', 'New-TuiDropdown', 'New-TuiProgressBar', 'New-TuiTextArea', 'New-TuiDatePicker', 'New-TuiTimePicker', 'New-TuiTable', 'New-TuiChart'


####\refactor_checkpoints\checkpoint_20250629_204807_pre-phase-a-complete\components\tui-primitives.psm1
# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations

using namespace System
using namespace System.Management.Automation

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    [ConsoleColor] $ForegroundColor = [ConsoleColor]::White
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = ""
    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() {
        $this.Char = ' '
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Character constructor
    TuiCell([char]$char) {
        $this.Char = $char
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Full constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }

    # Style constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }

    # Copy constructor
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.StyleFlags = $other.StyleFlags
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Create a styled copy
    [TuiCell] WithStyle([ConsoleColor]$fg, [ConsoleColor]$bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    # Create a character copy
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blend this cell with another (higher Z-index wins)
    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return $other }
        if ($other.ZIndex -eq $this.ZIndex -and $other.Char -ne ' ') { return $other }
        return $this
    }

    # Check if this cell differs from another
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic)
    }

    # Generate ANSI escape sequence for this cell
    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Color codes
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append("`e[${fgCode};${bgCode}")
        
        # Style codes
        if ($this.Bold) { [void]$sb.Append(";1") }
        if ($this.Underline) { [void]$sb.Append(";4") }
        if ($this.Italic) { [void]$sb.Append(";3") }
        
        [void]$sb.Append("m").Append($this.Char)
        return $sb.ToString()
    }

    # Convert to legacy buffer format for compatibility
    [hashtable] ToLegacyFormat() {
        return @{
            Char = $this.Char
            FG = $this.ForegroundColor
            BG = $this.BackgroundColor
        }
    }

    # String representation
    [string] ToString() {
        return "TuiCell($($this.Char), $($this.ForegroundColor), $($this.BackgroundColor))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

#region UIElement Base Class - Foundation for All Components
class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer = $null
    [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{}

    # Constructor
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with position and size
    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Buffer")
    }

    # Get absolute screen position
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # Add child component
    [void] AddChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
        }
    }

    # Remove child component
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
            $this.RequestRedraw()
        }
    }

    # Request redraw for this component and parents
    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
    }

    # Resize the component and its buffer
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Resize($newWidth, $newHeight)
        }
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # Move the component
    [void] Move([int]$newX, [int]$newY) {
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
    }

    # Check if point is within component bounds
    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge $this.X -and $x -lt ($this.X + $this.Width) -and 
                $y -ge $this.Y -and $y -lt ($this.Y + $this.Height))
    }

    # Get child at specific point (relative to this component)
    [UIElement] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $this.X, $y - $this.Y)) {
                return $child
            }
        }
        return $null
    }

    # Virtual methods for subclasses to override
    [void] OnRender() {
        # Default implementation - clear buffer
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Override in subclasses
    }

    [void] OnMove([int]$newX, [int]$newY) {
        # Override in subclasses
    }

    [void] OnFocus() {
        # Override in subclasses
    }

    [void] OnBlur() {
        # Override in subclasses
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Override in subclasses - return true if input was handled
        return $false
    }

    # Main render method - calls OnRender and renders children
    [void] Render() {
        if (-not $this.Visible) { return }

        # Render this component to its private buffer
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer) {
                $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }
            
            $this.OnRender()
            $this._needs_redraw = $false
        }

        # Render children to their buffers, then composite onto parent
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
    }

    # Get the final rendered buffer
    [TuiBuffer] GetBuffer() {
        return $this._private_buffer
    }
}
#endregion

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int] GetForegroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()]
    }

    static [int] GetBackgroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()] + 10
    }

    static [string] Reset() {
        return "`e[0m"
    }

    static [string] Bold() {
        return "`e[1m"
    }

    static [string] Underline() {
        return "`e[4m"
    }

    static [string] Italic() {
        return "`e[3m"
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions
function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    
    $cell = [TuiCell]::new(' ', $ForegroundColor, $BackgroundColor)
    $cell.Bold = $Bold
    $cell.Underline = $Underline
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0) {
            $charCell = [TuiCell]::new($cell)
            $charCell.Char = $char
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$BorderStyle = "Single",
        [ConsoleColor]$BorderColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }
    
    $borders = Get-TuiBorderChars -Style $BorderStyle
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Side borders and fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        $currentY = $Y + $i
        
        # Left border
        Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill
        $fillText = ' ' * ($Width - 2)
        Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -BackgroundColor $BackgroundColor
        
        # Right border
        Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $bottomLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all classes and functions
Export-ModuleMember -Function 'Write-TuiText', 'Write-TuiBox', 'Get-TuiBorderChars'


####\refactor_checkpoints\checkpoint_20250629_204807_pre-phase-a-complete\layout\panels-class.psm1
# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

using module .\components\tui-primitives.psm1

#region Panel Class - Basic Layout Container
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds
    [void] Resize([int]$newWidth, [int]$newHeight) {
        ([UIElement]$this).Resize($newWidth, $newHeight)
        $this.UpdateContentBounds()
    }

    # Add child with automatic layout (if enabled)
    [void] AddChild([UIElement]$child) {
        ([UIElement]$this).AddChild($child)
        $this.PerformLayout()
    }

    # Remove child and re-layout
    [void] RemoveChild([UIElement]$child) {
        ([UIElement]$this).RemoveChild($child)
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.Move($this.ContentX, $currentY)
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.Move($currentX, $this.ContentY)
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        # Calculate grid dimensions
        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            # Adjust size for last column/row
            $width = if ($col -eq ($cols - 1)) { 
                $this.ContentX + $this.ContentWidth - $x 
            } else { 
                $cellWidth 
            }
            $height = if ($row -eq ($rows - 1)) { 
                $this.ContentY + $this.ContentHeight - $y 
            } else { 
                $cellHeight 
            }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    # Set border style and update content bounds
    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    # Enable/disable border
    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    # Set title
    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    # Check if point is within content area
    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    # Get content bounds as hashtable
    [hashtable] GetContentBounds() {
        return @{
            X = $this.ContentX
            Y = $this.ContentY
            Width = $this.ContentWidth
            Height = $this.ContentHeight
        }
    }

    # Clear content area only
    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return }

        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    # Main render implementation
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }

        # Clear entire buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this._private_buffer.Clear($bgCell)

        # Draw border if enabled
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }

        # Fill content area
        $this.ClearContent()
    }

    # Override OnResize to update content bounds
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Handle focus for focusable panels
    [void] OnFocus() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Cyan
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Gray
            $this.RequestRedraw()
        }
    }

    # Find first focusable child
    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    # Get all focusable children (recursive)
    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        
        return $focusable
    }

    # Basic input handling - delegate to focused child
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # If this panel can focus and is focused, handle some basic navigation
        if ($this.CanFocus -and $this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        Set-ComponentFocus -Component $firstChild
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        Set-ComponentFocus -Component $firstChild
                        return $true
                    }
                }
            }
        }

        # Delegate to children
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }

        return $false
    }

    # String representation
    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}
#endregion

#region Specialized Panel Types

# Scrollable Panel - supports content larger than visible area
class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    # Constructor
    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    # Set virtual content size
    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        
        # Create virtual buffer if needed
        if ($width -gt 0 -and $height -gt 0) {
            $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        
        $this.RequestRedraw()
    }

    # Scroll to position
    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        
        $this.RequestRedraw()
    }

    # Scroll by delta
    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    # Handle scrolling input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }

        return ([Panel]$this).HandleInput($keyInfo)
    }

    # Render with scrolling support
    [void] OnRender() {
        # Render base panel
        ([Panel]$this).OnRender()

        # Render virtual content if available
        if ($null -ne $this._virtual_buffer) {
            # Create a sub-buffer view of the virtual content
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            
            # Blend visible content onto our buffer
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }

        # Draw scrollbars if enabled and needed
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    # Draw scrollbar indicators
    [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return }

        # Vertical scrollbar
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
        }

        # Horizontal scrollbar
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    # Get virtual content buffer for external drawing
    [TuiBuffer] GetVirtualBuffer() {
        return $this._virtual_buffer
    }
}

# Group Panel - collapsible panel with header
class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    # Toggle collapsed state
    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)  # Just header + border
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        
        # Update child visibility
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        
        $this.RequestRedraw()
    }

    # Handle collapse/expand input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }

        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        
        return $false
    }

    # Render with collapse indicator
    [void] OnRender() {
        ([Panel]$this).OnRender()

        # Draw collapse/expand indicator in title area
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            $this._private_buffer.SetCell(2, 0, $indicatorCell)
        }
    }
}
#endregion

# Export the Panel classes
Export-ModuleMember -Function @()


####\refactor_checkpoints\checkpoint_20250629_204807_pre-phase-a-complete\modules\dialog-system-class.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Base Dialog Class
class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    [int] $Width = 50
    [int] $Height = 10
    [int] $X
    [int] $Y
    [ConsoleColor] $BorderColor = [ConsoleColor]::Cyan
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [ConsoleColor] $MessageColor = [ConsoleColor]::Gray
    
    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    [void] Show() {
        # Calculate centered position
        $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
        $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 2)
        
        # Register with dialog manager
        $script:DialogState.CurrentDialog = $this
        Request-TuiRefresh
    }
    
    [void] Close() {
        $script:DialogState.CurrentDialog = $null
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        }
        Request-TuiRefresh
    }
    
    # Base render draws dialog frame
    hidden [void] _RenderContent() {
        # Draw dialog box
        Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height `
            -Title " $($this.Title) " -BorderColor $this.BorderColor
        
        # Draw message if present
        if (-not [string]::IsNullOrWhiteSpace($this.Message)) {
            $this.RenderMessage()
        }
        
        # Let derived classes render their specific content
        $this._RenderDialogContent()
    }
    
    hidden [void] RenderMessage() {
        $messageY = $this.Y + 2
        $messageX = $this.X + 2
        $maxWidth = $this.Width - 4
        
        $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
        foreach ($line in $wrappedLines) {
            if ($messageY -ge ($this.Y + $this.Height - 3)) { break }
            Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor $this.MessageColor
            $messageY++
        }
    }
    
    # Override in derived classes
    hidden [void] _RenderDialogContent() { }
    
    # Base input handling - ESC closes dialog
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.OnCancel()
        }
    }
    
    # Virtual methods for derived classes
    [void] OnConfirm() { $this.Close() }
    [void] OnCancel() { $this.Close() }
}

# Alert Dialog - Simple OK dialog
class AlertDialog : Dialog {
    [string] $ButtonText = "OK"
    
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 10
        $this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))
    }
    
    hidden [void] _RenderDialogContent() {
        # Render OK button
        $buttonY = $this.Y + $this.Height - 2
        $buttonText = "[ $($this.ButtonText) ]"
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
        
        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) { $this.OnConfirm() }
            ([ConsoleKey]::Spacebar) { $this.OnConfirm() }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
}

# Confirm Dialog - Yes/No dialog
class ConfirmDialog : Dialog {
    [scriptblock] $OnConfirmAction
    [scriptblock] $OnCancelAction
    [string[]] $Buttons = @("Yes", "No")
    [int] $SelectedButton = 0
    
    ConfirmDialog([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) : base("ConfirmDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.OnConfirmAction = $onConfirm
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render buttons
        $buttonY = $this.Y + $this.Height - 3
        $totalButtonWidth = ($this.Buttons.Count * 12) + (($this.Buttons.Count - 1) * 2)
        $buttonX = $this.X + [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        
        for ($i = 0; $i -lt $this.Buttons.Count; $i++) {
            $button = $this.Buttons[$i]
            $isSelected = ($i -eq $this.SelectedButton)
            $buttonText = if ($isSelected) { "[ $button ]" } else { "  $button  " }
            $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
            $buttonX += 14
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) { 
                $this.SelectedButton = [Math]::Max(0, $this.SelectedButton - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::RightArrow) { 
                $this.SelectedButton = [Math]::Min($this.Buttons.Count - 1, $this.SelectedButton + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Tab) { 
                $this.SelectedButton = ($this.SelectedButton + 1) % $this.Buttons.Count
                Request-TuiRefresh
            }
            ([ConsoleKey]::Enter) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Spacebar) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnConfirmAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnConfirm" -ScriptBlock $this.OnConfirmAction
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Input Dialog - Text input dialog
class InputDialog : Dialog {
    [string] $Prompt = ""
    [string] $InputValue = ""
    [string] $DefaultValue = ""
    [scriptblock] $OnSubmitAction
    [scriptblock] $OnCancelAction
    [int] $FocusedElement = 0  # 0=TextBox, 1=OK, 2=Cancel
    [int] $CursorPosition = 0
    
    InputDialog([string]$title, [string]$prompt, [scriptblock]$onSubmit, [scriptblock]$onCancel) : base("InputDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.OnSubmitAction = $onSubmit
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(70, [Math]::Max(50, $prompt.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render prompt
        $promptX = $this.X + 2
        $promptY = $this.Y + 2
        Write-BufferString -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor ([ConsoleColor]::White)
        
        # Render input box
        $inputY = $promptY + 2
        $inputWidth = $this.Width - 4
        $isFocused = ($this.FocusedElement -eq 0)
        $borderColor = if ($isFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::DarkGray }
        
        Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 -BorderColor $borderColor
        
        # Render input text
        $displayText = $this.InputValue
        if ($displayText.Length -gt ($inputWidth - 3)) {
            $displayText = $displayText.Substring(0, $inputWidth - 3)
        }
        Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText -ForegroundColor ([ConsoleColor]::White)
        
        # Show cursor when focused
        if ($isFocused -and $this.CursorPosition -le $displayText.Length) {
            Write-BufferString -X ($promptX + 1 + $this.CursorPosition) -Y ($inputY + 1) `
                -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
        }
        
        # Render buttons
        $buttonY = $this.Y + $this.Height - 2
        $buttonSpacing = 15
        $buttonsWidth = $buttonSpacing * 2
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonsWidth) / 2)
        
        # OK button
        $okFocused = ($this.FocusedElement -eq 1)
        $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
        $okColor = if ($okFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
        
        # Cancel button
        $cancelFocused = ($this.FocusedElement -eq 2)
        $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
        $cancelColor = if ($cancelFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Tab) {
                $direction = if ($key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                $this.FocusedElement = ($this.FocusedElement + $direction + 3) % 3
                Request-TuiRefresh
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
            default {
                switch ($this.FocusedElement) {
                    0 { # TextBox
                        switch ($key.Key) {
                            ([ConsoleKey]::Enter) { $this.OnConfirm() }
                            ([ConsoleKey]::Backspace) {
                                if ($this.InputValue.Length -gt 0 -and $this.CursorPosition -gt 0) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition - 1, 1)
                                    $this.CursorPosition--
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::Delete) {
                                if ($this.CursorPosition -lt $this.InputValue.Length) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition, 1)
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::LeftArrow) {
                                $this.CursorPosition = [Math]::Max(0, $this.CursorPosition - 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::RightArrow) {
                                $this.CursorPosition = [Math]::Min($this.InputValue.Length, $this.CursorPosition + 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::Home) {
                                $this.CursorPosition = 0
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::End) {
                                $this.CursorPosition = $this.InputValue.Length
                                Request-TuiRefresh
                            }
                            default {
                                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                                    $this.InputValue = $this.InputValue.Insert($this.CursorPosition, $key.KeyChar)
                                    $this.CursorPosition++
                                    Request-TuiRefresh
                                }
                            }
                        }
                    }
                    1 { # OK Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnConfirm()
                        }
                    }
                    2 { # Cancel Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnCancel()
                        }
                    }
                }
            }
        }
    }
    
    [void] SetDefaultValue([string]$value) {
        $this.InputValue = $value
        $this.DefaultValue = $value
        $this.CursorPosition = $value.Length
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSubmitAction) {
            $value = $this.InputValue
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnSubmit" -ScriptBlock {
                & $this.OnSubmitAction -Value $value
            }.GetNewClosure()
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Progress Dialog
class ProgressDialog : Dialog {
    [int] $PercentComplete = 0
    [bool] $ShowCancel = $false
    [bool] $IsCancelled = $false
    
    ProgressDialog([string]$title, [string]$message) : base("ProgressDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Width = 60
        $this.Height = 8
    }
    
    hidden [void] _RenderDialogContent() {
        # Render progress bar
        $barY = $this.Y + 4
        $barWidth = $this.Width - 4
        $filledWidth = [Math]::Floor($barWidth * ($this.PercentComplete / 100.0))
        
        # Draw bar background
        Write-BufferString -X ($this.X + 2) -Y $barY -Text ("─" * $barWidth) -ForegroundColor ([ConsoleColor]::DarkGray)
        
        # Draw filled portion
        if ($filledWidth -gt 0) {
            Write-BufferString -X ($this.X + 2) -Y $barY -Text ("█" * $filledWidth) -ForegroundColor ([ConsoleColor]::Green)
        }
        
        # Draw percentage
        $percentText = "$($this.PercentComplete)%"
        $percentX = $this.X + [Math]::Floor(($this.Width - $percentText.Length) / 2)
        Write-BufferString -X $percentX -Y $barY -Text $percentText -ForegroundColor ([ConsoleColor]::White)
        
        # Draw cancel button if enabled
        if ($this.ShowCancel) {
            $buttonY = $this.Y + $this.Height - 2
            $buttonText = if ($this.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
            $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
        }
    }
    
    [void] UpdateProgress([int]$percent, [string]$message) {
        $this.PercentComplete = [Math]::Min(100, [Math]::Max(0, $percent))
        if (-not [string]::IsNullOrWhiteSpace($message)) {
            $this.Message = $message
        }
        Request-TuiRefresh
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($this.ShowCancel -and -not $this.IsCancelled) {
            if ($key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsCancelled = $true
                Request-TuiRefresh
            }
        }
    }
}

# List Dialog
class ListDialog : Dialog {
    [string[]] $Items = @()
    [int] $SelectedIndex = 0
    [bool] $AllowMultiple = $false
    [System.Collections.Generic.HashSet[int]] $SelectedItems
    [scriptblock] $OnSelectAction
    [scriptblock] $OnCancelAction
    
    ListDialog([string]$title, [string]$prompt, [string[]]$items, [scriptblock]$onSelect, [scriptblock]$onCancel) : base("ListDialog") {
        $this.Title = $title
        $this.Message = $prompt
        $this.Items = $items
        $this.OnSelectAction = $onSelect
        $this.OnCancelAction = $onCancel
        $this.Width = 60
        $this.Height = [Math]::Min(20, $items.Count + 8)
        $this.SelectedItems = [System.Collections.Generic.HashSet[int]]::new()
    }
    
    hidden [void] _RenderDialogContent() {
        $listY = $this.Y + 4
        $listHeight = $this.Height - 7
        $listWidth = $this.Width - 4
        
        # Calculate visible range with scrolling
        $startIndex = [Math]::Max(0, $this.SelectedIndex - [Math]::Floor($listHeight / 2))
        $endIndex = [Math]::Min($this.Items.Count - 1, $startIndex + $listHeight - 1)
        
        # Render items
        for ($i = $startIndex; $i -le $endIndex; $i++) {
            $itemY = $listY + ($i - $startIndex)
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex)
            $isChecked = $this.SelectedItems.Contains($i)
            
            $prefix = if ($this.AllowMultiple) {
                if ($isChecked) { "[X] " } else { "[ ] " }
            } else { "" }
            
            $itemText = "$prefix$item"
            if ($itemText.Length -gt $listWidth - 2) {
                $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
            }
            
            $bgColor = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            $fgColor = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::Gray }
            
            # Clear the line first
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text (" " * ($listWidth - 2)) -BackgroundColor $bgColor
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text $itemText -ForegroundColor $fgColor -BackgroundColor $bgColor
        }
        
        # Render scrollbar if needed
        if ($this.Items.Count -gt $listHeight) {
            $scrollbarX = $this.X + $this.Width - 2
            $scrollbarHeight = $listHeight
            $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $this.Items.Count))
            $thumbPos = [Math]::Floor($scrollbarHeight * $this.SelectedIndex / $this.Items.Count)
            
            for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char -ForegroundColor ([ConsoleColor]::DarkGray)
            }
        }
        
        # Render buttons for multi-select
        if ($this.AllowMultiple) {
            $buttonY = $this.Y + $this.Height - 2
            $okText = "[ OK ]"
            $cancelText = "[ Cancel ]"
            $buttonSpacing = 15
            $totalWidth = 30
            $startX = $this.X + [Math]::Floor(($this.Width - $totalWidth) / 2)
            
            Write-BufferString -X $startX -Y $buttonY -Text $okText -ForegroundColor ([ConsoleColor]::Green)
            Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor ([ConsoleColor]::Gray)
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::DownArrow) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Spacebar) {
                if ($this.AllowMultiple) {
                    if ($this.SelectedItems.Contains($this.SelectedIndex)) {
                        [void]$this.SelectedItems.Remove($this.SelectedIndex)
                    } else {
                        [void]$this.SelectedItems.Add($this.SelectedIndex)
                    }
                    Request-TuiRefresh
                }
            }
            ([ConsoleKey]::Enter) {
                $this.OnConfirm()
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
            }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSelectAction) {
            if ($this.AllowMultiple) {
                $selectedValues = @($this.SelectedItems | ForEach-Object { $this.Items[$_] })
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selectedValues
                }.GetNewClosure()
            } else {
                $selected = $this.Items[$this.SelectedIndex]
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selected
                }.GetNewClosure()
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ListDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Dialog State Management
$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

# Public API Functions
function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        # Subscribe to dialog events
        Subscribe-Event -EventName "Confirm.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-ConfirmDialog -Title $params.Title -Message $params.Message `
                -OnConfirm $params.OnConfirm -OnCancel $params.OnCancel
        }
        
        Subscribe-Event -EventName "Alert.Show" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-AlertDialog -Title $params.Title -Message $params.Message
        }
        
        Subscribe-Event -EventName "Input.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-InputDialog -Title $params.Title -Prompt $params.Prompt `
                -DefaultValue $params.DefaultValue -OnSubmit $params.OnSubmit -OnCancel $params.OnCancel
        }
        
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

function Show-AlertDialog {
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock {
        $dialog = [AlertDialog]::new($Title, $Message)
        $dialog.Show()
    }
}

function Show-ConfirmDialog {
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock {
        $dialog = [ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)
        $dialog.Show()
    }
}

function Show-InputDialog {
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock {
        $dialog = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel)
        if ($DefaultValue) {
            $dialog.SetDefaultValue($DefaultValue)
        }
        $dialog.Show()
    }
}

function Show-ProgressDialog {
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock {
        $dialog = [ProgressDialog]::new($Title, $Message)
        $dialog.PercentComplete = $PercentComplete
        $dialog.ShowCancel = $ShowCancel
        $dialog.Show()
        return $dialog
    }
}

function Show-ListDialog {
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [string[]]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock {
        $dialog = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel)
        $dialog.AllowMultiple = $AllowMultiple
        $dialog.Show()
    }
}

function Close-TuiDialog {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.CurrentDialog.Close()
        }
    }
}

Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-AlertDialog',
    'Show-ConfirmDialog', 
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Close-TuiDialog'
) -Variable @()



####\refactor_checkpoints\checkpoint_20250629_204807_pre-phase-a-complete\modules\tui-engine.psm1
# TUI Engine v5.1 - NCurses Compositor Edition
# Implements NCurses-style compositor with private buffers and TuiCell rendering

using module .\components\tui-primitives.psm1

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    CompositorBuffer = $null    # AI: NEW - Master compositor buffer (TuiBuffer)
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
    CompositorMode  = $true     # AI: NEW - Enable NCurses-style rendering
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.1 (NCurses Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        # AI: ENHANCED - Create both legacy buffers and new TuiBuffer compositor
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        
        # Initialize legacy buffers for compatibility
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height; CompositorMode = $global:TuiState.CompositorMode }
        Write-Log -Level Info -Message "TUI Engine v5.1 initialized successfully (Compositor Mode: $($global:TuiState.CompositorMode))"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent) {
        try { 
            # AI: ENHANCED - Better class detection for UIElement-based components
            if ($focusedComponent -is [UIElement]) {
                # New UIElement-based component
                $focusedComponent.HandleInput($keyInfo)
            }
            elseif ($focusedComponent.PSObject.TypeNames -contains 'UIElement' -or $focusedComponent.GetType().IsSubclassOf([UIElement])) {
                # Class-based component (legacy detection)
                if ($focusedComponent.PSObject.Methods.Name -contains 'HandleInput') {
                    $focusedComponent.HandleInput($keyInfo)
                }
            }
            elseif ($focusedComponent.HandleInput) {
                # Functional component with HandleInput scriptblock
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return }
            }
        } catch { 
            Write-Warning "Component input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for component '$($focusedComponent.Name)': $_"
        }
    }
    
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            # AI: ENHANCED - Support for UIElement-based screens
            if ($currentScreen -is [UIElement]) {
                # New UIElement-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen -is [Screen]) {
                # Legacy class-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen.HandleInput) {
                # Hashtable/functional screen - use scriptblock invocation
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { Stop-TuiEngine }
                }
            }
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([object]$InitialScreen)  # AI: Accept both UIElement and hashtable screens
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

# AI: REWRITTEN - NCurses Compositor Render-Frame
function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        if ($global:TuiState.CompositorMode -and $null -ne $global:TuiState.CompositorBuffer) {
            # AI: NEW - NCurses-style compositor rendering
            Render-FrameCompositor
        } else {
            # AI: LEGACY - Fall back to old rendering for compatibility
            Render-FrameLegacy
        }
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    # AI: NEW - NCurses-style compositor rendering pipeline
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                if ($global:TuiState.CurrentScreen -is [UIElement]) {
                    # New UIElement-based screen - render to its private buffer
                    $global:TuiState.CurrentScreen.Render()
                    
                    # Composite screen buffer onto master compositor
                    $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                    if ($null -ne $screenBuffer) {
                        $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                    }
                } else {
                    # Legacy screen - render directly (will be deprecated)
                    $global:TuiState.CurrentScreen.Render()
                }
            }
        }
        
        # 3. Render dialogs on top
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog -is [UIElement]) {
                    # New UIElement-based dialog
                    $dialog.Render()
                    $dialogBuffer = $dialog.GetBuffer()
                    if ($null -ne $dialogBuffer) {
                        $pos = $dialog.GetAbsolutePosition()
                        $global:TuiState.CompositorBuffer.BlendBuffer($dialogBuffer, $pos.X, $pos.Y)
                    }
                } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                    # Class-based dialog with Render() method
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    # Functional/hashtable dialog with Render scriptblock
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
        # Fall back to legacy rendering
        Render-FrameLegacy
    }
}

function Render-CompositorToConsole {
    # AI: NEW - Convert TuiBuffer to optimized console output
    $outputBuilder = [System.Text.StringBuilder]::new(20000)
    $lastFG = -1
    $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1
    
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $rowChanged = $false
            $rowOutput = [System.Text.StringBuilder]::new()
            
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $newCell = $global:TuiState.CompositorBuffer.GetCell($x, $y)
                $oldLegacyCell = $global:TuiState.FrontBuffer[$y, $x]
                
                # Convert TuiCell to legacy format for comparison
                $newLegacyCell = $newCell.ToLegacyFormat()
                
                # Check if cell changed
                if ($forceFullRender -or 
                    $newLegacyCell.Char -ne $oldLegacyCell.Char -or
                    $newLegacyCell.FG -ne $oldLegacyCell.FG -or
                    $newLegacyCell.BG -ne $oldLegacyCell.BG) {
                    
                    $rowChanged = $true
                    
                    # Update front buffer
                    $global:TuiState.FrontBuffer[$y, $x] = $newLegacyCell
                    
                    # Add color codes if needed
                    if ($newLegacyCell.FG -ne $lastFG -or $newLegacyCell.BG -ne $lastBG) {
                        $fgCode = Get-AnsiColorCode $newLegacyCell.FG
                        $bgCode = Get-AnsiColorCode $newLegacyCell.BG -IsBackground $true
                        [void]$rowOutput.Append("`e[${fgCode};${bgCode}m")
                        $lastFG = $newLegacyCell.FG
                        $lastBG = $newLegacyCell.BG
                    }
                    
                    [void]$rowOutput.Append($newLegacyCell.Char)
                } else {
                    # Cell unchanged - add placeholder for position tracking
                    [void]$rowOutput.Append($null)
                }
            }
            
            # Output the row if it changed
            if ($rowChanged) {
                [void]$outputBuilder.Append("`e[$($y + 1);1H")
                $rowStr = $rowOutput.ToString() -replace [char]0, ''
                [void]$outputBuilder.Append($rowStr)
            }
        }
        
        [void]$outputBuilder.Append("`e[0m")
        
        if ($outputBuilder.Length -gt 10) {  # Only output if there are substantial changes
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Render-FrameLegacy {
    # AI: LEGACY - Original rendering code for compatibility
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component $global:TuiState.CurrentScreen.Name -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
            }
        }
        
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog.GetType().IsSubclassOf([UIElement]) -or $dialog -is [UIElement]) {
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        Render-BufferOptimized
        
    } catch {
        Write-Log -Level Error -Message "Legacy rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    # AI: ENHANCED - Accept both UIElement and legacy screen objects
    param([object]$Screen)
    if (-not $Screen) { return }
    
    $screenName = if ($Screen -is [UIElement]) { $Screen.Name } elseif ($Screen -is [Screen]) { $Screen.Name } else { $Screen.Name }
    Write-Log -Level Debug -Message "Pushing screen: $screenName"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($global:TuiState.CurrentScreen) {
            # Handle exit for current screen
            if ($global:TuiState.CurrentScreen -is [UIElement]) {
                # New UIElement-based screen
                # No explicit OnExit method - handled by framework
            } elseif ($global:TuiState.CurrentScreen -is [Screen]) {
                # Legacy class-based screen
                $global:TuiState.CurrentScreen.OnExit()
            } elseif ($global:TuiState.CurrentScreen.OnExit) {
                # Functional screen
                $global:TuiState.CurrentScreen.OnExit.Invoke()
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # Initialize new screen
        if ($Screen -is [UIElement]) {
            # New UIElement-based screen - ensure it's sized to fit screen
            if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) {  # Default size
                $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            }
            # Trigger initial render
            $Screen.RequestRedraw()
        } elseif ($Screen -is [Screen]) {
            # Legacy class-based screen
            $Screen.OnEnter()
        } elseif ($Screen.Init) { 
            # Functional screen
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $screenName }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$screenName': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $global:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering - Legacy Support
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:TuiState.BufferWidth) { break }
        if ($currentX -ge 0) { $global:TuiState.BackBuffer[$Y, $currentX] = @{ Char = $char; FG = $ForegroundColor; BG = $BackgroundColor } }
        $currentX++
    }
}

function Write-BufferBox {
    param([int]$X, [int]$Y, [int]$Width, [int]$Height, [string]$BorderStyle = "Single", [ConsoleColor]$BorderColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, [string]$Title = "")
    $borders = Get-BorderChars -Style $BorderStyle
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    if ($Title) {
        $titleText = " $Title "; if ($titleText.Length -gt ($Width-2)) { $titleText = " $($Title.Substring(0,[Math]::Max(0,$Width-5)))... " }
        Write-BufferString -X ($X + [Math]::Floor(($Width - $titleText.Length) / 2)) -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function Render-BufferOptimized {
    $outputBuilder = [System.Text.StringBuilder]::new(20000); $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 0
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $backCell = $global:TuiState.BackBuffer[$y, $x]; $frontCell = $global:TuiState.FrontBuffer[$y, $x]
                if (-not $forceFullRender -and $backCell.Char -eq $frontCell.Char -and $backCell.FG -eq $frontCell.FG -and $backCell.BG -eq $frontCell.BG) { continue }
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) { $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null }
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG; $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null; $lastFG = $backCell.FG; $lastBG = $backCell.BG
                }
                $outputBuilder.Append($backCell.Char) | Out-Null
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = $backCell.Char; FG = $backCell.FG; BG = $backCell.BG }
            }
        }
        $outputBuilder.Append("`e[0m") | Out-Null
        if ($outputBuilder.Length -gt 0) { [Console]::Write($outputBuilder.ToString()) }
    } catch { Write-Warning "Render error: $_" }
}
#endregion

#region Component System - Enhanced for UIElement
function Initialize-ComponentSystem { $global:TuiState.Components = @(); $global:TuiState.FocusedComponent = $null }

function Register-Component { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    $global:TuiState.Components += $Component
    
    # Initialize component based on type
    if ($Component -is [UIElement]) {
        # New UIElement-based component - no explicit init needed
        Write-Log -Level Debug -Message "Registered UIElement component: $($Component.Name)"
    } elseif ($Component.Init) { 
        try { & $Component.Init -self $Component } catch { Write-Warning "Component init error: $_" } 
    }
    return $Component 
}

function Set-ComponentFocus { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) { return }
    
    # Blur current component
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    
    # Set new focused component
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    
    # Focus new component
    if ($null -ne $Component) {
        if ($Component -is [UIElement]) {
            $Component.OnFocus()
        } else {
            $Component.OnFocus?.Invoke()
        }
    }
    
    Request-TuiRefresh 
}

function Clear-ComponentFocus { 
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    $global:TuiState.FocusedComponent = $null
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $null }
    Request-TuiRefresh 
}

# AI: ENHANCED - Support UIElement focusable detection
function Get-NextFocusableComponent { 
    param([object]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = @()
    
    function Find-Focusable([object]$Comp) { 
        if ($Comp -is [UIElement]) {
            # New UIElement-based component
            if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
                $focusableComponents += $Comp
            }
            # Check children
            foreach ($child in $Comp.Children) {
                Find-Focusable $child
            }
        } else {
            # Legacy component
            if ($Comp.IsFocusable -eq $true -and $Comp.Visible -ne $false) { 
                $focusableComponents += $Comp 
            }
            if ($Comp.Children) { 
                foreach ($c in $Comp.Children) { Find-Focusable $c } 
            }
        }
    }
    
    # Find focusable components in current screen
    if ($global:TuiState.CurrentScreen -is [UIElement]) {
        Find-Focusable $global:TuiState.CurrentScreen
    } elseif ($global:TuiState.CurrentScreen.Components) { 
        foreach ($c in $global:TuiState.CurrentScreen.Components.Values) { Find-Focusable $c } 
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by tab index and position
    $sorted = $focusableComponents | Sort-Object { 
        if ($_ -is [UIElement]) {
            $_.TabIndex * 10000 + $_.Y * 100 + $_.X
        } else {
            ($_.TabIndex ?? 0) * 10000 + ($_.Y ?? 0) * 100 + ($_.X ?? 0)
        }
    }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Handle-TabNavigation { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

# AI: LEGACY - Helper functions maintained for compatibility
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Move-Focus { param([bool]$Reverse = $false); Handle-TabNavigation -Reverse $Reverse }

function Get-CurrentDialog {
    try {
        if (Get-Module -Name 'dialog-system-class' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system-class') { $script:DialogState.CurrentDialog }
        } elseif (Get-Module -Name 'dialog-system' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system') { $script:DialogState.CurrentDialog }
        }
    } catch {
        Write-Log -Level Warning -Message "Error accessing dialog system: $_"
    }
    return $null
}

function Handle-DialogInput {
    param([System.ConsoleKeyInfo]$Key)
    try {
        $dialog = Get-CurrentDialog
        if ($dialog) {
            if ($dialog -is [UIElement]) {
                # New UIElement-based dialog
                return $dialog.HandleInput($Key)
            } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                # Legacy class-based dialog
                $dialog.HandleInput($Key)
                return $true
            } elseif ($dialog -is [hashtable] -and $dialog.HandleInput) {
                # Functional dialog
                return & $dialog.HandleInput -self $dialog -Key $Key
            }
        }
    } catch {
        Write-Log -Level Warning -Message "Error handling dialog input: $_"
    }
    return $false
}

function Update-DialogSystem {
    # Dialog system handles its own updates if loaded
}

function Stop-AllTuiAsyncJobs {
    Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)"
}
#endregion

#region Layout Management & Utilities
function Initialize-LayoutEngines { $global:TuiState.Layouts = @{} }
function Get-BorderChars { param([string]$Style); $styles = @{ Single=@{TopLeft='┌';TopRight='┐';BottomLeft='└';BottomRight='┘';Horizontal='─';Vertical='│'}; Double=@{TopLeft='╔';TopRight='╗';BottomLeft='╚';BottomRight='╝';Horizontal='═';Vertical='║'}; Rounded=@{TopLeft='╭';TopRight='╮';BottomLeft='╰';BottomRight='╯';Horizontal='─';Vertical='│'} }; return $styles[$Style] ?? $styles.Single }
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Get-WordWrappedLines { param([string]$Text, [int]$MaxWidth); if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }; $lines = @(); $words = $Text -split '\s+'; $sb = [System.Text.StringBuilder]::new(); foreach ($word in $words) { if ($sb.Length -eq 0) { [void]$sb.Append($word) } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) { [void]$sb.Append(' ').Append($word) } else { $lines += $sb.ToString(); [void]$sb.Clear().Append($word) } }; if ($sb.Length -gt 0) { $lines += $sb.ToString() }; return $lines }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }

# AI: NEW - Compositor helper functions
function Get-ThemeColor {
    param([string]$ColorName)
    # Simple theme color mapping - can be enhanced later
    $themeColors = @{
        Background = [ConsoleColor]::Black
        Foreground = [ConsoleColor]::White
        Border = [ConsoleColor]::Gray
        Focus = [ConsoleColor]::Cyan
        Highlight = [ConsoleColor]::Yellow
    }
    return $themeColors[$ColorName] ?? [ConsoleColor]::Black
}
#endregion

Export-ModuleMember -Function 'Initialize-TuiEngine', 'Start-TuiLoop', 'Stop-TuiEngine', 'Push-Screen', 'Pop-Screen', 'Request-TuiRefresh', 'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer', 'Get-BorderChars', 'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 'Get-NextFocusableComponent', 'Handle-TabNavigation', 'Get-WordWrappedLines', 'Get-FocusedComponent', 'Move-Focus', 'Get-CurrentDialog', 'Handle-DialogInput', 'Update-DialogSystem', 'Stop-AllTuiAsyncJobs', 'Get-ThemeColor' -Variable 'TuiState'


####\refactor_checkpoints\checkpoint_20250629_204807_pre-phase-a-complete\screens\task-list-screen.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Task List Screen
# Displays and manages tasks.
# ==============================================================================

# AI: CRITICAL FIX - Import models module for TaskStatus enum and other types
using module '..\modules\models.psm1'

# AI: FIX - Use relative paths for better portability
using module '..\components\ui-classes.psm1'
using module '..\layout\panels-class.psm1'
using module '..\components\advanced-data-components.psm1'
using module '..\modules\dialog-system-class.psm1'

class TaskListScreen : Screen {
    # --- UI Components ---
    [BorderPanel] $MainPanel
    [Table] $TaskTable
    [ContentPanel] $NavPanel

    # --- State ---
    [string] $FilterStatus = "All"

    TaskListScreen([hashtable]$services) : base("TaskListScreen", $services) { }

    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # --- Panel Setup ---
            $this.MainPanel = [BorderPanel]::new("TaskListMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "Task List"
            $this.AddPanel($this.MainPanel)

            # --- Task Table ---
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.SetColumns(@(
                [TableColumn]::new("Title", "Task Title", 50),
                [TableColumn]::new("Status", "Status", 15),
                [TableColumn]::new("Priority", "Priority", 12),
                [TableColumn]::new("DueDate", "Due Date", 15)
            ))
            
            $tableContainer = [BorderPanel]::new("TableContainer", 1, 1, 118, 24)
            $tableContainer.ShowBorder = $false
            $tableContainer.AddChild($this.TaskTable)
            $this.MainPanel.AddChild($tableContainer)
            
            # --- Navigation Panel ---
            $this.NavPanel = [ContentPanel]::new("NavPanel", 1, 26, 118, 3)
            $this.MainPanel.AddChild($this.NavPanel)
            
            # --- Event Subscriptions & Data Load ---
            $this.SubscribeToEvent("Tasks.Changed", { $this.RefreshData() })
            $this.RefreshData()
        }
    }

    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            $allTasks = @($this.Services.DataManager.GetTasks())
            $filteredTasks = switch ($this.FilterStatus) {
                "Active" { $allTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed } }
                "Completed" { $allTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed } }
                default { $allTasks }
            }
            $this.TaskTable.SetData($filteredTasks)
            $this.UpdateNavText()
        }
    }

    hidden [void] UpdateNavText() {
        $navContent = @(
            "[N]ew | [E]dit | [D]elete | [Space]Toggle | [F]ilter: $($this.FilterStatus) | [Esc]Back"
        )
        $this.NavPanel.SetContent($navContent)
    }

    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) { $this.TaskTable.SelectPrevious() }
                ([ConsoleKey]::DownArrow) { $this.TaskTable.SelectNext() }
                ([ConsoleKey]::Spacebar) { $this.ToggleSelectedTask() }
                ([ConsoleKey]::Escape) { $this.Services.Navigation.PopScreen() }
                default {
                    switch ($key.KeyChar.ToString().ToUpper()) {
                        'N' { $this.ShowNewTaskDialog() }
                        'E' { $this.EditSelectedTask() }
                        'D' { $this.DeleteSelectedTask() }
                        'F' { $this.CycleFilter() }
                    }
                }
            }
        }
    }
    
    hidden [void] ToggleSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            # AI: FIX - TaskStatus enum should now be available from models.psm1 import
            if ($task.Status -eq [TaskStatus]::Completed) {
                $task.Status = [TaskStatus]::Pending
            } else {
                $task.Complete()
            }
            $this.Services.DataManager.UpdateTask($task)
        }
    }

    hidden [void] ShowNewTaskDialog() {
        # AI: FIX - Implemented new task dialog functionality
        Write-Log -Level Info -Message "New task dialog requested"
        
        # AI: FIX - Capture $this context for closure
        $dataManager = $this.Services.DataManager
        $refreshCallback = { $this.RefreshData() }.GetNewClosure()
        
        # Use the input dialog from dialog system
        Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {
            param($Value)
            if (-not [string]::IsNullOrWhiteSpace($Value)) {
                $newTask = $dataManager.AddTask($Value, "", [TaskPriority]::Medium, "General")
                Write-Log -Level Info -Message "Created new task: $($newTask.Title)"
                & $refreshCallback
            }
        }
    }

    hidden [void] EditSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Edit task requested for: $($task.Title)"
        }
    }

    hidden [void] DeleteSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Delete task requested for: $($task.Title)"
        }
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\refactor_checkpoints\checkpoint_20250629_210720_phase-1-complete\components\advanced-data-components.psm1
# Advanced Data Components Module for PMC Terminal v5
# Enhanced data display components with sorting, filtering, and pagination

using namespace System.Text
using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Simple Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

class Table : Component {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    
    Table([string]$name) : base($name) {
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        # AI: FIX - Explicit array initialization
        $this.Data = @()
        $this.SelectedIndex = 0
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
    }
    
    [void] SetData([object[]]$data) {
        # AI: FIX - Defensive array initialization
        $this.Data = if ($null -eq $data) { @() } else { @($data) }
        # AI: FIX - Safe array count check
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -ge $dataCount) {
            $this.SelectedIndex = [Math]::Max(0, $dataCount - 1)
        }
    }
    
    [void] SelectNext() {
        # AI: FIX - Safe array count check
        $dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -lt ($dataCount - 1)) {
            $this.SelectedIndex++
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
        }
    }
    
    [object] GetSelectedItem() {
        # AI: FIX - Safe array access with null checking
        if ($null -eq $this.Data) { return $null }
        
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        
        if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {
            return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }
        }
        return $null
    }
    
    hidden [void] _RenderContent() {
        # AI: Render table to buffer using Write-BufferString
        if (-not (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue)) {
            return # Buffer functions not available
        }
        
        # AI: FIX - Get render position from parent panel if available
        $renderX = 0
        $renderY = 0
        $maxWidth = 120  # Default max width
        
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X
            $renderY = $contentArea.Y
            $maxWidth = $contentArea.Width
        }
        
        $currentY = $renderY
        
        # Header
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            $headerLine = ""
            foreach ($col in $this.Columns) {
                $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                $headerLine += $headerText + " "
            }
            # AI: FIX - Trim header to max width
            if ($headerLine.TrimEnd().Length -gt $maxWidth) {
                $headerLine = $headerLine.Substring(0, $maxWidth)
            }
            Write-BufferString -X $renderX -Y $currentY -Text $headerLine.TrimEnd() -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
            $currentY++
            Write-BufferString -X $renderX -Y $currentY -Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $maxWidth)) -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            $currentY++
        }
        
        # AI: FIX - Safe data array handling
        $dataToRender = @()
        if ($null -ne $this.Data) {
            $dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }
        }
        
        # Data rows
        for ($i = 0; $i -lt $dataToRender.Count; $i++) {
            $row = $dataToRender[$i]
            if ($null -eq $row) { continue }
            
            $rowLine = ""
            $isSelected = ($i -eq $this.SelectedIndex)
            
            foreach ($col in $this.Columns) {
                $cellValue = ""
                if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                    $cellValue = $row[$col.Key]?.ToString() ?? ""
                } elseif ($row.PSObject.Properties[$col.Key]) {
                    $cellValue = $row.($col.Key)?.ToString() ?? ""
                }
                
                $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                $rowLine += $cellText + " "
            }
            
            $finalLine = $rowLine.TrimEnd()
            if ($isSelected) {
                $finalLine = "> $finalLine"
            } else {
                $finalLine = "  $finalLine"
            }
            
            $fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
            $bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            # AI: FIX - Ensure line doesn't exceed parent bounds
            if ($finalLine.Length -gt $maxWidth) {
                $finalLine = $finalLine.Substring(0, $maxWidth)
            }
            Write-BufferString -X $renderX -Y $currentY -Text $finalLine -ForegroundColor $fg -BackgroundColor $bg
            $currentY++
        }
        
        if ($dataToRender.Count -eq 0) {
            Write-BufferString -X $renderX -Y $currentY -Text "  No data to display" -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
        }
    }
}

#endregion

#region Advanced Data Table Class

class DataTableComponent : UIElement {
    # ... (class content is unchanged) ...
    [hashtable[]] $Data = @()
    [hashtable[]] $Columns = @()
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 80
    [int] $Height = 20
    [string] $Title = "Data Table"
    [bool] $ShowBorder = $true
    [bool] $IsFocusable = $true
    [int] $SelectedRow = 0
    [int] $ScrollOffset = 0
    [string] $SortColumn
    [string] $SortDirection = "Ascending"
    [string] $FilterText = ""
    [string] $FilterColumn
    [int] $PageSize = 0  # 0 = auto-calculate
    [int] $CurrentPage = 0
    [bool] $ShowHeader = $true
    [bool] $ShowFooter = $true
    [bool] $ShowRowNumbers = $false
    [bool] $AllowSort = $true
    [bool] $AllowFilter = $true
    [bool] $AllowSelection = $true
    [bool] $MultiSelect = $false
    [int[]] $SelectedRows = @()
    [hashtable[]] $FilteredData = @()
    [hashtable[]] $ProcessedData = @()
    [bool] $FilterMode = $false
    hidden [int] $_lastRenderedWidth = 0
    hidden [int] $_lastRenderedHeight = 0
    
    # Event handlers
    [scriptblock] $OnRowSelect
    [scriptblock] $OnSelectionChange
    
    DataTableComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    DataTableComponent([string]$name, [hashtable[]]$data, [hashtable[]]$columns) : base($name) {
        $this.IsFocusable = $true
        $this.Data = $data
        $this.Columns = $columns
        $this.ProcessData()
    }
    
    [void] ProcessData() {
        Invoke-WithErrorHandling -Component "$($this.Name).ProcessData" -Context "Processing table data" -ScriptBlock {
            # Filter data
            if ([string]::IsNullOrWhiteSpace($this.FilterText)) {
                $this.FilteredData = $this.Data
            } else {
                if ($this.FilterColumn) {
                    # Filter specific column
                    $this.FilteredData = @($this.Data | Where-Object {
                        $value = $_."$($this.FilterColumn)"
                        $value -and $value.ToString() -like "*$($this.FilterText)*"
                    })
                } else {
                    # Filter all columns
                    $this.FilteredData = @($this.Data | Where-Object {
                        $row = $_
                        $matched = $false
                        foreach ($col in $this.Columns) {
                            if ($col.Filterable -ne $false) {
                                $value = $row."$($col.Name)"
                                if ($value -and $value.ToString() -like "*$($this.FilterText)*") {
                                    $matched = $true
                                    break
                                }
                            }
                        }
                        $matched
                    })
                }
            }
            
            # Sort data
            if ($this.SortColumn -and $this.AllowSort) {
                $this.ProcessedData = $this.FilteredData | Sort-Object -Property $this.SortColumn -Descending:($this.SortDirection -eq "Descending")
            } else {
                $this.ProcessedData = $this.FilteredData
            }
            
            # Reset selection if needed
            if ($this.SelectedRow -ge $this.ProcessedData.Count) {
                $this.SelectedRow = [Math]::Max(0, $this.ProcessedData.Count - 1)
            }
            
            # Calculate page size if auto
            if ($this.PageSize -eq 0) {
                $headerLines = $this.ShowHeader ? 3 : 0
                $footerLines = $this.ShowFooter ? 2 : 0
                $filterLines = $this.AllowFilter ? 2 : 0
                $borderAdjust = $this.ShowBorder ? 2 : 0
                $calculatedPageSize = $this.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
                $this.PageSize = [Math]::Max(1, $calculatedPageSize)
            }
            
            # Adjust current page
            $totalPages = [Math]::Ceiling($this.ProcessedData.Count / [Math]::Max(1, $this.PageSize))
            if ($this.CurrentPage -ge $totalPages) {
                $this.CurrentPage = [Math]::Max(0, $totalPages - 1)
            }
        }
    }
    
    [hashtable] GetContentBounds() {
        $borderOffset = $this.ShowBorder ? 1 : 0
        return @{
            X = $this.X + $borderOffset
            Y = $this.Y + $borderOffset
            Width = $this.Width - (2 * $borderOffset)
            Height = $this.Height - (2 * $borderOffset)
        }
    }
    
    hidden [void] _RenderContent() {
        # AI: TEMPORARY - Complex table rendering needs to be rewritten for buffer-based system
        # This is a placeholder until proper buffer rendering is implemented
        if (-not (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue)) {
            return # Buffer functions not available
        }
        
        # Simple placeholder rendering
        Write-BufferString -X ($this.X + 1) -Y ($this.Y + 1) -Text "[DataTable: $($this.Title)]" -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
        
        return # TODO: Implement full buffer-based table rendering
        
        # ORIGINAL COMPLEX RENDERING CODE (commented out for now):
        $renderedContent = [StringBuilder]::new()
        
        # Force ProcessData if dimensions changed
        if ($this._lastRenderedWidth -ne $this.Width -or $this._lastRenderedHeight -ne $this.Height) {
            $this.ProcessData()
            $this._lastRenderedWidth = $this.Width
            $this._lastRenderedHeight = $this.Height
        }
        
        # Calculate content area based on border settings
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        $contentHeight = $this.Height

        if ($this.ShowBorder) {
            $borderColor = ($this.IsFocusable -and $this.IsFocused) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
            
            [void]$renderedContent.Append($this.MoveCursor($this.X, $this.Y))
            [void]$renderedContent.Append($this.SetColor($borderColor))
            [void]$renderedContent.Append($this.RenderBorder($this.Title))
            
            # Adjust content area for border
            $contentX = $this.X + 1
            $contentY = $this.Y + 1
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
        }
        
        $currentY = $contentY
        
        # Filter bar
        if ($this.AllowFilter) {
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::White))
            [void]$renderedContent.Append("Filter: ")
            
            $filterDisplayText = $this.FilterText ? $this.FilterText : "Type to filter..."
            $filterColor = $this.FilterText ? [ConsoleColor]::Yellow : [ConsoleColor]::DarkGray
            [void]$renderedContent.Append($this.SetColor($filterColor))
            [void]$renderedContent.Append($filterDisplayText)
            
            $currentY += 2
        }
        
        # Calculate column widths
        $totalDefinedWidth = ($this.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum ?? 0
        $flexColumns = @($this.Columns | Where-Object { -not $_.Width })
        $columnSeparators = $this.Columns.Count -gt 1 ? $this.Columns.Count - 1 : 0
        $rowNumberWidth = $this.ShowRowNumbers ? 5 : 0
        $remainingWidth = $contentWidth - $totalDefinedWidth - $rowNumberWidth - $columnSeparators
        
        $flexWidth = ($flexColumns.Count -gt 0) ? [Math]::Floor($remainingWidth / $flexColumns.Count) : 0
        
        # Assign calculated widths
        foreach ($col in $this.Columns) {
            $col.CalculatedWidth = $col.Width ?? [Math]::Max(5, $flexWidth)
        }
        
        # Header
        if ($this.ShowHeader) {
            $headerX = $contentX
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append("#".PadRight(4))
                $headerX += 5
            }
            
            foreach ($col in $this.Columns) {
                $headerText = $col.Header ?? $col.Name
                $columnWidth = $col.CalculatedWidth
                
                if ($this.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $this.SortColumn) {
                    $sortIndicator = ($this.SortDirection -eq "Ascending") ? "▲" : "▼"
                    $headerText = "$headerText $sortIndicator"
                }
                
                if ($headerText.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $headerText = $headerText.Substring(0, $maxLength) + "..."
                }
                
                $alignedText = switch ($col.Align) {
                    "Right" { $headerText.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $headerText.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $headerText + " " * $rightPad
                    }
                    default { $headerText.PadRight($columnWidth) }
                }
                
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append($alignedText)
                
                $headerX += $columnWidth + 1
            }
            
            $currentY++
            
            [void]$renderedContent.Append($this.MoveCursor($contentX, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append("─" * $contentWidth)
            $currentY++
        }
        
        # Data rows
        $dataToRender = ($this.ProcessedData.Count -eq 0 -and $this.Data.Count -gt 0) ? $this.Data : $this.ProcessedData
        
        $startIdx = $this.CurrentPage * $this.PageSize
        $endIdx = [Math]::Min($startIdx + $this.PageSize - 1, $dataToRender.Count - 1)
        
        for ($i = $startIdx; $i -le $endIdx; $i++) {
            $row = $dataToRender[$i]
            $rowX = $contentX
            
            $isSelected = $this.MultiSelect ? ($this.SelectedRows -contains $i) : ($i -eq $this.SelectedRow)
            
            $rowBg = $isSelected ? [ConsoleColor]::Cyan : [ConsoleColor]::Black
            $rowFg = $isSelected ? [ConsoleColor]::Black : [ConsoleColor]::White
            
            if ($isSelected) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(" " * $contentWidth)
            }
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(($i + 1).ToString().PadRight(4))
                $rowX += 5
            }
            
            foreach ($col in $this.Columns) {
                $value = $row."$($col.Name)"
                $columnWidth = $col.CalculatedWidth
                
                $displayValue = if ($col.Format -and $value) { & $col.Format $value } else { "$($value)" }
                
                if ($displayValue.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $displayValue = ($maxLength -le 0) ? "..." : ($displayValue.Substring(0, $maxLength) + "...")
                }
                
                $alignedValue = switch ($col.Align) {
                    "Right" { $displayValue.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $displayValue.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $displayValue + " " * $rightPad
                    }
                    default { $displayValue.PadRight($columnWidth) }
                }
                
                $cellFg = if ($col.Color -and -not $isSelected) {
                    Get-ThemeColor (& $col.Color $value $row)
                } else {
                    $rowFg
                }
                
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor($cellFg))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append($alignedValue)
                
                $rowX += $columnWidth + 1
            }
            
            $currentY++
        }
        
        # Empty state
        if ($dataToRender.Count -eq 0) {
            $emptyMessage = $this.FilterText ? "No results match the filter" : "No data to display"
            $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
            $msgY = $contentY + [Math]::Floor($contentHeight / 2)
            [void]$renderedContent.Append($this.MoveCursor($msgX, $msgY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($emptyMessage)
        }
        
        # Footer
        if ($this.ShowFooter) {
            $footerY = $contentY + $contentHeight - 1
            
            $statusText = "$($dataToRender.Count) rows"
            if ($this.FilterText) { $statusText += " (filtered from $($this.Data.Count))" }
            if ($this.MultiSelect) { $statusText += " | $($this.SelectedRows.Count) selected" }
            
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $footerY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($statusText)
            
            if ($dataToRender.Count -gt $this.PageSize) {
                $totalPages = [Math]::Ceiling($dataToRender.Count / [Math]::Max(1, $this.PageSize))
                $pageText = "Page $($this.CurrentPage + 1)/$totalPages"
                [void]$renderedContent.Append($this.MoveCursor($contentX + $contentWidth - $pageText.Length - 1, $footerY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Blue))
                [void]$renderedContent.Append($pageText)
            }
        }
        
        # [void]$renderedContent.Append($this.ResetColor())
        # return $renderedContent.ToString()
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # Filter mode
        if ($key.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($key.Key) {
                ([ConsoleKey]::F) {
                    $this.FilterMode = -not $this.FilterMode
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::S) {
                    if ($this.AllowSort) {
                        $sortableCols = @($this.Columns | Where-Object { $_.Sortable -ne $false })
                        if ($sortableCols.Count -gt 0) {
                            $currentIdx = [array]::IndexOf($sortableCols.Name, $this.SortColumn)
                            $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                            $this.SortColumn = $sortableCols[$nextIdx].Name
                            $this.ProcessData()
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
            }
        }
        
        # Filter text input
        if ($this.FilterMode) {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.FilterMode = $false
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $this.FilterMode = $false
                    $this.ProcessData()
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.FilterText.Length -gt 0) {
                        $this.FilterText = $this.FilterText.Substring(0, $this.FilterText.Length - 1)
                        $this.ProcessData()
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                        $this.FilterText += $key.KeyChar
                        $this.ProcessData()
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            return $false
        }
        
        # Normal navigation
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedRow -gt 0) {
                    $this.SelectedRow--
                    if ($this.SelectedRow -lt ($this.CurrentPage * $this.PageSize)) {
                        $this.CurrentPage--
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedRow -lt ($this.ProcessedData.Count - 1)) {
                    $this.SelectedRow++
                    if ($this.SelectedRow -ge (($this.CurrentPage + 1) * $this.PageSize)) {
                        $this.CurrentPage++
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                if ($this.OnRowSelect -and $this.ProcessedData.Count -gt 0) {
                    $selectedData = $this.MultiSelect ? @($this.SelectedRows | ForEach-Object { $this.ProcessedData[$_] }) : $this.ProcessedData[$this.SelectedRow]
                    & $this.OnRowSelect $selectedData $this.SelectedRow
                }
                return $true
            }
        }
        
        return $false
    }
    
    # AI: Helper methods removed - using buffer-based rendering instead of ANSI
    
    # Public methods
    [void] RefreshData() {
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetData([hashtable[]]$data) {
        $this.Data = $data
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this.ProcessData()
        Request-TuiRefresh
    }
}
#endregion

#region Factory Functions for Backward Compatibility

function New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DataTable_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $data = $Props.Data ?? @()
    $columns = $Props.Columns ?? @()
    
    $table = [DataTableComponent]::new($name, $data, $columns)
    
    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.Title = $Props.Title ?? $table.Title
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader
    $table.ShowFooter = $Props.ShowFooter ?? $table.ShowFooter
    $table.ShowRowNumbers = $Props.ShowRowNumbers ?? $table.ShowRowNumbers
    $table.AllowSort = $Props.AllowSort ?? $table.AllowSort
    $table.AllowFilter = $Props.AllowFilter ?? $table.AllowFilter
    $table.AllowSelection = $Props.AllowSelection ?? $table.AllowSelection
    $table.MultiSelect = $Props.MultiSelect ?? $table.MultiSelect
    $table.Visible = $Props.Visible ?? $table.Visible
    $table.OnRowSelect = $Props.OnRowSelect ?? $table.OnRowSelect
    $table.OnSelectionChange = $Props.OnSelectionChange ?? $table.OnSelectionChange
    
    return $table
}
#endregion

Export-ModuleMember -Function 'New-TuiDataTable'



####\refactor_checkpoints\checkpoint_20250629_210720_phase-1-complete\components\advanced-input-components.psm1
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Value = $Props.Value ?? (Get-Date)
        Mode = $Props.Mode ?? "Date" # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = $Props.Value ?? (Get-Date)
        ViewDate = $Props.Value ?? (Get-Date)
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSelect = $Props.OnSelect
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                # Main container
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Calendar "
                
                # Header with navigation
                $headerY = $self.Y + 1
                $monthYear = $self.ViewDate.ToString("MMMM yyyy")
                $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
                
                Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
                Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
                Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
                
                # Day headers
                $dayHeaderY = $headerY + 2
                $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
                $dayWidth = 4
                $startX = $self.X + 2
                
                for ($i = 0; $i -lt $days.Count; $i++) {
                    Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                        -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
                }
                
                # Calendar grid
                $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
                $startDayOfWeek = [int]$firstDay.DayOfWeek
                $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
                
                $currentDay = 1
                $calendarY = $dayHeaderY + 1
                
                for ($week = 0; $week -lt 6; $week++) {
                    if ($currentDay -gt $daysInMonth) { break }
                    
                    for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                        $x = $startX + ($dayOfWeek * $dayWidth)
                        
                        if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                        
                        if ($currentDay -le $daysInMonth) {
                            $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                         $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                         $self.ViewDate.Year -eq $self.SelectedDate.Year)
                            
                            $isToday = ($currentDay -eq (Get-Date).Day -and 
                                      $self.ViewDate.Month -eq (Get-Date).Month -and 
                                      $self.ViewDate.Year -eq (Get-Date).Year)
                            
                            $fg = if ($isSelected) { Get-ThemeColor "Background" } elseif ($isToday) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                            $bg = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                            
                            $dayText = $currentDay.ToString().PadLeft(2)
                            Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText -ForegroundColor $fg -BackgroundColor $bg
                            
                            $currentDay++
                        }
                    }
                }
                
                # Time picker if in DateTime mode
                if ($self.Mode -eq "DateTime") {
                    $timeY = $self.Y + $self.Height - 2
                    $timeStr = $self.SelectedDate.ToString("HH:mm")
                    Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "CalendarPicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $date = $self.SelectedDate
                $viewDate = $self.ViewDate
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $self.ViewDate = $viewDate.AddMonths(-1) } # Previous month
                        else { $date = $date.AddDays(-1); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } } # Previous day
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $self.ViewDate = $viewDate.AddMonths(1) } # Next month
                        else { $date = $date.AddDays(1); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } } # Next day
                    }
                    ([ConsoleKey]::UpArrow) { $date = $date.AddDays(-7); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(7); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } }
                    ([ConsoleKey]::PageUp) {
                        $self.ViewDate = $viewDate.AddMonths(-1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::PageDown) {
                        $self.ViewDate = $viewDate.AddMonths(1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::Home) { $date = Get-Date; $self.ViewDate = $date }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSelect) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSelect" -ScriptBlock { & $self.OnSelect -Date $date } -AdditionalData @{ Component = $self.Name; SelectedDate = $date }
                        }
                    }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.SelectedDate = $date
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $date } -AdditionalData @{ Component = $self.Name; NewValue = $date }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "CalendarPicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 3
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Type to search..."
        MaxDisplayItems = $Props.MaxDisplayItems ?? 5
        AllowCustomValue = $Props.AllowCustomValue ?? $false
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                # Main dropdown box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                # Display text
                $displayText = ""
                if ($self.IsOpen) {
                    $displayText = $self.SearchText
                    if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                        $displayText = $self.Placeholder
                    }
                } else {
                    if ($self.Value) {
                        $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                        $displayText = $selected ? $selected.Display : $self.Value.ToString()
                    } else {
                        $displayText = "Select..."
                    }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                # Dropdown indicator
                $indicator = $self.IsOpen ? "▲" : "▼"
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator -ForegroundColor $borderColor
                
                # Cursor for search mode
                if ($self.IsOpen -and $self.IsFocused) {
                    $cursorX = $self.X + 2 + $self.SearchText.Length
                    if ($cursorX -lt ($self.X + $self.Width - 3)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Options dropdown
                if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                    $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                    Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $startIdx = ($self.SelectedIndex -ge $self.MaxDisplayItems) ? ($self.SelectedIndex - $self.MaxDisplayItems + 1) : 0
                    $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                    
                    for ($i = $startIdx; $i -le $endIdx; $i++) {
                        $option = $self.FilteredOptions[$i]
                        $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                        
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $fg = $isSelected ? (Get-ThemeColor "Background") : (Get-ThemeColor "Primary")
                        $bg = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                        
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) {
                            $text = $text.Substring(0, $self.Width - 7) + "..."
                        }
                        
                        # Highlight matching text
                        if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                            $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                            if ($matchIndex -ge 0) {
                                if ($matchIndex -gt 0) { Write-BufferString -X ($self.X + 2) -Y $y -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg }
                                Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y -Text $text.Substring($matchIndex, $self.SearchText.Length) -ForegroundColor (Get-ThemeColor "Warning")
                                $afterMatch = $matchIndex + $self.SearchText.Length
                                if ($afterMatch -lt $text.Length) { Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y -Text $text.Substring($afterMatch) -ForegroundColor $fg }
                                continue
                            }
                        }
                        
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                    
                    # Scrollbar if needed
                    if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                        $scrollHeight = $self.MaxDisplayItems
                        $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $char = ($i -eq $scrollPos) ? "█" : "│"
                            $color = ($i -eq $scrollPos) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Subtle")
                            Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        FilterOptions = {
            try {
                $this.FilteredOptions = if ([string]::IsNullOrEmpty($this.SearchText)) {
                    $this.Options
                } else {
                    @($this.Options | Where-Object { $_.Display -like "*$($this.SearchText)*" })
                }
                
                if ($this.AllowCustomValue -and $this.SearchText -and -not ($this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText })) {
                    $this.FilteredOptions = @(@{ Display = $this.SearchText; Value = $this.SearchText; IsCustom = $true }) + $this.FilteredOptions
                }
                
                $this.SelectedIndex = 0
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown FilterOptions error for '$($this.Name)': $_" -Data @{ Component = $this.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        $self.SearchText = ""
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                    return $false
                }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) { $self.IsOpen = $false; $self.SearchText = ""; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Enter) {
                        if ($self.FilteredOptions.Count -gt 0) {
                            $selected = $self.FilteredOptions[$self.SelectedIndex]
                            if ($self.OnChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $selected.Value -Option $selected } -AdditionalData @{ Component = $self.Name; NewValue = $selected.Value; Option = $selected }
                            }
                            $self.Value = $selected.Value
                            $self.IsOpen = $false
                            $self.SearchText = ""
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::UpArrow) { if ($self.SelectedIndex -gt 0) { $self.SelectedIndex--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::DownArrow) { if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) { $self.SelectedIndex++; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Backspace) {
                        if ($self.SearchText.Length -gt 0) {
                            $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                            & $self.FilterOptions
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.SearchText += $Key.KeyChar
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Options = $Props.Options ?? @()
        SelectedValues = $Props.SelectedValues ?? @()
        Title = $Props.Title ?? "Select items"
        AllowSelectAll = $Props.AllowSelectAll ?? $true
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSubmit = $Props.OnSubmit
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor -Title " $($self.Title) "
                
                $currentY = $self.Y + 1
                if ($self.AllowSelectAll) {
                    $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                    $checkbox = $allSelected ? "[X]" : "[ ]"
                    $fg = ($self.SelectedIndex -eq -1) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" -ForegroundColor $fg
                    $currentY += 2
                }
                
                $visibleHeight = $self.Height - 4 - ($self.AllowSelectAll ? 2 : 0)
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.Options[$i]
                    $isChecked = $self.SelectedValues -contains $option.Value
                    $isHighlighted = ($i -eq $self.SelectedIndex)
                    
                    $checkbox = $isChecked ? "[X]" : "[ ]"
                    $fg = $isHighlighted ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                    
                    $text = "$checkbox $($option.Display)"
                    if ($text.Length -gt ($self.Width - 4)) { $text = $text.Substring(0, $self.Width - 7) + "..." }
                    
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                    $currentY++
                }
                
                $statusY = $self.Y + $self.Height - 2
                $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
                Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText -ForegroundColor (Get-ThemeColor "Subtle")
            } catch {
                Write-Log -Level Error -Message "MultiSelect Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) { $self.SelectedIndex = -1 } 
                        elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                            $self.SelectedIndex--
                            if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) { $self.ScrollOffset = $self.SelectedIndex }
                        }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                            $self.SelectedIndex++
                            $visibleHeight = $self.Height - 4 - ($self.AllowSelectAll ? 2 : 0)
                            if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) { $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1 }
                        }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                            $self.SelectedValues = ($self.SelectedValues.Count -eq $self.Options.Count) ? @() : @($self.Options.Value)
                        } elseif ($self.SelectedIndex -ge 0) {
                            $optionValue = $self.Options[$self.SelectedIndex].Value
                            if ($self.SelectedValues -contains $optionValue) {
                                $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $optionValue })
                            } else {
                                $self.SelectedValues += $optionValue
                            }
                        }
                        
                        if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -SelectedValues $self.SelectedValues } }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSubmit) { Invoke-WithErrorHandling -Component "$($self.Name).OnSubmit" -ScriptBlock { & $self.OnSubmit -SelectedValues $self.SelectedValues } }
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "MultiSelect HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Value = $Props.Value ?? 0
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        DecimalPlaces = $Props.DecimalPlaces ?? 0
        IsFocusable = $true
        TextValue = ($Props.Value ?? 0).ToString()
        CursorPosition = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $displayValue = $self.TextValue
                if ($displayValue.Length -gt ($self.Width - 6)) { $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..." }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
                
                if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    if ($cursorX -lt ($self.X + $self.Width - 4)) { Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent") }
                }
                
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" -ForegroundColor $borderColor
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" -ForegroundColor $borderColor
                
                if ($self.Value -le $self.Min) { Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" -ForegroundColor (Get-ThemeColor "Warning") }
                if ($self.Value -ge $self.Max) { Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" -ForegroundColor (Get-ThemeColor "Warning") }
            } catch { Write-Log -Level Error -Message "NumberInput Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ } }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                $newValue = ($this.DecimalPlaces -eq 0) ? [Math]::Floor($newValue) : [Math]::Round($newValue, $this.DecimalPlaces)
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) { Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { & $this.OnChange -NewValue $newValue } }
                return $true
            } catch {
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                Write-Log -Level Warning -Message "NumberInput ValidateAndUpdate error for '$($this.Name)': $_" -Data @{ Component = $this.Name; InputText = $this.TextValue; Exception = $_ }
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step); $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)"); $self.CursorPosition = $self.TextValue.Length; if ($self.OnChange) { & $self.OnChange -NewValue $self.Value }; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::DownArrow) { $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step); $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)"); $self.CursorPosition = $self.TextValue.Length; if ($self.OnChange) { & $self.OnChange -NewValue $self.Value }; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::LeftArrow) { if ($self.CursorPosition -gt 0) { $self.CursorPosition--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::RightArrow) { if ($self.CursorPosition -lt $self.TextValue.Length) { $self.CursorPosition++; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Home) { $self.CursorPosition = 0; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::End) { $self.CursorPosition = $self.TextValue.Length; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Backspace) { if ($self.CursorPosition -gt 0) { $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1); $self.CursorPosition--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Delete) { if ($self.CursorPosition -lt $self.TextValue.Length) { $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1); Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Enter) { & $self.ValidateAndUpdate -self $self; Request-TuiRefresh; return $true }
                    default {
                        if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                            $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch { Write-Log -Level Error -Message "NumberInput HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ } }
            return $false
        }
    }
    
    return $component
}

function New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 1
        Value = $Props.Value ?? 50
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        ShowValue = $Props.ShowValue ?? $true
        IsFocusable = $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $fg = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                
                $range = $self.Max - $self.Min
                $percent = ($self.Value - $self.Min) / $range
                $trackWidth = $self.Width - 2
                $thumbPos = [Math]::Floor($trackWidth * $percent)
                
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text ("─" * $trackWidth) -ForegroundColor (Get-ThemeColor "Subtle")
                if ($thumbPos -gt 0) { Write-BufferString -X ($self.X + 1) -Y $self.Y -Text ("═" * $thumbPos) -ForegroundColor $fg }
                
                Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
                Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
                Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
                
                if ($self.ShowValue) {
                    $valueText = $self.Value.ToString()
                    $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                    Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
                }
            } catch { Write-Log -Level Error -Message "Slider Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ } }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $oldValue = $self.Value
                $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) { $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step) }
                    ([ConsoleKey]::RightArrow) { $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step) }
                    ([ConsoleKey]::Home) { $self.Value = $self.Min }
                    ([ConsoleKey]::End) { $self.Value = $self.Max }
                    ([ConsoleKey]::PageDown) { $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep) }
                    ([ConsoleKey]::PageUp) { $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep) }
                    default { $handled = $false }
                }
                
                if ($handled -and $self.Value -ne $oldValue) {
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $self.Value } }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch { Write-Log -Level Error -Message "Slider HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ } }
            return $false
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function 'New-TuiCalendarPicker', 'New-TuiSearchableDropdown', 'New-TuiMultiSelect', 'New-TuiNumberInput', 'New-TuiSlider'


####\refactor_checkpoints\checkpoint_20250629_210720_phase-1-complete\components\navigation-class.psm1
# Navigation Component Classes Module for PMC Terminal v5
# Implements navigation menu functionality with keyboard shortcuts

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        # Simplified format display without ANSI escape codes
        $display = "[$($this.Key)] "
        
        if ($this.Enabled) {
            $display += $this.Label
        }
        else {
            $display += "$($this.Label) (Disabled)"
        }
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            $display += " - $($this.Description)"
        }
        
        return $display
    }
}

# NavigationMenu - Component for displaying and handling navigation options
class NavigationMenu : Component {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    
    NavigationMenu([string]$name) : base($name) {
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.SelectedIndex = 0
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base($name) {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.SelectedIndex = 0
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) { 
            throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") 
        }
        $this.Items.Add($item)
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { [void]$this.Items.Remove($item) }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { 
                $item.Execute() 
            }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
    }

    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", { 
                    $this.Services.Navigation.GoTo("/tasks", @{mode="new"}) 
                }))
                $this.AddItem([NavigationItem]::new("P", "Projects", { 
                    $this.Services.Navigation.GoTo("/projects", @{}) 
                }))
                $this.AddItem([NavigationItem]::new("S", "Settings", { 
                    $this.Services.Navigation.GoTo("/settings", @{}) 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("Q", "Quit", { 
                    $this.Services.Navigation.RequestExit() 
                }))
            }
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", { 
                    Write-Host "New task not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("E", "Edit", { 
                    Write-Host "Edit not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("D", "Delete", { 
                    Write-Host "Delete not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("F", "Filter", { 
                    Write-Host "Filter not implemented" 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
            }
            default {
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
                $this.AddItem([NavigationItem]::new("H", "Home", { 
                    $this.Services.Navigation.GoTo("/dashboard", @{}) 
                }))
            }
        }
    }
    
    # AI: FIX - Get render coordinates from parent panel
    hidden [hashtable] GetRenderPosition() {
        # Default position if no parent
        $x = 0
        $y = 0
        
        # AI: FIX - If we have a parent Panel, use its content area
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $x = $contentArea.X
            $y = $contentArea.Y
        }
        
        return @{ X = $x; Y = $y }
    }
    
    hidden [void] _RenderContent() {
        # Get visible items
        if ($null -eq $this.Items -or $this.Items.Count -eq 0) {
            return
        }
        
        $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
        if ($visibleItems.Count -eq 0) { return }
        
        if ($this.Orientation -eq "Horizontal") { 
            $this.RenderHorizontal($visibleItems) 
        }
        else { 
            $this.RenderVertical($visibleItems) 
        }
    }
    
    hidden [void] RenderHorizontal([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) {
            return
        }
        
        # AI: FIX - Get proper render position from parent
        $pos = $this.GetRenderPosition()
        
        $menuText = ""
        $isFirst = $true
        foreach ($item in $items) {
            if ($null -eq $item) { continue }
            
            if (-not $isFirst) {
                $menuText += $this.Separator
            }
            $menuText += "[$($item.Key)] $($item.Label)"
            $isFirst = $false
        }
        
        if (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue) {
            Write-BufferString -X $pos.X -Y $pos.Y -Text $menuText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
        }
    }
    
    hidden [void] RenderVertical([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) {
            return
        }
        
        # AI: FIX - Get proper render position from parent
        $pos = $this.GetRenderPosition()
        
        # Ensure SelectedIndex is within bounds
        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {
            $this.SelectedIndex = 0
        }
        
        # AI: FIX - Calculate max width for proper clearing
        $maxWidth = 0
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $maxWidth = $contentArea.Width
        }
        
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($null -eq $item) { continue }
            
            $prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }
            $menuText = "$prefix[$($item.Key)] $($item.Label)"
            
            # AI: FIX - Pad text to clear the full line width
            if ($maxWidth -gt 0 -and $menuText.Length -lt $maxWidth) {
                $menuText = $menuText.PadRight($maxWidth)
            }
            
            if (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue) {
                $fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                    [ConsoleColor]::Black 
                } else { 
                    [ConsoleColor]::White 
                }
                $bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                    [ConsoleColor]::White 
                } else { 
                    [ConsoleColor]::Black 
                }
                
                Write-BufferString -X $pos.X -Y ($pos.Y + $i) -Text $menuText `
                    -ForegroundColor $fg -BackgroundColor $bg
            }
        }
    }
}

Export-ModuleMember -Function @()



####\refactor_checkpoints\checkpoint_20250629_210720_phase-1-complete\components\tui-components.psm1
# TUI Component Library - Phase 1 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

using module ..\components\tui-primitives.psm1

#region Core UI Components

# AI: REFACTORED - LabelComponent now properly inherits from UIElement
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor
    
    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Now renders to parent Panel's buffer instead of direct output
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            $parentPanel = [Panel]$this.Parent
            
            # AI: Calculate position relative to parent's content area
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            # AI: Render to parent's buffer
            $parentPanel.WriteToBuffer($renderX, $renderY, $this.Text, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "Label render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false # Labels don't handle input
    }
}

# AI: REFACTORED - ButtonComponent updated for buffer-based rendering
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick
    
    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
        $this.Text = "Button"
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Buffer-based rendering with parent Panel integration
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            $bgColor = $this.IsPressed ? [ConsoleColor]::Yellow : [ConsoleColor]::Black
            $fgColor = $this.IsPressed ? [ConsoleColor]::Black : $borderColor
            
            # AI: Render border to parent buffer
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, $bgColor)
            
            # AI: Render text centered
            $textX = $renderX + [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = $renderY + [Math]::Floor($this.Height / 2)
            $parentPanel.WriteToBuffer($textX, $textY, $this.Text, $fgColor, $bgColor)
            
        } catch { 
            Write-Log -Level Error -Message "Button render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsPressed = $true
                $this.Parent.RequestRedraw()
                
                if ($this.OnClick) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock { & $this.OnClick }
                }
                
                $this.IsPressed = $false
                $this.Parent.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "Button input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: REFACTORED - TextBoxComponent with buffer-based rendering
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.MaxLength = 100
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Renders to parent Panel buffer
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display text or placeholder
            $displayText = $this.Text ?? ""
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = $this.Placeholder ?? "" 
            }
            
            $maxDisplayLength = $this.Width - 4
            if ($displayText.Length -gt $maxDisplayLength) { 
                $displayText = $displayText.Substring(0, $maxDisplayLength) 
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, [ConsoleColor]::White, [ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $displayText.Length) {
                $cursorX = $textX + $this.CursorPosition
                if ($cursorX < $renderX + $this.Width - 2) {
                    $parentPanel.WriteToBuffer($cursorX, $textY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "TextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition ?? 0
            $originalText = $currentText
            
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $currentText = $currentText.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    } 
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $currentText.Length) { 
                        $currentText = $currentText.Remove($cursorPos, 1) 
                    } 
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- } 
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $currentText.Length) { $cursorPos++ } 
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $currentText.Length }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) { 
                        $currentText = $currentText.Insert($cursorPos, $key.KeyChar)
                        $cursorPos++ 
                    } else { 
                        return $false 
                    }
                }
            }
            
            if ($currentText -ne $originalText -or $cursorPos -ne $this.CursorPosition) {
                $this.Text = $currentText
                $this.CursorPosition = $cursorPos
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $currentText 
                    }
                }
                $this.Parent.RequestRedraw()
            }
            return $true
        } catch { 
            Write-Log -Level Error -Message "TextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
}

# AI: NEW - CheckBoxComponent converted from functional to class-based
class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange
    
    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $checkbox = $this.Checked ? "[X]" : "[ ]"
            $displayText = "$checkbox $($this.Text)"
            
            $parentPanel.WriteToBuffer($renderX, $renderY, $displayText, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "CheckBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Checked = -not $this.Checked
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $this.Checked 
                    } 
                }
                $this.Parent.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "CheckBox input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: NEW - RadioButtonComponent converted from functional to class-based
class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange
    
    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $radio = $this.Selected ? "(●)" : "( )"
            $displayText = "$radio $($this.Text)"
            
            $parentPanel.WriteToBuffer($renderX, $renderY, $displayText, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "RadioButton render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if (-not $this.Selected) {
                    # AI: Unselect other radio buttons in the same group
                    if ($this.Parent -and $this.GroupName) {
                        $siblingRadios = $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        }
                        foreach ($radio in $siblingRadios) {
                            $radio.Selected = $false
                        }
                    }
                    
                    $this.Selected = $true
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $this.Selected 
                        } 
                    }
                    $this.Parent.RequestRedraw()
                }
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "RadioButton input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $label = [LabelComponent]::new($name)
    
    $label.X = $Props.X ?? $label.X
    $label.Y = $Props.Y ?? $label.Y
    $label.Width = $Props.Width ?? $label.Width
    $label.Height = $Props.Height ?? $label.Height
    $label.Visible = $Props.Visible ?? $label.Visible
    $label.ZIndex = $Props.ZIndex ?? $label.ZIndex
    $label.Text = $Props.Text ?? $label.Text
    $label.ForegroundColor = $Props.ForegroundColor ?? $label.ForegroundColor
    
    return $label
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $button = [ButtonComponent]::new($name)
    
    $button.X = $Props.X ?? $button.X
    $button.Y = $Props.Y ?? $button.Y
    $button.Width = $Props.Width ?? $button.Width
    $button.Height = $Props.Height ?? $button.Height
    $button.Visible = $Props.Visible ?? $button.Visible
    $button.ZIndex = $Props.ZIndex ?? $button.ZIndex
    $button.Text = $Props.Text ?? $button.Text
    $button.OnClick = $Props.OnClick ?? $button.OnClick
    
    return $button
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [TextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Text = $Props.Text ?? $textBox.Text
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLength = $Props.MaxLength ?? $textBox.MaxLength
    $textBox.CursorPosition = $Props.CursorPosition ?? $textBox.CursorPosition
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    return $textBox
}

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $checkBox = [CheckBoxComponent]::new($name)
    
    $checkBox.X = $Props.X ?? $checkBox.X
    $checkBox.Y = $Props.Y ?? $checkBox.Y
    $checkBox.Width = $Props.Width ?? $checkBox.Width
    $checkBox.Height = $Props.Height ?? $checkBox.Height
    $checkBox.Visible = $Props.Visible ?? $checkBox.Visible
    $checkBox.ZIndex = $Props.ZIndex ?? $checkBox.ZIndex
    $checkBox.Text = $Props.Text ?? $checkBox.Text
    $checkBox.Checked = $Props.Checked ?? $checkBox.Checked
    $checkBox.OnChange = $Props.OnChange ?? $checkBox.OnChange
    
    return $checkBox
}

function New-TuiRadioButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $radioButton = [RadioButtonComponent]::new($name)
    
    $radioButton.X = $Props.X ?? $radioButton.X
    $radioButton.Y = $Props.Y ?? $radioButton.Y
    $radioButton.Width = $Props.Width ?? $radioButton.Width
    $radioButton.Height = $Props.Height ?? $radioButton.Height
    $radioButton.Visible = $Props.Visible ?? $radioButton.Visible
    $radioButton.ZIndex = $Props.ZIndex ?? $radioButton.ZIndex
    $radioButton.Text = $Props.Text ?? $radioButton.Text
    $radioButton.Selected = $Props.Selected ?? $radioButton.Selected
    $radioButton.GroupName = $Props.GroupName ?? $radioButton.GroupName
    $radioButton.OnChange = $Props.OnChange ?? $radioButton.OnChange
    
    return $radioButton
}

#endregion

Export-ModuleMember -Function 'New-TuiLabel', 'New-TuiButton', 'New-TuiTextBox', 'New-TuiCheckBox', 'New-TuiRadioButton'


####\refactor_checkpoints\checkpoint_20250629_210720_phase-1-complete\components\tui-primitives.psm1
# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations

using namespace System
using namespace System.Management.Automation

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    [ConsoleColor] $ForegroundColor = [ConsoleColor]::White
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = ""
    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() {
        $this.Char = ' '
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Character constructor
    TuiCell([char]$char) {
        $this.Char = $char
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Full constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }

    # Style constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }

    # Copy constructor
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.StyleFlags = $other.StyleFlags
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Create a styled copy
    [TuiCell] WithStyle([ConsoleColor]$fg, [ConsoleColor]$bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    # Create a character copy
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blend this cell with another (higher Z-index wins)
    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return $other }
        if ($other.ZIndex -eq $this.ZIndex -and $other.Char -ne ' ') { return $other }
        return $this
    }

    # Check if this cell differs from another
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic)
    }

    # Generate ANSI escape sequence for this cell
    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Color codes
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append("`e[${fgCode};${bgCode}")
        
        # Style codes
        if ($this.Bold) { [void]$sb.Append(";1") }
        if ($this.Underline) { [void]$sb.Append(";4") }
        if ($this.Italic) { [void]$sb.Append(";3") }
        
        [void]$sb.Append("m").Append($this.Char)
        return $sb.ToString()
    }

    # Convert to legacy buffer format for compatibility
    [hashtable] ToLegacyFormat() {
        return @{
            Char = $this.Char
            FG = $this.ForegroundColor
            BG = $this.BackgroundColor
        }
    }

    # String representation
    [string] ToString() {
        return "TuiCell($($this.Char), $($this.ForegroundColor), $($this.BackgroundColor))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

#region UIElement Base Class - Foundation for All Components
class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer = $null
    [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{}

    # Constructor
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with position and size
    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Buffer")
    }

    # Get absolute screen position
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # Add child component
    [void] AddChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
        }
    }

    # Remove child component
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
            $this.RequestRedraw()
        }
    }

    # Request redraw for this component and parents
    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
    }

    # Resize the component and its buffer
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Resize($newWidth, $newHeight)
        }
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # Move the component
    [void] Move([int]$newX, [int]$newY) {
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
    }

    # Check if point is within component bounds
    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge $this.X -and $x -lt ($this.X + $this.Width) -and 
                $y -ge $this.Y -and $y -lt ($this.Y + $this.Height))
    }

    # Get child at specific point (relative to this component)
    [UIElement] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $this.X, $y - $this.Y)) {
                return $child
            }
        }
        return $null
    }

    # Virtual methods for subclasses to override
    [void] OnRender() {
        # Default implementation - clear buffer
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Override in subclasses
    }

    [void] OnMove([int]$newX, [int]$newY) {
        # Override in subclasses
    }

    [void] OnFocus() {
        # Override in subclasses
    }

    [void] OnBlur() {
        # Override in subclasses
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Override in subclasses - return true if input was handled
        return $false
    }

    # Main render method - calls OnRender and renders children
    [void] Render() {
        if (-not $this.Visible) { return }

        # Render this component to its private buffer
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer) {
                $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }
            
            $this.OnRender()
            $this._needs_redraw = $false
        }

        # Render children to their buffers, then composite onto parent
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
    }

    # Get the final rendered buffer
    [TuiBuffer] GetBuffer() {
        return $this._private_buffer
    }
}
#endregion

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int] GetForegroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()]
    }

    static [int] GetBackgroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()] + 10
    }

    static [string] Reset() {
        return "`e[0m"
    }

    static [string] Bold() {
        return "`e[1m"
    }

    static [string] Underline() {
        return "`e[4m"
    }

    static [string] Italic() {
        return "`e[3m"
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions
function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    
    $cell = [TuiCell]::new(' ', $ForegroundColor, $BackgroundColor)
    $cell.Bold = $Bold
    $cell.Underline = $Underline
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0) {
            $charCell = [TuiCell]::new($cell)
            $charCell.Char = $char
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$BorderStyle = "Single",
        [ConsoleColor]$BorderColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }
    
    $borders = Get-TuiBorderChars -Style $BorderStyle
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Side borders and fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        $currentY = $Y + $i
        
        # Left border
        Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill
        $fillText = ' ' * ($Width - 2)
        Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -BackgroundColor $BackgroundColor
        
        # Right border
        Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $bottomLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all classes and functions
Export-ModuleMember -Function 'Write-TuiText', 'Write-TuiBox', 'Get-TuiBorderChars'


####\refactor_checkpoints\checkpoint_20250629_210720_phase-1-complete\layout\panels-class.psm1
# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

using module .\components\tui-primitives.psm1

#region Panel Class - Basic Layout Container
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds
    [void] Resize([int]$newWidth, [int]$newHeight) {
        ([UIElement]$this).Resize($newWidth, $newHeight)
        $this.UpdateContentBounds()
    }

    # Add child with automatic layout (if enabled)
    [void] AddChild([UIElement]$child) {
        ([UIElement]$this).AddChild($child)
        $this.PerformLayout()
    }

    # Remove child and re-layout
    [void] RemoveChild([UIElement]$child) {
        ([UIElement]$this).RemoveChild($child)
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.Move($this.ContentX, $currentY)
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.Move($currentX, $this.ContentY)
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        # Calculate grid dimensions
        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            # Adjust size for last column/row
            $width = if ($col -eq ($cols - 1)) { 
                $this.ContentX + $this.ContentWidth - $x 
            } else { 
                $cellWidth 
            }
            $height = if ($row -eq ($rows - 1)) { 
                $this.ContentY + $this.ContentHeight - $y 
            } else { 
                $cellHeight 
            }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    # Set border style and update content bounds
    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    # Enable/disable border
    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    # Set title
    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    # Check if point is within content area
    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    # Get content bounds as hashtable
    [hashtable] GetContentBounds() {
        return @{
            X = $this.ContentX
            Y = $this.ContentY
            Width = $this.ContentWidth
            Height = $this.ContentHeight
        }
    }

    # Clear content area only
    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return }

        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    # Main render implementation
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }

        # Clear entire buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this._private_buffer.Clear($bgCell)

        # Draw border if enabled
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }

        # Fill content area
        $this.ClearContent()
    }

    # Override OnResize to update content bounds
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Handle focus for focusable panels
    [void] OnFocus() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Cyan
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Gray
            $this.RequestRedraw()
        }
    }

    # Find first focusable child
    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    # Get all focusable children (recursive)
    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        
        return $focusable
    }

    # Basic input handling - delegate to focused child
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # If this panel can focus and is focused, handle some basic navigation
        if ($this.CanFocus -and $this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        Set-ComponentFocus -Component $firstChild
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        Set-ComponentFocus -Component $firstChild
                        return $true
                    }
                }
            }
        }

        # Delegate to children
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }

        return $false
    }

    # String representation
    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}
#endregion

#region Specialized Panel Types

# Scrollable Panel - supports content larger than visible area
class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    # Constructor
    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    # Set virtual content size
    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        
        # Create virtual buffer if needed
        if ($width -gt 0 -and $height -gt 0) {
            $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        
        $this.RequestRedraw()
    }

    # Scroll to position
    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        
        $this.RequestRedraw()
    }

    # Scroll by delta
    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    # Handle scrolling input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }

        return ([Panel]$this).HandleInput($keyInfo)
    }

    # Render with scrolling support
    [void] OnRender() {
        # Render base panel
        ([Panel]$this).OnRender()

        # Render virtual content if available
        if ($null -ne $this._virtual_buffer) {
            # Create a sub-buffer view of the virtual content
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            
            # Blend visible content onto our buffer
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }

        # Draw scrollbars if enabled and needed
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    # Draw scrollbar indicators
    [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return }

        # Vertical scrollbar
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
        }

        # Horizontal scrollbar
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    # Get virtual content buffer for external drawing
    [TuiBuffer] GetVirtualBuffer() {
        return $this._virtual_buffer
    }
}

# Group Panel - collapsible panel with header
class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    # Toggle collapsed state
    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)  # Just header + border
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        
        # Update child visibility
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        
        $this.RequestRedraw()
    }

    # Handle collapse/expand input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }

        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        
        return $false
    }

    # Render with collapse indicator
    [void] OnRender() {
        ([Panel]$this).OnRender()

        # Draw collapse/expand indicator in title area
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            $this._private_buffer.SetCell(2, 0, $indicatorCell)
        }
    }
}
#endregion

# Export the Panel classes
Export-ModuleMember -Function @()


####\refactor_checkpoints\checkpoint_20250629_210720_phase-1-complete\modules\dialog-system-class.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Base Dialog Class
class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    [int] $Width = 50
    [int] $Height = 10
    [int] $X
    [int] $Y
    [ConsoleColor] $BorderColor = [ConsoleColor]::Cyan
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [ConsoleColor] $MessageColor = [ConsoleColor]::Gray
    
    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    [void] Show() {
        # Calculate centered position
        $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
        $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 2)
        
        # Register with dialog manager
        $script:DialogState.CurrentDialog = $this
        Request-TuiRefresh
    }
    
    [void] Close() {
        $script:DialogState.CurrentDialog = $null
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        }
        Request-TuiRefresh
    }
    
    # Base render draws dialog frame
    hidden [void] _RenderContent() {
        # Draw dialog box
        Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height `
            -Title " $($this.Title) " -BorderColor $this.BorderColor
        
        # Draw message if present
        if (-not [string]::IsNullOrWhiteSpace($this.Message)) {
            $this.RenderMessage()
        }
        
        # Let derived classes render their specific content
        $this._RenderDialogContent()
    }
    
    hidden [void] RenderMessage() {
        $messageY = $this.Y + 2
        $messageX = $this.X + 2
        $maxWidth = $this.Width - 4
        
        $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
        foreach ($line in $wrappedLines) {
            if ($messageY -ge ($this.Y + $this.Height - 3)) { break }
            Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor $this.MessageColor
            $messageY++
        }
    }
    
    # Override in derived classes
    hidden [void] _RenderDialogContent() { }
    
    # Base input handling - ESC closes dialog
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.OnCancel()
        }
    }
    
    # Virtual methods for derived classes
    [void] OnConfirm() { $this.Close() }
    [void] OnCancel() { $this.Close() }
}

# Alert Dialog - Simple OK dialog
class AlertDialog : Dialog {
    [string] $ButtonText = "OK"
    
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 10
        $this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))
    }
    
    hidden [void] _RenderDialogContent() {
        # Render OK button
        $buttonY = $this.Y + $this.Height - 2
        $buttonText = "[ $($this.ButtonText) ]"
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
        
        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) { $this.OnConfirm() }
            ([ConsoleKey]::Spacebar) { $this.OnConfirm() }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
}

# Confirm Dialog - Yes/No dialog
class ConfirmDialog : Dialog {
    [scriptblock] $OnConfirmAction
    [scriptblock] $OnCancelAction
    [string[]] $Buttons = @("Yes", "No")
    [int] $SelectedButton = 0
    
    ConfirmDialog([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) : base("ConfirmDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.OnConfirmAction = $onConfirm
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render buttons
        $buttonY = $this.Y + $this.Height - 3
        $totalButtonWidth = ($this.Buttons.Count * 12) + (($this.Buttons.Count - 1) * 2)
        $buttonX = $this.X + [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        
        for ($i = 0; $i -lt $this.Buttons.Count; $i++) {
            $button = $this.Buttons[$i]
            $isSelected = ($i -eq $this.SelectedButton)
            $buttonText = if ($isSelected) { "[ $button ]" } else { "  $button  " }
            $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
            $buttonX += 14
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) { 
                $this.SelectedButton = [Math]::Max(0, $this.SelectedButton - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::RightArrow) { 
                $this.SelectedButton = [Math]::Min($this.Buttons.Count - 1, $this.SelectedButton + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Tab) { 
                $this.SelectedButton = ($this.SelectedButton + 1) % $this.Buttons.Count
                Request-TuiRefresh
            }
            ([ConsoleKey]::Enter) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Spacebar) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnConfirmAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnConfirm" -ScriptBlock $this.OnConfirmAction
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Input Dialog - Text input dialog
class InputDialog : Dialog {
    [string] $Prompt = ""
    [string] $InputValue = ""
    [string] $DefaultValue = ""
    [scriptblock] $OnSubmitAction
    [scriptblock] $OnCancelAction
    [int] $FocusedElement = 0  # 0=TextBox, 1=OK, 2=Cancel
    [int] $CursorPosition = 0
    
    InputDialog([string]$title, [string]$prompt, [scriptblock]$onSubmit, [scriptblock]$onCancel) : base("InputDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.OnSubmitAction = $onSubmit
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(70, [Math]::Max(50, $prompt.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render prompt
        $promptX = $this.X + 2
        $promptY = $this.Y + 2
        Write-BufferString -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor ([ConsoleColor]::White)
        
        # Render input box
        $inputY = $promptY + 2
        $inputWidth = $this.Width - 4
        $isFocused = ($this.FocusedElement -eq 0)
        $borderColor = if ($isFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::DarkGray }
        
        Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 -BorderColor $borderColor
        
        # Render input text
        $displayText = $this.InputValue
        if ($displayText.Length -gt ($inputWidth - 3)) {
            $displayText = $displayText.Substring(0, $inputWidth - 3)
        }
        Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText -ForegroundColor ([ConsoleColor]::White)
        
        # Show cursor when focused
        if ($isFocused -and $this.CursorPosition -le $displayText.Length) {
            Write-BufferString -X ($promptX + 1 + $this.CursorPosition) -Y ($inputY + 1) `
                -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
        }
        
        # Render buttons
        $buttonY = $this.Y + $this.Height - 2
        $buttonSpacing = 15
        $buttonsWidth = $buttonSpacing * 2
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonsWidth) / 2)
        
        # OK button
        $okFocused = ($this.FocusedElement -eq 1)
        $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
        $okColor = if ($okFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
        
        # Cancel button
        $cancelFocused = ($this.FocusedElement -eq 2)
        $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
        $cancelColor = if ($cancelFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Tab) {
                $direction = if ($key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                $this.FocusedElement = ($this.FocusedElement + $direction + 3) % 3
                Request-TuiRefresh
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
            default {
                switch ($this.FocusedElement) {
                    0 { # TextBox
                        switch ($key.Key) {
                            ([ConsoleKey]::Enter) { $this.OnConfirm() }
                            ([ConsoleKey]::Backspace) {
                                if ($this.InputValue.Length -gt 0 -and $this.CursorPosition -gt 0) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition - 1, 1)
                                    $this.CursorPosition--
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::Delete) {
                                if ($this.CursorPosition -lt $this.InputValue.Length) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition, 1)
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::LeftArrow) {
                                $this.CursorPosition = [Math]::Max(0, $this.CursorPosition - 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::RightArrow) {
                                $this.CursorPosition = [Math]::Min($this.InputValue.Length, $this.CursorPosition + 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::Home) {
                                $this.CursorPosition = 0
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::End) {
                                $this.CursorPosition = $this.InputValue.Length
                                Request-TuiRefresh
                            }
                            default {
                                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                                    $this.InputValue = $this.InputValue.Insert($this.CursorPosition, $key.KeyChar)
                                    $this.CursorPosition++
                                    Request-TuiRefresh
                                }
                            }
                        }
                    }
                    1 { # OK Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnConfirm()
                        }
                    }
                    2 { # Cancel Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnCancel()
                        }
                    }
                }
            }
        }
    }
    
    [void] SetDefaultValue([string]$value) {
        $this.InputValue = $value
        $this.DefaultValue = $value
        $this.CursorPosition = $value.Length
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSubmitAction) {
            $value = $this.InputValue
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnSubmit" -ScriptBlock {
                & $this.OnSubmitAction -Value $value
            }.GetNewClosure()
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Progress Dialog
class ProgressDialog : Dialog {
    [int] $PercentComplete = 0
    [bool] $ShowCancel = $false
    [bool] $IsCancelled = $false
    
    ProgressDialog([string]$title, [string]$message) : base("ProgressDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Width = 60
        $this.Height = 8
    }
    
    hidden [void] _RenderDialogContent() {
        # Render progress bar
        $barY = $this.Y + 4
        $barWidth = $this.Width - 4
        $filledWidth = [Math]::Floor($barWidth * ($this.PercentComplete / 100.0))
        
        # Draw bar background
        Write-BufferString -X ($this.X + 2) -Y $barY -Text ("─" * $barWidth) -ForegroundColor ([ConsoleColor]::DarkGray)
        
        # Draw filled portion
        if ($filledWidth -gt 0) {
            Write-BufferString -X ($this.X + 2) -Y $barY -Text ("█" * $filledWidth) -ForegroundColor ([ConsoleColor]::Green)
        }
        
        # Draw percentage
        $percentText = "$($this.PercentComplete)%"
        $percentX = $this.X + [Math]::Floor(($this.Width - $percentText.Length) / 2)
        Write-BufferString -X $percentX -Y $barY -Text $percentText -ForegroundColor ([ConsoleColor]::White)
        
        # Draw cancel button if enabled
        if ($this.ShowCancel) {
            $buttonY = $this.Y + $this.Height - 2
            $buttonText = if ($this.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
            $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
        }
    }
    
    [void] UpdateProgress([int]$percent, [string]$message) {
        $this.PercentComplete = [Math]::Min(100, [Math]::Max(0, $percent))
        if (-not [string]::IsNullOrWhiteSpace($message)) {
            $this.Message = $message
        }
        Request-TuiRefresh
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($this.ShowCancel -and -not $this.IsCancelled) {
            if ($key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsCancelled = $true
                Request-TuiRefresh
            }
        }
    }
}

# List Dialog
class ListDialog : Dialog {
    [string[]] $Items = @()
    [int] $SelectedIndex = 0
    [bool] $AllowMultiple = $false
    [System.Collections.Generic.HashSet[int]] $SelectedItems
    [scriptblock] $OnSelectAction
    [scriptblock] $OnCancelAction
    
    ListDialog([string]$title, [string]$prompt, [string[]]$items, [scriptblock]$onSelect, [scriptblock]$onCancel) : base("ListDialog") {
        $this.Title = $title
        $this.Message = $prompt
        $this.Items = $items
        $this.OnSelectAction = $onSelect
        $this.OnCancelAction = $onCancel
        $this.Width = 60
        $this.Height = [Math]::Min(20, $items.Count + 8)
        $this.SelectedItems = [System.Collections.Generic.HashSet[int]]::new()
    }
    
    hidden [void] _RenderDialogContent() {
        $listY = $this.Y + 4
        $listHeight = $this.Height - 7
        $listWidth = $this.Width - 4
        
        # Calculate visible range with scrolling
        $startIndex = [Math]::Max(0, $this.SelectedIndex - [Math]::Floor($listHeight / 2))
        $endIndex = [Math]::Min($this.Items.Count - 1, $startIndex + $listHeight - 1)
        
        # Render items
        for ($i = $startIndex; $i -le $endIndex; $i++) {
            $itemY = $listY + ($i - $startIndex)
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex)
            $isChecked = $this.SelectedItems.Contains($i)
            
            $prefix = if ($this.AllowMultiple) {
                if ($isChecked) { "[X] " } else { "[ ] " }
            } else { "" }
            
            $itemText = "$prefix$item"
            if ($itemText.Length -gt $listWidth - 2) {
                $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
            }
            
            $bgColor = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            $fgColor = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::Gray }
            
            # Clear the line first
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text (" " * ($listWidth - 2)) -BackgroundColor $bgColor
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text $itemText -ForegroundColor $fgColor -BackgroundColor $bgColor
        }
        
        # Render scrollbar if needed
        if ($this.Items.Count -gt $listHeight) {
            $scrollbarX = $this.X + $this.Width - 2
            $scrollbarHeight = $listHeight
            $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $this.Items.Count))
            $thumbPos = [Math]::Floor($scrollbarHeight * $this.SelectedIndex / $this.Items.Count)
            
            for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char -ForegroundColor ([ConsoleColor]::DarkGray)
            }
        }
        
        # Render buttons for multi-select
        if ($this.AllowMultiple) {
            $buttonY = $this.Y + $this.Height - 2
            $okText = "[ OK ]"
            $cancelText = "[ Cancel ]"
            $buttonSpacing = 15
            $totalWidth = 30
            $startX = $this.X + [Math]::Floor(($this.Width - $totalWidth) / 2)
            
            Write-BufferString -X $startX -Y $buttonY -Text $okText -ForegroundColor ([ConsoleColor]::Green)
            Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor ([ConsoleColor]::Gray)
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::DownArrow) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Spacebar) {
                if ($this.AllowMultiple) {
                    if ($this.SelectedItems.Contains($this.SelectedIndex)) {
                        [void]$this.SelectedItems.Remove($this.SelectedIndex)
                    } else {
                        [void]$this.SelectedItems.Add($this.SelectedIndex)
                    }
                    Request-TuiRefresh
                }
            }
            ([ConsoleKey]::Enter) {
                $this.OnConfirm()
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
            }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSelectAction) {
            if ($this.AllowMultiple) {
                $selectedValues = @($this.SelectedItems | ForEach-Object { $this.Items[$_] })
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selectedValues
                }.GetNewClosure()
            } else {
                $selected = $this.Items[$this.SelectedIndex]
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selected
                }.GetNewClosure()
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ListDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Dialog State Management
$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

# Public API Functions
function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        # Subscribe to dialog events
        Subscribe-Event -EventName "Confirm.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-ConfirmDialog -Title $params.Title -Message $params.Message `
                -OnConfirm $params.OnConfirm -OnCancel $params.OnCancel
        }
        
        Subscribe-Event -EventName "Alert.Show" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-AlertDialog -Title $params.Title -Message $params.Message
        }
        
        Subscribe-Event -EventName "Input.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-InputDialog -Title $params.Title -Prompt $params.Prompt `
                -DefaultValue $params.DefaultValue -OnSubmit $params.OnSubmit -OnCancel $params.OnCancel
        }
        
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

function Show-AlertDialog {
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock {
        $dialog = [AlertDialog]::new($Title, $Message)
        $dialog.Show()
    }
}

function Show-ConfirmDialog {
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock {
        $dialog = [ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)
        $dialog.Show()
    }
}

function Show-InputDialog {
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock {
        $dialog = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel)
        if ($DefaultValue) {
            $dialog.SetDefaultValue($DefaultValue)
        }
        $dialog.Show()
    }
}

function Show-ProgressDialog {
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock {
        $dialog = [ProgressDialog]::new($Title, $Message)
        $dialog.PercentComplete = $PercentComplete
        $dialog.ShowCancel = $ShowCancel
        $dialog.Show()
        return $dialog
    }
}

function Show-ListDialog {
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [string[]]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock {
        $dialog = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel)
        $dialog.AllowMultiple = $AllowMultiple
        $dialog.Show()
    }
}

function Close-TuiDialog {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.CurrentDialog.Close()
        }
    }
}

Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-AlertDialog',
    'Show-ConfirmDialog', 
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Close-TuiDialog'
) -Variable @()



####\refactor_checkpoints\checkpoint_20250629_210720_phase-1-complete\modules\tui-engine.psm1
# TUI Engine v5.1 - NCurses Compositor Edition
# Implements NCurses-style compositor with private buffers and TuiCell rendering

using module .\components\tui-primitives.psm1

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    CompositorBuffer = $null    # AI: NEW - Master compositor buffer (TuiBuffer)
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
    CompositorMode  = $true     # AI: NEW - Enable NCurses-style rendering
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.1 (NCurses Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        # AI: ENHANCED - Create both legacy buffers and new TuiBuffer compositor
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        
        # Initialize legacy buffers for compatibility
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height; CompositorMode = $global:TuiState.CompositorMode }
        Write-Log -Level Info -Message "TUI Engine v5.1 initialized successfully (Compositor Mode: $($global:TuiState.CompositorMode))"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent) {
        try { 
            # AI: ENHANCED - Better class detection for UIElement-based components
            if ($focusedComponent -is [UIElement]) {
                # New UIElement-based component
                $focusedComponent.HandleInput($keyInfo)
            }
            elseif ($focusedComponent.PSObject.TypeNames -contains 'UIElement' -or $focusedComponent.GetType().IsSubclassOf([UIElement])) {
                # Class-based component (legacy detection)
                if ($focusedComponent.PSObject.Methods.Name -contains 'HandleInput') {
                    $focusedComponent.HandleInput($keyInfo)
                }
            }
            elseif ($focusedComponent.HandleInput) {
                # Functional component with HandleInput scriptblock
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return }
            }
        } catch { 
            Write-Warning "Component input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for component '$($focusedComponent.Name)': $_"
        }
    }
    
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            # AI: ENHANCED - Support for UIElement-based screens
            if ($currentScreen -is [UIElement]) {
                # New UIElement-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen -is [Screen]) {
                # Legacy class-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen.HandleInput) {
                # Hashtable/functional screen - use scriptblock invocation
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { Stop-TuiEngine }
                }
            }
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([object]$InitialScreen)  # AI: Accept both UIElement and hashtable screens
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

# AI: REWRITTEN - NCurses Compositor Render-Frame
function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        if ($global:TuiState.CompositorMode -and $null -ne $global:TuiState.CompositorBuffer) {
            # AI: NEW - NCurses-style compositor rendering
            Render-FrameCompositor
        } else {
            # AI: LEGACY - Fall back to old rendering for compatibility
            Render-FrameLegacy
        }
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    # AI: NEW - NCurses-style compositor rendering pipeline
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                if ($global:TuiState.CurrentScreen -is [UIElement]) {
                    # New UIElement-based screen - render to its private buffer
                    $global:TuiState.CurrentScreen.Render()
                    
                    # Composite screen buffer onto master compositor
                    $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                    if ($null -ne $screenBuffer) {
                        $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                    }
                } else {
                    # Legacy screen - render directly (will be deprecated)
                    $global:TuiState.CurrentScreen.Render()
                }
            }
        }
        
        # 3. Render dialogs on top
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog -is [UIElement]) {
                    # New UIElement-based dialog
                    $dialog.Render()
                    $dialogBuffer = $dialog.GetBuffer()
                    if ($null -ne $dialogBuffer) {
                        $pos = $dialog.GetAbsolutePosition()
                        $global:TuiState.CompositorBuffer.BlendBuffer($dialogBuffer, $pos.X, $pos.Y)
                    }
                } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                    # Class-based dialog with Render() method
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    # Functional/hashtable dialog with Render scriptblock
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
        # Fall back to legacy rendering
        Render-FrameLegacy
    }
}

function Render-CompositorToConsole {
    # AI: NEW - Convert TuiBuffer to optimized console output
    $outputBuilder = [System.Text.StringBuilder]::new(20000)
    $lastFG = -1
    $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1
    
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $rowChanged = $false
            $rowOutput = [System.Text.StringBuilder]::new()
            
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $newCell = $global:TuiState.CompositorBuffer.GetCell($x, $y)
                $oldLegacyCell = $global:TuiState.FrontBuffer[$y, $x]
                
                # Convert TuiCell to legacy format for comparison
                $newLegacyCell = $newCell.ToLegacyFormat()
                
                # Check if cell changed
                if ($forceFullRender -or 
                    $newLegacyCell.Char -ne $oldLegacyCell.Char -or
                    $newLegacyCell.FG -ne $oldLegacyCell.FG -or
                    $newLegacyCell.BG -ne $oldLegacyCell.BG) {
                    
                    $rowChanged = $true
                    
                    # Update front buffer
                    $global:TuiState.FrontBuffer[$y, $x] = $newLegacyCell
                    
                    # Add color codes if needed
                    if ($newLegacyCell.FG -ne $lastFG -or $newLegacyCell.BG -ne $lastBG) {
                        $fgCode = Get-AnsiColorCode $newLegacyCell.FG
                        $bgCode = Get-AnsiColorCode $newLegacyCell.BG -IsBackground $true
                        [void]$rowOutput.Append("`e[${fgCode};${bgCode}m")
                        $lastFG = $newLegacyCell.FG
                        $lastBG = $newLegacyCell.BG
                    }
                    
                    [void]$rowOutput.Append($newLegacyCell.Char)
                } else {
                    # Cell unchanged - add placeholder for position tracking
                    [void]$rowOutput.Append($null)
                }
            }
            
            # Output the row if it changed
            if ($rowChanged) {
                [void]$outputBuilder.Append("`e[$($y + 1);1H")
                $rowStr = $rowOutput.ToString() -replace [char]0, ''
                [void]$outputBuilder.Append($rowStr)
            }
        }
        
        [void]$outputBuilder.Append("`e[0m")
        
        if ($outputBuilder.Length -gt 10) {  # Only output if there are substantial changes
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Render-FrameLegacy {
    # AI: LEGACY - Original rendering code for compatibility
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component $global:TuiState.CurrentScreen.Name -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
            }
        }
        
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog.GetType().IsSubclassOf([UIElement]) -or $dialog -is [UIElement]) {
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        Render-BufferOptimized
        
    } catch {
        Write-Log -Level Error -Message "Legacy rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    # AI: ENHANCED - Accept both UIElement and legacy screen objects
    param([object]$Screen)
    if (-not $Screen) { return }
    
    $screenName = if ($Screen -is [UIElement]) { $Screen.Name } elseif ($Screen -is [Screen]) { $Screen.Name } else { $Screen.Name }
    Write-Log -Level Debug -Message "Pushing screen: $screenName"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($global:TuiState.CurrentScreen) {
            # Handle exit for current screen
            if ($global:TuiState.CurrentScreen -is [UIElement]) {
                # New UIElement-based screen
                # No explicit OnExit method - handled by framework
            } elseif ($global:TuiState.CurrentScreen -is [Screen]) {
                # Legacy class-based screen
                $global:TuiState.CurrentScreen.OnExit()
            } elseif ($global:TuiState.CurrentScreen.OnExit) {
                # Functional screen
                $global:TuiState.CurrentScreen.OnExit.Invoke()
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # Initialize new screen
        if ($Screen -is [UIElement]) {
            # New UIElement-based screen - ensure it's sized to fit screen
            if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) {  # Default size
                $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            }
            # Trigger initial render
            $Screen.RequestRedraw()
        } elseif ($Screen -is [Screen]) {
            # Legacy class-based screen
            $Screen.OnEnter()
        } elseif ($Screen.Init) { 
            # Functional screen
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $screenName }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$screenName': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $global:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering - Legacy Support
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:TuiState.BufferWidth) { break }
        if ($currentX -ge 0) { $global:TuiState.BackBuffer[$Y, $currentX] = @{ Char = $char; FG = $ForegroundColor; BG = $BackgroundColor } }
        $currentX++
    }
}

function Write-BufferBox {
    param([int]$X, [int]$Y, [int]$Width, [int]$Height, [string]$BorderStyle = "Single", [ConsoleColor]$BorderColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, [string]$Title = "")
    $borders = Get-BorderChars -Style $BorderStyle
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    if ($Title) {
        $titleText = " $Title "; if ($titleText.Length -gt ($Width-2)) { $titleText = " $($Title.Substring(0,[Math]::Max(0,$Width-5)))... " }
        Write-BufferString -X ($X + [Math]::Floor(($Width - $titleText.Length) / 2)) -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function Render-BufferOptimized {
    $outputBuilder = [System.Text.StringBuilder]::new(20000); $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 0
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $backCell = $global:TuiState.BackBuffer[$y, $x]; $frontCell = $global:TuiState.FrontBuffer[$y, $x]
                if (-not $forceFullRender -and $backCell.Char -eq $frontCell.Char -and $backCell.FG -eq $frontCell.FG -and $backCell.BG -eq $frontCell.BG) { continue }
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) { $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null }
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG; $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null; $lastFG = $backCell.FG; $lastBG = $backCell.BG
                }
                $outputBuilder.Append($backCell.Char) | Out-Null
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = $backCell.Char; FG = $backCell.FG; BG = $backCell.BG }
            }
        }
        $outputBuilder.Append("`e[0m") | Out-Null
        if ($outputBuilder.Length -gt 0) { [Console]::Write($outputBuilder.ToString()) }
    } catch { Write-Warning "Render error: $_" }
}
#endregion

#region Component System - Enhanced for UIElement
function Initialize-ComponentSystem { $global:TuiState.Components = @(); $global:TuiState.FocusedComponent = $null }

function Register-Component { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    $global:TuiState.Components += $Component
    
    # Initialize component based on type
    if ($Component -is [UIElement]) {
        # New UIElement-based component - no explicit init needed
        Write-Log -Level Debug -Message "Registered UIElement component: $($Component.Name)"
    } elseif ($Component.Init) { 
        try { & $Component.Init -self $Component } catch { Write-Warning "Component init error: $_" } 
    }
    return $Component 
}

function Set-ComponentFocus { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) { return }
    
    # Blur current component
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    
    # Set new focused component
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    
    # Focus new component
    if ($null -ne $Component) {
        if ($Component -is [UIElement]) {
            $Component.OnFocus()
        } else {
            $Component.OnFocus?.Invoke()
        }
    }
    
    Request-TuiRefresh 
}

function Clear-ComponentFocus { 
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    $global:TuiState.FocusedComponent = $null
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $null }
    Request-TuiRefresh 
}

# AI: ENHANCED - Support UIElement focusable detection
function Get-NextFocusableComponent { 
    param([object]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = @()
    
    function Find-Focusable([object]$Comp) { 
        if ($Comp -is [UIElement]) {
            # New UIElement-based component
            if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
                $focusableComponents += $Comp
            }
            # Check children
            foreach ($child in $Comp.Children) {
                Find-Focusable $child
            }
        } else {
            # Legacy component
            if ($Comp.IsFocusable -eq $true -and $Comp.Visible -ne $false) { 
                $focusableComponents += $Comp 
            }
            if ($Comp.Children) { 
                foreach ($c in $Comp.Children) { Find-Focusable $c } 
            }
        }
    }
    
    # Find focusable components in current screen
    if ($global:TuiState.CurrentScreen -is [UIElement]) {
        Find-Focusable $global:TuiState.CurrentScreen
    } elseif ($global:TuiState.CurrentScreen.Components) { 
        foreach ($c in $global:TuiState.CurrentScreen.Components.Values) { Find-Focusable $c } 
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by tab index and position
    $sorted = $focusableComponents | Sort-Object { 
        if ($_ -is [UIElement]) {
            $_.TabIndex * 10000 + $_.Y * 100 + $_.X
        } else {
            ($_.TabIndex ?? 0) * 10000 + ($_.Y ?? 0) * 100 + ($_.X ?? 0)
        }
    }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Handle-TabNavigation { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

# AI: LEGACY - Helper functions maintained for compatibility
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Move-Focus { param([bool]$Reverse = $false); Handle-TabNavigation -Reverse $Reverse }

function Get-CurrentDialog {
    try {
        if (Get-Module -Name 'dialog-system-class' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system-class') { $script:DialogState.CurrentDialog }
        } elseif (Get-Module -Name 'dialog-system' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system') { $script:DialogState.CurrentDialog }
        }
    } catch {
        Write-Log -Level Warning -Message "Error accessing dialog system: $_"
    }
    return $null
}

function Handle-DialogInput {
    param([System.ConsoleKeyInfo]$Key)
    try {
        $dialog = Get-CurrentDialog
        if ($dialog) {
            if ($dialog -is [UIElement]) {
                # New UIElement-based dialog
                return $dialog.HandleInput($Key)
            } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                # Legacy class-based dialog
                $dialog.HandleInput($Key)
                return $true
            } elseif ($dialog -is [hashtable] -and $dialog.HandleInput) {
                # Functional dialog
                return & $dialog.HandleInput -self $dialog -Key $Key
            }
        }
    } catch {
        Write-Log -Level Warning -Message "Error handling dialog input: $_"
    }
    return $false
}

function Update-DialogSystem {
    # Dialog system handles its own updates if loaded
}

function Stop-AllTuiAsyncJobs {
    Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)"
}
#endregion

#region Layout Management & Utilities
function Initialize-LayoutEngines { $global:TuiState.Layouts = @{} }
function Get-BorderChars { param([string]$Style); $styles = @{ Single=@{TopLeft='┌';TopRight='┐';BottomLeft='└';BottomRight='┘';Horizontal='─';Vertical='│'}; Double=@{TopLeft='╔';TopRight='╗';BottomLeft='╚';BottomRight='╝';Horizontal='═';Vertical='║'}; Rounded=@{TopLeft='╭';TopRight='╮';BottomLeft='╰';BottomRight='╯';Horizontal='─';Vertical='│'} }; return $styles[$Style] ?? $styles.Single }
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Get-WordWrappedLines { param([string]$Text, [int]$MaxWidth); if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }; $lines = @(); $words = $Text -split '\s+'; $sb = [System.Text.StringBuilder]::new(); foreach ($word in $words) { if ($sb.Length -eq 0) { [void]$sb.Append($word) } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) { [void]$sb.Append(' ').Append($word) } else { $lines += $sb.ToString(); [void]$sb.Clear().Append($word) } }; if ($sb.Length -gt 0) { $lines += $sb.ToString() }; return $lines }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }

# AI: NEW - Compositor helper functions
function Get-ThemeColor {
    param([string]$ColorName)
    # Simple theme color mapping - can be enhanced later
    $themeColors = @{
        Background = [ConsoleColor]::Black
        Foreground = [ConsoleColor]::White
        Border = [ConsoleColor]::Gray
        Focus = [ConsoleColor]::Cyan
        Highlight = [ConsoleColor]::Yellow
    }
    return $themeColors[$ColorName] ?? [ConsoleColor]::Black
}
#endregion

Export-ModuleMember -Function 'Initialize-TuiEngine', 'Start-TuiLoop', 'Stop-TuiEngine', 'Push-Screen', 'Pop-Screen', 'Request-TuiRefresh', 'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer', 'Get-BorderChars', 'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 'Get-NextFocusableComponent', 'Handle-TabNavigation', 'Get-WordWrappedLines', 'Get-FocusedComponent', 'Move-Focus', 'Get-CurrentDialog', 'Handle-DialogInput', 'Update-DialogSystem', 'Stop-AllTuiAsyncJobs', 'Get-ThemeColor' -Variable 'TuiState'


####\refactor_checkpoints\checkpoint_20250629_210720_phase-1-complete\screens\task-list-screen.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Task List Screen
# Displays and manages tasks.
# ==============================================================================

# AI: CRITICAL FIX - Import models module for TaskStatus enum and other types
using module '..\modules\models.psm1'

# AI: FIX - Use relative paths for better portability
using module '..\components\ui-classes.psm1'
using module '..\layout\panels-class.psm1'
using module '..\components\advanced-data-components.psm1'
using module '..\modules\dialog-system-class.psm1'

class TaskListScreen : Screen {
    # --- UI Components ---
    [BorderPanel] $MainPanel
    [Table] $TaskTable
    [ContentPanel] $NavPanel

    # --- State ---
    [string] $FilterStatus = "All"

    TaskListScreen([hashtable]$services) : base("TaskListScreen", $services) { }

    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # --- Panel Setup ---
            $this.MainPanel = [BorderPanel]::new("TaskListMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "Task List"
            $this.AddPanel($this.MainPanel)

            # --- Task Table ---
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.SetColumns(@(
                [TableColumn]::new("Title", "Task Title", 50),
                [TableColumn]::new("Status", "Status", 15),
                [TableColumn]::new("Priority", "Priority", 12),
                [TableColumn]::new("DueDate", "Due Date", 15)
            ))
            
            $tableContainer = [BorderPanel]::new("TableContainer", 1, 1, 118, 24)
            $tableContainer.ShowBorder = $false
            $tableContainer.AddChild($this.TaskTable)
            $this.MainPanel.AddChild($tableContainer)
            
            # --- Navigation Panel ---
            $this.NavPanel = [ContentPanel]::new("NavPanel", 1, 26, 118, 3)
            $this.MainPanel.AddChild($this.NavPanel)
            
            # --- Event Subscriptions & Data Load ---
            $this.SubscribeToEvent("Tasks.Changed", { $this.RefreshData() })
            $this.RefreshData()
        }
    }

    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            $allTasks = @($this.Services.DataManager.GetTasks())
            $filteredTasks = switch ($this.FilterStatus) {
                "Active" { $allTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed } }
                "Completed" { $allTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed } }
                default { $allTasks }
            }
            $this.TaskTable.SetData($filteredTasks)
            $this.UpdateNavText()
        }
    }

    hidden [void] UpdateNavText() {
        $navContent = @(
            "[N]ew | [E]dit | [D]elete | [Space]Toggle | [F]ilter: $($this.FilterStatus) | [Esc]Back"
        )
        $this.NavPanel.SetContent($navContent)
    }

    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) { $this.TaskTable.SelectPrevious() }
                ([ConsoleKey]::DownArrow) { $this.TaskTable.SelectNext() }
                ([ConsoleKey]::Spacebar) { $this.ToggleSelectedTask() }
                ([ConsoleKey]::Escape) { $this.Services.Navigation.PopScreen() }
                default {
                    switch ($key.KeyChar.ToString().ToUpper()) {
                        'N' { $this.ShowNewTaskDialog() }
                        'E' { $this.EditSelectedTask() }
                        'D' { $this.DeleteSelectedTask() }
                        'F' { $this.CycleFilter() }
                    }
                }
            }
        }
    }
    
    hidden [void] ToggleSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            # AI: FIX - TaskStatus enum should now be available from models.psm1 import
            if ($task.Status -eq [TaskStatus]::Completed) {
                $task.Status = [TaskStatus]::Pending
            } else {
                $task.Complete()
            }
            $this.Services.DataManager.UpdateTask($task)
        }
    }

    hidden [void] ShowNewTaskDialog() {
        # AI: FIX - Implemented new task dialog functionality
        Write-Log -Level Info -Message "New task dialog requested"
        
        # AI: FIX - Capture $this context for closure
        $dataManager = $this.Services.DataManager
        $refreshCallback = { $this.RefreshData() }.GetNewClosure()
        
        # Use the input dialog from dialog system
        Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {
            param($Value)
            if (-not [string]::IsNullOrWhiteSpace($Value)) {
                $newTask = $dataManager.AddTask($Value, "", [TaskPriority]::Medium, "General")
                Write-Log -Level Info -Message "Created new task: $($newTask.Title)"
                & $refreshCallback
            }
        }
    }

    hidden [void] EditSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Edit task requested for: $($task.Title)"
        }
    }

    hidden [void] DeleteSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Delete task requested for: $($task.Title)"
        }
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\refactor_checkpoints\checkpoint_20250630_052353_phase-1-verified\components\advanced-data-components.psm1
# Advanced Data Components Module for PMC Terminal v5
# Enhanced data display components with sorting, filtering, and pagination

using namespace System.Text
using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Simple Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

class Table : Component {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    
    Table([string]$name) : base($name) {
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        # AI: FIX - Explicit array initialization
        $this.Data = @()
        $this.SelectedIndex = 0
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
    }
    
    [void] SetData([object[]]$data) {
        # AI: FIX - Defensive array initialization
        $this.Data = if ($null -eq $data) { @() } else { @($data) }
        # AI: FIX - Safe array count check
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -ge $dataCount) {
            $this.SelectedIndex = [Math]::Max(0, $dataCount - 1)
        }
    }
    
    [void] SelectNext() {
        # AI: FIX - Safe array count check
        $dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -lt ($dataCount - 1)) {
            $this.SelectedIndex++
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
        }
    }
    
    [object] GetSelectedItem() {
        # AI: FIX - Safe array access with null checking
        if ($null -eq $this.Data) { return $null }
        
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        
        if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {
            return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }
        }
        return $null
    }
    
    hidden [void] _RenderContent() {
        # AI: Render table to buffer using Write-BufferString
        if (-not (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue)) {
            return # Buffer functions not available
        }
        
        # AI: FIX - Get render position from parent panel if available
        $renderX = 0
        $renderY = 0
        $maxWidth = 120  # Default max width
        
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X
            $renderY = $contentArea.Y
            $maxWidth = $contentArea.Width
        }
        
        $currentY = $renderY
        
        # Header
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            $headerLine = ""
            foreach ($col in $this.Columns) {
                $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                $headerLine += $headerText + " "
            }
            # AI: FIX - Trim header to max width
            if ($headerLine.TrimEnd().Length -gt $maxWidth) {
                $headerLine = $headerLine.Substring(0, $maxWidth)
            }
            Write-BufferString -X $renderX -Y $currentY -Text $headerLine.TrimEnd() -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
            $currentY++
            Write-BufferString -X $renderX -Y $currentY -Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $maxWidth)) -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            $currentY++
        }
        
        # AI: FIX - Safe data array handling
        $dataToRender = @()
        if ($null -ne $this.Data) {
            $dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }
        }
        
        # Data rows
        for ($i = 0; $i -lt $dataToRender.Count; $i++) {
            $row = $dataToRender[$i]
            if ($null -eq $row) { continue }
            
            $rowLine = ""
            $isSelected = ($i -eq $this.SelectedIndex)
            
            foreach ($col in $this.Columns) {
                $cellValue = ""
                if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                    $cellValue = $row[$col.Key]?.ToString() ?? ""
                } elseif ($row.PSObject.Properties[$col.Key]) {
                    $cellValue = $row.($col.Key)?.ToString() ?? ""
                }
                
                $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                $rowLine += $cellText + " "
            }
            
            $finalLine = $rowLine.TrimEnd()
            if ($isSelected) {
                $finalLine = "> $finalLine"
            } else {
                $finalLine = "  $finalLine"
            }
            
            $fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
            $bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            # AI: FIX - Ensure line doesn't exceed parent bounds
            if ($finalLine.Length -gt $maxWidth) {
                $finalLine = $finalLine.Substring(0, $maxWidth)
            }
            Write-BufferString -X $renderX -Y $currentY -Text $finalLine -ForegroundColor $fg -BackgroundColor $bg
            $currentY++
        }
        
        if ($dataToRender.Count -eq 0) {
            Write-BufferString -X $renderX -Y $currentY -Text "  No data to display" -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
        }
    }
}

#endregion

#region Advanced Data Table Class

class DataTableComponent : UIElement {
    # ... (class content is unchanged) ...
    [hashtable[]] $Data = @()
    [hashtable[]] $Columns = @()
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 80
    [int] $Height = 20
    [string] $Title = "Data Table"
    [bool] $ShowBorder = $true
    [bool] $IsFocusable = $true
    [int] $SelectedRow = 0
    [int] $ScrollOffset = 0
    [string] $SortColumn
    [string] $SortDirection = "Ascending"
    [string] $FilterText = ""
    [string] $FilterColumn
    [int] $PageSize = 0  # 0 = auto-calculate
    [int] $CurrentPage = 0
    [bool] $ShowHeader = $true
    [bool] $ShowFooter = $true
    [bool] $ShowRowNumbers = $false
    [bool] $AllowSort = $true
    [bool] $AllowFilter = $true
    [bool] $AllowSelection = $true
    [bool] $MultiSelect = $false
    [int[]] $SelectedRows = @()
    [hashtable[]] $FilteredData = @()
    [hashtable[]] $ProcessedData = @()
    [bool] $FilterMode = $false
    hidden [int] $_lastRenderedWidth = 0
    hidden [int] $_lastRenderedHeight = 0
    
    # Event handlers
    [scriptblock] $OnRowSelect
    [scriptblock] $OnSelectionChange
    
    DataTableComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    DataTableComponent([string]$name, [hashtable[]]$data, [hashtable[]]$columns) : base($name) {
        $this.IsFocusable = $true
        $this.Data = $data
        $this.Columns = $columns
        $this.ProcessData()
    }
    
    [void] ProcessData() {
        Invoke-WithErrorHandling -Component "$($this.Name).ProcessData" -Context "Processing table data" -ScriptBlock {
            # Filter data
            if ([string]::IsNullOrWhiteSpace($this.FilterText)) {
                $this.FilteredData = $this.Data
            } else {
                if ($this.FilterColumn) {
                    # Filter specific column
                    $this.FilteredData = @($this.Data | Where-Object {
                        $value = $_."$($this.FilterColumn)"
                        $value -and $value.ToString() -like "*$($this.FilterText)*"
                    })
                } else {
                    # Filter all columns
                    $this.FilteredData = @($this.Data | Where-Object {
                        $row = $_
                        $matched = $false
                        foreach ($col in $this.Columns) {
                            if ($col.Filterable -ne $false) {
                                $value = $row."$($col.Name)"
                                if ($value -and $value.ToString() -like "*$($this.FilterText)*") {
                                    $matched = $true
                                    break
                                }
                            }
                        }
                        $matched
                    })
                }
            }
            
            # Sort data
            if ($this.SortColumn -and $this.AllowSort) {
                $this.ProcessedData = $this.FilteredData | Sort-Object -Property $this.SortColumn -Descending:($this.SortDirection -eq "Descending")
            } else {
                $this.ProcessedData = $this.FilteredData
            }
            
            # Reset selection if needed
            if ($this.SelectedRow -ge $this.ProcessedData.Count) {
                $this.SelectedRow = [Math]::Max(0, $this.ProcessedData.Count - 1)
            }
            
            # Calculate page size if auto
            if ($this.PageSize -eq 0) {
                $headerLines = $this.ShowHeader ? 3 : 0
                $footerLines = $this.ShowFooter ? 2 : 0
                $filterLines = $this.AllowFilter ? 2 : 0
                $borderAdjust = $this.ShowBorder ? 2 : 0
                $calculatedPageSize = $this.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
                $this.PageSize = [Math]::Max(1, $calculatedPageSize)
            }
            
            # Adjust current page
            $totalPages = [Math]::Ceiling($this.ProcessedData.Count / [Math]::Max(1, $this.PageSize))
            if ($this.CurrentPage -ge $totalPages) {
                $this.CurrentPage = [Math]::Max(0, $totalPages - 1)
            }
        }
    }
    
    [hashtable] GetContentBounds() {
        $borderOffset = $this.ShowBorder ? 1 : 0
        return @{
            X = $this.X + $borderOffset
            Y = $this.Y + $borderOffset
            Width = $this.Width - (2 * $borderOffset)
            Height = $this.Height - (2 * $borderOffset)
        }
    }
    
    hidden [void] _RenderContent() {
        # AI: TEMPORARY - Complex table rendering needs to be rewritten for buffer-based system
        # This is a placeholder until proper buffer rendering is implemented
        if (-not (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue)) {
            return # Buffer functions not available
        }
        
        # Simple placeholder rendering
        Write-BufferString -X ($this.X + 1) -Y ($this.Y + 1) -Text "[DataTable: $($this.Title)]" -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
        
        return # TODO: Implement full buffer-based table rendering
        
        # ORIGINAL COMPLEX RENDERING CODE (commented out for now):
        $renderedContent = [StringBuilder]::new()
        
        # Force ProcessData if dimensions changed
        if ($this._lastRenderedWidth -ne $this.Width -or $this._lastRenderedHeight -ne $this.Height) {
            $this.ProcessData()
            $this._lastRenderedWidth = $this.Width
            $this._lastRenderedHeight = $this.Height
        }
        
        # Calculate content area based on border settings
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        $contentHeight = $this.Height

        if ($this.ShowBorder) {
            $borderColor = ($this.IsFocusable -and $this.IsFocused) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
            
            [void]$renderedContent.Append($this.MoveCursor($this.X, $this.Y))
            [void]$renderedContent.Append($this.SetColor($borderColor))
            [void]$renderedContent.Append($this.RenderBorder($this.Title))
            
            # Adjust content area for border
            $contentX = $this.X + 1
            $contentY = $this.Y + 1
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
        }
        
        $currentY = $contentY
        
        # Filter bar
        if ($this.AllowFilter) {
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::White))
            [void]$renderedContent.Append("Filter: ")
            
            $filterDisplayText = $this.FilterText ? $this.FilterText : "Type to filter..."
            $filterColor = $this.FilterText ? [ConsoleColor]::Yellow : [ConsoleColor]::DarkGray
            [void]$renderedContent.Append($this.SetColor($filterColor))
            [void]$renderedContent.Append($filterDisplayText)
            
            $currentY += 2
        }
        
        # Calculate column widths
        $totalDefinedWidth = ($this.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum ?? 0
        $flexColumns = @($this.Columns | Where-Object { -not $_.Width })
        $columnSeparators = $this.Columns.Count -gt 1 ? $this.Columns.Count - 1 : 0
        $rowNumberWidth = $this.ShowRowNumbers ? 5 : 0
        $remainingWidth = $contentWidth - $totalDefinedWidth - $rowNumberWidth - $columnSeparators
        
        $flexWidth = ($flexColumns.Count -gt 0) ? [Math]::Floor($remainingWidth / $flexColumns.Count) : 0
        
        # Assign calculated widths
        foreach ($col in $this.Columns) {
            $col.CalculatedWidth = $col.Width ?? [Math]::Max(5, $flexWidth)
        }
        
        # Header
        if ($this.ShowHeader) {
            $headerX = $contentX
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append("#".PadRight(4))
                $headerX += 5
            }
            
            foreach ($col in $this.Columns) {
                $headerText = $col.Header ?? $col.Name
                $columnWidth = $col.CalculatedWidth
                
                if ($this.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $this.SortColumn) {
                    $sortIndicator = ($this.SortDirection -eq "Ascending") ? "▲" : "▼"
                    $headerText = "$headerText $sortIndicator"
                }
                
                if ($headerText.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $headerText = $headerText.Substring(0, $maxLength) + "..."
                }
                
                $alignedText = switch ($col.Align) {
                    "Right" { $headerText.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $headerText.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $headerText + " " * $rightPad
                    }
                    default { $headerText.PadRight($columnWidth) }
                }
                
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append($alignedText)
                
                $headerX += $columnWidth + 1
            }
            
            $currentY++
            
            [void]$renderedContent.Append($this.MoveCursor($contentX, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append("─" * $contentWidth)
            $currentY++
        }
        
        # Data rows
        $dataToRender = ($this.ProcessedData.Count -eq 0 -and $this.Data.Count -gt 0) ? $this.Data : $this.ProcessedData
        
        $startIdx = $this.CurrentPage * $this.PageSize
        $endIdx = [Math]::Min($startIdx + $this.PageSize - 1, $dataToRender.Count - 1)
        
        for ($i = $startIdx; $i -le $endIdx; $i++) {
            $row = $dataToRender[$i]
            $rowX = $contentX
            
            $isSelected = $this.MultiSelect ? ($this.SelectedRows -contains $i) : ($i -eq $this.SelectedRow)
            
            $rowBg = $isSelected ? [ConsoleColor]::Cyan : [ConsoleColor]::Black
            $rowFg = $isSelected ? [ConsoleColor]::Black : [ConsoleColor]::White
            
            if ($isSelected) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(" " * $contentWidth)
            }
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(($i + 1).ToString().PadRight(4))
                $rowX += 5
            }
            
            foreach ($col in $this.Columns) {
                $value = $row."$($col.Name)"
                $columnWidth = $col.CalculatedWidth
                
                $displayValue = if ($col.Format -and $value) { & $col.Format $value } else { "$($value)" }
                
                if ($displayValue.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $displayValue = ($maxLength -le 0) ? "..." : ($displayValue.Substring(0, $maxLength) + "...")
                }
                
                $alignedValue = switch ($col.Align) {
                    "Right" { $displayValue.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $displayValue.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $displayValue + " " * $rightPad
                    }
                    default { $displayValue.PadRight($columnWidth) }
                }
                
                $cellFg = if ($col.Color -and -not $isSelected) {
                    Get-ThemeColor (& $col.Color $value $row)
                } else {
                    $rowFg
                }
                
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor($cellFg))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append($alignedValue)
                
                $rowX += $columnWidth + 1
            }
            
            $currentY++
        }
        
        # Empty state
        if ($dataToRender.Count -eq 0) {
            $emptyMessage = $this.FilterText ? "No results match the filter" : "No data to display"
            $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
            $msgY = $contentY + [Math]::Floor($contentHeight / 2)
            [void]$renderedContent.Append($this.MoveCursor($msgX, $msgY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($emptyMessage)
        }
        
        # Footer
        if ($this.ShowFooter) {
            $footerY = $contentY + $contentHeight - 1
            
            $statusText = "$($dataToRender.Count) rows"
            if ($this.FilterText) { $statusText += " (filtered from $($this.Data.Count))" }
            if ($this.MultiSelect) { $statusText += " | $($this.SelectedRows.Count) selected" }
            
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $footerY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($statusText)
            
            if ($dataToRender.Count -gt $this.PageSize) {
                $totalPages = [Math]::Ceiling($dataToRender.Count / [Math]::Max(1, $this.PageSize))
                $pageText = "Page $($this.CurrentPage + 1)/$totalPages"
                [void]$renderedContent.Append($this.MoveCursor($contentX + $contentWidth - $pageText.Length - 1, $footerY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Blue))
                [void]$renderedContent.Append($pageText)
            }
        }
        
        # [void]$renderedContent.Append($this.ResetColor())
        # return $renderedContent.ToString()
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # Filter mode
        if ($key.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($key.Key) {
                ([ConsoleKey]::F) {
                    $this.FilterMode = -not $this.FilterMode
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::S) {
                    if ($this.AllowSort) {
                        $sortableCols = @($this.Columns | Where-Object { $_.Sortable -ne $false })
                        if ($sortableCols.Count -gt 0) {
                            $currentIdx = [array]::IndexOf($sortableCols.Name, $this.SortColumn)
                            $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                            $this.SortColumn = $sortableCols[$nextIdx].Name
                            $this.ProcessData()
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
            }
        }
        
        # Filter text input
        if ($this.FilterMode) {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.FilterMode = $false
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $this.FilterMode = $false
                    $this.ProcessData()
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.FilterText.Length -gt 0) {
                        $this.FilterText = $this.FilterText.Substring(0, $this.FilterText.Length - 1)
                        $this.ProcessData()
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                        $this.FilterText += $key.KeyChar
                        $this.ProcessData()
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            return $false
        }
        
        # Normal navigation
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedRow -gt 0) {
                    $this.SelectedRow--
                    if ($this.SelectedRow -lt ($this.CurrentPage * $this.PageSize)) {
                        $this.CurrentPage--
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedRow -lt ($this.ProcessedData.Count - 1)) {
                    $this.SelectedRow++
                    if ($this.SelectedRow -ge (($this.CurrentPage + 1) * $this.PageSize)) {
                        $this.CurrentPage++
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                if ($this.OnRowSelect -and $this.ProcessedData.Count -gt 0) {
                    $selectedData = $this.MultiSelect ? @($this.SelectedRows | ForEach-Object { $this.ProcessedData[$_] }) : $this.ProcessedData[$this.SelectedRow]
                    & $this.OnRowSelect $selectedData $this.SelectedRow
                }
                return $true
            }
        }
        
        return $false
    }
    
    # AI: Helper methods removed - using buffer-based rendering instead of ANSI
    
    # Public methods
    [void] RefreshData() {
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetData([hashtable[]]$data) {
        $this.Data = $data
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this.ProcessData()
        Request-TuiRefresh
    }
}
#endregion

#region Factory Functions for Backward Compatibility

function New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DataTable_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $data = $Props.Data ?? @()
    $columns = $Props.Columns ?? @()
    
    $table = [DataTableComponent]::new($name, $data, $columns)
    
    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.Title = $Props.Title ?? $table.Title
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader
    $table.ShowFooter = $Props.ShowFooter ?? $table.ShowFooter
    $table.ShowRowNumbers = $Props.ShowRowNumbers ?? $table.ShowRowNumbers
    $table.AllowSort = $Props.AllowSort ?? $table.AllowSort
    $table.AllowFilter = $Props.AllowFilter ?? $table.AllowFilter
    $table.AllowSelection = $Props.AllowSelection ?? $table.AllowSelection
    $table.MultiSelect = $Props.MultiSelect ?? $table.MultiSelect
    $table.Visible = $Props.Visible ?? $table.Visible
    $table.OnRowSelect = $Props.OnRowSelect ?? $table.OnRowSelect
    $table.OnSelectionChange = $Props.OnSelectionChange ?? $table.OnSelectionChange
    
    return $table
}
#endregion

Export-ModuleMember -Function 'New-TuiDataTable'



####\refactor_checkpoints\checkpoint_20250630_052353_phase-1-verified\components\advanced-input-components.psm1
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Value = $Props.Value ?? (Get-Date)
        Mode = $Props.Mode ?? "Date" # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = $Props.Value ?? (Get-Date)
        ViewDate = $Props.Value ?? (Get-Date)
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSelect = $Props.OnSelect
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                # Main container
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Calendar "
                
                # Header with navigation
                $headerY = $self.Y + 1
                $monthYear = $self.ViewDate.ToString("MMMM yyyy")
                $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
                
                Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
                Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
                Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
                
                # Day headers
                $dayHeaderY = $headerY + 2
                $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
                $dayWidth = 4
                $startX = $self.X + 2
                
                for ($i = 0; $i -lt $days.Count; $i++) {
                    Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                        -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
                }
                
                # Calendar grid
                $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
                $startDayOfWeek = [int]$firstDay.DayOfWeek
                $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
                
                $currentDay = 1
                $calendarY = $dayHeaderY + 1
                
                for ($week = 0; $week -lt 6; $week++) {
                    if ($currentDay -gt $daysInMonth) { break }
                    
                    for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                        $x = $startX + ($dayOfWeek * $dayWidth)
                        
                        if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                        
                        if ($currentDay -le $daysInMonth) {
                            $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                         $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                         $self.ViewDate.Year -eq $self.SelectedDate.Year)
                            
                            $isToday = ($currentDay -eq (Get-Date).Day -and 
                                      $self.ViewDate.Month -eq (Get-Date).Month -and 
                                      $self.ViewDate.Year -eq (Get-Date).Year)
                            
                            $fg = if ($isSelected) { Get-ThemeColor "Background" } elseif ($isToday) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                            $bg = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                            
                            $dayText = $currentDay.ToString().PadLeft(2)
                            Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText -ForegroundColor $fg -BackgroundColor $bg
                            
                            $currentDay++
                        }
                    }
                }
                
                # Time picker if in DateTime mode
                if ($self.Mode -eq "DateTime") {
                    $timeY = $self.Y + $self.Height - 2
                    $timeStr = $self.SelectedDate.ToString("HH:mm")
                    Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "CalendarPicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $date = $self.SelectedDate
                $viewDate = $self.ViewDate
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $self.ViewDate = $viewDate.AddMonths(-1) } # Previous month
                        else { $date = $date.AddDays(-1); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } } # Previous day
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $self.ViewDate = $viewDate.AddMonths(1) } # Next month
                        else { $date = $date.AddDays(1); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } } # Next day
                    }
                    ([ConsoleKey]::UpArrow) { $date = $date.AddDays(-7); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(7); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } }
                    ([ConsoleKey]::PageUp) {
                        $self.ViewDate = $viewDate.AddMonths(-1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::PageDown) {
                        $self.ViewDate = $viewDate.AddMonths(1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::Home) { $date = Get-Date; $self.ViewDate = $date }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSelect) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSelect" -ScriptBlock { & $self.OnSelect -Date $date } -AdditionalData @{ Component = $self.Name; SelectedDate = $date }
                        }
                    }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.SelectedDate = $date
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $date } -AdditionalData @{ Component = $self.Name; NewValue = $date }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "CalendarPicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 3
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Type to search..."
        MaxDisplayItems = $Props.MaxDisplayItems ?? 5
        AllowCustomValue = $Props.AllowCustomValue ?? $false
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                # Main dropdown box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                # Display text
                $displayText = ""
                if ($self.IsOpen) {
                    $displayText = $self.SearchText
                    if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                        $displayText = $self.Placeholder
                    }
                } else {
                    if ($self.Value) {
                        $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                        $displayText = $selected ? $selected.Display : $self.Value.ToString()
                    } else {
                        $displayText = "Select..."
                    }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                # Dropdown indicator
                $indicator = $self.IsOpen ? "▲" : "▼"
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator -ForegroundColor $borderColor
                
                # Cursor for search mode
                if ($self.IsOpen -and $self.IsFocused) {
                    $cursorX = $self.X + 2 + $self.SearchText.Length
                    if ($cursorX -lt ($self.X + $self.Width - 3)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Options dropdown
                if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                    $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                    Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $startIdx = ($self.SelectedIndex -ge $self.MaxDisplayItems) ? ($self.SelectedIndex - $self.MaxDisplayItems + 1) : 0
                    $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                    
                    for ($i = $startIdx; $i -le $endIdx; $i++) {
                        $option = $self.FilteredOptions[$i]
                        $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                        
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $fg = $isSelected ? (Get-ThemeColor "Background") : (Get-ThemeColor "Primary")
                        $bg = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                        
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) {
                            $text = $text.Substring(0, $self.Width - 7) + "..."
                        }
                        
                        # Highlight matching text
                        if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                            $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                            if ($matchIndex -ge 0) {
                                if ($matchIndex -gt 0) { Write-BufferString -X ($self.X + 2) -Y $y -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg }
                                Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y -Text $text.Substring($matchIndex, $self.SearchText.Length) -ForegroundColor (Get-ThemeColor "Warning")
                                $afterMatch = $matchIndex + $self.SearchText.Length
                                if ($afterMatch -lt $text.Length) { Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y -Text $text.Substring($afterMatch) -ForegroundColor $fg }
                                continue
                            }
                        }
                        
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                    
                    # Scrollbar if needed
                    if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                        $scrollHeight = $self.MaxDisplayItems
                        $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $char = ($i -eq $scrollPos) ? "█" : "│"
                            $color = ($i -eq $scrollPos) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Subtle")
                            Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        FilterOptions = {
            try {
                $this.FilteredOptions = if ([string]::IsNullOrEmpty($this.SearchText)) {
                    $this.Options
                } else {
                    @($this.Options | Where-Object { $_.Display -like "*$($this.SearchText)*" })
                }
                
                if ($this.AllowCustomValue -and $this.SearchText -and -not ($this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText })) {
                    $this.FilteredOptions = @(@{ Display = $this.SearchText; Value = $this.SearchText; IsCustom = $true }) + $this.FilteredOptions
                }
                
                $this.SelectedIndex = 0
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown FilterOptions error for '$($this.Name)': $_" -Data @{ Component = $this.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        $self.SearchText = ""
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                    return $false
                }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) { $self.IsOpen = $false; $self.SearchText = ""; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Enter) {
                        if ($self.FilteredOptions.Count -gt 0) {
                            $selected = $self.FilteredOptions[$self.SelectedIndex]
                            if ($self.OnChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $selected.Value -Option $selected } -AdditionalData @{ Component = $self.Name; NewValue = $selected.Value; Option = $selected }
                            }
                            $self.Value = $selected.Value
                            $self.IsOpen = $false
                            $self.SearchText = ""
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::UpArrow) { if ($self.SelectedIndex -gt 0) { $self.SelectedIndex--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::DownArrow) { if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) { $self.SelectedIndex++; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Backspace) {
                        if ($self.SearchText.Length -gt 0) {
                            $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                            & $self.FilterOptions
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.SearchText += $Key.KeyChar
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Options = $Props.Options ?? @()
        SelectedValues = $Props.SelectedValues ?? @()
        Title = $Props.Title ?? "Select items"
        AllowSelectAll = $Props.AllowSelectAll ?? $true
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSubmit = $Props.OnSubmit
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor -Title " $($self.Title) "
                
                $currentY = $self.Y + 1
                if ($self.AllowSelectAll) {
                    $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                    $checkbox = $allSelected ? "[X]" : "[ ]"
                    $fg = ($self.SelectedIndex -eq -1) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" -ForegroundColor $fg
                    $currentY += 2
                }
                
                $visibleHeight = $self.Height - 4 - ($self.AllowSelectAll ? 2 : 0)
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.Options[$i]
                    $isChecked = $self.SelectedValues -contains $option.Value
                    $isHighlighted = ($i -eq $self.SelectedIndex)
                    
                    $checkbox = $isChecked ? "[X]" : "[ ]"
                    $fg = $isHighlighted ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                    
                    $text = "$checkbox $($option.Display)"
                    if ($text.Length -gt ($self.Width - 4)) { $text = $text.Substring(0, $self.Width - 7) + "..." }
                    
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                    $currentY++
                }
                
                $statusY = $self.Y + $self.Height - 2
                $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
                Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText -ForegroundColor (Get-ThemeColor "Subtle")
            } catch {
                Write-Log -Level Error -Message "MultiSelect Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) { $self.SelectedIndex = -1 } 
                        elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                            $self.SelectedIndex--
                            if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) { $self.ScrollOffset = $self.SelectedIndex }
                        }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                            $self.SelectedIndex++
                            $visibleHeight = $self.Height - 4 - ($self.AllowSelectAll ? 2 : 0)
                            if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) { $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1 }
                        }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                            $self.SelectedValues = ($self.SelectedValues.Count -eq $self.Options.Count) ? @() : @($self.Options.Value)
                        } elseif ($self.SelectedIndex -ge 0) {
                            $optionValue = $self.Options[$self.SelectedIndex].Value
                            if ($self.SelectedValues -contains $optionValue) {
                                $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $optionValue })
                            } else {
                                $self.SelectedValues += $optionValue
                            }
                        }
                        
                        if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -SelectedValues $self.SelectedValues } }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSubmit) { Invoke-WithErrorHandling -Component "$($self.Name).OnSubmit" -ScriptBlock { & $self.OnSubmit -SelectedValues $self.SelectedValues } }
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "MultiSelect HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Value = $Props.Value ?? 0
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        DecimalPlaces = $Props.DecimalPlaces ?? 0
        IsFocusable = $true
        TextValue = ($Props.Value ?? 0).ToString()
        CursorPosition = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $displayValue = $self.TextValue
                if ($displayValue.Length -gt ($self.Width - 6)) { $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..." }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
                
                if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    if ($cursorX -lt ($self.X + $self.Width - 4)) { Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent") }
                }
                
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" -ForegroundColor $borderColor
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" -ForegroundColor $borderColor
                
                if ($self.Value -le $self.Min) { Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" -ForegroundColor (Get-ThemeColor "Warning") }
                if ($self.Value -ge $self.Max) { Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" -ForegroundColor (Get-ThemeColor "Warning") }
            } catch { Write-Log -Level Error -Message "NumberInput Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ } }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                $newValue = ($this.DecimalPlaces -eq 0) ? [Math]::Floor($newValue) : [Math]::Round($newValue, $this.DecimalPlaces)
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) { Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { & $this.OnChange -NewValue $newValue } }
                return $true
            } catch {
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                Write-Log -Level Warning -Message "NumberInput ValidateAndUpdate error for '$($this.Name)': $_" -Data @{ Component = $this.Name; InputText = $this.TextValue; Exception = $_ }
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step); $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)"); $self.CursorPosition = $self.TextValue.Length; if ($self.OnChange) { & $self.OnChange -NewValue $self.Value }; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::DownArrow) { $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step); $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)"); $self.CursorPosition = $self.TextValue.Length; if ($self.OnChange) { & $self.OnChange -NewValue $self.Value }; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::LeftArrow) { if ($self.CursorPosition -gt 0) { $self.CursorPosition--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::RightArrow) { if ($self.CursorPosition -lt $self.TextValue.Length) { $self.CursorPosition++; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Home) { $self.CursorPosition = 0; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::End) { $self.CursorPosition = $self.TextValue.Length; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Backspace) { if ($self.CursorPosition -gt 0) { $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1); $self.CursorPosition--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Delete) { if ($self.CursorPosition -lt $self.TextValue.Length) { $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1); Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Enter) { & $self.ValidateAndUpdate -self $self; Request-TuiRefresh; return $true }
                    default {
                        if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                            $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch { Write-Log -Level Error -Message "NumberInput HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ } }
            return $false
        }
    }
    
    return $component
}

function New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 1
        Value = $Props.Value ?? 50
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        ShowValue = $Props.ShowValue ?? $true
        IsFocusable = $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $fg = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                
                $range = $self.Max - $self.Min
                $percent = ($self.Value - $self.Min) / $range
                $trackWidth = $self.Width - 2
                $thumbPos = [Math]::Floor($trackWidth * $percent)
                
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text ("─" * $trackWidth) -ForegroundColor (Get-ThemeColor "Subtle")
                if ($thumbPos -gt 0) { Write-BufferString -X ($self.X + 1) -Y $self.Y -Text ("═" * $thumbPos) -ForegroundColor $fg }
                
                Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
                Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
                Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
                
                if ($self.ShowValue) {
                    $valueText = $self.Value.ToString()
                    $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                    Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
                }
            } catch { Write-Log -Level Error -Message "Slider Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ } }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $oldValue = $self.Value
                $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) { $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step) }
                    ([ConsoleKey]::RightArrow) { $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step) }
                    ([ConsoleKey]::Home) { $self.Value = $self.Min }
                    ([ConsoleKey]::End) { $self.Value = $self.Max }
                    ([ConsoleKey]::PageDown) { $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep) }
                    ([ConsoleKey]::PageUp) { $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep) }
                    default { $handled = $false }
                }
                
                if ($handled -and $self.Value -ne $oldValue) {
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $self.Value } }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch { Write-Log -Level Error -Message "Slider HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ } }
            return $false
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function 'New-TuiCalendarPicker', 'New-TuiSearchableDropdown', 'New-TuiMultiSelect', 'New-TuiNumberInput', 'New-TuiSlider'


####\refactor_checkpoints\checkpoint_20250630_052353_phase-1-verified\components\navigation-class.psm1
# Navigation Component Classes Module for PMC Terminal v5
# Implements navigation menu functionality with keyboard shortcuts

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        # Simplified format display without ANSI escape codes
        $display = "[$($this.Key)] "
        
        if ($this.Enabled) {
            $display += $this.Label
        }
        else {
            $display += "$($this.Label) (Disabled)"
        }
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            $display += " - $($this.Description)"
        }
        
        return $display
    }
}

# NavigationMenu - Component for displaying and handling navigation options
class NavigationMenu : Component {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    
    NavigationMenu([string]$name) : base($name) {
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.SelectedIndex = 0
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base($name) {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.SelectedIndex = 0
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) { 
            throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") 
        }
        $this.Items.Add($item)
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { [void]$this.Items.Remove($item) }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { 
                $item.Execute() 
            }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
    }

    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", { 
                    $this.Services.Navigation.GoTo("/tasks", @{mode="new"}) 
                }))
                $this.AddItem([NavigationItem]::new("P", "Projects", { 
                    $this.Services.Navigation.GoTo("/projects", @{}) 
                }))
                $this.AddItem([NavigationItem]::new("S", "Settings", { 
                    $this.Services.Navigation.GoTo("/settings", @{}) 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("Q", "Quit", { 
                    $this.Services.Navigation.RequestExit() 
                }))
            }
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", { 
                    Write-Host "New task not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("E", "Edit", { 
                    Write-Host "Edit not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("D", "Delete", { 
                    Write-Host "Delete not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("F", "Filter", { 
                    Write-Host "Filter not implemented" 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
            }
            default {
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
                $this.AddItem([NavigationItem]::new("H", "Home", { 
                    $this.Services.Navigation.GoTo("/dashboard", @{}) 
                }))
            }
        }
    }
    
    # AI: FIX - Get render coordinates from parent panel
    hidden [hashtable] GetRenderPosition() {
        # Default position if no parent
        $x = 0
        $y = 0
        
        # AI: FIX - If we have a parent Panel, use its content area
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $x = $contentArea.X
            $y = $contentArea.Y
        }
        
        return @{ X = $x; Y = $y }
    }
    
    hidden [void] _RenderContent() {
        # Get visible items
        if ($null -eq $this.Items -or $this.Items.Count -eq 0) {
            return
        }
        
        $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
        if ($visibleItems.Count -eq 0) { return }
        
        if ($this.Orientation -eq "Horizontal") { 
            $this.RenderHorizontal($visibleItems) 
        }
        else { 
            $this.RenderVertical($visibleItems) 
        }
    }
    
    hidden [void] RenderHorizontal([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) {
            return
        }
        
        # AI: FIX - Get proper render position from parent
        $pos = $this.GetRenderPosition()
        
        $menuText = ""
        $isFirst = $true
        foreach ($item in $items) {
            if ($null -eq $item) { continue }
            
            if (-not $isFirst) {
                $menuText += $this.Separator
            }
            $menuText += "[$($item.Key)] $($item.Label)"
            $isFirst = $false
        }
        
        if (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue) {
            Write-BufferString -X $pos.X -Y $pos.Y -Text $menuText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
        }
    }
    
    hidden [void] RenderVertical([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) {
            return
        }
        
        # AI: FIX - Get proper render position from parent
        $pos = $this.GetRenderPosition()
        
        # Ensure SelectedIndex is within bounds
        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {
            $this.SelectedIndex = 0
        }
        
        # AI: FIX - Calculate max width for proper clearing
        $maxWidth = 0
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $maxWidth = $contentArea.Width
        }
        
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($null -eq $item) { continue }
            
            $prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }
            $menuText = "$prefix[$($item.Key)] $($item.Label)"
            
            # AI: FIX - Pad text to clear the full line width
            if ($maxWidth -gt 0 -and $menuText.Length -lt $maxWidth) {
                $menuText = $menuText.PadRight($maxWidth)
            }
            
            if (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue) {
                $fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                    [ConsoleColor]::Black 
                } else { 
                    [ConsoleColor]::White 
                }
                $bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                    [ConsoleColor]::White 
                } else { 
                    [ConsoleColor]::Black 
                }
                
                Write-BufferString -X $pos.X -Y ($pos.Y + $i) -Text $menuText `
                    -ForegroundColor $fg -BackgroundColor $bg
            }
        }
    }
}

Export-ModuleMember -Function @()



####\refactor_checkpoints\checkpoint_20250630_052353_phase-1-verified\components\tui-components.psm1
# TUI Component Library - Phase 1 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

using module ..\components\tui-primitives.psm1

#region Core UI Components

# AI: REFACTORED - LabelComponent now properly inherits from UIElement
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor
    
    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Now renders to parent Panel's buffer instead of direct output
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            $parentPanel = [Panel]$this.Parent
            
            # AI: Calculate position relative to parent's content area
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            # AI: Render to parent's buffer
            $parentPanel.WriteToBuffer($renderX, $renderY, $this.Text, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "Label render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false # Labels don't handle input
    }
}

# AI: REFACTORED - ButtonComponent updated for buffer-based rendering
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick
    
    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
        $this.Text = "Button"
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Buffer-based rendering with parent Panel integration
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            $bgColor = $this.IsPressed ? [ConsoleColor]::Yellow : [ConsoleColor]::Black
            $fgColor = $this.IsPressed ? [ConsoleColor]::Black : $borderColor
            
            # AI: Render border to parent buffer
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, $bgColor)
            
            # AI: Render text centered
            $textX = $renderX + [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = $renderY + [Math]::Floor($this.Height / 2)
            $parentPanel.WriteToBuffer($textX, $textY, $this.Text, $fgColor, $bgColor)
            
        } catch { 
            Write-Log -Level Error -Message "Button render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsPressed = $true
                $this.Parent.RequestRedraw()
                
                if ($this.OnClick) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock { & $this.OnClick }
                }
                
                $this.IsPressed = $false
                $this.Parent.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "Button input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: REFACTORED - TextBoxComponent with buffer-based rendering
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.MaxLength = 100
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Renders to parent Panel buffer
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display text or placeholder
            $displayText = $this.Text ?? ""
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = $this.Placeholder ?? "" 
            }
            
            $maxDisplayLength = $this.Width - 4
            if ($displayText.Length -gt $maxDisplayLength) { 
                $displayText = $displayText.Substring(0, $maxDisplayLength) 
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, [ConsoleColor]::White, [ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $displayText.Length) {
                $cursorX = $textX + $this.CursorPosition
                if ($cursorX < $renderX + $this.Width - 2) {
                    $parentPanel.WriteToBuffer($cursorX, $textY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "TextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition ?? 0
            $originalText = $currentText
            
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $currentText = $currentText.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    } 
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $currentText.Length) { 
                        $currentText = $currentText.Remove($cursorPos, 1) 
                    } 
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- } 
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $currentText.Length) { $cursorPos++ } 
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $currentText.Length }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) { 
                        $currentText = $currentText.Insert($cursorPos, $key.KeyChar)
                        $cursorPos++ 
                    } else { 
                        return $false 
                    }
                }
            }
            
            if ($currentText -ne $originalText -or $cursorPos -ne $this.CursorPosition) {
                $this.Text = $currentText
                $this.CursorPosition = $cursorPos
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $currentText 
                    }
                }
                $this.Parent.RequestRedraw()
            }
            return $true
        } catch { 
            Write-Log -Level Error -Message "TextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
}

# AI: NEW - CheckBoxComponent converted from functional to class-based
class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange
    
    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $checkbox = $this.Checked ? "[X]" : "[ ]"
            $displayText = "$checkbox $($this.Text)"
            
            $parentPanel.WriteToBuffer($renderX, $renderY, $displayText, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "CheckBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Checked = -not $this.Checked
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $this.Checked 
                    } 
                }
                $this.Parent.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "CheckBox input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: NEW - RadioButtonComponent converted from functional to class-based
class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange
    
    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $radio = $this.Selected ? "(●)" : "( )"
            $displayText = "$radio $($this.Text)"
            
            $parentPanel.WriteToBuffer($renderX, $renderY, $displayText, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "RadioButton render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if (-not $this.Selected) {
                    # AI: Unselect other radio buttons in the same group
                    if ($this.Parent -and $this.GroupName) {
                        $siblingRadios = $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        }
                        foreach ($radio in $siblingRadios) {
                            $radio.Selected = $false
                        }
                    }
                    
                    $this.Selected = $true
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $this.Selected 
                        } 
                    }
                    $this.Parent.RequestRedraw()
                }
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "RadioButton input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $label = [LabelComponent]::new($name)
    
    $label.X = $Props.X ?? $label.X
    $label.Y = $Props.Y ?? $label.Y
    $label.Width = $Props.Width ?? $label.Width
    $label.Height = $Props.Height ?? $label.Height
    $label.Visible = $Props.Visible ?? $label.Visible
    $label.ZIndex = $Props.ZIndex ?? $label.ZIndex
    $label.Text = $Props.Text ?? $label.Text
    $label.ForegroundColor = $Props.ForegroundColor ?? $label.ForegroundColor
    
    return $label
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $button = [ButtonComponent]::new($name)
    
    $button.X = $Props.X ?? $button.X
    $button.Y = $Props.Y ?? $button.Y
    $button.Width = $Props.Width ?? $button.Width
    $button.Height = $Props.Height ?? $button.Height
    $button.Visible = $Props.Visible ?? $button.Visible
    $button.ZIndex = $Props.ZIndex ?? $button.ZIndex
    $button.Text = $Props.Text ?? $button.Text
    $button.OnClick = $Props.OnClick ?? $button.OnClick
    
    return $button
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [TextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Text = $Props.Text ?? $textBox.Text
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLength = $Props.MaxLength ?? $textBox.MaxLength
    $textBox.CursorPosition = $Props.CursorPosition ?? $textBox.CursorPosition
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    return $textBox
}

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $checkBox = [CheckBoxComponent]::new($name)
    
    $checkBox.X = $Props.X ?? $checkBox.X
    $checkBox.Y = $Props.Y ?? $checkBox.Y
    $checkBox.Width = $Props.Width ?? $checkBox.Width
    $checkBox.Height = $Props.Height ?? $checkBox.Height
    $checkBox.Visible = $Props.Visible ?? $checkBox.Visible
    $checkBox.ZIndex = $Props.ZIndex ?? $checkBox.ZIndex
    $checkBox.Text = $Props.Text ?? $checkBox.Text
    $checkBox.Checked = $Props.Checked ?? $checkBox.Checked
    $checkBox.OnChange = $Props.OnChange ?? $checkBox.OnChange
    
    return $checkBox
}

function New-TuiRadioButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $radioButton = [RadioButtonComponent]::new($name)
    
    $radioButton.X = $Props.X ?? $radioButton.X
    $radioButton.Y = $Props.Y ?? $radioButton.Y
    $radioButton.Width = $Props.Width ?? $radioButton.Width
    $radioButton.Height = $Props.Height ?? $radioButton.Height
    $radioButton.Visible = $Props.Visible ?? $radioButton.Visible
    $radioButton.ZIndex = $Props.ZIndex ?? $radioButton.ZIndex
    $radioButton.Text = $Props.Text ?? $radioButton.Text
    $radioButton.Selected = $Props.Selected ?? $radioButton.Selected
    $radioButton.GroupName = $Props.GroupName ?? $radioButton.GroupName
    $radioButton.OnChange = $Props.OnChange ?? $radioButton.OnChange
    
    return $radioButton
}

#endregion

Export-ModuleMember -Function 'New-TuiLabel', 'New-TuiButton', 'New-TuiTextBox', 'New-TuiCheckBox', 'New-TuiRadioButton'


####\refactor_checkpoints\checkpoint_20250630_052353_phase-1-verified\components\tui-primitives.psm1
# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations

using namespace System
using namespace System.Management.Automation

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    [ConsoleColor] $ForegroundColor = [ConsoleColor]::White
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = ""
    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() {
        $this.Char = ' '
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Character constructor
    TuiCell([char]$char) {
        $this.Char = $char
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Full constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }

    # Style constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }

    # Copy constructor
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.StyleFlags = $other.StyleFlags
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Create a styled copy
    [TuiCell] WithStyle([ConsoleColor]$fg, [ConsoleColor]$bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    # Create a character copy
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blend this cell with another (higher Z-index wins)
    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return $other }
        if ($other.ZIndex -eq $this.ZIndex -and $other.Char -ne ' ') { return $other }
        return $this
    }

    # Check if this cell differs from another
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic)
    }

    # Generate ANSI escape sequence for this cell
    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Color codes
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append("`e[${fgCode};${bgCode}")
        
        # Style codes
        if ($this.Bold) { [void]$sb.Append(";1") }
        if ($this.Underline) { [void]$sb.Append(";4") }
        if ($this.Italic) { [void]$sb.Append(";3") }
        
        [void]$sb.Append("m").Append($this.Char)
        return $sb.ToString()
    }

    # Convert to legacy buffer format for compatibility
    [hashtable] ToLegacyFormat() {
        return @{
            Char = $this.Char
            FG = $this.ForegroundColor
            BG = $this.BackgroundColor
        }
    }

    # String representation
    [string] ToString() {
        return "TuiCell($($this.Char), $($this.ForegroundColor), $($this.BackgroundColor))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

#region UIElement Base Class - Foundation for All Components
class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer = $null
    [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{}

    # Constructor
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with position and size
    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Buffer")
    }

    # Get absolute screen position
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # Add child component
    [void] AddChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
        }
    }

    # Remove child component
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
            $this.RequestRedraw()
        }
    }

    # Request redraw for this component and parents
    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
    }

    # Resize the component and its buffer
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Resize($newWidth, $newHeight)
        }
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # Move the component
    [void] Move([int]$newX, [int]$newY) {
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
    }

    # Check if point is within component bounds
    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge $this.X -and $x -lt ($this.X + $this.Width) -and 
                $y -ge $this.Y -and $y -lt ($this.Y + $this.Height))
    }

    # Get child at specific point (relative to this component)
    [UIElement] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $this.X, $y - $this.Y)) {
                return $child
            }
        }
        return $null
    }

    # Virtual methods for subclasses to override
    [void] OnRender() {
        # Default implementation - clear buffer
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Override in subclasses
    }

    [void] OnMove([int]$newX, [int]$newY) {
        # Override in subclasses
    }

    [void] OnFocus() {
        # Override in subclasses
    }

    [void] OnBlur() {
        # Override in subclasses
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Override in subclasses - return true if input was handled
        return $false
    }

    # Main render method - calls OnRender and renders children
    [void] Render() {
        if (-not $this.Visible) { return }

        # Render this component to its private buffer
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer) {
                $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }
            
            $this.OnRender()
            $this._needs_redraw = $false
        }

        # Render children to their buffers, then composite onto parent
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
    }

    # Get the final rendered buffer
    [TuiBuffer] GetBuffer() {
        return $this._private_buffer
    }
}
#endregion

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int] GetForegroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()]
    }

    static [int] GetBackgroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()] + 10
    }

    static [string] Reset() {
        return "`e[0m"
    }

    static [string] Bold() {
        return "`e[1m"
    }

    static [string] Underline() {
        return "`e[4m"
    }

    static [string] Italic() {
        return "`e[3m"
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions
function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    
    $cell = [TuiCell]::new(' ', $ForegroundColor, $BackgroundColor)
    $cell.Bold = $Bold
    $cell.Underline = $Underline
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0) {
            $charCell = [TuiCell]::new($cell)
            $charCell.Char = $char
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$BorderStyle = "Single",
        [ConsoleColor]$BorderColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }
    
    $borders = Get-TuiBorderChars -Style $BorderStyle
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Side borders and fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        $currentY = $Y + $i
        
        # Left border
        Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill
        $fillText = ' ' * ($Width - 2)
        Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -BackgroundColor $BackgroundColor
        
        # Right border
        Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $bottomLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all classes and functions
Export-ModuleMember -Function 'Write-TuiText', 'Write-TuiBox', 'Get-TuiBorderChars'


####\refactor_checkpoints\checkpoint_20250630_052353_phase-1-verified\layout\panels-class.psm1
# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

using module .\components\tui-primitives.psm1

#region Panel Class - Basic Layout Container
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds
    [void] Resize([int]$newWidth, [int]$newHeight) {
        ([UIElement]$this).Resize($newWidth, $newHeight)
        $this.UpdateContentBounds()
    }

    # Add child with automatic layout (if enabled)
    [void] AddChild([UIElement]$child) {
        ([UIElement]$this).AddChild($child)
        $this.PerformLayout()
    }

    # Remove child and re-layout
    [void] RemoveChild([UIElement]$child) {
        ([UIElement]$this).RemoveChild($child)
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.Move($this.ContentX, $currentY)
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.Move($currentX, $this.ContentY)
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        # Calculate grid dimensions
        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            # Adjust size for last column/row
            $width = if ($col -eq ($cols - 1)) { 
                $this.ContentX + $this.ContentWidth - $x 
            } else { 
                $cellWidth 
            }
            $height = if ($row -eq ($rows - 1)) { 
                $this.ContentY + $this.ContentHeight - $y 
            } else { 
                $cellHeight 
            }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    # Set border style and update content bounds
    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    # Enable/disable border
    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    # Set title
    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    # Check if point is within content area
    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    # Get content bounds as hashtable
    [hashtable] GetContentBounds() {
        return @{
            X = $this.ContentX
            Y = $this.ContentY
            Width = $this.ContentWidth
            Height = $this.ContentHeight
        }
    }

    # Clear content area only
    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return }

        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    # Main render implementation
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }

        # Clear entire buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this._private_buffer.Clear($bgCell)

        # Draw border if enabled
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }

        # Fill content area
        $this.ClearContent()
    }

    # Override OnResize to update content bounds
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Handle focus for focusable panels
    [void] OnFocus() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Cyan
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Gray
            $this.RequestRedraw()
        }
    }

    # Find first focusable child
    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    # Get all focusable children (recursive)
    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        
        return $focusable
    }

    # Basic input handling - delegate to focused child
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # If this panel can focus and is focused, handle some basic navigation
        if ($this.CanFocus -and $this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        Set-ComponentFocus -Component $firstChild
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        Set-ComponentFocus -Component $firstChild
                        return $true
                    }
                }
            }
        }

        # Delegate to children
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }

        return $false
    }

    # String representation
    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}
#endregion

#region Specialized Panel Types

# Scrollable Panel - supports content larger than visible area
class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    # Constructor
    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    # Set virtual content size
    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        
        # Create virtual buffer if needed
        if ($width -gt 0 -and $height -gt 0) {
            $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        
        $this.RequestRedraw()
    }

    # Scroll to position
    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        
        $this.RequestRedraw()
    }

    # Scroll by delta
    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    # Handle scrolling input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }

        return ([Panel]$this).HandleInput($keyInfo)
    }

    # Render with scrolling support
    [void] OnRender() {
        # Render base panel
        ([Panel]$this).OnRender()

        # Render virtual content if available
        if ($null -ne $this._virtual_buffer) {
            # Create a sub-buffer view of the virtual content
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            
            # Blend visible content onto our buffer
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }

        # Draw scrollbars if enabled and needed
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    # Draw scrollbar indicators
    [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return }

        # Vertical scrollbar
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
        }

        # Horizontal scrollbar
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    # Get virtual content buffer for external drawing
    [TuiBuffer] GetVirtualBuffer() {
        return $this._virtual_buffer
    }
}

# Group Panel - collapsible panel with header
class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    # Toggle collapsed state
    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)  # Just header + border
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        
        # Update child visibility
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        
        $this.RequestRedraw()
    }

    # Handle collapse/expand input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }

        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        
        return $false
    }

    # Render with collapse indicator
    [void] OnRender() {
        ([Panel]$this).OnRender()

        # Draw collapse/expand indicator in title area
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            $this._private_buffer.SetCell(2, 0, $indicatorCell)
        }
    }
}
#endregion

# Export the Panel classes
Export-ModuleMember -Function @()


####\refactor_checkpoints\checkpoint_20250630_052353_phase-1-verified\modules\dialog-system-class.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Base Dialog Class
class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    [int] $Width = 50
    [int] $Height = 10
    [int] $X
    [int] $Y
    [ConsoleColor] $BorderColor = [ConsoleColor]::Cyan
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [ConsoleColor] $MessageColor = [ConsoleColor]::Gray
    
    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    [void] Show() {
        # Calculate centered position
        $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
        $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 2)
        
        # Register with dialog manager
        $script:DialogState.CurrentDialog = $this
        Request-TuiRefresh
    }
    
    [void] Close() {
        $script:DialogState.CurrentDialog = $null
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        }
        Request-TuiRefresh
    }
    
    # Base render draws dialog frame
    hidden [void] _RenderContent() {
        # Draw dialog box
        Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height `
            -Title " $($this.Title) " -BorderColor $this.BorderColor
        
        # Draw message if present
        if (-not [string]::IsNullOrWhiteSpace($this.Message)) {
            $this.RenderMessage()
        }
        
        # Let derived classes render their specific content
        $this._RenderDialogContent()
    }
    
    hidden [void] RenderMessage() {
        $messageY = $this.Y + 2
        $messageX = $this.X + 2
        $maxWidth = $this.Width - 4
        
        $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
        foreach ($line in $wrappedLines) {
            if ($messageY -ge ($this.Y + $this.Height - 3)) { break }
            Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor $this.MessageColor
            $messageY++
        }
    }
    
    # Override in derived classes
    hidden [void] _RenderDialogContent() { }
    
    # Base input handling - ESC closes dialog
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.OnCancel()
        }
    }
    
    # Virtual methods for derived classes
    [void] OnConfirm() { $this.Close() }
    [void] OnCancel() { $this.Close() }
}

# Alert Dialog - Simple OK dialog
class AlertDialog : Dialog {
    [string] $ButtonText = "OK"
    
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 10
        $this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))
    }
    
    hidden [void] _RenderDialogContent() {
        # Render OK button
        $buttonY = $this.Y + $this.Height - 2
        $buttonText = "[ $($this.ButtonText) ]"
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
        
        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) { $this.OnConfirm() }
            ([ConsoleKey]::Spacebar) { $this.OnConfirm() }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
}

# Confirm Dialog - Yes/No dialog
class ConfirmDialog : Dialog {
    [scriptblock] $OnConfirmAction
    [scriptblock] $OnCancelAction
    [string[]] $Buttons = @("Yes", "No")
    [int] $SelectedButton = 0
    
    ConfirmDialog([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) : base("ConfirmDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.OnConfirmAction = $onConfirm
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render buttons
        $buttonY = $this.Y + $this.Height - 3
        $totalButtonWidth = ($this.Buttons.Count * 12) + (($this.Buttons.Count - 1) * 2)
        $buttonX = $this.X + [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        
        for ($i = 0; $i -lt $this.Buttons.Count; $i++) {
            $button = $this.Buttons[$i]
            $isSelected = ($i -eq $this.SelectedButton)
            $buttonText = if ($isSelected) { "[ $button ]" } else { "  $button  " }
            $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
            $buttonX += 14
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) { 
                $this.SelectedButton = [Math]::Max(0, $this.SelectedButton - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::RightArrow) { 
                $this.SelectedButton = [Math]::Min($this.Buttons.Count - 1, $this.SelectedButton + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Tab) { 
                $this.SelectedButton = ($this.SelectedButton + 1) % $this.Buttons.Count
                Request-TuiRefresh
            }
            ([ConsoleKey]::Enter) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Spacebar) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnConfirmAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnConfirm" -ScriptBlock $this.OnConfirmAction
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Input Dialog - Text input dialog
class InputDialog : Dialog {
    [string] $Prompt = ""
    [string] $InputValue = ""
    [string] $DefaultValue = ""
    [scriptblock] $OnSubmitAction
    [scriptblock] $OnCancelAction
    [int] $FocusedElement = 0  # 0=TextBox, 1=OK, 2=Cancel
    [int] $CursorPosition = 0
    
    InputDialog([string]$title, [string]$prompt, [scriptblock]$onSubmit, [scriptblock]$onCancel) : base("InputDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.OnSubmitAction = $onSubmit
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(70, [Math]::Max(50, $prompt.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render prompt
        $promptX = $this.X + 2
        $promptY = $this.Y + 2
        Write-BufferString -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor ([ConsoleColor]::White)
        
        # Render input box
        $inputY = $promptY + 2
        $inputWidth = $this.Width - 4
        $isFocused = ($this.FocusedElement -eq 0)
        $borderColor = if ($isFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::DarkGray }
        
        Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 -BorderColor $borderColor
        
        # Render input text
        $displayText = $this.InputValue
        if ($displayText.Length -gt ($inputWidth - 3)) {
            $displayText = $displayText.Substring(0, $inputWidth - 3)
        }
        Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText -ForegroundColor ([ConsoleColor]::White)
        
        # Show cursor when focused
        if ($isFocused -and $this.CursorPosition -le $displayText.Length) {
            Write-BufferString -X ($promptX + 1 + $this.CursorPosition) -Y ($inputY + 1) `
                -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
        }
        
        # Render buttons
        $buttonY = $this.Y + $this.Height - 2
        $buttonSpacing = 15
        $buttonsWidth = $buttonSpacing * 2
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonsWidth) / 2)
        
        # OK button
        $okFocused = ($this.FocusedElement -eq 1)
        $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
        $okColor = if ($okFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
        
        # Cancel button
        $cancelFocused = ($this.FocusedElement -eq 2)
        $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
        $cancelColor = if ($cancelFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Tab) {
                $direction = if ($key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                $this.FocusedElement = ($this.FocusedElement + $direction + 3) % 3
                Request-TuiRefresh
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
            default {
                switch ($this.FocusedElement) {
                    0 { # TextBox
                        switch ($key.Key) {
                            ([ConsoleKey]::Enter) { $this.OnConfirm() }
                            ([ConsoleKey]::Backspace) {
                                if ($this.InputValue.Length -gt 0 -and $this.CursorPosition -gt 0) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition - 1, 1)
                                    $this.CursorPosition--
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::Delete) {
                                if ($this.CursorPosition -lt $this.InputValue.Length) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition, 1)
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::LeftArrow) {
                                $this.CursorPosition = [Math]::Max(0, $this.CursorPosition - 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::RightArrow) {
                                $this.CursorPosition = [Math]::Min($this.InputValue.Length, $this.CursorPosition + 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::Home) {
                                $this.CursorPosition = 0
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::End) {
                                $this.CursorPosition = $this.InputValue.Length
                                Request-TuiRefresh
                            }
                            default {
                                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                                    $this.InputValue = $this.InputValue.Insert($this.CursorPosition, $key.KeyChar)
                                    $this.CursorPosition++
                                    Request-TuiRefresh
                                }
                            }
                        }
                    }
                    1 { # OK Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnConfirm()
                        }
                    }
                    2 { # Cancel Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnCancel()
                        }
                    }
                }
            }
        }
    }
    
    [void] SetDefaultValue([string]$value) {
        $this.InputValue = $value
        $this.DefaultValue = $value
        $this.CursorPosition = $value.Length
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSubmitAction) {
            $value = $this.InputValue
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnSubmit" -ScriptBlock {
                & $this.OnSubmitAction -Value $value
            }.GetNewClosure()
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Progress Dialog
class ProgressDialog : Dialog {
    [int] $PercentComplete = 0
    [bool] $ShowCancel = $false
    [bool] $IsCancelled = $false
    
    ProgressDialog([string]$title, [string]$message) : base("ProgressDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Width = 60
        $this.Height = 8
    }
    
    hidden [void] _RenderDialogContent() {
        # Render progress bar
        $barY = $this.Y + 4
        $barWidth = $this.Width - 4
        $filledWidth = [Math]::Floor($barWidth * ($this.PercentComplete / 100.0))
        
        # Draw bar background
        Write-BufferString -X ($this.X + 2) -Y $barY -Text ("─" * $barWidth) -ForegroundColor ([ConsoleColor]::DarkGray)
        
        # Draw filled portion
        if ($filledWidth -gt 0) {
            Write-BufferString -X ($this.X + 2) -Y $barY -Text ("█" * $filledWidth) -ForegroundColor ([ConsoleColor]::Green)
        }
        
        # Draw percentage
        $percentText = "$($this.PercentComplete)%"
        $percentX = $this.X + [Math]::Floor(($this.Width - $percentText.Length) / 2)
        Write-BufferString -X $percentX -Y $barY -Text $percentText -ForegroundColor ([ConsoleColor]::White)
        
        # Draw cancel button if enabled
        if ($this.ShowCancel) {
            $buttonY = $this.Y + $this.Height - 2
            $buttonText = if ($this.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
            $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
        }
    }
    
    [void] UpdateProgress([int]$percent, [string]$message) {
        $this.PercentComplete = [Math]::Min(100, [Math]::Max(0, $percent))
        if (-not [string]::IsNullOrWhiteSpace($message)) {
            $this.Message = $message
        }
        Request-TuiRefresh
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($this.ShowCancel -and -not $this.IsCancelled) {
            if ($key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsCancelled = $true
                Request-TuiRefresh
            }
        }
    }
}

# List Dialog
class ListDialog : Dialog {
    [string[]] $Items = @()
    [int] $SelectedIndex = 0
    [bool] $AllowMultiple = $false
    [System.Collections.Generic.HashSet[int]] $SelectedItems
    [scriptblock] $OnSelectAction
    [scriptblock] $OnCancelAction
    
    ListDialog([string]$title, [string]$prompt, [string[]]$items, [scriptblock]$onSelect, [scriptblock]$onCancel) : base("ListDialog") {
        $this.Title = $title
        $this.Message = $prompt
        $this.Items = $items
        $this.OnSelectAction = $onSelect
        $this.OnCancelAction = $onCancel
        $this.Width = 60
        $this.Height = [Math]::Min(20, $items.Count + 8)
        $this.SelectedItems = [System.Collections.Generic.HashSet[int]]::new()
    }
    
    hidden [void] _RenderDialogContent() {
        $listY = $this.Y + 4
        $listHeight = $this.Height - 7
        $listWidth = $this.Width - 4
        
        # Calculate visible range with scrolling
        $startIndex = [Math]::Max(0, $this.SelectedIndex - [Math]::Floor($listHeight / 2))
        $endIndex = [Math]::Min($this.Items.Count - 1, $startIndex + $listHeight - 1)
        
        # Render items
        for ($i = $startIndex; $i -le $endIndex; $i++) {
            $itemY = $listY + ($i - $startIndex)
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex)
            $isChecked = $this.SelectedItems.Contains($i)
            
            $prefix = if ($this.AllowMultiple) {
                if ($isChecked) { "[X] " } else { "[ ] " }
            } else { "" }
            
            $itemText = "$prefix$item"
            if ($itemText.Length -gt $listWidth - 2) {
                $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
            }
            
            $bgColor = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            $fgColor = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::Gray }
            
            # Clear the line first
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text (" " * ($listWidth - 2)) -BackgroundColor $bgColor
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text $itemText -ForegroundColor $fgColor -BackgroundColor $bgColor
        }
        
        # Render scrollbar if needed
        if ($this.Items.Count -gt $listHeight) {
            $scrollbarX = $this.X + $this.Width - 2
            $scrollbarHeight = $listHeight
            $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $this.Items.Count))
            $thumbPos = [Math]::Floor($scrollbarHeight * $this.SelectedIndex / $this.Items.Count)
            
            for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char -ForegroundColor ([ConsoleColor]::DarkGray)
            }
        }
        
        # Render buttons for multi-select
        if ($this.AllowMultiple) {
            $buttonY = $this.Y + $this.Height - 2
            $okText = "[ OK ]"
            $cancelText = "[ Cancel ]"
            $buttonSpacing = 15
            $totalWidth = 30
            $startX = $this.X + [Math]::Floor(($this.Width - $totalWidth) / 2)
            
            Write-BufferString -X $startX -Y $buttonY -Text $okText -ForegroundColor ([ConsoleColor]::Green)
            Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor ([ConsoleColor]::Gray)
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::DownArrow) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Spacebar) {
                if ($this.AllowMultiple) {
                    if ($this.SelectedItems.Contains($this.SelectedIndex)) {
                        [void]$this.SelectedItems.Remove($this.SelectedIndex)
                    } else {
                        [void]$this.SelectedItems.Add($this.SelectedIndex)
                    }
                    Request-TuiRefresh
                }
            }
            ([ConsoleKey]::Enter) {
                $this.OnConfirm()
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
            }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSelectAction) {
            if ($this.AllowMultiple) {
                $selectedValues = @($this.SelectedItems | ForEach-Object { $this.Items[$_] })
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selectedValues
                }.GetNewClosure()
            } else {
                $selected = $this.Items[$this.SelectedIndex]
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selected
                }.GetNewClosure()
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ListDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Dialog State Management
$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

# Public API Functions
function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        # Subscribe to dialog events
        Subscribe-Event -EventName "Confirm.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-ConfirmDialog -Title $params.Title -Message $params.Message `
                -OnConfirm $params.OnConfirm -OnCancel $params.OnCancel
        }
        
        Subscribe-Event -EventName "Alert.Show" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-AlertDialog -Title $params.Title -Message $params.Message
        }
        
        Subscribe-Event -EventName "Input.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-InputDialog -Title $params.Title -Prompt $params.Prompt `
                -DefaultValue $params.DefaultValue -OnSubmit $params.OnSubmit -OnCancel $params.OnCancel
        }
        
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

function Show-AlertDialog {
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock {
        $dialog = [AlertDialog]::new($Title, $Message)
        $dialog.Show()
    }
}

function Show-ConfirmDialog {
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock {
        $dialog = [ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)
        $dialog.Show()
    }
}

function Show-InputDialog {
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock {
        $dialog = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel)
        if ($DefaultValue) {
            $dialog.SetDefaultValue($DefaultValue)
        }
        $dialog.Show()
    }
}

function Show-ProgressDialog {
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock {
        $dialog = [ProgressDialog]::new($Title, $Message)
        $dialog.PercentComplete = $PercentComplete
        $dialog.ShowCancel = $ShowCancel
        $dialog.Show()
        return $dialog
    }
}

function Show-ListDialog {
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [string[]]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock {
        $dialog = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel)
        $dialog.AllowMultiple = $AllowMultiple
        $dialog.Show()
    }
}

function Close-TuiDialog {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.CurrentDialog.Close()
        }
    }
}

Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-AlertDialog',
    'Show-ConfirmDialog', 
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Close-TuiDialog'
) -Variable @()



####\refactor_checkpoints\checkpoint_20250630_052353_phase-1-verified\modules\tui-engine.psm1
# TUI Engine v5.1 - NCurses Compositor Edition
# Implements NCurses-style compositor with private buffers and TuiCell rendering

using module .\components\tui-primitives.psm1

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    CompositorBuffer = $null    # AI: NEW - Master compositor buffer (TuiBuffer)
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
    CompositorMode  = $true     # AI: NEW - Enable NCurses-style rendering
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.1 (NCurses Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        # AI: ENHANCED - Create both legacy buffers and new TuiBuffer compositor
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        
        # Initialize legacy buffers for compatibility
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height; CompositorMode = $global:TuiState.CompositorMode }
        Write-Log -Level Info -Message "TUI Engine v5.1 initialized successfully (Compositor Mode: $($global:TuiState.CompositorMode))"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent) {
        try { 
            # AI: ENHANCED - Better class detection for UIElement-based components
            if ($focusedComponent -is [UIElement]) {
                # New UIElement-based component
                $focusedComponent.HandleInput($keyInfo)
            }
            elseif ($focusedComponent.PSObject.TypeNames -contains 'UIElement' -or $focusedComponent.GetType().IsSubclassOf([UIElement])) {
                # Class-based component (legacy detection)
                if ($focusedComponent.PSObject.Methods.Name -contains 'HandleInput') {
                    $focusedComponent.HandleInput($keyInfo)
                }
            }
            elseif ($focusedComponent.HandleInput) {
                # Functional component with HandleInput scriptblock
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return }
            }
        } catch { 
            Write-Warning "Component input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for component '$($focusedComponent.Name)': $_"
        }
    }
    
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            # AI: ENHANCED - Support for UIElement-based screens
            if ($currentScreen -is [UIElement]) {
                # New UIElement-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen -is [Screen]) {
                # Legacy class-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen.HandleInput) {
                # Hashtable/functional screen - use scriptblock invocation
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { Stop-TuiEngine }
                }
            }
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([object]$InitialScreen)  # AI: Accept both UIElement and hashtable screens
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

# AI: REWRITTEN - NCurses Compositor Render-Frame
function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        if ($global:TuiState.CompositorMode -and $null -ne $global:TuiState.CompositorBuffer) {
            # AI: NEW - NCurses-style compositor rendering
            Render-FrameCompositor
        } else {
            # AI: LEGACY - Fall back to old rendering for compatibility
            Render-FrameLegacy
        }
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    # AI: NEW - NCurses-style compositor rendering pipeline
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                if ($global:TuiState.CurrentScreen -is [UIElement]) {
                    # New UIElement-based screen - render to its private buffer
                    $global:TuiState.CurrentScreen.Render()
                    
                    # Composite screen buffer onto master compositor
                    $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                    if ($null -ne $screenBuffer) {
                        $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                    }
                } else {
                    # Legacy screen - render directly (will be deprecated)
                    $global:TuiState.CurrentScreen.Render()
                }
            }
        }
        
        # 3. Render dialogs on top
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog -is [UIElement]) {
                    # New UIElement-based dialog
                    $dialog.Render()
                    $dialogBuffer = $dialog.GetBuffer()
                    if ($null -ne $dialogBuffer) {
                        $pos = $dialog.GetAbsolutePosition()
                        $global:TuiState.CompositorBuffer.BlendBuffer($dialogBuffer, $pos.X, $pos.Y)
                    }
                } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                    # Class-based dialog with Render() method
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    # Functional/hashtable dialog with Render scriptblock
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
        # Fall back to legacy rendering
        Render-FrameLegacy
    }
}

function Render-CompositorToConsole {
    # AI: NEW - Convert TuiBuffer to optimized console output
    $outputBuilder = [System.Text.StringBuilder]::new(20000)
    $lastFG = -1
    $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1
    
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $rowChanged = $false
            $rowOutput = [System.Text.StringBuilder]::new()
            
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $newCell = $global:TuiState.CompositorBuffer.GetCell($x, $y)
                $oldLegacyCell = $global:TuiState.FrontBuffer[$y, $x]
                
                # Convert TuiCell to legacy format for comparison
                $newLegacyCell = $newCell.ToLegacyFormat()
                
                # Check if cell changed
                if ($forceFullRender -or 
                    $newLegacyCell.Char -ne $oldLegacyCell.Char -or
                    $newLegacyCell.FG -ne $oldLegacyCell.FG -or
                    $newLegacyCell.BG -ne $oldLegacyCell.BG) {
                    
                    $rowChanged = $true
                    
                    # Update front buffer
                    $global:TuiState.FrontBuffer[$y, $x] = $newLegacyCell
                    
                    # Add color codes if needed
                    if ($newLegacyCell.FG -ne $lastFG -or $newLegacyCell.BG -ne $lastBG) {
                        $fgCode = Get-AnsiColorCode $newLegacyCell.FG
                        $bgCode = Get-AnsiColorCode $newLegacyCell.BG -IsBackground $true
                        [void]$rowOutput.Append("`e[${fgCode};${bgCode}m")
                        $lastFG = $newLegacyCell.FG
                        $lastBG = $newLegacyCell.BG
                    }
                    
                    [void]$rowOutput.Append($newLegacyCell.Char)
                } else {
                    # Cell unchanged - add placeholder for position tracking
                    [void]$rowOutput.Append($null)
                }
            }
            
            # Output the row if it changed
            if ($rowChanged) {
                [void]$outputBuilder.Append("`e[$($y + 1);1H")
                $rowStr = $rowOutput.ToString() -replace [char]0, ''
                [void]$outputBuilder.Append($rowStr)
            }
        }
        
        [void]$outputBuilder.Append("`e[0m")
        
        if ($outputBuilder.Length -gt 10) {  # Only output if there are substantial changes
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Render-FrameLegacy {
    # AI: LEGACY - Original rendering code for compatibility
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component $global:TuiState.CurrentScreen.Name -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
            }
        }
        
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog.GetType().IsSubclassOf([UIElement]) -or $dialog -is [UIElement]) {
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        Render-BufferOptimized
        
    } catch {
        Write-Log -Level Error -Message "Legacy rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    # AI: ENHANCED - Accept both UIElement and legacy screen objects
    param([object]$Screen)
    if (-not $Screen) { return }
    
    $screenName = if ($Screen -is [UIElement]) { $Screen.Name } elseif ($Screen -is [Screen]) { $Screen.Name } else { $Screen.Name }
    Write-Log -Level Debug -Message "Pushing screen: $screenName"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($global:TuiState.CurrentScreen) {
            # Handle exit for current screen
            if ($global:TuiState.CurrentScreen -is [UIElement]) {
                # New UIElement-based screen
                # No explicit OnExit method - handled by framework
            } elseif ($global:TuiState.CurrentScreen -is [Screen]) {
                # Legacy class-based screen
                $global:TuiState.CurrentScreen.OnExit()
            } elseif ($global:TuiState.CurrentScreen.OnExit) {
                # Functional screen
                $global:TuiState.CurrentScreen.OnExit.Invoke()
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # Initialize new screen
        if ($Screen -is [UIElement]) {
            # New UIElement-based screen - ensure it's sized to fit screen
            if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) {  # Default size
                $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            }
            # Trigger initial render
            $Screen.RequestRedraw()
        } elseif ($Screen -is [Screen]) {
            # Legacy class-based screen
            $Screen.OnEnter()
        } elseif ($Screen.Init) { 
            # Functional screen
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $screenName }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$screenName': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $global:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering - Legacy Support
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:TuiState.BufferWidth) { break }
        if ($currentX -ge 0) { $global:TuiState.BackBuffer[$Y, $currentX] = @{ Char = $char; FG = $ForegroundColor; BG = $BackgroundColor } }
        $currentX++
    }
}

function Write-BufferBox {
    param([int]$X, [int]$Y, [int]$Width, [int]$Height, [string]$BorderStyle = "Single", [ConsoleColor]$BorderColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, [string]$Title = "")
    $borders = Get-BorderChars -Style $BorderStyle
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    if ($Title) {
        $titleText = " $Title "; if ($titleText.Length -gt ($Width-2)) { $titleText = " $($Title.Substring(0,[Math]::Max(0,$Width-5)))... " }
        Write-BufferString -X ($X + [Math]::Floor(($Width - $titleText.Length) / 2)) -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function Render-BufferOptimized {
    $outputBuilder = [System.Text.StringBuilder]::new(20000); $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 0
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $backCell = $global:TuiState.BackBuffer[$y, $x]; $frontCell = $global:TuiState.FrontBuffer[$y, $x]
                if (-not $forceFullRender -and $backCell.Char -eq $frontCell.Char -and $backCell.FG -eq $frontCell.FG -and $backCell.BG -eq $frontCell.BG) { continue }
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) { $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null }
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG; $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null; $lastFG = $backCell.FG; $lastBG = $backCell.BG
                }
                $outputBuilder.Append($backCell.Char) | Out-Null
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = $backCell.Char; FG = $backCell.FG; BG = $backCell.BG }
            }
        }
        $outputBuilder.Append("`e[0m") | Out-Null
        if ($outputBuilder.Length -gt 0) { [Console]::Write($outputBuilder.ToString()) }
    } catch { Write-Warning "Render error: $_" }
}
#endregion

#region Component System - Enhanced for UIElement
function Initialize-ComponentSystem { $global:TuiState.Components = @(); $global:TuiState.FocusedComponent = $null }

function Register-Component { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    $global:TuiState.Components += $Component
    
    # Initialize component based on type
    if ($Component -is [UIElement]) {
        # New UIElement-based component - no explicit init needed
        Write-Log -Level Debug -Message "Registered UIElement component: $($Component.Name)"
    } elseif ($Component.Init) { 
        try { & $Component.Init -self $Component } catch { Write-Warning "Component init error: $_" } 
    }
    return $Component 
}

function Set-ComponentFocus { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) { return }
    
    # Blur current component
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    
    # Set new focused component
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    
    # Focus new component
    if ($null -ne $Component) {
        if ($Component -is [UIElement]) {
            $Component.OnFocus()
        } else {
            $Component.OnFocus?.Invoke()
        }
    }
    
    Request-TuiRefresh 
}

function Clear-ComponentFocus { 
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    $global:TuiState.FocusedComponent = $null
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $null }
    Request-TuiRefresh 
}

# AI: ENHANCED - Support UIElement focusable detection
function Get-NextFocusableComponent { 
    param([object]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = @()
    
    function Find-Focusable([object]$Comp) { 
        if ($Comp -is [UIElement]) {
            # New UIElement-based component
            if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
                $focusableComponents += $Comp
            }
            # Check children
            foreach ($child in $Comp.Children) {
                Find-Focusable $child
            }
        } else {
            # Legacy component
            if ($Comp.IsFocusable -eq $true -and $Comp.Visible -ne $false) { 
                $focusableComponents += $Comp 
            }
            if ($Comp.Children) { 
                foreach ($c in $Comp.Children) { Find-Focusable $c } 
            }
        }
    }
    
    # Find focusable components in current screen
    if ($global:TuiState.CurrentScreen -is [UIElement]) {
        Find-Focusable $global:TuiState.CurrentScreen
    } elseif ($global:TuiState.CurrentScreen.Components) { 
        foreach ($c in $global:TuiState.CurrentScreen.Components.Values) { Find-Focusable $c } 
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by tab index and position
    $sorted = $focusableComponents | Sort-Object { 
        if ($_ -is [UIElement]) {
            $_.TabIndex * 10000 + $_.Y * 100 + $_.X
        } else {
            ($_.TabIndex ?? 0) * 10000 + ($_.Y ?? 0) * 100 + ($_.X ?? 0)
        }
    }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Handle-TabNavigation { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

# AI: LEGACY - Helper functions maintained for compatibility
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Move-Focus { param([bool]$Reverse = $false); Handle-TabNavigation -Reverse $Reverse }

function Get-CurrentDialog {
    try {
        if (Get-Module -Name 'dialog-system-class' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system-class') { $script:DialogState.CurrentDialog }
        } elseif (Get-Module -Name 'dialog-system' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system') { $script:DialogState.CurrentDialog }
        }
    } catch {
        Write-Log -Level Warning -Message "Error accessing dialog system: $_"
    }
    return $null
}

function Handle-DialogInput {
    param([System.ConsoleKeyInfo]$Key)
    try {
        $dialog = Get-CurrentDialog
        if ($dialog) {
            if ($dialog -is [UIElement]) {
                # New UIElement-based dialog
                return $dialog.HandleInput($Key)
            } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                # Legacy class-based dialog
                $dialog.HandleInput($Key)
                return $true
            } elseif ($dialog -is [hashtable] -and $dialog.HandleInput) {
                # Functional dialog
                return & $dialog.HandleInput -self $dialog -Key $Key
            }
        }
    } catch {
        Write-Log -Level Warning -Message "Error handling dialog input: $_"
    }
    return $false
}

function Update-DialogSystem {
    # Dialog system handles its own updates if loaded
}

function Stop-AllTuiAsyncJobs {
    Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)"
}
#endregion

#region Layout Management & Utilities
function Initialize-LayoutEngines { $global:TuiState.Layouts = @{} }
function Get-BorderChars { param([string]$Style); $styles = @{ Single=@{TopLeft='┌';TopRight='┐';BottomLeft='└';BottomRight='┘';Horizontal='─';Vertical='│'}; Double=@{TopLeft='╔';TopRight='╗';BottomLeft='╚';BottomRight='╝';Horizontal='═';Vertical='║'}; Rounded=@{TopLeft='╭';TopRight='╮';BottomLeft='╰';BottomRight='╯';Horizontal='─';Vertical='│'} }; return $styles[$Style] ?? $styles.Single }
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Get-WordWrappedLines { param([string]$Text, [int]$MaxWidth); if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }; $lines = @(); $words = $Text -split '\s+'; $sb = [System.Text.StringBuilder]::new(); foreach ($word in $words) { if ($sb.Length -eq 0) { [void]$sb.Append($word) } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) { [void]$sb.Append(' ').Append($word) } else { $lines += $sb.ToString(); [void]$sb.Clear().Append($word) } }; if ($sb.Length -gt 0) { $lines += $sb.ToString() }; return $lines }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }

# AI: NEW - Compositor helper functions
function Get-ThemeColor {
    param([string]$ColorName)
    # Simple theme color mapping - can be enhanced later
    $themeColors = @{
        Background = [ConsoleColor]::Black
        Foreground = [ConsoleColor]::White
        Border = [ConsoleColor]::Gray
        Focus = [ConsoleColor]::Cyan
        Highlight = [ConsoleColor]::Yellow
    }
    return $themeColors[$ColorName] ?? [ConsoleColor]::Black
}
#endregion

Export-ModuleMember -Function 'Initialize-TuiEngine', 'Start-TuiLoop', 'Stop-TuiEngine', 'Push-Screen', 'Pop-Screen', 'Request-TuiRefresh', 'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer', 'Get-BorderChars', 'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 'Get-NextFocusableComponent', 'Handle-TabNavigation', 'Get-WordWrappedLines', 'Get-FocusedComponent', 'Move-Focus', 'Get-CurrentDialog', 'Handle-DialogInput', 'Update-DialogSystem', 'Stop-AllTuiAsyncJobs', 'Get-ThemeColor' -Variable 'TuiState'


####\refactor_checkpoints\checkpoint_20250630_052353_phase-1-verified\screens\task-list-screen.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Task List Screen
# Displays and manages tasks.
# ==============================================================================

# AI: CRITICAL FIX - Import models module for TaskStatus enum and other types
using module '..\modules\models.psm1'

# AI: FIX - Use relative paths for better portability
using module '..\components\ui-classes.psm1'
using module '..\layout\panels-class.psm1'
using module '..\components\advanced-data-components.psm1'
using module '..\modules\dialog-system-class.psm1'

class TaskListScreen : Screen {
    # --- UI Components ---
    [BorderPanel] $MainPanel
    [Table] $TaskTable
    [ContentPanel] $NavPanel

    # --- State ---
    [string] $FilterStatus = "All"

    TaskListScreen([hashtable]$services) : base("TaskListScreen", $services) { }

    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # --- Panel Setup ---
            $this.MainPanel = [BorderPanel]::new("TaskListMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "Task List"
            $this.AddPanel($this.MainPanel)

            # --- Task Table ---
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.SetColumns(@(
                [TableColumn]::new("Title", "Task Title", 50),
                [TableColumn]::new("Status", "Status", 15),
                [TableColumn]::new("Priority", "Priority", 12),
                [TableColumn]::new("DueDate", "Due Date", 15)
            ))
            
            $tableContainer = [BorderPanel]::new("TableContainer", 1, 1, 118, 24)
            $tableContainer.ShowBorder = $false
            $tableContainer.AddChild($this.TaskTable)
            $this.MainPanel.AddChild($tableContainer)
            
            # --- Navigation Panel ---
            $this.NavPanel = [ContentPanel]::new("NavPanel", 1, 26, 118, 3)
            $this.MainPanel.AddChild($this.NavPanel)
            
            # --- Event Subscriptions & Data Load ---
            $this.SubscribeToEvent("Tasks.Changed", { $this.RefreshData() })
            $this.RefreshData()
        }
    }

    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            $allTasks = @($this.Services.DataManager.GetTasks())
            $filteredTasks = switch ($this.FilterStatus) {
                "Active" { $allTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed } }
                "Completed" { $allTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed } }
                default { $allTasks }
            }
            $this.TaskTable.SetData($filteredTasks)
            $this.UpdateNavText()
        }
    }

    hidden [void] UpdateNavText() {
        $navContent = @(
            "[N]ew | [E]dit | [D]elete | [Space]Toggle | [F]ilter: $($this.FilterStatus) | [Esc]Back"
        )
        $this.NavPanel.SetContent($navContent)
    }

    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) { $this.TaskTable.SelectPrevious() }
                ([ConsoleKey]::DownArrow) { $this.TaskTable.SelectNext() }
                ([ConsoleKey]::Spacebar) { $this.ToggleSelectedTask() }
                ([ConsoleKey]::Escape) { $this.Services.Navigation.PopScreen() }
                default {
                    switch ($key.KeyChar.ToString().ToUpper()) {
                        'N' { $this.ShowNewTaskDialog() }
                        'E' { $this.EditSelectedTask() }
                        'D' { $this.DeleteSelectedTask() }
                        'F' { $this.CycleFilter() }
                    }
                }
            }
        }
    }
    
    hidden [void] ToggleSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            # AI: FIX - TaskStatus enum should now be available from models.psm1 import
            if ($task.Status -eq [TaskStatus]::Completed) {
                $task.Status = [TaskStatus]::Pending
            } else {
                $task.Complete()
            }
            $this.Services.DataManager.UpdateTask($task)
        }
    }

    hidden [void] ShowNewTaskDialog() {
        # AI: FIX - Implemented new task dialog functionality
        Write-Log -Level Info -Message "New task dialog requested"
        
        # AI: FIX - Capture $this context for closure
        $dataManager = $this.Services.DataManager
        $refreshCallback = { $this.RefreshData() }.GetNewClosure()
        
        # Use the input dialog from dialog system
        Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {
            param($Value)
            if (-not [string]::IsNullOrWhiteSpace($Value)) {
                $newTask = $dataManager.AddTask($Value, "", [TaskPriority]::Medium, "General")
                Write-Log -Level Info -Message "Created new task: $($newTask.Title)"
                & $refreshCallback
            }
        }
    }

    hidden [void] EditSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Edit task requested for: $($task.Title)"
        }
    }

    hidden [void] DeleteSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Delete task requested for: $($task.Title)"
        }
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\refactor_checkpoints\checkpoint_20250630_052441_phase-1-verified\components\advanced-data-components.psm1
# Advanced Data Components Module for PMC Terminal v5
# Enhanced data display components with sorting, filtering, and pagination

using namespace System.Text
using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Simple Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

class Table : Component {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    
    Table([string]$name) : base($name) {
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        # AI: FIX - Explicit array initialization
        $this.Data = @()
        $this.SelectedIndex = 0
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
    }
    
    [void] SetData([object[]]$data) {
        # AI: FIX - Defensive array initialization
        $this.Data = if ($null -eq $data) { @() } else { @($data) }
        # AI: FIX - Safe array count check
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -ge $dataCount) {
            $this.SelectedIndex = [Math]::Max(0, $dataCount - 1)
        }
    }
    
    [void] SelectNext() {
        # AI: FIX - Safe array count check
        $dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -lt ($dataCount - 1)) {
            $this.SelectedIndex++
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
        }
    }
    
    [object] GetSelectedItem() {
        # AI: FIX - Safe array access with null checking
        if ($null -eq $this.Data) { return $null }
        
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        
        if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {
            return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }
        }
        return $null
    }
    
    hidden [void] _RenderContent() {
        # AI: Render table to buffer using Write-BufferString
        if (-not (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue)) {
            return # Buffer functions not available
        }
        
        # AI: FIX - Get render position from parent panel if available
        $renderX = 0
        $renderY = 0
        $maxWidth = 120  # Default max width
        
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X
            $renderY = $contentArea.Y
            $maxWidth = $contentArea.Width
        }
        
        $currentY = $renderY
        
        # Header
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            $headerLine = ""
            foreach ($col in $this.Columns) {
                $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                $headerLine += $headerText + " "
            }
            # AI: FIX - Trim header to max width
            if ($headerLine.TrimEnd().Length -gt $maxWidth) {
                $headerLine = $headerLine.Substring(0, $maxWidth)
            }
            Write-BufferString -X $renderX -Y $currentY -Text $headerLine.TrimEnd() -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
            $currentY++
            Write-BufferString -X $renderX -Y $currentY -Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $maxWidth)) -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            $currentY++
        }
        
        # AI: FIX - Safe data array handling
        $dataToRender = @()
        if ($null -ne $this.Data) {
            $dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }
        }
        
        # Data rows
        for ($i = 0; $i -lt $dataToRender.Count; $i++) {
            $row = $dataToRender[$i]
            if ($null -eq $row) { continue }
            
            $rowLine = ""
            $isSelected = ($i -eq $this.SelectedIndex)
            
            foreach ($col in $this.Columns) {
                $cellValue = ""
                if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                    $cellValue = $row[$col.Key]?.ToString() ?? ""
                } elseif ($row.PSObject.Properties[$col.Key]) {
                    $cellValue = $row.($col.Key)?.ToString() ?? ""
                }
                
                $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                $rowLine += $cellText + " "
            }
            
            $finalLine = $rowLine.TrimEnd()
            if ($isSelected) {
                $finalLine = "> $finalLine"
            } else {
                $finalLine = "  $finalLine"
            }
            
            $fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
            $bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            # AI: FIX - Ensure line doesn't exceed parent bounds
            if ($finalLine.Length -gt $maxWidth) {
                $finalLine = $finalLine.Substring(0, $maxWidth)
            }
            Write-BufferString -X $renderX -Y $currentY -Text $finalLine -ForegroundColor $fg -BackgroundColor $bg
            $currentY++
        }
        
        if ($dataToRender.Count -eq 0) {
            Write-BufferString -X $renderX -Y $currentY -Text "  No data to display" -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
        }
    }
}

#endregion

#region Advanced Data Table Class

class DataTableComponent : UIElement {
    # ... (class content is unchanged) ...
    [hashtable[]] $Data = @()
    [hashtable[]] $Columns = @()
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 80
    [int] $Height = 20
    [string] $Title = "Data Table"
    [bool] $ShowBorder = $true
    [bool] $IsFocusable = $true
    [int] $SelectedRow = 0
    [int] $ScrollOffset = 0
    [string] $SortColumn
    [string] $SortDirection = "Ascending"
    [string] $FilterText = ""
    [string] $FilterColumn
    [int] $PageSize = 0  # 0 = auto-calculate
    [int] $CurrentPage = 0
    [bool] $ShowHeader = $true
    [bool] $ShowFooter = $true
    [bool] $ShowRowNumbers = $false
    [bool] $AllowSort = $true
    [bool] $AllowFilter = $true
    [bool] $AllowSelection = $true
    [bool] $MultiSelect = $false
    [int[]] $SelectedRows = @()
    [hashtable[]] $FilteredData = @()
    [hashtable[]] $ProcessedData = @()
    [bool] $FilterMode = $false
    hidden [int] $_lastRenderedWidth = 0
    hidden [int] $_lastRenderedHeight = 0
    
    # Event handlers
    [scriptblock] $OnRowSelect
    [scriptblock] $OnSelectionChange
    
    DataTableComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    DataTableComponent([string]$name, [hashtable[]]$data, [hashtable[]]$columns) : base($name) {
        $this.IsFocusable = $true
        $this.Data = $data
        $this.Columns = $columns
        $this.ProcessData()
    }
    
    [void] ProcessData() {
        Invoke-WithErrorHandling -Component "$($this.Name).ProcessData" -Context "Processing table data" -ScriptBlock {
            # Filter data
            if ([string]::IsNullOrWhiteSpace($this.FilterText)) {
                $this.FilteredData = $this.Data
            } else {
                if ($this.FilterColumn) {
                    # Filter specific column
                    $this.FilteredData = @($this.Data | Where-Object {
                        $value = $_."$($this.FilterColumn)"
                        $value -and $value.ToString() -like "*$($this.FilterText)*"
                    })
                } else {
                    # Filter all columns
                    $this.FilteredData = @($this.Data | Where-Object {
                        $row = $_
                        $matched = $false
                        foreach ($col in $this.Columns) {
                            if ($col.Filterable -ne $false) {
                                $value = $row."$($col.Name)"
                                if ($value -and $value.ToString() -like "*$($this.FilterText)*") {
                                    $matched = $true
                                    break
                                }
                            }
                        }
                        $matched
                    })
                }
            }
            
            # Sort data
            if ($this.SortColumn -and $this.AllowSort) {
                $this.ProcessedData = $this.FilteredData | Sort-Object -Property $this.SortColumn -Descending:($this.SortDirection -eq "Descending")
            } else {
                $this.ProcessedData = $this.FilteredData
            }
            
            # Reset selection if needed
            if ($this.SelectedRow -ge $this.ProcessedData.Count) {
                $this.SelectedRow = [Math]::Max(0, $this.ProcessedData.Count - 1)
            }
            
            # Calculate page size if auto
            if ($this.PageSize -eq 0) {
                $headerLines = $this.ShowHeader ? 3 : 0
                $footerLines = $this.ShowFooter ? 2 : 0
                $filterLines = $this.AllowFilter ? 2 : 0
                $borderAdjust = $this.ShowBorder ? 2 : 0
                $calculatedPageSize = $this.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
                $this.PageSize = [Math]::Max(1, $calculatedPageSize)
            }
            
            # Adjust current page
            $totalPages = [Math]::Ceiling($this.ProcessedData.Count / [Math]::Max(1, $this.PageSize))
            if ($this.CurrentPage -ge $totalPages) {
                $this.CurrentPage = [Math]::Max(0, $totalPages - 1)
            }
        }
    }
    
    [hashtable] GetContentBounds() {
        $borderOffset = $this.ShowBorder ? 1 : 0
        return @{
            X = $this.X + $borderOffset
            Y = $this.Y + $borderOffset
            Width = $this.Width - (2 * $borderOffset)
            Height = $this.Height - (2 * $borderOffset)
        }
    }
    
    hidden [void] _RenderContent() {
        # AI: TEMPORARY - Complex table rendering needs to be rewritten for buffer-based system
        # This is a placeholder until proper buffer rendering is implemented
        if (-not (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue)) {
            return # Buffer functions not available
        }
        
        # Simple placeholder rendering
        Write-BufferString -X ($this.X + 1) -Y ($this.Y + 1) -Text "[DataTable: $($this.Title)]" -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
        
        return # TODO: Implement full buffer-based table rendering
        
        # ORIGINAL COMPLEX RENDERING CODE (commented out for now):
        $renderedContent = [StringBuilder]::new()
        
        # Force ProcessData if dimensions changed
        if ($this._lastRenderedWidth -ne $this.Width -or $this._lastRenderedHeight -ne $this.Height) {
            $this.ProcessData()
            $this._lastRenderedWidth = $this.Width
            $this._lastRenderedHeight = $this.Height
        }
        
        # Calculate content area based on border settings
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        $contentHeight = $this.Height

        if ($this.ShowBorder) {
            $borderColor = ($this.IsFocusable -and $this.IsFocused) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
            
            [void]$renderedContent.Append($this.MoveCursor($this.X, $this.Y))
            [void]$renderedContent.Append($this.SetColor($borderColor))
            [void]$renderedContent.Append($this.RenderBorder($this.Title))
            
            # Adjust content area for border
            $contentX = $this.X + 1
            $contentY = $this.Y + 1
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
        }
        
        $currentY = $contentY
        
        # Filter bar
        if ($this.AllowFilter) {
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::White))
            [void]$renderedContent.Append("Filter: ")
            
            $filterDisplayText = $this.FilterText ? $this.FilterText : "Type to filter..."
            $filterColor = $this.FilterText ? [ConsoleColor]::Yellow : [ConsoleColor]::DarkGray
            [void]$renderedContent.Append($this.SetColor($filterColor))
            [void]$renderedContent.Append($filterDisplayText)
            
            $currentY += 2
        }
        
        # Calculate column widths
        $totalDefinedWidth = ($this.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum ?? 0
        $flexColumns = @($this.Columns | Where-Object { -not $_.Width })
        $columnSeparators = $this.Columns.Count -gt 1 ? $this.Columns.Count - 1 : 0
        $rowNumberWidth = $this.ShowRowNumbers ? 5 : 0
        $remainingWidth = $contentWidth - $totalDefinedWidth - $rowNumberWidth - $columnSeparators
        
        $flexWidth = ($flexColumns.Count -gt 0) ? [Math]::Floor($remainingWidth / $flexColumns.Count) : 0
        
        # Assign calculated widths
        foreach ($col in $this.Columns) {
            $col.CalculatedWidth = $col.Width ?? [Math]::Max(5, $flexWidth)
        }
        
        # Header
        if ($this.ShowHeader) {
            $headerX = $contentX
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append("#".PadRight(4))
                $headerX += 5
            }
            
            foreach ($col in $this.Columns) {
                $headerText = $col.Header ?? $col.Name
                $columnWidth = $col.CalculatedWidth
                
                if ($this.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $this.SortColumn) {
                    $sortIndicator = ($this.SortDirection -eq "Ascending") ? "▲" : "▼"
                    $headerText = "$headerText $sortIndicator"
                }
                
                if ($headerText.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $headerText = $headerText.Substring(0, $maxLength) + "..."
                }
                
                $alignedText = switch ($col.Align) {
                    "Right" { $headerText.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $headerText.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $headerText + " " * $rightPad
                    }
                    default { $headerText.PadRight($columnWidth) }
                }
                
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append($alignedText)
                
                $headerX += $columnWidth + 1
            }
            
            $currentY++
            
            [void]$renderedContent.Append($this.MoveCursor($contentX, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append("─" * $contentWidth)
            $currentY++
        }
        
        # Data rows
        $dataToRender = ($this.ProcessedData.Count -eq 0 -and $this.Data.Count -gt 0) ? $this.Data : $this.ProcessedData
        
        $startIdx = $this.CurrentPage * $this.PageSize
        $endIdx = [Math]::Min($startIdx + $this.PageSize - 1, $dataToRender.Count - 1)
        
        for ($i = $startIdx; $i -le $endIdx; $i++) {
            $row = $dataToRender[$i]
            $rowX = $contentX
            
            $isSelected = $this.MultiSelect ? ($this.SelectedRows -contains $i) : ($i -eq $this.SelectedRow)
            
            $rowBg = $isSelected ? [ConsoleColor]::Cyan : [ConsoleColor]::Black
            $rowFg = $isSelected ? [ConsoleColor]::Black : [ConsoleColor]::White
            
            if ($isSelected) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(" " * $contentWidth)
            }
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(($i + 1).ToString().PadRight(4))
                $rowX += 5
            }
            
            foreach ($col in $this.Columns) {
                $value = $row."$($col.Name)"
                $columnWidth = $col.CalculatedWidth
                
                $displayValue = if ($col.Format -and $value) { & $col.Format $value } else { "$($value)" }
                
                if ($displayValue.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $displayValue = ($maxLength -le 0) ? "..." : ($displayValue.Substring(0, $maxLength) + "...")
                }
                
                $alignedValue = switch ($col.Align) {
                    "Right" { $displayValue.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $displayValue.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $displayValue + " " * $rightPad
                    }
                    default { $displayValue.PadRight($columnWidth) }
                }
                
                $cellFg = if ($col.Color -and -not $isSelected) {
                    Get-ThemeColor (& $col.Color $value $row)
                } else {
                    $rowFg
                }
                
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor($cellFg))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append($alignedValue)
                
                $rowX += $columnWidth + 1
            }
            
            $currentY++
        }
        
        # Empty state
        if ($dataToRender.Count -eq 0) {
            $emptyMessage = $this.FilterText ? "No results match the filter" : "No data to display"
            $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
            $msgY = $contentY + [Math]::Floor($contentHeight / 2)
            [void]$renderedContent.Append($this.MoveCursor($msgX, $msgY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($emptyMessage)
        }
        
        # Footer
        if ($this.ShowFooter) {
            $footerY = $contentY + $contentHeight - 1
            
            $statusText = "$($dataToRender.Count) rows"
            if ($this.FilterText) { $statusText += " (filtered from $($this.Data.Count))" }
            if ($this.MultiSelect) { $statusText += " | $($this.SelectedRows.Count) selected" }
            
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $footerY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($statusText)
            
            if ($dataToRender.Count -gt $this.PageSize) {
                $totalPages = [Math]::Ceiling($dataToRender.Count / [Math]::Max(1, $this.PageSize))
                $pageText = "Page $($this.CurrentPage + 1)/$totalPages"
                [void]$renderedContent.Append($this.MoveCursor($contentX + $contentWidth - $pageText.Length - 1, $footerY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Blue))
                [void]$renderedContent.Append($pageText)
            }
        }
        
        # [void]$renderedContent.Append($this.ResetColor())
        # return $renderedContent.ToString()
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # Filter mode
        if ($key.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($key.Key) {
                ([ConsoleKey]::F) {
                    $this.FilterMode = -not $this.FilterMode
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::S) {
                    if ($this.AllowSort) {
                        $sortableCols = @($this.Columns | Where-Object { $_.Sortable -ne $false })
                        if ($sortableCols.Count -gt 0) {
                            $currentIdx = [array]::IndexOf($sortableCols.Name, $this.SortColumn)
                            $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                            $this.SortColumn = $sortableCols[$nextIdx].Name
                            $this.ProcessData()
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
            }
        }
        
        # Filter text input
        if ($this.FilterMode) {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.FilterMode = $false
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $this.FilterMode = $false
                    $this.ProcessData()
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.FilterText.Length -gt 0) {
                        $this.FilterText = $this.FilterText.Substring(0, $this.FilterText.Length - 1)
                        $this.ProcessData()
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                        $this.FilterText += $key.KeyChar
                        $this.ProcessData()
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            return $false
        }
        
        # Normal navigation
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedRow -gt 0) {
                    $this.SelectedRow--
                    if ($this.SelectedRow -lt ($this.CurrentPage * $this.PageSize)) {
                        $this.CurrentPage--
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedRow -lt ($this.ProcessedData.Count - 1)) {
                    $this.SelectedRow++
                    if ($this.SelectedRow -ge (($this.CurrentPage + 1) * $this.PageSize)) {
                        $this.CurrentPage++
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                if ($this.OnRowSelect -and $this.ProcessedData.Count -gt 0) {
                    $selectedData = $this.MultiSelect ? @($this.SelectedRows | ForEach-Object { $this.ProcessedData[$_] }) : $this.ProcessedData[$this.SelectedRow]
                    & $this.OnRowSelect $selectedData $this.SelectedRow
                }
                return $true
            }
        }
        
        return $false
    }
    
    # AI: Helper methods removed - using buffer-based rendering instead of ANSI
    
    # Public methods
    [void] RefreshData() {
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetData([hashtable[]]$data) {
        $this.Data = $data
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this.ProcessData()
        Request-TuiRefresh
    }
}
#endregion

#region Factory Functions for Backward Compatibility

function New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DataTable_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $data = $Props.Data ?? @()
    $columns = $Props.Columns ?? @()
    
    $table = [DataTableComponent]::new($name, $data, $columns)
    
    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.Title = $Props.Title ?? $table.Title
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader
    $table.ShowFooter = $Props.ShowFooter ?? $table.ShowFooter
    $table.ShowRowNumbers = $Props.ShowRowNumbers ?? $table.ShowRowNumbers
    $table.AllowSort = $Props.AllowSort ?? $table.AllowSort
    $table.AllowFilter = $Props.AllowFilter ?? $table.AllowFilter
    $table.AllowSelection = $Props.AllowSelection ?? $table.AllowSelection
    $table.MultiSelect = $Props.MultiSelect ?? $table.MultiSelect
    $table.Visible = $Props.Visible ?? $table.Visible
    $table.OnRowSelect = $Props.OnRowSelect ?? $table.OnRowSelect
    $table.OnSelectionChange = $Props.OnSelectionChange ?? $table.OnSelectionChange
    
    return $table
}
#endregion

Export-ModuleMember -Function 'New-TuiDataTable'



####\refactor_checkpoints\checkpoint_20250630_052441_phase-1-verified\components\advanced-input-components.psm1
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Value = $Props.Value ?? (Get-Date)
        Mode = $Props.Mode ?? "Date" # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = $Props.Value ?? (Get-Date)
        ViewDate = $Props.Value ?? (Get-Date)
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSelect = $Props.OnSelect
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                # Main container
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Calendar "
                
                # Header with navigation
                $headerY = $self.Y + 1
                $monthYear = $self.ViewDate.ToString("MMMM yyyy")
                $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
                
                Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
                Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
                Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
                
                # Day headers
                $dayHeaderY = $headerY + 2
                $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
                $dayWidth = 4
                $startX = $self.X + 2
                
                for ($i = 0; $i -lt $days.Count; $i++) {
                    Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                        -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
                }
                
                # Calendar grid
                $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
                $startDayOfWeek = [int]$firstDay.DayOfWeek
                $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
                
                $currentDay = 1
                $calendarY = $dayHeaderY + 1
                
                for ($week = 0; $week -lt 6; $week++) {
                    if ($currentDay -gt $daysInMonth) { break }
                    
                    for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                        $x = $startX + ($dayOfWeek * $dayWidth)
                        
                        if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                        
                        if ($currentDay -le $daysInMonth) {
                            $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                         $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                         $self.ViewDate.Year -eq $self.SelectedDate.Year)
                            
                            $isToday = ($currentDay -eq (Get-Date).Day -and 
                                      $self.ViewDate.Month -eq (Get-Date).Month -and 
                                      $self.ViewDate.Year -eq (Get-Date).Year)
                            
                            $fg = if ($isSelected) { Get-ThemeColor "Background" } elseif ($isToday) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                            $bg = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                            
                            $dayText = $currentDay.ToString().PadLeft(2)
                            Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText -ForegroundColor $fg -BackgroundColor $bg
                            
                            $currentDay++
                        }
                    }
                }
                
                # Time picker if in DateTime mode
                if ($self.Mode -eq "DateTime") {
                    $timeY = $self.Y + $self.Height - 2
                    $timeStr = $self.SelectedDate.ToString("HH:mm")
                    Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "CalendarPicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $date = $self.SelectedDate
                $viewDate = $self.ViewDate
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $self.ViewDate = $viewDate.AddMonths(-1) } # Previous month
                        else { $date = $date.AddDays(-1); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } } # Previous day
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $self.ViewDate = $viewDate.AddMonths(1) } # Next month
                        else { $date = $date.AddDays(1); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } } # Next day
                    }
                    ([ConsoleKey]::UpArrow) { $date = $date.AddDays(-7); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(7); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } }
                    ([ConsoleKey]::PageUp) {
                        $self.ViewDate = $viewDate.AddMonths(-1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::PageDown) {
                        $self.ViewDate = $viewDate.AddMonths(1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::Home) { $date = Get-Date; $self.ViewDate = $date }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSelect) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSelect" -ScriptBlock { & $self.OnSelect -Date $date } -AdditionalData @{ Component = $self.Name; SelectedDate = $date }
                        }
                    }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.SelectedDate = $date
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $date } -AdditionalData @{ Component = $self.Name; NewValue = $date }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "CalendarPicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 3
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Type to search..."
        MaxDisplayItems = $Props.MaxDisplayItems ?? 5
        AllowCustomValue = $Props.AllowCustomValue ?? $false
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                # Main dropdown box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                # Display text
                $displayText = ""
                if ($self.IsOpen) {
                    $displayText = $self.SearchText
                    if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                        $displayText = $self.Placeholder
                    }
                } else {
                    if ($self.Value) {
                        $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                        $displayText = $selected ? $selected.Display : $self.Value.ToString()
                    } else {
                        $displayText = "Select..."
                    }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                # Dropdown indicator
                $indicator = $self.IsOpen ? "▲" : "▼"
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator -ForegroundColor $borderColor
                
                # Cursor for search mode
                if ($self.IsOpen -and $self.IsFocused) {
                    $cursorX = $self.X + 2 + $self.SearchText.Length
                    if ($cursorX -lt ($self.X + $self.Width - 3)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Options dropdown
                if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                    $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                    Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $startIdx = ($self.SelectedIndex -ge $self.MaxDisplayItems) ? ($self.SelectedIndex - $self.MaxDisplayItems + 1) : 0
                    $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                    
                    for ($i = $startIdx; $i -le $endIdx; $i++) {
                        $option = $self.FilteredOptions[$i]
                        $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                        
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $fg = $isSelected ? (Get-ThemeColor "Background") : (Get-ThemeColor "Primary")
                        $bg = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                        
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) {
                            $text = $text.Substring(0, $self.Width - 7) + "..."
                        }
                        
                        # Highlight matching text
                        if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                            $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                            if ($matchIndex -ge 0) {
                                if ($matchIndex -gt 0) { Write-BufferString -X ($self.X + 2) -Y $y -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg }
                                Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y -Text $text.Substring($matchIndex, $self.SearchText.Length) -ForegroundColor (Get-ThemeColor "Warning")
                                $afterMatch = $matchIndex + $self.SearchText.Length
                                if ($afterMatch -lt $text.Length) { Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y -Text $text.Substring($afterMatch) -ForegroundColor $fg }
                                continue
                            }
                        }
                        
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                    
                    # Scrollbar if needed
                    if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                        $scrollHeight = $self.MaxDisplayItems
                        $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $char = ($i -eq $scrollPos) ? "█" : "│"
                            $color = ($i -eq $scrollPos) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Subtle")
                            Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        FilterOptions = {
            try {
                $this.FilteredOptions = if ([string]::IsNullOrEmpty($this.SearchText)) {
                    $this.Options
                } else {
                    @($this.Options | Where-Object { $_.Display -like "*$($this.SearchText)*" })
                }
                
                if ($this.AllowCustomValue -and $this.SearchText -and -not ($this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText })) {
                    $this.FilteredOptions = @(@{ Display = $this.SearchText; Value = $this.SearchText; IsCustom = $true }) + $this.FilteredOptions
                }
                
                $this.SelectedIndex = 0
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown FilterOptions error for '$($this.Name)': $_" -Data @{ Component = $this.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        $self.SearchText = ""
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                    return $false
                }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) { $self.IsOpen = $false; $self.SearchText = ""; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Enter) {
                        if ($self.FilteredOptions.Count -gt 0) {
                            $selected = $self.FilteredOptions[$self.SelectedIndex]
                            if ($self.OnChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $selected.Value -Option $selected } -AdditionalData @{ Component = $self.Name; NewValue = $selected.Value; Option = $selected }
                            }
                            $self.Value = $selected.Value
                            $self.IsOpen = $false
                            $self.SearchText = ""
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::UpArrow) { if ($self.SelectedIndex -gt 0) { $self.SelectedIndex--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::DownArrow) { if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) { $self.SelectedIndex++; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Backspace) {
                        if ($self.SearchText.Length -gt 0) {
                            $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                            & $self.FilterOptions
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.SearchText += $Key.KeyChar
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Options = $Props.Options ?? @()
        SelectedValues = $Props.SelectedValues ?? @()
        Title = $Props.Title ?? "Select items"
        AllowSelectAll = $Props.AllowSelectAll ?? $true
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSubmit = $Props.OnSubmit
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor -Title " $($self.Title) "
                
                $currentY = $self.Y + 1
                if ($self.AllowSelectAll) {
                    $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                    $checkbox = $allSelected ? "[X]" : "[ ]"
                    $fg = ($self.SelectedIndex -eq -1) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" -ForegroundColor $fg
                    $currentY += 2
                }
                
                $visibleHeight = $self.Height - 4 - ($self.AllowSelectAll ? 2 : 0)
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.Options[$i]
                    $isChecked = $self.SelectedValues -contains $option.Value
                    $isHighlighted = ($i -eq $self.SelectedIndex)
                    
                    $checkbox = $isChecked ? "[X]" : "[ ]"
                    $fg = $isHighlighted ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                    
                    $text = "$checkbox $($option.Display)"
                    if ($text.Length -gt ($self.Width - 4)) { $text = $text.Substring(0, $self.Width - 7) + "..." }
                    
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                    $currentY++
                }
                
                $statusY = $self.Y + $self.Height - 2
                $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
                Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText -ForegroundColor (Get-ThemeColor "Subtle")
            } catch {
                Write-Log -Level Error -Message "MultiSelect Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) { $self.SelectedIndex = -1 } 
                        elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                            $self.SelectedIndex--
                            if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) { $self.ScrollOffset = $self.SelectedIndex }
                        }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                            $self.SelectedIndex++
                            $visibleHeight = $self.Height - 4 - ($self.AllowSelectAll ? 2 : 0)
                            if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) { $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1 }
                        }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                            $self.SelectedValues = ($self.SelectedValues.Count -eq $self.Options.Count) ? @() : @($self.Options.Value)
                        } elseif ($self.SelectedIndex -ge 0) {
                            $optionValue = $self.Options[$self.SelectedIndex].Value
                            if ($self.SelectedValues -contains $optionValue) {
                                $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $optionValue })
                            } else {
                                $self.SelectedValues += $optionValue
                            }
                        }
                        
                        if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -SelectedValues $self.SelectedValues } }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSubmit) { Invoke-WithErrorHandling -Component "$($self.Name).OnSubmit" -ScriptBlock { & $self.OnSubmit -SelectedValues $self.SelectedValues } }
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "MultiSelect HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Value = $Props.Value ?? 0
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        DecimalPlaces = $Props.DecimalPlaces ?? 0
        IsFocusable = $true
        TextValue = ($Props.Value ?? 0).ToString()
        CursorPosition = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $displayValue = $self.TextValue
                if ($displayValue.Length -gt ($self.Width - 6)) { $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..." }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
                
                if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    if ($cursorX -lt ($self.X + $self.Width - 4)) { Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent") }
                }
                
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" -ForegroundColor $borderColor
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" -ForegroundColor $borderColor
                
                if ($self.Value -le $self.Min) { Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" -ForegroundColor (Get-ThemeColor "Warning") }
                if ($self.Value -ge $self.Max) { Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" -ForegroundColor (Get-ThemeColor "Warning") }
            } catch { Write-Log -Level Error -Message "NumberInput Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ } }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                $newValue = ($this.DecimalPlaces -eq 0) ? [Math]::Floor($newValue) : [Math]::Round($newValue, $this.DecimalPlaces)
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) { Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { & $this.OnChange -NewValue $newValue } }
                return $true
            } catch {
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                Write-Log -Level Warning -Message "NumberInput ValidateAndUpdate error for '$($this.Name)': $_" -Data @{ Component = $this.Name; InputText = $this.TextValue; Exception = $_ }
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step); $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)"); $self.CursorPosition = $self.TextValue.Length; if ($self.OnChange) { & $self.OnChange -NewValue $self.Value }; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::DownArrow) { $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step); $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)"); $self.CursorPosition = $self.TextValue.Length; if ($self.OnChange) { & $self.OnChange -NewValue $self.Value }; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::LeftArrow) { if ($self.CursorPosition -gt 0) { $self.CursorPosition--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::RightArrow) { if ($self.CursorPosition -lt $self.TextValue.Length) { $self.CursorPosition++; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Home) { $self.CursorPosition = 0; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::End) { $self.CursorPosition = $self.TextValue.Length; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Backspace) { if ($self.CursorPosition -gt 0) { $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1); $self.CursorPosition--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Delete) { if ($self.CursorPosition -lt $self.TextValue.Length) { $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1); Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Enter) { & $self.ValidateAndUpdate -self $self; Request-TuiRefresh; return $true }
                    default {
                        if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                            $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch { Write-Log -Level Error -Message "NumberInput HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ } }
            return $false
        }
    }
    
    return $component
}

function New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 1
        Value = $Props.Value ?? 50
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        ShowValue = $Props.ShowValue ?? $true
        IsFocusable = $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $fg = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                
                $range = $self.Max - $self.Min
                $percent = ($self.Value - $self.Min) / $range
                $trackWidth = $self.Width - 2
                $thumbPos = [Math]::Floor($trackWidth * $percent)
                
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text ("─" * $trackWidth) -ForegroundColor (Get-ThemeColor "Subtle")
                if ($thumbPos -gt 0) { Write-BufferString -X ($self.X + 1) -Y $self.Y -Text ("═" * $thumbPos) -ForegroundColor $fg }
                
                Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
                Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
                Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
                
                if ($self.ShowValue) {
                    $valueText = $self.Value.ToString()
                    $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                    Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
                }
            } catch { Write-Log -Level Error -Message "Slider Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ } }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $oldValue = $self.Value
                $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) { $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step) }
                    ([ConsoleKey]::RightArrow) { $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step) }
                    ([ConsoleKey]::Home) { $self.Value = $self.Min }
                    ([ConsoleKey]::End) { $self.Value = $self.Max }
                    ([ConsoleKey]::PageDown) { $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep) }
                    ([ConsoleKey]::PageUp) { $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep) }
                    default { $handled = $false }
                }
                
                if ($handled -and $self.Value -ne $oldValue) {
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $self.Value } }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch { Write-Log -Level Error -Message "Slider HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ } }
            return $false
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function 'New-TuiCalendarPicker', 'New-TuiSearchableDropdown', 'New-TuiMultiSelect', 'New-TuiNumberInput', 'New-TuiSlider'


####\refactor_checkpoints\checkpoint_20250630_052441_phase-1-verified\components\navigation-class.psm1
# Navigation Component Classes Module for PMC Terminal v5
# Implements navigation menu functionality with keyboard shortcuts

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        # Simplified format display without ANSI escape codes
        $display = "[$($this.Key)] "
        
        if ($this.Enabled) {
            $display += $this.Label
        }
        else {
            $display += "$($this.Label) (Disabled)"
        }
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            $display += " - $($this.Description)"
        }
        
        return $display
    }
}

# NavigationMenu - Component for displaying and handling navigation options
class NavigationMenu : Component {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    
    NavigationMenu([string]$name) : base($name) {
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.SelectedIndex = 0
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base($name) {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.SelectedIndex = 0
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) { 
            throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") 
        }
        $this.Items.Add($item)
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { [void]$this.Items.Remove($item) }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { 
                $item.Execute() 
            }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
    }

    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", { 
                    $this.Services.Navigation.GoTo("/tasks", @{mode="new"}) 
                }))
                $this.AddItem([NavigationItem]::new("P", "Projects", { 
                    $this.Services.Navigation.GoTo("/projects", @{}) 
                }))
                $this.AddItem([NavigationItem]::new("S", "Settings", { 
                    $this.Services.Navigation.GoTo("/settings", @{}) 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("Q", "Quit", { 
                    $this.Services.Navigation.RequestExit() 
                }))
            }
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", { 
                    Write-Host "New task not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("E", "Edit", { 
                    Write-Host "Edit not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("D", "Delete", { 
                    Write-Host "Delete not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("F", "Filter", { 
                    Write-Host "Filter not implemented" 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
            }
            default {
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
                $this.AddItem([NavigationItem]::new("H", "Home", { 
                    $this.Services.Navigation.GoTo("/dashboard", @{}) 
                }))
            }
        }
    }
    
    # AI: FIX - Get render coordinates from parent panel
    hidden [hashtable] GetRenderPosition() {
        # Default position if no parent
        $x = 0
        $y = 0
        
        # AI: FIX - If we have a parent Panel, use its content area
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $x = $contentArea.X
            $y = $contentArea.Y
        }
        
        return @{ X = $x; Y = $y }
    }
    
    hidden [void] _RenderContent() {
        # Get visible items
        if ($null -eq $this.Items -or $this.Items.Count -eq 0) {
            return
        }
        
        $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
        if ($visibleItems.Count -eq 0) { return }
        
        if ($this.Orientation -eq "Horizontal") { 
            $this.RenderHorizontal($visibleItems) 
        }
        else { 
            $this.RenderVertical($visibleItems) 
        }
    }
    
    hidden [void] RenderHorizontal([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) {
            return
        }
        
        # AI: FIX - Get proper render position from parent
        $pos = $this.GetRenderPosition()
        
        $menuText = ""
        $isFirst = $true
        foreach ($item in $items) {
            if ($null -eq $item) { continue }
            
            if (-not $isFirst) {
                $menuText += $this.Separator
            }
            $menuText += "[$($item.Key)] $($item.Label)"
            $isFirst = $false
        }
        
        if (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue) {
            Write-BufferString -X $pos.X -Y $pos.Y -Text $menuText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
        }
    }
    
    hidden [void] RenderVertical([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) {
            return
        }
        
        # AI: FIX - Get proper render position from parent
        $pos = $this.GetRenderPosition()
        
        # Ensure SelectedIndex is within bounds
        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {
            $this.SelectedIndex = 0
        }
        
        # AI: FIX - Calculate max width for proper clearing
        $maxWidth = 0
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $maxWidth = $contentArea.Width
        }
        
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($null -eq $item) { continue }
            
            $prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }
            $menuText = "$prefix[$($item.Key)] $($item.Label)"
            
            # AI: FIX - Pad text to clear the full line width
            if ($maxWidth -gt 0 -and $menuText.Length -lt $maxWidth) {
                $menuText = $menuText.PadRight($maxWidth)
            }
            
            if (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue) {
                $fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                    [ConsoleColor]::Black 
                } else { 
                    [ConsoleColor]::White 
                }
                $bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                    [ConsoleColor]::White 
                } else { 
                    [ConsoleColor]::Black 
                }
                
                Write-BufferString -X $pos.X -Y ($pos.Y + $i) -Text $menuText `
                    -ForegroundColor $fg -BackgroundColor $bg
            }
        }
    }
}

Export-ModuleMember -Function @()



####\refactor_checkpoints\checkpoint_20250630_052441_phase-1-verified\components\tui-components.psm1
# TUI Component Library - Phase 1 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

using module ..\components\tui-primitives.psm1

#region Core UI Components

# AI: REFACTORED - LabelComponent now properly inherits from UIElement
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor
    
    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Now renders to parent Panel's buffer instead of direct output
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            $parentPanel = [Panel]$this.Parent
            
            # AI: Calculate position relative to parent's content area
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            # AI: Render to parent's buffer
            $parentPanel.WriteToBuffer($renderX, $renderY, $this.Text, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "Label render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false # Labels don't handle input
    }
}

# AI: REFACTORED - ButtonComponent updated for buffer-based rendering
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick
    
    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
        $this.Text = "Button"
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Buffer-based rendering with parent Panel integration
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            $bgColor = $this.IsPressed ? [ConsoleColor]::Yellow : [ConsoleColor]::Black
            $fgColor = $this.IsPressed ? [ConsoleColor]::Black : $borderColor
            
            # AI: Render border to parent buffer
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, $bgColor)
            
            # AI: Render text centered
            $textX = $renderX + [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = $renderY + [Math]::Floor($this.Height / 2)
            $parentPanel.WriteToBuffer($textX, $textY, $this.Text, $fgColor, $bgColor)
            
        } catch { 
            Write-Log -Level Error -Message "Button render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsPressed = $true
                $this.Parent.RequestRedraw()
                
                if ($this.OnClick) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock { & $this.OnClick }
                }
                
                $this.IsPressed = $false
                $this.Parent.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "Button input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: REFACTORED - TextBoxComponent with buffer-based rendering
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.MaxLength = 100
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Renders to parent Panel buffer
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display text or placeholder
            $displayText = $this.Text ?? ""
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = $this.Placeholder ?? "" 
            }
            
            $maxDisplayLength = $this.Width - 4
            if ($displayText.Length -gt $maxDisplayLength) { 
                $displayText = $displayText.Substring(0, $maxDisplayLength) 
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, [ConsoleColor]::White, [ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $displayText.Length) {
                $cursorX = $textX + $this.CursorPosition
                if ($cursorX < $renderX + $this.Width - 2) {
                    $parentPanel.WriteToBuffer($cursorX, $textY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "TextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition ?? 0
            $originalText = $currentText
            
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $currentText = $currentText.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    } 
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $currentText.Length) { 
                        $currentText = $currentText.Remove($cursorPos, 1) 
                    } 
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- } 
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $currentText.Length) { $cursorPos++ } 
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $currentText.Length }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) { 
                        $currentText = $currentText.Insert($cursorPos, $key.KeyChar)
                        $cursorPos++ 
                    } else { 
                        return $false 
                    }
                }
            }
            
            if ($currentText -ne $originalText -or $cursorPos -ne $this.CursorPosition) {
                $this.Text = $currentText
                $this.CursorPosition = $cursorPos
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $currentText 
                    }
                }
                $this.Parent.RequestRedraw()
            }
            return $true
        } catch { 
            Write-Log -Level Error -Message "TextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
}

# AI: NEW - CheckBoxComponent converted from functional to class-based
class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange
    
    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $checkbox = $this.Checked ? "[X]" : "[ ]"
            $displayText = "$checkbox $($this.Text)"
            
            $parentPanel.WriteToBuffer($renderX, $renderY, $displayText, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "CheckBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Checked = -not $this.Checked
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $this.Checked 
                    } 
                }
                $this.Parent.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "CheckBox input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: NEW - RadioButtonComponent converted from functional to class-based
class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange
    
    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $radio = $this.Selected ? "(●)" : "( )"
            $displayText = "$radio $($this.Text)"
            
            $parentPanel.WriteToBuffer($renderX, $renderY, $displayText, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "RadioButton render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if (-not $this.Selected) {
                    # AI: Unselect other radio buttons in the same group
                    if ($this.Parent -and $this.GroupName) {
                        $siblingRadios = $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        }
                        foreach ($radio in $siblingRadios) {
                            $radio.Selected = $false
                        }
                    }
                    
                    $this.Selected = $true
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $this.Selected 
                        } 
                    }
                    $this.Parent.RequestRedraw()
                }
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "RadioButton input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $label = [LabelComponent]::new($name)
    
    $label.X = $Props.X ?? $label.X
    $label.Y = $Props.Y ?? $label.Y
    $label.Width = $Props.Width ?? $label.Width
    $label.Height = $Props.Height ?? $label.Height
    $label.Visible = $Props.Visible ?? $label.Visible
    $label.ZIndex = $Props.ZIndex ?? $label.ZIndex
    $label.Text = $Props.Text ?? $label.Text
    $label.ForegroundColor = $Props.ForegroundColor ?? $label.ForegroundColor
    
    return $label
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $button = [ButtonComponent]::new($name)
    
    $button.X = $Props.X ?? $button.X
    $button.Y = $Props.Y ?? $button.Y
    $button.Width = $Props.Width ?? $button.Width
    $button.Height = $Props.Height ?? $button.Height
    $button.Visible = $Props.Visible ?? $button.Visible
    $button.ZIndex = $Props.ZIndex ?? $button.ZIndex
    $button.Text = $Props.Text ?? $button.Text
    $button.OnClick = $Props.OnClick ?? $button.OnClick
    
    return $button
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [TextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Text = $Props.Text ?? $textBox.Text
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLength = $Props.MaxLength ?? $textBox.MaxLength
    $textBox.CursorPosition = $Props.CursorPosition ?? $textBox.CursorPosition
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    return $textBox
}

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $checkBox = [CheckBoxComponent]::new($name)
    
    $checkBox.X = $Props.X ?? $checkBox.X
    $checkBox.Y = $Props.Y ?? $checkBox.Y
    $checkBox.Width = $Props.Width ?? $checkBox.Width
    $checkBox.Height = $Props.Height ?? $checkBox.Height
    $checkBox.Visible = $Props.Visible ?? $checkBox.Visible
    $checkBox.ZIndex = $Props.ZIndex ?? $checkBox.ZIndex
    $checkBox.Text = $Props.Text ?? $checkBox.Text
    $checkBox.Checked = $Props.Checked ?? $checkBox.Checked
    $checkBox.OnChange = $Props.OnChange ?? $checkBox.OnChange
    
    return $checkBox
}

function New-TuiRadioButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $radioButton = [RadioButtonComponent]::new($name)
    
    $radioButton.X = $Props.X ?? $radioButton.X
    $radioButton.Y = $Props.Y ?? $radioButton.Y
    $radioButton.Width = $Props.Width ?? $radioButton.Width
    $radioButton.Height = $Props.Height ?? $radioButton.Height
    $radioButton.Visible = $Props.Visible ?? $radioButton.Visible
    $radioButton.ZIndex = $Props.ZIndex ?? $radioButton.ZIndex
    $radioButton.Text = $Props.Text ?? $radioButton.Text
    $radioButton.Selected = $Props.Selected ?? $radioButton.Selected
    $radioButton.GroupName = $Props.GroupName ?? $radioButton.GroupName
    $radioButton.OnChange = $Props.OnChange ?? $radioButton.OnChange
    
    return $radioButton
}

#endregion

Export-ModuleMember -Function 'New-TuiLabel', 'New-TuiButton', 'New-TuiTextBox', 'New-TuiCheckBox', 'New-TuiRadioButton'


####\refactor_checkpoints\checkpoint_20250630_052441_phase-1-verified\components\tui-primitives.psm1
# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations

using namespace System
using namespace System.Management.Automation

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    [ConsoleColor] $ForegroundColor = [ConsoleColor]::White
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = ""
    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() {
        $this.Char = ' '
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Character constructor
    TuiCell([char]$char) {
        $this.Char = $char
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Full constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }

    # Style constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }

    # Copy constructor
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.StyleFlags = $other.StyleFlags
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Create a styled copy
    [TuiCell] WithStyle([ConsoleColor]$fg, [ConsoleColor]$bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    # Create a character copy
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blend this cell with another (higher Z-index wins)
    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return $other }
        if ($other.ZIndex -eq $this.ZIndex -and $other.Char -ne ' ') { return $other }
        return $this
    }

    # Check if this cell differs from another
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic)
    }

    # Generate ANSI escape sequence for this cell
    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Color codes
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append("`e[${fgCode};${bgCode}")
        
        # Style codes
        if ($this.Bold) { [void]$sb.Append(";1") }
        if ($this.Underline) { [void]$sb.Append(";4") }
        if ($this.Italic) { [void]$sb.Append(";3") }
        
        [void]$sb.Append("m").Append($this.Char)
        return $sb.ToString()
    }

    # Convert to legacy buffer format for compatibility
    [hashtable] ToLegacyFormat() {
        return @{
            Char = $this.Char
            FG = $this.ForegroundColor
            BG = $this.BackgroundColor
        }
    }

    # String representation
    [string] ToString() {
        return "TuiCell($($this.Char), $($this.ForegroundColor), $($this.BackgroundColor))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

#region UIElement Base Class - Foundation for All Components
class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer = $null
    [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{}

    # Constructor
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with position and size
    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Buffer")
    }

    # Get absolute screen position
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # Add child component
    [void] AddChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
        }
    }

    # Remove child component
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
            $this.RequestRedraw()
        }
    }

    # Request redraw for this component and parents
    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
    }

    # Resize the component and its buffer
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Resize($newWidth, $newHeight)
        }
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # Move the component
    [void] Move([int]$newX, [int]$newY) {
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
    }

    # Check if point is within component bounds
    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge $this.X -and $x -lt ($this.X + $this.Width) -and 
                $y -ge $this.Y -and $y -lt ($this.Y + $this.Height))
    }

    # Get child at specific point (relative to this component)
    [UIElement] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $this.X, $y - $this.Y)) {
                return $child
            }
        }
        return $null
    }

    # Virtual methods for subclasses to override
    [void] OnRender() {
        # Default implementation - clear buffer
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Override in subclasses
    }

    [void] OnMove([int]$newX, [int]$newY) {
        # Override in subclasses
    }

    [void] OnFocus() {
        # Override in subclasses
    }

    [void] OnBlur() {
        # Override in subclasses
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Override in subclasses - return true if input was handled
        return $false
    }

    # Main render method - calls OnRender and renders children
    [void] Render() {
        if (-not $this.Visible) { return }

        # Render this component to its private buffer
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer) {
                $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }
            
            $this.OnRender()
            $this._needs_redraw = $false
        }

        # Render children to their buffers, then composite onto parent
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
    }

    # Get the final rendered buffer
    [TuiBuffer] GetBuffer() {
        return $this._private_buffer
    }
}
#endregion

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int] GetForegroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()]
    }

    static [int] GetBackgroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()] + 10
    }

    static [string] Reset() {
        return "`e[0m"
    }

    static [string] Bold() {
        return "`e[1m"
    }

    static [string] Underline() {
        return "`e[4m"
    }

    static [string] Italic() {
        return "`e[3m"
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions
function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    
    $cell = [TuiCell]::new(' ', $ForegroundColor, $BackgroundColor)
    $cell.Bold = $Bold
    $cell.Underline = $Underline
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0) {
            $charCell = [TuiCell]::new($cell)
            $charCell.Char = $char
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$BorderStyle = "Single",
        [ConsoleColor]$BorderColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }
    
    $borders = Get-TuiBorderChars -Style $BorderStyle
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Side borders and fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        $currentY = $Y + $i
        
        # Left border
        Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill
        $fillText = ' ' * ($Width - 2)
        Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -BackgroundColor $BackgroundColor
        
        # Right border
        Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $bottomLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all classes and functions
Export-ModuleMember -Function 'Write-TuiText', 'Write-TuiBox', 'Get-TuiBorderChars'


####\refactor_checkpoints\checkpoint_20250630_052441_phase-1-verified\layout\panels-class.psm1
# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

using module .\components\tui-primitives.psm1

#region Panel Class - Basic Layout Container
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds
    [void] Resize([int]$newWidth, [int]$newHeight) {
        ([UIElement]$this).Resize($newWidth, $newHeight)
        $this.UpdateContentBounds()
    }

    # Add child with automatic layout (if enabled)
    [void] AddChild([UIElement]$child) {
        ([UIElement]$this).AddChild($child)
        $this.PerformLayout()
    }

    # Remove child and re-layout
    [void] RemoveChild([UIElement]$child) {
        ([UIElement]$this).RemoveChild($child)
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.Move($this.ContentX, $currentY)
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.Move($currentX, $this.ContentY)
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        # Calculate grid dimensions
        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            # Adjust size for last column/row
            $width = if ($col -eq ($cols - 1)) { 
                $this.ContentX + $this.ContentWidth - $x 
            } else { 
                $cellWidth 
            }
            $height = if ($row -eq ($rows - 1)) { 
                $this.ContentY + $this.ContentHeight - $y 
            } else { 
                $cellHeight 
            }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    # Set border style and update content bounds
    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    # Enable/disable border
    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    # Set title
    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    # Check if point is within content area
    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    # Get content bounds as hashtable
    [hashtable] GetContentBounds() {
        return @{
            X = $this.ContentX
            Y = $this.ContentY
            Width = $this.ContentWidth
            Height = $this.ContentHeight
        }
    }

    # Clear content area only
    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return }

        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    # Main render implementation
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }

        # Clear entire buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this._private_buffer.Clear($bgCell)

        # Draw border if enabled
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }

        # Fill content area
        $this.ClearContent()
    }

    # Override OnResize to update content bounds
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Handle focus for focusable panels
    [void] OnFocus() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Cyan
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Gray
            $this.RequestRedraw()
        }
    }

    # Find first focusable child
    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    # Get all focusable children (recursive)
    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        
        return $focusable
    }

    # Basic input handling - delegate to focused child
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # If this panel can focus and is focused, handle some basic navigation
        if ($this.CanFocus -and $this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        Set-ComponentFocus -Component $firstChild
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        Set-ComponentFocus -Component $firstChild
                        return $true
                    }
                }
            }
        }

        # Delegate to children
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }

        return $false
    }

    # String representation
    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}
#endregion

#region Specialized Panel Types

# Scrollable Panel - supports content larger than visible area
class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    # Constructor
    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    # Set virtual content size
    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        
        # Create virtual buffer if needed
        if ($width -gt 0 -and $height -gt 0) {
            $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        
        $this.RequestRedraw()
    }

    # Scroll to position
    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        
        $this.RequestRedraw()
    }

    # Scroll by delta
    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    # Handle scrolling input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }

        return ([Panel]$this).HandleInput($keyInfo)
    }

    # Render with scrolling support
    [void] OnRender() {
        # Render base panel
        ([Panel]$this).OnRender()

        # Render virtual content if available
        if ($null -ne $this._virtual_buffer) {
            # Create a sub-buffer view of the virtual content
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            
            # Blend visible content onto our buffer
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }

        # Draw scrollbars if enabled and needed
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    # Draw scrollbar indicators
    [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return }

        # Vertical scrollbar
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
        }

        # Horizontal scrollbar
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    # Get virtual content buffer for external drawing
    [TuiBuffer] GetVirtualBuffer() {
        return $this._virtual_buffer
    }
}

# Group Panel - collapsible panel with header
class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    # Toggle collapsed state
    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)  # Just header + border
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        
        # Update child visibility
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        
        $this.RequestRedraw()
    }

    # Handle collapse/expand input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }

        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        
        return $false
    }

    # Render with collapse indicator
    [void] OnRender() {
        ([Panel]$this).OnRender()

        # Draw collapse/expand indicator in title area
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            $this._private_buffer.SetCell(2, 0, $indicatorCell)
        }
    }
}
#endregion

# Export the Panel classes
Export-ModuleMember -Function @()


####\refactor_checkpoints\checkpoint_20250630_052441_phase-1-verified\modules\dialog-system-class.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Base Dialog Class
class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    [int] $Width = 50
    [int] $Height = 10
    [int] $X
    [int] $Y
    [ConsoleColor] $BorderColor = [ConsoleColor]::Cyan
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [ConsoleColor] $MessageColor = [ConsoleColor]::Gray
    
    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    [void] Show() {
        # Calculate centered position
        $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
        $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 2)
        
        # Register with dialog manager
        $script:DialogState.CurrentDialog = $this
        Request-TuiRefresh
    }
    
    [void] Close() {
        $script:DialogState.CurrentDialog = $null
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        }
        Request-TuiRefresh
    }
    
    # Base render draws dialog frame
    hidden [void] _RenderContent() {
        # Draw dialog box
        Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height `
            -Title " $($this.Title) " -BorderColor $this.BorderColor
        
        # Draw message if present
        if (-not [string]::IsNullOrWhiteSpace($this.Message)) {
            $this.RenderMessage()
        }
        
        # Let derived classes render their specific content
        $this._RenderDialogContent()
    }
    
    hidden [void] RenderMessage() {
        $messageY = $this.Y + 2
        $messageX = $this.X + 2
        $maxWidth = $this.Width - 4
        
        $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
        foreach ($line in $wrappedLines) {
            if ($messageY -ge ($this.Y + $this.Height - 3)) { break }
            Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor $this.MessageColor
            $messageY++
        }
    }
    
    # Override in derived classes
    hidden [void] _RenderDialogContent() { }
    
    # Base input handling - ESC closes dialog
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.OnCancel()
        }
    }
    
    # Virtual methods for derived classes
    [void] OnConfirm() { $this.Close() }
    [void] OnCancel() { $this.Close() }
}

# Alert Dialog - Simple OK dialog
class AlertDialog : Dialog {
    [string] $ButtonText = "OK"
    
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 10
        $this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))
    }
    
    hidden [void] _RenderDialogContent() {
        # Render OK button
        $buttonY = $this.Y + $this.Height - 2
        $buttonText = "[ $($this.ButtonText) ]"
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
        
        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) { $this.OnConfirm() }
            ([ConsoleKey]::Spacebar) { $this.OnConfirm() }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
}

# Confirm Dialog - Yes/No dialog
class ConfirmDialog : Dialog {
    [scriptblock] $OnConfirmAction
    [scriptblock] $OnCancelAction
    [string[]] $Buttons = @("Yes", "No")
    [int] $SelectedButton = 0
    
    ConfirmDialog([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) : base("ConfirmDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.OnConfirmAction = $onConfirm
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render buttons
        $buttonY = $this.Y + $this.Height - 3
        $totalButtonWidth = ($this.Buttons.Count * 12) + (($this.Buttons.Count - 1) * 2)
        $buttonX = $this.X + [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        
        for ($i = 0; $i -lt $this.Buttons.Count; $i++) {
            $button = $this.Buttons[$i]
            $isSelected = ($i -eq $this.SelectedButton)
            $buttonText = if ($isSelected) { "[ $button ]" } else { "  $button  " }
            $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
            $buttonX += 14
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) { 
                $this.SelectedButton = [Math]::Max(0, $this.SelectedButton - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::RightArrow) { 
                $this.SelectedButton = [Math]::Min($this.Buttons.Count - 1, $this.SelectedButton + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Tab) { 
                $this.SelectedButton = ($this.SelectedButton + 1) % $this.Buttons.Count
                Request-TuiRefresh
            }
            ([ConsoleKey]::Enter) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Spacebar) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnConfirmAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnConfirm" -ScriptBlock $this.OnConfirmAction
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Input Dialog - Text input dialog
class InputDialog : Dialog {
    [string] $Prompt = ""
    [string] $InputValue = ""
    [string] $DefaultValue = ""
    [scriptblock] $OnSubmitAction
    [scriptblock] $OnCancelAction
    [int] $FocusedElement = 0  # 0=TextBox, 1=OK, 2=Cancel
    [int] $CursorPosition = 0
    
    InputDialog([string]$title, [string]$prompt, [scriptblock]$onSubmit, [scriptblock]$onCancel) : base("InputDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.OnSubmitAction = $onSubmit
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(70, [Math]::Max(50, $prompt.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render prompt
        $promptX = $this.X + 2
        $promptY = $this.Y + 2
        Write-BufferString -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor ([ConsoleColor]::White)
        
        # Render input box
        $inputY = $promptY + 2
        $inputWidth = $this.Width - 4
        $isFocused = ($this.FocusedElement -eq 0)
        $borderColor = if ($isFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::DarkGray }
        
        Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 -BorderColor $borderColor
        
        # Render input text
        $displayText = $this.InputValue
        if ($displayText.Length -gt ($inputWidth - 3)) {
            $displayText = $displayText.Substring(0, $inputWidth - 3)
        }
        Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText -ForegroundColor ([ConsoleColor]::White)
        
        # Show cursor when focused
        if ($isFocused -and $this.CursorPosition -le $displayText.Length) {
            Write-BufferString -X ($promptX + 1 + $this.CursorPosition) -Y ($inputY + 1) `
                -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
        }
        
        # Render buttons
        $buttonY = $this.Y + $this.Height - 2
        $buttonSpacing = 15
        $buttonsWidth = $buttonSpacing * 2
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonsWidth) / 2)
        
        # OK button
        $okFocused = ($this.FocusedElement -eq 1)
        $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
        $okColor = if ($okFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
        
        # Cancel button
        $cancelFocused = ($this.FocusedElement -eq 2)
        $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
        $cancelColor = if ($cancelFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Tab) {
                $direction = if ($key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                $this.FocusedElement = ($this.FocusedElement + $direction + 3) % 3
                Request-TuiRefresh
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
            default {
                switch ($this.FocusedElement) {
                    0 { # TextBox
                        switch ($key.Key) {
                            ([ConsoleKey]::Enter) { $this.OnConfirm() }
                            ([ConsoleKey]::Backspace) {
                                if ($this.InputValue.Length -gt 0 -and $this.CursorPosition -gt 0) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition - 1, 1)
                                    $this.CursorPosition--
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::Delete) {
                                if ($this.CursorPosition -lt $this.InputValue.Length) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition, 1)
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::LeftArrow) {
                                $this.CursorPosition = [Math]::Max(0, $this.CursorPosition - 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::RightArrow) {
                                $this.CursorPosition = [Math]::Min($this.InputValue.Length, $this.CursorPosition + 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::Home) {
                                $this.CursorPosition = 0
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::End) {
                                $this.CursorPosition = $this.InputValue.Length
                                Request-TuiRefresh
                            }
                            default {
                                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                                    $this.InputValue = $this.InputValue.Insert($this.CursorPosition, $key.KeyChar)
                                    $this.CursorPosition++
                                    Request-TuiRefresh
                                }
                            }
                        }
                    }
                    1 { # OK Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnConfirm()
                        }
                    }
                    2 { # Cancel Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnCancel()
                        }
                    }
                }
            }
        }
    }
    
    [void] SetDefaultValue([string]$value) {
        $this.InputValue = $value
        $this.DefaultValue = $value
        $this.CursorPosition = $value.Length
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSubmitAction) {
            $value = $this.InputValue
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnSubmit" -ScriptBlock {
                & $this.OnSubmitAction -Value $value
            }.GetNewClosure()
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Progress Dialog
class ProgressDialog : Dialog {
    [int] $PercentComplete = 0
    [bool] $ShowCancel = $false
    [bool] $IsCancelled = $false
    
    ProgressDialog([string]$title, [string]$message) : base("ProgressDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Width = 60
        $this.Height = 8
    }
    
    hidden [void] _RenderDialogContent() {
        # Render progress bar
        $barY = $this.Y + 4
        $barWidth = $this.Width - 4
        $filledWidth = [Math]::Floor($barWidth * ($this.PercentComplete / 100.0))
        
        # Draw bar background
        Write-BufferString -X ($this.X + 2) -Y $barY -Text ("─" * $barWidth) -ForegroundColor ([ConsoleColor]::DarkGray)
        
        # Draw filled portion
        if ($filledWidth -gt 0) {
            Write-BufferString -X ($this.X + 2) -Y $barY -Text ("█" * $filledWidth) -ForegroundColor ([ConsoleColor]::Green)
        }
        
        # Draw percentage
        $percentText = "$($this.PercentComplete)%"
        $percentX = $this.X + [Math]::Floor(($this.Width - $percentText.Length) / 2)
        Write-BufferString -X $percentX -Y $barY -Text $percentText -ForegroundColor ([ConsoleColor]::White)
        
        # Draw cancel button if enabled
        if ($this.ShowCancel) {
            $buttonY = $this.Y + $this.Height - 2
            $buttonText = if ($this.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
            $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
        }
    }
    
    [void] UpdateProgress([int]$percent, [string]$message) {
        $this.PercentComplete = [Math]::Min(100, [Math]::Max(0, $percent))
        if (-not [string]::IsNullOrWhiteSpace($message)) {
            $this.Message = $message
        }
        Request-TuiRefresh
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($this.ShowCancel -and -not $this.IsCancelled) {
            if ($key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsCancelled = $true
                Request-TuiRefresh
            }
        }
    }
}

# List Dialog
class ListDialog : Dialog {
    [string[]] $Items = @()
    [int] $SelectedIndex = 0
    [bool] $AllowMultiple = $false
    [System.Collections.Generic.HashSet[int]] $SelectedItems
    [scriptblock] $OnSelectAction
    [scriptblock] $OnCancelAction
    
    ListDialog([string]$title, [string]$prompt, [string[]]$items, [scriptblock]$onSelect, [scriptblock]$onCancel) : base("ListDialog") {
        $this.Title = $title
        $this.Message = $prompt
        $this.Items = $items
        $this.OnSelectAction = $onSelect
        $this.OnCancelAction = $onCancel
        $this.Width = 60
        $this.Height = [Math]::Min(20, $items.Count + 8)
        $this.SelectedItems = [System.Collections.Generic.HashSet[int]]::new()
    }
    
    hidden [void] _RenderDialogContent() {
        $listY = $this.Y + 4
        $listHeight = $this.Height - 7
        $listWidth = $this.Width - 4
        
        # Calculate visible range with scrolling
        $startIndex = [Math]::Max(0, $this.SelectedIndex - [Math]::Floor($listHeight / 2))
        $endIndex = [Math]::Min($this.Items.Count - 1, $startIndex + $listHeight - 1)
        
        # Render items
        for ($i = $startIndex; $i -le $endIndex; $i++) {
            $itemY = $listY + ($i - $startIndex)
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex)
            $isChecked = $this.SelectedItems.Contains($i)
            
            $prefix = if ($this.AllowMultiple) {
                if ($isChecked) { "[X] " } else { "[ ] " }
            } else { "" }
            
            $itemText = "$prefix$item"
            if ($itemText.Length -gt $listWidth - 2) {
                $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
            }
            
            $bgColor = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            $fgColor = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::Gray }
            
            # Clear the line first
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text (" " * ($listWidth - 2)) -BackgroundColor $bgColor
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text $itemText -ForegroundColor $fgColor -BackgroundColor $bgColor
        }
        
        # Render scrollbar if needed
        if ($this.Items.Count -gt $listHeight) {
            $scrollbarX = $this.X + $this.Width - 2
            $scrollbarHeight = $listHeight
            $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $this.Items.Count))
            $thumbPos = [Math]::Floor($scrollbarHeight * $this.SelectedIndex / $this.Items.Count)
            
            for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char -ForegroundColor ([ConsoleColor]::DarkGray)
            }
        }
        
        # Render buttons for multi-select
        if ($this.AllowMultiple) {
            $buttonY = $this.Y + $this.Height - 2
            $okText = "[ OK ]"
            $cancelText = "[ Cancel ]"
            $buttonSpacing = 15
            $totalWidth = 30
            $startX = $this.X + [Math]::Floor(($this.Width - $totalWidth) / 2)
            
            Write-BufferString -X $startX -Y $buttonY -Text $okText -ForegroundColor ([ConsoleColor]::Green)
            Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor ([ConsoleColor]::Gray)
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::DownArrow) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Spacebar) {
                if ($this.AllowMultiple) {
                    if ($this.SelectedItems.Contains($this.SelectedIndex)) {
                        [void]$this.SelectedItems.Remove($this.SelectedIndex)
                    } else {
                        [void]$this.SelectedItems.Add($this.SelectedIndex)
                    }
                    Request-TuiRefresh
                }
            }
            ([ConsoleKey]::Enter) {
                $this.OnConfirm()
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
            }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSelectAction) {
            if ($this.AllowMultiple) {
                $selectedValues = @($this.SelectedItems | ForEach-Object { $this.Items[$_] })
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selectedValues
                }.GetNewClosure()
            } else {
                $selected = $this.Items[$this.SelectedIndex]
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selected
                }.GetNewClosure()
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ListDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Dialog State Management
$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

# Public API Functions
function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        # Subscribe to dialog events
        Subscribe-Event -EventName "Confirm.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-ConfirmDialog -Title $params.Title -Message $params.Message `
                -OnConfirm $params.OnConfirm -OnCancel $params.OnCancel
        }
        
        Subscribe-Event -EventName "Alert.Show" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-AlertDialog -Title $params.Title -Message $params.Message
        }
        
        Subscribe-Event -EventName "Input.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-InputDialog -Title $params.Title -Prompt $params.Prompt `
                -DefaultValue $params.DefaultValue -OnSubmit $params.OnSubmit -OnCancel $params.OnCancel
        }
        
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

function Show-AlertDialog {
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock {
        $dialog = [AlertDialog]::new($Title, $Message)
        $dialog.Show()
    }
}

function Show-ConfirmDialog {
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock {
        $dialog = [ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)
        $dialog.Show()
    }
}

function Show-InputDialog {
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock {
        $dialog = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel)
        if ($DefaultValue) {
            $dialog.SetDefaultValue($DefaultValue)
        }
        $dialog.Show()
    }
}

function Show-ProgressDialog {
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock {
        $dialog = [ProgressDialog]::new($Title, $Message)
        $dialog.PercentComplete = $PercentComplete
        $dialog.ShowCancel = $ShowCancel
        $dialog.Show()
        return $dialog
    }
}

function Show-ListDialog {
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [string[]]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock {
        $dialog = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel)
        $dialog.AllowMultiple = $AllowMultiple
        $dialog.Show()
    }
}

function Close-TuiDialog {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.CurrentDialog.Close()
        }
    }
}

Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-AlertDialog',
    'Show-ConfirmDialog', 
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Close-TuiDialog'
) -Variable @()



####\refactor_checkpoints\checkpoint_20250630_052441_phase-1-verified\modules\tui-engine.psm1
# TUI Engine v5.1 - NCurses Compositor Edition
# Implements NCurses-style compositor with private buffers and TuiCell rendering

using module .\components\tui-primitives.psm1

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    CompositorBuffer = $null    # AI: NEW - Master compositor buffer (TuiBuffer)
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
    CompositorMode  = $true     # AI: NEW - Enable NCurses-style rendering
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.1 (NCurses Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        # AI: ENHANCED - Create both legacy buffers and new TuiBuffer compositor
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        
        # Initialize legacy buffers for compatibility
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height; CompositorMode = $global:TuiState.CompositorMode }
        Write-Log -Level Info -Message "TUI Engine v5.1 initialized successfully (Compositor Mode: $($global:TuiState.CompositorMode))"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent) {
        try { 
            # AI: ENHANCED - Better class detection for UIElement-based components
            if ($focusedComponent -is [UIElement]) {
                # New UIElement-based component
                $focusedComponent.HandleInput($keyInfo)
            }
            elseif ($focusedComponent.PSObject.TypeNames -contains 'UIElement' -or $focusedComponent.GetType().IsSubclassOf([UIElement])) {
                # Class-based component (legacy detection)
                if ($focusedComponent.PSObject.Methods.Name -contains 'HandleInput') {
                    $focusedComponent.HandleInput($keyInfo)
                }
            }
            elseif ($focusedComponent.HandleInput) {
                # Functional component with HandleInput scriptblock
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return }
            }
        } catch { 
            Write-Warning "Component input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for component '$($focusedComponent.Name)': $_"
        }
    }
    
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            # AI: ENHANCED - Support for UIElement-based screens
            if ($currentScreen -is [UIElement]) {
                # New UIElement-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen -is [Screen]) {
                # Legacy class-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen.HandleInput) {
                # Hashtable/functional screen - use scriptblock invocation
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { Stop-TuiEngine }
                }
            }
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([object]$InitialScreen)  # AI: Accept both UIElement and hashtable screens
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

# AI: REWRITTEN - NCurses Compositor Render-Frame
function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        if ($global:TuiState.CompositorMode -and $null -ne $global:TuiState.CompositorBuffer) {
            # AI: NEW - NCurses-style compositor rendering
            Render-FrameCompositor
        } else {
            # AI: LEGACY - Fall back to old rendering for compatibility
            Render-FrameLegacy
        }
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    # AI: NEW - NCurses-style compositor rendering pipeline
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                if ($global:TuiState.CurrentScreen -is [UIElement]) {
                    # New UIElement-based screen - render to its private buffer
                    $global:TuiState.CurrentScreen.Render()
                    
                    # Composite screen buffer onto master compositor
                    $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                    if ($null -ne $screenBuffer) {
                        $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                    }
                } else {
                    # Legacy screen - render directly (will be deprecated)
                    $global:TuiState.CurrentScreen.Render()
                }
            }
        }
        
        # 3. Render dialogs on top
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog -is [UIElement]) {
                    # New UIElement-based dialog
                    $dialog.Render()
                    $dialogBuffer = $dialog.GetBuffer()
                    if ($null -ne $dialogBuffer) {
                        $pos = $dialog.GetAbsolutePosition()
                        $global:TuiState.CompositorBuffer.BlendBuffer($dialogBuffer, $pos.X, $pos.Y)
                    }
                } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                    # Class-based dialog with Render() method
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    # Functional/hashtable dialog with Render scriptblock
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
        # Fall back to legacy rendering
        Render-FrameLegacy
    }
}

function Render-CompositorToConsole {
    # AI: NEW - Convert TuiBuffer to optimized console output
    $outputBuilder = [System.Text.StringBuilder]::new(20000)
    $lastFG = -1
    $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1
    
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $rowChanged = $false
            $rowOutput = [System.Text.StringBuilder]::new()
            
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $newCell = $global:TuiState.CompositorBuffer.GetCell($x, $y)
                $oldLegacyCell = $global:TuiState.FrontBuffer[$y, $x]
                
                # Convert TuiCell to legacy format for comparison
                $newLegacyCell = $newCell.ToLegacyFormat()
                
                # Check if cell changed
                if ($forceFullRender -or 
                    $newLegacyCell.Char -ne $oldLegacyCell.Char -or
                    $newLegacyCell.FG -ne $oldLegacyCell.FG -or
                    $newLegacyCell.BG -ne $oldLegacyCell.BG) {
                    
                    $rowChanged = $true
                    
                    # Update front buffer
                    $global:TuiState.FrontBuffer[$y, $x] = $newLegacyCell
                    
                    # Add color codes if needed
                    if ($newLegacyCell.FG -ne $lastFG -or $newLegacyCell.BG -ne $lastBG) {
                        $fgCode = Get-AnsiColorCode $newLegacyCell.FG
                        $bgCode = Get-AnsiColorCode $newLegacyCell.BG -IsBackground $true
                        [void]$rowOutput.Append("`e[${fgCode};${bgCode}m")
                        $lastFG = $newLegacyCell.FG
                        $lastBG = $newLegacyCell.BG
                    }
                    
                    [void]$rowOutput.Append($newLegacyCell.Char)
                } else {
                    # Cell unchanged - add placeholder for position tracking
                    [void]$rowOutput.Append($null)
                }
            }
            
            # Output the row if it changed
            if ($rowChanged) {
                [void]$outputBuilder.Append("`e[$($y + 1);1H")
                $rowStr = $rowOutput.ToString() -replace [char]0, ''
                [void]$outputBuilder.Append($rowStr)
            }
        }
        
        [void]$outputBuilder.Append("`e[0m")
        
        if ($outputBuilder.Length -gt 10) {  # Only output if there are substantial changes
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Render-FrameLegacy {
    # AI: LEGACY - Original rendering code for compatibility
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component $global:TuiState.CurrentScreen.Name -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
            }
        }
        
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog.GetType().IsSubclassOf([UIElement]) -or $dialog -is [UIElement]) {
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        Render-BufferOptimized
        
    } catch {
        Write-Log -Level Error -Message "Legacy rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    # AI: ENHANCED - Accept both UIElement and legacy screen objects
    param([object]$Screen)
    if (-not $Screen) { return }
    
    $screenName = if ($Screen -is [UIElement]) { $Screen.Name } elseif ($Screen -is [Screen]) { $Screen.Name } else { $Screen.Name }
    Write-Log -Level Debug -Message "Pushing screen: $screenName"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($global:TuiState.CurrentScreen) {
            # Handle exit for current screen
            if ($global:TuiState.CurrentScreen -is [UIElement]) {
                # New UIElement-based screen
                # No explicit OnExit method - handled by framework
            } elseif ($global:TuiState.CurrentScreen -is [Screen]) {
                # Legacy class-based screen
                $global:TuiState.CurrentScreen.OnExit()
            } elseif ($global:TuiState.CurrentScreen.OnExit) {
                # Functional screen
                $global:TuiState.CurrentScreen.OnExit.Invoke()
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # Initialize new screen
        if ($Screen -is [UIElement]) {
            # New UIElement-based screen - ensure it's sized to fit screen
            if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) {  # Default size
                $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            }
            # Trigger initial render
            $Screen.RequestRedraw()
        } elseif ($Screen -is [Screen]) {
            # Legacy class-based screen
            $Screen.OnEnter()
        } elseif ($Screen.Init) { 
            # Functional screen
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $screenName }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$screenName': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $global:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering - Legacy Support
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:TuiState.BufferWidth) { break }
        if ($currentX -ge 0) { $global:TuiState.BackBuffer[$Y, $currentX] = @{ Char = $char; FG = $ForegroundColor; BG = $BackgroundColor } }
        $currentX++
    }
}

function Write-BufferBox {
    param([int]$X, [int]$Y, [int]$Width, [int]$Height, [string]$BorderStyle = "Single", [ConsoleColor]$BorderColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, [string]$Title = "")
    $borders = Get-BorderChars -Style $BorderStyle
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    if ($Title) {
        $titleText = " $Title "; if ($titleText.Length -gt ($Width-2)) { $titleText = " $($Title.Substring(0,[Math]::Max(0,$Width-5)))... " }
        Write-BufferString -X ($X + [Math]::Floor(($Width - $titleText.Length) / 2)) -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function Render-BufferOptimized {
    $outputBuilder = [System.Text.StringBuilder]::new(20000); $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 0
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $backCell = $global:TuiState.BackBuffer[$y, $x]; $frontCell = $global:TuiState.FrontBuffer[$y, $x]
                if (-not $forceFullRender -and $backCell.Char -eq $frontCell.Char -and $backCell.FG -eq $frontCell.FG -and $backCell.BG -eq $frontCell.BG) { continue }
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) { $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null }
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG; $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null; $lastFG = $backCell.FG; $lastBG = $backCell.BG
                }
                $outputBuilder.Append($backCell.Char) | Out-Null
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = $backCell.Char; FG = $backCell.FG; BG = $backCell.BG }
            }
        }
        $outputBuilder.Append("`e[0m") | Out-Null
        if ($outputBuilder.Length -gt 0) { [Console]::Write($outputBuilder.ToString()) }
    } catch { Write-Warning "Render error: $_" }
}
#endregion

#region Component System - Enhanced for UIElement
function Initialize-ComponentSystem { $global:TuiState.Components = @(); $global:TuiState.FocusedComponent = $null }

function Register-Component { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    $global:TuiState.Components += $Component
    
    # Initialize component based on type
    if ($Component -is [UIElement]) {
        # New UIElement-based component - no explicit init needed
        Write-Log -Level Debug -Message "Registered UIElement component: $($Component.Name)"
    } elseif ($Component.Init) { 
        try { & $Component.Init -self $Component } catch { Write-Warning "Component init error: $_" } 
    }
    return $Component 
}

function Set-ComponentFocus { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) { return }
    
    # Blur current component
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    
    # Set new focused component
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    
    # Focus new component
    if ($null -ne $Component) {
        if ($Component -is [UIElement]) {
            $Component.OnFocus()
        } else {
            $Component.OnFocus?.Invoke()
        }
    }
    
    Request-TuiRefresh 
}

function Clear-ComponentFocus { 
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    $global:TuiState.FocusedComponent = $null
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $null }
    Request-TuiRefresh 
}

# AI: ENHANCED - Support UIElement focusable detection
function Get-NextFocusableComponent { 
    param([object]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = @()
    
    function Find-Focusable([object]$Comp) { 
        if ($Comp -is [UIElement]) {
            # New UIElement-based component
            if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
                $focusableComponents += $Comp
            }
            # Check children
            foreach ($child in $Comp.Children) {
                Find-Focusable $child
            }
        } else {
            # Legacy component
            if ($Comp.IsFocusable -eq $true -and $Comp.Visible -ne $false) { 
                $focusableComponents += $Comp 
            }
            if ($Comp.Children) { 
                foreach ($c in $Comp.Children) { Find-Focusable $c } 
            }
        }
    }
    
    # Find focusable components in current screen
    if ($global:TuiState.CurrentScreen -is [UIElement]) {
        Find-Focusable $global:TuiState.CurrentScreen
    } elseif ($global:TuiState.CurrentScreen.Components) { 
        foreach ($c in $global:TuiState.CurrentScreen.Components.Values) { Find-Focusable $c } 
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by tab index and position
    $sorted = $focusableComponents | Sort-Object { 
        if ($_ -is [UIElement]) {
            $_.TabIndex * 10000 + $_.Y * 100 + $_.X
        } else {
            ($_.TabIndex ?? 0) * 10000 + ($_.Y ?? 0) * 100 + ($_.X ?? 0)
        }
    }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Handle-TabNavigation { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

# AI: LEGACY - Helper functions maintained for compatibility
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Move-Focus { param([bool]$Reverse = $false); Handle-TabNavigation -Reverse $Reverse }

function Get-CurrentDialog {
    try {
        if (Get-Module -Name 'dialog-system-class' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system-class') { $script:DialogState.CurrentDialog }
        } elseif (Get-Module -Name 'dialog-system' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system') { $script:DialogState.CurrentDialog }
        }
    } catch {
        Write-Log -Level Warning -Message "Error accessing dialog system: $_"
    }
    return $null
}

function Handle-DialogInput {
    param([System.ConsoleKeyInfo]$Key)
    try {
        $dialog = Get-CurrentDialog
        if ($dialog) {
            if ($dialog -is [UIElement]) {
                # New UIElement-based dialog
                return $dialog.HandleInput($Key)
            } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                # Legacy class-based dialog
                $dialog.HandleInput($Key)
                return $true
            } elseif ($dialog -is [hashtable] -and $dialog.HandleInput) {
                # Functional dialog
                return & $dialog.HandleInput -self $dialog -Key $Key
            }
        }
    } catch {
        Write-Log -Level Warning -Message "Error handling dialog input: $_"
    }
    return $false
}

function Update-DialogSystem {
    # Dialog system handles its own updates if loaded
}

function Stop-AllTuiAsyncJobs {
    Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)"
}
#endregion

#region Layout Management & Utilities
function Initialize-LayoutEngines { $global:TuiState.Layouts = @{} }
function Get-BorderChars { param([string]$Style); $styles = @{ Single=@{TopLeft='┌';TopRight='┐';BottomLeft='└';BottomRight='┘';Horizontal='─';Vertical='│'}; Double=@{TopLeft='╔';TopRight='╗';BottomLeft='╚';BottomRight='╝';Horizontal='═';Vertical='║'}; Rounded=@{TopLeft='╭';TopRight='╮';BottomLeft='╰';BottomRight='╯';Horizontal='─';Vertical='│'} }; return $styles[$Style] ?? $styles.Single }
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Get-WordWrappedLines { param([string]$Text, [int]$MaxWidth); if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }; $lines = @(); $words = $Text -split '\s+'; $sb = [System.Text.StringBuilder]::new(); foreach ($word in $words) { if ($sb.Length -eq 0) { [void]$sb.Append($word) } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) { [void]$sb.Append(' ').Append($word) } else { $lines += $sb.ToString(); [void]$sb.Clear().Append($word) } }; if ($sb.Length -gt 0) { $lines += $sb.ToString() }; return $lines }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }

# AI: NEW - Compositor helper functions
function Get-ThemeColor {
    param([string]$ColorName)
    # Simple theme color mapping - can be enhanced later
    $themeColors = @{
        Background = [ConsoleColor]::Black
        Foreground = [ConsoleColor]::White
        Border = [ConsoleColor]::Gray
        Focus = [ConsoleColor]::Cyan
        Highlight = [ConsoleColor]::Yellow
    }
    return $themeColors[$ColorName] ?? [ConsoleColor]::Black
}
#endregion

Export-ModuleMember -Function 'Initialize-TuiEngine', 'Start-TuiLoop', 'Stop-TuiEngine', 'Push-Screen', 'Pop-Screen', 'Request-TuiRefresh', 'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer', 'Get-BorderChars', 'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 'Get-NextFocusableComponent', 'Handle-TabNavigation', 'Get-WordWrappedLines', 'Get-FocusedComponent', 'Move-Focus', 'Get-CurrentDialog', 'Handle-DialogInput', 'Update-DialogSystem', 'Stop-AllTuiAsyncJobs', 'Get-ThemeColor' -Variable 'TuiState'


####\refactor_checkpoints\checkpoint_20250630_052441_phase-1-verified\screens\task-list-screen.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Task List Screen
# Displays and manages tasks.
# ==============================================================================

# AI: CRITICAL FIX - Import models module for TaskStatus enum and other types
using module '..\modules\models.psm1'

# AI: FIX - Use relative paths for better portability
using module '..\components\ui-classes.psm1'
using module '..\layout\panels-class.psm1'
using module '..\components\advanced-data-components.psm1'
using module '..\modules\dialog-system-class.psm1'

class TaskListScreen : Screen {
    # --- UI Components ---
    [BorderPanel] $MainPanel
    [Table] $TaskTable
    [ContentPanel] $NavPanel

    # --- State ---
    [string] $FilterStatus = "All"

    TaskListScreen([hashtable]$services) : base("TaskListScreen", $services) { }

    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # --- Panel Setup ---
            $this.MainPanel = [BorderPanel]::new("TaskListMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "Task List"
            $this.AddPanel($this.MainPanel)

            # --- Task Table ---
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.SetColumns(@(
                [TableColumn]::new("Title", "Task Title", 50),
                [TableColumn]::new("Status", "Status", 15),
                [TableColumn]::new("Priority", "Priority", 12),
                [TableColumn]::new("DueDate", "Due Date", 15)
            ))
            
            $tableContainer = [BorderPanel]::new("TableContainer", 1, 1, 118, 24)
            $tableContainer.ShowBorder = $false
            $tableContainer.AddChild($this.TaskTable)
            $this.MainPanel.AddChild($tableContainer)
            
            # --- Navigation Panel ---
            $this.NavPanel = [ContentPanel]::new("NavPanel", 1, 26, 118, 3)
            $this.MainPanel.AddChild($this.NavPanel)
            
            # --- Event Subscriptions & Data Load ---
            $this.SubscribeToEvent("Tasks.Changed", { $this.RefreshData() })
            $this.RefreshData()
        }
    }

    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            $allTasks = @($this.Services.DataManager.GetTasks())
            $filteredTasks = switch ($this.FilterStatus) {
                "Active" { $allTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed } }
                "Completed" { $allTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed } }
                default { $allTasks }
            }
            $this.TaskTable.SetData($filteredTasks)
            $this.UpdateNavText()
        }
    }

    hidden [void] UpdateNavText() {
        $navContent = @(
            "[N]ew | [E]dit | [D]elete | [Space]Toggle | [F]ilter: $($this.FilterStatus) | [Esc]Back"
        )
        $this.NavPanel.SetContent($navContent)
    }

    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) { $this.TaskTable.SelectPrevious() }
                ([ConsoleKey]::DownArrow) { $this.TaskTable.SelectNext() }
                ([ConsoleKey]::Spacebar) { $this.ToggleSelectedTask() }
                ([ConsoleKey]::Escape) { $this.Services.Navigation.PopScreen() }
                default {
                    switch ($key.KeyChar.ToString().ToUpper()) {
                        'N' { $this.ShowNewTaskDialog() }
                        'E' { $this.EditSelectedTask() }
                        'D' { $this.DeleteSelectedTask() }
                        'F' { $this.CycleFilter() }
                    }
                }
            }
        }
    }
    
    hidden [void] ToggleSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            # AI: FIX - TaskStatus enum should now be available from models.psm1 import
            if ($task.Status -eq [TaskStatus]::Completed) {
                $task.Status = [TaskStatus]::Pending
            } else {
                $task.Complete()
            }
            $this.Services.DataManager.UpdateTask($task)
        }
    }

    hidden [void] ShowNewTaskDialog() {
        # AI: FIX - Implemented new task dialog functionality
        Write-Log -Level Info -Message "New task dialog requested"
        
        # AI: FIX - Capture $this context for closure
        $dataManager = $this.Services.DataManager
        $refreshCallback = { $this.RefreshData() }.GetNewClosure()
        
        # Use the input dialog from dialog system
        Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {
            param($Value)
            if (-not [string]::IsNullOrWhiteSpace($Value)) {
                $newTask = $dataManager.AddTask($Value, "", [TaskPriority]::Medium, "General")
                Write-Log -Level Info -Message "Created new task: $($newTask.Title)"
                & $refreshCallback
            }
        }
    }

    hidden [void] EditSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Edit task requested for: $($task.Title)"
        }
    }

    hidden [void] DeleteSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Delete task requested for: $($task.Title)"
        }
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\refactor_checkpoints\checkpoint_20250630_053620_phase 2 complete\components\advanced-data-components.psm1
# Advanced Data Components Module for PMC Terminal v5
# Enhanced data display components with sorting, filtering, and pagination

using namespace System.Text
using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Simple Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

class Table : Component {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    
    Table([string]$name) : base($name) {
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        # AI: FIX - Explicit array initialization
        $this.Data = @()
        $this.SelectedIndex = 0
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
    }
    
    [void] SetData([object[]]$data) {
        # AI: FIX - Defensive array initialization
        $this.Data = if ($null -eq $data) { @() } else { @($data) }
        # AI: FIX - Safe array count check
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -ge $dataCount) {
            $this.SelectedIndex = [Math]::Max(0, $dataCount - 1)
        }
    }
    
    [void] SelectNext() {
        # AI: FIX - Safe array count check
        $dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -lt ($dataCount - 1)) {
            $this.SelectedIndex++
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
        }
    }
    
    [object] GetSelectedItem() {
        # AI: FIX - Safe array access with null checking
        if ($null -eq $this.Data) { return $null }
        
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        
        if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {
            return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }
        }
        return $null
    }
    
    hidden [void] _RenderContent() {
        # AI: Render table to buffer using Write-BufferString
        if (-not (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue)) {
            return # Buffer functions not available
        }
        
        # AI: FIX - Get render position from parent panel if available
        $renderX = 0
        $renderY = 0
        $maxWidth = 120  # Default max width
        
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X
            $renderY = $contentArea.Y
            $maxWidth = $contentArea.Width
        }
        
        $currentY = $renderY
        
        # Header
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            $headerLine = ""
            foreach ($col in $this.Columns) {
                $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                $headerLine += $headerText + " "
            }
            # AI: FIX - Trim header to max width
            if ($headerLine.TrimEnd().Length -gt $maxWidth) {
                $headerLine = $headerLine.Substring(0, $maxWidth)
            }
            Write-BufferString -X $renderX -Y $currentY -Text $headerLine.TrimEnd() -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
            $currentY++
            Write-BufferString -X $renderX -Y $currentY -Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $maxWidth)) -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            $currentY++
        }
        
        # AI: FIX - Safe data array handling
        $dataToRender = @()
        if ($null -ne $this.Data) {
            $dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }
        }
        
        # Data rows
        for ($i = 0; $i -lt $dataToRender.Count; $i++) {
            $row = $dataToRender[$i]
            if ($null -eq $row) { continue }
            
            $rowLine = ""
            $isSelected = ($i -eq $this.SelectedIndex)
            
            foreach ($col in $this.Columns) {
                $cellValue = ""
                if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                    $cellValue = $row[$col.Key]?.ToString() ?? ""
                } elseif ($row.PSObject.Properties[$col.Key]) {
                    $cellValue = $row.($col.Key)?.ToString() ?? ""
                }
                
                $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                $rowLine += $cellText + " "
            }
            
            $finalLine = $rowLine.TrimEnd()
            if ($isSelected) {
                $finalLine = "> $finalLine"
            } else {
                $finalLine = "  $finalLine"
            }
            
            $fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
            $bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            # AI: FIX - Ensure line doesn't exceed parent bounds
            if ($finalLine.Length -gt $maxWidth) {
                $finalLine = $finalLine.Substring(0, $maxWidth)
            }
            Write-BufferString -X $renderX -Y $currentY -Text $finalLine -ForegroundColor $fg -BackgroundColor $bg
            $currentY++
        }
        
        if ($dataToRender.Count -eq 0) {
            Write-BufferString -X $renderX -Y $currentY -Text "  No data to display" -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
        }
    }
}

#endregion

#region Advanced Data Table Class

class DataTableComponent : UIElement {
    # ... (class content is unchanged) ...
    [hashtable[]] $Data = @()
    [hashtable[]] $Columns = @()
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 80
    [int] $Height = 20
    [string] $Title = "Data Table"
    [bool] $ShowBorder = $true
    [bool] $IsFocusable = $true
    [int] $SelectedRow = 0
    [int] $ScrollOffset = 0
    [string] $SortColumn
    [string] $SortDirection = "Ascending"
    [string] $FilterText = ""
    [string] $FilterColumn
    [int] $PageSize = 0  # 0 = auto-calculate
    [int] $CurrentPage = 0
    [bool] $ShowHeader = $true
    [bool] $ShowFooter = $true
    [bool] $ShowRowNumbers = $false
    [bool] $AllowSort = $true
    [bool] $AllowFilter = $true
    [bool] $AllowSelection = $true
    [bool] $MultiSelect = $false
    [int[]] $SelectedRows = @()
    [hashtable[]] $FilteredData = @()
    [hashtable[]] $ProcessedData = @()
    [bool] $FilterMode = $false
    hidden [int] $_lastRenderedWidth = 0
    hidden [int] $_lastRenderedHeight = 0
    
    # Event handlers
    [scriptblock] $OnRowSelect
    [scriptblock] $OnSelectionChange
    
    DataTableComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    DataTableComponent([string]$name, [hashtable[]]$data, [hashtable[]]$columns) : base($name) {
        $this.IsFocusable = $true
        $this.Data = $data
        $this.Columns = $columns
        $this.ProcessData()
    }
    
    [void] ProcessData() {
        Invoke-WithErrorHandling -Component "$($this.Name).ProcessData" -Context "Processing table data" -ScriptBlock {
            # Filter data
            if ([string]::IsNullOrWhiteSpace($this.FilterText)) {
                $this.FilteredData = $this.Data
            } else {
                if ($this.FilterColumn) {
                    # Filter specific column
                    $this.FilteredData = @($this.Data | Where-Object {
                        $value = $_."$($this.FilterColumn)"
                        $value -and $value.ToString() -like "*$($this.FilterText)*"
                    })
                } else {
                    # Filter all columns
                    $this.FilteredData = @($this.Data | Where-Object {
                        $row = $_
                        $matched = $false
                        foreach ($col in $this.Columns) {
                            if ($col.Filterable -ne $false) {
                                $value = $row."$($col.Name)"
                                if ($value -and $value.ToString() -like "*$($this.FilterText)*") {
                                    $matched = $true
                                    break
                                }
                            }
                        }
                        $matched
                    })
                }
            }
            
            # Sort data
            if ($this.SortColumn -and $this.AllowSort) {
                $this.ProcessedData = $this.FilteredData | Sort-Object -Property $this.SortColumn -Descending:($this.SortDirection -eq "Descending")
            } else {
                $this.ProcessedData = $this.FilteredData
            }
            
            # Reset selection if needed
            if ($this.SelectedRow -ge $this.ProcessedData.Count) {
                $this.SelectedRow = [Math]::Max(0, $this.ProcessedData.Count - 1)
            }
            
            # Calculate page size if auto
            if ($this.PageSize -eq 0) {
                $headerLines = $this.ShowHeader ? 3 : 0
                $footerLines = $this.ShowFooter ? 2 : 0
                $filterLines = $this.AllowFilter ? 2 : 0
                $borderAdjust = $this.ShowBorder ? 2 : 0
                $calculatedPageSize = $this.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
                $this.PageSize = [Math]::Max(1, $calculatedPageSize)
            }
            
            # Adjust current page
            $totalPages = [Math]::Ceiling($this.ProcessedData.Count / [Math]::Max(1, $this.PageSize))
            if ($this.CurrentPage -ge $totalPages) {
                $this.CurrentPage = [Math]::Max(0, $totalPages - 1)
            }
        }
    }
    
    [hashtable] GetContentBounds() {
        $borderOffset = $this.ShowBorder ? 1 : 0
        return @{
            X = $this.X + $borderOffset
            Y = $this.Y + $borderOffset
            Width = $this.Width - (2 * $borderOffset)
            Height = $this.Height - (2 * $borderOffset)
        }
    }
    
    hidden [void] _RenderContent() {
        # AI: TEMPORARY - Complex table rendering needs to be rewritten for buffer-based system
        # This is a placeholder until proper buffer rendering is implemented
        if (-not (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue)) {
            return # Buffer functions not available
        }
        
        # Simple placeholder rendering
        Write-BufferString -X ($this.X + 1) -Y ($this.Y + 1) -Text "[DataTable: $($this.Title)]" -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
        
        return # TODO: Implement full buffer-based table rendering
        
        # ORIGINAL COMPLEX RENDERING CODE (commented out for now):
        $renderedContent = [StringBuilder]::new()
        
        # Force ProcessData if dimensions changed
        if ($this._lastRenderedWidth -ne $this.Width -or $this._lastRenderedHeight -ne $this.Height) {
            $this.ProcessData()
            $this._lastRenderedWidth = $this.Width
            $this._lastRenderedHeight = $this.Height
        }
        
        # Calculate content area based on border settings
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        $contentHeight = $this.Height

        if ($this.ShowBorder) {
            $borderColor = ($this.IsFocusable -and $this.IsFocused) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
            
            [void]$renderedContent.Append($this.MoveCursor($this.X, $this.Y))
            [void]$renderedContent.Append($this.SetColor($borderColor))
            [void]$renderedContent.Append($this.RenderBorder($this.Title))
            
            # Adjust content area for border
            $contentX = $this.X + 1
            $contentY = $this.Y + 1
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
        }
        
        $currentY = $contentY
        
        # Filter bar
        if ($this.AllowFilter) {
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::White))
            [void]$renderedContent.Append("Filter: ")
            
            $filterDisplayText = $this.FilterText ? $this.FilterText : "Type to filter..."
            $filterColor = $this.FilterText ? [ConsoleColor]::Yellow : [ConsoleColor]::DarkGray
            [void]$renderedContent.Append($this.SetColor($filterColor))
            [void]$renderedContent.Append($filterDisplayText)
            
            $currentY += 2
        }
        
        # Calculate column widths
        $totalDefinedWidth = ($this.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum ?? 0
        $flexColumns = @($this.Columns | Where-Object { -not $_.Width })
        $columnSeparators = $this.Columns.Count -gt 1 ? $this.Columns.Count - 1 : 0
        $rowNumberWidth = $this.ShowRowNumbers ? 5 : 0
        $remainingWidth = $contentWidth - $totalDefinedWidth - $rowNumberWidth - $columnSeparators
        
        $flexWidth = ($flexColumns.Count -gt 0) ? [Math]::Floor($remainingWidth / $flexColumns.Count) : 0
        
        # Assign calculated widths
        foreach ($col in $this.Columns) {
            $col.CalculatedWidth = $col.Width ?? [Math]::Max(5, $flexWidth)
        }
        
        # Header
        if ($this.ShowHeader) {
            $headerX = $contentX
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append("#".PadRight(4))
                $headerX += 5
            }
            
            foreach ($col in $this.Columns) {
                $headerText = $col.Header ?? $col.Name
                $columnWidth = $col.CalculatedWidth
                
                if ($this.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $this.SortColumn) {
                    $sortIndicator = ($this.SortDirection -eq "Ascending") ? "▲" : "▼"
                    $headerText = "$headerText $sortIndicator"
                }
                
                if ($headerText.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $headerText = $headerText.Substring(0, $maxLength) + "..."
                }
                
                $alignedText = switch ($col.Align) {
                    "Right" { $headerText.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $headerText.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $headerText + " " * $rightPad
                    }
                    default { $headerText.PadRight($columnWidth) }
                }
                
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append($alignedText)
                
                $headerX += $columnWidth + 1
            }
            
            $currentY++
            
            [void]$renderedContent.Append($this.MoveCursor($contentX, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append("─" * $contentWidth)
            $currentY++
        }
        
        # Data rows
        $dataToRender = ($this.ProcessedData.Count -eq 0 -and $this.Data.Count -gt 0) ? $this.Data : $this.ProcessedData
        
        $startIdx = $this.CurrentPage * $this.PageSize
        $endIdx = [Math]::Min($startIdx + $this.PageSize - 1, $dataToRender.Count - 1)
        
        for ($i = $startIdx; $i -le $endIdx; $i++) {
            $row = $dataToRender[$i]
            $rowX = $contentX
            
            $isSelected = $this.MultiSelect ? ($this.SelectedRows -contains $i) : ($i -eq $this.SelectedRow)
            
            $rowBg = $isSelected ? [ConsoleColor]::Cyan : [ConsoleColor]::Black
            $rowFg = $isSelected ? [ConsoleColor]::Black : [ConsoleColor]::White
            
            if ($isSelected) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(" " * $contentWidth)
            }
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(($i + 1).ToString().PadRight(4))
                $rowX += 5
            }
            
            foreach ($col in $this.Columns) {
                $value = $row."$($col.Name)"
                $columnWidth = $col.CalculatedWidth
                
                $displayValue = if ($col.Format -and $value) { & $col.Format $value } else { "$($value)" }
                
                if ($displayValue.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $displayValue = ($maxLength -le 0) ? "..." : ($displayValue.Substring(0, $maxLength) + "...")
                }
                
                $alignedValue = switch ($col.Align) {
                    "Right" { $displayValue.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $displayValue.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $displayValue + " " * $rightPad
                    }
                    default { $displayValue.PadRight($columnWidth) }
                }
                
                $cellFg = if ($col.Color -and -not $isSelected) {
                    Get-ThemeColor (& $col.Color $value $row)
                } else {
                    $rowFg
                }
                
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor($cellFg))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append($alignedValue)
                
                $rowX += $columnWidth + 1
            }
            
            $currentY++
        }
        
        # Empty state
        if ($dataToRender.Count -eq 0) {
            $emptyMessage = $this.FilterText ? "No results match the filter" : "No data to display"
            $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
            $msgY = $contentY + [Math]::Floor($contentHeight / 2)
            [void]$renderedContent.Append($this.MoveCursor($msgX, $msgY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($emptyMessage)
        }
        
        # Footer
        if ($this.ShowFooter) {
            $footerY = $contentY + $contentHeight - 1
            
            $statusText = "$($dataToRender.Count) rows"
            if ($this.FilterText) { $statusText += " (filtered from $($this.Data.Count))" }
            if ($this.MultiSelect) { $statusText += " | $($this.SelectedRows.Count) selected" }
            
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $footerY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($statusText)
            
            if ($dataToRender.Count -gt $this.PageSize) {
                $totalPages = [Math]::Ceiling($dataToRender.Count / [Math]::Max(1, $this.PageSize))
                $pageText = "Page $($this.CurrentPage + 1)/$totalPages"
                [void]$renderedContent.Append($this.MoveCursor($contentX + $contentWidth - $pageText.Length - 1, $footerY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Blue))
                [void]$renderedContent.Append($pageText)
            }
        }
        
        # [void]$renderedContent.Append($this.ResetColor())
        # return $renderedContent.ToString()
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # Filter mode
        if ($key.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($key.Key) {
                ([ConsoleKey]::F) {
                    $this.FilterMode = -not $this.FilterMode
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::S) {
                    if ($this.AllowSort) {
                        $sortableCols = @($this.Columns | Where-Object { $_.Sortable -ne $false })
                        if ($sortableCols.Count -gt 0) {
                            $currentIdx = [array]::IndexOf($sortableCols.Name, $this.SortColumn)
                            $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                            $this.SortColumn = $sortableCols[$nextIdx].Name
                            $this.ProcessData()
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
            }
        }
        
        # Filter text input
        if ($this.FilterMode) {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.FilterMode = $false
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $this.FilterMode = $false
                    $this.ProcessData()
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.FilterText.Length -gt 0) {
                        $this.FilterText = $this.FilterText.Substring(0, $this.FilterText.Length - 1)
                        $this.ProcessData()
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                        $this.FilterText += $key.KeyChar
                        $this.ProcessData()
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            return $false
        }
        
        # Normal navigation
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedRow -gt 0) {
                    $this.SelectedRow--
                    if ($this.SelectedRow -lt ($this.CurrentPage * $this.PageSize)) {
                        $this.CurrentPage--
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedRow -lt ($this.ProcessedData.Count - 1)) {
                    $this.SelectedRow++
                    if ($this.SelectedRow -ge (($this.CurrentPage + 1) * $this.PageSize)) {
                        $this.CurrentPage++
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                if ($this.OnRowSelect -and $this.ProcessedData.Count -gt 0) {
                    $selectedData = $this.MultiSelect ? @($this.SelectedRows | ForEach-Object { $this.ProcessedData[$_] }) : $this.ProcessedData[$this.SelectedRow]
                    & $this.OnRowSelect $selectedData $this.SelectedRow
                }
                return $true
            }
        }
        
        return $false
    }
    
    # AI: Helper methods removed - using buffer-based rendering instead of ANSI
    
    # Public methods
    [void] RefreshData() {
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetData([hashtable[]]$data) {
        $this.Data = $data
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this.ProcessData()
        Request-TuiRefresh
    }
}
#endregion

#region Factory Functions for Backward Compatibility

function New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DataTable_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $data = $Props.Data ?? @()
    $columns = $Props.Columns ?? @()
    
    $table = [DataTableComponent]::new($name, $data, $columns)
    
    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.Title = $Props.Title ?? $table.Title
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader
    $table.ShowFooter = $Props.ShowFooter ?? $table.ShowFooter
    $table.ShowRowNumbers = $Props.ShowRowNumbers ?? $table.ShowRowNumbers
    $table.AllowSort = $Props.AllowSort ?? $table.AllowSort
    $table.AllowFilter = $Props.AllowFilter ?? $table.AllowFilter
    $table.AllowSelection = $Props.AllowSelection ?? $table.AllowSelection
    $table.MultiSelect = $Props.MultiSelect ?? $table.MultiSelect
    $table.Visible = $Props.Visible ?? $table.Visible
    $table.OnRowSelect = $Props.OnRowSelect ?? $table.OnRowSelect
    $table.OnSelectionChange = $Props.OnSelectionChange ?? $table.OnSelectionChange
    
    return $table
}
#endregion

Export-ModuleMember -Function 'New-TuiDataTable'



####\refactor_checkpoints\checkpoint_20250630_053620_phase 2 complete\components\advanced-input-components.psm1
# Advanced Input Components - Phase 2 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

using module ..\components\tui-primitives.psm1

#region Advanced Input Classes

# AI: REFACTORED - MultilineTextBox converted from functional to class-based
class MultilineTextBoxComponent : UIElement {
    [string[]]$Lines = @("")
    [string]$Placeholder = "Enter text..."
    [int]$MaxLines = 10
    [int]$MaxLineLength = 100
    [int]$CurrentLine = 0
    [int]$CursorPosition = 0
    [int]$ScrollOffsetY = 0
    [bool]$WordWrap = $true
    [scriptblock]$OnChange
    
    MultilineTextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 40
        $this.Height = 10
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Buffer-based rendering with parent Panel integration
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Calculate visible area
            $textAreaHeight = $this.Height - 2
            $textAreaWidth = $this.Width - 2
            $startLine = $this.ScrollOffsetY
            $endLine = [Math]::Min($this.Lines.Count - 1, $startLine + $textAreaHeight - 1)
            
            # AI: Render text lines
            for ($i = $startLine; $i -le $endLine; $i++) {
                if ($i -ge $this.Lines.Count) { break }
                
                $line = $this.Lines[$i] ?? ""
                $displayLine = $line
                if ($displayLine.Length -gt $textAreaWidth) {
                    $displayLine = $displayLine.Substring(0, $textAreaWidth)
                }
                
                $lineY = $renderY + 1 + ($i - $startLine)
                $parentPanel.WriteToBuffer($renderX + 1, $lineY, $displayLine, [ConsoleColor]::White, [ConsoleColor]::Black)
            }
            
            # AI: Show placeholder if empty and not focused
            if ($this.Lines.Count -eq 1 -and [string]::IsNullOrEmpty($this.Lines[0]) -and -not $this.IsFocused) {
                $parentPanel.WriteToBuffer($renderX + 1, $renderY + 1, $this.Placeholder, [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
            }
            
            # AI: Draw cursor if focused
            if ($this.IsFocused) {
                $cursorLine = $this.CurrentLine - $this.ScrollOffsetY
                if ($cursorLine -ge 0 -and $cursorLine -lt $textAreaHeight) {
                    $cursorX = $renderX + 1 + $this.CursorPosition
                    $cursorY = $renderY + 1 + $cursorLine
                    if ($cursorX -lt $renderX + $this.Width - 1) {
                        $parentPanel.WriteToBuffer($cursorX, $cursorY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                    }
                }
            }
            
            # AI: Draw scrollbar if needed
            if ($this.Lines.Count -gt $textAreaHeight) {
                $scrollbarX = $renderX + $this.Width - 1
                $scrollHeight = $textAreaHeight
                $thumbSize = [Math]::Max(1, [Math]::Floor($scrollHeight * $textAreaHeight / $this.Lines.Count))
                $thumbPos = [Math]::Floor($scrollHeight * $this.ScrollOffsetY / ($this.Lines.Count - $textAreaHeight))
                
                for ($i = 0; $i -lt $scrollHeight; $i++) {
                    $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                    $parentPanel.WriteToBuffer($scrollbarX, $renderY + 1 + $i, $char, [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentLine = $this.Lines[$this.CurrentLine] ?? ""
            $originalLines = $this.Lines.Clone()
            $handled = $true
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = $this.Lines[$this.CurrentLine].Length
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $currentLine.Length) {
                        $this.CursorPosition++
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $currentLine.Length }
                ([ConsoleKey]::Enter) {
                    if ($this.Lines.Count -lt $this.MaxLines) {
                        $beforeCursor = $currentLine.Substring(0, $this.CursorPosition)
                        $afterCursor = $currentLine.Substring($this.CursorPosition)
                        
                        $this.Lines[$this.CurrentLine] = $beforeCursor
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($afterCursor) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.Lines[$this.CurrentLine] = $currentLine.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0 -and $this.Lines.Count -gt 1) {
                        $previousLine = $this.Lines[$this.CurrentLine - 1]
                        $this.CursorPosition = $previousLine.Length
                        $this.Lines[$this.CurrentLine - 1] = $previousLine + $currentLine
                        $this.Lines = @($this.Lines[0..($this.CurrentLine - 1)]) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        $this.CurrentLine--
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $currentLine.Length) {
                        $this.Lines[$this.CurrentLine] = $currentLine.Remove($this.CursorPosition, 1)
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $nextLine = $this.Lines[$this.CurrentLine + 1]
                        $this.Lines[$this.CurrentLine] = $currentLine + $nextLine
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($this.Lines[($this.CurrentLine + 2)..($this.Lines.Count - 1)])
                    }
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentLine.Length -lt $this.MaxLineLength) {
                        $this.Lines[$this.CurrentLine] = $currentLine.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.OnChange -and -not $this._ArraysEqual($originalLines, $this.Lines)) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Lines 
                }
                $this.Parent.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _UpdateScrolling() {
        $textAreaHeight = $this.Height - 2
        if ($this.CurrentLine -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CurrentLine
        } elseif ($this.CurrentLine -ge ($this.ScrollOffsetY + $textAreaHeight)) {
            $this.ScrollOffsetY = $this.CurrentLine - $textAreaHeight + 1
        }
    }
    
    hidden [bool] _ArraysEqual([string[]]$array1, [string[]]$array2) {
        if ($array1.Count -ne $array2.Count) { return $false }
        for ($i = 0; $i -lt $array1.Count; $i++) {
            if ($array1[$i] -ne $array2[$i]) { return $false }
        }
        return $true
    }
    
    [string] GetText() {
        return $this.Lines -join "`n"
    }
    
    [void] SetText([string]$text) {
        $this.Lines = if ([string]::IsNullOrEmpty($text)) { @("") } else { $text -split "`n" }
        $this.CurrentLine = 0
        $this.CursorPosition = 0
        $this.ScrollOffsetY = 0
    }
}

# AI: REFACTORED - NumericInput converted from functional to class-based
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$Min = [double]::MinValue
    [double]$Max = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [string]$TextValue = "0"
    [int]$CursorPosition = 0
    [string]$Suffix = ""
    [scriptblock]$OnChange
    
    NumericInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display value with suffix
            $displayText = $this.TextValue + $this.Suffix
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, [ConsoleColor]::White, [ConsoleColor]::Black)
            
            # AI: Draw spinner arrows
            $parentPanel.WriteToBuffer($renderX + $this.Width - 3, $renderY, "▲", $borderColor, [ConsoleCore]::Black)
            $parentPanel.WriteToBuffer($renderX + $this.Width - 3, $renderY + 2, "▼", $borderColor, [ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = $textX + $this.CursorPosition
                if ($cursorX -lt $renderX + $this.Width - 4) {
                    $parentPanel.WriteToBuffer($cursorX, $textY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                }
            }
            
            # AI: Show min/max indicators
            if ($this.Value -le $this.Min) {
                $parentPanel.WriteToBuffer($renderX + 1, $textY, "⊥", [ConsoleColor]::Red, [ConsoleColor]::Black)
            }
            if ($this.Value -ge $this.Max) {
                $parentPanel.WriteToBuffer($renderX + $this.Width - 2, $textY, "⊤", [ConsoleColor]::Red, [ConsoleColor]::Black)
            }
            
        } catch { 
            Write-Log -Level Error -Message "NumericInput render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this._IncrementValue()
                }
                ([ConsoleKey]::DownArrow) {
                    $this._DecrementValue()
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) { 
                        $this.CursorPosition-- 
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) { 
                        $this.CursorPosition++ 
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this._ValidateAndUpdate()
                }
                default {
                    if ($key.KeyChar -and ($key.KeyChar -match '[\d\.\-]' -or 
                        ($key.KeyChar -eq '.' -and $this.DecimalPlaces -gt 0 -and -not $this.TextValue.Contains('.')))) {
                        $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.Parent.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "NumericInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _IncrementValue() {
        $newValue = [Math]::Min($this.Max, $this.Value + $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _DecrementValue() {
        $newValue = [Math]::Max($this.Min, $this.Value - $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _SetValue([double]$value) {
        $this.Value = $value
        $this.TextValue = $value.ToString("F$($this.DecimalPlaces)")
        $this.CursorPosition = $this.TextValue.Length
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newValue = [double]$this.TextValue
            $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
            $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
            
            $this._SetValue($newValue)
            return $true
        } catch {
            $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
            Write-Log -Level Warning -Message "NumericInput validation failed for '$($this.Name)': $_"
            return $false
        }
    }
}

# AI: REFACTORED - DateInput converted from functional to class-based
class DateInputComponent : UIElement {
    [DateTime]$Value = (Get-Date)
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [string]$Format = "yyyy-MM-dd"
    [string]$TextValue = ""
    [int]$CursorPosition = 0
    [bool]$ShowCalendar = $false
    [scriptblock]$OnChange
    
    DateInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.TextValue = $this.Value.ToString($this.Format)
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display date value
            $displayText = $this.TextValue
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, [ConsoleColor]::White, [ConsoleColor]::Black)
            
            # AI: Draw calendar icon
            $parentPanel.WriteToBuffer($renderX + $this.Width - 3, $textY, "📅", [ConsoleColor]::Cyan, [ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = $textX + $this.CursorPosition
                if ($cursorX -lt $renderX + $this.Width - 4) {
                    $parentPanel.WriteToBuffer($cursorX, $textY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                }
            }
            
            # AI: Show calendar popup if requested
            if ($this.ShowCalendar) {
                $this._RenderCalendar()
            }
            
        } catch { 
            Write-Log -Level Error -Message "DateInput render error for '$($this.Name)': $_" 
        }
    }
    
    hidden [void] _RenderCalendar() {
        if (-not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $calX = $contentArea.X + $this.X
            $calY = $contentArea.Y + $this.Y + $this.Height
            $calWidth = 22
            $calHeight = 8
            
            # AI: Draw calendar background
            $parentPanel.DrawBoxToBuffer($calX, $calY, $calWidth, $calHeight, [ConsoleColor]::Cyan, [ConsoleColor]::DarkBlue)
            
            # AI: Draw month/year header
            $monthYear = $this.Value.ToString("MMMM yyyy")
            $headerX = $calX + [Math]::Floor(($calWidth - $monthYear.Length) / 2)
            $parentPanel.WriteToBuffer($headerX, $calY + 1, $monthYear, [ConsoleColor]::White, [ConsoleColor]::DarkBlue)
            
            # AI: Draw day headers
            $dayHeaders = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
            $dayY = $calY + 2
            for ($i = 0; $i -lt $dayHeaders.Count; $i++) {
                $dayX = $calX + 2 + ($i * 3)
                $parentPanel.WriteToBuffer($dayX, $dayY, $dayHeaders[$i], [ConsoleColor]::Yellow, [ConsoleColor]::DarkBlue)
            }
            
            # AI: Draw calendar days (simplified)
            $firstDay = Get-Date -Year $this.Value.Year -Month $this.Value.Month -Day 1
            $daysInMonth = [DateTime]::DaysInMonth($this.Value.Year, $this.Value.Month)
            $startDayOfWeek = [int]$firstDay.DayOfWeek
            
            $currentDay = 1
            for ($week = 0; $week -lt 4 -and $currentDay -le $daysInMonth; $week++) {
                for ($dayOfWeek = 0; $dayOfWeek -lt 7 -and $currentDay -le $daysInMonth; $dayOfWeek++) {
                    if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                    
                    $dayX = $calX + 2 + ($dayOfWeek * 3)
                    $dayY = $calY + 3 + $week
                    
                    $isToday = ($currentDay -eq $this.Value.Day)
                    $fg = $isToday ? [ConsoleColor]::Black : [ConsoleColor]::White
                    $bg = $isToday ? [ConsoleColor]::Yellow : [ConsoleColor]::DarkBlue
                    
                    $parentPanel.WriteToBuffer($dayX, $dayY, $currentDay.ToString().PadLeft(2), $fg, $bg)
                    $currentDay++
                }
            }
            
        } catch {
            Write-Log -Level Error -Message "DateInput calendar render error for '$($this.Name)': $_"
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            if ($this.ShowCalendar) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) { $this.ShowCalendar = $false }
                    ([ConsoleKey]::LeftArrow) { $this.Value = $this.Value.AddDays(-1) }
                    ([ConsoleKey]::RightArrow) { $this.Value = $this.Value.AddDays(1) }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(-7) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(7) }
                    ([ConsoleKey]::Enter) { 
                        $this.ShowCalendar = $false
                        $this.TextValue = $this.Value.ToString($this.Format)
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::F4) { $this.ShowCalendar = $true }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(-1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::LeftArrow) {
                        if ($this.CursorPosition -gt 0) { $this.CursorPosition-- }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) { $this.CursorPosition++ }
                    }
                    ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                    ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                    ([ConsoleKey]::Backspace) {
                        if ($this.CursorPosition -gt 0) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                            $this.CursorPosition--
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                        }
                    }
                    ([ConsoleKey]::Enter) {
                        $this._ValidateAndUpdate()
                    }
                    default {
                        if ($key.KeyChar -and ($key.KeyChar -match '[\d\-\/]')) {
                            $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                            $this.CursorPosition++
                        } else {
                            $handled = $false
                        }
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.Parent.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "DateInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newDate = [DateTime]::ParseExact($this.TextValue, $this.Format, $null)
            if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                $this.Value = $newDate
                $this.TextValue = $newDate.ToString($this.Format)
                return $true
            }
        } catch {
            # Reset to current value on parse error
            $this.TextValue = $this.Value.ToString($this.Format)
            Write-Log -Level Warning -Message "DateInput validation failed for '$($this.Name)': $_"
        }
        return $false
    }
}

# AI: REFACTORED - ComboBox converted from functional to class-based
class ComboBoxComponent : UIElement {
    [object[]]$Items = @()
    [object]$SelectedItem = $null
    [int]$SelectedIndex = -1
    [string]$DisplayMember = "Display"
    [string]$ValueMember = "Value"
    [string]$Placeholder = "Select an item..."
    [bool]$IsDropDownOpen = $false
    [int]$MaxDropDownHeight = 6
    [int]$ScrollOffset = 0
    [scriptblock]$OnSelectionChanged
    
    ComboBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 30
        $this.Height = 3
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw main combobox
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display selected item or placeholder
            $displayText = ""
            if ($this.SelectedItem) {
                if ($this.SelectedItem -is [string]) {
                    $displayText = $this.SelectedItem
                } elseif ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.DisplayMember)) {
                    $displayText = $this.SelectedItem[$this.DisplayMember]
                } else {
                    $displayText = $this.SelectedItem.ToString()
                }
            } else {
                $displayText = $this.Placeholder
            }
            
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength - 3) + "..."
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $textColor = $this.SelectedItem ? [ConsoleColor]::White : [ConsoleColor]::DarkGray
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, $textColor, [ConsoleColor]::Black)
            
            # AI: Draw dropdown arrow
            $arrow = $this.IsDropDownOpen ? "▲" : "▼"
            $parentPanel.WriteToBuffer($renderX + $this.Width - 3, $textY, $arrow, $borderColor, [ConsoleColor]::Black)
            
            # AI: Draw dropdown if open
            if ($this.IsDropDownOpen -and $this.Items.Count -gt 0) {
                $this._RenderDropDown()
            }
            
        } catch { 
            Write-Log -Level Error -Message "ComboBox render error for '$($this.Name)': $_" 
        }
    }
    
    hidden [void] _RenderDropDown() {
        if (-not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $dropX = $contentArea.X + $this.X
            $dropY = $contentArea.Y + $this.Y + $this.Height
            $dropHeight = [Math]::Min($this.MaxDropDownHeight, $this.Items.Count) + 2
            
            # AI: Draw dropdown background
            $parentPanel.DrawBoxToBuffer($dropX, $dropY, $this.Width, $dropHeight, [ConsoleColor]::Gray, [ConsoleColor]::DarkBlue)
            
            # AI: Calculate visible items
            $visibleCount = [Math]::Min($this.MaxDropDownHeight, $this.Items.Count)
            $startIndex = $this.ScrollOffset
            $endIndex = [Math]::Min($this.Items.Count - 1, $startIndex + $visibleCount - 1)
            
            # AI: Render visible items
            for ($i = $startIndex; $i -le $endIndex; $i++) {
                $item = $this.Items[$i]
                $itemY = $dropY + 1 + ($i - $startIndex)
                
                $displayText = ""
                if ($item -is [string]) {
                    $displayText = $item
                } elseif ($item -is [hashtable] -and $item.ContainsKey($this.DisplayMember)) {
                    $displayText = $item[$this.DisplayMember]
                } else {
                    $displayText = $item.ToString()
                }
                
                if ($displayText.Length -gt ($this.Width - 4)) {
                    $displayText = $displayText.Substring(0, $this.Width - 7) + "..."
                }
                
                $isHighlighted = ($i -eq $this.SelectedIndex)
                $fg = $isHighlighted ? [ConsoleColor]::Black : [ConsoleColor]::White
                $bg = $isHighlighted ? [ConsoleColor]::Yellow : [ConsoleColor]::DarkBlue
                
                # AI: Clear line first
                $parentPanel.WriteToBuffer($dropX + 1, $itemY, (" " * ($this.Width - 2)), $fg, $bg)
                $parentPanel.WriteToBuffer($dropX + 2, $itemY, $displayText, $fg, $bg)
            }
            
            # AI: Draw scrollbar if needed
            if ($this.Items.Count -gt $this.MaxDropDownHeight) {
                $scrollbarX = $dropX + $this.Width - 1
                $scrollHeight = $visibleCount
                $thumbSize = [Math]::Max(1, [Math]::Floor($scrollHeight * $visibleCount / $this.Items.Count))
                $thumbPos = [Math]::Floor($scrollHeight * $this.ScrollOffset / ($this.Items.Count - $visibleCount))
                
                for ($i = 0; $i -lt $scrollHeight; $i++) {
                    $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                    $parentPanel.WriteToBuffer($scrollbarX, $dropY + 1 + $i, $char, [ConsoleColor]::Gray, [ConsoleColor]::DarkBlue)
                }
            }
            
        } catch {
            Write-Log -Level Error -Message "ComboBox dropdown render error for '$($this.Name)': $_"
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalSelection = $this.SelectedItem
            
            if ($this.IsDropDownOpen) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) {
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::Enter) {
                        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
                            $this.SelectedItem = $this.Items[$this.SelectedIndex]
                        }
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($this.SelectedIndex -gt 0) {
                            $this.SelectedIndex--
                            $this._UpdateScrolling()
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                            $this.SelectedIndex++
                            $this._UpdateScrolling()
                        }
                    }
                    ([ConsoleKey]::PageUp) {
                        $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this.MaxDropDownHeight)
                        $this._UpdateScrolling()
                    }
                    ([ConsoleKey]::PageDown) {
                        $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this.MaxDropDownHeight)
                        $this._UpdateScrolling()
                    }
                    ([ConsoleKey]::Home) {
                        $this.SelectedIndex = 0
                        $this._UpdateScrolling()
                    }
                    ([ConsoleKey]::End) {
                        $this.SelectedIndex = $this.Items.Count - 1
                        $this._UpdateScrolling()
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::Enter) { $this._OpenDropDown() }
                    ([ConsoleKey]::Spacebar) { $this._OpenDropDown() }
                    ([ConsoleKey]::DownArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::UpArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::F4) { $this._OpenDropDown() }
                    default { $handled = $false }
                }
            }
            
            if ($handled -and $this.SelectedItem -ne $originalSelection -and $this.OnSelectionChanged) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnSelectionChanged" -ScriptBlock { 
                    & $this.OnSelectionChanged -SelectedItem $this.SelectedItem 
                }
                $this.Parent.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "ComboBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _OpenDropDown() {
        if ($this.Items.Count -gt 0) {
            $this.IsDropDownOpen = $true
            $this._FindCurrentSelection()
        }
    }
    
    hidden [void] _FindCurrentSelection() {
        $this.SelectedIndex = -1
        if ($this.SelectedItem) {
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                if ($this._ItemsEqual($this.Items[$i], $this.SelectedItem)) {
                    $this.SelectedIndex = $i
                    break
                }
            }
        }
        if ($this.SelectedIndex -eq -1) { $this.SelectedIndex = 0 }
        $this._UpdateScrolling()
    }
    
    hidden [void] _UpdateScrolling() {
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $this.MaxDropDownHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $this.MaxDropDownHeight + 1
        }
    }
    
    hidden [bool] _ItemsEqual([object]$item1, [object]$item2) {
        if ($item1 -is [string] -and $item2 -is [string]) {
            return $item1 -eq $item2
        } elseif ($item1 -is [hashtable] -and $item2 -is [hashtable]) {
            return $item1[$this.ValueMember] -eq $item2[$this.ValueMember]
        } else {
            return $item1 -eq $item2
        }
    }
    
    [void] SetItems([object[]]$items) {
        $this.Items = $items
        $this.SelectedItem = $null
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.IsDropDownOpen = $false
    }
    
    [object] GetSelectedValue() {
        if ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.ValueMember)) {
            return $this.SelectedItem[$this.ValueMember]
        }
        return $this.SelectedItem
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiMultilineTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "MultilineTextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [MultilineTextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLines = $Props.MaxLines ?? $textBox.MaxLines
    $textBox.MaxLineLength = $Props.MaxLineLength ?? $textBox.MaxLineLength
    $textBox.WordWrap = $Props.WordWrap ?? $textBox.WordWrap
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    if ($Props.Text) {
        $textBox.SetText($Props.Text)
    }
    
    return $textBox
}

function New-TuiNumericInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "NumericInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $numericInput = [NumericInputComponent]::new($name)
    
    $numericInput.X = $Props.X ?? $numericInput.X
    $numericInput.Y = $Props.Y ?? $numericInput.Y
    $numericInput.Width = $Props.Width ?? $numericInput.Width
    $numericInput.Height = $Props.Height ?? $numericInput.Height
    $numericInput.Visible = $Props.Visible ?? $numericInput.Visible
    $numericInput.ZIndex = $Props.ZIndex ?? $numericInput.ZIndex
    $numericInput.Value = $Props.Value ?? $numericInput.Value
    $numericInput.Min = $Props.Min ?? $numericInput.Min
    $numericInput.Max = $Props.Max ?? $numericInput.Max
    $numericInput.Step = $Props.Step ?? $numericInput.Step
    $numericInput.DecimalPlaces = $Props.DecimalPlaces ?? $numericInput.DecimalPlaces
    $numericInput.Suffix = $Props.Suffix ?? $numericInput.Suffix
    $numericInput.OnChange = $Props.OnChange ?? $numericInput.OnChange
    
    # Update text value based on initial value
    $numericInput.TextValue = $numericInput.Value.ToString("F$($numericInput.DecimalPlaces)")
    
    return $numericInput
}

function New-TuiDateInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DateInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $dateInput = [DateInputComponent]::new($name)
    
    $dateInput.X = $Props.X ?? $dateInput.X
    $dateInput.Y = $Props.Y ?? $dateInput.Y
    $dateInput.Width = $Props.Width ?? $dateInput.Width
    $dateInput.Height = $Props.Height ?? $dateInput.Height
    $dateInput.Visible = $Props.Visible ?? $dateInput.Visible
    $dateInput.ZIndex = $Props.ZIndex ?? $dateInput.ZIndex
    $dateInput.Value = $Props.Value ?? $dateInput.Value
    $dateInput.MinDate = $Props.MinDate ?? $dateInput.MinDate
    $dateInput.MaxDate = $Props.MaxDate ?? $dateInput.MaxDate
    $dateInput.Format = $Props.Format ?? $dateInput.Format
    $dateInput.OnChange = $Props.OnChange ?? $dateInput.OnChange
    
    # Update text value based on initial value
    $dateInput.TextValue = $dateInput.Value.ToString($dateInput.Format)
    
    return $dateInput
}

function New-TuiComboBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "ComboBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $comboBox = [ComboBoxComponent]::new($name)
    
    $comboBox.X = $Props.X ?? $comboBox.X
    $comboBox.Y = $Props.Y ?? $comboBox.Y
    $comboBox.Width = $Props.Width ?? $comboBox.Width
    $comboBox.Height = $Props.Height ?? $comboBox.Height
    $comboBox.Visible = $Props.Visible ?? $comboBox.Visible
    $comboBox.ZIndex = $Props.ZIndex ?? $comboBox.ZIndex
    $comboBox.DisplayMember = $Props.DisplayMember ?? $comboBox.DisplayMember
    $comboBox.ValueMember = $Props.ValueMember ?? $comboBox.ValueMember
    $comboBox.Placeholder = $Props.Placeholder ?? $comboBox.Placeholder
    $comboBox.MaxDropDownHeight = $Props.MaxDropDownHeight ?? $comboBox.MaxDropDownHeight
    $comboBox.OnSelectionChanged = $Props.OnSelectionChanged ?? $comboBox.OnSelectionChanged
    
    if ($Props.Items) {
        $comboBox.SetItems($Props.Items)
    }
    
    if ($Props.SelectedItem) {
        $comboBox.SelectedItem = $Props.SelectedItem
    }
    
    return $comboBox
}

#endregion

Export-ModuleMember -Function 'New-TuiMultilineTextBox', 'New-TuiNumericInput', 'New-TuiDateInput', 'New-TuiComboBox'


####\refactor_checkpoints\checkpoint_20250630_053620_phase 2 complete\components\navigation-class.psm1
# Navigation Component Classes Module for PMC Terminal v5
# Implements navigation menu functionality with keyboard shortcuts

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        # Simplified format display without ANSI escape codes
        $display = "[$($this.Key)] "
        
        if ($this.Enabled) {
            $display += $this.Label
        }
        else {
            $display += "$($this.Label) (Disabled)"
        }
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            $display += " - $($this.Description)"
        }
        
        return $display
    }
}

# NavigationMenu - Component for displaying and handling navigation options
class NavigationMenu : Component {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    
    NavigationMenu([string]$name) : base($name) {
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.SelectedIndex = 0
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base($name) {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.SelectedIndex = 0
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) { 
            throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") 
        }
        $this.Items.Add($item)
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { [void]$this.Items.Remove($item) }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { 
                $item.Execute() 
            }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
    }

    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", { 
                    $this.Services.Navigation.GoTo("/tasks", @{mode="new"}) 
                }))
                $this.AddItem([NavigationItem]::new("P", "Projects", { 
                    $this.Services.Navigation.GoTo("/projects", @{}) 
                }))
                $this.AddItem([NavigationItem]::new("S", "Settings", { 
                    $this.Services.Navigation.GoTo("/settings", @{}) 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("Q", "Quit", { 
                    $this.Services.Navigation.RequestExit() 
                }))
            }
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", { 
                    Write-Host "New task not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("E", "Edit", { 
                    Write-Host "Edit not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("D", "Delete", { 
                    Write-Host "Delete not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("F", "Filter", { 
                    Write-Host "Filter not implemented" 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
            }
            default {
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
                $this.AddItem([NavigationItem]::new("H", "Home", { 
                    $this.Services.Navigation.GoTo("/dashboard", @{}) 
                }))
            }
        }
    }
    
    # AI: FIX - Get render coordinates from parent panel
    hidden [hashtable] GetRenderPosition() {
        # Default position if no parent
        $x = 0
        $y = 0
        
        # AI: FIX - If we have a parent Panel, use its content area
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $x = $contentArea.X
            $y = $contentArea.Y
        }
        
        return @{ X = $x; Y = $y }
    }
    
    hidden [void] _RenderContent() {
        # Get visible items
        if ($null -eq $this.Items -or $this.Items.Count -eq 0) {
            return
        }
        
        $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
        if ($visibleItems.Count -eq 0) { return }
        
        if ($this.Orientation -eq "Horizontal") { 
            $this.RenderHorizontal($visibleItems) 
        }
        else { 
            $this.RenderVertical($visibleItems) 
        }
    }
    
    hidden [void] RenderHorizontal([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) {
            return
        }
        
        # AI: FIX - Get proper render position from parent
        $pos = $this.GetRenderPosition()
        
        $menuText = ""
        $isFirst = $true
        foreach ($item in $items) {
            if ($null -eq $item) { continue }
            
            if (-not $isFirst) {
                $menuText += $this.Separator
            }
            $menuText += "[$($item.Key)] $($item.Label)"
            $isFirst = $false
        }
        
        if (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue) {
            Write-BufferString -X $pos.X -Y $pos.Y -Text $menuText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
        }
    }
    
    hidden [void] RenderVertical([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) {
            return
        }
        
        # AI: FIX - Get proper render position from parent
        $pos = $this.GetRenderPosition()
        
        # Ensure SelectedIndex is within bounds
        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {
            $this.SelectedIndex = 0
        }
        
        # AI: FIX - Calculate max width for proper clearing
        $maxWidth = 0
        if ($this.Parent -and $this.Parent -is [Panel]) {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $maxWidth = $contentArea.Width
        }
        
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($null -eq $item) { continue }
            
            $prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }
            $menuText = "$prefix[$($item.Key)] $($item.Label)"
            
            # AI: FIX - Pad text to clear the full line width
            if ($maxWidth -gt 0 -and $menuText.Length -lt $maxWidth) {
                $menuText = $menuText.PadRight($maxWidth)
            }
            
            if (Get-Command "Write-BufferString" -ErrorAction SilentlyContinue) {
                $fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                    [ConsoleColor]::Black 
                } else { 
                    [ConsoleColor]::White 
                }
                $bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                    [ConsoleColor]::White 
                } else { 
                    [ConsoleColor]::Black 
                }
                
                Write-BufferString -X $pos.X -Y ($pos.Y + $i) -Text $menuText `
                    -ForegroundColor $fg -BackgroundColor $bg
            }
        }
    }
}

Export-ModuleMember -Function @()



####\refactor_checkpoints\checkpoint_20250630_053620_phase 2 complete\components\tui-components.psm1
# TUI Component Library - Phase 1 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

using module ..\components\tui-primitives.psm1

#region Core UI Components

# AI: REFACTORED - LabelComponent now properly inherits from UIElement
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor
    
    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Now renders to parent Panel's buffer instead of direct output
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            $parentPanel = [Panel]$this.Parent
            
            # AI: Calculate position relative to parent's content area
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            # AI: Render to parent's buffer
            $parentPanel.WriteToBuffer($renderX, $renderY, $this.Text, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "Label render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false # Labels don't handle input
    }
}

# AI: REFACTORED - ButtonComponent updated for buffer-based rendering
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick
    
    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
        $this.Text = "Button"
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Buffer-based rendering with parent Panel integration
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            $bgColor = $this.IsPressed ? [ConsoleColor]::Yellow : [ConsoleColor]::Black
            $fgColor = $this.IsPressed ? [ConsoleColor]::Black : $borderColor
            
            # AI: Render border to parent buffer
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, $bgColor)
            
            # AI: Render text centered
            $textX = $renderX + [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = $renderY + [Math]::Floor($this.Height / 2)
            $parentPanel.WriteToBuffer($textX, $textY, $this.Text, $fgColor, $bgColor)
            
        } catch { 
            Write-Log -Level Error -Message "Button render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsPressed = $true
                $this.Parent.RequestRedraw()
                
                if ($this.OnClick) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock { & $this.OnClick }
                }
                
                $this.IsPressed = $false
                $this.Parent.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "Button input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: REFACTORED - TextBoxComponent with buffer-based rendering
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.MaxLength = 100
    }
    
    hidden [void] _RenderContent() {
        # AI: REFACTORED - Renders to parent Panel buffer
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            $parentPanel.DrawBoxToBuffer($renderX, $renderY, $this.Width, $this.Height, $borderColor, [ConsoleColor]::Black)
            
            # AI: Display text or placeholder
            $displayText = $this.Text ?? ""
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = $this.Placeholder ?? "" 
            }
            
            $maxDisplayLength = $this.Width - 4
            if ($displayText.Length -gt $maxDisplayLength) { 
                $displayText = $displayText.Substring(0, $maxDisplayLength) 
            }
            
            $textX = $renderX + 2
            $textY = $renderY + 1
            $parentPanel.WriteToBuffer($textX, $textY, $displayText, [ConsoleColor]::White, [ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $displayText.Length) {
                $cursorX = $textX + $this.CursorPosition
                if ($cursorX < $renderX + $this.Width - 2) {
                    $parentPanel.WriteToBuffer($cursorX, $textY, "_", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "TextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition ?? 0
            $originalText = $currentText
            
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $currentText = $currentText.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    } 
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $currentText.Length) { 
                        $currentText = $currentText.Remove($cursorPos, 1) 
                    } 
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- } 
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $currentText.Length) { $cursorPos++ } 
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $currentText.Length }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) { 
                        $currentText = $currentText.Insert($cursorPos, $key.KeyChar)
                        $cursorPos++ 
                    } else { 
                        return $false 
                    }
                }
            }
            
            if ($currentText -ne $originalText -or $cursorPos -ne $this.CursorPosition) {
                $this.Text = $currentText
                $this.CursorPosition = $cursorPos
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $currentText 
                    }
                }
                $this.Parent.RequestRedraw()
            }
            return $true
        } catch { 
            Write-Log -Level Error -Message "TextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
}

# AI: NEW - CheckBoxComponent converted from functional to class-based
class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange
    
    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $checkbox = $this.Checked ? "[X]" : "[ ]"
            $displayText = "$checkbox $($this.Text)"
            
            $parentPanel.WriteToBuffer($renderX, $renderY, $displayText, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "CheckBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Checked = -not $this.Checked
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $this.Checked 
                    } 
                }
                $this.Parent.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "CheckBox input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: NEW - RadioButtonComponent converted from functional to class-based
class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange
    
    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    hidden [void] _RenderContent() {
        if (-not $this.Visible -or -not $this.Parent) { return }
        
        try {
            $parentPanel = [Panel]$this.Parent
            $contentArea = $parentPanel.GetContentArea()
            $renderX = $contentArea.X + $this.X
            $renderY = $contentArea.Y + $this.Y
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $radio = $this.Selected ? "(●)" : "( )"
            $displayText = "$radio $($this.Text)"
            
            $parentPanel.WriteToBuffer($renderX, $renderY, $displayText, $fg, [ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "RadioButton render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if (-not $this.Selected) {
                    # AI: Unselect other radio buttons in the same group
                    if ($this.Parent -and $this.GroupName) {
                        $siblingRadios = $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        }
                        foreach ($radio in $siblingRadios) {
                            $radio.Selected = $false
                        }
                    }
                    
                    $this.Selected = $true
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $this.Selected 
                        } 
                    }
                    $this.Parent.RequestRedraw()
                }
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "RadioButton input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $label = [LabelComponent]::new($name)
    
    $label.X = $Props.X ?? $label.X
    $label.Y = $Props.Y ?? $label.Y
    $label.Width = $Props.Width ?? $label.Width
    $label.Height = $Props.Height ?? $label.Height
    $label.Visible = $Props.Visible ?? $label.Visible
    $label.ZIndex = $Props.ZIndex ?? $label.ZIndex
    $label.Text = $Props.Text ?? $label.Text
    $label.ForegroundColor = $Props.ForegroundColor ?? $label.ForegroundColor
    
    return $label
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $button = [ButtonComponent]::new($name)
    
    $button.X = $Props.X ?? $button.X
    $button.Y = $Props.Y ?? $button.Y
    $button.Width = $Props.Width ?? $button.Width
    $button.Height = $Props.Height ?? $button.Height
    $button.Visible = $Props.Visible ?? $button.Visible
    $button.ZIndex = $Props.ZIndex ?? $button.ZIndex
    $button.Text = $Props.Text ?? $button.Text
    $button.OnClick = $Props.OnClick ?? $button.OnClick
    
    return $button
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [TextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Text = $Props.Text ?? $textBox.Text
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLength = $Props.MaxLength ?? $textBox.MaxLength
    $textBox.CursorPosition = $Props.CursorPosition ?? $textBox.CursorPosition
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    return $textBox
}

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $checkBox = [CheckBoxComponent]::new($name)
    
    $checkBox.X = $Props.X ?? $checkBox.X
    $checkBox.Y = $Props.Y ?? $checkBox.Y
    $checkBox.Width = $Props.Width ?? $checkBox.Width
    $checkBox.Height = $Props.Height ?? $checkBox.Height
    $checkBox.Visible = $Props.Visible ?? $checkBox.Visible
    $checkBox.ZIndex = $Props.ZIndex ?? $checkBox.ZIndex
    $checkBox.Text = $Props.Text ?? $checkBox.Text
    $checkBox.Checked = $Props.Checked ?? $checkBox.Checked
    $checkBox.OnChange = $Props.OnChange ?? $checkBox.OnChange
    
    return $checkBox
}

function New-TuiRadioButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $radioButton = [RadioButtonComponent]::new($name)
    
    $radioButton.X = $Props.X ?? $radioButton.X
    $radioButton.Y = $Props.Y ?? $radioButton.Y
    $radioButton.Width = $Props.Width ?? $radioButton.Width
    $radioButton.Height = $Props.Height ?? $radioButton.Height
    $radioButton.Visible = $Props.Visible ?? $radioButton.Visible
    $radioButton.ZIndex = $Props.ZIndex ?? $radioButton.ZIndex
    $radioButton.Text = $Props.Text ?? $radioButton.Text
    $radioButton.Selected = $Props.Selected ?? $radioButton.Selected
    $radioButton.GroupName = $Props.GroupName ?? $radioButton.GroupName
    $radioButton.OnChange = $Props.OnChange ?? $radioButton.OnChange
    
    return $radioButton
}

#endregion

Export-ModuleMember -Function 'New-TuiLabel', 'New-TuiButton', 'New-TuiTextBox', 'New-TuiCheckBox', 'New-TuiRadioButton'


####\refactor_checkpoints\checkpoint_20250630_053620_phase 2 complete\components\tui-primitives.psm1
# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations

using namespace System
using namespace System.Management.Automation

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    [ConsoleColor] $ForegroundColor = [ConsoleColor]::White
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = ""
    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() {
        $this.Char = ' '
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Character constructor
    TuiCell([char]$char) {
        $this.Char = $char
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Full constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }

    # Style constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }

    # Copy constructor
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.StyleFlags = $other.StyleFlags
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Create a styled copy
    [TuiCell] WithStyle([ConsoleColor]$fg, [ConsoleColor]$bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    # Create a character copy
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blend this cell with another (higher Z-index wins)
    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return $other }
        if ($other.ZIndex -eq $this.ZIndex -and $other.Char -ne ' ') { return $other }
        return $this
    }

    # Check if this cell differs from another
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic)
    }

    # Generate ANSI escape sequence for this cell
    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Color codes
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append("`e[${fgCode};${bgCode}")
        
        # Style codes
        if ($this.Bold) { [void]$sb.Append(";1") }
        if ($this.Underline) { [void]$sb.Append(";4") }
        if ($this.Italic) { [void]$sb.Append(";3") }
        
        [void]$sb.Append("m").Append($this.Char)
        return $sb.ToString()
    }

    # Convert to legacy buffer format for compatibility
    [hashtable] ToLegacyFormat() {
        return @{
            Char = $this.Char
            FG = $this.ForegroundColor
            BG = $this.BackgroundColor
        }
    }

    # String representation
    [string] ToString() {
        return "TuiCell($($this.Char), $($this.ForegroundColor), $($this.BackgroundColor))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

#region UIElement Base Class - Foundation for All Components
class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer = $null
    [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{}

    # Constructor
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with position and size
    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Buffer")
    }

    # Get absolute screen position
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # Add child component
    [void] AddChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
        }
    }

    # Remove child component
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
            $this.RequestRedraw()
        }
    }

    # Request redraw for this component and parents
    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
    }

    # Resize the component and its buffer
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Resize($newWidth, $newHeight)
        }
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # Move the component
    [void] Move([int]$newX, [int]$newY) {
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
    }

    # Check if point is within component bounds
    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge $this.X -and $x -lt ($this.X + $this.Width) -and 
                $y -ge $this.Y -and $y -lt ($this.Y + $this.Height))
    }

    # Get child at specific point (relative to this component)
    [UIElement] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $this.X, $y - $this.Y)) {
                return $child
            }
        }
        return $null
    }

    # Virtual methods for subclasses to override
    [void] OnRender() {
        # Default implementation - clear buffer
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Override in subclasses
    }

    [void] OnMove([int]$newX, [int]$newY) {
        # Override in subclasses
    }

    [void] OnFocus() {
        # Override in subclasses
    }

    [void] OnBlur() {
        # Override in subclasses
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Override in subclasses - return true if input was handled
        return $false
    }

    # Main render method - calls OnRender and renders children
    [void] Render() {
        if (-not $this.Visible) { return }

        # Render this component to its private buffer
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer) {
                $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }
            
            $this.OnRender()
            $this._needs_redraw = $false
        }

        # Render children to their buffers, then composite onto parent
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
    }

    # Get the final rendered buffer
    [TuiBuffer] GetBuffer() {
        return $this._private_buffer
    }
}
#endregion

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int] GetForegroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()]
    }

    static [int] GetBackgroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()] + 10
    }

    static [string] Reset() {
        return "`e[0m"
    }

    static [string] Bold() {
        return "`e[1m"
    }

    static [string] Underline() {
        return "`e[4m"
    }

    static [string] Italic() {
        return "`e[3m"
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions
function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    
    $cell = [TuiCell]::new(' ', $ForegroundColor, $BackgroundColor)
    $cell.Bold = $Bold
    $cell.Underline = $Underline
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0) {
            $charCell = [TuiCell]::new($cell)
            $charCell.Char = $char
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$BorderStyle = "Single",
        [ConsoleColor]$BorderColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }
    
    $borders = Get-TuiBorderChars -Style $BorderStyle
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Side borders and fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        $currentY = $Y + $i
        
        # Left border
        Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill
        $fillText = ' ' * ($Width - 2)
        Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -BackgroundColor $BackgroundColor
        
        # Right border
        Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $bottomLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all classes and functions
Export-ModuleMember -Function 'Write-TuiText', 'Write-TuiBox', 'Get-TuiBorderChars'


####\refactor_checkpoints\checkpoint_20250630_053620_phase 2 complete\layout\panels-class.psm1
# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

using module .\components\tui-primitives.psm1

#region Panel Class - Basic Layout Container
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds
    [void] Resize([int]$newWidth, [int]$newHeight) {
        ([UIElement]$this).Resize($newWidth, $newHeight)
        $this.UpdateContentBounds()
    }

    # Add child with automatic layout (if enabled)
    [void] AddChild([UIElement]$child) {
        ([UIElement]$this).AddChild($child)
        $this.PerformLayout()
    }

    # Remove child and re-layout
    [void] RemoveChild([UIElement]$child) {
        ([UIElement]$this).RemoveChild($child)
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.Move($this.ContentX, $currentY)
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.Move($currentX, $this.ContentY)
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        # Calculate grid dimensions
        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            # Adjust size for last column/row
            $width = if ($col -eq ($cols - 1)) { 
                $this.ContentX + $this.ContentWidth - $x 
            } else { 
                $cellWidth 
            }
            $height = if ($row -eq ($rows - 1)) { 
                $this.ContentY + $this.ContentHeight - $y 
            } else { 
                $cellHeight 
            }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    # Set border style and update content bounds
    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    # Enable/disable border
    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    # Set title
    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    # Check if point is within content area
    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    # Get content bounds as hashtable
    [hashtable] GetContentBounds() {
        return @{
            X = $this.ContentX
            Y = $this.ContentY
            Width = $this.ContentWidth
            Height = $this.ContentHeight
        }
    }

    # Clear content area only
    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return }

        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    # Main render implementation
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }

        # Clear entire buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this._private_buffer.Clear($bgCell)

        # Draw border if enabled
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }

        # Fill content area
        $this.ClearContent()
    }

    # Override OnResize to update content bounds
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Handle focus for focusable panels
    [void] OnFocus() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Cyan
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Gray
            $this.RequestRedraw()
        }
    }

    # Find first focusable child
    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    # Get all focusable children (recursive)
    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        
        return $focusable
    }

    # Basic input handling - delegate to focused child
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # If this panel can focus and is focused, handle some basic navigation
        if ($this.CanFocus -and $this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        Set-ComponentFocus -Component $firstChild
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        Set-ComponentFocus -Component $firstChild
                        return $true
                    }
                }
            }
        }

        # Delegate to children
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }

        return $false
    }

    # String representation
    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}
#endregion

#region Specialized Panel Types

# Scrollable Panel - supports content larger than visible area
class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    # Constructor
    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    # Set virtual content size
    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        
        # Create virtual buffer if needed
        if ($width -gt 0 -and $height -gt 0) {
            $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        
        $this.RequestRedraw()
    }

    # Scroll to position
    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        
        $this.RequestRedraw()
    }

    # Scroll by delta
    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    # Handle scrolling input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }

        return ([Panel]$this).HandleInput($keyInfo)
    }

    # Render with scrolling support
    [void] OnRender() {
        # Render base panel
        ([Panel]$this).OnRender()

        # Render virtual content if available
        if ($null -ne $this._virtual_buffer) {
            # Create a sub-buffer view of the virtual content
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            
            # Blend visible content onto our buffer
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }

        # Draw scrollbars if enabled and needed
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    # Draw scrollbar indicators
    [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return }

        # Vertical scrollbar
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
        }

        # Horizontal scrollbar
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    # Get virtual content buffer for external drawing
    [TuiBuffer] GetVirtualBuffer() {
        return $this._virtual_buffer
    }
}

# Group Panel - collapsible panel with header
class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    # Toggle collapsed state
    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)  # Just header + border
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        
        # Update child visibility
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        
        $this.RequestRedraw()
    }

    # Handle collapse/expand input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this -eq (Get-FocusedComponent)) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }

        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        
        return $false
    }

    # Render with collapse indicator
    [void] OnRender() {
        ([Panel]$this).OnRender()

        # Draw collapse/expand indicator in title area
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            $this._private_buffer.SetCell(2, 0, $indicatorCell)
        }
    }
}
#endregion

# Export the Panel classes
Export-ModuleMember -Function @()


####\refactor_checkpoints\checkpoint_20250630_053620_phase 2 complete\modules\dialog-system-class.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Base Dialog Class
class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    [int] $Width = 50
    [int] $Height = 10
    [int] $X
    [int] $Y
    [ConsoleColor] $BorderColor = [ConsoleColor]::Cyan
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [ConsoleColor] $MessageColor = [ConsoleColor]::Gray
    
    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    [void] Show() {
        # Calculate centered position
        $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
        $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 2)
        
        # Register with dialog manager
        $script:DialogState.CurrentDialog = $this
        Request-TuiRefresh
    }
    
    [void] Close() {
        $script:DialogState.CurrentDialog = $null
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        }
        Request-TuiRefresh
    }
    
    # Base render draws dialog frame
    hidden [void] _RenderContent() {
        # Draw dialog box
        Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height `
            -Title " $($this.Title) " -BorderColor $this.BorderColor
        
        # Draw message if present
        if (-not [string]::IsNullOrWhiteSpace($this.Message)) {
            $this.RenderMessage()
        }
        
        # Let derived classes render their specific content
        $this._RenderDialogContent()
    }
    
    hidden [void] RenderMessage() {
        $messageY = $this.Y + 2
        $messageX = $this.X + 2
        $maxWidth = $this.Width - 4
        
        $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
        foreach ($line in $wrappedLines) {
            if ($messageY -ge ($this.Y + $this.Height - 3)) { break }
            Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor $this.MessageColor
            $messageY++
        }
    }
    
    # Override in derived classes
    hidden [void] _RenderDialogContent() { }
    
    # Base input handling - ESC closes dialog
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.OnCancel()
        }
    }
    
    # Virtual methods for derived classes
    [void] OnConfirm() { $this.Close() }
    [void] OnCancel() { $this.Close() }
}

# Alert Dialog - Simple OK dialog
class AlertDialog : Dialog {
    [string] $ButtonText = "OK"
    
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 10
        $this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))
    }
    
    hidden [void] _RenderDialogContent() {
        # Render OK button
        $buttonY = $this.Y + $this.Height - 2
        $buttonText = "[ $($this.ButtonText) ]"
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
        
        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) { $this.OnConfirm() }
            ([ConsoleKey]::Spacebar) { $this.OnConfirm() }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
}

# Confirm Dialog - Yes/No dialog
class ConfirmDialog : Dialog {
    [scriptblock] $OnConfirmAction
    [scriptblock] $OnCancelAction
    [string[]] $Buttons = @("Yes", "No")
    [int] $SelectedButton = 0
    
    ConfirmDialog([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) : base("ConfirmDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.OnConfirmAction = $onConfirm
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render buttons
        $buttonY = $this.Y + $this.Height - 3
        $totalButtonWidth = ($this.Buttons.Count * 12) + (($this.Buttons.Count - 1) * 2)
        $buttonX = $this.X + [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        
        for ($i = 0; $i -lt $this.Buttons.Count; $i++) {
            $button = $this.Buttons[$i]
            $isSelected = ($i -eq $this.SelectedButton)
            $buttonText = if ($isSelected) { "[ $button ]" } else { "  $button  " }
            $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
            $buttonX += 14
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) { 
                $this.SelectedButton = [Math]::Max(0, $this.SelectedButton - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::RightArrow) { 
                $this.SelectedButton = [Math]::Min($this.Buttons.Count - 1, $this.SelectedButton + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Tab) { 
                $this.SelectedButton = ($this.SelectedButton + 1) % $this.Buttons.Count
                Request-TuiRefresh
            }
            ([ConsoleKey]::Enter) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Spacebar) { 
                if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnConfirmAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnConfirm" -ScriptBlock $this.OnConfirmAction
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Input Dialog - Text input dialog
class InputDialog : Dialog {
    [string] $Prompt = ""
    [string] $InputValue = ""
    [string] $DefaultValue = ""
    [scriptblock] $OnSubmitAction
    [scriptblock] $OnCancelAction
    [int] $FocusedElement = 0  # 0=TextBox, 1=OK, 2=Cancel
    [int] $CursorPosition = 0
    
    InputDialog([string]$title, [string]$prompt, [scriptblock]$onSubmit, [scriptblock]$onCancel) : base("InputDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.OnSubmitAction = $onSubmit
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(70, [Math]::Max(50, $prompt.Length + 10))
        $this.Height = 10
    }
    
    hidden [void] _RenderDialogContent() {
        # Render prompt
        $promptX = $this.X + 2
        $promptY = $this.Y + 2
        Write-BufferString -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor ([ConsoleColor]::White)
        
        # Render input box
        $inputY = $promptY + 2
        $inputWidth = $this.Width - 4
        $isFocused = ($this.FocusedElement -eq 0)
        $borderColor = if ($isFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::DarkGray }
        
        Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 -BorderColor $borderColor
        
        # Render input text
        $displayText = $this.InputValue
        if ($displayText.Length -gt ($inputWidth - 3)) {
            $displayText = $displayText.Substring(0, $inputWidth - 3)
        }
        Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText -ForegroundColor ([ConsoleColor]::White)
        
        # Show cursor when focused
        if ($isFocused -and $this.CursorPosition -le $displayText.Length) {
            Write-BufferString -X ($promptX + 1 + $this.CursorPosition) -Y ($inputY + 1) `
                -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
        }
        
        # Render buttons
        $buttonY = $this.Y + $this.Height - 2
        $buttonSpacing = 15
        $buttonsWidth = $buttonSpacing * 2
        $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonsWidth) / 2)
        
        # OK button
        $okFocused = ($this.FocusedElement -eq 1)
        $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
        $okColor = if ($okFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
        
        # Cancel button
        $cancelFocused = ($this.FocusedElement -eq 2)
        $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
        $cancelColor = if ($cancelFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
        Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Tab) {
                $direction = if ($key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                $this.FocusedElement = ($this.FocusedElement + $direction + 3) % 3
                Request-TuiRefresh
            }
            ([ConsoleKey]::Escape) { $this.OnCancel() }
            default {
                switch ($this.FocusedElement) {
                    0 { # TextBox
                        switch ($key.Key) {
                            ([ConsoleKey]::Enter) { $this.OnConfirm() }
                            ([ConsoleKey]::Backspace) {
                                if ($this.InputValue.Length -gt 0 -and $this.CursorPosition -gt 0) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition - 1, 1)
                                    $this.CursorPosition--
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::Delete) {
                                if ($this.CursorPosition -lt $this.InputValue.Length) {
                                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition, 1)
                                    Request-TuiRefresh
                                }
                            }
                            ([ConsoleKey]::LeftArrow) {
                                $this.CursorPosition = [Math]::Max(0, $this.CursorPosition - 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::RightArrow) {
                                $this.CursorPosition = [Math]::Min($this.InputValue.Length, $this.CursorPosition + 1)
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::Home) {
                                $this.CursorPosition = 0
                                Request-TuiRefresh
                            }
                            ([ConsoleKey]::End) {
                                $this.CursorPosition = $this.InputValue.Length
                                Request-TuiRefresh
                            }
                            default {
                                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                                    $this.InputValue = $this.InputValue.Insert($this.CursorPosition, $key.KeyChar)
                                    $this.CursorPosition++
                                    Request-TuiRefresh
                                }
                            }
                        }
                    }
                    1 { # OK Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnConfirm()
                        }
                    }
                    2 { # Cancel Button
                        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                            $this.OnCancel()
                        }
                    }
                }
            }
        }
    }
    
    [void] SetDefaultValue([string]$value) {
        $this.InputValue = $value
        $this.DefaultValue = $value
        $this.CursorPosition = $value.Length
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSubmitAction) {
            $value = $this.InputValue
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnSubmit" -ScriptBlock {
                & $this.OnSubmitAction -Value $value
            }.GetNewClosure()
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Progress Dialog
class ProgressDialog : Dialog {
    [int] $PercentComplete = 0
    [bool] $ShowCancel = $false
    [bool] $IsCancelled = $false
    
    ProgressDialog([string]$title, [string]$message) : base("ProgressDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Width = 60
        $this.Height = 8
    }
    
    hidden [void] _RenderDialogContent() {
        # Render progress bar
        $barY = $this.Y + 4
        $barWidth = $this.Width - 4
        $filledWidth = [Math]::Floor($barWidth * ($this.PercentComplete / 100.0))
        
        # Draw bar background
        Write-BufferString -X ($this.X + 2) -Y $barY -Text ("─" * $barWidth) -ForegroundColor ([ConsoleColor]::DarkGray)
        
        # Draw filled portion
        if ($filledWidth -gt 0) {
            Write-BufferString -X ($this.X + 2) -Y $barY -Text ("█" * $filledWidth) -ForegroundColor ([ConsoleColor]::Green)
        }
        
        # Draw percentage
        $percentText = "$($this.PercentComplete)%"
        $percentX = $this.X + [Math]::Floor(($this.Width - $percentText.Length) / 2)
        Write-BufferString -X $percentX -Y $barY -Text $percentText -ForegroundColor ([ConsoleColor]::White)
        
        # Draw cancel button if enabled
        if ($this.ShowCancel) {
            $buttonY = $this.Y + $this.Height - 2
            $buttonText = if ($this.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
            $buttonX = $this.X + [Math]::Floor(($this.Width - $buttonText.Length) / 2)
            Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor ([ConsoleColor]::Yellow)
        }
    }
    
    [void] UpdateProgress([int]$percent, [string]$message) {
        $this.PercentComplete = [Math]::Min(100, [Math]::Max(0, $percent))
        if (-not [string]::IsNullOrWhiteSpace($message)) {
            $this.Message = $message
        }
        Request-TuiRefresh
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($this.ShowCancel -and -not $this.IsCancelled) {
            if ($key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsCancelled = $true
                Request-TuiRefresh
            }
        }
    }
}

# List Dialog
class ListDialog : Dialog {
    [string[]] $Items = @()
    [int] $SelectedIndex = 0
    [bool] $AllowMultiple = $false
    [System.Collections.Generic.HashSet[int]] $SelectedItems
    [scriptblock] $OnSelectAction
    [scriptblock] $OnCancelAction
    
    ListDialog([string]$title, [string]$prompt, [string[]]$items, [scriptblock]$onSelect, [scriptblock]$onCancel) : base("ListDialog") {
        $this.Title = $title
        $this.Message = $prompt
        $this.Items = $items
        $this.OnSelectAction = $onSelect
        $this.OnCancelAction = $onCancel
        $this.Width = 60
        $this.Height = [Math]::Min(20, $items.Count + 8)
        $this.SelectedItems = [System.Collections.Generic.HashSet[int]]::new()
    }
    
    hidden [void] _RenderDialogContent() {
        $listY = $this.Y + 4
        $listHeight = $this.Height - 7
        $listWidth = $this.Width - 4
        
        # Calculate visible range with scrolling
        $startIndex = [Math]::Max(0, $this.SelectedIndex - [Math]::Floor($listHeight / 2))
        $endIndex = [Math]::Min($this.Items.Count - 1, $startIndex + $listHeight - 1)
        
        # Render items
        for ($i = $startIndex; $i -le $endIndex; $i++) {
            $itemY = $listY + ($i - $startIndex)
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex)
            $isChecked = $this.SelectedItems.Contains($i)
            
            $prefix = if ($this.AllowMultiple) {
                if ($isChecked) { "[X] " } else { "[ ] " }
            } else { "" }
            
            $itemText = "$prefix$item"
            if ($itemText.Length -gt $listWidth - 2) {
                $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
            }
            
            $bgColor = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
            $fgColor = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::Gray }
            
            # Clear the line first
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text (" " * ($listWidth - 2)) -BackgroundColor $bgColor
            Write-BufferString -X ($this.X + 2) -Y $itemY -Text $itemText -ForegroundColor $fgColor -BackgroundColor $bgColor
        }
        
        # Render scrollbar if needed
        if ($this.Items.Count -gt $listHeight) {
            $scrollbarX = $this.X + $this.Width - 2
            $scrollbarHeight = $listHeight
            $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $this.Items.Count))
            $thumbPos = [Math]::Floor($scrollbarHeight * $this.SelectedIndex / $this.Items.Count)
            
            for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char -ForegroundColor ([ConsoleColor]::DarkGray)
            }
        }
        
        # Render buttons for multi-select
        if ($this.AllowMultiple) {
            $buttonY = $this.Y + $this.Height - 2
            $okText = "[ OK ]"
            $cancelText = "[ Cancel ]"
            $buttonSpacing = 15
            $totalWidth = 30
            $startX = $this.X + [Math]::Floor(($this.Width - $totalWidth) / 2)
            
            Write-BufferString -X $startX -Y $buttonY -Text $okText -ForegroundColor ([ConsoleColor]::Green)
            Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor ([ConsoleColor]::Gray)
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::DownArrow) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + 1)
                Request-TuiRefresh
            }
            ([ConsoleKey]::Spacebar) {
                if ($this.AllowMultiple) {
                    if ($this.SelectedItems.Contains($this.SelectedIndex)) {
                        [void]$this.SelectedItems.Remove($this.SelectedIndex)
                    } else {
                        [void]$this.SelectedItems.Add($this.SelectedIndex)
                    }
                    Request-TuiRefresh
                }
            }
            ([ConsoleKey]::Enter) {
                $this.OnConfirm()
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
            }
        }
    }
    
    [void] OnConfirm() {
        $this.Close()
        if ($this.OnSelectAction) {
            if ($this.AllowMultiple) {
                $selectedValues = @($this.SelectedItems | ForEach-Object { $this.Items[$_] })
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selectedValues
                }.GetNewClosure()
            } else {
                $selected = $this.Items[$this.SelectedIndex]
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction -Selected $selected
                }.GetNewClosure()
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ListDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Dialog State Management
$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

# Public API Functions
function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        # Subscribe to dialog events
        Subscribe-Event -EventName "Confirm.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-ConfirmDialog -Title $params.Title -Message $params.Message `
                -OnConfirm $params.OnConfirm -OnCancel $params.OnCancel
        }
        
        Subscribe-Event -EventName "Alert.Show" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-AlertDialog -Title $params.Title -Message $params.Message
        }
        
        Subscribe-Event -EventName "Input.Request" -Handler {
            param($EventData)
            $params = $EventData.Data
            Show-InputDialog -Title $params.Title -Prompt $params.Prompt `
                -DefaultValue $params.DefaultValue -OnSubmit $params.OnSubmit -OnCancel $params.OnCancel
        }
        
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

function Show-AlertDialog {
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock {
        $dialog = [AlertDialog]::new($Title, $Message)
        $dialog.Show()
    }
}

function Show-ConfirmDialog {
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock {
        $dialog = [ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)
        $dialog.Show()
    }
}

function Show-InputDialog {
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock {
        $dialog = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel)
        if ($DefaultValue) {
            $dialog.SetDefaultValue($DefaultValue)
        }
        $dialog.Show()
    }
}

function Show-ProgressDialog {
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock {
        $dialog = [ProgressDialog]::new($Title, $Message)
        $dialog.PercentComplete = $PercentComplete
        $dialog.ShowCancel = $ShowCancel
        $dialog.Show()
        return $dialog
    }
}

function Show-ListDialog {
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [string[]]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock {
        $dialog = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel)
        $dialog.AllowMultiple = $AllowMultiple
        $dialog.Show()
    }
}

function Close-TuiDialog {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.CurrentDialog.Close()
        }
    }
}

Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-AlertDialog',
    'Show-ConfirmDialog', 
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Close-TuiDialog'
) -Variable @()



####\refactor_checkpoints\checkpoint_20250630_053620_phase 2 complete\modules\tui-engine.psm1
# TUI Engine v5.1 - NCurses Compositor Edition
# Implements NCurses-style compositor with private buffers and TuiCell rendering

using module .\components\tui-primitives.psm1

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    CompositorBuffer = $null    # AI: NEW - Master compositor buffer (TuiBuffer)
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
    CompositorMode  = $true     # AI: NEW - Enable NCurses-style rendering
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.1 (NCurses Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        # AI: ENHANCED - Create both legacy buffers and new TuiBuffer compositor
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        
        # Initialize legacy buffers for compatibility
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height; CompositorMode = $global:TuiState.CompositorMode }
        Write-Log -Level Info -Message "TUI Engine v5.1 initialized successfully (Compositor Mode: $($global:TuiState.CompositorMode))"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent) {
        try { 
            # AI: ENHANCED - Better class detection for UIElement-based components
            if ($focusedComponent -is [UIElement]) {
                # New UIElement-based component
                $focusedComponent.HandleInput($keyInfo)
            }
            elseif ($focusedComponent.PSObject.TypeNames -contains 'UIElement' -or $focusedComponent.GetType().IsSubclassOf([UIElement])) {
                # Class-based component (legacy detection)
                if ($focusedComponent.PSObject.Methods.Name -contains 'HandleInput') {
                    $focusedComponent.HandleInput($keyInfo)
                }
            }
            elseif ($focusedComponent.HandleInput) {
                # Functional component with HandleInput scriptblock
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return }
            }
        } catch { 
            Write-Warning "Component input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for component '$($focusedComponent.Name)': $_"
        }
    }
    
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            # AI: ENHANCED - Support for UIElement-based screens
            if ($currentScreen -is [UIElement]) {
                # New UIElement-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen -is [Screen]) {
                # Legacy class-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen.HandleInput) {
                # Hashtable/functional screen - use scriptblock invocation
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { Stop-TuiEngine }
                }
            }
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([object]$InitialScreen)  # AI: Accept both UIElement and hashtable screens
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

# AI: REWRITTEN - NCurses Compositor Render-Frame
function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        if ($global:TuiState.CompositorMode -and $null -ne $global:TuiState.CompositorBuffer) {
            # AI: NEW - NCurses-style compositor rendering
            Render-FrameCompositor
        } else {
            # AI: LEGACY - Fall back to old rendering for compatibility
            Render-FrameLegacy
        }
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    # AI: NEW - NCurses-style compositor rendering pipeline
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                if ($global:TuiState.CurrentScreen -is [UIElement]) {
                    # New UIElement-based screen - render to its private buffer
                    $global:TuiState.CurrentScreen.Render()
                    
                    # Composite screen buffer onto master compositor
                    $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                    if ($null -ne $screenBuffer) {
                        $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                    }
                } else {
                    # Legacy screen - render directly (will be deprecated)
                    $global:TuiState.CurrentScreen.Render()
                }
            }
        }
        
        # 3. Render dialogs on top
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog -is [UIElement]) {
                    # New UIElement-based dialog
                    $dialog.Render()
                    $dialogBuffer = $dialog.GetBuffer()
                    if ($null -ne $dialogBuffer) {
                        $pos = $dialog.GetAbsolutePosition()
                        $global:TuiState.CompositorBuffer.BlendBuffer($dialogBuffer, $pos.X, $pos.Y)
                    }
                } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                    # Class-based dialog with Render() method
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    # Functional/hashtable dialog with Render scriptblock
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
        # Fall back to legacy rendering
        Render-FrameLegacy
    }
}

function Render-CompositorToConsole {
    # AI: NEW - Convert TuiBuffer to optimized console output
    $outputBuilder = [System.Text.StringBuilder]::new(20000)
    $lastFG = -1
    $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1
    
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $rowChanged = $false
            $rowOutput = [System.Text.StringBuilder]::new()
            
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $newCell = $global:TuiState.CompositorBuffer.GetCell($x, $y)
                $oldLegacyCell = $global:TuiState.FrontBuffer[$y, $x]
                
                # Convert TuiCell to legacy format for comparison
                $newLegacyCell = $newCell.ToLegacyFormat()
                
                # Check if cell changed
                if ($forceFullRender -or 
                    $newLegacyCell.Char -ne $oldLegacyCell.Char -or
                    $newLegacyCell.FG -ne $oldLegacyCell.FG -or
                    $newLegacyCell.BG -ne $oldLegacyCell.BG) {
                    
                    $rowChanged = $true
                    
                    # Update front buffer
                    $global:TuiState.FrontBuffer[$y, $x] = $newLegacyCell
                    
                    # Add color codes if needed
                    if ($newLegacyCell.FG -ne $lastFG -or $newLegacyCell.BG -ne $lastBG) {
                        $fgCode = Get-AnsiColorCode $newLegacyCell.FG
                        $bgCode = Get-AnsiColorCode $newLegacyCell.BG -IsBackground $true
                        [void]$rowOutput.Append("`e[${fgCode};${bgCode}m")
                        $lastFG = $newLegacyCell.FG
                        $lastBG = $newLegacyCell.BG
                    }
                    
                    [void]$rowOutput.Append($newLegacyCell.Char)
                } else {
                    # Cell unchanged - add placeholder for position tracking
                    [void]$rowOutput.Append($null)
                }
            }
            
            # Output the row if it changed
            if ($rowChanged) {
                [void]$outputBuilder.Append("`e[$($y + 1);1H")
                $rowStr = $rowOutput.ToString() -replace [char]0, ''
                [void]$outputBuilder.Append($rowStr)
            }
        }
        
        [void]$outputBuilder.Append("`e[0m")
        
        if ($outputBuilder.Length -gt 10) {  # Only output if there are substantial changes
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Render-FrameLegacy {
    # AI: LEGACY - Original rendering code for compatibility
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component $global:TuiState.CurrentScreen.Name -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
            }
        }
        
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog.GetType().IsSubclassOf([UIElement]) -or $dialog -is [UIElement]) {
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        Render-BufferOptimized
        
    } catch {
        Write-Log -Level Error -Message "Legacy rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    # AI: ENHANCED - Accept both UIElement and legacy screen objects
    param([object]$Screen)
    if (-not $Screen) { return }
    
    $screenName = if ($Screen -is [UIElement]) { $Screen.Name } elseif ($Screen -is [Screen]) { $Screen.Name } else { $Screen.Name }
    Write-Log -Level Debug -Message "Pushing screen: $screenName"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($global:TuiState.CurrentScreen) {
            # Handle exit for current screen
            if ($global:TuiState.CurrentScreen -is [UIElement]) {
                # New UIElement-based screen
                # No explicit OnExit method - handled by framework
            } elseif ($global:TuiState.CurrentScreen -is [Screen]) {
                # Legacy class-based screen
                $global:TuiState.CurrentScreen.OnExit()
            } elseif ($global:TuiState.CurrentScreen.OnExit) {
                # Functional screen
                $global:TuiState.CurrentScreen.OnExit.Invoke()
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # Initialize new screen
        if ($Screen -is [UIElement]) {
            # New UIElement-based screen - ensure it's sized to fit screen
            if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) {  # Default size
                $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            }
            # Trigger initial render
            $Screen.RequestRedraw()
        } elseif ($Screen -is [Screen]) {
            # Legacy class-based screen
            $Screen.OnEnter()
        } elseif ($Screen.Init) { 
            # Functional screen
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $screenName }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$screenName': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $global:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering - Legacy Support
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:TuiState.BufferWidth) { break }
        if ($currentX -ge 0) { $global:TuiState.BackBuffer[$Y, $currentX] = @{ Char = $char; FG = $ForegroundColor; BG = $BackgroundColor } }
        $currentX++
    }
}

function Write-BufferBox {
    param([int]$X, [int]$Y, [int]$Width, [int]$Height, [string]$BorderStyle = "Single", [ConsoleColor]$BorderColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, [string]$Title = "")
    $borders = Get-BorderChars -Style $BorderStyle
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    if ($Title) {
        $titleText = " $Title "; if ($titleText.Length -gt ($Width-2)) { $titleText = " $($Title.Substring(0,[Math]::Max(0,$Width-5)))... " }
        Write-BufferString -X ($X + [Math]::Floor(($Width - $titleText.Length) / 2)) -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function Render-BufferOptimized {
    $outputBuilder = [System.Text.StringBuilder]::new(20000); $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 0
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $backCell = $global:TuiState.BackBuffer[$y, $x]; $frontCell = $global:TuiState.FrontBuffer[$y, $x]
                if (-not $forceFullRender -and $backCell.Char -eq $frontCell.Char -and $backCell.FG -eq $frontCell.FG -and $backCell.BG -eq $frontCell.BG) { continue }
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) { $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null }
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG; $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null; $lastFG = $backCell.FG; $lastBG = $backCell.BG
                }
                $outputBuilder.Append($backCell.Char) | Out-Null
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = $backCell.Char; FG = $backCell.FG; BG = $backCell.BG }
            }
        }
        $outputBuilder.Append("`e[0m") | Out-Null
        if ($outputBuilder.Length -gt 0) { [Console]::Write($outputBuilder.ToString()) }
    } catch { Write-Warning "Render error: $_" }
}
#endregion

#region Component System - Enhanced for UIElement
function Initialize-ComponentSystem { $global:TuiState.Components = @(); $global:TuiState.FocusedComponent = $null }

function Register-Component { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    $global:TuiState.Components += $Component
    
    # Initialize component based on type
    if ($Component -is [UIElement]) {
        # New UIElement-based component - no explicit init needed
        Write-Log -Level Debug -Message "Registered UIElement component: $($Component.Name)"
    } elseif ($Component.Init) { 
        try { & $Component.Init -self $Component } catch { Write-Warning "Component init error: $_" } 
    }
    return $Component 
}

function Set-ComponentFocus { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) { return }
    
    # Blur current component
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    
    # Set new focused component
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    
    # Focus new component
    if ($null -ne $Component) {
        if ($Component -is [UIElement]) {
            $Component.OnFocus()
        } else {
            $Component.OnFocus?.Invoke()
        }
    }
    
    Request-TuiRefresh 
}

function Clear-ComponentFocus { 
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    $global:TuiState.FocusedComponent = $null
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $null }
    Request-TuiRefresh 
}

# AI: ENHANCED - Support UIElement focusable detection
function Get-NextFocusableComponent { 
    param([object]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = @()
    
    function Find-Focusable([object]$Comp) { 
        if ($Comp -is [UIElement]) {
            # New UIElement-based component
            if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
                $focusableComponents += $Comp
            }
            # Check children
            foreach ($child in $Comp.Children) {
                Find-Focusable $child
            }
        } else {
            # Legacy component
            if ($Comp.IsFocusable -eq $true -and $Comp.Visible -ne $false) { 
                $focusableComponents += $Comp 
            }
            if ($Comp.Children) { 
                foreach ($c in $Comp.Children) { Find-Focusable $c } 
            }
        }
    }
    
    # Find focusable components in current screen
    if ($global:TuiState.CurrentScreen -is [UIElement]) {
        Find-Focusable $global:TuiState.CurrentScreen
    } elseif ($global:TuiState.CurrentScreen.Components) { 
        foreach ($c in $global:TuiState.CurrentScreen.Components.Values) { Find-Focusable $c } 
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by tab index and position
    $sorted = $focusableComponents | Sort-Object { 
        if ($_ -is [UIElement]) {
            $_.TabIndex * 10000 + $_.Y * 100 + $_.X
        } else {
            ($_.TabIndex ?? 0) * 10000 + ($_.Y ?? 0) * 100 + ($_.X ?? 0)
        }
    }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Handle-TabNavigation { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

# AI: LEGACY - Helper functions maintained for compatibility
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Move-Focus { param([bool]$Reverse = $false); Handle-TabNavigation -Reverse $Reverse }

function Get-CurrentDialog {
    try {
        if (Get-Module -Name 'dialog-system-class' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system-class') { $script:DialogState.CurrentDialog }
        } elseif (Get-Module -Name 'dialog-system' -ErrorAction SilentlyContinue) {
            return & (Get-Module -Name 'dialog-system') { $script:DialogState.CurrentDialog }
        }
    } catch {
        Write-Log -Level Warning -Message "Error accessing dialog system: $_"
    }
    return $null
}

function Handle-DialogInput {
    param([System.ConsoleKeyInfo]$Key)
    try {
        $dialog = Get-CurrentDialog
        if ($dialog) {
            if ($dialog -is [UIElement]) {
                # New UIElement-based dialog
                return $dialog.HandleInput($Key)
            } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                # Legacy class-based dialog
                $dialog.HandleInput($Key)
                return $true
            } elseif ($dialog -is [hashtable] -and $dialog.HandleInput) {
                # Functional dialog
                return & $dialog.HandleInput -self $dialog -Key $Key
            }
        }
    } catch {
        Write-Log -Level Warning -Message "Error handling dialog input: $_"
    }
    return $false
}

function Update-DialogSystem {
    # Dialog system handles its own updates if loaded
}

function Stop-AllTuiAsyncJobs {
    Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)"
}
#endregion

#region Layout Management & Utilities
function Initialize-LayoutEngines { $global:TuiState.Layouts = @{} }
function Get-BorderChars { param([string]$Style); $styles = @{ Single=@{TopLeft='┌';TopRight='┐';BottomLeft='└';BottomRight='┘';Horizontal='─';Vertical='│'}; Double=@{TopLeft='╔';TopRight='╗';BottomLeft='╚';BottomRight='╝';Horizontal='═';Vertical='║'}; Rounded=@{TopLeft='╭';TopRight='╮';BottomLeft='╰';BottomRight='╯';Horizontal='─';Vertical='│'} }; return $styles[$Style] ?? $styles.Single }
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Get-WordWrappedLines { param([string]$Text, [int]$MaxWidth); if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }; $lines = @(); $words = $Text -split '\s+'; $sb = [System.Text.StringBuilder]::new(); foreach ($word in $words) { if ($sb.Length -eq 0) { [void]$sb.Append($word) } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) { [void]$sb.Append(' ').Append($word) } else { $lines += $sb.ToString(); [void]$sb.Clear().Append($word) } }; if ($sb.Length -gt 0) { $lines += $sb.ToString() }; return $lines }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }

# AI: NEW - Compositor helper functions
function Get-ThemeColor {
    param([string]$ColorName)
    # Simple theme color mapping - can be enhanced later
    $themeColors = @{
        Background = [ConsoleColor]::Black
        Foreground = [ConsoleColor]::White
        Border = [ConsoleColor]::Gray
        Focus = [ConsoleColor]::Cyan
        Highlight = [ConsoleColor]::Yellow
    }
    return $themeColors[$ColorName] ?? [ConsoleColor]::Black
}
#endregion

Export-ModuleMember -Function 'Initialize-TuiEngine', 'Start-TuiLoop', 'Stop-TuiEngine', 'Push-Screen', 'Pop-Screen', 'Request-TuiRefresh', 'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer', 'Get-BorderChars', 'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 'Get-NextFocusableComponent', 'Handle-TabNavigation', 'Get-WordWrappedLines', 'Get-FocusedComponent', 'Move-Focus', 'Get-CurrentDialog', 'Handle-DialogInput', 'Update-DialogSystem', 'Stop-AllTuiAsyncJobs', 'Get-ThemeColor' -Variable 'TuiState'


####\refactor_checkpoints\checkpoint_20250630_053620_phase 2 complete\screens\task-list-screen.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Task List Screen
# Displays and manages tasks.
# ==============================================================================

# AI: CRITICAL FIX - Import models module for TaskStatus enum and other types
using module '..\modules\models.psm1'

# AI: FIX - Use relative paths for better portability
using module '..\components\ui-classes.psm1'
using module '..\layout\panels-class.psm1'
using module '..\components\advanced-data-components.psm1'
using module '..\modules\dialog-system-class.psm1'

class TaskListScreen : Screen {
    # --- UI Components ---
    [BorderPanel] $MainPanel
    [Table] $TaskTable
    [ContentPanel] $NavPanel

    # --- State ---
    [string] $FilterStatus = "All"

    TaskListScreen([hashtable]$services) : base("TaskListScreen", $services) { }

    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # --- Panel Setup ---
            $this.MainPanel = [BorderPanel]::new("TaskListMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "Task List"
            $this.AddPanel($this.MainPanel)

            # --- Task Table ---
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.SetColumns(@(
                [TableColumn]::new("Title", "Task Title", 50),
                [TableColumn]::new("Status", "Status", 15),
                [TableColumn]::new("Priority", "Priority", 12),
                [TableColumn]::new("DueDate", "Due Date", 15)
            ))
            
            $tableContainer = [BorderPanel]::new("TableContainer", 1, 1, 118, 24)
            $tableContainer.ShowBorder = $false
            $tableContainer.AddChild($this.TaskTable)
            $this.MainPanel.AddChild($tableContainer)
            
            # --- Navigation Panel ---
            $this.NavPanel = [ContentPanel]::new("NavPanel", 1, 26, 118, 3)
            $this.MainPanel.AddChild($this.NavPanel)
            
            # --- Event Subscriptions & Data Load ---
            $this.SubscribeToEvent("Tasks.Changed", { $this.RefreshData() })
            $this.RefreshData()
        }
    }

    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            $allTasks = @($this.Services.DataManager.GetTasks())
            $filteredTasks = switch ($this.FilterStatus) {
                "Active" { $allTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed } }
                "Completed" { $allTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed } }
                default { $allTasks }
            }
            $this.TaskTable.SetData($filteredTasks)
            $this.UpdateNavText()
        }
    }

    hidden [void] UpdateNavText() {
        $navContent = @(
            "[N]ew | [E]dit | [D]elete | [Space]Toggle | [F]ilter: $($this.FilterStatus) | [Esc]Back"
        )
        $this.NavPanel.SetContent($navContent)
    }

    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) { $this.TaskTable.SelectPrevious() }
                ([ConsoleKey]::DownArrow) { $this.TaskTable.SelectNext() }
                ([ConsoleKey]::Spacebar) { $this.ToggleSelectedTask() }
                ([ConsoleKey]::Escape) { $this.Services.Navigation.PopScreen() }
                default {
                    switch ($key.KeyChar.ToString().ToUpper()) {
                        'N' { $this.ShowNewTaskDialog() }
                        'E' { $this.EditSelectedTask() }
                        'D' { $this.DeleteSelectedTask() }
                        'F' { $this.CycleFilter() }
                    }
                }
            }
        }
    }
    
    hidden [void] ToggleSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            # AI: FIX - TaskStatus enum should now be available from models.psm1 import
            if ($task.Status -eq [TaskStatus]::Completed) {
                $task.Status = [TaskStatus]::Pending
            } else {
                $task.Complete()
            }
            $this.Services.DataManager.UpdateTask($task)
        }
    }

    hidden [void] ShowNewTaskDialog() {
        # AI: FIX - Implemented new task dialog functionality
        Write-Log -Level Info -Message "New task dialog requested"
        
        # AI: FIX - Capture $this context for closure
        $dataManager = $this.Services.DataManager
        $refreshCallback = { $this.RefreshData() }.GetNewClosure()
        
        # Use the input dialog from dialog system
        Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {
            param($Value)
            if (-not [string]::IsNullOrWhiteSpace($Value)) {
                $newTask = $dataManager.AddTask($Value, "", [TaskPriority]::Medium, "General")
                Write-Log -Level Info -Message "Created new task: $($newTask.Title)"
                & $refreshCallback
            }
        }
    }

    hidden [void] EditSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Edit task requested for: $($task.Title)"
        }
    }

    hidden [void] DeleteSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Delete task requested for: $($task.Title)"
        }
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\screens\dashboard\dashboard-screen.psm1
# ==============================================================================
# PMC Terminal v5 - NCurses Dashboard Screen
# Main entry screen with buffer-based rendering
# ==============================================================================

# AI: PHASE 3 REFACTORED - NCurses buffer-based architecture
using module '..\..\components\tui-primitives.psm1'
using module '..\..\layout\panels-class.psm1'
using module '..\..\components\navigation-class.psm1'
using module '..\..\components\advanced-data-components.psm1'
using module '..\..\modules\models.psm1'

class DashboardScreen : UIElement {
    # --- Core Architecture ---
    [hashtable] $Services
    [Panel] $MainPanel
    [Panel] $SummaryPanel
    [Panel] $MenuPanel
    [Panel] $StatusPanel
    [NavigationMenu] $MainMenu
    [System.Collections.Generic.List[UIElement]] $Components

    # --- State Management ---
    [object[]] $Tasks = @()
    [int] $TotalTasks = 0
    [int] $CompletedTasks = 0
    [int] $PendingTasks = 0

    # --- Constructor ---
    DashboardScreen([hashtable]$services) : base(0, 0, 120, 30) {
        $this.Name = "DashboardScreen"
        $this.Services = $services
        $this.Components = [System.Collections.Generic.List[UIElement]]::new()
        $this.IsFocusable = $true
        $this.Enabled = $true
        $this.Visible = $true
        $this.Tasks = @()
        
        Write-Log -Level Info -Message "Creating DashboardScreen with NCurses architecture"
    }

    # --- Initialization ---
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "Initialize" -ScriptBlock {
            # AI: PHASE 3 - Create main panel structure
            $this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "PMC Terminal v5 - Dashboard")
            $this.MainPanel.HasBorder = $true
            $this.MainPanel.BorderStyle = "Double"
            $this.MainPanel.BorderColor = [ConsoleColor]::Cyan
            $this.MainPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MainPanel.TitleColor = [ConsoleColor]::White
            $this.MainPanel.Name = "MainDashboardPanel"
            $this.AddChild($this.MainPanel)
            
            # AI: PHASE 3 - Summary panel (left side)
            $this.SummaryPanel = [Panel]::new(2, 2, 45, 12, "Task Summary")
            $this.SummaryPanel.HasBorder = $true
            $this.SummaryPanel.BorderStyle = "Single"
            $this.SummaryPanel.BorderColor = [ConsoleColor]::Green
            $this.SummaryPanel.BackgroundColor = [ConsoleColor]::Black
            $this.SummaryPanel.Name = "SummaryPanel"
            $this.MainPanel.AddChild($this.SummaryPanel)
            
            # AI: PHASE 3 - Menu panel (right side)
            $this.MenuPanel = [Panel]::new(49, 2, 50, 15, "Main Menu")
            $this.MenuPanel.HasBorder = $true
            $this.MenuPanel.BorderStyle = "Single"
            $this.MenuPanel.BorderColor = [ConsoleColor]::Yellow
            $this.MenuPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MenuPanel.Name = "MenuPanel"
            $this.MainPanel.AddChild($this.MenuPanel)
            
            # AI: PHASE 3 - Status panel (bottom)
            $this.StatusPanel = [Panel]::new(2, 19, 116, 8, "System Status")
            $this.StatusPanel.HasBorder = $true
            $this.StatusPanel.BorderStyle = "Single"
            $this.StatusPanel.BorderColor = [ConsoleColor]::Magenta
            $this.StatusPanel.BackgroundColor = [ConsoleColor]::Black
            $this.StatusPanel.Name = "StatusPanel"
            $this.MainPanel.AddChild($this.StatusPanel)
            
            # AI: PHASE 3 - Create navigation menu
            $this.MainMenu = [NavigationMenu]::new("MainMenu")
            $this.MainMenu.Move(1, 1)  # Inside menu panel
            $this.MainMenu.Resize(48, 13)
            $this.BuildMainMenu()
            $this.MenuPanel.AddChild($this.MainMenu)
            
            # AI: PHASE 3 - Load initial data and update display
            $this.RefreshData()
            $this.UpdateDisplay()
            
            Write-Log -Level Info -Message "DashboardScreen initialized with NCurses architecture"
        }
    }

    # --- Menu Building ---
    hidden [void] BuildMainMenu() {
        try {
            $this.MainMenu.AddItem([NavigationItem]::new("1", "Task Management", { 
                $this.Services.Navigation.GoTo("/tasks", @{}) 
            }))
            $this.MainMenu.AddItem([NavigationItem]::new("2", "Project Management", { 
                $this.Services.Navigation.GoTo("/projects", @{}) 
            }))
            $this.MainMenu.AddItem([NavigationItem]::new("3", "Settings", { 
                $this.Services.Navigation.GoTo("/settings", @{}) 
            }))
            $this.MainMenu.AddSeparator()
            $this.MainMenu.AddItem([NavigationItem]::new("Q", "Quit Application", { 
                $this.Services.Navigation.RequestExit() 
            }))
            
            Write-Log -Level Debug -Message "Main menu built with $($this.MainMenu.Items.Count) items"
        } catch {
            Write-Log -Level Error -Message "Failed to build main menu: $_"
        }
    }

    # --- Data Management ---
    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "RefreshData" -ScriptBlock {
            # AI: PHASE 3 - Safe data loading
            $this.Tasks = @()
            $this.TotalTasks = 0
            $this.CompletedTasks = 0
            $this.PendingTasks = 0
            
            if ($null -eq $this.Services.DataManager) {
                Write-Log -Level Warning -Message "DataManager service not available"
                return
            }
            
            try {
                $taskData = $this.Services.DataManager.GetTasks()
                $this.Tasks = if ($null -eq $taskData) { @() } else { @($taskData) }
                
                # AI: PHASE 3 - Calculate statistics
                $this.TotalTasks = $this.Tasks.Count
                
                if ($this.TotalTasks -gt 0) {
                    try {
                        $completedTasks = @($this.Tasks | Where-Object { 
                            $null -ne $_ -and $_.Status -eq [TaskStatus]::Completed 
                        })
                        $this.CompletedTasks = $completedTasks.Count
                        $this.PendingTasks = $this.TotalTasks - $this.CompletedTasks
                    } catch {
                        # AI: PHASE 3 - Fallback for enum issues
                        Write-Log -Level Warning -Message "TaskStatus enum not available, using string comparison"
                        $completedTasks = @($this.Tasks | Where-Object { 
                            $null -ne $_ -and ($_.Status -eq "Completed" -or $_.Status -eq 2)
                        })
                        $this.CompletedTasks = $completedTasks.Count
                        $this.PendingTasks = $this.TotalTasks - $this.CompletedTasks
                    }
                }
                
                Write-Log -Level Debug -Message "Dashboard data refreshed - $($this.TotalTasks) tasks loaded"
            } catch {
                Write-Log -Level Warning -Message "Failed to load tasks: $_"
                $this.Tasks = @()
            }
        }
    }

    hidden [void] UpdateDisplay() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "UpdateDisplay" -ScriptBlock {
            # AI: PHASE 3 - Update summary panel
            $this.UpdateSummaryPanel()
            
            # AI: PHASE 3 - Update status panel
            $this.UpdateStatusPanel()
            
            $this.RequestRedraw()
        }
    }

    hidden [void] UpdateSummaryPanel() {
        if ($null -eq $this.SummaryPanel) { return }
        
        # AI: PHASE 3 - Clear summary panel content area
        $this.ClearPanelContent($this.SummaryPanel)
        
        # AI: PHASE 3 - Write summary information
        $summaryLines = @(
            "Task Overview",
            "═══════════════",
            "",
            "Total Tasks:    $($this.TotalTasks)",
            "Completed:      $($this.CompletedTasks)",
            "Pending:        $($this.PendingTasks)",
            "",
            "Progress: $($this.GetProgressBar())",
            "",
            "Use number keys or",
            "arrow keys + Enter"
        )
        
        for ($i = 0; $i -lt $summaryLines.Count; $i++) {
            $color = if ($i -eq 0) { [ConsoleColor]::White } elseif ($i -eq 1) { [ConsoleColor]::Gray } else { [ConsoleColor]::Cyan }
            $this.WriteTextToPanel($this.SummaryPanel, $summaryLines[$i], 1, $i, $color)
        }
    }

    hidden [void] UpdateStatusPanel() {
        if ($null -eq $this.StatusPanel) { return }
        
        # AI: PHASE 3 - Clear status panel content area
        $this.ClearPanelContent($this.StatusPanel)
        
        # AI: PHASE 3 - Write system status information
        $statusLines = @(
            "System Information",
            "════════════════════",
            "",
            "PowerShell Version: $($PSVersionTable.PSVersion)",
            "Platform:           $($PSVersionTable.Platform)",
            "Memory Usage:       $(Get-MemoryUsage)",
            "Current Time:       $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        )
        
        for ($i = 0; $i -lt $statusLines.Count; $i++) {
            $color = if ($i -eq 0) { [ConsoleColor]::White } elseif ($i -eq 1) { [ConsoleColor]::Gray } else { [ConsoleColor]::Green }
            $this.WriteTextToPanel($this.StatusPanel, $statusLines[$i], 1, $i, $color)
        }
    }

    # --- Helper Methods ---
    hidden [string] GetProgressBar() {
        if ($this.TotalTasks -eq 0) { return "No tasks" }
        
        $percentage = [Math]::Round(($this.CompletedTasks / $this.TotalTasks) * 100)
        $barLength = 20
        $filledLength = [Math]::Round(($percentage / 100) * $barLength)
        $bar = "█" * $filledLength + "░" * ($barLength - $filledLength)
        return "$bar $percentage%"
    }

    hidden [string] GetMemoryUsage() {
        try {
            $process = Get-Process -Id $PID
            $memoryMB = [Math]::Round($process.WorkingSet64 / 1MB, 2)
            return "$memoryMB MB"
        } catch {
            return "Unknown"
        }
    }

    hidden [void] ClearPanelContent([Panel]$panel) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $panel.BackgroundColor)
        for ($y = $panel.ContentY; $y -lt ($panel.ContentY + $panel.ContentHeight); $y++) {
            for ($x = $panel.ContentX; $x -lt ($panel.ContentX + $panel.ContentWidth); $x++) {
                $panel._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    hidden [void] WriteTextToPanel([Panel]$panel, [string]$text, [int]$x, [int]$y, [ConsoleColor]$color) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        if ($y -ge $panel.ContentHeight) { return }
        
        $chars = $text.ToCharArray()
        for ($i = 0; $i -lt $chars.Length -and ($x + $i) -lt $panel.ContentWidth; $i++) {
            $cell = [TuiCell]::new($chars[$i], $color, $panel.BackgroundColor)
            $panel._private_buffer.SetCell($panel.ContentX + $x + $i, $panel.ContentY + $y, $cell)
        }
    }

    # --- Input Handling ---
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "HandleInput" -ScriptBlock {
            # AI: PHASE 3 - Handle hotkeys first
            $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
            if ($keyChar -match '^[123Q]$') {
                Write-Log -Level Debug -Message "Processing hotkey: $keyChar"
                try {
                    $this.MainMenu.ExecuteAction($keyChar)
                    return $true
                } catch {
                    Write-Log -Level Error -Message "Failed to execute menu action: $_"
                }
            }
            
            # AI: PHASE 3 - Handle navigation keys
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.MainMenu.SelectedIndex -gt 0) {
                        $this.MainMenu.SelectedIndex--
                        $this.RequestRedraw()
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.MainMenu.SelectedIndex -lt ($this.MainMenu.Items.Count - 1)) {
                        $this.MainMenu.SelectedIndex++
                        $this.RequestRedraw()
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    try {
                        $selectedItem = $this.MainMenu.Items[$this.MainMenu.SelectedIndex]
                        if ($selectedItem -and $selectedItem.Enabled) {
                            Write-Log -Level Debug -Message "Executing selected menu item: $($selectedItem.Key)"
                            $selectedItem.Execute()
                            return $true
                        }
                    } catch {
                        Write-Log -Level Error -Message "Failed to execute selected menu item: $_"
                    }
                }
                ([ConsoleKey]::Escape) {
                    Write-Log -Level Debug -Message "Escape pressed - requesting exit"
                    try {
                        $this.Services.Navigation.RequestExit()
                        return $true
                    } catch {
                        Write-Log -Level Error -Message "Failed to request exit: $_"
                    }
                }
                ([ConsoleKey]::F5) {
                    # AI: PHASE 3 - Refresh data on F5
                    $this.RefreshData()
                    $this.UpdateDisplay()
                    return $true
                }
            }
        }
        return $false
    }

    # --- NCurses Rendering ---
    [void] _RenderContent() {
        # AI: PHASE 3 - Buffer-based rendering
        if ($null -eq $this._private_buffer) { return }
        
        # AI: PHASE 3 - Clear buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black)
        $this._private_buffer.Clear($bgCell)
        
        # AI: PHASE 3 - Render all child components
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
            }
        }
    }

    # --- Lifecycle Methods ---
    [void] OnEnter() {
        $this.RefreshData()
        $this.UpdateDisplay()
        Write-Log -Level Debug -Message "DashboardScreen entered"
    }

    [void] OnExit() {
        Write-Log -Level Debug -Message "DashboardScreen exited"
    }

    [void] OnDeactivate() {
        $this.Cleanup()
        Write-Log -Level Debug -Message "DashboardScreen deactivated"
    }

    [void] Cleanup() {
        $this.Components.Clear()
        $this.Children.Clear()
        Write-Log -Level Debug -Message "DashboardScreen cleaned up"
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\screens\task-list-screen.psm1
# ==============================================================================
# PMC Terminal v5 - NCurses Task List Screen
# Displays and manages tasks with buffer-based rendering
# ==============================================================================

# AI: PHASE 3 REFACTORED - NCurses buffer-based architecture
using module '..\components\tui-primitives.psm1'
using module '..\layout\panels-class.psm1'
using module '..\components\advanced-data-components.psm1'
using module '..\components\navigation-class.psm1'
using module '..\modules\dialog-system-class.psm1'
using module '..\modules\models.psm1'

class TaskListScreen : UIElement {
    # --- Core Architecture ---
    [hashtable] $Services
    [Panel] $MainPanel
    [Panel] $HeaderPanel
    [Panel] $TablePanel
    [Panel] $FooterPanel
    [Table] $TaskTable
    [System.Collections.Generic.List[UIElement]] $Components

    # --- State Management ---
    [string] $FilterStatus = "All"
    [object[]] $AllTasks = @()
    [object[]] $FilteredTasks = @()
    [int] $SelectedIndex = 0

    # --- Constructor ---
    TaskListScreen([hashtable]$services) : base(0, 0, 120, 30) {
        $this.Name = "TaskListScreen"
        $this.Services = $services
        $this.Components = [System.Collections.Generic.List[UIElement]]::new()
        $this.IsFocusable = $true
        $this.Enabled = $true
        $this.Visible = $true
    }

    # --- Initialization ---
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # AI: PHASE 3 - Create main panel structure
            $this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "Task List")
            $this.MainPanel.HasBorder = $true
            $this.MainPanel.BorderStyle = "Double"
            $this.MainPanel.BorderColor = [ConsoleColor]::Gray
            $this.MainPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MainPanel.Name = "MainTaskPanel"
            $this.AddChild($this.MainPanel)
            
            # AI: PHASE 3 - Header panel for title and filter info
            $this.HeaderPanel = [Panel]::new(1, 1, 118, 3, "")
            $this.HeaderPanel.HasBorder = $false
            $this.HeaderPanel.BackgroundColor = [ConsoleColor]::Black
            $this.HeaderPanel.Name = "HeaderPanel"
            $this.MainPanel.AddChild($this.HeaderPanel)
            
            # AI: PHASE 3 - Table panel for task data
            $this.TablePanel = [Panel]::new(1, 4, 118, 22, "")
            $this.TablePanel.HasBorder = $true
            $this.TablePanel.BorderStyle = "Single"
            $this.TablePanel.BorderColor = [ConsoleColor]::DarkGray
            $this.TablePanel.BackgroundColor = [ConsoleColor]::Black
            $this.TablePanel.Name = "TablePanel"
            $this.MainPanel.AddChild($this.TablePanel)
            
            # AI: PHASE 3 - Footer panel for navigation help
            $this.FooterPanel = [Panel]::new(1, 26, 118, 3, "")
            $this.FooterPanel.HasBorder = $false
            $this.FooterPanel.BackgroundColor = [ConsoleColor]::Black
            $this.FooterPanel.Name = "FooterPanel"
            $this.MainPanel.AddChild($this.FooterPanel)
            
            # AI: PHASE 3 - Create task table component
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.Move(1, 1)  # Inside table panel
            $this.TaskTable.Resize(116, 20)
            $this.TaskTable.SetColumns(@(
                @{ Name = "Title"; Width = 50; Header = "Task Title" },
                @{ Name = "Status"; Width = 15; Header = "Status" },
                @{ Name = "Priority"; Width = 12; Header = "Priority" },
                @{ Name = "DueDate"; Width = 15; Header = "Due Date" }
            ))
            $this.TablePanel.AddChild($this.TaskTable)
            
            # AI: PHASE 3 - Load initial data
            $this.RefreshData()
            $this.UpdateDisplay()
            
            Write-Log -Level Info -Message "TaskListScreen initialized with NCurses architecture"
        }
    }

    # --- Data Management ---
    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            # AI: PHASE 3 - Safe data loading with error handling
            try {
                $this.AllTasks = @($this.Services.DataManager.GetTasks())
                if ($null -eq $this.AllTasks) { $this.AllTasks = @() }
            } catch {
                Write-Log -Level Warning -Message "Failed to load tasks: $_"
                $this.AllTasks = @()
            }
            
            # AI: PHASE 3 - Apply current filter
            $this.FilteredTasks = switch ($this.FilterStatus) {
                "Active" { @($this.AllTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed }) }
                "Completed" { @($this.AllTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed }) }
                default { $this.AllTasks }
            }
            
            # AI: PHASE 3 - Update table data
            $this.TaskTable.SetData($this.FilteredTasks)
            
            # AI: PHASE 3 - Adjust selection if needed
            if ($this.SelectedIndex -ge $this.FilteredTasks.Count) {
                $this.SelectedIndex = [Math]::Max(0, $this.FilteredTasks.Count - 1)
            }
            
            $this.RequestRedraw()
        }
    }

    hidden [void] UpdateDisplay() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "UpdateDisplay" -ScriptBlock {
            # AI: PHASE 3 - Update header text
            $headerText = "Filter: $($this.FilterStatus) | Total: $($this.FilteredTasks.Count) tasks"
            $this.WriteTextToPanel($this.HeaderPanel, $headerText, 0, 0, [ConsoleColor]::White)
            
            # AI: PHASE 3 - Update footer navigation text
            $footerText = "[↑↓]Navigate [Space]Toggle [N]ew [E]dit [D]elete [F]ilter [Esc]Back"
            $this.WriteTextToPanel($this.FooterPanel, $footerText, 0, 0, [ConsoleColor]::Yellow)
            
            # AI: PHASE 3 - Update table selection
            $this.TaskTable.SetSelectedIndex($this.SelectedIndex)
            
            $this.RequestRedraw()
        }
    }

    # --- Helper Methods ---
    hidden [void] WriteTextToPanel([Panel]$panel, [string]$text, [int]$x, [int]$y, [ConsoleColor]$color) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        
        $chars = $text.ToCharArray()
        for ($i = 0; $i -lt $chars.Length -and ($x + $i) -lt $panel.ContentWidth; $i++) {
            $cell = [TuiCell]::new($chars[$i], $color, $panel.BackgroundColor)
            $panel._private_buffer.SetCell($panel.ContentX + $x + $i, $panel.ContentY + $y, $cell)
        }
    }

    # --- Input Handling ---
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $this.UpdateDisplay()
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt ($this.FilteredTasks.Count - 1) -and $this.FilteredTasks.Count -gt 0) {
                        $this.SelectedIndex++
                        $this.UpdateDisplay()
                        return $true
                    }
                }
                ([ConsoleKey]::Spacebar) {
                    $this.ToggleSelectedTask()
                    return $true
                }
                ([ConsoleKey]::Escape) {
                    $this.NavigateBack()
                    return $true
                }
                default {
                    $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
                    switch ($keyChar) {
                        'N' { $this.ShowNewTaskDialog(); return $true }
                        'E' { $this.EditSelectedTask(); return $true }
                        'D' { $this.DeleteSelectedTask(); return $true }
                        'F' { $this.CycleFilter(); return $true }
                    }
                }
            }
        }
        return $false
    }

    # --- Task Actions ---
    hidden [void] ToggleSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        try {
            if ($task.Status -eq [TaskStatus]::Completed) {
                $task.Status = [TaskStatus]::Pending
            } else {
                $task.Status = [TaskStatus]::Completed
            }
            $this.Services.DataManager.UpdateTask($task)
            $this.RefreshData()
            $this.UpdateDisplay()
        } catch {
            Write-Log -Level Error -Message "Failed to toggle task: $_"
        }
    }

    hidden [void] ShowNewTaskDialog() {
        Write-Log -Level Info -Message "New task dialog requested"
        
        # AI: PHASE 3 - Implement new task creation
        $dataManager = $this.Services.DataManager
        $refreshCallback = { $this.RefreshData(); $this.UpdateDisplay() }.GetNewClosure()
        
        try {
            Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {
                param($Value)
                if (-not [string]::IsNullOrWhiteSpace($Value)) {
                    $newTask = $dataManager.AddTask($Value, "", [TaskPriority]::Medium, "General")
                    Write-Log -Level Info -Message "Created new task: $($newTask.Title)"
                    & $refreshCallback
                }
            }
        } catch {
            Write-Log -Level Error -Message "Failed to show new task dialog: $_"
        }
    }

    hidden [void] EditSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        Write-Log -Level Info -Message "Edit task requested for: $($task.Title)"
        # AI: PHASE 3 - Placeholder for edit functionality
    }

    hidden [void] DeleteSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        Write-Log -Level Info -Message "Delete task requested for: $($task.Title)"
        # AI: PHASE 3 - Placeholder for delete functionality
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
        $this.UpdateDisplay()
    }

    hidden [void] NavigateBack() {
        try {
            $this.Services.Navigation.PopScreen()
        } catch {
            Write-Log -Level Error -Message "Failed to navigate back: $_"
        }
    }

    # --- NCurses Rendering ---
    [void] _RenderContent() {
        # AI: PHASE 3 - Buffer-based rendering
        if ($null -eq $this._private_buffer) { return }
        
        # AI: PHASE 3 - Clear buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black)
        $this._private_buffer.Clear($bgCell)
        
        # AI: PHASE 3 - Render all child components
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
            }
        }
    }

    # --- Lifecycle Methods ---
    [void] OnEnter() {
        $this.RefreshData()
        $this.UpdateDisplay()
        Write-Log -Level Debug -Message "TaskListScreen entered"
    }

    [void] OnExit() {
        Write-Log -Level Debug -Message "TaskListScreen exited"
    }

    [void] Cleanup() {
        $this.Components.Clear()
        $this.Children.Clear()
        Write-Log -Level Debug -Message "TaskListScreen cleaned up"
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\services\keybinding-service.psm1
# KeybindingService - Class-Based Implementation
# Manages application keybindings with proper error handling and validation
# AI: Updated with sophisticated keybinding features from R2 version

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# KeybindingService Class - Manages application-wide key bindings
class KeybindingService {
    [hashtable] $KeyMap = @{}
    [hashtable] $GlobalHandlers = @{}
    [System.Collections.Generic.List[string]] $ContextStack
    [bool] $EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized"
    }
    
    KeybindingService([bool]$enableChords) {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.EnableChords = $enableChords
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized with chords: $enableChords"
    }
    
    hidden [void] InitializeDefaultBindings() {
        # AI: Standard application keybindings
        $this.KeyMap = @{
            "app.exit" = @{ Key = "Q"; Modifiers = @("Ctrl") }
            "app.help" = @{ Key = [System.ConsoleKey]::F1; Modifiers = @() }
            "nav.back" = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }
            "nav.up" = @{ Key = [System.ConsoleKey]::UpArrow; Modifiers = @() }
            "nav.down" = @{ Key = [System.ConsoleKey]::DownArrow; Modifiers = @() }
            "nav.left" = @{ Key = [System.ConsoleKey]::LeftArrow; Modifiers = @() }
            "nav.right" = @{ Key = [System.ConsoleKey]::RightArrow; Modifiers = @() }
            "nav.select" = @{ Key = [System.ConsoleKey]::Enter; Modifiers = @() }
            "nav.pageup" = @{ Key = [System.ConsoleKey]::PageUp; Modifiers = @() }
            "nav.pagedown" = @{ Key = [System.ConsoleKey]::PageDown; Modifiers = @() }
            "nav.home" = @{ Key = [System.ConsoleKey]::Home; Modifiers = @() }
            "nav.end" = @{ Key = [System.ConsoleKey]::End; Modifiers = @() }
            "nav.tab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @() }
            "nav.shifttab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @("Shift") }
            "edit.delete" = @{ Key = [System.ConsoleKey]::Delete; Modifiers = @() }
            "edit.backspace" = @{ Key = [System.ConsoleKey]::Backspace; Modifiers = @() }
            "edit.new" = @{ Key = "n"; Modifiers = @() }
            "edit.save" = @{ Key = "s"; Modifiers = @("Ctrl") }
            "app.refresh" = @{ Key = [System.ConsoleKey]::F5; Modifiers = @() }
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKey]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [char]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
        }
        
        $modifiers = @()
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) { $modifiers += "Ctrl" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) { $modifiers += "Alt" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) { $modifiers += "Shift" }

        $this.KeyMap[$actionName.ToLower()] = @{
            Key = $keyInfo.Key
            KeyChar = $keyInfo.KeyChar
            Modifiers = $modifiers
        }
        Write-Log -Level Debug -Message "Set keybinding for '$actionName': $($this.GetBindingDescription($actionName))"
    }
    
    [void] RemoveBinding([string]$actionName) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RemoveBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return
            }
            
            $normalizedName = $actionName.ToLower()
            if ($this.KeyMap.ContainsKey($normalizedName)) {
                $this.KeyMap.Remove($normalizedName)
                Write-Log -Level Debug -Message "Removed keybinding: $actionName"
            }
        }
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        return $this.IsAction($actionName, $keyInfo, $null)
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "IsAction:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return $false
            }
            
            $normalizedName = $actionName.ToLower()
            if (-not $this.KeyMap.ContainsKey($normalizedName)) {
                return $false
            }
            
            $binding = $this.KeyMap[$normalizedName]
            
            # Check if the key matches
            $keyMatches = $false
            if ($binding.Key -is [System.ConsoleKey]) {
                $keyMatches = ($keyInfo.Key -eq $binding.Key)
            }
            elseif ($binding.Key -is [char]) {
                $keyMatches = ($keyInfo.KeyChar -eq $binding.Key)
            }
            elseif ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
                # Character-based binding (case-insensitive)
                $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.KeyChar.ToString(), [System.StringComparison]::OrdinalIgnoreCase)
            }
            else {
                # Try string comparison for backward compatibility
                $keyString = $binding.Key.ToString()
                if ($keyString.Length -eq 1) {
                    $keyMatches = ($keyInfo.KeyChar.ToString().ToUpper() -eq $keyString.ToUpper())
                }
                else {
                    # Try to match against ConsoleKey enum
                    try {
                        $consoleKey = [System.ConsoleKey]::Parse([System.ConsoleKey], $keyString, $true)
                        $keyMatches = ($keyInfo.Key -eq $consoleKey)
                    }
                    catch {
                        $keyMatches = $false
                    }
                }
            }
            
            if (-not $keyMatches) {
                return $false
            }
            
            # Check modifiers
            $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
            $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
            $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
            
            $expectedCtrl = $binding.Modifiers -contains "Ctrl"
            $expectedAlt = $binding.Modifiers -contains "Alt"
            $expectedShift = $binding.Modifiers -contains "Shift"
            
            return ($hasCtrl -eq $expectedCtrl) -and ($hasAlt -eq $expectedAlt) -and ($hasShift -eq $expectedShift)
        }
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "GetAction" -ScriptBlock {
            foreach ($actionName in $this.KeyMap.Keys) {
                if ($this.IsAction($actionName, $keyInfo)) {
                    return $actionName
                }
            }
            return $null
        }
    }
    
    [void] RegisterGlobalHandler([string]$actionName, [scriptblock]$handler) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RegisterGlobalHandler:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            if ($null -eq $handler) {
                throw [System.ArgumentNullException]::new("handler", "Handler cannot be null")
            }
            
            $this.GlobalHandlers[$actionName.ToLower()] = $handler
            Write-Log -Level Debug -Message "Registered global handler: $actionName"
        }
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo) {
        return $this.HandleKey($keyInfo, $null)
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "HandleKey" -ScriptBlock {
            # Check all registered actions
            foreach ($action in $this.KeyMap.Keys) {
                if ($this.IsAction($action, $keyInfo, $context)) {
                    # Execute global handler if registered
                    if ($this.GlobalHandlers.ContainsKey($action)) {
                        Write-Log -Level Debug -Message "Executing global handler: $action"
                        try {
                            return & $this.GlobalHandlers[$action] -KeyInfo $keyInfo -Context $context
                        }
                        catch {
                            Write-Log -Level Error -Message "Global handler failed for '$action': $_"
                            return $null
                        }
                    }
                    
                    # Return the action name for the caller to handle
                    return $action
                }
            }
            
            return $null
        }
    }
    
    [void] PushContext([string]$context) {
        if (-not [string]::IsNullOrWhiteSpace($context)) {
            $this.ContextStack.Add($context)
            Write-Log -Level Debug -Message "Pushed keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
        }
    }
    
    [string] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $context = $this.ContextStack[-1]
            $this.ContextStack.RemoveAt($this.ContextStack.Count - 1)
            Write-Log -Level Debug -Message "Popped keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
            return $context
        }
        return $null
    }
    
    [string] GetCurrentContext() {
        if ($this.ContextStack.Count -gt 0) {
            return $this.ContextStack[-1]
        }
        return "global"
    }
    
    [string] GetBindingDescription([string]$actionName) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            return $null
        }
        
        $normalizedName = $actionName.ToLower()
        if (-not $this.KeyMap.ContainsKey($normalizedName)) {
            return "Unbound"
        }
        
        $binding = $this.KeyMap[$normalizedName]
        $keyStr = if ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
            $binding.KeyChar.ToString().ToUpper()
        } elseif ($binding.Key -is [System.ConsoleKey]) {
            $binding.Key.ToString()
        } else {
            $binding.Key.ToString().ToUpper()
        }
        
        if ($binding.Modifiers.Count -gt 0) {
            return "$($binding.Modifiers -join '+') + $keyStr"
        }
        
        return $keyStr
    }
    
    [hashtable] GetAllBindings() {
        return $this.GetAllBindings($false)
    }
    
    [hashtable] GetAllBindings([bool]$groupByCategory) {
        if (-not $groupByCategory) {
            return $this.KeyMap.Clone()
        }
        
        # Group by category (part before the dot)
        $grouped = @{}
        foreach ($action in $this.KeyMap.Keys) {
            $parts = $action.Split('.')
            $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
            if (-not $grouped.ContainsKey($category)) {
                $grouped[$category] = @{}
            }
            $grouped[$category][$action] = $this.KeyMap[$action]
        }
        
        return $grouped
    }
    
    [void] ExportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ExportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            $this.KeyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $path -Encoding UTF8
            Write-Log -Level Info -Message "Exported keybindings to: $path"
        }
    }
    
    [void] ImportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ImportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            if (-not (Test-Path $path)) {
                Write-Log -Level Warning -Message "Keybindings file not found: $path"
                return
            }
            
            try {
                $imported = Get-Content $path -Raw | ConvertFrom-Json
                foreach ($prop in $imported.PSObject.Properties) {
                    $bindingData = @{
                        Key = $prop.Value.Key
                        Modifiers = $prop.Value.Modifiers
                    }
                    if ($prop.Value.PSObject.Properties.Name -contains 'KeyChar') {
                        $bindingData['KeyChar'] = $prop.Value.KeyChar
                    }
                    $this.KeyMap[$prop.Name] = $bindingData
                }
                Write-Log -Level Info -Message "Imported keybindings from: $path"
            }
            catch {
                Write-Log -Level Error -Message "Failed to import keybindings from '$path': $_"
                throw
            }
        }
    }
}

# AI: Factory function to create KeybindingService instances
# This is the most reliable way to expose classes from modules in PowerShell 7
function New-KeybindingService {
    <#
    .SYNOPSIS
    Creates a new instance of the KeybindingService class
    
    .PARAMETER EnableChords
    Enable chord keybinding support
    
    .EXAMPLE
    $keybindingService = New-KeybindingService
    
    .EXAMPLE
    $keybindingService = New-KeybindingService -EnableChords
    #>
    [CmdletBinding()]
    param(
        [switch]$EnableChords
    )
    
    if ($EnableChords) {
        return [KeybindingService]::new($true)
    }
    else {
        return [KeybindingService]::new()
    }
}

# This module only contains a class, so this is the most compatible way to export it.
# AI: In PowerShell 7, we need to export the class using the Export-ModuleMember with proper patterns
# The class is automatically available when the module is imported with 'using module'

# Export the factory function
Export-ModuleMember -Function 'New-KeybindingService'

# For standard Import-Module usage, we need to ensure the type is available
# The class KeybindingService is now accessible after Import-Module


####\services\navigation-service-class.psm1
# Navigation Service - Class-Based Implementation
# Manages screen navigation, routing, and history.

using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

class ScreenFactory {
    hidden [hashtable] $Services
    hidden [hashtable] $ScreenTypes = @{}
    
    ScreenFactory([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        Write-Log -Level Debug -Message "ScreenFactory initialized"
    }
    
    [void] RegisterScreen([string]$name, [type]$screenType) {
        if (-not $screenType.IsSubclassOf([Screen])) { 
            throw "Screen type '$($screenType.Name)' must inherit from the Screen class." 
        }
        $this.ScreenTypes[$name] = $screenType
        Write-Log -Level Info -Message "Registered screen factory: $name -> $($screenType.Name)"
    }
    
    [Screen] CreateScreen([string]$screenName, [hashtable]$parameters) {
        $screenType = $this.ScreenTypes[$screenName]
        if (-not $screenType) {
            throw "Unknown screen type: '$screenName'. Available screens: $($this.ScreenTypes.Keys -join ', ')"
        }
        
        try {
            # AI: FIX - Create screen instance with services parameter
            $screen = $screenType::new($this.Services)
            if ($parameters) {
                foreach ($key in $parameters.Keys) { 
                    $screen.State[$key] = $parameters[$key] 
                }
            }
            Write-Log -Level Info -Message "Created screen: $screenName"
            return $screen
        } catch {
            Write-Log -Level Error -Message "Failed to create screen '$screenName': $($_.Exception.Message)"
            throw
        }
    }
    
    [string[]] GetRegisteredScreens() {
        return @($this.ScreenTypes.Keys)
    }
}

class NavigationService {
    [System.Collections.Generic.Stack[Screen]] $ScreenStack
    [ScreenFactory] $ScreenFactory
    [Screen] $CurrentScreen
    [hashtable] $Services
    [hashtable] $RouteMap = @{}
    
    NavigationService([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        $this.ScreenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.ScreenFactory = [ScreenFactory]::new($services)
        $this.InitializeRoutes()
        Write-Log -Level Info -Message "NavigationService initialized"
    }
    
    hidden [void] InitializeRoutes() {
        $this.RouteMap = @{
            "/" = "DashboardScreen"
            "/dashboard" = "DashboardScreen"
            "/tasks" = "TaskListScreen"
        }
        Write-Log -Level Debug -Message "Routes initialized: $($this.RouteMap.Keys -join ', ')"
    }
    
    # AI: FIX - Method to register screen classes from main program
    [void] RegisterScreenClass([string]$name, [type]$screenType) {
        $this.ScreenFactory.RegisterScreen($name, $screenType)
    }
    
    [void] GoTo([string]$path, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "GoTo:$path" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) { 
                throw [System.ArgumentException]::new("Path cannot be empty.") 
            }
            if ($path -eq "/exit") { 
                $this.RequestExit()
                return 
            }
            
            $screenName = $this.RouteMap[$path]
            if (-not $screenName) {
                $availableRoutes = $this.RouteMap.Keys -join ', '
                throw "Unknown route: '$path'. Available routes: $availableRoutes"
            }
            
            Write-Log -Level Info -Message "Navigating to: $path -> $screenName"
            $this.PushScreen($screenName, $parameters)
        }
    }
    
    [void] PushScreen([string]$screenName, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "PushScreen:$screenName" -ScriptBlock {
            Write-Log -Level Info -Message "Pushing screen: $screenName"
            
            if ($this.CurrentScreen) {
                Write-Log -Level Debug -Message "Exiting current screen: $($this.CurrentScreen.Name)"
                $this.CurrentScreen.OnExit()
                $this.ScreenStack.Push($this.CurrentScreen)
            }
            
            Write-Log -Level Debug -Message "Creating new screen: $screenName"
            $newScreen = $this.ScreenFactory.CreateScreen($screenName, $parameters)
            $this.CurrentScreen = $newScreen
            
            Write-Log -Level Debug -Message "Initializing screen: $screenName"
            $newScreen.Initialize()
            $newScreen.OnEnter()
            
            # AI: FIX - Push screen to TUI engine using global function
            if (Get-Command "Push-Screen" -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Pushing screen to TUI engine"
                Push-Screen -Screen $newScreen
            } else {
                # Fallback - set global state directly
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $newScreen
                    Request-TuiRefresh
                }
            }
            
            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{ Screen = $screenName; Action = "Push" }
            Write-Log -Level Info -Message "Successfully pushed screen: $screenName"
        }
    }
    
    [bool] PopScreen() {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "PopScreen" -ScriptBlock {
            if ($this.ScreenStack.Count -eq 0) { 
                Write-Log -Level Warning -Message "Cannot pop screen: stack is empty"
                return $false 
            }
            
            Write-Log -Level Info -Message "Popping screen"
            $this.CurrentScreen?.OnExit()
            $this.CurrentScreen = $this.ScreenStack.Pop()
            $this.CurrentScreen?.OnResume()
            
            # AI: FIX - Use TUI engine function if available
            if (Get-Command "Pop-Screen" -ErrorAction SilentlyContinue) {
                Pop-Screen
            } else {
                # Fallback - set global state directly
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $this.CurrentScreen
                    Request-TuiRefresh
                }
            }
            
            Publish-Event -EventName "Navigation.ScreenPopped" -Data @{ Screen = $this.CurrentScreen.Name }
            return $true
        }
    }
    
    [void] RequestExit() {
        Write-Log -Level Info -Message "Exit requested"
        while ($this.PopScreen()) {} # Pop all screens
        $this.CurrentScreen?.OnExit()
        if (Get-Command "Stop-TuiEngine" -ErrorAction SilentlyContinue) {
            Stop-TuiEngine
        }
        Publish-Event -EventName "Application.Exit"
    }
    
    [Screen] GetCurrentScreen() { return $this.CurrentScreen }
    [bool] IsValidRoute([string]$path) { return $this.RouteMap.ContainsKey($path) }
    
    # AI: FIX - Debug methods
    [void] ListRegisteredScreens() {
        $screens = $this.ScreenFactory.GetRegisteredScreens()
        Write-Log -Level Info -Message "Registered screens: $($screens -join ', ')"
        Write-Host "Registered screens: $($screens -join ', ')" -ForegroundColor Green
    }
    
    [void] ListAvailableRoutes() {
        $routes = $this.RouteMap.Keys
        Write-Log -Level Info -Message "Available routes: $($routes -join ', ')"
        Write-Host "Available routes: $($routes -join ', ')" -ForegroundColor Green
    }
}

function Initialize-NavigationService {
    param([hashtable]$Services)
    if (-not $Services) { throw [System.ArgumentNullException]::new("Services") }
    return [NavigationService]::new($Services)
}

Export-ModuleMember -Function 'Initialize-NavigationService'


####\tests\Test-PMCTerminal.ps1
# ==============================================================================
# PMC Terminal v5 "Helios" - Comprehensive Test Script
# ==============================================================================

param(
    [switch]$Verbose,
    [switch]$SkipClearCache
)

$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# Change to project root
Set-Location $PSScriptRoot\..

Write-Host "`n=== PMC Terminal v5 Test Suite ===" -ForegroundColor Cyan

# 1. Clear module cache
if (-not $SkipClearCache) {
    Write-Host "`n[1] Clearing module cache..." -ForegroundColor Yellow
    & .\Clear-ModuleCache.ps1
    Write-Host "    ✓ Module cache cleared" -ForegroundColor Green
}

# 2. Test module loading
Write-Host "`n[2] Testing module loading..." -ForegroundColor Yellow
$modulesToTest = @(
    'exceptions', 'logger', 'event-system', 'theme-manager',
    'models', 'ui-classes', 'panels-class', 'navigation-class',
    'advanced-data-components', 'data-manager', 'keybinding-service',
    'navigation-service-class', 'dialog-system', 'tui-framework',
    'dashboard-screen', 'task-list-screen', 'tui-engine-v2'
)

$loadErrors = @()
foreach ($module in $modulesToTest) {
    try {
        $modulePath = Get-ChildItem -Path . -Filter "*$module*.psm1" -Recurse | Select-Object -First 1
        if ($modulePath) {
            Import-Module $modulePath.FullName -Force -ErrorAction Stop
            Write-Host "    ✓ Loaded: $module" -ForegroundColor Green
        } else {
            throw "Module file not found"
        }
    } catch {
        Write-Host "    ✗ Failed: $module - $_" -ForegroundColor Red
        $loadErrors += @{ Module = $module; Error = $_.Exception.Message }
    }
}

if ($loadErrors.Count -gt 0) {
    Write-Host "`nModule loading errors detected. Aborting tests." -ForegroundColor Red
    $loadErrors | Format-Table -AutoSize
    exit 1
}

# 3. Test service initialization
Write-Host "`n[3] Testing service initialization..." -ForegroundColor Yellow
try {
    # Initialize core services
    Initialize-Logger
    Write-Host "    ✓ Logger initialized" -ForegroundColor Green
    
    Initialize-EventSystem
    Write-Host "    ✓ Event system initialized" -ForegroundColor Green
    
    Initialize-ThemeManager
    Write-Host "    ✓ Theme manager initialized" -ForegroundColor Green
    
    Initialize-DialogSystem
    Write-Host "    ✓ Dialog system initialized" -ForegroundColor Green
    
    # Initialize data manager
    $dataManager = Initialize-DataManager
    Write-Host "    ✓ Data manager initialized" -ForegroundColor Green
    
    # Create services hashtable
    $services = @{
        DataManager = $dataManager
        Keybindings = New-KeybindingService  # AI: Using factory function for better compatibility
    }
    $services.Navigation = Initialize-NavigationService -Services $services  # AI: Using factory function
    Write-Host "    ✓ All services initialized" -ForegroundColor Green
    
} catch {
    Write-Host "    ✗ Service initialization failed: $_" -ForegroundColor Red
    exit 1
}

# 4. Test screen creation
Write-Host "`n[4] Testing screen creation..." -ForegroundColor Yellow
try {
    # AI: Using ScreenFactory through NavigationService for proper screen creation
    # This tests both the factory pattern and screen initialization
    
    # Test dashboard screen creation through factory
    $dashboardScreen = $services.Navigation.ScreenFactory.CreateScreen("DashboardScreen", @{})
    Write-Host "    ✓ Dashboard screen created via factory" -ForegroundColor Green
    
    # Test task list screen creation through factory
    $taskScreen = $services.Navigation.ScreenFactory.CreateScreen("TaskListScreen", @{})
    Write-Host "    ✓ Task list screen created via factory" -ForegroundColor Green
    
    # Test navigation to screens
    $services.Navigation.GoTo("/dashboard")
    Write-Host "    ✓ Successfully navigated to dashboard" -ForegroundColor Green
    
} catch {
    Write-Host "    ✗ Screen creation failed: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    exit 1
}

# 5. Test data operations
Write-Host "`n[5] Testing data operations..." -ForegroundColor Yellow
try {
    # Add test task
    $testTask = $dataManager.AddTask("Test Task", "This is a test task", [TaskPriority]::Medium, "General")
    Write-Host "    ✓ Created test task: $($testTask.Title)" -ForegroundColor Green
    
    # Get tasks
    $tasks = $dataManager.GetTasks()
    Write-Host "    ✓ Retrieved $($tasks.Count) tasks" -ForegroundColor Green
    
    # Save data
    $dataManager.SaveData()
    Write-Host "    ✓ Data saved successfully" -ForegroundColor Green
    
} catch {
    Write-Host "    ✗ Data operations failed: $_" -ForegroundColor Red
    exit 1
}

# 6. Test TUI engine functions
Write-Host "`n[6] Testing TUI engine functions..." -ForegroundColor Yellow
try {
    # Test missing function availability
    if (Get-Command Get-CurrentDialog -ErrorAction SilentlyContinue) {
        Write-Host "    ✓ Get-CurrentDialog function available" -ForegroundColor Green
    } else {
        Write-Host "    ✗ Get-CurrentDialog function missing" -ForegroundColor Red
    }
    
    if (Get-Command Stop-AllTuiAsyncJobs -ErrorAction SilentlyContinue) {
        Write-Host "    ✓ Stop-AllTuiAsyncJobs function available" -ForegroundColor Green
    } else {
        Write-Host "    ✗ Stop-AllTuiAsyncJobs function missing" -ForegroundColor Red
    }
    
    if (Get-Command Move-Focus -ErrorAction SilentlyContinue) {
        Write-Host "    ✓ Move-Focus function available" -ForegroundColor Green
    } else {
        Write-Host "    ✗ Move-Focus function missing" -ForegroundColor Red
    }
    
} catch {
    Write-Host "    ✗ TUI engine function test failed: $_" -ForegroundColor Red
}

# 7. Test navigation
Write-Host "`n[7] Testing navigation..." -ForegroundColor Yellow
try {
    # Check if dashboard route exists
    if ($services.Navigation.IsValidRoute("/dashboard")) {
        Write-Host "    ✓ Dashboard route is valid" -ForegroundColor Green
    } else {
        Write-Host "    ✗ Dashboard route not found" -ForegroundColor Red
    }
    
    # Check if tasks route exists
    if ($services.Navigation.IsValidRoute("/tasks")) {
        Write-Host "    ✓ Tasks route is valid" -ForegroundColor Green
    } else {
        Write-Host "    ✗ Tasks route not found" -ForegroundColor Red
    }
    
} catch {
    Write-Host "    ✗ Navigation test failed: $_" -ForegroundColor Red
}

Write-Host "`n=== Test Summary ===" -ForegroundColor Cyan
Write-Host "All critical tests passed! The application should now work." -ForegroundColor Green
Write-Host "`nTo run the application, execute:" -ForegroundColor Yellow
Write-Host "    .\_CLASSY-MAIN.ps1" -ForegroundColor White
Write-Host "`nNote: If you still encounter errors, check the log file at:" -ForegroundColor Yellow
Write-Host "    $env:TEMP\PMCTerminal\pmc_terminal_$(Get-Date -Format 'yyyy-MM-dd').log" -ForegroundColor White



####\tools\refactor-checkpoint.psm1
# Refactor Checkpoint System
# Manages safe rollback points during the ncurses migration

function New-RefactorCheckpoint {
    param([string]$Name, [string]$Description)
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $checkpointDir = ".\refactor_checkpoints\checkpoint_${timestamp}_${Name}"
    
    Write-Host "Creating checkpoint: $Name" -ForegroundColor Cyan
    
    # Create checkpoint directory
    New-Item -ItemType Directory -Path $checkpointDir -Force | Out-Null
    
    # Save current state of all tracked files
    $manifest = Get-Content -Path ".\refactor-manifest.json" | ConvertFrom-Json
    
    foreach ($category in $manifest.refactor.components.PSObject.Properties) {
        foreach ($component in $category.Value) {
            if (Test-Path $component.file) {
                $destPath = Join-Path $checkpointDir $component.file
                $destDir = Split-Path $destPath -Parent
                New-Item -ItemType Directory -Path $destDir -Force | Out-Null
                Copy-Item -Path $component.file -Destination $destPath -Force
            }
        }
    }
    
    # Save checkpoint metadata
    @{
        Name = $Name
        Description = $Description
        Timestamp = $timestamp
        Files = $manifest.refactor.components
    } | ConvertTo-Json -Depth 10 | Set-Content -Path "$checkpointDir\checkpoint.json"
    
    # Update manifest
    $manifest.refactor.lastCheckpoint = $checkpointDir
    $manifest | ConvertTo-Json -Depth 10 | Set-Content -Path ".\refactor-manifest.json"
    
    Write-Host "Checkpoint created: $checkpointDir" -ForegroundColor Green
}

function Restore-RefactorCheckpoint {
    param([string]$CheckpointPath)
    
    if (-not (Test-Path "$CheckpointPath\checkpoint.json")) {
        throw "Invalid checkpoint: $CheckpointPath"
    }
    
    Write-Host "Restoring from checkpoint: $CheckpointPath" -ForegroundColor Yellow
    
    $checkpoint = Get-Content "$CheckpointPath\checkpoint.json" | ConvertFrom-Json
    
    foreach ($category in $checkpoint.Files.PSObject.Properties) {
        foreach ($component in $category.Value) {
            $sourcePath = Join-Path $CheckpointPath $component.file
            if (Test-Path $sourcePath) {
                Copy-Item -Path $sourcePath -Destination $component.file -Force
                Write-Host "  Restored: $($component.file)" -ForegroundColor Gray
            }
        }
    }
    
    Write-Host "Checkpoint restored successfully" -ForegroundColor Green
}

function Get-RefactorCheckpoints {
    Get-ChildItem -Path ".\refactor_checkpoints" -Directory | 
        Where-Object { Test-Path "$($_.FullName)\checkpoint.json" } |
        ForEach-Object {
            $meta = Get-Content "$($_.FullName)\checkpoint.json" | ConvertFrom-Json
            [PSCustomObject]@{
                Path = $_.FullName
                Name = $meta.Name
                Description = $meta.Description
                Timestamp = $meta.Timestamp
            }
        } | Sort-Object Timestamp -Descending
}

Export-ModuleMember -Function New-RefactorCheckpoint, Restore-RefactorCheckpoint, Get-RefactorCheckpoints


####\tools\refactor-errors.psm1
# Refactor Error Tracking System
# Captures and categorizes errors during the migration process

$script:ErrorLog = @{
    Errors = @()
    CurrentPhase = $null
    CurrentFile = $null
}

function Start-RefactorPhase {
    param([string]$PhaseName)
    
    $script:ErrorLog.CurrentPhase = $PhaseName
    Write-Host "`n=== Starting Phase: $PhaseName ===" -ForegroundColor Cyan
    
    # Update manifest
    $manifest = Get-Content -Path ".\refactor-manifest.json" | ConvertFrom-Json
    $manifest.refactor.currentPhase = $PhaseName
    $manifest | ConvertTo-Json -Depth 10 | Set-Content -Path ".\refactor-manifest.json"
}

function Set-RefactorContext {
    param([string]$FileName)
    
    $script:ErrorLog.CurrentFile = $FileName
    Write-Host "Working on: $FileName" -ForegroundColor Gray
}

function Add-RefactorError {
    param(
        [string]$ErrorType,
        [string]$Message,
        [object]$Exception,
        [string]$Resolution = $null
    )
    
    $errorEntry = @{
        Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        Phase = $script:ErrorLog.CurrentPhase
        File = $script:ErrorLog.CurrentFile
        Type = $ErrorType
        Message = $Message
        Exception = if ($Exception) { $Exception.ToString() } else { $null }
        Resolution = $Resolution
        Resolved = $false
    }
    
    $script:ErrorLog.Errors += $errorEntry
    
    # Save to manifest
    $manifest = Get-Content -Path ".\refactor-manifest.json" | ConvertFrom-Json
    $manifest.refactor.errors += $errorEntry
    $manifest | ConvertTo-Json -Depth 10 | Set-Content -Path ".\refactor-manifest.json"
    
    Write-Host "ERROR: $Message" -ForegroundColor Red
    if ($Resolution) {
        Write-Host "RESOLUTION: $Resolution" -ForegroundColor Yellow
    }
}

function Get-RefactorErrors {
    param(
        [string]$Phase = $null,
        [string]$File = $null,
        [switch]$Unresolved
    )
    
    $manifest = Get-Content -Path ".\refactor-manifest.json" | ConvertFrom-Json
    $errors = $manifest.refactor.errors
    
    if ($Phase) {
        $errors = $errors | Where-Object { $_.Phase -eq $Phase }
    }
    
    if ($File) {
        $errors = $errors | Where-Object { $_.File -eq $File }
    }
    
    if ($Unresolved) {
        $errors = $errors | Where-Object { -not $_.Resolved }
    }
    
    return $errors
}

function Resolve-RefactorError {
    param(
        [int]$ErrorIndex,
        [string]$Resolution
    )
    
    $manifest = Get-Content -Path ".\refactor-manifest.json" | ConvertFrom-Json
    
    if ($ErrorIndex -lt $manifest.refactor.errors.Count) {
        $manifest.refactor.errors[$ErrorIndex].Resolution = $Resolution
        $manifest.refactor.errors[$ErrorIndex].Resolved = $true
        $manifest | ConvertTo-Json -Depth 10 | Set-Content -Path ".\refactor-manifest.json"
        
        Write-Host "Error #$ErrorIndex resolved" -ForegroundColor Green
    }
}

function Show-RefactorStatus {
    $manifest = Get-Content -Path ".\refactor-manifest.json" | ConvertFrom-Json
    
    Write-Host "`n=== REFACTOR STATUS ===" -ForegroundColor Cyan
    Write-Host "Current Phase: $($manifest.refactor.currentPhase)" -ForegroundColor White
    Write-Host "Last Checkpoint: $($manifest.refactor.lastCheckpoint)" -ForegroundColor White
    
    # Component status
    $total = 0
    $completed = 0
    
    foreach ($category in $manifest.refactor.components.PSObject.Properties) {
        foreach ($component in $category.Value) {
            $total++
            if ($component.status -eq "completed") { $completed++ }
        }
    }
    
    Write-Host "`nProgress: $completed/$total components completed" -ForegroundColor $(if ($completed -eq $total) { "Green" } else { "Yellow" })
    
    # Error summary
    $unresolvedErrors = @($manifest.refactor.errors | Where-Object { -not $_.Resolved }).Count
    if ($unresolvedErrors -gt 0) {
        Write-Host "Unresolved Errors: $unresolvedErrors" -ForegroundColor Red
    }
    
    # Performance comparison
    if ($manifest.refactor.benchmarks.baseline -and $manifest.refactor.benchmarks.current) {
        $improvement = [Math]::Round((($manifest.refactor.benchmarks.baseline - $manifest.refactor.benchmarks.current) / $manifest.refactor.benchmarks.baseline) * 100, 2)
        Write-Host "`nPerformance: $($improvement)% improvement" -ForegroundColor $(if ($improvement -gt 0) { "Green" } else { "Red" })
    }
}

Export-ModuleMember -Function Start-RefactorPhase, Set-RefactorContext, Add-RefactorError, Get-RefactorErrors, Resolve-RefactorError, Show-RefactorStatus


####\tools\tui-validation.psm1
# TUI Component Validation Framework
# Provides visual snapshot testing and performance benchmarking

using namespace System.Management.Automation
using namespace System.Diagnostics

function Test-TuiComponent {
    param(
        [string]$ComponentFile,
        [string]$ComponentClass,
        [scriptblock]$TestSetup,
        [scriptblock]$TestScenario
    )
    
    $result = @{
        Component = "$ComponentFile::$ComponentClass"
        Passed = $false
        Errors = @()
        Performance = @{}
        Snapshot = $null
    }
    
    try {
        # Load component
        Import-Module $ComponentFile -Force
        
        # Create test buffer
        $testWidth = 80
        $testHeight = 24
        $testBuffer = New-Object 'TuiCell[,]' $testHeight, $testWidth
        
        # Initialize with clear cells
        $clearCell = [TuiCell]::new()
        for ($y = 0; $y -lt $testHeight; $y++) {
            for ($x = 0; $x -lt $testWidth; $x++) {
                $testBuffer[$y, $x] = $clearCell
            }
        }
        
        # Mock the global Write-Buffer functions to write to our test buffer
        $global:TestBuffer = $testBuffer
        $global:TestBufferWidth = $testWidth
        $global:TestBufferHeight = $testHeight
        
        # Run test setup
        if ($TestSetup) {
            & $TestSetup
        }
        
        # Measure performance
        $stopwatch = [Stopwatch]::StartNew()
        
        # Run test scenario
        & $TestScenario
        
        $stopwatch.Stop()
        $result.Performance.RenderTimeMs = $stopwatch.ElapsedMilliseconds
        
        # Capture visual snapshot
        $snapshot = ""
        for ($y = 0; $y -lt $testHeight; $y++) {
            for ($x = 0; $x -lt $testWidth; $x++) {
                $snapshot += $testBuffer[$y, $x].Char
            }
            $snapshot += "`n"
        }
        $result.Snapshot = $snapshot
        
        $result.Passed = $true
    }
    catch {
        $result.Errors += $_.Exception.Message
    }
    
    return $result
}

function Compare-TuiSnapshots {
    param(
        [string]$Before,
        [string]$After
    )
    
    if ($Before -eq $After) {
        return @{ Identical = $true; Differences = @() }
    }
    
    $differences = @()
    $beforeLines = $Before -split "`n"
    $afterLines = $After -split "`n"
    
    for ($i = 0; $i -lt [Math]::Max($beforeLines.Count, $afterLines.Count); $i++) {
        if ($i -lt $beforeLines.Count -and $i -lt $afterLines.Count) {
            if ($beforeLines[$i] -ne $afterLines[$i]) {
                $differences += "Line $i differs"
            }
        }
        else {
            $differences += "Line count mismatch at line $i"
        }
    }
    
    return @{ Identical = $false; Differences = $differences }
}

function Measure-TuiPerformance {
    param(
        [scriptblock]$Scenario,
        [int]$Iterations = 100
    )
    
    $measurements = @()
    
    for ($i = 0; $i -lt $Iterations; $i++) {
        $stopwatch = [Stopwatch]::StartNew()
        & $Scenario
        $stopwatch.Stop()
        $measurements += $stopwatch.ElapsedMilliseconds
    }
    
    $sorted = $measurements | Sort-Object
    
    return @{
        Min = $sorted[0]
        Max = $sorted[-1]
        Average = ($measurements | Measure-Object -Average).Average
        Median = $sorted[[Math]::Floor($sorted.Count / 2)]
        P95 = $sorted[[Math]::Floor($sorted.Count * 0.95)]
    }
}

function Save-TuiTestResults {
    param(
        [object]$Results,
        [string]$Phase
    )
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $resultsPath = ".\test_results\phase_${Phase}_${timestamp}.json"
    
    New-Item -ItemType Directory -Path ".\test_results" -Force | Out-Null
    
    $Results | ConvertTo-Json -Depth 10 | Set-Content -Path $resultsPath
    
    Write-Host "Test results saved: $resultsPath" -ForegroundColor Green
    
    # Update manifest with test results
    $manifest = Get-Content -Path ".\refactor-manifest.json" | ConvertFrom-Json
    
    foreach ($result in $Results) {
        # Find component in manifest and update test status
        foreach ($category in $manifest.refactor.components.PSObject.Properties) {
            foreach ($component in $category.Value) {
                if ("$($component.file)::$($component.class)" -eq $result.Component) {
                    $component.tests += @{
                        Phase = $Phase
                        Timestamp = $timestamp
                        Passed = $result.Passed
                        Performance = $result.Performance
                    }
                }
            }
        }
    }
    
    $manifest | ConvertTo-Json -Depth 10 | Set-Content -Path ".\refactor-manifest.json"
}

Export-ModuleMember -Function Test-TuiComponent, Compare-TuiSnapshots, Measure-TuiPerformance, Save-TuiTestResults


####\_CLASSY-MAIN.ps1
# ==============================================================================
# PMC Terminal v5 "Helios" - Modern PowerShell 7 Main Entry Point
# ==============================================================================

# --- Declarative Module Loading ---
# PowerShell 7+ loads all necessary modules and their classes/functions here.
# Order is important: dependencies must be loaded before dependents.

# Core Services (no dependencies)
using module '.\modules\exceptions.psm1'
using module '.\modules\logger.psm1'
using module '.\modules\event-system.psm1'
using module '.\modules\theme-manager.psm1'

# Base Classes
using module '.\modules\models.psm1'
using module '.\components\ui-classes.psm1'

# Components (depend on base classes)
using module '.\layout\panels-class.psm1'
using module '.\components\navigation-class.psm1'
using module '.\components\advanced-data-components.psm1'
using module '.\components\advanced-input-components.psm1'
using module '.\components\tui-components.psm1'

# Framework & Services (depend on core services and models)
using module '.\modules\data-manager.psm1'
using module '.\services\keybinding-service.psm1'
using module '.\services\navigation-service-class.psm1'
using module '.\modules\dialog-system-class.psm1'
using module '.\modules\tui-framework.psm1'

# Screens (depend on services and components) - LOAD BEFORE TUI ENGINE
using module '.\screens\dashboard\dashboard-screen.psm1'
using module '.\screens\task-list-screen.psm1'

# Engine (loaded last, depends on many utilities)
using module '.\modules\tui-engine.psm1'

# --- Script Configuration ---
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# --- Main Application Logic ---
function Start-PMCTerminal {
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "Main" -Context "Main startup sequence" -ScriptBlock {
        # --- 1. Initialize Core Systems ---
        Write-Host "Initializing core systems..." -ForegroundColor Cyan
        Initialize-Logger
        Write-Log -Level Info -Message "PMC Terminal v5 'Helios' startup initiated."
        
        Initialize-EventSystem
        Initialize-ThemeManager
        Initialize-DialogSystem
        
        # --- 2. Initialize and Assemble Services ---
        Write-Host "Initializing services..." -ForegroundColor Cyan
        $services = @{
            DataManager = Initialize-DataManager
            Keybindings = New-KeybindingService  # AI: Using factory function for better compatibility
        }
        $services.Navigation = Initialize-NavigationService -Services $services  # AI: Using factory function
        
        # --- 3. CRITICAL FIX - Register Screen Classes ---
        Write-Host "Registering screen classes..." -ForegroundColor Cyan
        try {
            $services.Navigation.RegisterScreenClass("DashboardScreen", [DashboardScreen])
            Write-Host "✓ DashboardScreen registered" -ForegroundColor Green
        }
        catch {
            Write-Host "✗ Failed to register DashboardScreen: $_" -ForegroundColor Red
            throw
        }
        
        try {
            $services.Navigation.RegisterScreenClass("TaskListScreen", [TaskListScreen])
            Write-Host "✓ TaskListScreen registered" -ForegroundColor Green
        }
        catch {
            Write-Host "⚠ TaskListScreen not available: $_" -ForegroundColor Yellow
        }
        
        # Debug output
        $services.Navigation.ListRegisteredScreens()
        $services.Navigation.ListAvailableRoutes()
        
        $global:Services = $services
        Write-Log -Level Info -Message "All services initialized and assembled."
        
        # --- 4. Initialize TUI Engine and Navigate ---
        Write-Host "Starting TUI Engine..." -ForegroundColor Green
        Clear-Host
        
        Initialize-TuiEngine
        
        # AI: FIX - Verify TUI state before proceeding
        if (-not $global:TuiState) {
            throw "TUI Engine failed to initialize - global state is null"
        }
        Write-Host "✓ TUI Engine initialized: $($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight)" -ForegroundColor Green
        
        $startPath = if ($args -contains "-start" -and ($args.IndexOf("-start") + 1) -lt $args.Count) {
            $args[$args.IndexOf("-start") + 1]
        } else {
            "/dashboard"
        }
        
        if (-not $services.Navigation.IsValidRoute($startPath)) {
            Write-Log -Level Warning -Message "Startup path '$startPath' is not valid. Defaulting to /dashboard."
            $startPath = "/dashboard"
        }
        
        Write-Host "Navigating to: $startPath" -ForegroundColor Cyan
        $services.Navigation.GoTo($startPath, @{})
        
        # AI: FIX - Verify screen was created and pushed
        if (-not $global:TuiState.CurrentScreen) {
            throw "Failed to navigate to $startPath - no current screen set"
        }
        Write-Host "✓ Successfully navigated to: $startPath" -ForegroundColor Green
        Write-Host "✓ Current screen: $($global:TuiState.CurrentScreen.Name)" -ForegroundColor Green
        
        # --- 5. Start the Main Loop ---
        Write-Host "Starting main TUI loop... (Press ESC to exit)" -ForegroundColor Yellow
        Start-TuiLoop
        
        Write-Log -Level Info -Message "PMC Terminal exited gracefully."
    }
}

# --- Main Execution Block ---
try {
    Start-PMCTerminal
}
catch {
    $errorMessage = "A fatal, unhandled exception occurred: $($_.Exception.Message)"
    Write-Host "`n$errorMessage" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Fatal -Message $errorMessage -Data @{ Exception = $_.Exception; Stack = $_.ScriptStackTrace } -Force
    }
    
    Read-Host "Press Enter to exit"
    exit 1
}
finally {
    if ($global:Services -and $global:Services.DataManager) {
        try {
            $global:Services.DataManager.SaveData()
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Info -Message "Data saved on exit." -Force
            }
        }
        catch {
            Write-Warning "Failed to save data on exit: $_"
        }
    }
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Info -Message "Application shutdown complete." -Force
    }
}


####\Clear-ModuleCache.ps1
# Clear PowerShell Module Cache for PMC Terminal
Write-Host "Clearing PowerShell module cache..." -ForegroundColor Yellow

# Get all loaded modules from our application
$modulesToRemove = Get-Module | Where-Object { 
    $_.Path -like "*\_CLASSY*" -or 
    $_.Name -in @('models', 'logger', 'exceptions', 'event-system', 'data-manager', 
                   'theme-manager', 'tui-framework', 'tui-engine-v2', 'dialog-system',
                   'keybinding-service', 'navigation-service-class', 'panels-class',
                   'focus-manager', 'advanced-input-components', 'advanced-data-components',
                   'ui-classes', 'panel-classes', 'table-class', 'navigation-class')
}

foreach ($module in $modulesToRemove) {
    Write-Host "Removing module: $($module.Name)" -ForegroundColor Cyan
    Remove-Module $module -Force -ErrorAction SilentlyContinue
}

# Clear any compiled assemblies (for our custom exceptions)
if ('Helios.HeliosException' -as [type]) {
    Write-Host "Note: Custom exception types are loaded and cannot be unloaded in this session." -ForegroundColor Yellow
    Write-Host "For a complete refresh, please start a new PowerShell session." -ForegroundColor Yellow
}

Write-Host "`nModule cache cleared. You can now run the application again." -ForegroundColor Green
Write-Host "Run: pwsh -file _CLASSY-MAIN.ps1" -ForegroundColor White



####\filecopy.ps1
# This script finds all .ps1 and .psm1 files in the current directory and its subdirectories.
# For each found file, it creates a copy with a .txt extension in the same location.
# Finally, it concatenates the content of all original .ps1 and .psm1 files into a single file named 'all.txt'
# in the current directory. Each appended file is preceded by a header indicating its relative path.

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the current working directory, ensuring no trailing backslash for consistent path manipulation
$currentDirectory = (Get-Location).Path.TrimEnd('\')

# Define the name of the output concatenated file
$outputFileName = "all.txt"

Write-Host "Starting script operations in: $currentDirectory"

# --- Step 1: Clear the existing output file if it exists ---
try {
    if (Test-Path $outputFileName) {
        Remove-Item $outputFileName -Force -ErrorAction Stop
        Write-Host "Cleared existing '$outputFileName'."
    }
} catch {
    Write-Warning "Failed to clear '$outputFileName': $($_.Exception.Message)"
    # Continue, as this might not be a fatal error for the rest of the script
}

# --- Step 2: Find all .ps1 and .psm1 files recursively ---
try {
    $scriptFiles = Get-ChildItem -Path $currentDirectory -Recurse -Include *.ps1, *.psm1 -File -ErrorAction Stop
    Write-Host "Found $($scriptFiles.Count) PowerShell script files."
} catch {
    Write-Error "Failed to enumerate script files: $($_.Exception.Message)"
    exit 1 # Exit if we can't even find the files
}

# --- Step 3: Process each file (copy and concatenate) ---
if ($scriptFiles.Count -eq 0) {
    Write-Warning "No .ps1 or .psm1 files found to process."
} else {
    foreach ($file in $scriptFiles) {
        # Create a copy with .txt ending in the same folder
        $txtCopyPath = Join-Path -Path $file.DirectoryName -ChildPath ($file.BaseName + ".txt")
        try {
            Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force -ErrorAction Stop
            Write-Host "  Copied: $($file.Name) to $($txtCopyPath)"
        } catch {
            Write-Warning "  Failed to copy $($file.FullName) to $($txtCopyPath): $($_.Exception.Message)"
        }

        # Prepare header for all.txt using relative path
        # Remove the base directory part from the full path to get the relative path
        $relativePath = $file.FullName.Substring($currentDirectory.Length)
        # Ensure the relative path starts with a single backslash
        if (-not $relativePath.StartsWith('\')) {
            $relativePath = '\' + $relativePath
        }

        $header = "####$relativePath"
        
        # Append the header and file content to all.txt
        try {
            Add-Content -Path $outputFileName -Value $header -Encoding UTF8 -ErrorAction Stop
            # Read the entire file content as a single string
            $fileContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value $fileContent -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value "`n" -Encoding UTF8 -ErrorAction Stop # Add an extra newline for separation
            Write-Host "  Appended: $($file.Name) to $($outputFileName)"
        } catch {
            Write-Warning "  Failed to append $($file.FullName) to $($outputFileName): $($_.Exception.Message)"
        }
    }
}

Write-Host "All operations complete. Concatenated content saved to '$outputFileName'."


####\fix-component-functions.ps1
# Component Function Fix Script
# This script removes the global: prefix from function definitions

$componentPaths = @(
    "components\advanced-data-components.psm1",
    "components\advanced-input-components.psm1", 
    "components\tui-components.psm1",
    "layout\panels.psm1",
    "modules\dialog-system.psm1",
    "modules\event-system.psm1",
    "modules\state-manager.psm1",
    "modules\text-resources.psm1",
    "modules\theme-manager.psm1",
    "services\keybindings.psm1",
    "services\navigation.psm1",
    "services\task-services.psm1",
    "utilities\focus-manager.psm1",
    "utilities\layout-manager.psm1",
    "utilities\positioning-helper.psm1"
)

$baseDir = "C:\Users\jhnhe\Documents\GitHub\_XP\"
$totalFixed = 0

foreach ($relativePath in $componentPaths) {
    $fullPath = Join-Path $baseDir $relativePath
    
    if (Test-Path $fullPath) {
        Write-Host "`nProcessing: $relativePath" -ForegroundColor Cyan
        
        $content = Get-Content $fullPath -Raw
        $backupPath = "$fullPath.backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
        $content | Set-Content $backupPath
        
        # Replace function global:FunctionName with function FunctionName
        $pattern = 'function\s+global:(\w+)'
        $replacement = 'function $1'
        
        $matches = [regex]::Matches($content, $pattern)
        $count = $matches.Count
        
        if ($count -gt 0) {
            $updatedContent = $content -replace $pattern, $replacement
            $updatedContent | Set-Content $fullPath
            
            Write-Host "  Fixed $count function definitions" -ForegroundColor Green
            foreach ($match in $matches) {
                Write-Host "    - $($match.Groups[1].Value)" -ForegroundColor DarkGray
            }
            $totalFixed += $count
        } else {
            Write-Host "  No global: prefixes found" -ForegroundColor Yellow
        }
    } else {
        Write-Host "`nWARNING: File not found: $fullPath" -ForegroundColor Red
    }
}

Write-Host "`n========================================" -ForegroundColor Cyan
Write-Host "Total functions fixed: $totalFixed" -ForegroundColor Green
Write-Host "All component files have been updated!" -ForegroundColor Green



####\fix-engine-scope.ps1
# Engine Scope Fix Script
# This script updates the TUI engine to use global state

$enginePath = "C:\Users\jhnhe\Documents\GitHub\_XP\modules\tui-engine-v2.psm1"

Write-Host "Reading engine file..." -ForegroundColor Cyan
$content = Get-Content $enginePath -Raw

Write-Host "Creating backup..." -ForegroundColor Cyan
$backupPath = "$enginePath.backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
$content | Set-Content $backupPath

Write-Host "Replacing script:TuiState with global:TuiState..." -ForegroundColor Cyan
$updatedContent = $content -replace '\$script:TuiState', '$global:TuiState'

# Count replacements
$originalCount = ([regex]::Matches($content, '\$script:TuiState')).Count
$newCount = ([regex]::Matches($updatedContent, '\$global:TuiState')).Count

Write-Host "Replaced $originalCount instances of `$script:TuiState with `$global:TuiState" -ForegroundColor Green

Write-Host "Writing updated file..." -ForegroundColor Cyan
$updatedContent | Set-Content $enginePath

Write-Host "Engine update complete!" -ForegroundColor Green
Write-Host "Backup saved to: $backupPath" -ForegroundColor Yellow



####\run-main.ps1
cd "C:\Users\jhnhe\Documents\GitHub\_XP"
.\_CLASSY-MAIN.ps1


####\Start-TuiMigration.ps1
# Master Refactor Orchestrator
# Run this to execute the ncurses-inspired TUI migration

using module .\tools\refactor-checkpoint.psm1
using module .\tools\tui-validation.psm1 
using module .\tools\refactor-errors.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Start-TuiMigration {
    Write-Host @"
╔══════════════════════════════════════════════════════════════════╗
║           PMC Terminal v5 - NCurses Migration Tool               ║
║                                                                  ║
║  This tool will guide you through the migration to a            ║
║  composited, layered window architecture.                        ║
╚══════════════════════════════════════════════════════════════════╝
"@ -ForegroundColor Cyan

    # Check for existing migration
    if (Test-Path ".\refactor-manifest.json") {
        $manifest = Get-Content ".\refactor-manifest.json" | ConvertFrom-Json
        Write-Host "`nExisting migration found!" -ForegroundColor Yellow
        Write-Host "Current Phase: $($manifest.refactor.currentPhase)" -ForegroundColor White
        
        $resume = Read-Host "Resume existing migration? (Y/N)"
        if ($resume -ne 'Y') {
            Write-Host "Creating backup of existing migration..." -ForegroundColor Gray
            $backupName = "backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
            Copy-Item ".\refactor-manifest.json" ".\refactor-manifest.$backupName.json"
            Remove-Item ".\refactor-manifest.json"
        }
    }
    
    Show-RefactorStatus
}

function Invoke-RefactorPhase {
    param([string]$PhaseName)
    
    Start-RefactorPhase -PhaseName $PhaseName
    
    try {
        switch ($PhaseName) {
            "pre-a" { Invoke-PrePhaseA }
            "phase-0" { Invoke-Phase0 }
            "phase-1" { Invoke-Phase1 }
            "phase-2" { Invoke-Phase2 }
            "validation" { Invoke-ValidationPhase }
            default { throw "Unknown phase: $PhaseName" }
        }
        
        Write-Host "`nPhase $PhaseName completed successfully!" -ForegroundColor Green
    }
    catch {
        Add-RefactorError -ErrorType "PhaseFailed" -Message "Phase $PhaseName failed" -Exception $_
        Write-Host "`nPhase $PhaseName FAILED!" -ForegroundColor Red
        Write-Host "Run 'Get-RefactorErrors -Unresolved' to see details" -ForegroundColor Yellow
        throw
    }
}

function Invoke-PrePhaseA {
    Write-Host "`nPre-Phase A: Setting up safety infrastructure" -ForegroundColor White
    
    # Create initial checkpoint
    New-RefactorCheckpoint -Name "pre-migration" -Description "State before any migration changes"
    
    # Run baseline performance tests
    Write-Host "`nRunning baseline performance tests..." -ForegroundColor Gray
    $baseline = Measure-TuiPerformance -Scenario {
        # Simulate typical render workload
        for ($i = 0; $i -lt 10; $i++) {
            # This would be replaced with actual component render tests
            Start-Sleep -Milliseconds 5
        }
    }
    
    $manifest = Get-Content ".\refactor-manifest.json" | ConvertFrom-Json
    $manifest.refactor.benchmarks.baseline = $baseline.Average
    $manifest | ConvertTo-Json -Depth 10 | Set-Content ".\refactor-manifest.json"
    
    Write-Host "Baseline performance: $($baseline.Average)ms average" -ForegroundColor White
}

function Invoke-Phase0 {
    Write-Host "`nPhase 0: Core Engine and Contract Stabilization" -ForegroundColor White
    
    # Create checkpoint before phase
    New-RefactorCheckpoint -Name "phase-0-start" -Description "Before core engine changes"
    
    Set-RefactorContext -FileName "modules/dialog-system.psm1"
    if (Test-Path "modules\dialog-system.psm1") {
        Write-Host "Removing legacy dialog system..." -ForegroundColor Gray
        Remove-Item "modules\dialog-system.psm1" -Force
    }
    
    Set-RefactorContext -FileName "modules/tui-engine.psm1"
    # Here you would apply the actual engine modifications
    # For now, we'll simulate the update
    
    # Mark components as updated in manifest
    Update-ComponentStatus -File "modules/tui-engine.psm1" -Status "completed"
}

function Update-ComponentStatus {
    param(
        [string]$File,
        [string]$Status
    )
    
    $manifest = Get-Content ".\refactor-manifest.json" | ConvertFrom-Json
    
    foreach ($category in $manifest.refactor.components.PSObject.Properties) {
        foreach ($component in $category.Value) {
            if ($component.file -eq $File) {
                $component.status = $Status
                break
            }
        }
    }
    
    $manifest | ConvertTo-Json -Depth 10 | Set-Content ".\refactor-manifest.json"
}

# Interactive Menu
function Show-MigrationMenu {
    while ($true) {
        Clear-Host
        Write-Host @"
╔══════════════════════════════════════════════════════════════════╗
║                  NCurses Migration Control Panel                 ║
╚══════════════════════════════════════════════════════════════════╝
"@ -ForegroundColor Cyan
        
        Show-RefactorStatus
        
        Write-Host "`n[1] Execute Next Phase" -ForegroundColor White
        Write-Host "[2] Run Component Tests" -ForegroundColor White
        Write-Host "[3] Create Checkpoint" -ForegroundColor White
        Write-Host "[4] Restore Checkpoint" -ForegroundColor White
        Write-Host "[5] View Errors" -ForegroundColor White
        Write-Host "[6] Generate Report" -ForegroundColor White
        Write-Host "[Q] Quit" -ForegroundColor White
        
        $choice = Read-Host "`nSelect option"
        
        switch ($choice) {
            "1" {
                $manifest = Get-Content ".\refactor-manifest.json" | ConvertFrom-Json
                $nextPhase = Get-NextPhase -CurrentPhase $manifest.refactor.currentPhase
                if ($nextPhase) {
                    Invoke-RefactorPhase -PhaseName $nextPhase
                } else {
                    Write-Host "All phases completed!" -ForegroundColor Green
                }
                Read-Host "Press Enter to continue"
            }
            "2" {
                Write-Host "Running component tests..." -ForegroundColor Yellow
                # Run validation tests
                Read-Host "Press Enter to continue"
            }
            "3" {
                $name = Read-Host "Checkpoint name"
                $desc = Read-Host "Description"
                New-RefactorCheckpoint -Name $name -Description $desc
                Read-Host "Press Enter to continue"
            }
            "4" {
                $checkpoints = Get-RefactorCheckpoints
                if ($checkpoints) {
                    for ($i = 0; $i -lt $checkpoints.Count; $i++) {
                        Write-Host "[$i] $($checkpoints[$i].Name) - $($checkpoints[$i].Timestamp)"
                    }
                    $selection = Read-Host "Select checkpoint"
                    if ($selection -match '^\d+$' -and [int]$selection -lt $checkpoints.Count) {
                        Restore-RefactorCheckpoint -CheckpointPath $checkpoints[[int]$selection].Path
                    }
                }
                Read-Host "Press Enter to continue"
            }
            "5" {
                Get-RefactorErrors -Unresolved | Format-Table -AutoSize
                Read-Host "Press Enter to continue"
            }
            "6" {
                Generate-MigrationReport
                Read-Host "Press Enter to continue"
            }
            "Q" { return }
        }
    }
}

function Get-NextPhase {
    param([string]$CurrentPhase)
    
    $phases = @("pre-a", "phase-0", "phase-1", "phase-2", "validation")
    $currentIndex = $phases.IndexOf($CurrentPhase)
    
    if ($currentIndex -ge 0 -and $currentIndex -lt $phases.Count - 1) {
        return $phases[$currentIndex + 1]
    }
    
    return $null
}

function Generate-MigrationReport {
    $manifest = Get-Content ".\refactor-manifest.json" | ConvertFrom-Json
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    
    $report = @"
# NCurses Migration Report
Generated: $timestamp

## Status
- Current Phase: $($manifest.refactor.currentPhase)
- Start Date: $($manifest.refactor.startDate)

## Component Progress
"@

    foreach ($category in $manifest.refactor.components.PSObject.Properties) {
        $report += "`n### $($category.Name)`n"
        foreach ($component in $category.Value) {
            $status = if ($component.status -eq "completed") { "✓" } else { "○" }
            $report += "- [$status] $($component.file)`n"
        }
    }
    
    $report += "`n## Errors`n"
    $errors = $manifest.refactor.errors
    if ($errors.Count -eq 0) {
        $report += "No errors recorded.`n"
    } else {
        foreach ($error in $errors) {
            $resolved = if ($error.Resolved) { "RESOLVED" } else { "OPEN" }
            $report += "- [$resolved] $($error.Message) ($($error.Phase))`n"
        }
    }
    
    $reportPath = ".\migration_report_$(Get-Date -Format 'yyyyMMdd_HHmmss').md"
    $report | Set-Content -Path $reportPath
    Write-Host "Report saved: $reportPath" -ForegroundColor Green
}

# Entry Point
Start-TuiMigration
Show-MigrationMenu


####\Sync-MigrationSystem.ps1
# Sync Migration System with Actual File State
# Fixes outdated checkpoint and manifest data

param(
    [switch]$WhatIf
)

Write-Host "🔄 Syncing Migration System with Actual File State..." -ForegroundColor Cyan

# Load migration tools
try {
    Import-Module ".\tools\refactor-checkpoint.psm1" -Force
    Import-Module ".\tools\refactor-errors.psm1" -Force
    Import-Module ".\tools\tui-validation.psm1" -Force
    Write-Host "✅ Migration tools loaded" -ForegroundColor Green
} catch {
    Write-Host "❌ Failed to load migration tools: $_" -ForegroundColor Red
    exit 1
}

# Create updated manifest reflecting actual completion state
$updatedManifest = @{
    refactor = @{
        name = "ncurses-compositor-migration"
        startDate = "2025-06-29"
        currentPhase = "phase-1-complete"
        lastCheckpoint = ".\refactor_checkpoints\checkpoint_$(Get-Date -Format 'yyyyMMdd_HHmmss')_phase-1-verified"
        components = @{
            core = @(
                @{
                    file = "components/tui-primitives.psm1"
                    status = "completed"
                    dependencies = @()
                    tests = @()
                    classes = @("TuiCell", "TuiBuffer", "UIElement", "TuiAnsiHelper")
                    completedDate = "2025-06-29T00:00:00Z"
                    notes = "Foundation classes - TuiCell compositor system operational"
                    verifiedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                },
                @{
                    file = "modules/tui-engine.psm1"
                    status = "completed"
                    dependencies = @("components/tui-primitives.psm1")
                    tests = @()
                    completedDate = "2025-06-29T00:00:00Z"
                    notes = "Enhanced with NCurses compositor support, buffer-based rendering"
                    verifiedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                }
            )
            panels = @(
                @{
                    file = "layout/panels-class.psm1"
                    status = "completed"
                    dependencies = @("components/tui-primitives.psm1")
                    tests = @()
                    classes = @("Panel", "ScrollablePanel", "GroupPanel")
                    completedDate = "2025-06-29T00:00:00Z"
                    notes = "Panel foundation classes with NCurses architecture - OnRender() methods implemented"
                    verifiedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                }
            )
            components = @(
                @{
                    file = "components/navigation-class.psm1"
                    class = "NavigationMenu"
                    status = "completed"
                    dependencies = @("layout/panels-class.psm1")
                    tests = @()
                    phase = "phase-1"
                    completedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                    notes = "_RenderContent() void method implemented, Write-BufferString rendering, ANSI helpers removed"
                    verifiedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                },
                @{
                    file = "components/advanced-data-components.psm1"
                    class = "Table"
                    status = "completed"
                    dependencies = @("layout/panels-class.psm1")
                    tests = @()
                    phase = "phase-1"
                    completedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                    notes = "_RenderContent() void method implemented, buffer-based rendering"
                    verifiedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                },
                @{
                    file = "components/advanced-data-components.psm1"
                    class = "DataTableComponent"
                    status = "completed"
                    dependencies = @("layout/panels-class.psm1")
                    tests = @()
                    phase = "phase-1"
                    completedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                    notes = "_RenderContent() void method implemented, placeholder for complex features"
                    verifiedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                },
                @{
                    file = "components/tui-components.psm1"
                    status = "pending"
                    dependencies = @("layout/panels-class.psm1")
                    tests = @()
                    phase = "phase-2"
                    classes = @("Button", "TextBox", "Label", "CheckBox", "RadioButton")
                    notes = "Ready for Phase 2 - functional to class conversion"
                },
                @{
                    file = "components/advanced-input-components.psm1"
                    status = "pending"
                    dependencies = @("layout/panels-class.psm1")
                    tests = @()
                    phase = "phase-2"
                    classes = @("MultilineTextBox", "NumericInput", "DateInput", "ComboBox")
                    notes = "Ready for Phase 2 - functional to class conversion"
                },
                @{
                    file = "modules/dialog-system-class.psm1"
                    status = "pending"
                    dependencies = @("layout/panels-class.psm1")
                    tests = @()
                    phase = "phase-2"
                    classes = @("Dialog", "MessageDialog", "InputDialog", "ConfirmDialog")
                    notes = "Ready for Phase 2 - dialog system integration"
                }
            )
            screens = @(
                @{
                    file = "screens/dashboard-screen.psm1"
                    status = "pending"
                    dependencies = @("components/navigation-class.psm1", "components/advanced-data-components.psm1")
                    tests = @()
                    phase = "phase-3"
                    notes = "Ready for Phase 3 - screen integration"
                },
                @{
                    file = "screens/task-list-screen.psm1"
                    status = "pending"
                    dependencies = @("components/advanced-data-components.psm1")
                    tests = @()
                    phase = "phase-3"
                    notes = "Ready for Phase 3 - screen integration"
                }
            )
        }
        phases = @{
            "pre-a" = @{
                name = "NCurses Foundation"
                status = "completed"
                description = "Establish TuiCell, UIElement, and Panel foundation classes"
                completedDate = "2025-06-29T00:00:00Z"
                verifiedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                deliverables = @(
                    "TuiCell class with blending support",
                    "TuiBuffer 2D array management", 
                    "UIElement base class for all components",
                    "Panel base class with layout support",
                    "Enhanced TUI engine with compositor"
                )
            }
            "phase-1" = @{
                name = "Core Components Migration"
                status = "completed"
                description = "Migrate basic UI components to buffer-based rendering"
                dependencies = @("pre-a")
                completedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                verifiedDate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                targets = @(
                    "NavigationMenu - void _RenderContent()",
                    "Table - buffer-based rendering",
                    "DataTableComponent - placeholder implementation",
                    "Panel classes - OnRender() methods"
                )
            }
            "phase-2" = @{
                name = "Advanced Components & Dialogs"
                status = "ready"
                description = "Convert functional components to classes, integrate dialog system"
                dependencies = @("phase-1")
                targets = @(
                    "Button, TextBox, Label components",
                    "Advanced input components",
                    "Dialog system integration"
                )
            }
            "phase-3" = @{
                name = "Screen Integration"
                status = "pending"
                description = "Migrate all screens to new architecture"
                dependencies = @("phase-2")
                targets = @(
                    "Dashboard screen",
                    "Task screens",
                    "All remaining screens"
                )
            }
        }
        errors = @()
        benchmarks = @{
            baseline = $null
            current = $null
        }
        statistics = @{
            totalComponents = 15
            completedComponents = 8
            completionPercentage = 53.3
            lastUpdate = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
        }
    }
}

# Write updated manifest
$manifestPath = ".\refactor-manifest.json"
$backupPath = ".\refactor-manifest.backup_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"

if (-not $WhatIf) {
    # Backup current manifest if it exists
    if (Test-Path $manifestPath) {
        Copy-Item $manifestPath $backupPath
        Write-Host "📋 Backed up current manifest to: $backupPath" -ForegroundColor Yellow
    }
    
    # Write new manifest
    $updatedManifest | ConvertTo-Json -Depth 10 | Set-Content $manifestPath -Encoding UTF8
    Write-Host "✅ Updated manifest written to: $manifestPath" -ForegroundColor Green
} else {
    Write-Host "📋 [WHATIF] Would update manifest: $manifestPath" -ForegroundColor Yellow
}

# Create verified checkpoint
$checkpointName = "phase-1-verified"
$checkpointDesc = "Phase 0 and Phase 1 completed - verified against actual file state"

if (-not $WhatIf) {
    try {
        New-RefactorCheckpoint -Name $checkpointName -Description $checkpointDesc
        Write-Host "✅ Created verified checkpoint: $checkpointName" -ForegroundColor Green
    } catch {
        Write-Host "⚠️  Checkpoint creation failed: $_" -ForegroundColor Yellow
        Write-Host "   Manual checkpoint creation may be required" -ForegroundColor Yellow
    }
} else {
    Write-Host "📁 [WHATIF] Would create checkpoint: $checkpointName" -ForegroundColor Yellow
}

# Clear any stale errors
if (-not $WhatIf) {
    try {
        Clear-RefactorErrors
        Write-Host "🧹 Cleared stale error log" -ForegroundColor Green
    } catch {
        Write-Host "⚠️  Could not clear errors: $_" -ForegroundColor Yellow
    }
} else {
    Write-Host "🧹 [WHATIF] Would clear error log" -ForegroundColor Yellow
}

# Display current status
Write-Host ""
Write-Host "📊 Updated Migration Status:" -ForegroundColor Cyan
Write-Host "  • Phase 0 (Foundation): ✅ COMPLETE" -ForegroundColor Green
Write-Host "  • Phase 1 (Core Components): ✅ COMPLETE" -ForegroundColor Green  
Write-Host "  • Phase 2 (Advanced Components): 🔄 READY" -ForegroundColor Yellow
Write-Host "  • Phase 3 (Screen Integration): ⏳ PENDING" -ForegroundColor Gray
Write-Host ""
Write-Host "📈 Progress: 8/15 components (53.3%) complete" -ForegroundColor Cyan
Write-Host ""

if (-not $WhatIf) {
    Write-Host "🎯 Migration system synchronized!" -ForegroundColor Green
    Write-Host "   Ready to proceed with Phase 2" -ForegroundColor Green
} else {
    Write-Host "💡 Run without -WhatIf to apply changes" -ForegroundColor Yellow
}

Write-Host ""
Write-Host "Next Steps:" -ForegroundColor White
Write-Host "  1. .\Sync-MigrationSystem.ps1" -ForegroundColor Gray
Write-Host "  2. .\Start-TuiMigration.ps1" -ForegroundColor Gray  
Write-Host "  3. Tell Helios: 'Execute Phase 2'" -ForegroundColor Gray



####\test-scope-fix.ps1
# Test TUI Scope Fix
# Verifies that the global scope fix allows proper TUI rendering

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

Write-Host "Testing TUI Scope Fix..." -ForegroundColor Cyan

try {
    # Import modules with global scope
    Write-Host "  1. Loading TUI Engine..." -ForegroundColor Yellow
    Import-Module ".\modules\tui-engine-v2.psm1" -Global -Force
    
    Write-Host "  2. Loading Components..." -ForegroundColor Yellow
    Import-Module ".\components\tui-components.psm1" -Global -Force
    
    Write-Host "  3. Loading Theme Manager..." -ForegroundColor Yellow
    Import-Module ".\modules\theme-manager.psm1" -Global -Force
    
    # Check if global state is accessible
    Write-Host "  4. Initializing TUI Engine..." -ForegroundColor Yellow
    Initialize-TuiEngine -Width 60 -Height 20
    
    # Verify global state exists
    if ($global:TuiState) {
        Write-Host "  ✓ Global TUI state created successfully" -ForegroundColor Green
        Write-Host "    Buffer size: $($global:TuiState.BufferWidth) x $($global:TuiState.BufferHeight)" -ForegroundColor DarkGray
    } else {
        throw "Global TUI state not found"
    }
    
    # Test component creation (this should now work with global state)
    Write-Host "  5. Testing component creation..." -ForegroundColor Yellow
    $testLabel = New-TuiLabel -Props @{
        X = 5
        Y = 5
        Text = "Scope Fix Test"
        Name = "TestLabel"
    }
    
    if ($testLabel) {
        Write-Host "  ✓ Component created successfully" -ForegroundColor Green
    } else {
        throw "Component creation failed"
    }
    
    # Test component rendering (this requires access to global state)
    Write-Host "  6. Testing component rendering..." -ForegroundColor Yellow
    
    # Clear the buffer first
    Clear-BackBuffer
    
    # Try to render the component
    try {
        & $testLabel.Render -self $testLabel
        Write-Host "  ✓ Component rendered without errors" -ForegroundColor Green
    } catch {
        Write-Host "  ✗ Component rendering failed: $_" -ForegroundColor Red
        throw
    }
    
    # Test buffer write functions
    Write-Host "  7. Testing buffer operations..." -ForegroundColor Yellow
    Write-BufferString -X 10 -Y 10 -Text "Buffer Test" -ForegroundColor White
    Write-Host "  ✓ Buffer operations working" -ForegroundColor Green
    
    # Clean up
    Write-Host "  8. Cleaning up..." -ForegroundColor Yellow
    try {
        Cleanup-TuiEngine
    } catch {
        # Cleanup might fail if not fully initialized, that's OK for this test
    }
    
    Write-Host "`n✅ TUI Scope Fix Verification PASSED" -ForegroundColor Green
    Write-Host "   The TUI system can now access global state across modules." -ForegroundColor DarkGreen
    
} catch {
    Write-Host "`n❌ TUI Scope Fix Verification FAILED" -ForegroundColor Red
    Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
    exit 1
}

Write-Host "`nNext steps:" -ForegroundColor Cyan
Write-Host "  • Test with a full TUI application" -ForegroundColor Gray
Write-Host "  • Verify all components can render properly" -ForegroundColor Gray
Write-Host "  • Check input handling works across modules" -ForegroundColor Gray



####\test-tui-render-fixed.ps1
# Fixed TUI Render Test
# This script tests if the TUI can render after scope fixes

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

Set-Location "C:\Users\jhnhe\Documents\GitHub\_XP"

try {
    Write-Host "Loading required modules..." -ForegroundColor Cyan
    
    # Import modules with correct names and proper error handling
    Import-Module ".\modules\exceptions.psm1" -Global -Force
    Import-Module ".\modules\logger.psm1" -Global -Force  
    Import-Module ".\modules\theme-manager.psm1" -Global -Force
    Import-Module ".\modules\event-system.psm1" -Global -Force
    Import-Module ".\modules\tui-engine-v2.psm1" -Global -Force
    Import-Module ".\components\tui-components.psm1" -Global -Force

    Write-Host "Modules loaded successfully!" -ForegroundColor Green

    # Initialize required systems
    Initialize-Logger
    Initialize-EventSystem  
    Initialize-ThemeManager

    Write-Host "Creating test screen..." -ForegroundColor Cyan

    # Create a minimal test screen using correct component factory pattern
    $testScreen = @{
        Name = "TestScreen"
        Components = @{}
        
        Init = {
            param($self, $services)
            Write-Host "Test screen initializing..." -ForegroundColor Green
            
            # Add a simple label to verify rendering
            $label = New-TuiLabel -Props @{
                X = 5
                Y = 5
                Text = "TUI IS RENDERING!"
                ForegroundColor = [ConsoleColor]::Green
                Name = "TestLabel"
            }
            $self.Components["TestLabel"] = $label
            
            # Add a box to make it obvious
            $button = New-TuiButton -Props @{
                X = 5
                Y = 7
                Width = 25
                Height = 3
                Text = "Press ENTER or ESC"
                Name = "TestButton"
                OnClick = { Write-Host "Button clicked!" -ForegroundColor Yellow }
            }
            $self.Components["TestButton"] = $button
            
            # Add visual border
            Write-Host "Components created successfully" -ForegroundColor Green
        }
        
        Render = {
            param($self)
            try {
                # Draw border around the test area
                Write-BufferBox -X 2 -Y 2 -Width 30 -Height 10 -Title "Render Test" -BorderColor ([ConsoleColor]::Cyan)
                
                # Render all components
                foreach ($component in $self.Components.Values) {
                    if ($component.Render) {
                        & $component.Render -self $component
                    }
                }
            }
            catch {
                Write-Log -Level Error -Message "Screen render failed: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            if ($Key.Key -eq [ConsoleKey]::Escape -or $Key.Key -eq [ConsoleKey]::Q) {
                return "Quit"
            }
            return $null
        }
    }

    Write-Host "Initializing TUI Engine..." -ForegroundColor Cyan
    Initialize-TuiEngine
    
    Write-Host "Verifying global state..." -ForegroundColor Cyan
    if ($global:TuiState -eq $null) {
        throw "Global TUI state was not initialized!"
    }
    
    Write-Host "Global TUI state confirmed: Width=$($global:TuiState.BufferWidth), Height=$($global:TuiState.BufferHeight)" -ForegroundColor Green

    Write-Host "Starting render test (Press ESC or Q to quit)..." -ForegroundColor Yellow
    
    # Push the test screen and start the loop
    Push-Screen -Screen $testScreen
    
    # Quick verification that buffer has content
    Clear-BackBuffer
    if ($global:TuiState.CurrentScreen -and $global:TuiState.CurrentScreen.Render) {
        & $global:TuiState.CurrentScreen.Render -self $global:TuiState.CurrentScreen
    }
    
    # Check if anything was written to the buffer
    $hasContent = $false
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            if ($global:TuiState.BackBuffer[$y, $x].Char -ne ' ') {
                $hasContent = $true
                break
            }
        }
        if ($hasContent) { break }
    }
    
    if ($hasContent) {
        Write-Host "`nSUCCESS: Content detected in buffer!" -ForegroundColor Green
        Write-Host "The TUI is now able to render. Starting interactive loop..." -ForegroundColor Green
        Write-Host "Use TAB to focus the button, ENTER to click it, ESC to quit." -ForegroundColor Yellow
        
        # Start the full interactive loop
        Start-TuiLoop
    } else {
        Write-Host "`nFAILED: No content in buffer - rendering is still broken!" -ForegroundColor Red
        Write-Host "Buffer state: Width=$($global:TuiState.BufferWidth), Height=$($global:TuiState.BufferHeight)" -ForegroundColor Yellow
        


####\test-tui-render.ps1
# Minimal TUI Render Test
# This script tests if the TUI can render after scope fixes

Set-Location "C:\Users\jhnhe\Documents\GitHub\_XP"

# Import required modules in correct order
Import-Module ".\modules\exception-system.psm1" -Global
Import-Module ".\modules\logging.psm1" -Global  
Import-Module ".\modules\theme-manager.psm1" -Global
Import-Module ".\modules\event-system.psm1" -Global
Import-Module ".\modules\tui-engine-v2.psm1" -Global
Import-Module ".\components\tui-components.psm1" -Global

Write-Host "Creating test screen..." -ForegroundColor Cyan

# Create a minimal test screen
$testScreen = @{
    Name = "TestScreen"
    Components = @{}
    
    Init = {
        param($self, $services)
        Write-Host "Test screen initializing..." -ForegroundColor Green
        
        # Add a simple label to verify rendering
        $label = New-TuiLabel -X 5 -Y 5 -Text "TUI IS RENDERING!" -ForegroundColor Green
        $self.Components["TestLabel"] = $label
        
        # Add a box to make it obvious
        $box = New-TuiBox -X 2 -Y 2 -Width 30 -Height 10 -Title "Render Test"
        $self.Components["TestBox"] = $box
    }
    
    Render = {
        param($self)
        # Render all components
        foreach ($component in $self.Components.Values) {
            if ($component.Render) {
                & $component.Render -self $component
            }
        }
    }
    
    HandleInput = {
        param($self, $Key)
        if ($Key.Key -eq [ConsoleKey]::Escape -or $Key.Key -eq [ConsoleKey]::Q) {
            return "Quit"
        }
    }
}

try {
    Write-Host "Initializing TUI Engine..." -ForegroundColor Cyan
    Initialize-TuiEngine
    
    Write-Host "Starting render test (Press ESC or Q to quit)..." -ForegroundColor Yellow
    
    # Quick test - just render one frame
    Push-Screen -Screen $testScreen
    Clear-BackBuffer
    
    # Force a render
    if ($global:TuiState.CurrentScreen -and $global:TuiState.CurrentScreen.Render) {
        & $global:TuiState.CurrentScreen.Render -self $global:TuiState.CurrentScreen
    }
    
    # Check if anything was written to the buffer
    $hasContent = $false
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            if ($global:TuiState.BackBuffer[$y, $x].Char -ne ' ') {
                $hasContent = $true
                break
            }
        }
        if ($hasContent) { break }
    }
    
    if ($hasContent) {
        Write-Host "`nSUCCESS: Content detected in buffer!" -ForegroundColor Green
        Write-Host "The TUI is now able to render. Starting full loop..." -ForegroundColor Green
        
        # Now run the full loop
        Start-TuiLoop
    } else {
        Write-Host "`nFAILED: No content in buffer - rendering is still broken!" -ForegroundColor Red
    }
    
} catch {
    Write-Host "`nERROR during test: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkGray
} finally {
    # Cleanup
    [Console]::Clear()
    [Console]::CursorVisible = $true
}



####\Verify-MigrationState.ps1
# Quick verification of current migration state
# Checks actual files against expected Phase 0 and Phase 1 completions

function Test-FileContains {
    param([string]$FilePath, [string]$Pattern, [string]$Description)
    
    if (-not (Test-Path $FilePath)) {
        Write-Host "❌ $Description - File not found: $FilePath" -ForegroundColor Red
        return $false
    }
    
    $content = Get-Content $FilePath -Raw
    if ($content -match $Pattern) {
        Write-Host "✅ $Description" -ForegroundColor Green
        return $true
    } else {
        Write-Host "❌ $Description - Pattern not found" -ForegroundColor Red
        return $false
    }
}

Write-Host "🔍 Verifying Migration State..." -ForegroundColor Cyan
Write-Host ""

# Phase 0 Verification
Write-Host "📋 Phase 0 (Foundation) Verification:" -ForegroundColor Yellow

$phase0Results = @()
$phase0Results += Test-FileContains "components\tui-primitives.psm1" "class TuiCell" "TuiCell class exists"
$phase0Results += Test-FileContains "components\tui-primitives.psm1" "class TuiBuffer" "TuiBuffer class exists"  
$phase0Results += Test-FileContains "components\tui-primitives.psm1" "class UIElement" "UIElement base class exists"
$phase0Results += Test-FileContains "layout\panels-class.psm1" "class Panel.*UIElement" "Panel inherits from UIElement"
$phase0Results += Test-FileContains "modules\tui-engine.psm1" "function.*Render-Frame" "Enhanced TUI engine exists"

$phase0Complete = -not ($phase0Results -contains $false)
Write-Host "Phase 0 Status: $(if($phase0Complete){'✅ COMPLETE'}else{'❌ INCOMPLETE'})" -ForegroundColor $(if($phase0Complete){'Green'}else{'Red'})
Write-Host ""

# Phase 1 Verification  
Write-Host "📋 Phase 1 (Core Components) Verification:" -ForegroundColor Yellow

$phase1Results = @()
$phase1Results += Test-FileContains "components\navigation-class.psm1" "\[void\]\s+_RenderContent\(\)" "NavigationMenu has void _RenderContent()"
$phase1Results += Test-FileContains "components\navigation-class.psm1" "Write-BufferString" "NavigationMenu uses Write-BufferString"
$phase1Results += Test-FileContains "components\advanced-data-components.psm1" "\[void\]\s+_RenderContent\(\)" "Table has void _RenderContent()"
$phase1Results += Test-FileContains "components\advanced-data-components.psm1" "Write-BufferString.*-X.*-Y" "Table uses buffer-based rendering"
$phase1Results += Test-FileContains "layout\panels-class.psm1" "\[void\]\s+OnRender\(\)" "Panel has void OnRender()"
$phase1Results += Test-FileContains "layout\panels-class.psm1" "Write-TuiBox" "Panel uses Write-TuiBox"

$phase1Complete = -not ($phase1Results -contains $false)
Write-Host "Phase 1 Status: $(if($phase1Complete){'✅ COMPLETE'}else{'❌ INCOMPLETE'})" -ForegroundColor $(if($phase1Complete){'Green'}else{'Red'})
Write-Host ""

# Overall Status
Write-Host "📊 Overall Migration Status:" -ForegroundColor Cyan
if ($phase0Complete -and $phase1Complete) {
    Write-Host "🎯 Ready for Phase 2 (Advanced Components)" -ForegroundColor Green
    Write-Host ""
    Write-Host "Next commands:" -ForegroundColor White
    Write-Host "  .\Sync-MigrationSystem.ps1" -ForegroundColor Gray
    Write-Host "  .\Start-TuiMigration.ps1" -ForegroundColor Gray
} elseif ($phase0Complete) {
    Write-Host "⚠️  Phase 0 complete, Phase 1 needs attention" -ForegroundColor Yellow
} else {
    Write-Host "❌ Foundation issues detected" -ForegroundColor Red
}

Write-Host ""
return @{
    Phase0Complete = $phase0Complete
    Phase1Complete = $phase1Complete  
    ReadyForPhase2 = ($phase0Complete -and $phase1Complete)
}



####\verify-scope-fix.ps1
# TUI Scope Fix Verification Script
# This script verifies that the scope fixes have been applied correctly

Write-Host "TUI Scope Fix Verification" -ForegroundColor Cyan
Write-Host "==========================" -ForegroundColor Cyan

$baseDir = "C:\Users\jhnhe\Documents\GitHub\_XP\"
$hasErrors = $false

# Check 1: Verify engine uses global:TuiState
Write-Host "`nChecking TUI Engine..." -ForegroundColor Yellow
$enginePath = Join-Path $baseDir "modules\tui-engine-v2.psm1"
$engineContent = Get-Content $enginePath -Raw

$scriptStateCount = ([regex]::Matches($engineContent, '\$script:TuiState')).Count
$globalStateCount = ([regex]::Matches($engineContent, '\$global:TuiState')).Count

if ($scriptStateCount -gt 0) {
    Write-Host "  ERROR: Found $scriptStateCount instances of `$script:TuiState" -ForegroundColor Red
    $hasErrors = $true
} else {
    Write-Host "  OK: No `$script:TuiState found" -ForegroundColor Green
}

Write-Host "  INFO: Found $globalStateCount instances of `$global:TuiState" -ForegroundColor Cyan

# Check 2: Verify no global: function definitions
Write-Host "`nChecking Component Functions..." -ForegroundColor Yellow
$componentPaths = @(
    "components\advanced-data-components.psm1",
    "components\advanced-input-components.psm1", 
    "components\tui-components.psm1",
    "layout\panels.psm1",
    "modules\dialog-system.psm1",
    "modules\event-system.psm1",
    "modules\state-manager.psm1",
    "modules\text-resources.psm1",
    "modules\theme-manager.psm1",
    "services\keybindings.psm1",
    "services\navigation.psm1",
    "services\task-services.psm1",
    "utilities\focus-manager.psm1",
    "utilities\layout-manager.psm1",
    "utilities\positioning-helper.psm1"
)

$totalGlobalFunctions = 0
foreach ($relativePath in $componentPaths) {
    $fullPath = Join-Path $baseDir $relativePath
    if (Test-Path $fullPath) {
        $content = Get-Content $fullPath -Raw
        $matches = [regex]::Matches($content, 'function\s+global:(\w+)')
        if ($matches.Count -gt 0) {
            Write-Host "  ERROR in $relativePath : Found $($matches.Count) global: functions" -ForegroundColor Red
            $hasErrors = $true
            $totalGlobalFunctions += $matches.Count
        }
    }
}

if ($totalGlobalFunctions -eq 0) {
    Write-Host "  OK: No global: function definitions found" -ForegroundColor Green
}

# Check 3: Verify main.ps1 uses Import-Module -Global
Write-Host "`nChecking main.ps1 module loading..." -ForegroundColor Yellow
$mainPath = Join-Path $baseDir "main.ps1"
if (Test-Path $mainPath) {
    $mainContent = Get-Content $mainPath -Raw
    if ($mainContent -match 'Import-Module.*-Global') {
        Write-Host "  OK: main.ps1 uses Import-Module -Global" -ForegroundColor Green
    } else {
        Write-Host "  WARNING: main.ps1 may not be using Import-Module -Global" -ForegroundColor Yellow
    }
}

Write-Host "`n========================================" -ForegroundColor Cyan
if ($hasErrors) {
    Write-Host "VERIFICATION FAILED: Issues found!" -ForegroundColor Red
    Write-Host "Run the fix scripts before proceeding." -ForegroundColor Yellow
} else {
    Write-Host "VERIFICATION PASSED: All checks successful!" -ForegroundColor Green
    Write-Host "The TUI should now render correctly." -ForegroundColor Green
}



