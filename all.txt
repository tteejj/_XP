####\components\advanced-data-components\advanced-data-components.psm1
# Advanced Data Components Module for PMC Terminal v5
# Phase 1 Migration Complete - Enhanced data display with proper UIElement inheritance

#using namespace System.Text
#using namespace System.Management.Automation
#using module '.\components\tui-primitives.psm1'
#using module '.\components\ui-classes.psm1'
#using module '..\modules\logger.psm1'

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

# AI: REFACTORED - Table now properly inherits from UIElement
class Table : UIElement {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    [bool]$IsFocused = $false
    
    Table([string]$name) : base() {
        $this.Name = $name
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        $this.Data = @()
        $this.SelectedIndex = 0
        $this.IsFocusable = $true
        $this.Width = 60
        $this.Height = 15
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
        $this.RequestRedraw()
    }
    
    [void] SetData([object[]]$data) {
        $this.Data = if ($null -eq $data) { @() } else { @($data) }
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -ge $dataCount) {
            $this.SelectedIndex = [Math]::Max(0, $dataCount - 1)
        }
        $this.RequestRedraw()
    }
    
    [void] SelectNext() {
        $dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -lt ($dataCount - 1)) {
            $this.SelectedIndex++
            $this.RequestRedraw()
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
            $this.RequestRedraw()
        }
    }
    
    [object] GetSelectedItem() {
        if ($null -eq $this.Data) { return $null }
        
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        
        if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {
            return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }
        }
        return $null
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Draw border if enabled
            if ($this.ShowBorder) {
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                    -BorderStyle "Single" -BorderColor ([ConsoleColor]::Gray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            $currentY = if ($this.ShowBorder) { 1 } else { 0 }
            $contentWidth = if ($this.ShowBorder) { $this.Width - 2 } else { $this.Width }
            $renderX = if ($this.ShowBorder) { 1 } else { 0 }
            
            # Header
            if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
                $headerLine = ""
                foreach ($col in $this.Columns) {
                    $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                    $headerLine += $headerText + " "
                }
                
                if ($headerLine.TrimEnd().Length -gt $contentWidth) {
                    $headerLine = $headerLine.Substring(0, $contentWidth)
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $headerLine.TrimEnd() `
                    -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
                $currentY++
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY `
                    -Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $contentWidth)) `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
                $currentY++
            }
            
            # Data rows
            $dataToRender = @()
            if ($null -ne $this.Data) {
                $dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }
            }
            
            for ($i = 0; $i -lt $dataToRender.Count; $i++) {
                $row = $dataToRender[$i]
                if ($null -eq $row) { continue }
                
                $rowLine = ""
                $isSelected = ($i -eq $this.SelectedIndex)
                
                foreach ($col in $this.Columns) {
                    $cellValue = ""
                    if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                        $cellValue = $row[$col.Key]?.ToString() ?? ""
                    } elseif ($row.PSObject.Properties[$col.Key]) {
                        $cellValue = $row.($col.Key)?.ToString() ?? ""
                    }
                    
                    $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                    $rowLine += $cellText + " "
                }
                
                $finalLine = $rowLine.TrimEnd()
                if ($isSelected) {
                    $finalLine = "> $finalLine"
                } else {
                    $finalLine = "  $finalLine"
                }
                
                $fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
                $bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
                
                if ($finalLine.Length -gt $contentWidth) {
                    $finalLine = $finalLine.Substring(0, $contentWidth)
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $finalLine `
                    -ForegroundColor $fg -BackgroundColor $bg
                $currentY++
                
                # Don't exceed available space
                if ($currentY -ge ($this.Height - 1)) { break }
            }
            
            if ($dataToRender.Count -eq 0) {
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text "  No data to display" `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
        } catch { 
            Write-Log -Level Error -Message "Table render error for '$($this.Name)': $_" 
        }
    }
    
    # AI: REFACTORED - Updated input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this.SelectPrevious()
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $this.SelectNext()
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $selectedItem = $this.GetSelectedItem()
                    if ($null -ne $selectedItem) {
                        # Trigger selection event or action
                        Write-Log -Level Debug -Message "Table item selected: $($selectedItem)"
                    }
                    return $true
                }
            }
        } catch { 
            Write-Log -Level Error -Message "Table input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    [void] OnFocus() {
        $this.IsFocused = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        $this.IsFocused = $false
        $this.RequestRedraw()
    }
}

# AI: DELETED - Obsolete DataTableComponent class was here and has been removed.

#endregion

#region Factory Functions

function New-TuiTable {
    # AI: REFACTORED - Creates a proper Table instance
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Table_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $table = [Table]::new($name)
    
    if ($Props.Columns) {
        $table.SetColumns($Props.Columns)
    }
    if ($Props.Data) {
        $table.SetData($Props.Data)
    }

    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader
    $table.Visible = $Props.Visible ?? $table.Visible
    
    return $table
}

#endregion

Export-ModuleMember -Function 'New-TuiTable'


####\components\advanced-input-components\advanced-input-components.psm1
# Advanced Input Components - Phase 2 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

#using module '.\components\tui-primitives.psm1'
#using module '.\components\ui-classes.psm1'
#using module '..\modules\logger.psm1'
#using module '..\modules\exceptions.psm1'

#region Advanced Input Classes

# AI: REFACTORED - MultilineTextBox converted from functional to class-based
class MultilineTextBoxComponent : UIElement {
    [string[]]$Lines = @("")
    [string]$Placeholder = "Enter text..."
    [int]$MaxLines = 10
    [int]$MaxLineLength = 100
    [int]$CurrentLine = 0
    [int]$CursorPosition = 0
    [int]$ScrollOffsetY = 0
    [bool]$WordWrap = $true
    [scriptblock]$OnChange
    
    MultilineTextBoxComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 40
        $this.Height = 10
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Calculate visible area
            $textAreaHeight = $this.Height - 2
            $textAreaWidth = $this.Width - 2
            $startLine = $this.ScrollOffsetY
            $endLine = [Math]::Min($this.Lines.Count - 1, $startLine + $textAreaHeight - 1)
            
            # AI: Render text lines
            for ($i = $startLine; $i -le $endLine; $i++) {
                if ($i -ge $this.Lines.Count) { break }
                
                $line = $this.Lines[$i] ?? ""
                $displayLine = $line
                if ($displayLine.Length -gt $textAreaWidth) {
                    $displayLine = $displayLine.Substring(0, $textAreaWidth)
                }
                
                $lineY = 1 + ($i - $startLine)
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y $lineY -Text $displayLine `
                    -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            # AI: Show placeholder if empty and not focused
            if ($this.Lines.Count -eq 1 -and [string]::IsNullOrEmpty($this.Lines[0]) -and -not $this.IsFocused) {
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $this.Placeholder `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            # AI: Draw cursor if focused
            if ($this.IsFocused) {
                $cursorLine = $this.CurrentLine - $this.ScrollOffsetY
                if ($cursorLine -ge 0 -and $cursorLine -lt $textAreaHeight) {
                    $cursorX = 1 + $this.CursorPosition
                    $cursorY = 1 + $cursorLine
                    if ($cursorX -lt $this.Width - 1) {
                        Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y $cursorY -Text "_" `
                            -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                    }
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentLineText = $this.Lines[$this.CurrentLine] ?? ""
            $originalLines = $this.Lines.Clone()
            $handled = $true
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = $this.Lines[$this.CurrentLine].Length
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.CursorPosition++
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $currentLineText.Length }
                ([ConsoleKey]::Enter) {
                    if ($this.Lines.Count -lt $this.MaxLines) {
                        $beforeCursor = $currentLineText.Substring(0, $this.CursorPosition)
                        $afterCursor = $currentLineText.Substring($this.CursorPosition)
                        
                        $this.Lines[$this.CurrentLine] = $beforeCursor
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($afterCursor) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0 -and $this.Lines.Count -gt 1) {
                        $previousLine = $this.Lines[$this.CurrentLine - 1]
                        $this.CursorPosition = $previousLine.Length
                        $this.Lines[$this.CurrentLine - 1] = $previousLine + $currentLineText
                        $this.Lines = @($this.Lines[0..($this.CurrentLine - 1)]) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        $this.CurrentLine--
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition, 1)
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $nextLine = $this.Lines[$this.CurrentLine + 1]
                        $this.Lines[$this.CurrentLine] = $currentLineText + $nextLine
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($this.Lines[($this.CurrentLine + 2)..($this.Lines.Count - 1)])
                    }
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentLineText.Length -lt $this.MaxLineLength) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.OnChange -and -not $this._ArraysEqual($originalLines, $this.Lines)) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Lines 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _UpdateScrolling() {
        $textAreaHeight = $this.Height - 2
        if ($this.CurrentLine -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CurrentLine
        } elseif ($this.CurrentLine -ge ($this.ScrollOffsetY + $textAreaHeight)) {
            $this.ScrollOffsetY = $this.CurrentLine - $textAreaHeight + 1
        }
    }
    
    hidden [bool] _ArraysEqual([string[]]$array1, [string[]]$array2) {
        if ($array1.Count -ne $array2.Count) { return $false }
        for ($i = 0; $i -lt $array1.Count; $i++) {
            if ($array1[$i] -ne $array2[$i]) { return $false }
        }
        return $true
    }
    
    [string] GetText() {
        return $this.Lines -join "`n"
    }
    
    [void] SetText([string]$text) {
        $this.Lines = if ([string]::IsNullOrEmpty($text)) { @("") } else { $text -split "`n" }
        $this.CurrentLine = 0
        $this.CursorPosition = 0
        $this.ScrollOffsetY = 0
        $this.RequestRedraw()
    }
}

# AI: REFACTORED - NumericInput converted from functional to class-based
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$Min = [double]::MinValue
    [double]$Max = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [string]$TextValue = "0"
    [int]$CursorPosition = 0
    [string]$Suffix = ""
    [scriptblock]$OnChange
    
    NumericInputComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display value with suffix
            $displayText = $this.TextValue + $this.Suffix
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw spinner arrows
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 0 -Text "▲" `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 2 -Text "▼" `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt $this.Width - 4) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" `
                        -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "NumericInput render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this._IncrementValue()
                }
                ([ConsoleKey]::DownArrow) {
                    $this._DecrementValue()
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) { 
                        $this.CursorPosition-- 
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) { 
                        $this.CursorPosition++ 
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this._ValidateAndUpdate()
                }
                default {
                    if ($key.KeyChar -and ($key.KeyChar -match '[\d\.\-]' -or 
                        ($key.KeyChar -eq '.' -and $this.DecimalPlaces -gt 0 -and -not $this.TextValue.Contains('.')))) {
                        $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "NumericInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _IncrementValue() {
        $newValue = [Math]::Min($this.Max, $this.Value + $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _DecrementValue() {
        $newValue = [Math]::Max($this.Min, $this.Value - $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _SetValue([double]$value) {
        $this.Value = $value
        $this.TextValue = $value.ToString("F$($this.DecimalPlaces)")
        $this.CursorPosition = $this.TextValue.Length
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newValue = [double]$this.TextValue
            $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
            $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
            
            $this._SetValue($newValue)
            return $true
        } catch {
            $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
            Write-Log -Level Warning -Message "NumericInput validation failed for '$($this.Name)': $_"
            return $false
        }
    }
}

# AI: REFACTORED - DateInput converted from functional to class-based
class DateInputComponent : UIElement {
    [DateTime]$Value = (Get-Date)
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [string]$Format = "yyyy-MM-dd"
    [string]$TextValue = ""
    [int]$CursorPosition = 0
    [bool]$ShowCalendar = $false
    [scriptblock]$OnChange
    
    DateInputComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.TextValue = $this.Value.ToString($this.Format)
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display date value
            $displayText = $this.TextValue
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw calendar icon
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text "📅" `
                -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt $this.Width - 4) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" `
                        -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "DateInput render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            if ($this.ShowCalendar) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) { $this.ShowCalendar = $false }
                    ([ConsoleKey]::LeftArrow) { $this.Value = $this.Value.AddDays(-1) }
                    ([ConsoleKey]::RightArrow) { $this.Value = $this.Value.AddDays(1) }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(-7) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(7) }
                    ([ConsoleKey]::Enter) { 
                        $this.ShowCalendar = $false
                        $this.TextValue = $this.Value.ToString($this.Format)
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::F4) { $this.ShowCalendar = $true }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(-1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::LeftArrow) {
                        if ($this.CursorPosition -gt 0) { $this.CursorPosition-- }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) { $this.CursorPosition++ }
                    }
                    ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                    ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                    ([ConsoleKey]::Backspace) {
                        if ($this.CursorPosition -gt 0) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                            $this.CursorPosition--
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                        }
                    }
                    ([ConsoleKey]::Enter) {
                        $this._ValidateAndUpdate()
                    }
                    default {
                        if ($key.KeyChar -and ($key.KeyChar -match '[\d\-\/]')) {
                            $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                            $this.CursorPosition++
                        } else {
                            $handled = $false
                        }
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "DateInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newDate = [DateTime]::ParseExact($this.TextValue, $this.Format, $null)
            if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                $this.Value = $newDate
                $this.TextValue = $newDate.ToString($this.Format)
                return $true
            }
        } catch {
            # Reset to current value on parse error
            $this.TextValue = $this.Value.ToString($this.Format)
            Write-Log -Level Warning -Message "DateInput validation failed for '$($this.Name)': $_"
        }
        return $false
    }
}

# AI: REFACTORED - ComboBox converted from functional to class-based
class ComboBoxComponent : UIElement {
    [object[]]$Items = @()
    [object]$SelectedItem = $null
    [int]$SelectedIndex = -1
    [string]$DisplayMember = "Display"
    [string]$ValueMember = "Value"
    [string]$Placeholder = "Select an item..."
    [bool]$IsDropDownOpen = $false
    [int]$MaxDropDownHeight = 6
    [int]$ScrollOffset = 0
    [scriptblock]$OnSelectionChanged
    
    ComboBoxComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 30
        $this.Height = 3
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw main combobox
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display selected item or placeholder
            $displayText = ""
            if ($this.SelectedItem) {
                if ($this.SelectedItem -is [string]) {
                    $displayText = $this.SelectedItem
                } elseif ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.DisplayMember)) {
                    $displayText = $this.SelectedItem[$this.DisplayMember]
                } else {
                    $displayText = $this.SelectedItem.ToString()
                }
            } else {
                $displayText = $this.Placeholder
            }
            
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength - 3) + "..."
            }
            
            $textColor = $this.SelectedItem ? [ConsoleColor]::White : [ConsoleColor]::DarkGray
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor $textColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw dropdown arrow
            $arrow = $this.IsDropDownOpen ? "▲" : "▼"
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text $arrow `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "ComboBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalSelection = $this.SelectedItem
            
            if ($this.IsDropDownOpen) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) {
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::Enter) {
                        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
                            $this.SelectedItem = $this.Items[$this.SelectedIndex]
                        }
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($this.SelectedIndex -gt 0) {
                            $this.SelectedIndex--
                            $this._UpdateScrolling()
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                            $this.SelectedIndex++
                            $this._UpdateScrolling()
                        }
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::Enter) { $this._OpenDropDown() }
                    ([ConsoleKey]::Spacebar) { $this._OpenDropDown() }
                    ([ConsoleKey]::DownArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::UpArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::F4) { $this._OpenDropDown() }
                    default { $handled = $false }
                }
            }
            
            if ($handled -and $this.SelectedItem -ne $originalSelection -and $this.OnSelectionChanged) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnSelectionChanged" -Context "Selection Change" -ScriptBlock { 
                    & $this.OnSelectionChanged -SelectedItem $this.SelectedItem 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "ComboBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _OpenDropDown() {
        if ($this.Items.Count -gt 0) {
            $this.IsDropDownOpen = $true
            $this._FindCurrentSelection()
        }
    }
    
    hidden [void] _FindCurrentSelection() {
        $this.SelectedIndex = -1
        if ($this.SelectedItem) {
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                if ($this._ItemsEqual($this.Items[$i], $this.SelectedItem)) {
                    $this.SelectedIndex = $i
                    break
                }
            }
        }
        if ($this.SelectedIndex -eq -1) { $this.SelectedIndex = 0 }
        $this._UpdateScrolling()
    }
    
    hidden [void] _UpdateScrolling() {
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $this.MaxDropDownHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $this.MaxDropDownHeight + 1
        }
    }
    
    hidden [bool] _ItemsEqual([object]$item1, [object]$item2) {
        if ($item1 -is [string] -and $item2 -is [string]) {
            return $item1 -eq $item2
        } elseif ($item1 -is [hashtable] -and $item2 -is [hashtable]) {
            return $item1[$this.ValueMember] -eq $item2[$this.ValueMember]
        } else {
            return $item1 -eq $item2
        }
    }
    
    [void] SetItems([object[]]$items) {
        $this.Items = $items
        $this.SelectedItem = $null
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.IsDropDownOpen = $false
        $this.RequestRedraw()
    }
    
    [object] GetSelectedValue() {
        if ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.ValueMember)) {
            return $this.SelectedItem[$this.ValueMember]
        }
        return $this.SelectedItem
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiMultilineTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "MultilineTextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [MultilineTextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLines = $Props.MaxLines ?? $textBox.MaxLines
    $textBox.MaxLineLength = $Props.MaxLineLength ?? $textBox.MaxLineLength
    $textBox.WordWrap = $Props.WordWrap ?? $textBox.WordWrap
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    if ($Props.Text) {
        $textBox.SetText($Props.Text)
    }
    
    return $textBox
}

function New-TuiNumericInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "NumericInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $numericInput = [NumericInputComponent]::new($name)
    
    $numericInput.X = $Props.X ?? $numericInput.X
    $numericInput.Y = $Props.Y ?? $numericInput.Y
    $numericInput.Width = $Props.Width ?? $numericInput.Width
    $numericInput.Height = $Props.Height ?? $numericInput.Height
    $numericInput.Visible = $Props.Visible ?? $numericInput.Visible
    $numericInput.ZIndex = $Props.ZIndex ?? $numericInput.ZIndex
    $numericInput.Value = $Props.Value ?? $numericInput.Value
    $numericInput.Min = $Props.Min ?? $numericInput.Min
    $numericInput.Max = $Props.Max ?? $numericInput.Max
    $numericInput.Step = $Props.Step ?? $numericInput.Step
    $numericInput.DecimalPlaces = $Props.DecimalPlaces ?? $numericInput.DecimalPlaces
    $numericInput.Suffix = $Props.Suffix ?? $numericInput.Suffix
    $numericInput.OnChange = $Props.OnChange ?? $numericInput.OnChange
    
    # Update text value based on initial value
    $numericInput.TextValue = $numericInput.Value.ToString("F$($numericInput.DecimalPlaces)")
    
    return $numericInput
}

function New-TuiDateInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DateInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $dateInput = [DateInputComponent]::new($name)
    
    $dateInput.X = $Props.X ?? $dateInput.X
    $dateInput.Y = $Props.Y ?? $dateInput.Y
    $dateInput.Width = $Props.Width ?? $dateInput.Width
    $dateInput.Height = $Props.Height ?? $dateInput.Height
    $dateInput.Visible = $Props.Visible ?? $dateInput.Visible
    $dateInput.ZIndex = $Props.ZIndex ?? $dateInput.ZIndex
    $dateInput.Value = $Props.Value ?? $dateInput.Value
    $dateInput.MinDate = $Props.MinDate ?? $dateInput.MinDate
    $dateInput.MaxDate = $Props.MaxDate ?? $dateInput.MaxDate
    $dateInput.Format = $Props.Format ?? $dateInput.Format
    $dateInput.OnChange = $Props.OnChange ?? $dateInput.OnChange
    
    # Update text value based on initial value
    $dateInput.TextValue = $dateInput.Value.ToString($dateInput.Format)
    
    return $dateInput
}

function New-TuiComboBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "ComboBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $comboBox = [ComboBoxComponent]::new($name)
    
    $comboBox.X = $Props.X ?? $comboBox.X
    $comboBox.Y = $Props.Y ?? $comboBox.Y
    $comboBox.Width = $Props.Width ?? $comboBox.Width
    $comboBox.Height = $Props.Height ?? $comboBox.Height
    $comboBox.Visible = $Props.Visible ?? $comboBox.Visible
    $comboBox.ZIndex = $Props.ZIndex ?? $comboBox.ZIndex
    $comboBox.DisplayMember = $Props.DisplayMember ?? $comboBox.DisplayMember
    $comboBox.ValueMember = $Props.ValueMember ?? $comboBox.ValueMember
    $comboBox.Placeholder = $Props.Placeholder ?? $comboBox.Placeholder
    $comboBox.MaxDropDownHeight = $Props.MaxDropDownHeight ?? $comboBox.MaxDropDownHeight
    $comboBox.OnSelectionChanged = $Props.OnSelectionChanged ?? $comboBox.OnSelectionChanged
    
    if ($Props.Items) {
        $comboBox.SetItems($Props.Items)
    }
    
    if ($Props.SelectedItem) {
        $comboBox.SelectedItem = $Props.SelectedItem
    }
    
    return $comboBox
}

#endregion

Export-ModuleMember -Function 'New-TuiMultilineTextBox', 'New-TuiNumericInput', 'New-TuiDateInput', 'New-TuiComboBox'


####\components\navigation-class\navigation-class.psm1
# Navigation Component Classes Module for PMC Terminal v5
# Phase 1 Migration Complete - Proper UIElement inheritance and Panel integration

#using namespace System.Management.Automation
#using module '.\tui-primitives.psm1'
#using module '.\ui-classes.psm1'
#using module '..\modules\exceptions.psm1'
#using module '..\modules\logger.psm1'

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        $display = "[$($this.Key)] "
        
        if ($this.Enabled) {
            $display += $this.Label
        }
        else {
            $display += "$($this.Label) (Disabled)"
        }
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            $display += " - $($this.Description)"
        }
        
        return $display
    }
}

# AI: REFACTORED - NavigationMenu now properly inherits from UIElement
class NavigationMenu : UIElement {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    [bool] $IsFocused = $false
    
    NavigationMenu([string]$name) : base() {
        $this.Name = $name
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.SelectedIndex = 0
        $this.Width = 30
        $this.Height = 10
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base() {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Name = $name
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.SelectedIndex = 0
        $this.Width = 30
        $this.Height = 10
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) { 
            throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") 
        }
        $this.Items.Add($item)
        $this.RequestRedraw()
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { 
            [void]$this.Items.Remove($item)
            $this.RequestRedraw()
        }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { 
                $item.Execute() 
            }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
        $this.RequestRedraw()
    }

    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", { 
                    $this.Services.Navigation.GoTo("/tasks", @{mode="new"}) 
                }))
                $this.AddItem([NavigationItem]::new("P", "Projects", { 
                    $this.Services.Navigation.GoTo("/projects", @{}) 
                }))
                $this.AddItem([NavigationItem]::new("S", "Settings", { 
                    $this.Services.Navigation.GoTo("/settings", @{}) 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("Q", "Quit", { 
                    $this.Services.Navigation.RequestExit() 
                }))
            }
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", { 
                    Write-Host "New task not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("E", "Edit", { 
                    Write-Host "Edit not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("D", "Delete", { 
                    Write-Host "Delete not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("F", "Filter", { 
                    Write-Host "Filter not implemented" 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
            }
            default {
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
                $this.AddItem([NavigationItem]::new("H", "Home", { 
                    $this.Services.Navigation.GoTo("/dashboard", @{}) 
                }))
            }
        }
    }
    
    # AI: REFACTORED - Now uses Panel buffer integration
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear our buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Get visible items
            $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
            if ($visibleItems.Count -eq 0) { return }
            
            if ($this.Orientation -eq "Horizontal") { 
                $this.RenderHorizontal($visibleItems) 
            }
            else { 
                $this.RenderVertical($visibleItems) 
            }
            
        } catch { 
            Write-Log -Level Error -Message "NavigationMenu render error for '$($this.Name)': $_" 
        }
    }
    
    hidden [void] RenderHorizontal([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) { return }
        
        $menuText = ""
        $isFirst = $true
        foreach ($item in $items) {
            if ($null -eq $item) { continue }
            
            if (-not $isFirst) {
                $menuText += $this.Separator
            }
            $menuText += "[$($item.Key)] $($item.Label)"
            $isFirst = $false
        }
        
        # Write to our private buffer
        $this._private_buffer.WriteString(0, 0, $menuText, [ConsoleColor]::White, [ConsoleColor]::Black)
    }
    
    hidden [void] RenderVertical([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) { return }
        
        # Ensure SelectedIndex is within bounds
        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {
            $this.SelectedIndex = 0
        }
        
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($null -eq $item) { continue }
            
            $prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }
            $menuText = "$prefix[$($item.Key)] $($item.Label)"
            
            # Pad text to clear the full line width
            if ($menuText.Length -lt $this.Width) {
                $menuText = $menuText.PadRight($this.Width)
            }
            
            $fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                [ConsoleColor]::Black 
            } else { 
                [ConsoleColor]::White 
            }
            $bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                [ConsoleColor]::White 
            } else { 
                [ConsoleColor]::Black 
            }
            
            # Write to our private buffer
            $this._private_buffer.WriteString(0, $i, $menuText, $fg, $bg)
        }
    }
    
    # AI: REFACTORED - Updated input handling for new architecture
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
            if ($visibleItems.Count -eq 0) { return $false }
            
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt ($visibleItems.Count - 1)) {
                        $this.SelectedIndex++
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $visibleItems.Count) {
                        $selectedItem = $visibleItems[$this.SelectedIndex]
                        if ($selectedItem.Enabled -and $selectedItem.Key -ne "-") {
                            $selectedItem.Execute()
                        }
                    }
                    return $true
                }
                default {
                    # Check for direct key matches
                    $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
                    $matchingItem = $this.Items.Find({param($x) $x.Key -eq $keyChar})
                    if ($matchingItem -and $matchingItem.Enabled -and $matchingItem.Visible) {
                        $matchingItem.Execute()
                        return $true
                    }
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "NavigationMenu input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    # AI: NEW - Focus management
    [void] OnFocus() {
        $this.IsFocused = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        $this.IsFocused = $false
        $this.RequestRedraw()
    }
}

Export-ModuleMember -Function @()


####\components\tui-components\tui-components.psm1
####\components\tui-components.psm1
# TUI Component Library - Phase 1 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

#using module '.\tui-primitives.psm1'
#using module '.\ui-classes.psm1'
#using module '..\modules\exceptions.psm1'
#using module '..\modules\logger.psm1'

#region Core UI Components

# AI: REFACTORED - LabelComponent now properly inherits from UIElement
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor
    
    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $this.Text -ForegroundColor $fg

        } catch { 
            Write-Log -Level Error -Message "Label render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false # Labels don't handle input
    }
}

# AI: REFACTORED - ButtonComponent updated for buffer-based rendering
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick
    
    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
        $this.Text = "Button"
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer, not the parent's.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))

            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            $bgColor = $this.IsPressed ? [ConsoleColor]::Yellow : [ConsoleColor]::Black
            $fgColor = $this.IsPressed ? [ConsoleColor]::Black : $borderColor
            
            # Render border to own buffer
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
            
            # Render text centered in own buffer
            $textX = [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = [Math]::Floor(($this.Height - 1) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -ForegroundColor $fgColor -BackgroundColor $bgColor

        } catch { 
            Write-Log -Level Error -Message "Button render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsPressed = $true
                $this.RequestRedraw()
                
                if ($this.OnClick) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock { & $this.OnClick }
                }
                
                Start-Sleep -Milliseconds 50 # Visual feedback for press
                $this.IsPressed = $false
                $this.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "Button input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: REFACTORED - TextBoxComponent with buffer-based rendering
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.MaxLength = 100
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)

            # Display text or placeholder
            $displayText = $this.Text ?? ""
            $textColor = [ConsoleColor]::White
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = $this.Placeholder ?? "" 
                $textColor = [ConsoleColor]::DarkGray
            }
            
            $maxDisplayLength = $this.Width - 2
            if ($displayText.Length > $maxDisplayLength) { 
                $displayText = $displayText.Substring(0, $maxDisplayLength) 
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayText -ForegroundColor $textColor
            
            # Draw cursor if focused
            if ($this.IsFocused -and ($this.CursorPosition -le $displayText.Length)) {
                $cursorX = 1 + $this.CursorPosition
                # Only draw cursor if it's within the visible area
                # AI: FIX - Changed '<' to '-lt' to avoid PowerShell parser ambiguity
                if ($cursorX -lt ($this.Width - 1)) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" -ForegroundColor [ConsoleColor]::Yellow
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "TextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition ?? 0
            $originalText = $currentText
            $handled = $true
            
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $currentText = $currentText.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    } 
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $currentText.Length) { 
                        $currentText = $currentText.Remove($cursorPos, 1) 
                    } 
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- } 
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $currentText.Length) { $cursorPos++ } 
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $currentText.Length }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) { 
                        $currentText = $currentText.Insert($cursorPos, $key.KeyChar)
                        $cursorPos++ 
                    } else { 
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                if ($currentText -ne $originalText -or $cursorPos -ne $this.CursorPosition) {
                    $this.Text = $currentText
                    $this.CursorPosition = $cursorPos
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $currentText 
                        }
                    }
                    $this.RequestRedraw()
                }
            }
            return $handled
        } catch { 
            Write-Log -Level Error -Message "TextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
}

# AI: NEW - CheckBoxComponent converted from functional to class-based
class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange
    
    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $checkbox = $this.Checked ? "[X]" : "[ ]"
            $displayText = "$checkbox $($this.Text)"
            
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $displayText -ForegroundColor $fg
            
        } catch { 
            Write-Log -Level Error -Message "CheckBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Checked = -not $this.Checked
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $this.Checked 
                    } 
                }
                $this.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "CheckBox input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: NEW - RadioButtonComponent converted from functional to class-based
class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange
    
    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $radio = $this.Selected ? "(●)" : "( )"
            $displayText = "$radio $($this.Text)"

            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $displayText -ForegroundColor $fg

        } catch { 
            Write-Log -Level Error -Message "RadioButton render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if (-not $this.Selected) {
                    # AI: Unselect other radio buttons in the same group
                    if ($this.Parent -and $this.GroupName) {
                        $siblingRadios = $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        }
                        foreach ($radio in $siblingRadios) {
                            $radio.Selected = $false
                        }
                    }
                    
                    $this.Selected = $true
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $this.Selected 
                        } 
                    }
                    $this.Parent.RequestRedraw()
                }
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "RadioButton input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $label = [LabelComponent]::new($name)
    
    $label.X = $Props.X ?? $label.X
    $label.Y = $Props.Y ?? $label.Y
    $label.Width = $Props.Width ?? $label.Width
    $label.Height = $Props.Height ?? $label.Height
    $label.Visible = $Props.Visible ?? $label.Visible
    $label.ZIndex = $Props.ZIndex ?? $label.ZIndex
    $label.Text = $Props.Text ?? $label.Text
    $label.ForegroundColor = $Props.ForegroundColor ?? $label.ForegroundColor
    
    return $label
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $button = [ButtonComponent]::new($name)
    
    $button.X = $Props.X ?? $button.X
    $button.Y = $Props.Y ?? $button.Y
    $button.Width = $Props.Width ?? $button.Width
    $button.Height = $Props.Height ?? $button.Height
    $button.Visible = $Props.Visible ?? $button.Visible
    $button.ZIndex = $Props.ZIndex ?? $button.ZIndex
    $button.Text = $Props.Text ?? $button.Text
    $button.OnClick = $Props.OnClick ?? $button.OnClick
    
    return $button
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [TextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Text = $Props.Text ?? $textBox.Text
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLength = $Props.MaxLength ?? $textBox.MaxLength
    $textBox.CursorPosition = $Props.CursorPosition ?? $textBox.CursorPosition
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    return $textBox
}

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $checkBox = [CheckBoxComponent]::new($name)
    
    $checkBox.X = $Props.X ?? $checkBox.X
    $checkBox.Y = $Props.Y ?? $checkBox.Y
    $checkBox.Width = $Props.Width ?? $checkBox.Width
    $checkBox.Height = $Props.Height ?? $checkBox.Height
    $checkBox.Visible = $Props.Visible ?? $checkBox.Visible
    $checkBox.ZIndex = $Props.ZIndex ?? $checkBox.ZIndex
    $checkBox.Text = $Props.Text ?? $checkBox.Text
    $checkBox.Checked = $Props.Checked ?? $checkBox.Checked
    $checkBox.OnChange = $Props.OnChange ?? $checkBox.OnChange
    
    return $checkBox
}

function New-TuiRadioButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $radioButton = [RadioButtonComponent]::new($name)
    
    $radioButton.X = $Props.X ?? $radioButton.X
    $radioButton.Y = $Props.Y ?? $radioButton.Y
    $radioButton.Width = $Props.Width ?? $radioButton.Width
    $radioButton.Height = $Props.Height ?? $radioButton.Height
    $radioButton.Visible = $Props.Visible ?? $radioButton.Visible
    $radioButton.ZIndex = $Props.ZIndex ?? $radioButton.ZIndex
    $radioButton.Text = $Props.Text ?? $radioButton.Text
    $radioButton.Selected = $Props.Selected ?? $radioButton.Selected
    $radioButton.GroupName = $Props.GroupName ?? $radioButton.GroupName
    $radioButton.OnChange = $Props.OnChange ?? $radioButton.OnChange
    
    return $radioButton
}

#endregion

Export-ModuleMember -Function 'New-TuiLabel', 'New-TuiButton', 'New-TuiTextBox', 'New-TuiCheckBox', 'New-TuiRadioButton'


####\components\tui-primitives\test.ps1
# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations
# CORRECTED ORDERING: TuiAnsiHelper is defined BEFORE TuiCell to resolve parse-time dependency.

#using namespace System
#using namespace System.Management.Automation

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int] GetForegroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()]
    }

    static [int] GetBackgroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()] + 10
    }

    static [string] Reset() {
        return "`e[0m"
    }

    static [string] Bold() {
        return "`e[1m"
    }

    static [string] Underline() {
        return "`e[4m"
    }

    static [string] Italic() {
        return "`e[3m"
    }
}
#endregion

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    [ConsoleColor] $ForegroundColor = [ConsoleColor]::White
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = ""
    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() {
        $this.Char = ' '
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Character constructor
    TuiCell([char]$char) {
        $this.Char = $char
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Full constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }

    # Style constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }

    # Copy constructor
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.StyleFlags = $other.StyleFlags
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Create a styled copy
    [TuiCell] WithStyle([ConsoleColor]$fg, [ConsoleColor]$bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    # Create a character copy
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blend this cell with another (higher Z-index wins)
    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return $other }
        if ($other.ZIndex -eq $this.ZIndex -and $other.Char -ne ' ') { return $other }
        return $this
    }

    # Check if this cell differs from another
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic)
    }

    # Generate ANSI escape sequence for this cell
    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Color codes - This now works because TuiAnsiHelper is known to the parser.
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append("`e[${fgCode};${bgCode}")
        
        # Style codes
        if ($this.Bold) { [void]$sb.Append(";1") }
        if ($this.Underline) { [void]$sb.Append(";4") }
        if ($this.Italic) { [void]$sb.Append(";3") }
        
        [void]$sb.Append("m").Append($this.Char)
        return $sb.ToString()
    }

    # Convert to legacy buffer format for compatibility
    [hashtable] ToLegacyFormat() {
        return @{
            Char = $this.Char
            FG = $this.ForegroundColor
            BG = $this.BackgroundColor
        }
    }

    # String representation
    [string] ToString() {
        return "TuiCell($($this.Char), $($this.ForegroundColor), $($this.BackgroundColor))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions
function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    
    $cell = [TuiCell]::new(' ', $ForegroundColor, $BackgroundColor)
    $cell.Bold = $Bold
    $cell.Underline = $Underline
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0) {
            $charCell = [TuiCell]::new($cell)
            $charCell.Char = $char
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$BorderStyle = "Single",
        [ConsoleColor]$BorderColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }
    
    $borders = Get-TuiBorderChars -Style $BorderStyle
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Side borders and fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        $currentY = $Y + $i
        
        # Left border
        Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill
        $fillText = ' ' * ($Width - 2)
        Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -BackgroundColor $BackgroundColor
        
        # Right border
        Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $bottomLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all functions
Export-ModuleMember -Function 'Write-TuiText', 'Write-TuiBox', 'Get-TuiBorderChars'


####\components\tui-primitives\tui-primitives.psm1
# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations
# CORRECTED ORDERING: TuiAnsiHelper is defined BEFORE TuiCell to resolve parse-time dependency.

#using namespace System
#using namespace System.Management.Automation

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int] GetForegroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()]
    }

    static [int] GetBackgroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()] + 10
    }

    static [string] Reset() {
        return "`e[0m"
    }

    static [string] Bold() {
        return "`e[1m"
    }

    static [string] Underline() {
        return "`e[4m"
    }

    static [string] Italic() {
        return "`e[3m"
    }
}
#endregion

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    [ConsoleColor] $ForegroundColor = [ConsoleColor]::White
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = ""
    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() {
        $this.Char = ' '
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Character constructor
    TuiCell([char]$char) {
        $this.Char = $char
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Full constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }

    # Style constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }

    # Copy constructor
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.StyleFlags = $other.StyleFlags
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Create a styled copy
    [TuiCell] WithStyle([ConsoleColor]$fg, [ConsoleColor]$bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    # Create a character copy
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blend this cell with another (higher Z-index wins)
    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return $other }
        if ($other.ZIndex -eq $this.ZIndex -and $other.Char -ne ' ') { return $other }
        return $this
    }

    # Check if this cell differs from another
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic)
    }

    # Generate ANSI escape sequence for this cell
    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Color codes - This now works because TuiAnsiHelper is known to the parser.
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append("`e[${fgCode};${bgCode}")
        
        # Style codes
        if ($this.Bold) { [void]$sb.Append(";1") }
        if ($this.Underline) { [void]$sb.Append(";4") }
        if ($this.Italic) { [void]$sb.Append(";3") }
        
        [void]$sb.Append("m").Append($this.Char)
        return $sb.ToString()
    }

    # Convert to legacy buffer format for compatibility
    [hashtable] ToLegacyFormat() {
        return @{
            Char = $this.Char
            FG = $this.ForegroundColor
            BG = $this.BackgroundColor
        }
    }

    # String representation
    [string] ToString() {
        return "TuiCell($($this.Char), $($this.ForegroundColor), $($this.BackgroundColor))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions
function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    
    $cell = [TuiCell]::new(' ', $ForegroundColor, $BackgroundColor)
    $cell.Bold = $Bold
    $cell.Underline = $Underline
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0) {
            $charCell = [TuiCell]::new($cell)
            $charCell.Char = $char
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$BorderStyle = "Single",
        [ConsoleColor]$BorderColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }
    
    $borders = Get-TuiBorderChars -Style $BorderStyle
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Side borders and fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        $currentY = $Y + $i
        
        # Left border
        Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill
        $fillText = ' ' * ($Width - 2)
        Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -BackgroundColor $BackgroundColor
        
        # Right border
        Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $bottomLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all functions
#Export-ModuleMember -Function 'Write-TuiText', 'Write-TuiBox', 'Get-TuiBorderChars'


####\components\ui-classes\ui-classes.psm1
# ==============================================================================
# PMC Terminal v5 - Base UI Class Hierarchy
# Provides the foundational classes for all UI components with NCurses compositor support.
# ==============================================================================

#using namespace System.Text
#using namespace System.Management.Automation
#using module '.\tui-primitives.psm1'
#using module '..\modules\exceptions.psm1'
#using module '..\modules\logger.psm1'
#using module '..\modules\event-system.psm1'

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# --- Enhanced UI Element with Buffer Management ---
class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [bool] $IsFocused = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer = $null
    [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{}

    # Constructor
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with name
    UIElement([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [ArgumentException]::new("UIElement name cannot be null or empty.")
        }
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with position and size
    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Buffer")
    }

    # Get absolute screen position
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # Add child component
    [void] AddChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
        }
    }

    # Remove child component
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
            $this.RequestRedraw()
        }
    }

    # Request redraw for this component and parents
    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
    }

    # Resize the component and its buffer
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Resize($newWidth, $newHeight)
        }
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # Move the component
    [void] Move([int]$newX, [int]$newY) {
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
    }

    # Check if point is within component bounds
    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge $this.X -and $x -lt ($this.X + $this.Width) -and 
                $y -ge $this.Y -and $y -lt ($this.Y + $this.Height))
    }

    # Get child at specific point (relative to this component)
    [UIElement] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $this.X, $y - $this.Y)) {
                return $child
            }
        }
        return $null
    }

    # Virtual methods for subclasses to override
    [void] OnRender() {
        # Default implementation - clear buffer
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Override in subclasses
    }

    [void] OnMove([int]$newX, [int]$newY) {
        # Override in subclasses
    }

    [void] OnFocus() {
        # Override in subclasses
    }

    [void] OnBlur() {
        # Override in subclasses
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Override in subclasses - return true if input was handled
        return $false
    }

    # Main render method with error handling - calls _RenderContent and renders children
    [void] Render() {
        Invoke-WithErrorHandling -Component $this.Name -Context "Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            $this._RenderContent()
        } -AdditionalData @{ ComponentType = $this.GetType().Name }
    }

    # Protected render implementation - can be overridden by subclasses
    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }

        # Render this component to its private buffer
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer) {
                $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }
            
            $this.OnRender()
            $this._needs_redraw = $false
        }

        # Render children to their buffers, then composite onto parent
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
    }

    # Get the final rendered buffer
    [TuiBuffer] GetBuffer() {
        return $this._private_buffer
    }
    
    [string] ToString() {
        return "$($this.GetType().Name): $($this.Name)"
    }
}

# --- Base Component (can contain children) ---
class Component : UIElement {
    Component([string]$name) : base($name) {
    }

    # AI: Default implementation renders all visible children to buffer
    hidden [void] _RenderContent() {
        # Call parent implementation for buffer management
        ([UIElement]$this)._RenderContent()
    }
}

# Note: Panel class is now defined in layout\panels-class.psm1

# --- Base Screen (top-level container) ---
class Screen : UIElement {
    [hashtable]$Services
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[UIElement]]$Panels
    hidden [System.Collections.Generic.Dictionary[string, string]]$EventSubscriptions

    Screen([string]$name, [hashtable]$services) : base($name) {
        if (-not $services) { throw [ArgumentNullException]::new("services") }
        
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
    }
    
    [void] Initialize() { }
    [void] OnEnter() { }
    [void] OnExit() { }
    [void] OnResume() { }
    [void] HandleInput([System.ConsoleKeyInfo]$key) { }

    [void] Cleanup() {
        foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -SubscriberId $kvp.Value
            }
            catch {
                Write-Log -Level Warning -Message "Failed to unregister event '$($kvp.Key)' for screen '$($this.Name)'."
            }
        }
        $this.EventSubscriptions.Clear()
        $this.Panels.Clear()
        Write-Log -Level Debug -Message "Cleaned up screen: $($this.Name)"
    }
    
    [void] AddPanel([UIElement]$panel) {
        if (-not $panel) { throw [ArgumentNullException]::new("panel") }
        $this.Panels.Add($panel)
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($eventName)) { throw [ArgumentException]::new("Event name cannot be null or empty.") }
        if (-not $action) { throw [ArgumentNullException]::new("action") }
        
        # AI: Fixed parameter name from -Action to -Handler to match event-system.psm1 function signature
        $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
        $this.EventSubscriptions[$eventName] = $subscriptionId
    }
    
    # AI: Override _RenderContent to render all panels to buffer
    hidden [void] _RenderContent() {
        # Call base implementation for buffer management
        ([UIElement]$this)._RenderContent()
        
        # Render all panels in the screen to the back-buffer
        foreach ($panel in $this.Panels) {
            if ($panel.Visible) {
                $panel.Render()
            }
        }
    }
}



####\layout\panels-class\panels-class.psm1
# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

# Import TUI primitives and base classes
#using namespace System
#using namespace System.Management.Automation
#using module '..\components\tui-primitives.psm1'
#using module '..\components\ui-classes.psm1'

#region Panel Class - Basic Layout Container
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $this.ContentX
            $child.Y = $currentY
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $currentX
            $child.Y = $this.ContentY
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        # Calculate grid dimensions
        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            # Adjust size for last column/row
            $width = if ($col -eq ($cols - 1)) { 
                $this.ContentX + $this.ContentWidth - $x 
            } else { 
                $cellWidth 
            }
            $height = if ($row -eq ($rows - 1)) { 
                $this.ContentY + $this.ContentHeight - $y 
            } else { 
                $cellHeight 
            }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    # Set border style and update content bounds
    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    # Enable/disable border
    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    # Set title
    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    # Check if point is within content area
    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    # Get content bounds as hashtable
    [hashtable] GetContentBounds() {
        return @{
            X = $this.ContentX
            Y = $this.ContentY
            Width = $this.ContentWidth
            Height = $this.ContentHeight
        }
    }
    
    # Alias for compatibility with migrated components
    [hashtable] GetContentArea() {
        return $this.GetContentBounds()
    }
    
    # Write text to buffer at specified position
    [void] WriteToBuffer([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ($null -eq $this._private_buffer) { return }
        Write-TuiText -Buffer $this._private_buffer -X $x -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
    }
    
    # Draw a box to buffer
    [void] DrawBoxToBuffer([int]$x, [int]$y, [int]$width, [int]$height, [ConsoleColor]$borderColor, [ConsoleColor]$bgColor) {
        if ($null -eq $this._private_buffer) { return }
        Write-TuiBox -Buffer $this._private_buffer -X $x -Y $y -Width $width -Height $height `
            -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
    }

    # Clear content area only
    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return }

        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    # Main render implementation - override from UIElement
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }

        # Clear entire buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this._private_buffer.Clear($bgCell)

        # Draw border if enabled
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }

        # Fill content area
        $this.ClearContent()
    }

    # Handle focus for focusable panels
    [void] OnFocus() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Cyan
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Gray
            $this.RequestRedraw()
        }
    }

    # Find first focusable child
    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    # Get all focusable children (recursive)
    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        
        return $focusable
    }

    # Basic input handling - delegate to focused child
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # If this panel can focus and is focused, handle some basic navigation
        if ($this.CanFocus -and $this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
            }
        }

        # Delegate to children
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }

        return $false
    }

    # String representation
    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}
#endregion

#region Specialized Panel Types

# Scrollable Panel - supports content larger than visible area
class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    # Constructor
    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    # Set virtual content size
    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        
        # Create virtual buffer if needed
        if ($width -gt 0 -and $height -gt 0) {
            $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        
        $this.RequestRedraw()
    }

    # Scroll to position
    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        
        $this.RequestRedraw()
    }

    # Scroll by delta
    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    # Handle scrolling input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }

        return ([Panel]$this).HandleInput($keyInfo)
    }

    # Render with scrolling support
    [void] OnRender() {
        # Render base panel
        ([Panel]$this).OnRender()

        # Render virtual content if available
        if ($null -ne $this._virtual_buffer) {
            # Create a sub-buffer view of the virtual content
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            
            # Blend visible content onto our buffer
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }

        # Draw scrollbars if enabled and needed
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    # Draw scrollbar indicators
    [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return }

        # Vertical scrollbar
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
        }

        # Horizontal scrollbar
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    # Get virtual content buffer for external drawing
    [TuiBuffer] GetVirtualBuffer() {
        return $this._virtual_buffer
    }
}

# Group Panel - collapsible panel with header
class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    # Toggle collapsed state
    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)  # Just header + border
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        
        # Update child visibility
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        
        $this.RequestRedraw()
    }

    # Handle collapse/expand input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }

        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        
        return $false
    }

    # Render with collapse indicator
    [void] OnRender() {
        ([Panel]$this).OnRender()

        # Draw collapse/expand indicator in title area
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            $this._private_buffer.SetCell(2, 0, $indicatorCell)
        }
    }
}
#endregion

# Export the Panel classes
Export-ModuleMember -Function @()



####\modules\data-manager\data-manager-class.psm1
# DataManager Class Definition
# Split from data-manager.psm1 to resolve class dependency issues

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

class DataManager {
    hidden [hashtable] $DataStore
    hidden [string] $DataFilePath
    hidden [bool] $AutoSaveEnabled = $true
    
    DataManager() {
        $this.DataStore = $script:Data
        $global:Data = $script:Data
        $this.DataFilePath = $script:DataPath
        $this.AutoSaveEnabled = $this.DataStore.Settings.AutoSave
    }

    [void] LoadData() { Load-UnifiedData }
    [void] SaveData() { Save-UnifiedData }
    
    [PmcTask] AddTask([string]$Title, [string]$Description, [string]$Priority, [string]$ProjectKey) { 
        return Add-PmcTask -Title $Title -Description $Description -Priority $Priority -Category $ProjectKey 
    }

    # AI: FIX - Changed method to accept a hashtable for flexible updates via splatting.
    [PmcTask] UpdateTask([hashtable]$UpdateParameters) {
        if (-not $UpdateParameters.ContainsKey('Task')) {
            throw [System.ArgumentException]::new("The 'UpdateParameters' hashtable must contain a 'Task' key with the task object to update.")
        }
        return Update-PmcTask @UpdateParameters
    }
    
    [void] RemoveTask([PmcTask]$Task) {
        Remove-PmcTask -Task $Task
    }
    
    [PmcTask[]] GetTasks() { 
        return Get-PmcTasks 
    }

    [PmcProject[]] GetProjects() { 
        return Get-PmcProjects 
    }
}



####\modules\data-manager\data-manager-fixed.psm1
# Data Manager Module - Fixed for dot-sourcing
Set-StrictMode -Version Latest

$script:Data = @{
    Projects = New-Object System.Collections.ArrayList
    Tasks = New-Object System.Collections.ArrayList
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    time_entries = @()
    timers = @()
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function Initialize-DataManager {
    [CmdletBinding()]
    param()
    
    $dataDirectory = Split-Path $script:DataPath -Parent
    if (-not (Test-Path $dataDirectory)) {
        New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
        Write-Log -Level Info -Message "Created data directory: $dataDirectory"
    }
    
    if (-not (Test-Path $script:BackupPath)) {
        New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
        Write-Log -Level Info -Message "Created backup directory: $script:BackupPath"
    }
    
    Load-UnifiedData
    Initialize-DataEventHandlers
    
    Write-Log -Level Info -Message "DataManager initialized successfully"
    
    # Return object that DataManager class would have created
    return [PSCustomObject]@{
        PSTypeName = 'DataManager'
        DataStore = $script:Data
        DataFilePath = $script:DataPath
        AutoSaveEnabled = $script:Data.Settings.AutoSave
    }
}

function Load-UnifiedData {
    [CmdletBinding()]
    param()
    
    if (Test-Path $script:DataPath) {
        try {
            $loadedData = Get-Content -Path $script:DataPath -Raw | ConvertFrom-Json -AsHashtable
            
            if ($loadedData -is [hashtable]) {
                if ($loadedData.Tasks) {
                    $script:Data.Tasks.Clear()
                    foreach ($taskData in $loadedData.Tasks) {
                        if ($taskData -is [hashtable]) {
                            $script:Data.Tasks.Add($taskData) | Out-Null
                        }
                    }
                    Write-Log -Level Debug -Message "Loaded $($script:Data.Tasks.Count) tasks"
                }
                
                if ($loadedData.Projects -is [hashtable]) {
                    $script:Data.Projects.Clear()
                    foreach ($projectKey in $loadedData.Projects.Keys) {
                        $projectData = $loadedData.Projects[$projectKey]
                        if ($projectData -is [hashtable]) {
                            $script:Data.Projects.Add($projectData) | Out-Null
                        }
                    }
                    Write-Log -Level Debug -Message "Loaded $($script:Data.Projects.Count) projects"
                }
                
                foreach ($key in 'TimeEntries', 'ActiveTimers', 'TodoTemplates', 'Settings', 'time_entries', 'timers') {
                    if ($loadedData.ContainsKey($key)) {
                        $script:Data[$key] = $loadedData[$key]
                    }
                }
                
                $global:Data = $script:Data
                Write-Log -Level Info -Message "Data loaded successfully from disk"
            } else {
                Write-Log -Level Warning -Message "Invalid data format in file, using defaults"
                $global:Data = $script:Data
            }
        } catch {
            Write-Log -Level Error -Message "Failed to parse data file: $_"
            $global:Data = $script:Data
        }
    } else {
        Write-Log -Level Info -Message "No existing data file found, using defaults"
        $global:Data = $script:Data
    }
    
    $script:LastSaveTime = Get-Date
}

function Save-UnifiedData {
    [CmdletBinding()]
    param()
    
    if (Test-Path $script:DataPath) {
        $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
        Copy-Item -Path $script:DataPath -Destination (Join-Path $script:BackupPath $backupName) -Force
        
        $backups = Get-ChildItem -Path $script:BackupPath -Filter "pmc-data_*.json" | Sort-Object LastWriteTime -Descending
        if ($backups.Count -gt $script:Data.Settings.BackupCount) {
            $backups | Select-Object -Skip $script:Data.Settings.BackupCount | Remove-Item -Force
        }
    }
    
    $dataToSave = @{
        Tasks = @($script:Data.Tasks)
        Projects = @{}
        TimeEntries = $script:Data.TimeEntries
        ActiveTimers = $script:Data.ActiveTimers
        TodoTemplates = $script:Data.TodoTemplates
        Settings = $script:Data.Settings
        time_entries = $script:Data.time_entries
        timers = $script:Data.timers
    }
    
    foreach ($project in $script:Data.Projects) {
        if ($project.Key) {
            $dataToSave.Projects[$project.Key] = $project
        }
    }
    
    $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $script:DataPath -Encoding UTF8
    $script:LastSaveTime = Get-Date
    $script:DataModified = $false
    Write-Log -Level Debug -Message "Data saved successfully"
}

function Initialize-DataEventHandlers {
    Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
        Publish-Event -EventName "Tasks.Changed" -Data @{
            Action = "Refreshed"
            Tasks = @($script:Data.Tasks)
        }
    }
    Write-Log -Level Debug -Message "Data event handlers initialized"
}

# Simple stub functions for now
function Add-PmcTask { param($Title) Write-Host "Add-PmcTask: $Title" }
function Update-PmcTask { param($Task) Write-Host "Update-PmcTask" }
function Remove-PmcTask { param($Task) Write-Host "Remove-PmcTask" }
function Get-PmcTasks { return @($script:Data.Tasks) }
function Get-PmcProjects { return @($script:Data.Projects) }
function Get-PmcProject { param($Key) return $null }
function Add-PmcProject { param($Project) Write-Host "Add-PmcProject" }



####\modules\data-manager\data-manager-simple.psm1
# Data Manager Module
# Unified data persistence and CRUD operations with event integration

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Module-level state variables
$script:Data = @{
    Projects = New-Object System.Collections.ArrayList
    Tasks = New-Object System.Collections.ArrayList
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    time_entries = @()
    timers = @()
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function Initialize-DataManager {
    [CmdletBinding()]
    param()
    
    $dataDirectory = Split-Path $script:DataPath -Parent
    if (-not (Test-Path $dataDirectory)) {
        New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
    }
    
    if (-not (Test-Path $script:BackupPath)) {
        New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
    }
    
    # Return a simple object for now
    return [PSCustomObject]@{
        PSTypeName = 'DataManager'
        LoadData = { Load-UnifiedData }
        SaveData = { Save-UnifiedData }
    }
}

function Load-UnifiedData {
    Write-Host "Load-UnifiedData called"
}

function Save-UnifiedData {
    Write-Host "Save-UnifiedData called"
}

# Export functions
# Export-ModuleMember -Function *  # This breaks dot-sourcing!



####\modules\data-manager\data-manager.psm1
####\modules\data-manager.psm1
# Data Manager Module
# Unified data persistence and CRUD operations with event integration

# AI: FIX - Corrected relative paths for all dependencies.
#using module '.\models.psm1'
#using module '.\logger.psm1'
#using module '.\event-system.psm1'
#using module '.\exceptions.psm1'

Set-StrictMode -Version Latest
# $ErrorActionPreference = "Stop"  # This causes silent failures during dot-sourcing

# Module-level state variables
$script:Data = @{
    Projects = New-Object System.Collections.ArrayList
    Tasks = New-Object System.Collections.ArrayList
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    time_entries = @() # underscore format for action compatibility
    timers = @()       # for action compatibility
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system, loads data, and returns a service instance.
    #>
    [CmdletBinding()]
    param()
    
    return Invoke-WithErrorHandling -Component "DataManager.Initialize" -Context "DataManager initialization" -ScriptBlock {
        $dataDirectory = Split-Path $script:DataPath -Parent
        if (-not (Test-Path $dataDirectory)) {
            New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
            Write-Log -Level Info -Message "Created data directory: $dataDirectory"
        }
        
        if (-not (Test-Path $script:BackupPath)) {
            New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
            Write-Log -Level Info -Message "Created backup directory: $script:BackupPath"
        }
        
        Load-UnifiedData
        Initialize-DataEventHandlers
        
        Write-Log -Level Info -Message "DataManager initialized successfully"
        return [DataManager]::new()
    }
}

function Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads application data from disk into strongly-typed objects.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.LoadData" -Context "Loading unified data from disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            try {
                $loadedData = Get-Content -Path $script:DataPath -Raw | ConvertFrom-Json -AsHashtable
                
                if ($loadedData -is [hashtable]) {
                    if ($loadedData.Tasks) {
                        $script:Data.Tasks.Clear()
                        foreach ($taskData in $loadedData.Tasks) {
                            if ($taskData -is [hashtable]) { 
                                $task = [PSCustomObject]$taskData
                                $task.PSObject.TypeNames.Insert(0, 'PmcTask')
                                $script:Data.Tasks.Add($task) | Out-Null
                            }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Tasks.Count) tasks as PmcTask objects"
                    }
                    
                    if ($loadedData.Projects -is [hashtable]) {
                        $script:Data.Projects.Clear()
                        foreach ($projectKey in $loadedData.Projects.Keys) {
                            $projectData = $loadedData.Projects[$projectKey]
                            if ($projectData -is [hashtable]) { $script:Data.Projects.Add([PmcProject]::FromLegacyFormat($projectData)) }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Projects.Count) projects as PmcProject objects"
                    }
                    
                    foreach ($key in 'TimeEntries', 'ActiveTimers', 'TodoTemplates', 'Settings', 'time_entries', 'timers') {
                        if ($loadedData.ContainsKey($key)) { $script:Data[$key] = $loadedData[$key] }
                    }
                    
                    $global:Data = $script:Data
                    Write-Log -Level Info -Message "Data loaded successfully from disk"
                } else {
                    Write-Log -Level Warning -Message "Invalid data format in file, using defaults"
                    $global:Data = $script:Data
                }
            } catch {
                Write-Log -Level Error -Message "Failed to parse data file: $_"
                $global:Data = $script:Data
            }
        } else {
            Write-Log -Level Info -Message "No existing data file found, using defaults"
            $global:Data = $script:Data
        }
        
        $script:LastSaveTime = Get-Date
    }
}

function Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves application data to disk with backup rotation.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.SaveData" -Context "Saving unified data to disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
            Copy-Item -Path $script:DataPath -Destination (Join-Path $script:BackupPath $backupName) -Force
            
            $backups = Get-ChildItem -Path $script:BackupPath -Filter "pmc-data_*.json" | Sort-Object LastWriteTime -Descending
            if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                $backups | Select-Object -Skip $script:Data.Settings.BackupCount | Remove-Item -Force
            }
        }
        
        $dataToSave = @{
            Tasks = @($script:Data.Tasks | ForEach-Object { $_.ToLegacyFormat() })
            Projects = @{}
            TimeEntries = $script:Data.TimeEntries
            ActiveTimers = $script:Data.ActiveTimers
            TodoTemplates = $script:Data.TodoTemplates
            Settings = $script:Data.Settings
            time_entries = $script:Data.time_entries
            timers = $script:Data.timers
        }
        
        foreach ($project in $script:Data.Projects) { $dataToSave.Projects[$project.Key] = $project.ToLegacyFormat() }
        
        $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $script:DataPath -Encoding UTF8
        $script:LastSaveTime = Get-Date; $script:DataModified = $false
        Write-Log -Level Debug -Message "Data saved successfully"
    }
}

#region Task Management Functions

function Add-PmcTask {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [ValidateNotNullOrEmpty()] [string]$Title,
        [string]$Description = "",
        [ValidateSet("low", "medium", "high")] [string]$Priority = "medium",
        [string]$Category = "General",
        [string]$DueDate = ""
    )
    
    return Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task" -ScriptBlock {
        if ([string]::IsNullOrWhiteSpace($Title)) { throw [StateMutationException]::new("Task title cannot be empty", @{ Title = $Title }) }
        
        $taskPriority = [TaskPriority]::$Priority
        $newTask = [PmcTask]::new($Title, $Description, $taskPriority, $Category)
        
        if ($DueDate -and $DueDate -ne "N/A") {
            try { $newTask.DueDate = [datetime]::Parse($DueDate) } catch { Write-Log -Level Warning -Message "Invalid due date format: $DueDate" }
        }
        
        $script:Data.Tasks.Add($newTask); $script:DataModified = $true
        Write-Log -Level Info -Message "Created task '$($newTask.Title)' with ID $($newTask.Id)"
        
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        
        Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Created"; TaskId = $newTask.Id; Task = $newTask }
        return $newTask
    }
}

function Update-PmcTask {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [PmcTask]$Task,
        [string]$Title, [string]$Description, [ValidateSet("low", "medium", "high")] [string]$Priority,
        [string]$Category, [string]$DueDate, [bool]$Completed, [ValidateRange(0, 100)] [int]$Progress
    )
    
    return Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating task" -ScriptBlock {
        $managedTask = $script:Data.Tasks.Find({$_.Id -eq $Task.Id})
        if (-not $managedTask) { throw [StateMutationException]::new("Task not found in data store", @{ TaskId = $Task.Id }) }
        
        $updatedFields = @()
        if ($PSBoundParameters.ContainsKey('Title')) { $managedTask.Title = $Title.Trim(); $updatedFields += "Title" }
        if ($PSBoundParameters.ContainsKey('Description')) { $managedTask.Description = $Description; $updatedFields += "Description" }
        if ($PSBoundParameters.ContainsKey('Priority')) { $managedTask.Priority = [TaskPriority]::$Priority; $updatedFields += "Priority" }
        if ($PSBoundParameters.ContainsKey('Category')) { $managedTask.ProjectKey = $Category; $managedTask.Category = $Category; $updatedFields += "Category" }
        if ($PSBoundParameters.ContainsKey('DueDate')) {
            try { $managedTask.DueDate = ($DueDate -and $DueDate -ne "N/A") ? [datetime]::Parse($DueDate) : $null } catch { Write-Log -Level Warning -Message "Invalid due date format: $DueDate" }
            $updatedFields += "DueDate"
        }
        if ($PSBoundParameters.ContainsKey('Progress')) { $managedTask.UpdateProgress($Progress); $updatedFields += "Progress" }
        if ($PSBoundParameters.ContainsKey('Completed')) {
            if ($Completed) { $managedTask.Complete() } else { $managedTask.Status = [TaskStatus]::Pending; $managedTask.Completed = $false; $managedTask.Progress = 0 }
            $updatedFields += "Completed"
        }
        
        $managedTask.UpdatedAt = [datetime]::Now; $script:DataModified = $true
        Write-Log -Level Info -Message "Updated task $($managedTask.Id) - Fields: $($updatedFields -join ', ')"
        
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        
        Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Updated"; TaskId = $managedTask.Id; Task = $managedTask; UpdatedFields = $updatedFields }
        return $managedTask
    }
}

function Remove-PmcTask {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [PmcTask]$Task)
    
    return Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task" -ScriptBlock {
        $taskToRemove = $script:Data.Tasks.Find({$_.Id -eq $Task.Id})
        if ($taskToRemove) {
            $script:Data.Tasks.Remove($taskToRemove) | Out-Null; $script:DataModified = $true
            Write-Log -Level Info -Message "Deleted task $($Task.Id)"
            if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Deleted"; TaskId = $Task.Id; Task = $Task }
            return $true
        }
        Write-Log -Level Warning -Message "Task not found with ID $($Task.Id)"; return $false
    }
}

function Get-PmcTasks {
    [CmdletBinding()]
    param([bool]$Completed, [ValidateSet("low", "medium", "high")] [string]$Priority, [string]$Category)
    
    return Invoke-WithErrorHandling -Component "DataManager.GetTasks" -Context "Retrieving tasks" -ScriptBlock {
        $tasks = $script:Data.Tasks
        if ($PSBoundParameters.ContainsKey('Completed')) { $tasks = $tasks | Where-Object { $_.Completed -eq $Completed } }
        if ($Priority) { $priorityEnum = [TaskPriority]::$Priority; $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum } }
        if ($Category) { $tasks = $tasks | Where-Object { $_.ProjectKey -eq $Category -or $_.Category -eq $Category } }
        return @($tasks)
    }
}

#endregion

#region Project Management Functions

function Get-PmcProjects { [CmdletBinding()] param() return @($script:Data.Projects) }
function Get-PmcProject { [CmdletBinding()] param([Parameter(Mandatory)] [string]$Key) return $script:Data.Projects.Find({$_.Key -eq $Key}) }

function Add-PmcProject {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [PmcProject]$Project)
    
    return Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding project" -ScriptBlock {
        if ($script:Data.Projects.Exists({$_.Key -eq $Project.Key})) { throw [StateMutationException]::new("Project with key '$($Project.Key)' already exists", @{ ProjectKey = $Project.Key }) }
        
        $script:Data.Projects.Add($Project); $script:DataModified = $true
        Write-Log -Level Info -Message "Created project '$($Project.Name)' with key $($Project.Key)"
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Created"; ProjectKey = $Project.Key; Project = $Project }
        return $Project
    }
}

#endregion

#region DataManager Class Definition

# DataManager class moved to data-manager-class.psm1 to resolve dependency issues

#endregion

#region Private Helper Functions

function Initialize-DataEventHandlers {
    Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -Context "Initializing data event handlers" -ScriptBlock {
        $null = Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Refreshed"; Tasks = @($script:Data.Tasks) }
        }
        Write-Log -Level Debug -Message "Data event handlers initialized"
    }
}

#endregion
# Export-ModuleMember -Function *  # This breaks dot-sourcing!


####\modules\data-manager-class\data-manager-class.psm1
# DataManager Class Definition
# Split from data-manager.psm1 to resolve class dependency issues

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

class DataManager {
    hidden [hashtable] $DataStore
    hidden [string] $DataFilePath
    hidden [bool] $AutoSaveEnabled = $true
    
    DataManager() {
        $this.DataStore = $script:Data
        $global:Data = $script:Data
        $this.DataFilePath = $script:DataPath
        $this.AutoSaveEnabled = $this.DataStore.Settings.AutoSave
    }

    [void] LoadData() { Load-UnifiedData }
    [void] SaveData() { Save-UnifiedData }
    
    [PmcTask] AddTask([string]$Title, [string]$Description, [string]$Priority, [string]$ProjectKey) { 
        return Add-PmcTask -Title $Title -Description $Description -Priority $Priority -Category $ProjectKey 
    }

    # AI: FIX - Changed method to accept a hashtable for flexible updates via splatting.
    [PmcTask] UpdateTask([hashtable]$UpdateParameters) {
        if (-not $UpdateParameters.ContainsKey('Task')) {
            throw [System.ArgumentException]::new("The 'UpdateParameters' hashtable must contain a 'Task' key with the task object to update.")
        }
        return Update-PmcTask @UpdateParameters
    }
    
    [void] RemoveTask([PmcTask]$Task) {
        Remove-PmcTask -Task $Task
    }
    
    [PmcTask[]] GetTasks() { 
        return Get-PmcTasks 
    }

    [PmcProject[]] GetProjects() { 
        return Get-PmcProjects 
    }
}



####\modules\dialog-system-class\dialog-system-class.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================

#using namespace System.Management.Automation
#using module '..\components\ui-classes.psm1'
#using module '..\components\tui-primitives.psm1'
#using module '.\exceptions.psm1'
#using module '.\logger.psm1'
#using module '.\event-system.psm1'

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Base Dialog Class - properly inheriting from UIElement
class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    [ConsoleColor] $BorderColor = [ConsoleColor]::Cyan
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [ConsoleColor] $MessageColor = [ConsoleColor]::Gray
    
    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 50
        $this.Height = 10
    }
    
    [void] Show() {
        $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
        $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 2)
        if ($null -eq $this._private_buffer -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
            $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        }
        $script:DialogState.CurrentDialog = $this
        # AI: FIX - Changed to event-based refresh to break circular dependency
        Publish-Event -EventName "TUI.RefreshRequested"
    }
    
    [void] Close() {
        $script:DialogState.CurrentDialog = $null
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        }
        # AI: FIX - Changed to event-based refresh to break circular dependency
        Publish-Event -EventName "TUI.RefreshRequested"
    }
    
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
            -BorderStyle "Single" -BorderColor $this.BorderColor -BackgroundColor [ConsoleColor]::Black -Title $this.Title
        if (-not [string]::IsNullOrWhiteSpace($this.Message)) { $this.RenderMessage() }
        $this.RenderDialogContent()
    }
    
    hidden [void] RenderMessage() {
        $messageY = 2; $messageX = 2; $maxWidth = $this.Width - 4
        $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
        foreach ($line in $wrappedLines) {
            if ($messageY -ge ($this.Height - 3)) { break }
            Write-TuiText -Buffer $this._private_buffer -X $messageX -Y $messageY -Text $line -ForegroundColor $this.MessageColor
            $messageY++
        }
    }
    
    [void] RenderDialogContent() { }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) { $this.OnCancel(); return $true }
        return $false
    }
    
    [void] OnConfirm() { $this.Close() }
    [void] OnCancel() { $this.Close() }
}

class AlertDialog : Dialog {
    [string] $ButtonText = "OK"
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title; $this.Message = $message; $this.Height = 10
        $this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))
    }
    [void] RenderDialogContent() {
        $buttonY = $this.Height - 2; $buttonLabel = "[ $($this.ButtonText) ]"
        $buttonX = [Math]::Floor(($this.Width - $buttonLabel.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY -Text $buttonLabel -ForegroundColor ([ConsoleColor]::Yellow)
    }
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) { $this.OnConfirm(); return $true }
        return ([Dialog]$this).HandleInput($key)
    }
}

class ConfirmDialog : Dialog {
    [scriptblock] $OnConfirmAction; [scriptblock] $OnCancelAction
    [string[]] $Buttons = @("Yes", "No"); [int] $SelectedButton = 0
    ConfirmDialog([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) : base("ConfirmDialog") {
        $this.Title = $title; $this.Message = $message; $this.OnConfirmAction = $onConfirm; $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10)); $this.Height = 10
    }
    [void] RenderDialogContent() {
        $buttonY = $this.Height - 3; $totalButtonWidth = ($this.Buttons.Count * 12) + (($this.Buttons.Count - 1) * 2)
        $buttonX = [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        for ($i = 0; $i -lt $this.Buttons.Count; $i++) {
            $isSelected = ($i -eq $this.SelectedButton)
            $buttonLabel = if ($isSelected) { "[ $($this.Buttons[$i]) ]" } else { "  $($this.Buttons[$i])  " }
            $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY -Text $buttonLabel -ForegroundColor $color
            $buttonX += 14
        }
    }
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) { $this.SelectedButton = [Math]::Max(0, $this.SelectedButton - 1); $this.RequestRedraw(); return $true }
            ([ConsoleKey]::RightArrow) { $this.SelectedButton = [Math]::Min($this.Buttons.Count - 1, $this.SelectedButton + 1); $this.RequestRedraw(); return $true }
            ([ConsoleKey]::Tab) { $this.SelectedButton = ($this.SelectedButton + 1) % $this.Buttons.Count; $this.RequestRedraw(); return $true }
            ([ConsoleKey]::Enter) { if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }; return $true }
            ([ConsoleKey]::Spacebar) { if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }; return $true }
        }
        return ([Dialog]$this).HandleInput($key)
    }
    [void] OnConfirm() { $this.Close(); if ($this.OnConfirmAction) { Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnConfirm" -ScriptBlock $this.OnConfirmAction } }
    [void] OnCancel() { $this.Close(); if ($this.OnCancelAction) { Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction } }
}

class InputDialog : Dialog {
    [string] $Prompt = ""
    [string] $InputValue = ""
    [int] $CursorPosition = 0
    [scriptblock] $OnSubmitAction
    [scriptblock] $OnCancelAction
    
    InputDialog([string]$title, [string]$prompt, [scriptblock]$onSubmit, [scriptblock]$onCancel) : base("InputDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.OnSubmitAction = $onSubmit
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $prompt.Length + 20))
        $this.Height = 12
    }
    
    [void] SetDefaultValue([string]$value) {
        $this.InputValue = $value
        $this.CursorPosition = $value.Length
    }
    
    [void] RenderDialogContent() {
        # Render prompt
        $promptY = 3
        $promptX = 4
        Write-TuiText -Buffer $this._private_buffer -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor [ConsoleColor]::White
        
        # Render input box
        $inputY = 5
        $inputX = 4
        $inputWidth = $this.Width - 8
        
        # Input box border
        Write-TuiBox -Buffer $this._private_buffer -X $inputX -Y $inputY -Width $inputWidth -Height 3 `
            -BorderStyle "Single" -BorderColor [ConsoleColor]::DarkGray
        
        # Input value
        $displayValue = $this.InputValue
        if ($displayValue.Length -gt ($inputWidth - 3)) {
            $displayValue = $displayValue.Substring($displayValue.Length - ($inputWidth - 3))
        }
        Write-TuiText -Buffer $this._private_buffer -X ($inputX + 1) -Y ($inputY + 1) -Text $displayValue `
            -ForegroundColor [ConsoleColor]::Yellow
        
        # Render buttons
        $buttonY = $this.Height - 3
        $okLabel = "[ OK ]"
        $cancelLabel = "[ Cancel ]"
        $totalWidth = $okLabel.Length + $cancelLabel.Length + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        Write-TuiText -Buffer $this._private_buffer -X $startX -Y $buttonY -Text $okLabel `
            -ForegroundColor [ConsoleColor]::Green
        Write-TuiText -Buffer $this._private_buffer -X ($startX + $okLabel.Length + 4) -Y $buttonY `
            -Text $cancelLabel -ForegroundColor [ConsoleColor]::Gray
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) {
                $this.OnSubmit()
                return $true
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
                return $true
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.InputValue.Length) {
                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition, 1)
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.InputValue.Length) {
                    $this.CursorPosition++
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Home) {
                $this.CursorPosition = 0
                $this.RequestRedraw()
                return $true
            }
            ([ConsoleKey]::End) {
                $this.CursorPosition = $this.InputValue.Length
                $this.RequestRedraw()
                return $true
            }
            default {
                if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or 
                    $key.KeyChar -in @(' ', '.', '-', '_', '@', '!', '?', ',', ';', ':', '/', '\', '(', ')', '[', ']', '{', '}')) {
                    $this.InputValue = $this.InputValue.Insert($this.CursorPosition, $key.KeyChar)
                    $this.CursorPosition++
                    $this.RequestRedraw()
                    return $true
                }
            }
        }
        return ([Dialog]$this).HandleInput($key)
    }
    
    [void] OnSubmit() {
        $this.Close()
        if ($this.OnSubmitAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnSubmit" -ScriptBlock {
                & $this.OnSubmitAction $this.InputValue
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

class ProgressDialog : Dialog {
    [int] $PercentComplete = 0
    [string] $StatusText = ""
    [bool] $ShowCancel = $false
    [bool] $IsCancelled = $false
    
    ProgressDialog([string]$title, [string]$message) : base("ProgressDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Width = 60
        $this.Height = 10
    }
    
    [void] UpdateProgress([int]$percent, [string]$status = "") {
        $this.PercentComplete = [Math]::Max(0, [Math]::Min(100, $percent))
        if ($status) { $this.StatusText = $status }
        $this.RequestRedraw()
    }
    
    [void] RenderDialogContent() {
        # Progress bar
        $barY = 4
        $barX = 4
        $barWidth = $this.Width - 8
        $filledWidth = [Math]::Floor($barWidth * ($this.PercentComplete / 100.0))
        
        # Bar background
        Write-TuiText -Buffer $this._private_buffer -X $barX -Y $barY `
            -Text ('─' * $barWidth) -ForegroundColor [ConsoleColor]::DarkGray
        
        # Filled portion
        if ($filledWidth -gt 0) {
            Write-TuiText -Buffer $this._private_buffer -X $barX -Y $barY `
                -Text ('█' * $filledWidth) -ForegroundColor [ConsoleColor]::Green
        }
        
        # Percentage text
        $percentText = "$($this.PercentComplete)%"
        $percentX = [Math]::Floor(($this.Width - $percentText.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $percentX -Y ($barY + 1) `
            -Text $percentText -ForegroundColor [ConsoleColor]::White
        
        # Status text
        if ($this.StatusText) {
            $statusY = $barY + 3
            $maxStatusWidth = $this.Width - 8
            if ($this.StatusText.Length -gt $maxStatusWidth) {
                $displayStatus = $this.StatusText.Substring(0, $maxStatusWidth - 3) + "..."
            } else {
                $displayStatus = $this.StatusText
            }
            $statusX = [Math]::Floor(($this.Width - $displayStatus.Length) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $statusX -Y $statusY `
                -Text $displayStatus -ForegroundColor [ConsoleColor]::Gray
        }
        
        # Cancel button if enabled
        if ($this.ShowCancel) {
            $buttonY = $this.Height - 2
            $cancelLabel = "[ Cancel ]"
            $buttonX = [Math]::Floor(($this.Width - $cancelLabel.Length) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY `
                -Text $cancelLabel -ForegroundColor [ConsoleColor]::Yellow
        }
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($this.ShowCancel -and $key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            $this.IsCancelled = $true
            $this.Close()
            return $true
        }
        return $false
    }
}

class ListDialog : Dialog {
    [string] $Prompt = ""
    [string[]] $Items = @()
    [int] $SelectedIndex = 0
    [int] $ScrollOffset = 0
    [int] $VisibleItems = 10
    [bool] $AllowMultiple = $false
    [System.Collections.Generic.HashSet[int]] $SelectedIndices
    [scriptblock] $OnSelectAction
    [scriptblock] $OnCancelAction
    
    ListDialog([string]$title, [string]$prompt, [string[]]$items, [scriptblock]$onSelect, [scriptblock]$onCancel) : base("ListDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.Items = $items
        $this.OnSelectAction = $onSelect
        $this.OnCancelAction = $onCancel
        $this.SelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
        
        # Calculate dimensions
        $maxItemWidth = ($items | Measure-Object -Property Length -Maximum).Maximum
        $this.Width = [Math]::Min(80, [Math]::Max(40, $maxItemWidth + 10))
        $this.VisibleItems = [Math]::Min(10, $items.Count)
        $this.Height = $this.VisibleItems + 8
    }
    
    [void] RenderDialogContent() {
        # Render prompt
        if ($this.Prompt) {
            $promptY = 2
            $promptX = 4
            Write-TuiText -Buffer $this._private_buffer -X $promptX -Y $promptY `
                -Text $this.Prompt -ForegroundColor [ConsoleColor]::White
        }
        
        # List area
        $listY = 4
        $listX = 4
        $listWidth = $this.Width - 8
        
        # Render visible items
        $endIndex = [Math]::Min($this.ScrollOffset + $this.VisibleItems, $this.Items.Count)
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $relativeY = $listY + ($i - $this.ScrollOffset)
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex)
            $isChecked = $this.SelectedIndices.Contains($i)
            
            # Truncate if too long
            if ($item.Length -gt ($listWidth - 4)) {
                $item = $item.Substring(0, $listWidth - 7) + "..."
            }
            
            # Format item
            $prefix = ""
            if ($this.AllowMultiple) {
                $prefix = if ($isChecked) { "[x] " } else { "[ ] " }
            }
            $displayText = "$prefix$item"
            
            # Colors
            $fg = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            $bg = if ($isSelected) { [ConsoleColor]::DarkGray } else { [ConsoleColor]::Black }
            
            # Clear line and write
            Write-TuiText -Buffer $this._private_buffer -X $listX -Y $relativeY `
                -Text (' ' * $listWidth) -BackgroundColor $bg
            Write-TuiText -Buffer $this._private_buffer -X $listX -Y $relativeY `
                -Text $displayText -ForegroundColor $fg -BackgroundColor $bg
        }
        
        # Scroll indicators
        if ($this.ScrollOffset -gt 0) {
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 5) -Y $listY `
                -Text "▲" -ForegroundColor [ConsoleColor]::DarkGray
        }
        if ($endIndex -lt $this.Items.Count) {
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 5) -Y ($listY + $this.VisibleItems - 1) `
                -Text "▼" -ForegroundColor [ConsoleColor]::DarkGray
        }
        
        # Instructions
        $instructY = $this.Height - 3
        $instructions = if ($this.AllowMultiple) { 
            "Space: Toggle, Enter: Confirm, Esc: Cancel" 
        } else { 
            "Enter: Select, Esc: Cancel" 
        }
        $instructX = [Math]::Floor(($this.Width - $instructions.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $instructX -Y $instructY `
            -Text $instructions -ForegroundColor [ConsoleColor]::DarkGray
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    if ($this.SelectedIndex -lt $this.ScrollOffset) {
                        $this.ScrollOffset = $this.SelectedIndex
                    }
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                    $this.SelectedIndex++
                    if ($this.SelectedIndex -ge ($this.ScrollOffset + $this.VisibleItems)) {
                        $this.ScrollOffset = $this.SelectedIndex - $this.VisibleItems + 1
                    }
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Spacebar) {
                if ($this.AllowMultiple) {
                    if ($this.SelectedIndices.Contains($this.SelectedIndex)) {
                        [void]$this.SelectedIndices.Remove($this.SelectedIndex)
                    } else {
                        [void]$this.SelectedIndices.Add($this.SelectedIndex)
                    }
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                $this.OnSelect()
                return $true
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
                return $true
            }
        }
        return $false
    }
    
    [void] OnSelect() {
        $this.Close()
        if ($this.OnSelectAction) {
            if ($this.AllowMultiple) {
                $selectedItems = @()
                foreach ($index in $this.SelectedIndices) {
                    $selectedItems += $this.Items[$index]
                }
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction $selectedItems
                }
            } else {
                $selectedItem = $this.Items[$this.SelectedIndex]
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction $selectedItem
                }
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ListDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Helper function for word wrapping
function Get-WordWrappedLines {
    param([string]$Text, [int]$MaxWidth)
    
    $lines = @()
    $words = $Text -split '\s+'
    $currentLine = ""
    
    foreach ($word in $words) {
        if ($currentLine.Length -eq 0) {
            $currentLine = $word
        } elseif (($currentLine.Length + 1 + $word.Length) -le $MaxWidth) {
            $currentLine += " " + $word
        } else {
            $lines += $currentLine
            $currentLine = $word
        }
    }
    
    if ($currentLine.Length -gt 0) {
        $lines += $currentLine
    }
    
    return $lines
}

$script:DialogState = @{ CurrentDialog = $null; DialogStack = [System.Collections.Stack]::new() }

function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        Subscribe-Event -EventName "Confirm.Request" -Handler { param($EventData)
            $params = $EventData.Data; Show-ConfirmDialog @params }
        Subscribe-Event -EventName "Alert.Show" -Handler { param($EventData)
            $params = $EventData.Data; Show-AlertDialog @params }
        Subscribe-Event -EventName "Input.Request" -Handler { param($EventData)
            $params = $EventData.Data; Show-InputDialog @params }
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

function Show-AlertDialog { param([string]$Title="Alert", [string]$Message); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock { ([AlertDialog]::new($Title, $Message)).Show() } }
function Show-ConfirmDialog { param([string]$Title="Confirm", [string]$Message, [scriptblock]$OnConfirm, [scriptblock]$OnCancel={}); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock { ([ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)).Show() } }
function Show-InputDialog { param([string]$Title="Input", [string]$Prompt, [string]$DefaultValue="", [scriptblock]$OnSubmit, [scriptblock]$OnCancel={}); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock { $d = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel); if ($DefaultValue) { $d.SetDefaultValue($DefaultValue) }; $d.Show() } }
function Show-ProgressDialog { param([string]$Title="Progress", [string]$Message="Processing...", [int]$PercentComplete=0, [switch]$ShowCancel); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock { $d = [ProgressDialog]::new($Title, $Message); $d.PercentComplete = $PercentComplete; $d.ShowCancel = $ShowCancel; $d.Show(); return $d } }
function Show-ListDialog { param([string]$Title="Select Item", [string]$Prompt="Choose an item:", [string[]]$Items, [scriptblock]$OnSelect, [scriptblock]$OnCancel={}, [switch]$AllowMultiple); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock { $d = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel); $d.AllowMultiple = $AllowMultiple; $d.Show() } }
function Close-TuiDialog { Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock { if ($script:DialogState.CurrentDialog) { $script:DialogState.CurrentDialog.Close() } } }

Export-ModuleMember -Function 'Initialize-DialogSystem', 'Show-AlertDialog', 'Show-ConfirmDialog', 'Show-InputDialog', 'Show-ProgressDialog', 'Show-ListDialog', 'Close-TuiDialog'


####\modules\event-system\event-system.psm1
# Event System Module
# Provides pub/sub event functionality for decoupled communication

# AI: FIX - Corrected relative paths for all dependencies.
#using module '.\exceptions.psm1'
#using module '.\logger.psm1'

$script:EventHandlers = @{}
$script:EventHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxEventHistory = 100

function Initialize-EventSystem {
    <# .SYNOPSIS Initializes the event system for the application #>
    Invoke-WithErrorHandling -Component "EventSystem.Initialize" -Context "Initializing event system" -ScriptBlock {
        $script:EventHandlers = @{}
        $script:EventHistory = [System.Collections.Generic.List[object]]::new()
        Write-Verbose "Event system initialized"
    }
}

function Publish-Event {
    <#
    .SYNOPSIS Publishes an event to all registered handlers
    .PARAMETER EventName The name of the event to publish
    .PARAMETER Data Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter()] [hashtable]$Data = @{}
    )
    Invoke-WithErrorHandling -Component "EventSystem.PublishEvent" -Context "Publishing event '$EventName'" -ScriptBlock {
        $eventRecord = @{ EventName = $EventName; Data = $Data; Timestamp = Get-Date }
        
        $script:EventHistory.Add($eventRecord)
        if ($script:EventHistory.Count -gt $script:MaxEventHistory) { $script:EventHistory.RemoveAt(0) }
        
        if ($script:EventHandlers.ContainsKey($EventName)) {
            foreach ($handler in $script:EventHandlers[$EventName]) {
                try {
                    $eventData = @{ EventName = $EventName; Data = $Data; Timestamp = $eventRecord.Timestamp }
                    & $handler.ScriptBlock -EventData $eventData
                } catch {
                    Write-Log -Level Warning -Message "Error in event handler for '$EventName' (ID: $($handler.HandlerId)): $_"
                }
            }
        }
        Write-Verbose "Published event: $EventName"
    } -AdditionalData @{ EventName = $EventName; EventData = $Data }
}

function Subscribe-Event {
    <#
    .SYNOPSIS Subscribes to an event with a handler
    .PARAMETER EventName The name of the event to subscribe to
    .PARAMETER Handler The script block to execute
    .PARAMETER HandlerId Optional unique identifier for the handler
    .PARAMETER Source Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter(Mandatory)] [scriptblock]$Handler,
        [Parameter()] [string]$HandlerId = [Guid]::NewGuid().ToString(),
        [Parameter()] [string]$Source
    )
    return Invoke-WithErrorHandling -Component "EventSystem.SubscribeEvent" -Context "Subscribing to event '$EventName'" -ScriptBlock {
        if (-not $script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers[$EventName] = @() }
        
        $handlerInfo = @{ HandlerId = $HandlerId; ScriptBlock = $Handler; SubscribedAt = Get-Date; Source = $Source }
        $script:EventHandlers[$EventName] += $handlerInfo
        
        Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
        return $HandlerId
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId; Source = $Source }
}

function Unsubscribe-Event {
    <#
    .SYNOPSIS Unsubscribes from an event
    .PARAMETER EventName The name of the event (optional if HandlerId is provided)
    .PARAMETER HandlerId The unique identifier of the handler to remove
    #>
    param(
        [Parameter()] [string]$EventName,
        [Parameter(Mandatory)] [string]$HandlerId
    )
    Invoke-WithErrorHandling -Component "EventSystem.UnsubscribeEvent" -Context "Unsubscribing from event '$EventName' (Handler: $HandlerId)" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($script:EventHandlers[$EventName].Count -eq 0) { $script:EventHandlers.Remove($EventName) }
                Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
            }
        } else {
            $found = $false
            foreach ($eventKey in @($script:EventHandlers.Keys)) {
                $handlers = $script:EventHandlers[$eventKey]
                $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($newHandlers.Count -lt $handlers.Count) {
                    $found = $true
                    $script:EventHandlers[$eventKey] = if ($newHandlers.Count -eq 0) { $script:EventHandlers.Remove($eventKey) } else { $newHandlers }
                    Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"; break
                }
            }
            if (-not $found) { Write-Warning "Handler ID not found: $HandlerId" }
        }
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId }
}

function Get-EventHandlers {
    <# .SYNOPSIS Gets all registered event handlers #>
    param([Parameter()] [string]$EventName)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHandlers" -Context "Getting event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { return $script:EventHandlers[$EventName] ?? @() }
        else { return $script:EventHandlers }
    }
}

function Clear-EventHandlers {
    <# .SYNOPSIS Clears all event handlers for a specific event or all events #>
    param([Parameter()] [string]$EventName)
    Invoke-WithErrorHandling -Component "EventSystem.ClearEventHandlers" -Context "Clearing event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { if ($script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers.Remove($EventName); Write-Verbose "Cleared handlers for event: $EventName" } } 
        else { $script:EventHandlers = @{}; Write-Verbose "Cleared all event handlers" }
    }
}

function Get-EventHistory {
    <# .SYNOPSIS Gets the event history #>
    param([Parameter()] [string]$EventName, [Parameter()] [int]$Last = 0)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHistory" -Context "Getting event history for '$EventName'" -ScriptBlock {
        $history = $script:EventHistory
        if ($EventName) { $history = $history | Where-Object { $_.EventName -eq $EventName } }
        if ($Last -gt 0) { $history = $history | Select-Object -Last $Last }
        return $history
    }
}

function Remove-ComponentEventHandlers {
    <# .SYNOPSIS Removes all event handlers associated with a specific component #>
    param([Parameter(Mandatory)] [string]$ComponentId)
    Invoke-WithErrorHandling -Component "EventSystem.RemoveComponentEventHandlers" -Context "Removing event handlers for component '$ComponentId'" -ScriptBlock {
        $removedCount = 0
        foreach ($eventName in @($script:EventHandlers.Keys)) {
            $initialCount = $script:EventHandlers[$eventName].Count
            $script:EventHandlers[$eventName] = @($script:EventHandlers[$eventName] | Where-Object { $_.Source -ne $ComponentId })
            $removedCount += $initialCount - $script:EventHandlers[$eventName].Count
            if ($script:EventHandlers[$eventName].Count -eq 0) { $script:EventHandlers.Remove($eventName) }
        }
        Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
    }
}

Export-ModuleMember -Function 'Initialize-EventSystem', 'Publish-Event', 'Subscribe-Event', 'Unsubscribe-Event', 'Get-EventHandlers', 'Clear-EventHandlers', 'Get-EventHistory', 'Remove-ComponentEventHandlers'


####\modules\exceptions\exceptions.psm1

# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
#
#using module '.\logger.psm1'
# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

try {
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException) {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
    }
} catch {
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}

# ------------------------------------------------------------------------------
# Error Handling Wrapper
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Component,
        
        [Parameter(Mandatory)]
        [string]$Context,
        
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock
    )
    
    try {
        return & $ScriptBlock
    }
    catch {
        Write-Log -Level Error -Message "$Context failed: $_" -Component $Component
        throw
    }
}

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

function _Identify-HeliosComponent {
    param([System.Management.Automation.ErrorRecord]$ErrorRecord)
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName ?? (Get-PSCallStack | Where-Object ScriptName | Select-Object -First 1).ScriptName
        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        $componentMap = @{
            'tui-engine' = 'TUI Engine'; 'navigation' = 'Navigation Service'; 'keybindings' = 'Keybinding Service'
            'task-service' = 'Task Service'; 'helios-components' = 'Helios UI Components'; 'helios-panels' = 'Helios UI Panels'
            'dashboard-screen' = 'Dashboard Screen'; 'task-screen' = 'Task Screen'; 'exceptions' = 'Exception Module'
            'logger' = 'Logger Module'; 'Start-PMCTerminal' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") { return $componentMap[$pattern] }
        }
        return "Unknown ($fileName)"
    } catch { return "Component Identification Failed" }
}

function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp = Get-Date -Format "o"; Summary = $ErrorRecord.Exception.Message; Type = $ErrorRecord.Exception.GetType().FullName
            Category = $ErrorRecord.CategoryInfo.Category.ToString(); TargetObject = $ErrorRecord.TargetObject
            ScriptName = $ErrorRecord.InvocationInfo.ScriptName; LineNumber = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line = $ErrorRecord.InvocationInfo.Line; PositionMessage = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace = $ErrorRecord.Exception.StackTrace; InnerExceptions = @(); AdditionalContext = $AdditionalContext
            SystemContext = @{
                ProcessId = $PID; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{ Message = $innerEx.Message; Type = $innerEx.GetType().FullName; StackTrace = $innerEx.StackTrace }
            $innerEx = $innerEx.InnerException
        }
        return $errorInfo
    } catch {
        return [PSCustomObject]@{ Timestamp = Get-Date -Format "o"; Summary = "CRITICAL: Error analysis failed."; OriginalError = $ErrorRecord.Exception.Message; AnalysisError = $_.Exception.Message; Type = "ErrorAnalysisFailure" }
    }
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$Component,
        [Parameter(Mandatory)] [string]$Context,
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [hashtable]$AdditionalData = @{}
    )

    if (-not $ScriptBlock) { throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null." }
    $Component = [string]::IsNullOrWhiteSpace($Component) ? "Unknown Component" : $Component
    $Context = [string]::IsNullOrWhiteSpace($Context) ? "Unknown Operation" : $Context

    try {
        return (& $ScriptBlock)
    }
    catch {
        $originalErrorRecord = $_
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = ($Component -ne "Unknown Component") ? $Component : $identifiedComponent

        $errorContext = @{ Operation = $Context }
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)" -Data $detailedError
        }

        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) { $script:ErrorHistory.RemoveAt(0) }

        $contextHashtable = @{
            Operation = $Context; Timestamp = $detailedError.Timestamp; LineNumber = $detailedError.LineNumber
            ScriptName = $detailedError.ScriptName ?? "Unknown"
        }
        
        foreach ($key in $AdditionalData.Keys) {
            $value = $AdditionalData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) { $contextHashtable[$key] = $value }
        }
        
        $heliosException = New-Object Helios.HeliosException($originalErrorRecord.Exception.Message, $finalComponent, $contextHashtable, $originalErrorRecord.Exception)
        throw $heliosException
    }
}

function Get-ErrorHistory {
    [CmdletBinding()]
    param([int]$Count = 25)
    
    $total = $script:ErrorHistory.Count
    if ($Count -ge $total) { return $script:ErrorHistory }
    $start = $total - $Count
    return $script:ErrorHistory.GetRange($start, $Count)
}

Export-ModuleMember -Function 'Invoke-WithErrorHandling', 'Get-ErrorHistory'


####\modules\logger\logger.psm1

# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------
$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------
function ConvertTo-SerializableObject {
    param([object]$Object)
    if ($null -eq $Object) { return $null }
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'
    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)
        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) { [void]$visited.Add($InputObject) }
        switch ($InputObject.GetType().Name) {
            'Hashtable' { $r = @{}; foreach ($k in $InputObject.Keys) { try { $r[$k] = Convert-Internal $InputObject[$k] ($Depth+1) } catch { $r[$k] = "<Err>" } }; return $r }
            'PSCustomObject' { $r = @{}; foreach ($p in $InputObject.PSObject.Properties) { try { if ($p.MemberType -ne 'ScriptMethod') { $r[$p.Name] = Convert-Internal $p.Value ($Depth+1) } } catch { $r[$p.Name] = "<Err>" } }; return $r }
            'Object[]' { $r = @(); for ($i=0; $i -lt [Math]::Min($InputObject.Count,10); $i++) { try { $r += Convert-Internal $InputObject[$i] ($Depth+1) } catch { $r += "<Err>" } }; if($InputObject.Count -gt 10) { $r += "<...>" }; return $r }
            default { try { if ($InputObject -is [ValueType] -or $InputObject -is [string] -or $InputObject -is [datetime]) { return $InputObject } else { return $InputObject.ToString() } } catch { return "<Err>" } }
        }
    }
    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------
function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Debug"
    )
    if ([string]::IsNullOrWhiteSpace($LogDirectory) -or [string]::IsNullOrWhiteSpace($LogFileName)) { Write-Warning "Invalid logger parameters."; return }
    try {
        if (-not (Test-Path $LogDirectory)) { New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null }
        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true
        Write-Log -Level Info -Message "Logger initialized" -Data @{ LogPath = $script:LogPath; PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS; PID = $PID } -Force
    } catch { Write-Warning "Failed to initialize logger: $_"; $script:LogInitialized = $false }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")] [string]$Level = "Info",
        [Parameter(Mandatory)] [string]$Message,
        [object]$Data,
        [switch]$Force
    )
    if (-not $script:LogInitialized -and -not $Force) { return }
    $levelPriority = @{ Debug=0; Trace=0; Verbose=1; Info=2; Warning=3; Error=4; Fatal=5 }
    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }
    try {
        $caller = (Get-PSCallStack)[1]
        $logContext = @{
            Timestamp = (Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"); Level = $Level; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
            CallDepth = $script:CallDepth; Message = $Message; Caller = @{ Command = $caller.Command; Location = $caller.Location; ScriptName = $caller.ScriptName; LineNumber = $caller.ScriptLineNumber }
        }
        if ($PSBoundParameters.ContainsKey('Data')) { $logContext.UserData = if ($Data -is [Exception]) { @{ Type="Exception"; Message=$Data.Message; StackTrace=$Data.StackTrace; InnerException=$Data.InnerException.Message } } else { ConvertTo-SerializableObject -Object $Data } }
        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) { "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)" } else { $caller.Command }
        $logEntry = "$($logContext.Timestamp) [$($Level.PadRight(7))] $indent [$callerInfo] $Message"
        if ($PSBoundParameters.ContainsKey('Data')) { $logEntry += if ($Data -is [Exception]) { "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)" } else { try { "`n${indent}  Data: $(ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue)" } catch { "`n${indent}  Data: $($Data.ToString())" } } }
        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) { $script:LogQueue.RemoveRange(0, 1000) }
        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) { Move-Item $script:LogPath ($script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log") -Force }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch { Write-Host "LOG WRITE FAILED: $logEntry`nError: $_" -ForegroundColor Yellow }
        }
        if ($Level -in @('Error', 'Fatal', 'Warning')) { Write-Host $logEntry -ForegroundColor ($Level -in @('Error', 'Fatal') ? 'Red' : 'Yellow') }
    } catch { try { $errorEntry = "$(Get-Date -Format 'o') [LOGGER ERROR] Failed to log: $_"; if ($script:LogPath) { Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8 }; Write-Host $errorEntry -ForegroundColor Red } catch { Write-Host "CRITICAL: Logger failed: $_" -ForegroundColor Red } }
}

function Trace-FunctionEntry { [CmdletBinding()] param([string]$FunctionName, [object]$Parameters); if (-not $script:TraceAllCalls) { return }; $script:CallDepth++; Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{ Parameters=$Parameters; Action="FunctionEntry" } }
function Trace-FunctionExit { [CmdletBinding()] param([string]$FunctionName, [object]$ReturnValue, [switch]$WithError); if (-not $script:TraceAllCalls) { return }; Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{ ReturnValue=$ReturnValue; Action=($WithError ? "FunctionExitWithError" : "FunctionExit"); HasError=$WithError.IsPresent }; $script:CallDepth = [Math]::Max(0, $script:CallDepth - 1) }
function Trace-Step { [CmdletBinding()] param([string]$StepName, [object]$StepData, [string]$Module); $caller = (Get-PSCallStack)[1]; $moduleInfo = $Module ?? ($caller.ScriptName ? [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) : "Unknown"); Write-Log -Level Debug -Message "STEP: $StepName" -Data @{ StepData=$StepData; Module=$moduleInfo; Action="Step" } }
function Trace-StateChange { [CmdletBinding()] param([string]$StateType, [object]$OldValue, [object]$NewValue, [string]$PropertyPath); Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{ StateType=$StateType; PropertyPath=$PropertyPath; OldValue=$OldValue; NewValue=$NewValue; Action="StateChange" } }
function Trace-ComponentLifecycle { [CmdletBinding()] param([string]$ComponentType, [string]$ComponentId, [ValidateSet('Create','Initialize','Render','Update','Destroy')] [string]$Phase, [object]$ComponentData); Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{ ComponentType=$ComponentType; ComponentId=$ComponentId; Phase=$Phase; ComponentData=$ComponentData; Action="ComponentLifecycle" } }
function Trace-ServiceCall { [CmdletBinding()] param([string]$ServiceName, [string]$MethodName, [object]$Parameters, [object]$Result, [switch]$IsError); Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{ ServiceName=$ServiceName; MethodName=$MethodName; Parameters=$Parameters; Result=$Result; Action=($IsError ? "ServiceCallError" : "ServiceCall"); IsError=$IsError.IsPresent } }

function Get-LogEntries {
    [CmdletBinding()]
    param([int]$Count = 100, [string]$Level, [string]$Module, [string]$Action)
    try {
        $entries = $script:LogQueue.ToArray()
        if ($Level) { $entries = $entries | Where-Object { $_.Level -eq $Level } }
        if ($Module) { $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") } }
        if ($Action) { $entries = $entries | Where-Object { $_.UserData.Action -eq $Action } }
        return $entries | Select-Object -Last $Count
    } catch { Write-Warning "Error getting log entries: $_"; return @() }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)
    try {
        $callStack = Get-PSCallStack; $trace = @()
        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { $call = $callStack[$i]; $trace += @{ Level=$i-1; Command=$call.Command; Location=$call.Location; ScriptName=$call.ScriptName; LineNumber=$call.ScriptLineNumber } }
        return $trace
    } catch { Write-Warning "Error getting call trace: $_"; return @() }
}

function Clear-LogQueue { try { $script:LogQueue.Clear(); Write-Log -Level Info -Message "In-memory log queue cleared" } catch { Write-Warning "Error clearing log queue: $_" } }
function Set-LogLevel { [CmdletBinding()] param([Parameter(Mandatory)] [ValidateSet("Debug","Verbose","Info","Warning","Error","Fatal","Trace")] [string]$Level); try { $oldLevel = $script:LogLevel; $script:LogLevel = $Level; Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force } catch { Write-Warning "Error setting log level to '$Level': $_" } }
function Enable-CallTracing { $script:TraceAllCalls = $true; Write-Log -Level Info -Message "Call tracing enabled" -Force }
function Disable-CallTracing { $script:TraceAllCalls = $false; Write-Log -Level Info -Message "Call tracing disabled" -Force }
function Get-LogPath { return $script:LogPath }

function Get-LogStatistics {
    [CmdletBinding()]
    param()
    try {
        $stats = [PSCustomObject]@{ TotalEntries=$script:LogQueue.Count; LogPath=$script:LogPath; LogLevel=$script:LogLevel; CallTracingEnabled=$script:TraceAllCalls; LogFileSize=($script:LogPath -and (Test-Path $script:LogPath) ? (Get-Item $script:LogPath).Length : 0); EntriesByLevel=@{}; EntriesByModule=@{}; EntriesByAction=@{} }
        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level; if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level]=0 }; $stats.EntriesByLevel[$level]++
            if ($entry.Caller.ScriptName) { $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName); if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module]=0 }; $stats.EntriesByModule[$module]++ }
            if ($entry.UserData.Action) { $action = $entry.UserData.Action; if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action]=0 }; $stats.EntriesByAction[$action]++ }
        }
        return $stats
    } catch { Write-Warning "Error getting log statistics: $_"; return [PSCustomObject]@{} }
}

Export-ModuleMember -Function 'Initialize-Logger', 'Write-Log', 'Trace-FunctionEntry', 'Trace-FunctionExit', 'Trace-Step', 'Trace-StateChange', 'Trace-ComponentLifecycle', 'Trace-ServiceCall', 'Get-LogEntries', 'Get-CallTrace', 'Clear-LogQueue', 'Set-LogLevel', 'Enable-CallTracing', 'Disable-CallTracing', 'Get-LogPath', 'Get-LogStatistics'



####\modules\models\models.psm1
# ==============================================================================
# PMC Terminal v5 - Core Data Models
# Defines all core business entity classes with built-in validation.
# ==============================================================================

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Enums

enum TaskStatus { Pending; InProgress; Completed; Cancelled }
enum TaskPriority { Low; Medium; High }
enum BillingType { Billable; NonBillable }

#endregion

#region Base Validation Class
class ValidationBase {
    static [void] ValidateNotEmpty([string]$value, [string]$parameterName) {
        if ([string]::IsNullOrWhiteSpace($value)) {
            throw [System.ArgumentException]::new("Parameter '$($parameterName)' cannot be null or empty.")
        }
    }
}
#endregion

#region Core Model Classes

class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()
    [string]$Title
    [string]$Description
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [string]$ProjectKey = "General"
    [string]$Category
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now
    [Nullable[datetime]]$DueDate
    [string[]]$Tags = @()
    [int]$Progress = 0
    [bool]$Completed = $false

    PmcTask() {}
    PmcTask([string]$title) { [ValidationBase]::ValidateNotEmpty($title, "Title"); $this.Title = $title }
    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title; $this.Description = $description; $this.Priority = $priority
        $this.ProjectKey = $projectKey; $this.Category = $projectKey
    }

    [void] Complete() {
        $this.Status = [TaskStatus]::Completed; $this.Completed = $true
        $this.Progress = 100; $this.UpdatedAt = [datetime]::Now
    }

    [void] UpdateProgress([int]$newProgress) {
        if ($newProgress -lt 0 -or $newProgress -gt 100) { throw "Progress must be between 0 and 100." }
        $this.Progress = $newProgress
        $this.Status = $newProgress -eq 100 ? [TaskStatus]::Completed : $newProgress -gt 0 ? [TaskStatus]::InProgress : [TaskStatus]::Pending
        $this.Completed = ($this.Status -eq [TaskStatus]::Completed)
        $this.UpdatedAt = [datetime]::Now
    }
    
    [string] GetDueDateString() { return $this.DueDate ? $this.DueDate.Value.ToString("yyyy-MM-dd") : "N/A" }

    [hashtable] ToLegacyFormat() {
        return @{
            id = $this.Id; title = $this.Title; description = $this.Description
            completed = $this.Completed; priority = $this.Priority.ToString().ToLower()
            project = $this.ProjectKey; due_date = $this.DueDate ? $this.GetDueDateString() : $null
            created_at = $this.CreatedAt.ToString("o"); updated_at = $this.UpdatedAt.ToString("o")
        }
    }

    static [PmcTask] FromLegacyFormat([hashtable]$legacyData) {
        $task = [PmcTask]::new()
        $task.Id = $legacyData.id ?? $task.Id
        $task.Title = $legacyData.title
        $task.Description = $legacyData.description
        if ($legacyData.priority) { try { $task.Priority = [TaskPriority]::$($legacyData.priority) } catch {} }
        $task.ProjectKey = $legacyData.project ?? $legacyData.Category ?? "General"
        $task.Category = $task.ProjectKey
        if ($legacyData.created_at) { try { $task.CreatedAt = [datetime]::Parse($legacyData.created_at) } catch {} }
        if ($legacyData.updated_at) { try { $task.UpdatedAt = [datetime]::Parse($legacyData.updated_at) } catch {} }
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") { try { $task.DueDate = [datetime]::Parse($legacyData.due_date) } catch {} }
        if ($legacyData.completed -is [bool] -and $legacyData.completed) { $task.Complete() }
        return $task
    }
}

class PmcProject : ValidationBase {
    [string]$Key = ([Guid]::NewGuid().ToString().Split('-')[0]).ToUpper()
    [string]$Name
    [string]$Client
    [BillingType]$BillingType = [BillingType]::NonBillable
    [double]$Rate = 0.0
    [double]$Budget = 0.0
    [bool]$Active = $true
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now

    PmcProject() {}
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key"); [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key; $this.Name = $name
    }

    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key; Name = $this.Name; Client = $this.Client
            BillingType = $this.BillingType.ToString(); Rate = $this.Rate; Budget = $this.Budget
            Active = $this.Active; CreatedAt = $this.CreatedAt.ToString("o")
        }
    }

    static [PmcProject] FromLegacyFormat([hashtable]$legacyData) {
        $project = [PmcProject]::new()
        $project.Key = $legacyData.Key ?? $project.Key
        $project.Name = $legacyData.Name
        $project.Client = $legacyData.Client
        if ($legacyData.Rate) { $project.Rate = [double]$legacyData.Rate }
        if ($legacyData.Budget) { $project.Budget = [double]$legacyData.Budget }
        if ($legacyData.Active -is [bool]) { $project.Active = $legacyData.Active }
        if ($legacyData.BillingType) { try { $project.BillingType = [BillingType]::$($legacyData.BillingType) } catch {} }
        if ($legacyData.CreatedAt) { try { $project.CreatedAt = [datetime]::Parse($legacyData.CreatedAt) } catch {} }
        $project.UpdatedAt = $project.CreatedAt
        return $project
    }
}

#endregion

# AI: Export everything including enums for PowerShell 7+
#Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\modules\theme-manager\theme-manager.psm1
# FILE: modules/theme-manager.psm1
# PURPOSE: Provides theming and color management for the TUI.
#

#using module '.\logger.psm1'
#using module '.\event-system.psm1'
#using module '.\exceptions.psm1'

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{ Name="Modern"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::White; Primary=[ConsoleColor]::White; Secondary=[ConsoleColor]::Gray; Accent=[ConsoleColor]::Cyan; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::Yellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Blue; Header=[ConsoleColor]::Cyan; Border=[ConsoleColor]::DarkGray; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::Cyan; Subtle=[ConsoleColor]::DarkGray; Keyword=[ConsoleColor]::Blue; String=[ConsoleColor]::Green; Number=[ConsoleColor]::Magenta; Comment=[ConsoleColor]::DarkGray } }
    Dark   = @{ Name="Dark"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::Gray; Primary=[ConsoleColor]::Gray; Secondary=[ConsoleColor]::DarkGray; Accent=[ConsoleColor]::DarkCyan; Success=[ConsoleColor]::DarkGreen; Warning=[ConsoleColor]::DarkYellow; Error=[ConsoleColor]::DarkRed; Info=[ConsoleColor]::DarkBlue; Header=[ConsoleColor]::DarkCyan; Border=[ConsoleColor]::DarkGray; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::Cyan; Subtle=[ConsoleColor]::DarkGray; Keyword=[ConsoleColor]::DarkBlue; String=[ConsoleColor]::DarkGreen; Number=[ConsoleColor]::DarkMagenta; Comment=[ConsoleColor]::DarkGray } }
    Light  = @{ Name="Light"; Colors=@{ Background=[ConsoleColor]::White; Foreground=[ConsoleColor]::Black; Primary=[ConsoleColor]::Black; Secondary=[ConsoleColor]::DarkGray; Accent=[ConsoleColor]::Blue; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::DarkYellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Blue; Header=[ConsoleColor]::Blue; Border=[ConsoleColor]::Gray; Selection=[ConsoleColor]::Cyan; Highlight=[ConsoleColor]::Yellow; Subtle=[ConsoleColor]::Gray; Keyword=[ConsoleColor]::Blue; String=[ConsoleColor]::Green; Number=[ConsoleColor]::Magenta; Comment=[ConsoleColor]::Gray } }
    Retro  = @{ Name="Retro"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::Green; Primary=[ConsoleColor]::Green; Secondary=[ConsoleColor]::DarkGreen; Accent=[ConsoleColor]::Yellow; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::Yellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Cyan; Header=[ConsoleColor]::Yellow; Border=[ConsoleColor]::DarkGreen; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::White; Subtle=[ConsoleColor]::DarkGreen; Keyword=[ConsoleColor]::Yellow; String=[ConsoleColor]::Cyan; Number=[ConsoleColor]::White; Comment=[ConsoleColor]::DarkGreen } }
}

function Initialize-ThemeManager {
    Invoke-WithErrorHandling -Component "ThemeManager.Initialize" -Context "Initializing theme service" -ScriptBlock {
        Set-TuiTheme -ThemeName "Modern"
        Write-Log -Level Info -Message "Theme manager initialized."
    }
}

function Set-TuiTheme {
    param([Parameter(Mandatory)] [string]$ThemeName)
    Invoke-WithErrorHandling -Component "ThemeManager.SetTheme" -Context "Setting active TUI theme" -AdditionalData @{ ThemeName = $ThemeName } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $script:CurrentTheme = $script:Themes[$ThemeName]
            if ($Host.UI.RawUI) {
                $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
                $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
            }
            Write-Log -Level Debug -Message "Theme set to: $ThemeName"
            Publish-Event -EventName "Theme.Changed" -Data @{ ThemeName = $ThemeName; Theme = $script:CurrentTheme }
        } else {
            Write-Log -Level Warning -Message "Theme not found: $ThemeName"
        }
    }
}

function Get-ThemeColor {
    param([Parameter(Mandatory)] [string]$ColorName, [ConsoleColor]$Default = [ConsoleColor]::Gray)
    try {
        return $script:CurrentTheme.Colors[$ColorName] ?? $Default
    } catch {
        Write-Log -Level Warning -Message "Error in Get-ThemeColor for '$ColorName'. Returning default. Error: $_"
        return $Default
    }
}

function Get-TuiTheme {
    Invoke-WithErrorHandling -Component "ThemeManager.GetTheme" -Context "Retrieving current theme" -ScriptBlock {
        return $script:CurrentTheme
    }
}

function Get-AvailableThemes {
    Invoke-WithErrorHandling -Component "ThemeManager.GetAvailableThemes" -Context "Retrieving available themes" -ScriptBlock {
        return $script:Themes.Keys | Sort-Object
    }
}

function New-TuiTheme {
    param([Parameter(Mandatory)] [string]$Name, [string]$BaseTheme = "Modern", [hashtable]$Colors = @{})
    Invoke-WithErrorHandling -Component "ThemeManager.NewTheme" -Context "Creating new theme" -AdditionalData @{ ThemeName = $Name } -ScriptBlock {
        $newTheme = @{ Name = $Name; Colors = @{} }
        if ($script:Themes.ContainsKey($BaseTheme)) { $newTheme.Colors = $script:Themes[$BaseTheme].Colors.Clone() }
        foreach ($colorKey in $Colors.Keys) { $newTheme.Colors[$colorKey] = $Colors[$colorKey] }
        $script:Themes[$Name] = $newTheme
        Write-Log -Level Info -Message "Created new theme: $Name"
        return $newTheme
    }
}

function Export-TuiTheme {
    param([Parameter(Mandatory)] [string]$ThemeName, [Parameter(Mandatory)] [string]$Path)
    Invoke-WithErrorHandling -Component "ThemeManager.ExportTheme" -Context "Exporting theme to JSON" -AdditionalData @{ ThemeName = $ThemeName; FilePath = $Path } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $theme = $script:Themes[$ThemeName]
            $exportTheme = @{ Name = $theme.Name; Colors = @{} }
            foreach ($colorKey in $theme.Colors.Keys) { $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString() }
            $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
            Write-Log -Level Info -Message "Exported theme '$ThemeName' to: $Path"
        } else {
            Write-Log -Level Warning -Message "Cannot export theme. Theme not found: $ThemeName"
        }
    }
}

function Import-TuiTheme {
    param([Parameter(Mandatory)] [string]$Path)
    Invoke-WithErrorHandling -Component "ThemeManager.ImportTheme" -Context "Importing theme from JSON" -AdditionalData @{ FilePath = $Path } -ScriptBlock {
        if (Test-Path $Path) {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
            $theme = @{ Name = $importedTheme.Name; Colors = @{} }
            foreach ($colorKey in $importedTheme.Colors.Keys) {
                $theme.Colors[$colorKey] = [System.Enum]::Parse([System.ConsoleColor], $importedTheme.Colors[$colorKey], $true)
            }
            $script:Themes[$theme.Name] = $theme
            Write-Log -Level Info -Message "Imported theme: $($theme.Name)"
            return $theme
        } else {
            Write-Log -Level Warning -Message "Cannot import theme. File not found: $Path"
            return $null
        }
    }
}

Export-ModuleMember -Function 'Initialize-ThemeManager', 'Set-TuiTheme', 'Get-ThemeColor', 'Get-TuiTheme', 'Get-AvailableThemes', 'New-TuiTheme', 'Export-TuiTheme', 'Import-TuiTheme'


####\modules\tui-engine\tui-engine.psm1
# TUI Engine v5.1 - NCurses Compositor Edition
# Implements NCurses-style compositor with private buffers and TuiCell rendering

#using module '..\components\tui-primitives.psm1'
#using module '.\logger.psm1'
#using module '.\event-system.psm1'
#using module '.\exceptions.psm1'
#using module '.\dialog-system-class.psm1'

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    CompositorBuffer = $null    # AI: NEW - Master compositor buffer (TuiBuffer)
    PreviousCompositorBuffer = $null # AI: NEW - Buffer for diffing against the main compositor
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
    CompositorMode  = $true     # AI: NEW - Enable NCurses-style rendering
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.1 (NCurses Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        # AI: ENHANCED - Create both legacy buffers and new TuiBuffer compositor
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        $global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new($Width, $Height, "PreviousCompositor")
        
        # Initialize legacy buffers for compatibility
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        # AI: FIX - Subscribe to refresh requests to decouple dialog system
        Subscribe-Event -EventName "TUI.RefreshRequested" -Handler {
            Request-TuiRefresh
        } -Source "TuiEngine"

        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height; CompositorMode = $global:TuiState.CompositorMode }
        Write-Log -Level Info -Message "TUI Engine v5.1 initialized successfully (Compositor Mode: $($global:TuiState.CompositorMode))"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent) {
        try { 
            # AI: ENHANCED - Better class detection for UIElement-based components
            if ($focusedComponent -is [UIElement]) {
                # New UIElement-based component
                $focusedComponent.HandleInput($keyInfo)
            }
            elseif ($focusedComponent.PSObject.TypeNames -contains 'UIElement' -or $focusedComponent.GetType().IsSubclassOf([UIElement])) {
                # Class-based component (legacy detection)
                if ($focusedComponent.PSObject.Methods.Name -contains 'HandleInput') {
                    $focusedComponent.HandleInput($keyInfo)
                }
            }
            elseif ($focusedComponent.HandleInput) {
                # Functional component with HandleInput scriptblock
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return }
            }
        } catch { 
            Write-Warning "Component input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for component '$($focusedComponent.Name)': $_"
        }
    }
    
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            # AI: ENHANCED - Support for UIElement-based screens
            if ($currentScreen -is [UIElement]) {
                # New UIElement-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen -is [Screen]) {
                # Legacy class-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen.HandleInput) {
                # Hashtable/functional screen - use scriptblock invocation
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { Stop-TuiEngine }
                }
            }
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([object]$InitialScreen)  # AI: Accept both UIElement and hashtable screens
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

# AI: REWRITTEN - NCurses Compositor Render-Frame
function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        if ($global:TuiState.CompositorMode -and $null -ne $global:TuiState.CompositorBuffer) {
            # AI: NEW - NCurses-style compositor rendering
            Render-FrameCompositor
        } else {
            # AI: LEGACY - Fall back to old rendering for compatibility
            Render-FrameLegacy
        }
        
        # AI: NEW - After rendering, copy the current compositor state to the previous state buffer for the next frame's diff.
        if ($global:TuiState.CompositorMode) {
            $global:TuiState.PreviousCompositorBuffer.Clear()
            $global:TuiState.PreviousCompositorBuffer.BlendBuffer($global:TuiState.CompositorBuffer, 0, 0)
        }
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    # AI: NEW - NCurses-style compositor rendering pipeline
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                if ($global:TuiState.CurrentScreen -is [UIElement]) {
                    # New UIElement-based screen - render to its private buffer
                    $global:TuiState.CurrentScreen.Render()
                    
                    # Composite screen buffer onto master compositor
                    $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                    if ($null -ne $screenBuffer) {
                        $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                    }
                } else {
                    # Legacy screen - render directly (will be deprecated)
                    $global:TuiState.CurrentScreen.Render()
                }
            }
        }
        
        # 3. Render dialogs on top
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog -is [UIElement]) {
                    # New UIElement-based dialog
                    $dialog.Render()
                    $dialogBuffer = $dialog.GetBuffer()
                    if ($null -ne $dialogBuffer) {
                        $pos = $dialog.GetAbsolutePosition()
                        $global:TuiState.CompositorBuffer.BlendBuffer($dialogBuffer, $pos.X, $pos.Y)
                    }
                } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                    # Class-based dialog with Render() method
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    # Functional/hashtable dialog with Render scriptblock
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
        # Fall back to legacy rendering
        Render-FrameLegacy
    }
}

function Render-CompositorToConsole {
    # AI: REWRITTEN - True TuiBuffer-to-TuiBuffer diffing.
    $outputBuilder = [System.Text.StringBuilder]::new(20000)
    $currentBuffer = $global:TuiState.CompositorBuffer
    $previousBuffer = $global:TuiState.PreviousCompositorBuffer
    $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1

    try {
        for ($y = 0; $y -lt $currentBuffer.Height; $y++) {
            $rowChanged = $false
            for ($x = 0; $x -lt $currentBuffer.Width; $x++) {
                $newCell = $currentBuffer.GetCell($x, $y)
                $oldCell = $previousBuffer.GetCell($x, $y)
                
                if ($forceFullRender -or $newCell.DiffersFrom($oldCell)) {
                    if (-not $rowChanged) {
                        [void]$outputBuilder.Append("`e[$($y + 1);1H")
                        # On the first change in a row, we must move the cursor.
                        # For subsequent changes, we need to move it again if there was a gap.
                        if ($x > 0) { [void]$outputBuilder.Append("`e[$($y + 1);$($x + 1)H") }
                        $rowChanged = $true
                    }

                    if ($newCell.ForegroundColor -ne $lastFG -or $newCell.BackgroundColor -ne $lastBG) {
                        $fgCode = Get-AnsiColorCode $newCell.ForegroundColor
                        $bgCode = Get-AnsiColorCode $newCell.BackgroundColor -IsBackground $true
                        [void]$outputBuilder.Append("`e[${fgCode};${bgCode}m")
                        $lastFG = $newCell.ForegroundColor
                        $lastBG = $newCell.BackgroundColor
                    }
                    [void]$outputBuilder.Append($newCell.Char)
                } elseif ($rowChanged) {
                    # If a change occurred in this row previously, but this cell is the same,
                    # we need to move the cursor to the next potential change point.
                    [void]$outputBuilder.Append("`e[$($y + 1);$($x + 2)H")
                }
            }
        }
        
        # Reset colors at the end
        if ($lastFG -ne -1) { [void]$outputBuilder.Append("`e[0m") }
        
        if ($outputBuilder.Length -gt 10) {
            [Console]::Write($outputBuilder.ToString())
        }
    } catch {
        Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Render-FrameLegacy {
    # AI: LEGACY - Original rendering code for compatibility
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component $global:TuiState.CurrentScreen.Name -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
            }
        }
        
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog.GetType().IsSubclassOf([UIElement]) -or $dialog -is [UIElement]) {
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        Render-BufferOptimized
        
    } catch {
        Write-Log -Level Error -Message "Legacy rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    # AI: ENHANCED - Accept both UIElement and legacy screen objects
    param([object]$Screen)
    if (-not $Screen) { return }
    
    $screenName = if ($Screen -is [UIElement]) { $Screen.Name } elseif ($Screen -is [Screen]) { $Screen.Name } else { $Screen.Name }
    Write-Log -Level Debug -Message "Pushing screen: $screenName"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($global:TuiState.CurrentScreen) {
            # Handle exit for current screen
            if ($global:TuiState.CurrentScreen -is [UIElement]) {
                # New UIElement-based screen
                # No explicit OnExit method - handled by framework
            } elseif ($global:TuiState.CurrentScreen -is [Screen]) {
                # Legacy class-based screen
                $global:TuiState.CurrentScreen.OnExit()
            } elseif ($global:TuiState.CurrentScreen.OnExit) {
                # Functional screen
                $global:TuiState.CurrentScreen.OnExit.Invoke()
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # Initialize new screen
        if ($Screen -is [UIElement]) {
            # New UIElement-based screen - ensure it's sized to fit screen
            if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) {  # Default size
                $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            }
            # Trigger initial render
            $Screen.RequestRedraw()
        } elseif ($Screen -is [Screen]) {
            # Legacy class-based screen
            $Screen.OnEnter()
        } elseif ($Screen.Init) { 
            # Functional screen
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $screenName }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$screenName': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $global:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering - Legacy Support
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:TuiState.BufferWidth) { break }
        if ($currentX -ge 0) { $global:TuiState.BackBuffer[$Y, $currentX] = @{ Char = $char; FG = $ForegroundColor; BG = $BackgroundColor } }
        $currentX++
    }
}

function Write-BufferBox {
    param([int]$X, [int]$Y, [int]$Width, [int]$Height, [string]$BorderStyle = "Single", [ConsoleColor]$BorderColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, [string]$Title = "")
    $borders = Get-BorderChars -Style $BorderStyle
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    if ($Title) {
        $titleText = " $Title "; if ($titleText.Length -gt ($Width-2)) { $titleText = " $($Title.Substring(0,[Math]::Max(0,$Width-5)))... " }
        Write-BufferString -X ($X + [Math]::Floor(($Width - $titleText.Length) / 2)) -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function Render-BufferOptimized {
    $outputBuilder = [System.Text.StringBuilder]::new(20000); $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 0
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $backCell = $global:TuiState.BackBuffer[$y, $x]; $frontCell = $global:TuiState.FrontBuffer[$y, $x]
                if (-not $forceFullRender -and $backCell.Char -eq $frontCell.Char -and $backCell.FG -eq $frontCell.FG -and $backCell.BG -eq $frontCell.BG) { continue }
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) { $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null }
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG; $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null; $lastFG = $backCell.FG; $lastBG = $backCell.BG
                }
                $outputBuilder.Append($backCell.Char) | Out-Null
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = $backCell.Char; FG = $backCell.FG; BG = $backCell.BG }
            }
        }
        $outputBuilder.Append("`e[0m") | Out-Null
        if ($outputBuilder.Length -gt 0) { [Console]::Write($outputBuilder.ToString()) }
    } catch { Write-Warning "Render error: $_" }
}
#endregion

#region Component System - Enhanced for UIElement
function Initialize-ComponentSystem { $global:TuiState.Components = @(); $global:TuiState.FocusedComponent = $null }

function Register-Component { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    $global:TuiState.Components += $Component
    
    # Initialize component based on type
    if ($Component -is [UIElement]) {
        # New UIElement-based component - no explicit init needed
        Write-Log -Level Debug -Message "Registered UIElement component: $($Component.Name)"
    } elseif ($Component.Init) { 
        try { & $Component.Init -self $Component } catch { Write-Warning "Component init error: $_" } 
    }
    return $Component 
}

function Set-ComponentFocus { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) { return }
    
    # Blur current component
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    
    # Set new focused component
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    
    # Focus new component
    if ($null -ne $Component) {
        if ($Component -is [UIElement]) {
            $Component.OnFocus()
        } else {
            $Component.OnFocus?.Invoke()
        }
    }
    
    Request-TuiRefresh 
}

function Clear-ComponentFocus { 
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    $global:TuiState.FocusedComponent = $null
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $null }
    Request-TuiRefresh 
}

# AI: ENHANCED - Support UIElement focusable detection
function Get-NextFocusableComponent { 
    param([object]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = @()
    
    function Find-Focusable([object]$Comp) { 
        if ($Comp -is [UIElement]) {
            # New UIElement-based component
            if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
                $focusableComponents += $Comp
            }
            # Check children
            foreach ($child in $Comp.Children) {
                Find-Focusable $child
            }
        } else {
            # Legacy component
            if ($Comp.IsFocusable -eq $true -and $Comp.Visible -ne $false) { 
                $focusableComponents += $Comp 
            }
            if ($Comp.Children) { 
                foreach ($c in $Comp.Children) { Find-Focusable $c } 
            }
        }
    }
    
    # Find focusable components in current screen
    if ($global:TuiState.CurrentScreen -is [UIElement]) {
        Find-Focusable $global:TuiState.CurrentScreen
    } elseif ($global:TuiState.CurrentScreen.Components) { 
        foreach ($c in $global:TuiState.CurrentScreen.Components.Values) { Find-Focusable $c } 
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by tab index and position
    $sorted = $focusableComponents | Sort-Object { 
        if ($_ -is [UIElement]) {
            $_.TabIndex * 10000 + $_.Y * 100 + $_.X
        } else {
            ($_.TabIndex ?? 0) * 10000 + ($_.Y ?? 0) * 100 + ($_.X ?? 0)
        }
    }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Handle-TabNavigation { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

# AI: LEGACY - Helper functions maintained for compatibility
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Move-Focus { param([bool]$Reverse = $false); Handle-TabNavigation -Reverse $Reverse }

function Get-CurrentDialog {
    # AI: REFACTORED - This function now directly and reliably accesses the dialog state
    # from the single, class-based dialog system.
    try {
        if (Get-Module -Name 'dialog-system-class' -ErrorAction SilentlyContinue) {
            # This retrieves the $script:DialogState variable from the specified module's scope.
            return (Get-Module -Name 'dialog-system-class').SessionState.PSVariable.Get('DialogState').Value.CurrentDialog
        }
    } catch {
        Write-Log -Level Error -Message "Critical error accessing dialog system state: $_"
    }
    return $null
}

function Handle-DialogInput {
    param([System.ConsoleKeyInfo]$Key)
    # AI: REFACTORED - Simplified to work only with the new UIElement-based dialogs.
    try {
        $dialog = Get-CurrentDialog
        if ($dialog -and $dialog -is [UIElement]) {
            # All dialogs are now UIElements and have a HandleInput method.
            return $dialog.HandleInput($Key)
        }
    } catch {
        Write-Log -Level Error -Message "Error handling dialog input: $_"
    }
    return $false
}

function Update-DialogSystem {
    # Dialog system handles its own updates if loaded
}

function Stop-AllTuiAsyncJobs {
    Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)"
}
#endregion

#region Layout Management & Utilities
function Initialize-LayoutEngines { $global:TuiState.Layouts = @{} }
function Get-BorderChars { param([string]$Style); $styles = @{ Single=@{TopLeft='┌';TopRight='┐';BottomLeft='└';BottomRight='┘';Horizontal='─';Vertical='│'}; Double=@{TopLeft='╔';TopRight='╗';BottomLeft='╚';BottomRight='╝';Horizontal='═';Vertical='║'}; Rounded=@{TopLeft='╭';TopRight='╮';BottomLeft='╰';BottomRight='╯';Horizontal='─';Vertical='│'} }; return $styles[$Style] ?? $styles.Single }
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Get-WordWrappedLines { param([string]$Text, [int]$MaxWidth); if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }; $lines = @(); $words = $Text -split '\s+'; $sb = [System.Text.StringBuilder]::new(); foreach ($word in $words) { if ($sb.Length -eq 0) { [void]$sb.Append($word) } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) { [void]$sb.Append(' ').Append($word) } else { $lines += $sb.ToString(); [void]$sb.Clear().Append($word) } }; if ($sb.Length -gt 0) { $lines += $sb.ToString() }; return $lines }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }

# AI: NEW - Compositor helper functions
function Get-ThemeColor {
    param([string]$ColorName)
    # Simple theme color mapping - can be enhanced later
    $themeColors = @{
        Background = [ConsoleColor]::Black
        Foreground = [ConsoleColor]::White
        Border = [ConsoleColor]::Gray
        Focus = [ConsoleColor]::Cyan
        Highlight = [ConsoleColor]::Yellow
    }
    return $themeColors[$ColorName] ?? [ConsoleColor]::Black
}
#endregion

Export-ModuleMember -Function 'Initialize-TuiEngine', 'Start-TuiLoop', 'Stop-TuiEngine', 'Push-Screen', 'Pop-Screen', 'Request-TuiRefresh', 'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer', 'Get-BorderChars', 'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 'Get-NextFocusableComponent', 'Handle-TabNavigation', 'Get-WordWrappedLines', 'Get-FocusedComponent', 'Move-Focus', 'Get-CurrentDialog', 'Handle-DialogInput', 'Update-DialogSystem', 'Stop-AllTuiAsyncJobs', 'Get-ThemeColor' -Variable 'TuiState'


####\modules\tui-framework\tui-framework.psm1
# TUI Framework Integration Module
# Contains utility functions for interacting with the TUI engine and components.
# AI: FIX - Added all missing dependencies.
#using module '.\exceptions.psm1'
#using module '.\logger.psm1'
#using module '.\event-system.psm1'

$script:TuiAsyncJobs = @()

function Invoke-TuiMethod {
    <# .SYNOPSIS Safely invokes a method on a TUI component. #>
    param(
        [Parameter(Mandatory)] [hashtable]$Component,
        [Parameter(Mandatory)] [string]$MethodName,
        [Parameter()] [hashtable]$Arguments = @{}
    )
    if (-not $Component) { return }
    $method = $Component[$MethodName]
    if (-not ($method -is [scriptblock])) { return }

    $Arguments['self'] = $Component
    Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock { & $method @Arguments }
}

function Initialize-TuiFramework {
    Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {
        if (-not $global:TuiState) { throw "TUI Engine must be initialized before the TUI Framework." }
        Write-Log -Level Info -Message "TUI Framework initialized."
    }
}

function Invoke-TuiAsync {
    <# .SYNOPSIS Executes a script block asynchronously with job management. #>
    param(
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [string]$JobName = "TuiAsyncJob_$(Get-Random)",
        [hashtable]$ArgumentList = @{}
    )
    Invoke-WithErrorHandling -Component "TuiFramework.Async" -Context "Starting async job: $JobName" -ScriptBlock {
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList -Name $JobName
        $script:TuiAsyncJobs += $job
        Write-Log -Level Debug -Message "Started async job: $JobName" -Data @{ JobId = $job.Id }
        return $job
    }
}

function Get-TuiAsyncResults {
    <# .SYNOPSIS Checks for completed async jobs and returns their results. #>
    param([switch]$RemoveCompleted = $true)
    Invoke-WithErrorHandling -Component "TuiFramework.AsyncResults" -Context "Checking async job results" -ScriptBlock {
        $results = @()
        $completedJobs = $script:TuiAsyncJobs | Where-Object { $_.State -in @('Completed', 'Failed', 'Stopped') }
        
        foreach ($job in $completedJobs) {
            $results += @{
                JobId = $job.Id; JobName = $job.Name; State = $job.State
                Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job } else { $null }
                Error = if ($job.State -eq 'Failed') { $job.ChildJobs[0].JobStateInfo.Reason } else { $null }
            }
            Write-Log -Level Debug -Message "Async job completed: $($job.Name)" -Data @{ JobId = $job.Id; State = $job.State }
        }
        
        if ($RemoveCompleted -and $completedJobs.Count -gt 0) {
            foreach ($job in $completedJobs) {
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                $script:TuiAsyncJobs = $script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id }
            }
        }
        return $results
    }
}

function Stop-AllTuiAsyncJobs {
    Invoke-WithErrorHandling -Component "TuiFramework.StopAsync" -Context "Stopping all async jobs" -ScriptBlock {
        foreach ($job in $script:TuiAsyncJobs) {
            try {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                Write-Log -Level Debug -Message "Stopped async job: $($job.Name)"
            } catch {
                Write-Log -Level Warning -Message "Failed to stop job $($job.Name): $_"
            }
        }
        $script:TuiAsyncJobs = @()
        Write-Log -Level Info -Message "All TUI async jobs stopped."
    }
}

function Request-TuiRefresh {
    if ($global:TuiState.RequestRefresh) { & $global:TuiState.RequestRefresh }
    else { Publish-Event -EventName "TUI.RefreshRequested" }
}

function Get-TuiState { return $global:TuiState }

function Test-TuiState {
    param([switch]$ThrowOnError)
    $isValid = $global:TuiState -and $global:TuiState.Running -and $global:TuiState.CurrentScreen
    if (-not $isValid -and $ThrowOnError) { throw "TUI state is not properly initialized. Call Initialize-TuiEngine first." }
    return $isValid
}

Export-ModuleMember -Function 'Invoke-TuiMethod', 'Initialize-TuiFramework', 'Invoke-TuiAsync', 'Get-TuiAsyncResults', 'Stop-AllTuiAsyncJobs', 'Request-TuiRefresh', 'Get-TuiState', 'Test-TuiState'


####\screens\dashboard-screen\dashboard-screen.psm1
####\screens\dashboard\dashboard-screen.psm1
# ==============================================================================
# PMC Terminal v5 - NCurses Dashboard Screen
# Main entry screen with buffer-based rendering
# ==============================================================================

# AI: PHASE 3 REFACTORED - NCurses buffer-based architecture
#using module '..\..\components\tui-primitives.psm1'
#using module '..\..\layout\panels-class.psm1'
#using module '..\..\components\navigation-class.psm1'
#using module '..\..\modules\models.psm1'
#using module '..\..\components\ui-classes.psm1'
#using module '..\..\modules\logger.psm1'
#using module '..\..\modules\exceptions.psm1'

class DashboardScreen : UIElement {
    # --- Core Architecture ---
    [hashtable] $Services
    [Panel] $MainPanel
    [Panel] $SummaryPanel
    [Panel] $MenuPanel
    [Panel] $StatusPanel
    [NavigationMenu] $MainMenu
    [System.Collections.Generic.List[UIElement]] $Components

    # --- State Management ---
    [object[]] $Tasks = @()
    [int] $TotalTasks = 0
    [int] $CompletedTasks = 0
    [int] $PendingTasks = 0

    # --- Constructor ---
    DashboardScreen([hashtable]$services) : base(0, 0, 120, 30) {
        $this.Name = "DashboardScreen"
        $this.Services = $services
        $this.Components = [System.Collections.Generic.List[UIElement]]::new()
        $this.IsFocusable = $true
        $this.Enabled = $true
        $this.Visible = $true
        $this.Tasks = @()
        
        Write-Log -Level Info -Message "Creating DashboardScreen with NCurses architecture"
    }

    # --- Initialization ---
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "Initialize" -ScriptBlock {
            # AI: PHASE 3 - Create main panel structure
            $this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "PMC Terminal v5 - Dashboard")
            $this.MainPanel.HasBorder = $true
            $this.MainPanel.BorderStyle = "Double"
            $this.MainPanel.BorderColor = [ConsoleColor]::Cyan
            $this.MainPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MainPanel.TitleColor = [ConsoleColor]::White
            $this.MainPanel.Name = "MainDashboardPanel"
            $this.AddChild($this.MainPanel)
            
            # AI: PHASE 3 - Summary panel (left side)
            $this.SummaryPanel = [Panel]::new(2, 2, 45, 12, "Task Summary")
            $this.SummaryPanel.HasBorder = $true
            $this.SummaryPanel.BorderStyle = "Single"
            $this.SummaryPanel.BorderColor = [ConsoleColor]::Green
            $this.SummaryPanel.BackgroundColor = [ConsoleColor]::Black
            $this.SummaryPanel.Name = "SummaryPanel"
            $this.MainPanel.AddChild($this.SummaryPanel)
            
            # AI: PHASE 3 - Menu panel (right side)
            $this.MenuPanel = [Panel]::new(49, 2, 50, 15, "Main Menu")
            $this.MenuPanel.HasBorder = $true
            $this.MenuPanel.BorderStyle = "Single"
            $this.MenuPanel.BorderColor = [ConsoleColor]::Yellow
            $this.MenuPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MenuPanel.Name = "MenuPanel"
            $this.MainPanel.AddChild($this.MenuPanel)
            
            # AI: PHASE 3 - Status panel (bottom)
            $this.StatusPanel = [Panel]::new(2, 19, 116, 8, "System Status")
            $this.StatusPanel.HasBorder = $true
            $this.StatusPanel.BorderStyle = "Single"
            $this.StatusPanel.BorderColor = [ConsoleColor]::Magenta
            $this.StatusPanel.BackgroundColor = [ConsoleColor]::Black
            $this.StatusPanel.Name = "StatusPanel"
            $this.MainPanel.AddChild($this.StatusPanel)
            
            # AI: PHASE 3 - Create navigation menu
            $this.MainMenu = [NavigationMenu]::new("MainMenu")
            $this.MainMenu.Move(1, 1)  # Inside menu panel
            $this.MainMenu.Resize(48, 13)
            $this.BuildMainMenu()
            $this.MenuPanel.AddChild($this.MainMenu)
            
            # AI: PHASE 3 - Load initial data and update display
            $this.RefreshData()
            $this.UpdateDisplay()
            
            Write-Log -Level Info -Message "DashboardScreen initialized with NCurses architecture"
        }
    }

    # --- Menu Building ---
    hidden [void] BuildMainMenu() {
        try {
            $this.MainMenu.AddItem([NavigationItem]::new("1", "Task Management", { 
                $this.Services.Navigation.GoTo("/tasks", @{}) 
            }))
            $this.MainMenu.AddItem([NavigationItem]::new("2", "Project Management", { 
                $this.Services.Navigation.GoTo("/projects", @{}) 
            }))
            $this.MainMenu.AddItem([NavigationItem]::new("3", "Settings", { 
                $this.Services.Navigation.GoTo("/settings", @{}) 
            }))
            $this.MainMenu.AddSeparator()
            $this.MainMenu.AddItem([NavigationItem]::new("Q", "Quit Application", { 
                $this.Services.Navigation.RequestExit() 
            }))
            
            Write-Log -Level Debug -Message "Main menu built with $($this.MainMenu.Items.Count) items"
        } catch {
            Write-Log -Level Error -Message "Failed to build main menu: $_"
        }
    }

    # --- Data Management ---
    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "RefreshData" -ScriptBlock {
            # AI: PHASE 3 - Safe data loading
            $this.Tasks = @()
            $this.TotalTasks = 0
            $this.CompletedTasks = 0
            $this.PendingTasks = 0
            
            if ($null -eq $this.Services.DataManager) {
                Write-Log -Level Warning -Message "DataManager service not available"
                return
            }
            
            try {
                $taskData = $this.Services.DataManager.GetTasks()
                $this.Tasks = if ($null -eq $taskData) { @() } else { @($taskData) }
                
                # AI: PHASE 3 - Calculate statistics
                $this.TotalTasks = $this.Tasks.Count
                
                if ($this.TotalTasks -gt 0) {
                    try {
                        $completedTasks = @($this.Tasks | Where-Object { 
                            $null -ne $_ -and $_.Status -eq [TaskStatus]::Completed 
                        })
                        $this.CompletedTasks = $completedTasks.Count
                        $this.PendingTasks = $this.TotalTasks - $this.CompletedTasks
                    } catch {
                        # AI: PHASE 3 - Fallback for enum issues
                        Write-Log -Level Warning -Message "TaskStatus enum not available, using string comparison"
                        $completedTasks = @($this.Tasks | Where-Object { 
                            $null -ne $_ -and ($_.Status -eq "Completed" -or $_.Status -eq 2)
                        })
                        $this.CompletedTasks = $completedTasks.Count
                        $this.PendingTasks = $this.TotalTasks - $this.CompletedTasks
                    }
                }
                
                Write-Log -Level Debug -Message "Dashboard data refreshed - $($this.TotalTasks) tasks loaded"
            } catch {
                Write-Log -Level Warning -Message "Failed to load tasks: $_"
                $this.Tasks = @()
            }
        }
    }

    hidden [void] UpdateDisplay() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "UpdateDisplay" -ScriptBlock {
            # AI: PHASE 3 - Update summary panel
            $this.UpdateSummaryPanel()
            
            # AI: PHASE 3 - Update status panel
            $this.UpdateStatusPanel()
            
            $this.RequestRedraw()
        }
    }

    hidden [void] UpdateSummaryPanel() {
        if ($null -eq $this.SummaryPanel) { return }
        
        # AI: PHASE 3 - Clear summary panel content area
        $this.ClearPanelContent($this.SummaryPanel)
        
        # AI: PHASE 3 - Write summary information
        $summaryLines = @(
            "Task Overview",
            "═══════════════",
            "",
            "Total Tasks:    $($this.TotalTasks)",
            "Completed:      $($this.CompletedTasks)",
            "Pending:        $($this.PendingTasks)",
            "",
            "Progress: $($this.GetProgressBar())",
            "",
            "Use number keys or",
            "arrow keys + Enter"
        )
        
        for ($i = 0; $i -lt $summaryLines.Count; $i++) {
            $color = if ($i -eq 0) { [ConsoleColor]::White } elseif ($i -eq 1) { [ConsoleColor]::Gray } else { [ConsoleColor]::Cyan }
            $this.WriteTextToPanel($this.SummaryPanel, $summaryLines[$i], 1, $i, $color)
        }
    }

    hidden [void] UpdateStatusPanel() {
        if ($null -eq $this.StatusPanel) { return }
        
        # AI: PHASE 3 - Clear status panel content area
        $this.ClearPanelContent($this.StatusPanel)
        
        # AI: PHASE 3 - Write system status information
        $statusLines = @(
            "System Information",
            "════════════════════",
            "",
            # AI: FIX - Use $global scope for automatic variables inside class methods
            "PowerShell Version: $($global:PSVersionTable.PSVersion)",
            "Platform:           $($global:PSVersionTable.Platform)",
            "Memory Usage:       $($this.GetMemoryUsage())",
            "Current Time:       $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        )
        
        for ($i = 0; $i -lt $statusLines.Count; $i++) {
            $color = if ($i -eq 0) { [ConsoleColor]::White } elseif ($i -eq 1) { [ConsoleColor]::Gray } else { [ConsoleColor]::Green }
            $this.WriteTextToPanel($this.StatusPanel, $statusLines[$i], 1, $i, $color)
        }
    }

    # --- Helper Methods ---
    hidden [string] GetProgressBar() {
        if ($this.TotalTasks -eq 0) { return "No tasks" }
        
        $percentage = [Math]::Round(($this.CompletedTasks / $this.TotalTasks) * 100)
        $barLength = 20
        $filledLength = [Math]::Round(($percentage / 100) * $barLength)
        $bar = "█" * $filledLength + "░" * ($barLength - $filledLength)
        return "$bar $percentage%"
    }

    hidden [string] GetMemoryUsage() {
        try {
            # AI: FIX - Use $global scope for automatic variables inside class methods
            $process = Get-Process -Id $global:PID
            $memoryMB = [Math]::Round($process.WorkingSet64 / 1MB, 2)
            return "$memoryMB MB"
        } catch {
            return "Unknown"
        }
    }

    hidden [void] ClearPanelContent([Panel]$panel) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $panel.BackgroundColor)
        for ($y = $panel.ContentY; $y -lt ($panel.ContentY + $panel.ContentHeight); $y++) {
            for ($x = $panel.ContentX; $x -lt ($panel.ContentX + $panel.ContentWidth); $x++) {
                $panel._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    hidden [void] WriteTextToPanel([Panel]$panel, [string]$text, [int]$x, [int]$y, [ConsoleColor]$color) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        if ($y -ge $panel.ContentHeight) { return }
        
        $chars = $text.ToCharArray()
        for ($i = 0; $i -lt $chars.Length -and ($x + $i) -lt $panel.ContentWidth; $i++) {
            $cell = [TuiCell]::new($chars[$i], $color, $panel.BackgroundColor)
            $panel._private_buffer.SetCell($panel.ContentX + $x + $i, $panel.ContentY + $y, $cell)
        }
    }

    # --- Input Handling ---
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "HandleInput" -ScriptBlock {
            # AI: PHASE 3 - Handle hotkeys first
            $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
            if ($keyChar -match '^[123Q]$') {
                Write-Log -Level Debug -Message "Processing hotkey: $keyChar"
                try {
                    $this.MainMenu.ExecuteAction($keyChar)
                    return $true
                } catch {
                    Write-Log -Level Error -Message "Failed to execute menu action: $_"
                }
            }
            
            # AI: PHASE 3 - Handle navigation keys
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.MainMenu.SelectedIndex -gt 0) {
                        $this.MainMenu.SelectedIndex--
                        $this.RequestRedraw()
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.MainMenu.SelectedIndex -lt ($this.MainMenu.Items.Count - 1)) {
                        $this.MainMenu.SelectedIndex++
                        $this.RequestRedraw()
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    try {
                        $selectedItem = $this.MainMenu.Items[$this.MainMenu.SelectedIndex]
                        if ($selectedItem -and $selectedItem.Enabled) {
                            Write-Log -Level Debug -Message "Executing selected menu item: $($selectedItem.Key)"
                            $selectedItem.Execute()
                            return $true
                        }
                    } catch {
                        Write-Log -Level Error -Message "Failed to execute selected menu item: $_"
                    }
                }
                ([ConsoleKey]::Escape) {
                    Write-Log -Level Debug -Message "Escape pressed - requesting exit"
                    try {
                        $this.Services.Navigation.RequestExit()
                        return $true
                    } catch {
                        Write-Log -Level Error -Message "Failed to request exit: $_"
                    }
                }
                ([ConsoleKey]::F5) {
                    # AI: PHASE 3 - Refresh data on F5
                    $this.RefreshData()
                    $this.UpdateDisplay()
                    return $true
                }
            }
        }
        return $false
    }

    # --- NCurses Rendering ---
    [void] _RenderContent() {
        # AI: PHASE 3 - Buffer-based rendering
        if ($null -eq $this._private_buffer) { return }
        
        # AI: PHASE 3 - Clear buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black)
        $this._private_buffer.Clear($bgCell)
        
        # AI: PHASE 3 - Render all child components
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
            }
        }
    }

    # --- Lifecycle Methods ---
    [void] OnEnter() {
        $this.RefreshData()
        $this.UpdateDisplay()
        Write-Log -Level Debug -Message "DashboardScreen entered"
    }

    [void] OnExit() {
        Write-Log -Level Debug -Message "DashboardScreen exited"
    }

    [void] OnDeactivate() {
        $this.Cleanup()
        Write-Log -Level Debug -Message "DashboardScreen deactivated"
    }

    [void] Cleanup() {
        $this.Components.Clear()
        $this.Children.Clear()
        Write-Log -Level Debug -Message "DashboardScreen cleaned up"
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()


####\screens\task-list-screen\task-list-screen.psm1
# ==============================================================================
# PMC Terminal v5 - NCurses Task List Screen
# Displays and manages tasks with buffer-based rendering
# ==============================================================================

# AI: PHASE 3 REFACTORED - NCurses buffer-based architecture
#using module '..\components\tui-primitives.psm1'
#using module '..\layout\panels-class.psm1'
#using module '..\components\advanced-data-components.psm1'
#using module '..\modules\dialog-system-class.psm1'
#using module '..\modules\models.psm1'
#using module '..\components\ui-classes.psm1'
#using module '..\modules\logger.psm1'
#using module '..\modules\exceptions.psm1'

class TaskListScreen : UIElement {
    # --- Core Architecture ---
    [hashtable] $Services
    [Panel] $MainPanel
    [Panel] $HeaderPanel
    [Panel] $TablePanel
    [Panel] $FooterPanel
    [Table] $TaskTable
    [System.Collections.Generic.List[UIElement]] $Components

    # --- State Management ---
    [string] $FilterStatus = "All"
    [object[]] $AllTasks = @()
    [object[]] $FilteredTasks = @()
    [int] $SelectedIndex = 0

    # --- Constructor ---
    TaskListScreen([hashtable]$services) : base(0, 0, 120, 30) {
        $this.Name = "TaskListScreen"
        $this.Services = $services
        $this.Components = [System.Collections.Generic.List[UIElement]]::new()
        $this.IsFocusable = $true
        $this.Enabled = $true
        $this.Visible = $true
    }

    # --- Initialization ---
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # AI: PHASE 3 - Create main panel structure
            $this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "Task List")
            $this.MainPanel.HasBorder = $true
            $this.MainPanel.BorderStyle = "Double"
            $this.MainPanel.BorderColor = [ConsoleColor]::Gray
            $this.MainPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MainPanel.Name = "MainTaskPanel"
            $this.AddChild($this.MainPanel)
            
            # AI: PHASE 3 - Header panel for title and filter info
            $this.HeaderPanel = [Panel]::new(1, 1, 118, 3, "")
            $this.HeaderPanel.HasBorder = $false
            $this.HeaderPanel.BackgroundColor = [ConsoleColor]::Black
            $this.HeaderPanel.Name = "HeaderPanel"
            $this.MainPanel.AddChild($this.HeaderPanel)
            
            # AI: PHASE 3 - Table panel for task data
            $this.TablePanel = [Panel]::new(1, 4, 118, 22, "")
            $this.TablePanel.HasBorder = $true
            $this.TablePanel.BorderStyle = "Single"
            $this.TablePanel.BorderColor = [ConsoleColor]::DarkGray
            $this.TablePanel.BackgroundColor = [ConsoleColor]::Black
            $this.TablePanel.Name = "TablePanel"
            $this.MainPanel.AddChild($this.TablePanel)
            
            # AI: PHASE 3 - Footer panel for navigation help
            $this.FooterPanel = [Panel]::new(1, 26, 118, 3, "")
            $this.FooterPanel.HasBorder = $false
            $this.FooterPanel.BackgroundColor = [ConsoleColor]::Black
            $this.FooterPanel.Name = "FooterPanel"
            $this.MainPanel.AddChild($this.FooterPanel)
            
            # AI: PHASE 3 - Create task table component
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.Move(1, 1)  # Inside table panel
            $this.TaskTable.Resize(116, 20)

            # AI: FIX - Use proper TableColumn class instances
            $columns = @(
                [TableColumn]::new('Title', 'Task Title', 50),
                [TableColumn]::new('Status', 'Status', 15),
                [TableColumn]::new('Priority', 'Priority', 12),
                [TableColumn]::new('GetDueDateString', 'Due Date', 15) # Use method for display
            )
            $this.TaskTable.SetColumns($columns)
            
            $this.TablePanel.AddChild($this.TaskTable)
            
            # AI: PHASE 3 - Load initial data
            $this.RefreshData()
            $this.UpdateDisplay()
            
            Write-Log -Level Info -Message "TaskListScreen initialized with NCurses architecture"
        }
    }

    # --- Data Management ---
    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            # AI: PHASE 3 - Safe data loading with error handling
            try {
                $this.AllTasks = @($this.Services.DataManager.GetTasks())
                if ($null -eq $this.AllTasks) { $this.AllTasks = @() }
            } catch {
                Write-Log -Level Warning -Message "Failed to load tasks: $_"
                $this.AllTasks = @()
            }
            
            # AI: PHASE 3 - Apply current filter
            $this.FilteredTasks = switch ($this.FilterStatus) {
                "Active" { @($this.AllTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed }) }
                "Completed" { @($this.AllTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed }) }
                default { $this.AllTasks }
            }
            
            # AI: PHASE 3 - Update table data
            $this.TaskTable.SetData($this.FilteredTasks)
            
            # AI: PHASE 3 - Adjust selection if needed
            if ($this.SelectedIndex -ge $this.FilteredTasks.Count) {
                $this.SelectedIndex = [Math]::Max(0, $this.FilteredTasks.Count - 1)
            }
            
            $this.RequestRedraw()
        }
    }

    hidden [void] UpdateDisplay() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "UpdateDisplay" -ScriptBlock {
            # AI: PHASE 3 - Update header text
            $headerText = "Filter: $($this.FilterStatus) | Total: $($this.FilteredTasks.Count) tasks"
            $this.WriteTextToPanel($this.HeaderPanel, $headerText, 0, 0, [ConsoleColor]::White)
            
            # AI: PHASE 3 - Update footer navigation text
            $footerText = "[↑↓]Navigate [Space]Toggle [N]ew [E]dit [D]elete [F]ilter [Esc]Back"
            $this.WriteTextToPanel($this.FooterPanel, $footerText, 0, 0, [ConsoleColor]::Yellow)
            
            # AI: PHASE 3 - Update table selection
            $this.TaskTable.SelectedIndex = $this.SelectedIndex
            
            $this.RequestRedraw()
        }
    }

    # --- Helper Methods ---
    hidden [void] WriteTextToPanel([Panel]$panel, [string]$text, [int]$x, [int]$y, [ConsoleColor]$color) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        
        $chars = $text.ToCharArray()
        for ($i = 0; $i -lt $chars.Length -and ($x + $i) -lt $panel.ContentWidth; $i++) {
            $cell = [TuiCell]::new($chars[$i], $color, $panel.BackgroundColor)
            $panel._private_buffer.SetCell($panel.ContentX + $x + $i, $panel.ContentY + $y, $cell)
        }
    }

    # --- Input Handling ---
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $this.UpdateDisplay()
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt ($this.FilteredTasks.Count - 1) -and $this.FilteredTasks.Count -gt 0) {
                        $this.SelectedIndex++
                        $this.UpdateDisplay()
                        return $true
                    }
                }
                ([ConsoleKey]::Spacebar) {
                    $this.ToggleSelectedTask()
                    return $true
                }
                ([ConsoleKey]::Escape) {
                    $this.NavigateBack()
                    return $true
                }
                default {
                    $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
                    switch ($keyChar) {
                        'N' { $this.ShowNewTaskDialog(); return $true }
                        'E' { $this.EditSelectedTask(); return $true }
                        'D' { $this.DeleteSelectedTask(); return $true }
                        'F' { $this.CycleFilter(); return $true }
                    }
                }
            }
        }
        return $false
    }

    # --- Task Actions ---
    hidden [void] ToggleSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        try {
            $newCompletedStatus = $task.Status -ne [TaskStatus]::Completed
            
            $this.Services.DataManager.UpdateTask(@{
                Task = $task
                Completed = $newCompletedStatus
            })
            
            $this.RefreshData()
            $this.UpdateDisplay()
        } catch {
            Write-Log -Level Error -Message "Failed to toggle task: $_"
        }
    }

    hidden [void] ShowNewTaskDialog() {
        Write-Log -Level Info -Message "New task dialog requested"
        
        $dataManager = $this.Services.DataManager
        $refreshCallback = { $this.RefreshData(); $this.UpdateDisplay() }.GetNewClosure()
        
        try {
            Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {
                param($Value)
                if (-not [string]::IsNullOrWhiteSpace($Value)) {
                    # AI: FIX - This now uses correct method call syntax with positional arguments.
                    $newTask = $dataManager.AddTask($Value, "", "medium", "General")
                    Write-Log -Level Info -Message "Created new task: $($newTask.Title)"
                    & $refreshCallback
                }
            }
        } catch {
            Write-Log -Level Error -Message "Failed to show new task dialog: $_"
        }
    }

    hidden [void] EditSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        Write-Log -Level Info -Message "Edit task requested for: $($task.Title)"
        
        $refreshCallback = { $this.RefreshData(); $this.UpdateDisplay() }.GetNewClosure()
        try {
            Show-InputDialog -Title "Edit Task" -Prompt "New title:" -DefaultValue $task.Title -OnSubmit {
                param($Value)
                if (-not [string]::IsNullOrWhiteSpace($Value)) {
                    $this.Services.DataManager.UpdateTask(@{
                        Task = $task
                        Title = $Value
                    })
                    & $refreshCallback
                }
            }
        } catch {
             Write-Log -Level Error -Message "Failed to show edit task dialog: $_"
        }
    }

    hidden [void] DeleteSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        Write-Log -Level Info -Message "Delete task requested for: $($task.Title)"
        
        $refreshCallback = { $this.RefreshData(); $this.UpdateDisplay() }.GetNewClosure()
        try {
            Show-ConfirmDialog -Title "Delete Task" -Message "Are you sure you want to delete `"$($task.Title)`"?" -OnConfirm {
                $this.Services.DataManager.RemoveTask($task)
                & $refreshCallback
            }
        } catch {
             Write-Log -Level Error -Message "Failed to show delete confirm dialog: $_"
        }
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
        $this.UpdateDisplay()
    }

    hidden [void] NavigateBack() {
        try {
            $this.Services.Navigation.PopScreen()
        } catch {
            Write-Log -Level Error -Message "Failed to navigate back: $_"
        }
    }

    # --- NCurses Rendering ---
    [void] _RenderContent() {
        # AI: PHASE 3 - Buffer-based rendering
        if ($null -eq $this._private_buffer) { return }
        
        # AI: PHASE 3 - Clear buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black)
        $this._private_buffer.Clear($bgCell)
        
        # AI: PHASE 3 - Render all child components
        # Call the base class's _RenderContent which handles compositing children.
        ([UIElement]$this)._RenderContent()
    }
    
    # --- Lifecycle Methods ---
    [void] OnEnter() {
        $this.RefreshData()
        $this.UpdateDisplay()
        Write-Log -Level Debug -Message "TaskListScreen entered"
    }

    [void] OnExit() {
        Write-Log -Level Debug -Message "TaskListScreen exited"
    }

    [void] Cleanup() {
        $this.Components.Clear()
        $this.Children.Clear()
        Write-Log -Level Debug -Message "TaskListScreen cleaned up"
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()


####\services\keybinding-service\keybinding-service.psm1
# keybinding-service.psm1
# Contains only the factory function for creating KeybindingService instances.

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function New-KeybindingService {
    <#
    .SYNOPSIS
    Creates a new instance of the KeybindingService class.
    #>
    [CmdletBinding()]
    param(
        [switch]$EnableChords
    )
    
    if ($EnableChords) {
        return [KeybindingService]::new($true)
    }
    else {
        return [KeybindingService]::new()
    }
}

Export-ModuleMember -Function 'New-KeybindingService'


####\services\keybinding-service-class\keybinding-service-class.psm1
# keybinding-service-class.psm1
# Contains only the KeybindingService class definition.

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

class KeybindingService {
    [hashtable] $KeyMap = @{}
    [hashtable] $GlobalHandlers = @{}
    [System.Collections.Generic.List[string]] $ContextStack
    [bool] $EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized"
    }
    
    KeybindingService([bool]$enableChords) {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.EnableChords = $enableChords
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized with chords: $enableChords"
    }
    
    hidden [void] InitializeDefaultBindings() {
        # AI: Standard application keybindings
        $this.KeyMap = @{
            "app.exit" = @{ Key = "Q"; Modifiers = @("Ctrl") }
            "app.help" = @{ Key = [System.ConsoleKey]::F1; Modifiers = @() }
            "nav.back" = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }
            "nav.up" = @{ Key = [System.ConsoleKey]::UpArrow; Modifiers = @() }
            "nav.down" = @{ Key = [System.ConsoleKey]::DownArrow; Modifiers = @() }
            "nav.left" = @{ Key = [System.ConsoleKey]::LeftArrow; Modifiers = @() }
            "nav.right" = @{ Key = [System.ConsoleKey]::RightArrow; Modifiers = @() }
            "nav.select" = @{ Key = [System.ConsoleKey]::Enter; Modifiers = @() }
            "nav.pageup" = @{ Key = [System.ConsoleKey]::PageUp; Modifiers = @() }
            "nav.pagedown" = @{ Key = [System.ConsoleKey]::PageDown; Modifiers = @() }
            "nav.home" = @{ Key = [System.ConsoleKey]::Home; Modifiers = @() }
            "nav.end" = @{ Key = [System.ConsoleKey]::End; Modifiers = @() }
            "nav.tab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @() }
            "nav.shifttab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @("Shift") }
            "edit.delete" = @{ Key = [System.ConsoleKey]::Delete; Modifiers = @() }
            "edit.backspace" = @{ Key = [System.ConsoleKey]::Backspace; Modifiers = @() }
            "edit.new" = @{ Key = "n"; Modifiers = @() }
            "edit.save" = @{ Key = "s"; Modifiers = @("Ctrl") }
            "app.refresh" = @{ Key = [System.ConsoleKey]::F5; Modifiers = @() }
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKey]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [char]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
        }
        
        $modifiers = @()
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) { $modifiers += "Ctrl" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) { $modifiers += "Alt" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) { $modifiers += "Shift" }

        $this.KeyMap[$actionName.ToLower()] = @{
            Key = $keyInfo.Key
            KeyChar = $keyInfo.KeyChar
            Modifiers = $modifiers
        }
        Write-Log -Level Debug -Message "Set keybinding for '$actionName': $($this.GetBindingDescription($actionName))"
    }
    
    [void] RemoveBinding([string]$actionName) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RemoveBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return
            }
            
            $normalizedName = $actionName.ToLower()
            if ($this.KeyMap.ContainsKey($normalizedName)) {
                $this.KeyMap.Remove($normalizedName)
                Write-Log -Level Debug -Message "Removed keybinding: $actionName"
            }
        }
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        return $this.IsAction($actionName, $keyInfo, $null)
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "IsAction:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return $false
            }
            
            $normalizedName = $actionName.ToLower()
            if (-not $this.KeyMap.ContainsKey($normalizedName)) {
                return $false
            }
            
            $binding = $this.KeyMap[$normalizedName]
            
            # Check if the key matches
            $keyMatches = $false
            if ($binding.Key -is [System.ConsoleKey]) {
                $keyMatches = ($keyInfo.Key -eq $binding.Key)
            }
            elseif ($binding.Key -is [char]) {
                $keyMatches = ($keyInfo.KeyChar -eq $binding.Key)
            }
            elseif ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
                # Character-based binding (case-insensitive)
                $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.KeyChar.ToString(), [System.StringComparison]::OrdinalIgnoreCase)
            }
            else {
                # Try string comparison for backward compatibility
                $keyString = $binding.Key.ToString()
                if ($keyString.Length -eq 1) {
                    $keyMatches = ($keyInfo.KeyChar.ToString().ToUpper() -eq $keyString.ToUpper())
                }
                else {
                    # Try to match against ConsoleKey enum
                    try {
                        $consoleKey = [System.ConsoleKey]::Parse([System.ConsoleKey], $keyString, $true)
                        $keyMatches = ($keyInfo.Key -eq $consoleKey)
                    }
                    catch {
                        $keyMatches = $false
                    }
                }
            }
            
            if (-not $keyMatches) {
                return $false
            }
            
            # Check modifiers
            $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
            $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
            $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
            
            $expectedCtrl = $binding.Modifiers -contains "Ctrl"
            $expectedAlt = $binding.Modifiers -contains "Alt"
            $expectedShift = $binding.Modifiers -contains "Shift"
            
            return ($hasCtrl -eq $expectedCtrl) -and ($hasAlt -eq $expectedAlt) -and ($hasShift -eq $expectedShift)
        }
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "GetAction" -ScriptBlock {
            foreach ($actionName in $this.KeyMap.Keys) {
                if ($this.IsAction($actionName, $keyInfo)) {
                    return $actionName
                }
            }
            return $null
        }
    }
    
    [void] RegisterGlobalHandler([string]$actionName, [scriptblock]$handler) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RegisterGlobalHandler:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            if ($null -eq $handler) {
                throw [System.ArgumentNullException]::new("handler", "Handler cannot be null")
            }
            
            $this.GlobalHandlers[$actionName.ToLower()] = $handler
            Write-Log -Level Debug -Message "Registered global handler: $actionName"
        }
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo) {
        return $this.HandleKey($keyInfo, $null)
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "HandleKey" -ScriptBlock {
            # Check all registered actions
            foreach ($action in $this.KeyMap.Keys) {
                if ($this.IsAction($action, $keyInfo, $context)) {
                    # Execute global handler if registered
                    if ($this.GlobalHandlers.ContainsKey($action)) {
                        Write-Log -Level Debug -Message "Executing global handler: $action"
                        try {
                            return & $this.GlobalHandlers[$action] -KeyInfo $keyInfo -Context $context
                        }
                        catch {
                            Write-Log -Level Error -Message "Global handler failed for '$action': $_"
                            return $null
                        }
                    }
                    
                    # Return the action name for the caller to handle
                    return $action
                }
            }
            
            return $null
        }
    }
    
    [void] PushContext([string]$context) {
        if (-not [string]::IsNullOrWhiteSpace($context)) {
            $this.ContextStack.Add($context)
            Write-Log -Level Debug -Message "Pushed keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
        }
    }
    
    [string] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $context = $this.ContextStack[-1]
            $this.ContextStack.RemoveAt($this.ContextStack.Count - 1)
            Write-Log -Level Debug -Message "Popped keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
            return $context
        }
        return $null
    }
    
    [string] GetCurrentContext() {
        if ($this.ContextStack.Count -gt 0) {
            return $this.ContextStack[-1]
        }
        return "global"
    }
    
    [string] GetBindingDescription([string]$actionName) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            return $null
        }
        
        $normalizedName = $actionName.ToLower()
        if (-not $this.KeyMap.ContainsKey($normalizedName)) {
            return "Unbound"
        }
        
        $binding = $this.KeyMap[$normalizedName]
        $keyStr = if ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
            $binding.KeyChar.ToString().ToUpper()
        } elseif ($binding.Key -is [System.ConsoleKey]) {
            $binding.Key.ToString()
        } else {
            $binding.Key.ToString().ToUpper()
        }
        
        if ($binding.Modifiers.Count -gt 0) {
            return "$($binding.Modifiers -join '+') + $keyStr"
        }
        
        return $keyStr
    }
    
    [hashtable] GetAllBindings() {
        return $this.GetAllBindings($false)
    }
    
    [hashtable] GetAllBindings([bool]$groupByCategory) {
        if (-not $groupByCategory) {
            return $this.KeyMap.Clone()
        }
        
        # Group by category (part before the dot)
        $grouped = @{}
        foreach ($action in $this.KeyMap.Keys) {
            $parts = $action.Split('.')
            $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
            if (-not $grouped.ContainsKey($category)) {
                $grouped[$category] = @{}
            }
            $grouped[$category][$action] = $this.KeyMap[$action]
        }
        
        return $grouped
    }
    
    [void] ExportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ExportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            $this.KeyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $path -Encoding UTF8
            Write-Log -Level Info -Message "Exported keybindings to: $path"
        }
    }
    
    [void] ImportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ImportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            if (-not (Test-Path $path)) {
                Write-Log -Level Warning -Message "Keybindings file not found: $path"
                return
            }
            
            try {
                $imported = Get-Content $path -Raw | ConvertFrom-Json
                foreach ($prop in $imported.PSObject.Properties) {
                    $bindingData = @{
                        Key = $prop.Value.Key
                        Modifiers = $prop.Value.Modifiers
                    }
                    if ($prop.Value.PSObject.Properties.Name -contains 'KeyChar') {
                        $bindingData['KeyChar'] = $prop.Value.KeyChar
                    }
                    $this.KeyMap[$prop.Name] = $bindingData
                }
                Write-Log -Level Info -Message "Imported keybindings from: $path"
            }
            catch {
                Write-Log -Level Error -Message "Failed to import keybindings from '$path': $_"
                throw
            }
        }
    }
}


####\services\navigation-service\navigation-service.psm1
# navigation-service-functions.psm1
# Contains only the factory function for the NavigationService.

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Initialize-NavigationService {
    param([hashtable]$Services)
    if (-not $Services) { throw [System.ArgumentNullException]::new("Services") }
    return [NavigationService]::new($Services)
}

Export-ModuleMember -Function 'Initialize-NavigationService'


####\services\navigation-service-class\navigation-service-class.psm1
# navigation-service-class.psm1
# Contains only the NavigationService and ScreenFactory class definitions.

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

class ScreenFactory {
    hidden [hashtable] $Services
    hidden [hashtable] $ScreenTypes = @{}
    
    ScreenFactory([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        Write-Log -Level Debug -Message "ScreenFactory initialized"
    }
    
    [void] RegisterScreen([string]$name, [type]$screenType) {
        if (-not $screenType.IsSubclassOf([Screen])) { 
            throw "Screen type '$($screenType.Name)' must inherit from the Screen class." 
        }
        $this.ScreenTypes[$name] = $screenType
        Write-Log -Level Info -Message "Registered screen factory: $name -> $($screenType.Name)"
    }
    
    [Screen] CreateScreen([string]$screenName, [hashtable]$parameters) {
        $screenType = $this.ScreenTypes[$screenName]
        if (-not $screenType) {
            throw "Unknown screen type: '$screenName'. Available screens: $($this.ScreenTypes.Keys -join ', ')"
        }
        
        try {
            $screen = $screenType::new($this.Services)
            if ($parameters) {
                foreach ($key in $parameters.Keys) { 
                    $screen.State[$key] = $parameters[$key] 
                }
            }
            Write-Log -Level Info -Message "Created screen: $screenName"
            return $screen
        } catch {
            Write-Log -Level Error -Message "Failed to create screen '$screenName': $($_.Exception.Message)"
            throw
        }
    }
    
    [string[]] GetRegisteredScreens() {
        return @($this.ScreenTypes.Keys)
    }
}

class NavigationService {
    [System.Collections.Generic.Stack[Screen]] $ScreenStack
    [ScreenFactory] $ScreenFactory
    [Screen] $CurrentScreen
    [hashtable] $Services
    [hashtable] $RouteMap = @{}
    
    NavigationService([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        $this.ScreenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.ScreenFactory = [ScreenFactory]::new($services)
        $this.InitializeRoutes()
        Write-Log -Level Info -Message "NavigationService initialized"
    }
    
    hidden [void] InitializeRoutes() {
        $this.RouteMap = @{
            "/" = "DashboardScreen"
            "/dashboard" = "DashboardScreen"
            "/tasks" = "TaskListScreen"
        }
        Write-Log -Level Debug -Message "Routes initialized: $($this.RouteMap.Keys -join ', ')"
    }
    
    [void] RegisterScreenClass([string]$name, [type]$screenType) {
        $this.ScreenFactory.RegisterScreen($name, $screenType)
    }
    
    [void] GoTo([string]$path, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "GoTo:$path" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) { 
                throw [System.ArgumentException]::new("Path cannot be empty.") 
            }
            if ($path -eq "/exit") { 
                $this.RequestExit()
                return 
            }
            
            $screenName = $this.RouteMap[$path]
            if (-not $screenName) {
                $availableRoutes = $this.RouteMap.Keys -join ', '
                throw "Unknown route: '$path'. Available routes: $availableRoutes"
            }
            
            Write-Log -Level Info -Message "Navigating to: $path -> $screenName"
            $this.PushScreen($screenName, $parameters)
        }
    }
    
    [void] PushScreen([string]$screenName, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "PushScreen:$screenName" -ScriptBlock {
            Write-Log -Level Info -Message "Pushing screen: $screenName"
            
            if ($this.CurrentScreen) {
                Write-Log -Level Debug -Message "Exiting current screen: $($this.CurrentScreen.Name)"
                $this.CurrentScreen.OnExit()
                $this.ScreenStack.Push($this.CurrentScreen)
            }
            
            Write-Log -Level Debug -Message "Creating new screen: $screenName"
            $newScreen = $this.ScreenFactory.CreateScreen($screenName, $parameters)
            $this.CurrentScreen = $newScreen
            
            Write-Log -Level Debug -Message "Initializing screen: $screenName"
            $newScreen.Initialize()
            $newScreen.OnEnter()
            
            if (Get-Command "Push-Screen" -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Pushing screen to TUI engine"
                Push-Screen -Screen $newScreen
            } else {
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $newScreen
                    Request-TuiRefresh
                }
            }
            
            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{ Screen = $screenName; Action = "Push" }
            Write-Log -Level Info -Message "Successfully pushed screen: $screenName"
        }
    }
    
    [bool] PopScreen() {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "PopScreen" -ScriptBlock {
            if ($this.ScreenStack.Count -eq 0) { 
                Write-Log -Level Warning -Message "Cannot pop screen: stack is empty"
                return $false 
            }
            
            Write-Log -Level Info -Message "Popping screen"
            $this.CurrentScreen?.OnExit()
            $this.CurrentScreen = $this.ScreenStack.Pop()
            $this.CurrentScreen?.OnResume()
            
            if (Get-Command "Pop-Screen" -ErrorAction SilentlyContinue) {
                Pop-Screen
            } else {
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $this.CurrentScreen
                    Request-TuiRefresh
                }
            }
            
            Publish-Event -EventName "Navigation.ScreenPopped" -Data @{ Screen = $this.CurrentScreen.Name }
            return $true
        }
    }
    
    [void] RequestExit() {
        Write-Log -Level Info -Message "Exit requested"
        while ($this.PopScreen()) {} # Pop all screens
        $this.CurrentScreen?.OnExit()
        if (Get-Command "Stop-TuiEngine" -ErrorAction SilentlyContinue) {
            Stop-TuiEngine
        }
        Publish-Event -EventName "Application.Exit"
    }
    
    [Screen] GetCurrentScreen() { return $this.CurrentScreen }
    [bool] IsValidRoute([string]$path) { return $this.RouteMap.ContainsKey($path) }
    
    [void] ListRegisteredScreens() {
        $screens = $this.ScreenFactory.GetRegisteredScreens()
        Write-Log -Level Info -Message "Registered screens: $($screens -join ', ')"
        Write-Host "Registered screens: $($screens -join ', ')" -ForegroundColor Green
    }
    
    [void] ListAvailableRoutes() {
        $routes = $this.RouteMap.Keys
        Write-Log -Level Info -Message "Available routes: $($routes -join ', ')"
        Write-Host "Available routes: $($routes -join ', ')" -ForegroundColor Green
    }
}


####\_CLASSY-MAIN.ps1
# _CLASSY-MAIN.ps1 (Corrected and Final)
#
# This script uses the modern 'using module' syntax, which is the correct
# way to load PowerShell modules and their classes in PS 7+.
# The load order has been fixed to resolve all class and function dependencies.
#
#Requires -Version 7.0

# ==============================================================================
# STAGE 1: MODULE LOADING (Handled by PowerShell Engine)
# 'using module' statements MUST be at the very top of the script.
# PowerShell parses these first, ensuring all types are available before
# any script code is executed. The order is critical for dependencies.
# ==============================================================================

# Layer 0: Core Primitives & Models (No internal dependencies)
using module '.\modules\logger\logger.psm1'
using module '.\modules\exceptions\exceptions.psm1'
using module '.\modules\models\models.psm1'
using module '.\components\tui-primitives\tui-primitives.psm1'

# Layer 1: Foundational Systems (Depend on Layer 0)
using module '.\modules\event-system\event-system.psm1'      # Depends on logger, exceptions
#using module '.\components\ui-classes\ui-classes.psm1'       # Depends on primitives, event-system
#using module '.\modules\theme-manager\theme-manager.psm1'     # Depends on logger, event-system

# Layer 2: Layout & Core Components (Depend on Layer 1)
#using module '.\layout\panels-class\panels-class.psm1'             # Depends on ui-classes
#using module '.\components\navigation-class\navigation-class.psm1'     # Depends on ui-classes
#using module '.\components\tui-components\tui-components.psm1'       # Depends on ui-classes

# Layer 3: Advanced Components & Data/Service Classes (Depend on previous layers)
#using module '.\components\advanced-data-components\advanced-data-components.psm1'
#using module '.\components\advanced-input-components\advanced-input-components.psm1'
#using module '.\modules\data-manager-class\data-manager-class.psm1'
#using module '.\services\keybinding-service-class\keybinding-service-class.psm1'
#using module '.\services\navigation-service-class\navigation-service-class.psm1'
#using module '.\modules\dialog-system-class\dialog-system-class.psm1'

# Layer 4: Service Implementation & TUI Engine (Depend on classes and primitives)
#using module '.\modules\data-manager\data-manager.psm1'
#using module '.\services\keybinding-service\keybinding-service.psm1'
#using module '.\services\navigation-service\navigation-service.psm1'
#using module '.\modules\tui-engine\tui-engine.psm1'

# Layer 5: Application Screens (The final layer, depends on all others)
#using module '.\screens\dashboard-screen\dashboard-screen.psm1'
#using module '.\screens\task-list-screen\task-list-screen.psm1'


# ==============================================================================
# STAGE 2: APPLICATION BOOTSTRAP
# All modules are now loaded and all functions/classes are available.
# ==============================================================================
param(
    [switch]$Debug,
    [switch]$SkipLogo
)

# Set execution context
Set-Location $PSScriptRoot
$ErrorActionPreference = 'Stop'

try {
    Write-Host "`n=== PMC Terminal v5 - Starting (Classy Loader) ===" -ForegroundColor Cyan
    Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)" -ForegroundColor DarkGray
    
    # Initialize core services that have no dependencies
    Write-Host "`nInitializing services..." -ForegroundColor Yellow
    Initialize-Logger -Level $(if ($Debug) { "Debug" } else { "Info" })
    Initialize-EventSystem
    Initialize-ThemeManager
    
    # Create the service container
    $services = @{}
    
    # Initialize services that depend on others, passing the container
    $services.KeybindingService = New-KeybindingService
    $services.DataManager = Initialize-DataManager
    
    # NavigationService needs the $services container to pass to screens
    $services.Navigation = Initialize-NavigationService -Services $services
    
    # Register screen classes with the navigation service
    $services.Navigation.RegisterScreenClass("DashboardScreen", [DashboardScreen])
    $services.Navigation.RegisterScreenClass("TaskListScreen", [TaskListScreen])
    
    # Initialize the dialog system
    Initialize-DialogSystem
    
    Write-Host "All services initialized!" -ForegroundColor Green
    
    if (-not $SkipLogo) {
        Write-Host @"
    
    ╔═══════════════════════════════════════╗
    ║      PMC Terminal v5.0                ║
    ║      PowerShell Management Console    ║
    ╚═══════════════════════════════════════╝
    
"@ -ForegroundColor Cyan
    }
    
    # Initialize the TUI Engine which orchestrates the UI
    Write-Host "Starting TUI Engine..." -ForegroundColor Yellow
    Initialize-TuiEngine
    
    # Create and initialize the first screen
    $dashboard = [DashboardScreen]::new($services)
    $dashboard.Initialize()
    
    # Push the screen to the engine and start the main loop
    Push-Screen -Screen $dashboard
    Start-TuiLoop
    
} catch {
    Write-Host "`n=== FATAL ERROR ===" -ForegroundColor Red
    Write-Host "An error occurred during application startup."
    Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack Trace:" -ForegroundColor DarkRed
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
    
    Write-Host "`nPress any key to exit..." -ForegroundColor Yellow
    if ($Host.UI.RawUI) {
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    }
    exit 1
} finally {
    # Cleanup logic if needed
    Pop-Location -ErrorAction SilentlyContinue
   
}


####\axiom.ps1
# PMC-Terminal-Axiom-Loader.ps1
# Master loader for PMC Terminal v5 (Axiom) with comprehensive debugging

[CmdletBinding()]
param(
    [switch]$DebugLoading,
    [switch]$VerboseErrors,
    [switch]$CleanSession
)

# Global tracking for module load debugging
$Global:PMC_LoadTrace = @()
$Global:PMC_LoadErrors = @()

function Write-LoadTrace {
    param([string]$Message, [string]$Type = "INFO")
    $timestamp = Get-Date -Format "HH:mm:ss.fff"
    $traceEntry = "$timestamp [$Type] $Message"
    $Global:PMC_LoadTrace += $traceEntry
    
    if ($DebugLoading) {
        $color = switch ($Type) {
            "ERROR" { "Red" }
            "WARN"  { "Yellow" }
            "SUCCESS" { "Green" }
            default { "Cyan" }
        }
        Write-Host $traceEntry -ForegroundColor $color
    }
}

function Test-ModuleManifest {
    param([string]$ManifestPath)
    
    try {
        $manifest = Import-PowerShellDataFile -Path $ManifestPath -ErrorAction Stop
        Write-LoadTrace "Manifest validated: $ManifestPath" "SUCCESS"
        return $manifest
    }
    catch {
        Write-LoadTrace "Manifest validation failed: $ManifestPath - $($_.Exception.Message)" "ERROR"
        $Global:PMC_LoadErrors += @{
            Type = "ManifestValidation"
            Path = $ManifestPath
            Error = $_.Exception.Message
            FullError = $_
        }
        return $null
    }
}

function Get-ModuleDependencyTree {
    param([string]$ManifestPath)
    
    $manifest = Test-ModuleManifest -ManifestPath $ManifestPath
    if (-not $manifest) { return @() }
    
    $dependencies = @()
    if ($manifest.RequiredModules) {
        foreach ($dep in $manifest.RequiredModules) {
            $depName = if ($dep -is [string]) { $dep } else { $dep.ModuleName }
            $dependencies += $depName
            Write-LoadTrace "Found dependency: $depName for $ManifestPath"
        }
    }
    
    return $dependencies
}

function Clear-ModuleCache {
    Write-LoadTrace "Clearing PowerShell module cache" "INFO"
    
    # Remove any PMC-related modules from current session
    Get-Module | Where-Object { $_.Name -like "*PMC*" -or $_.Name -like "*Tui*" } | Remove-Module -Force
    
    # Clear the module cache
    $cacheDir = "$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\ModuleAnalysisCache"
    if (Test-Path $cacheDir) {
        try {
            Remove-Item "$cacheDir\*" -Recurse -Force -ErrorAction SilentlyContinue
            Write-LoadTrace "Module analysis cache cleared" "SUCCESS"
        }
        catch {
            Write-LoadTrace "Warning: Could not clear module cache - $($_.Exception.Message)" "WARN"
        }
    }
}

function Test-PMCEnvironment {
    Write-LoadTrace "Testing PMC Terminal environment" "INFO"
    
    # Check PowerShell version
    if ($PSVersionTable.PSVersion.Major -lt 7) {
        Write-LoadTrace "ERROR: PowerShell 7+ required. Current version: $($PSVersionTable.PSVersion)" "ERROR"
        return $false
    }
    
    # Check if we're in the right directory
    $expectedFiles = @("PMCTerminal.psd1", "_CLASSY-MAIN.ps1")
    foreach ($file in $expectedFiles) {
        if (-not (Test-Path $file)) {
            Write-LoadTrace "ERROR: Missing expected file: $file" "ERROR"
            return $false
        }
    }
    
    Write-LoadTrace "Environment validation passed" "SUCCESS"
    return $true
}

function Import-PMCModuleWithDebugging {
    param([string]$ModulePath)
    
    try {
        Write-LoadTrace "Attempting to import: $ModulePath" "INFO"
        
        # Pre-flight check
        if (-not (Test-Path $ModulePath)) {
            throw "Module path does not exist: $ModulePath"
        }
        
        # Import with explicit error handling
        $module = Import-Module $ModulePath -PassThru -Force -ErrorAction Stop
        
        Write-LoadTrace "Successfully imported: $($module.Name) from $ModulePath" "SUCCESS"
        return $module
    }
    catch {
        $errorDetails = @{
            Type = "ModuleImport"
            Path = $ModulePath
            Error = $_.Exception.Message
            FullError = $_
            InnerException = $_.Exception.InnerException?.Message
            ScriptStackTrace = $_.ScriptStackTrace
        }
        
        $Global:PMC_LoadErrors += $errorDetails
        
        Write-LoadTrace "FAILED to import: $ModulePath" "ERROR"
        Write-LoadTrace "Error: $($_.Exception.Message)" "ERROR"
        
        if ($VerboseErrors) {
            Write-LoadTrace "Stack trace: $($_.ScriptStackTrace)" "ERROR"
            if ($_.Exception.InnerException) {
                Write-LoadTrace "Inner exception: $($_.Exception.InnerException.Message)" "ERROR"
            }
        }
        
        throw
    }
}

function Show-LoadReport {
    Write-Host "`n=== PMC Terminal Load Report ===" -ForegroundColor Magenta
    Write-Host "Total trace entries: $($Global:PMC_LoadTrace.Count)" -ForegroundColor Cyan
    Write-Host "Total errors: $($Global:PMC_LoadErrors.Count)" -ForegroundColor $(if ($Global:PMC_LoadErrors.Count -eq 0) { "Green" } else { "Red" })
    
    if ($Global:PMC_LoadErrors.Count -gt 0) {
        Write-Host "`nERRORS ENCOUNTERED:" -ForegroundColor Red
        foreach ($error in $Global:PMC_LoadErrors) {
            Write-Host "  Type: $($error.Type)" -ForegroundColor Yellow
            Write-Host "  Path: $($error.Path)" -ForegroundColor Yellow
            Write-Host "  Error: $($error.Error)" -ForegroundColor Red
            if ($VerboseErrors -and $error.InnerException) {
                Write-Host "  Inner: $($error.InnerException)" -ForegroundColor Red
            }
            Write-Host ""
        }
    }
    
    if ($DebugLoading) {
        Write-Host "`nFULL TRACE LOG:" -ForegroundColor Magenta
        $Global:PMC_LoadTrace | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }
    }
}

function Start-PMCTerminal {
    try {
        Write-LoadTrace "Starting PMC Terminal application" "INFO"
        
        # Look for the main entry point
        if (Test-Path "_CLASSY-MAIN.ps1") {
            Write-LoadTrace "Executing _CLASSY-MAIN.ps1" "INFO"
            & ".\_CLASSY-MAIN.ps1"
        }
        elseif (Get-Command "Start-PMCTerminal" -ErrorAction SilentlyContinue) {
            Write-LoadTrace "Calling Start-PMCTerminal command" "INFO"
            Start-PMCTerminal
        }
        else {
            throw "No valid entry point found. Expected _CLASSY-MAIN.ps1 or Start-PMCTerminal command."
        }
    }
    catch {
        Write-LoadTrace "Failed to start PMC Terminal: $($_.Exception.Message)" "ERROR"
        $Global:PMC_LoadErrors += @{
            Type = "ApplicationStart"
            Error = $_.Exception.Message
            FullError = $_
        }
        throw
    }
}

# === MAIN EXECUTION ===

try {
    Write-Host "PMC Terminal v5 (Axiom) Loader" -ForegroundColor Green
    Write-Host "================================" -ForegroundColor Green
    
    # Clear session if requested
    if ($CleanSession) {
        Clear-ModuleCache
    }
    
    # Environment validation
    if (-not (Test-PMCEnvironment)) {
        throw "Environment validation failed. Check the trace above for details."
    }
    
    # Validate main manifest exists
    $mainManifest = "PMCTerminal.psd1"
    if (-not (Test-Path $mainManifest)) {
        throw "Main manifest not found: $mainManifest"
    }
    
    # Read main manifest to get dependencies
    Write-LoadTrace "Reading main manifest: $mainManifest" "INFO"
    $manifestData = Import-PowerShellDataFile -Path $mainManifest -ErrorAction Stop
    
    # Manually load each required module first
    if ($manifestData.RequiredModules) {
        Write-LoadTrace "Loading required modules manually..." "INFO"
        foreach ($reqModule in $manifestData.RequiredModules) {
            $modulePath = if ($reqModule -is [hashtable]) {
                $reqModule.ModuleName
            } else {
                $reqModule
            }
            
            Write-LoadTrace "Loading dependency: $modulePath" "INFO"
            try {
                # Import the dependency
                Import-Module $modulePath -Force -ErrorAction Stop
                Write-LoadTrace "Successfully loaded: $modulePath" "SUCCESS"
            }
            catch {
                Write-LoadTrace "Failed to load dependency: $modulePath - $($_.Exception.Message)" "ERROR"
                throw
            }
        }
    }
    
    # Now we need to temporarily remove RequiredModules from the manifest
    # Create a temporary manifest without RequiredModules
    $tempManifest = "PMCTerminal-temp.psd1"
    $manifestContent = Get-Content $mainManifest -Raw
    $manifestContent = $manifestContent -replace "RequiredModules\s*=\s*@\([^)]+\)", "RequiredModules = @()"
    $manifestContent | Out-File $tempManifest -Encoding UTF8
    
    # Import the main module using the temp manifest
    Write-LoadTrace "Importing main PMC Terminal module" "INFO"
    $pmcModule = Import-PMCModuleWithDebugging -ModulePath ".\$tempManifest"
    
    # Clean up temp manifest
    Remove-Item $tempManifest -Force -ErrorAction SilentlyContinue
    
    Write-LoadTrace "PMC Terminal module loaded successfully" "SUCCESS"
    Write-LoadTrace "Loaded module: $($pmcModule.Name), Version: $($pmcModule.Version)" "SUCCESS"
    
    # Show what got loaded
    $loadedModules = Get-Module | Where-Object { $_.Name -like "*PMC*" -or $_.Name -like "*Tui*" }
    Write-LoadTrace "Total PMC/TUI modules loaded: $($loadedModules.Count)" "SUCCESS"
    
    if ($DebugLoading) {
        foreach ($mod in $loadedModules) {
            Write-LoadTrace "  Loaded: $($mod.Name) v$($mod.Version) from $($mod.ModuleBase)" "SUCCESS"
        }
    }
    
    # Start the application
    Start-PMCTerminal
}
catch {
    Write-LoadTrace "CRITICAL ERROR: $($_.Exception.Message)" "ERROR"
    
    if ($VerboseErrors) {
        Write-LoadTrace "Full exception details:" "ERROR"
        Write-LoadTrace $_.Exception.ToString() "ERROR"
    }
}
finally {
    # Always show the load report
    Show-LoadReport
    
    # Export trace for debugging
    if ($Global:PMC_LoadTrace) {
        $traceFile = "PMC_Load_Trace_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
        $Global:PMC_LoadTrace | Out-File -FilePath $traceFile -Encoding UTF8
        Write-Host "Load trace saved to: $traceFile" -ForegroundColor Green
    }
    
    # Clean up any temp files
    if (Test-Path "PMCTerminal-temp.psd1") {
        Remove-Item "PMCTerminal-temp.psd1" -Force -ErrorAction SilentlyContinue
    }
}


####\Clear-ModuleCache.ps1
# Clear PowerShell Module Cache for PMC Terminal
Write-Host "Clearing PowerShell module cache..." -ForegroundColor Yellow

# Get all loaded modules from our application
$modulesToRemove = Get-Module | Where-Object { 
    $_.Path -like "*\_CLASSY*" -or 
    $_.Name -in @('models', 'logger', 'exceptions', 'event-system', 'data-manager', 
                   'theme-manager', 'tui-framework', 'tui-engine-v2', 'dialog-system',
                   'keybinding-service', 'navigation-service-class', 'panels-class',
                   'focus-manager', 'advanced-input-components', 'advanced-data-components',
                   'ui-classes', 'panel-classes', 'table-class', 'navigation-class')
}

foreach ($module in $modulesToRemove) {
    Write-Host "Removing module: $($module.Name)" -ForegroundColor Cyan
    Remove-Module $module -Force -ErrorAction SilentlyContinue
}

# Clear any compiled assemblies (for our custom exceptions)
if ('Helios.HeliosException' -as [type]) {
    Write-Host "Note: Custom exception types are loaded and cannot be unloaded in this session." -ForegroundColor Yellow
    Write-Host "For a complete refresh, please start a new PowerShell session." -ForegroundColor Yellow
}

Write-Host "`nModule cache cleared. You can now run the application again." -ForegroundColor Green
Write-Host "Run: pwsh -file _CLASSY-MAIN.ps1" -ForegroundColor White



####\filecopy.ps1
# This script finds all .ps1 and .psm1 files in the current directory and its subdirectories.
# For each found file, it creates a copy with a .txt extension in the same location.
# Finally, it concatenates the content of all original .ps1 and .psm1 files into a single file named 'all.txt'
# in the current directory. Each appended file is preceded by a header indicating its relative path.

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the current working directory, ensuring no trailing backslash for consistent path manipulation
$currentDirectory = (Get-Location).Path.TrimEnd('\')

# Define the name of the output concatenated file
$outputFileName = "all.txt"

Write-Host "Starting script operations in: $currentDirectory"

# --- Step 1: Clear the existing output file if it exists ---
try {
    if (Test-Path $outputFileName) {
        Remove-Item $outputFileName -Force -ErrorAction Stop
        Write-Host "Cleared existing '$outputFileName'."
    }
} catch {
    Write-Warning "Failed to clear '$outputFileName': $($_.Exception.Message)"
    # Continue, as this might not be a fatal error for the rest of the script
}

# --- Step 2: Find all .ps1 and .psm1 files recursively ---
try {
    $scriptFiles = Get-ChildItem -Path $currentDirectory -Recurse -Include *.ps1, *.psm1 -File -ErrorAction Stop
    Write-Host "Found $($scriptFiles.Count) PowerShell script files."
} catch {
    Write-Error "Failed to enumerate script files: $($_.Exception.Message)"
    exit 1 # Exit if we can't even find the files
}

# --- Step 3: Process each file (copy and concatenate) ---
if ($scriptFiles.Count -eq 0) {
    Write-Warning "No .ps1 or .psm1 files found to process."
} else {
    foreach ($file in $scriptFiles) {
        # Create a copy with .txt ending in the same folder
        $txtCopyPath = Join-Path -Path $file.DirectoryName -ChildPath ($file.BaseName + ".txt")
        try {
            Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force -ErrorAction Stop
            Write-Host "  Copied: $($file.Name) to $($txtCopyPath)"
        } catch {
            Write-Warning "  Failed to copy $($file.FullName) to $($txtCopyPath): $($_.Exception.Message)"
        }

        # Prepare header for all.txt using relative path
        # Remove the base directory part from the full path to get the relative path
        $relativePath = $file.FullName.Substring($currentDirectory.Length)
        # Ensure the relative path starts with a single backslash
        if (-not $relativePath.StartsWith('\')) {
            $relativePath = '\' + $relativePath
        }

        $header = "####$relativePath"
        
        # Append the header and file content to all.txt
        try {
            Add-Content -Path $outputFileName -Value $header -Encoding UTF8 -ErrorAction Stop
            # Read the entire file content as a single string
            $fileContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value $fileContent -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value "`n" -Encoding UTF8 -ErrorAction Stop # Add an extra newline for separation
            Write-Host "  Appended: $($file.Name) to $($outputFileName)"
        } catch {
            Write-Warning "  Failed to append $($file.FullName) to $($outputFileName): $($_.Exception.Message)"
        }
    }
}

Write-Host "All operations complete. Concatenated content saved to '$outputFileName'."


####\monolith.ps1
# Create-Monolith.ps1 (v14 - BRUTAL CLEANING)
# This script builds a single, runnable monolithic script. It has been completely
# rewritten to programmatically PATCH the source code in memory and AGGRESSIVELY
# clean all files to remove any and all module-specific commands.

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

$PSScriptRoot = Get-Location
$OutputScript = Join-Path $PSScriptRoot "Monolithic-PMCTerminal.ps1"

# ----------------------------------------------------------------------------------
# CRITICAL: This is the DEFINITIVE, manually-verified load order for all files.
# ----------------------------------------------------------------------------------
$FileLoadOrder = @(
    # Level 0: Core Primitives & Models
    'modules\logger\logger.psm1',
    'modules\exceptions\exceptions.psm1',
    'modules\models\models.psm1',
    'components\tui-primitives\tui-primitives.psm1',

    # Level 1: Foundational Systems
    'modules\event-system\event-system.psm1',
    'modules\theme-manager\theme-manager.psm1',
    'components\ui-classes\ui-classes.psm1', # Defines UIElement, Screen. MUST be loaded before anything that inherits from them.

    # Level 2: Layout & Core Component Classes
    'layout\panels-class\panels-class.psm1',
    'components\navigation-class\navigation-class.psm1',
    'components\tui-components\tui-components.psm1',
    'components\advanced-data-components\advanced-data-components.psm1',
    'components\advanced-input-components\advanced-input-components.psm1',
    
    # Level 3: Service and Dialog Classes
    'modules\data-manager-class\data-manager-class.psm1',
    'services\keybinding-service-class\keybinding-service-class.psm1',
    'modules\dialog-system-class\dialog-system-class.psm1',
    
    # Level 4: Screen Classes (which must be defined before the factory uses them)
    'screens\dashboard-screen\dashboard-screen.psm1',
    'screens\task-list-screen\task-list-screen.psm1',
    
    # Level 5: Navigation Service (which uses the Screen classes)
    'services\navigation-service-class\navigation-service-class.psm1',

    # Level 6: Service Implementation Functions & TUI Engine
    'modules\data-manager\data-manager.psm1',
    'services\keybinding-service\keybinding-service.psm1',
    'services\navigation-service\navigation-service.psm1',
    'modules\tui-engine\tui-engine.psm1',
    'modules\tui-framework\tui-framework.psm1'
)

# --- Script Logic ---

Write-Host "Starting monolithic script creation..." -ForegroundColor Yellow

if (Test-Path $OutputScript) { Remove-Item $OutputScript -Force }

# --- Stage 1: Define a robust cleaning function ---
function Clean-FileContent {
    param(
        [string]$RawContent
    )
    # This regex aggressively finds and removes lines containing the forbidden statements,
    # even if they are commented out or have leading/trailing whitespace.
    $forbiddenPatterns = 'using\s+module', 'using\s+namespace', 'Export-ModuleMember', 'Set-StrictMode', '`?\$ErrorActionPreference'
    $regex = '(?im)^\s*(#\s*)?(' + ($forbiddenPatterns -join '|') + ').*$'

    $cleanedContent = $RawContent -replace $regex, ''
    return $cleanedContent.Trim()
}

# --- Stage 2: Extract and CLEAN main script logic and its param() block ---
$mainScriptPath = Join-Path $PSScriptRoot '_CLASSY-MAIN.ps1'
if (-not (Test-Path $mainScriptPath)) { throw "FATAL: Main script file '_CLASSY-MAIN.ps1' not found." }
$mainScriptContent = Get-Content -Path $mainScriptPath -Raw
$paramBlock = ""
if ($mainScriptContent -match '(?msi)^\s*param\s*\((.*?)\)') {
    $paramBlock = $matches[0]
    Write-Host "  -> Extracted top-level param() block." -ForegroundColor Green
}
if ($mainScriptContent -match '(?msi)(try\s*\{.*\}\s*finally\s*\{.*\})') {
    $mainScriptBody = $matches[1]
    Write-Host "  -> Extracted main try/catch/finally execution block." -ForegroundColor Green
} else {
    throw "FATAL: Could not find the main 'try { ... }' block in _CLASSY-MAIN.ps1."
}

# --- Stage 3: Process, PATCH, and clean all other files ---
$allOtherContent = [System.Text.StringBuilder]::new()

foreach ($filePath in $FileLoadOrder) {
    $fullPath = Join-Path $PSScriptRoot $filePath
    if (-not (Test-Path $fullPath)) {
        Write-Warning "File not found, skipping: $filePath"
        continue
    }

    Write-Host "Processing: $filePath" -ForegroundColor Cyan
    $content = Get-Content -Path $fullPath -Raw

    # ==============================================================================
    # PROGRAMMATIC PATCHING TO FIX LOGIC BUGS
    # ==============================================================================
    switch -Wildcard ($filePath) {
        '*dashboard-screen.psm1' {
            $content = $content -replace 'class DashboardScreen : UIElement', 'class DashboardScreen : Screen'
            $content = $content -replace 'base\(0, 0, 120, 30\)', 'base("DashboardScreen", $services)'
            Write-Host "  -> PATCHED: DashboardScreen to inherit from Screen and fixed constructor." -ForegroundColor Magenta
        }
        '*task-list-screen.psm1' {
            $content = $content -replace 'class TaskListScreen : UIElement', 'class TaskListScreen : Screen'
            $content = $content -replace 'base\(0, 0, 120, 30\)', 'base("TaskListScreen", $services)'
            Write-Host "  -> PATCHED: TaskListScreen to inherit from Screen and fixed constructor." -ForegroundColor Magenta
        }
        '*navigation-service-class.psm1' {
            $content = $content -replace 'if \(-not \$screenType.IsSubclassOf\(\[Screen\]\)\)', 'if (-not ($screenType -eq [Screen] -or $screenType.IsSubclassOf([Screen])))'
            Write-Host "  -> PATCHED: ScreenFactory type check to be correct." -ForegroundColor Magenta
        }
    }

    $cleanedFile = Clean-FileContent -RawContent $content
    
    [void]$allOtherContent.AppendLine()
    [void]$allOtherContent.AppendLine("# --- START OF ORIGINAL FILE: $filePath ---")
    [void]$allOtherContent.AppendLine($cleanedFile)
    [void]$allOtherContent.AppendLine("# --- END OF ORIGINAL FILE: $filePath ---")
    [void]$allOtherContent.AppendLine()
}

# --- Stage 4: Assemble the final script ---
$finalScript = [System.Text.StringBuilder]::new()
[void]$finalScript.AppendLine("# ==================================================================================")
[void]$finalScript.AppendLine("# PMC Terminal v5 - MONOLITHIC SCRIPT (Generated by Create-Monolith.ps1)")
[void]$finalScript.AppendLine("# DO NOT EDIT THIS FILE DIRECTLY.")
[void]$finalScript.AppendLine("# ==================================================================================")
[void]$finalScript.AppendLine(@"
#Requires -Version 7.0
using namespace System.Text
using namespace System.Management.Automation
using namespace System
"@)
if (-not [string]::IsNullOrWhiteSpace($paramBlock)) {
    [void]$finalScript.AppendLine($paramBlock)
}
[void]$finalScript.AppendLine(@"
# Global script settings
Set-StrictMode -Version Latest
`$ErrorActionPreference = "Stop"
"@)
[void]$finalScript.Append($allOtherContent.ToString())
[void]$finalScript.AppendLine()
[void]$finalScript.AppendLine("# --- START OF MAIN EXECUTION LOGIC (from _CLASSY-MAIN.ps1) ---")
[void]$finalScript.AppendLine($mainScriptBody)
[void]$finalScript.AppendLine("# --- END OF MAIN EXECUTION LOGIC ---")

Add-Content -Path $OutputScript -Value $finalScript.ToString() -Encoding UTF8

Write-Host "`nSuccessfully created monolithic script: $OutputScript" -ForegroundColor Green
Write-Host "You can now run the application with: pwsh -File `"$OutputScript`"" -ForegroundColor White


####\monolith2.ps1
# Create-Monolith.ps1 (v15 - LOGIC & DEPENDENCY INJECTION FIX)
# This script builds a single, runnable monolithic script. It programmatically
# PATCHES the source code in memory to fix the fundamental class inheritance
# and dependency injection errors, and aggressively cleans all files.

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

$PSScriptRoot = Get-Location
$OutputScript = Join-Path $PSScriptRoot "Monolithic-PMCTerminal.ps1"

# ----------------------------------------------------------------------------------
# CRITICAL: This is the DEFINITIVE, manually-verified load order for all files.
# ----------------------------------------------------------------------------------
$FileLoadOrder = @(
    # Level 0: Core Primitives & Models
    'modules\logger\logger.psm1',
    'modules\exceptions\exceptions.psm1',
    'modules\models\models.psm1',
    'components\tui-primitives\tui-primitives.psm1',

    # Level 1: Foundational Systems
    'modules\event-system\event-system.psm1',
    'modules\theme-manager\theme-manager.psm1',
    'components\ui-classes\ui-classes.psm1', # Defines UIElement, Screen. MUST be loaded before anything that inherits from them.

    # Level 2: Layout & Core Component Classes
    'layout\panels-class\panels-class.psm1',
    'components\navigation-class\navigation-class.psm1',
    'components\tui-components\tui-components.psm1',
    'components\advanced-data-components\advanced-data-components.psm1',
    'components\advanced-input-components\advanced-input-components.psm1',
    
    # Level 3: Service and Dialog Classes
    'modules\data-manager-class\data-manager-class.psm1',
    'services\keybinding-service-class\keybinding-service-class.psm1',
    'modules\dialog-system-class\dialog-system-class.psm1',
    
    # Level 4: Screen Classes (which must be defined before the factory uses them)
    'screens\dashboard-screen\dashboard-screen.psm1',
    'screens\task-list-screen\task-list-screen.psm1',
    
    # Level 5: Navigation Service (which uses the Screen classes)
    'services\navigation-service-class\navigation-service-class.psm1',

    # Level 6: Service Implementation Functions & TUI Engine
    'modules\data-manager\data-manager.psm1',
    'services\keybinding-service\keybinding-service.psm1',
    'services\navigation-service\navigation-service.psm1',
    'modules\tui-engine\tui-engine.psm1',
    'modules\tui-framework\tui-framework.psm1'
)

# --- Script Logic ---

Write-Host "Starting monolithic script creation..." -ForegroundColor Yellow

if (Test-Path $OutputScript) { Remove-Item $OutputScript -Force }

# --- Stage 1: Define a robust cleaning function ---
function Clean-FileContent {
    param(
        [string]$RawContent
    )
    $forbiddenPatterns = 'using\s+module', 'using\s+namespace', 'Export-ModuleMember', 'Set-StrictMode', '`?\$ErrorActionPreference'
    $regex = '(?im)^\s*(#\s*)?(' + ($forbiddenPatterns -join '|') + ').*$'
    $cleanedContent = $RawContent -replace $regex, ''
    return $cleanedContent.Trim()
}

# --- Stage 2: Extract and CLEAN main script logic and its param() block ---
$mainScriptPath = Join-Path $PSScriptRoot '_CLASSY-MAIN.ps1'
if (-not (Test-Path $mainScriptPath)) { throw "FATAL: Main script file '_CLASSY-MAIN.ps1' not found." }
$mainScriptContent = Get-Content -Path $mainScriptPath -Raw
$paramBlock = ""
if ($mainScriptContent -match '(?msi)^\s*param\s*\((.*?)\)') {
    $paramBlock = $matches[0]
    Write-Host "  -> Extracted top-level param() block." -ForegroundColor Green
}
if ($mainScriptContent -match '(?msi)(try\s*\{.*\}\s*finally\s*\{.*\})') {
    $mainScriptBody = $matches[1]
    Write-Host "  -> Extracted main try/catch/finally execution block." -ForegroundColor Green
} else {
    throw "FATAL: Could not find the main 'try { ... }' block in _CLASSY-MAIN.ps1."
}

# --- Stage 3: Process, PATCH, and clean all other files ---
$allOtherContent = [System.Text.StringBuilder]::new()

foreach ($filePath in $FileLoadOrder) {
    $fullPath = Join-Path $PSScriptRoot $filePath
    if (-not (Test-Path $fullPath)) {
        Write-Warning "File not found, skipping: $filePath"
        continue
    }

    Write-Host "Processing: $filePath" -ForegroundColor Cyan
    $content = Get-Content -Path $fullPath -Raw

    # ==============================================================================
    # PROGRAMMATIC PATCHING TO FIX LOGIC BUGS
    # ==============================================================================
    switch -Wildcard ($filePath) {
        '*dashboard-screen.psm1' {
            $content = $content -replace 'class DashboardScreen : UIElement', 'class DashboardScreen : Screen'
            $content = $content -replace 'DashboardScreen\(\[hashtable\]\$services\) : base\(0, 0, 120, 30\)', 'DashboardScreen([hashtable]$services) : base("DashboardScreen", $services)'
            # CRITICAL FIX: Inject services into the NavigationMenu
            $content = $content -replace '\[NavigationMenu\]::new\("MainMenu"\)', '[NavigationMenu]::new("MainMenu", $this.Services)'
            Write-Host "  -> PATCHED: DashboardScreen inheritance, constructor, and service injection." -ForegroundColor Magenta
        }
        '*task-list-screen.psm1' {
            $content = $content -replace 'class TaskListScreen : UIElement', 'class TaskListScreen : Screen'
            $content = $content -replace 'TaskListScreen\(\[hashtable\]\$services\) : base\(0, 0, 120, 30\)', 'TaskListScreen([hashtable]$services) : base("TaskListScreen", $services)'
            Write-Host "  -> PATCHED: TaskListScreen inheritance and constructor." -ForegroundColor Magenta
        }
        '*navigation-service-class.psm1' {
            $content = $content -replace 'if \(-not \$screenType.IsSubclassOf\(\[Screen\]\)\)', 'if (-not ($screenType -eq [Screen] -or $screenType.IsSubclassOf([Screen])))'
            Write-Host "  -> PATCHED: ScreenFactory type check to be correct." -ForegroundColor Magenta
        }
        '*tui-engine.psm1' {
            # CRITICAL FIX: Replace the entire flawed function with a correct one.
            $content = $content -replace '(?s)function Request-TuiRefresh.*?\}', 'function Request-TuiRefresh { $global:TuiState.IsDirty = $true }'
            Write-Host "  -> PATCHED: Request-TuiRefresh function to be reliable." -ForegroundColor Magenta
        }
    }

    $cleanedFile = Clean-FileContent -RawContent $content
    
    [void]$allOtherContent.AppendLine()
    [void]$allOtherContent.AppendLine("# --- START OF ORIGINAL FILE: $filePath ---")
    [void]$allOtherContent.AppendLine($cleanedFile)
    [void]$allOtherContent.AppendLine("# --- END OF ORIGINAL FILE: $filePath ---")
    [void]$allOtherContent.AppendLine()
}

# --- Stage 4: Assemble the final script ---
$finalScript = [System.Text.StringBuilder]::new()
[void]$finalScript.AppendLine("# ==================================================================================")
[void]$finalScript.AppendLine("# PMC Terminal v5 - MONOLITHIC SCRIPT (Generated by Create-Monolith.ps1)")
[void]$finalScript.AppendLine("# DO NOT EDIT THIS FILE DIRECTLY.")
[void]$finalScript.AppendLine("# ==================================================================================")
[void]$finalScript.AppendLine(@"
#Requires -Version 7.0
using namespace System.Text
using namespace System.Management.Automation
using namespace System
"@)
if (-not [string]::IsNullOrWhiteSpace($paramBlock)) {
    [void]$finalScript.AppendLine($paramBlock)
}
[void]$finalScript.AppendLine(@"
# Global script settings
Set-StrictMode -Version Latest
`$ErrorActionPreference = "Stop"
"@)
[void]$finalScript.Append($allOtherContent.ToString())
[void]$finalScript.AppendLine()
[void]$finalScript.AppendLine("# --- START OF MAIN EXECUTION LOGIC (from _CLASSY-MAIN.ps1) ---")
[void]$finalScript.AppendLine($mainScriptBody)
[void]$finalScript.AppendLine("# --- END OF MAIN EXECUTION LOGIC ---")

Add-Content -Path $OutputScript -Value $finalScript.ToString() -Encoding UTF8

Write-Host "`nSuccessfully created monolithic script: $OutputScript" -ForegroundColor Green
Write-Host "You can now run the application with: pwsh -File `"$OutputScript`"" -ForegroundColor White


####\Monolithic-PMCTerminal.ps1
# ==================================================================================
# PMC Terminal v5 - MONOLITHIC SCRIPT (Generated by Create-Monolith.ps1)
# DO NOT EDIT THIS FILE DIRECTLY.
# ==================================================================================
#Requires -Version 7.0
using namespace System.Text
using namespace System.Management.Automation
using namespace System
param(
    [switch]$Debug,
    [switch]$SkipLogo
)
# Global script settings
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# --- START OF ORIGINAL FILE: modules\logger\logger.psm1 ---
# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------
$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------
function ConvertTo-SerializableObject {
    param([object]$Object)
    if ($null -eq $Object) { return $null }
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'
    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)
        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) { [void]$visited.Add($InputObject) }
        switch ($InputObject.GetType().Name) {
            'Hashtable' { $r = @{}; foreach ($k in $InputObject.Keys) { try { $r[$k] = Convert-Internal $InputObject[$k] ($Depth+1) } catch { $r[$k] = "<Err>" } }; return $r }
            'PSCustomObject' { $r = @{}; foreach ($p in $InputObject.PSObject.Properties) { try { if ($p.MemberType -ne 'ScriptMethod') { $r[$p.Name] = Convert-Internal $p.Value ($Depth+1) } } catch { $r[$p.Name] = "<Err>" } }; return $r }
            'Object[]' { $r = @(); for ($i=0; $i -lt [Math]::Min($InputObject.Count,10); $i++) { try { $r += Convert-Internal $InputObject[$i] ($Depth+1) } catch { $r += "<Err>" } }; if($InputObject.Count -gt 10) { $r += "<...>" }; return $r }
            default { try { if ($InputObject -is [ValueType] -or $InputObject -is [string] -or $InputObject -is [datetime]) { return $InputObject } else { return $InputObject.ToString() } } catch { return "<Err>" } }
        }
    }
    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------
function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Debug"
    )
    if ([string]::IsNullOrWhiteSpace($LogDirectory) -or [string]::IsNullOrWhiteSpace($LogFileName)) { Write-Warning "Invalid logger parameters."; return }
    try {
        if (-not (Test-Path $LogDirectory)) { New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null }
        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true
        Write-Log -Level Info -Message "Logger initialized" -Data @{ LogPath = $script:LogPath; PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS; PID = $PID } -Force
    } catch { Write-Warning "Failed to initialize logger: $_"; $script:LogInitialized = $false }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")] [string]$Level = "Info",
        [Parameter(Mandatory)] [string]$Message,
        [object]$Data,
        [switch]$Force
    )
    if (-not $script:LogInitialized -and -not $Force) { return }
    $levelPriority = @{ Debug=0; Trace=0; Verbose=1; Info=2; Warning=3; Error=4; Fatal=5 }
    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }
    try {
        $caller = (Get-PSCallStack)[1]
        $logContext = @{
            Timestamp = (Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"); Level = $Level; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
            CallDepth = $script:CallDepth; Message = $Message; Caller = @{ Command = $caller.Command; Location = $caller.Location; ScriptName = $caller.ScriptName; LineNumber = $caller.ScriptLineNumber }
        }
        if ($PSBoundParameters.ContainsKey('Data')) { $logContext.UserData = if ($Data -is [Exception]) { @{ Type="Exception"; Message=$Data.Message; StackTrace=$Data.StackTrace; InnerException=$Data.InnerException.Message } } else { ConvertTo-SerializableObject -Object $Data } }
        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) { "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)" } else { $caller.Command }
        $logEntry = "$($logContext.Timestamp) [$($Level.PadRight(7))] $indent [$callerInfo] $Message"
        if ($PSBoundParameters.ContainsKey('Data')) { $logEntry += if ($Data -is [Exception]) { "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)" } else { try { "`n${indent}  Data: $(ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue)" } catch { "`n${indent}  Data: $($Data.ToString())" } } }
        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) { $script:LogQueue.RemoveRange(0, 1000) }
        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) { Move-Item $script:LogPath ($script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log") -Force }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch { Write-Host "LOG WRITE FAILED: $logEntry`nError: $_" -ForegroundColor Yellow }
        }
        if ($Level -in @('Error', 'Fatal', 'Warning')) { Write-Host $logEntry -ForegroundColor ($Level -in @('Error', 'Fatal') ? 'Red' : 'Yellow') }
    } catch { try { $errorEntry = "$(Get-Date -Format 'o') [LOGGER ERROR] Failed to log: $_"; if ($script:LogPath) { Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8 }; Write-Host $errorEntry -ForegroundColor Red } catch { Write-Host "CRITICAL: Logger failed: $_" -ForegroundColor Red } }
}

function Trace-FunctionEntry { [CmdletBinding()] param([string]$FunctionName, [object]$Parameters); if (-not $script:TraceAllCalls) { return }; $script:CallDepth++; Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{ Parameters=$Parameters; Action="FunctionEntry" } }
function Trace-FunctionExit { [CmdletBinding()] param([string]$FunctionName, [object]$ReturnValue, [switch]$WithError); if (-not $script:TraceAllCalls) { return }; Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{ ReturnValue=$ReturnValue; Action=($WithError ? "FunctionExitWithError" : "FunctionExit"); HasError=$WithError.IsPresent }; $script:CallDepth = [Math]::Max(0, $script:CallDepth - 1) }
function Trace-Step { [CmdletBinding()] param([string]$StepName, [object]$StepData, [string]$Module); $caller = (Get-PSCallStack)[1]; $moduleInfo = $Module ?? ($caller.ScriptName ? [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) : "Unknown"); Write-Log -Level Debug -Message "STEP: $StepName" -Data @{ StepData=$StepData; Module=$moduleInfo; Action="Step" } }
function Trace-StateChange { [CmdletBinding()] param([string]$StateType, [object]$OldValue, [object]$NewValue, [string]$PropertyPath); Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{ StateType=$StateType; PropertyPath=$PropertyPath; OldValue=$OldValue; NewValue=$NewValue; Action="StateChange" } }
function Trace-ComponentLifecycle { [CmdletBinding()] param([string]$ComponentType, [string]$ComponentId, [ValidateSet('Create','Initialize','Render','Update','Destroy')] [string]$Phase, [object]$ComponentData); Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{ ComponentType=$ComponentType; ComponentId=$ComponentId; Phase=$Phase; ComponentData=$ComponentData; Action="ComponentLifecycle" } }
function Trace-ServiceCall { [CmdletBinding()] param([string]$ServiceName, [string]$MethodName, [object]$Parameters, [object]$Result, [switch]$IsError); Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{ ServiceName=$ServiceName; MethodName=$MethodName; Parameters=$Parameters; Result=$Result; Action=($IsError ? "ServiceCallError" : "ServiceCall"); IsError=$IsError.IsPresent } }

function Get-LogEntries {
    [CmdletBinding()]
    param([int]$Count = 100, [string]$Level, [string]$Module, [string]$Action)
    try {
        $entries = $script:LogQueue.ToArray()
        if ($Level) { $entries = $entries | Where-Object { $_.Level -eq $Level } }
        if ($Module) { $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") } }
        if ($Action) { $entries = $entries | Where-Object { $_.UserData.Action -eq $Action } }
        return $entries | Select-Object -Last $Count
    } catch { Write-Warning "Error getting log entries: $_"; return @() }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)
    try {
        $callStack = Get-PSCallStack; $trace = @()
        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { $call = $callStack[$i]; $trace += @{ Level=$i-1; Command=$call.Command; Location=$call.Location; ScriptName=$call.ScriptName; LineNumber=$call.ScriptLineNumber } }
        return $trace
    } catch { Write-Warning "Error getting call trace: $_"; return @() }
}

function Clear-LogQueue { try { $script:LogQueue.Clear(); Write-Log -Level Info -Message "In-memory log queue cleared" } catch { Write-Warning "Error clearing log queue: $_" } }
function Set-LogLevel { [CmdletBinding()] param([Parameter(Mandatory)] [ValidateSet("Debug","Verbose","Info","Warning","Error","Fatal","Trace")] [string]$Level); try { $oldLevel = $script:LogLevel; $script:LogLevel = $Level; Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force } catch { Write-Warning "Error setting log level to '$Level': $_" } }
function Enable-CallTracing { $script:TraceAllCalls = $true; Write-Log -Level Info -Message "Call tracing enabled" -Force }
function Disable-CallTracing { $script:TraceAllCalls = $false; Write-Log -Level Info -Message "Call tracing disabled" -Force }
function Get-LogPath { return $script:LogPath }

function Get-LogStatistics {
    [CmdletBinding()]
    param()
    try {
        $stats = [PSCustomObject]@{ TotalEntries=$script:LogQueue.Count; LogPath=$script:LogPath; LogLevel=$script:LogLevel; CallTracingEnabled=$script:TraceAllCalls; LogFileSize=($script:LogPath -and (Test-Path $script:LogPath) ? (Get-Item $script:LogPath).Length : 0); EntriesByLevel=@{}; EntriesByModule=@{}; EntriesByAction=@{} }
        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level; if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level]=0 }; $stats.EntriesByLevel[$level]++
            if ($entry.Caller.ScriptName) { $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName); if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module]=0 }; $stats.EntriesByModule[$module]++ }
            if ($entry.UserData.Action) { $action = $entry.UserData.Action; if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action]=0 }; $stats.EntriesByAction[$action]++ }
        }
        return $stats
    } catch { Write-Warning "Error getting log statistics: $_"; return [PSCustomObject]@{} }
}
# --- END OF ORIGINAL FILE: modules\logger\logger.psm1 ---


# --- START OF ORIGINAL FILE: modules\exceptions\exceptions.psm1 ---
# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

try {
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException) {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
    }
} catch {
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}

# ------------------------------------------------------------------------------
# Error Handling Wrapper
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Component,
        
        [Parameter(Mandatory)]
        [string]$Context,
        
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock
    )
    
    try {
        return & $ScriptBlock
    }
    catch {
        Write-Log -Level Error -Message "$Context failed: $_" -Component $Component
        throw
    }
}

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

function _Identify-HeliosComponent {
    param([System.Management.Automation.ErrorRecord]$ErrorRecord)
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName ?? (Get-PSCallStack | Where-Object ScriptName | Select-Object -First 1).ScriptName
        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        $componentMap = @{
            'tui-engine' = 'TUI Engine'; 'navigation' = 'Navigation Service'; 'keybindings' = 'Keybinding Service'
            'task-service' = 'Task Service'; 'helios-components' = 'Helios UI Components'; 'helios-panels' = 'Helios UI Panels'
            'dashboard-screen' = 'Dashboard Screen'; 'task-screen' = 'Task Screen'; 'exceptions' = 'Exception Module'
            'logger' = 'Logger Module'; 'Start-PMCTerminal' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") { return $componentMap[$pattern] }
        }
        return "Unknown ($fileName)"
    } catch { return "Component Identification Failed" }
}

function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp = Get-Date -Format "o"; Summary = $ErrorRecord.Exception.Message; Type = $ErrorRecord.Exception.GetType().FullName
            Category = $ErrorRecord.CategoryInfo.Category.ToString(); TargetObject = $ErrorRecord.TargetObject
            ScriptName = $ErrorRecord.InvocationInfo.ScriptName; LineNumber = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line = $ErrorRecord.InvocationInfo.Line; PositionMessage = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace = $ErrorRecord.Exception.StackTrace; InnerExceptions = @(); AdditionalContext = $AdditionalContext
            SystemContext = @{
                ProcessId = $PID; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{ Message = $innerEx.Message; Type = $innerEx.GetType().FullName; StackTrace = $innerEx.StackTrace }
            $innerEx = $innerEx.InnerException
        }
        return $errorInfo
    } catch {
        return [PSCustomObject]@{ Timestamp = Get-Date -Format "o"; Summary = "CRITICAL: Error analysis failed."; OriginalError = $ErrorRecord.Exception.Message; AnalysisError = $_.Exception.Message; Type = "ErrorAnalysisFailure" }
    }
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$Component,
        [Parameter(Mandatory)] [string]$Context,
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [hashtable]$AdditionalData = @{}
    )

    if (-not $ScriptBlock) { throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null." }
    $Component = [string]::IsNullOrWhiteSpace($Component) ? "Unknown Component" : $Component
    $Context = [string]::IsNullOrWhiteSpace($Context) ? "Unknown Operation" : $Context

    try {
        return (& $ScriptBlock)
    }
    catch {
        $originalErrorRecord = $_
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = ($Component -ne "Unknown Component") ? $Component : $identifiedComponent

        $errorContext = @{ Operation = $Context }
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)" -Data $detailedError
        }

        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) { $script:ErrorHistory.RemoveAt(0) }

        $contextHashtable = @{
            Operation = $Context; Timestamp = $detailedError.Timestamp; LineNumber = $detailedError.LineNumber
            ScriptName = $detailedError.ScriptName ?? "Unknown"
        }
        
        foreach ($key in $AdditionalData.Keys) {
            $value = $AdditionalData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) { $contextHashtable[$key] = $value }
        }
        
        $heliosException = New-Object Helios.HeliosException($originalErrorRecord.Exception.Message, $finalComponent, $contextHashtable, $originalErrorRecord.Exception)
        throw $heliosException
    }
}

function Get-ErrorHistory {
    [CmdletBinding()]
    param([int]$Count = 25)
    
    $total = $script:ErrorHistory.Count
    if ($Count -ge $total) { return $script:ErrorHistory }
    $start = $total - $Count
    return $script:ErrorHistory.GetRange($start, $Count)
}
# --- END OF ORIGINAL FILE: modules\exceptions\exceptions.psm1 ---


# --- START OF ORIGINAL FILE: modules\models\models.psm1 ---
# ==============================================================================
# PMC Terminal v5 - Core Data Models
# Defines all core business entity classes with built-in validation.
# ==============================================================================



#region Enums

enum TaskStatus { Pending; InProgress; Completed; Cancelled }
enum TaskPriority { Low; Medium; High }
enum BillingType { Billable; NonBillable }

#endregion

#region Base Validation Class
class ValidationBase {
    static [void] ValidateNotEmpty([string]$value, [string]$parameterName) {
        if ([string]::IsNullOrWhiteSpace($value)) {
            throw [System.ArgumentException]::new("Parameter '$($parameterName)' cannot be null or empty.")
        }
    }
}
#endregion

#region Core Model Classes

class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()
    [string]$Title
    [string]$Description
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [string]$ProjectKey = "General"
    [string]$Category
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now
    [Nullable[datetime]]$DueDate
    [string[]]$Tags = @()
    [int]$Progress = 0
    [bool]$Completed = $false

    PmcTask() {}
    PmcTask([string]$title) { [ValidationBase]::ValidateNotEmpty($title, "Title"); $this.Title = $title }
    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title; $this.Description = $description; $this.Priority = $priority
        $this.ProjectKey = $projectKey; $this.Category = $projectKey
    }

    [void] Complete() {
        $this.Status = [TaskStatus]::Completed; $this.Completed = $true
        $this.Progress = 100; $this.UpdatedAt = [datetime]::Now
    }

    [void] UpdateProgress([int]$newProgress) {
        if ($newProgress -lt 0 -or $newProgress -gt 100) { throw "Progress must be between 0 and 100." }
        $this.Progress = $newProgress
        $this.Status = $newProgress -eq 100 ? [TaskStatus]::Completed : $newProgress -gt 0 ? [TaskStatus]::InProgress : [TaskStatus]::Pending
        $this.Completed = ($this.Status -eq [TaskStatus]::Completed)
        $this.UpdatedAt = [datetime]::Now
    }
    
    [string] GetDueDateString() { return $this.DueDate ? $this.DueDate.Value.ToString("yyyy-MM-dd") : "N/A" }

    [hashtable] ToLegacyFormat() {
        return @{
            id = $this.Id; title = $this.Title; description = $this.Description
            completed = $this.Completed; priority = $this.Priority.ToString().ToLower()
            project = $this.ProjectKey; due_date = $this.DueDate ? $this.GetDueDateString() : $null
            created_at = $this.CreatedAt.ToString("o"); updated_at = $this.UpdatedAt.ToString("o")
        }
    }

    static [PmcTask] FromLegacyFormat([hashtable]$legacyData) {
        $task = [PmcTask]::new()
        $task.Id = $legacyData.id ?? $task.Id
        $task.Title = $legacyData.title
        $task.Description = $legacyData.description
        if ($legacyData.priority) { try { $task.Priority = [TaskPriority]::$($legacyData.priority) } catch {} }
        $task.ProjectKey = $legacyData.project ?? $legacyData.Category ?? "General"
        $task.Category = $task.ProjectKey
        if ($legacyData.created_at) { try { $task.CreatedAt = [datetime]::Parse($legacyData.created_at) } catch {} }
        if ($legacyData.updated_at) { try { $task.UpdatedAt = [datetime]::Parse($legacyData.updated_at) } catch {} }
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") { try { $task.DueDate = [datetime]::Parse($legacyData.due_date) } catch {} }
        if ($legacyData.completed -is [bool] -and $legacyData.completed) { $task.Complete() }
        return $task
    }
}

class PmcProject : ValidationBase {
    [string]$Key = ([Guid]::NewGuid().ToString().Split('-')[0]).ToUpper()
    [string]$Name
    [string]$Client
    [BillingType]$BillingType = [BillingType]::NonBillable
    [double]$Rate = 0.0
    [double]$Budget = 0.0
    [bool]$Active = $true
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now

    PmcProject() {}
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key"); [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key; $this.Name = $name
    }

    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key; Name = $this.Name; Client = $this.Client
            BillingType = $this.BillingType.ToString(); Rate = $this.Rate; Budget = $this.Budget
            Active = $this.Active; CreatedAt = $this.CreatedAt.ToString("o")
        }
    }

    static [PmcProject] FromLegacyFormat([hashtable]$legacyData) {
        $project = [PmcProject]::new()
        $project.Key = $legacyData.Key ?? $project.Key
        $project.Name = $legacyData.Name
        $project.Client = $legacyData.Client
        if ($legacyData.Rate) { $project.Rate = [double]$legacyData.Rate }
        if ($legacyData.Budget) { $project.Budget = [double]$legacyData.Budget }
        if ($legacyData.Active -is [bool]) { $project.Active = $legacyData.Active }
        if ($legacyData.BillingType) { try { $project.BillingType = [BillingType]::$($legacyData.BillingType) } catch {} }
        if ($legacyData.CreatedAt) { try { $project.CreatedAt = [datetime]::Parse($legacyData.CreatedAt) } catch {} }
        $project.UpdatedAt = $project.CreatedAt
        return $project
    }
}

#endregion

# AI: Export everything including enums for PowerShell 7+
# --- END OF ORIGINAL FILE: modules\models\models.psm1 ---


# --- START OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---
# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations
# CORRECTED ORDERING: TuiAnsiHelper is defined BEFORE TuiCell to resolve parse-time dependency.



#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int] GetForegroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()]
    }

    static [int] GetBackgroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()] + 10
    }

    static [string] Reset() {
        return "`e[0m"
    }

    static [string] Bold() {
        return "`e[1m"
    }

    static [string] Underline() {
        return "`e[4m"
    }

    static [string] Italic() {
        return "`e[3m"
    }
}
#endregion

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    [ConsoleColor] $ForegroundColor = [ConsoleColor]::White
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = ""
    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() {
        $this.Char = ' '
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Character constructor
    TuiCell([char]$char) {
        $this.Char = $char
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Full constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }

    # Style constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }

    # Copy constructor
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.StyleFlags = $other.StyleFlags
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Create a styled copy
    [TuiCell] WithStyle([ConsoleColor]$fg, [ConsoleColor]$bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    # Create a character copy
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blend this cell with another (higher Z-index wins)
    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return $other }
        if ($other.ZIndex -eq $this.ZIndex -and $other.Char -ne ' ') { return $other }
        return $this
    }

    # Check if this cell differs from another
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic)
    }

    # Generate ANSI escape sequence for this cell
    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Color codes - This now works because TuiAnsiHelper is known to the parser.
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append("`e[${fgCode};${bgCode}")
        
        # Style codes
        if ($this.Bold) { [void]$sb.Append(";1") }
        if ($this.Underline) { [void]$sb.Append(";4") }
        if ($this.Italic) { [void]$sb.Append(";3") }
        
        [void]$sb.Append("m").Append($this.Char)
        return $sb.ToString()
    }

    # Convert to legacy buffer format for compatibility
    [hashtable] ToLegacyFormat() {
        return @{
            Char = $this.Char
            FG = $this.ForegroundColor
            BG = $this.BackgroundColor
        }
    }

    # String representation
    [string] ToString() {
        return "TuiCell($($this.Char), $($this.ForegroundColor), $($this.BackgroundColor))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions
function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    
    $cell = [TuiCell]::new(' ', $ForegroundColor, $BackgroundColor)
    $cell.Bold = $Bold
    $cell.Underline = $Underline
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0) {
            $charCell = [TuiCell]::new($cell)
            $charCell.Char = $char
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$BorderStyle = "Single",
        [ConsoleColor]$BorderColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }
    
    $borders = Get-TuiBorderChars -Style $BorderStyle
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Side borders and fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        $currentY = $Y + $i
        
        # Left border
        Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill
        $fillText = ' ' * ($Width - 2)
        Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -BackgroundColor $BackgroundColor
        
        # Right border
        Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $bottomLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all functions
# --- END OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---


# --- START OF ORIGINAL FILE: modules\event-system\event-system.psm1 ---
# Event System Module
# Provides pub/sub event functionality for decoupled communication

# AI: FIX - Corrected relative paths for all dependencies.



$script:EventHandlers = @{}
$script:EventHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxEventHistory = 100

function Initialize-EventSystem {
    <# .SYNOPSIS Initializes the event system for the application #>
    Invoke-WithErrorHandling -Component "EventSystem.Initialize" -Context "Initializing event system" -ScriptBlock {
        $script:EventHandlers = @{}
        $script:EventHistory = [System.Collections.Generic.List[object]]::new()
        Write-Verbose "Event system initialized"
    }
}

function Publish-Event {
    <#
    .SYNOPSIS Publishes an event to all registered handlers
    .PARAMETER EventName The name of the event to publish
    .PARAMETER Data Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter()] [hashtable]$Data = @{}
    )
    Invoke-WithErrorHandling -Component "EventSystem.PublishEvent" -Context "Publishing event '$EventName'" -ScriptBlock {
        $eventRecord = @{ EventName = $EventName; Data = $Data; Timestamp = Get-Date }
        
        $script:EventHistory.Add($eventRecord)
        if ($script:EventHistory.Count -gt $script:MaxEventHistory) { $script:EventHistory.RemoveAt(0) }
        
        if ($script:EventHandlers.ContainsKey($EventName)) {
            foreach ($handler in $script:EventHandlers[$EventName]) {
                try {
                    $eventData = @{ EventName = $EventName; Data = $Data; Timestamp = $eventRecord.Timestamp }
                    & $handler.ScriptBlock -EventData $eventData
                } catch {
                    Write-Log -Level Warning -Message "Error in event handler for '$EventName' (ID: $($handler.HandlerId)): $_"
                }
            }
        }
        Write-Verbose "Published event: $EventName"
    } -AdditionalData @{ EventName = $EventName; EventData = $Data }
}

function Subscribe-Event {
    <#
    .SYNOPSIS Subscribes to an event with a handler
    .PARAMETER EventName The name of the event to subscribe to
    .PARAMETER Handler The script block to execute
    .PARAMETER HandlerId Optional unique identifier for the handler
    .PARAMETER Source Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter(Mandatory)] [scriptblock]$Handler,
        [Parameter()] [string]$HandlerId = [Guid]::NewGuid().ToString(),
        [Parameter()] [string]$Source
    )
    return Invoke-WithErrorHandling -Component "EventSystem.SubscribeEvent" -Context "Subscribing to event '$EventName'" -ScriptBlock {
        if (-not $script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers[$EventName] = @() }
        
        $handlerInfo = @{ HandlerId = $HandlerId; ScriptBlock = $Handler; SubscribedAt = Get-Date; Source = $Source }
        $script:EventHandlers[$EventName] += $handlerInfo
        
        Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
        return $HandlerId
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId; Source = $Source }
}

function Unsubscribe-Event {
    <#
    .SYNOPSIS Unsubscribes from an event
    .PARAMETER EventName The name of the event (optional if HandlerId is provided)
    .PARAMETER HandlerId The unique identifier of the handler to remove
    #>
    param(
        [Parameter()] [string]$EventName,
        [Parameter(Mandatory)] [string]$HandlerId
    )
    Invoke-WithErrorHandling -Component "EventSystem.UnsubscribeEvent" -Context "Unsubscribing from event '$EventName' (Handler: $HandlerId)" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($script:EventHandlers[$EventName].Count -eq 0) { $script:EventHandlers.Remove($EventName) }
                Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
            }
        } else {
            $found = $false
            foreach ($eventKey in @($script:EventHandlers.Keys)) {
                $handlers = $script:EventHandlers[$eventKey]
                $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($newHandlers.Count -lt $handlers.Count) {
                    $found = $true
                    $script:EventHandlers[$eventKey] = if ($newHandlers.Count -eq 0) { $script:EventHandlers.Remove($eventKey) } else { $newHandlers }
                    Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"; break
                }
            }
            if (-not $found) { Write-Warning "Handler ID not found: $HandlerId" }
        }
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId }
}

function Get-EventHandlers {
    <# .SYNOPSIS Gets all registered event handlers #>
    param([Parameter()] [string]$EventName)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHandlers" -Context "Getting event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { return $script:EventHandlers[$EventName] ?? @() }
        else { return $script:EventHandlers }
    }
}

function Clear-EventHandlers {
    <# .SYNOPSIS Clears all event handlers for a specific event or all events #>
    param([Parameter()] [string]$EventName)
    Invoke-WithErrorHandling -Component "EventSystem.ClearEventHandlers" -Context "Clearing event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { if ($script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers.Remove($EventName); Write-Verbose "Cleared handlers for event: $EventName" } } 
        else { $script:EventHandlers = @{}; Write-Verbose "Cleared all event handlers" }
    }
}

function Get-EventHistory {
    <# .SYNOPSIS Gets the event history #>
    param([Parameter()] [string]$EventName, [Parameter()] [int]$Last = 0)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHistory" -Context "Getting event history for '$EventName'" -ScriptBlock {
        $history = $script:EventHistory
        if ($EventName) { $history = $history | Where-Object { $_.EventName -eq $EventName } }
        if ($Last -gt 0) { $history = $history | Select-Object -Last $Last }
        return $history
    }
}

function Remove-ComponentEventHandlers {
    <# .SYNOPSIS Removes all event handlers associated with a specific component #>
    param([Parameter(Mandatory)] [string]$ComponentId)
    Invoke-WithErrorHandling -Component "EventSystem.RemoveComponentEventHandlers" -Context "Removing event handlers for component '$ComponentId'" -ScriptBlock {
        $removedCount = 0
        foreach ($eventName in @($script:EventHandlers.Keys)) {
            $initialCount = $script:EventHandlers[$eventName].Count
            $script:EventHandlers[$eventName] = @($script:EventHandlers[$eventName] | Where-Object { $_.Source -ne $ComponentId })
            $removedCount += $initialCount - $script:EventHandlers[$eventName].Count
            if ($script:EventHandlers[$eventName].Count -eq 0) { $script:EventHandlers.Remove($eventName) }
        }
        Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
    }
}
# --- END OF ORIGINAL FILE: modules\event-system\event-system.psm1 ---


# --- START OF ORIGINAL FILE: modules\theme-manager\theme-manager.psm1 ---
# FILE: modules/theme-manager.psm1
# PURPOSE: Provides theming and color management for the TUI.
#




$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{ Name="Modern"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::White; Primary=[ConsoleColor]::White; Secondary=[ConsoleColor]::Gray; Accent=[ConsoleColor]::Cyan; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::Yellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Blue; Header=[ConsoleColor]::Cyan; Border=[ConsoleColor]::DarkGray; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::Cyan; Subtle=[ConsoleColor]::DarkGray; Keyword=[ConsoleColor]::Blue; String=[ConsoleColor]::Green; Number=[ConsoleColor]::Magenta; Comment=[ConsoleColor]::DarkGray } }
    Dark   = @{ Name="Dark"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::Gray; Primary=[ConsoleColor]::Gray; Secondary=[ConsoleColor]::DarkGray; Accent=[ConsoleColor]::DarkCyan; Success=[ConsoleColor]::DarkGreen; Warning=[ConsoleColor]::DarkYellow; Error=[ConsoleColor]::DarkRed; Info=[ConsoleColor]::DarkBlue; Header=[ConsoleColor]::DarkCyan; Border=[ConsoleColor]::DarkGray; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::Cyan; Subtle=[ConsoleColor]::DarkGray; Keyword=[ConsoleColor]::DarkBlue; String=[ConsoleColor]::DarkGreen; Number=[ConsoleColor]::DarkMagenta; Comment=[ConsoleColor]::DarkGray } }
    Light  = @{ Name="Light"; Colors=@{ Background=[ConsoleColor]::White; Foreground=[ConsoleColor]::Black; Primary=[ConsoleColor]::Black; Secondary=[ConsoleColor]::DarkGray; Accent=[ConsoleColor]::Blue; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::DarkYellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Blue; Header=[ConsoleColor]::Blue; Border=[ConsoleColor]::Gray; Selection=[ConsoleColor]::Cyan; Highlight=[ConsoleColor]::Yellow; Subtle=[ConsoleColor]::Gray; Keyword=[ConsoleColor]::Blue; String=[ConsoleColor]::Green; Number=[ConsoleColor]::Magenta; Comment=[ConsoleColor]::Gray } }
    Retro  = @{ Name="Retro"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::Green; Primary=[ConsoleColor]::Green; Secondary=[ConsoleColor]::DarkGreen; Accent=[ConsoleColor]::Yellow; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::Yellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Cyan; Header=[ConsoleColor]::Yellow; Border=[ConsoleColor]::DarkGreen; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::White; Subtle=[ConsoleColor]::DarkGreen; Keyword=[ConsoleColor]::Yellow; String=[ConsoleColor]::Cyan; Number=[ConsoleColor]::White; Comment=[ConsoleColor]::DarkGreen } }
}

function Initialize-ThemeManager {
    Invoke-WithErrorHandling -Component "ThemeManager.Initialize" -Context "Initializing theme service" -ScriptBlock {
        Set-TuiTheme -ThemeName "Modern"
        Write-Log -Level Info -Message "Theme manager initialized."
    }
}

function Set-TuiTheme {
    param([Parameter(Mandatory)] [string]$ThemeName)
    Invoke-WithErrorHandling -Component "ThemeManager.SetTheme" -Context "Setting active TUI theme" -AdditionalData @{ ThemeName = $ThemeName } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $script:CurrentTheme = $script:Themes[$ThemeName]
            if ($Host.UI.RawUI) {
                $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
                $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
            }
            Write-Log -Level Debug -Message "Theme set to: $ThemeName"
            Publish-Event -EventName "Theme.Changed" -Data @{ ThemeName = $ThemeName; Theme = $script:CurrentTheme }
        } else {
            Write-Log -Level Warning -Message "Theme not found: $ThemeName"
        }
    }
}

function Get-ThemeColor {
    param([Parameter(Mandatory)] [string]$ColorName, [ConsoleColor]$Default = [ConsoleColor]::Gray)
    try {
        return $script:CurrentTheme.Colors[$ColorName] ?? $Default
    } catch {
        Write-Log -Level Warning -Message "Error in Get-ThemeColor for '$ColorName'. Returning default. Error: $_"
        return $Default
    }
}

function Get-TuiTheme {
    Invoke-WithErrorHandling -Component "ThemeManager.GetTheme" -Context "Retrieving current theme" -ScriptBlock {
        return $script:CurrentTheme
    }
}

function Get-AvailableThemes {
    Invoke-WithErrorHandling -Component "ThemeManager.GetAvailableThemes" -Context "Retrieving available themes" -ScriptBlock {
        return $script:Themes.Keys | Sort-Object
    }
}

function New-TuiTheme {
    param([Parameter(Mandatory)] [string]$Name, [string]$BaseTheme = "Modern", [hashtable]$Colors = @{})
    Invoke-WithErrorHandling -Component "ThemeManager.NewTheme" -Context "Creating new theme" -AdditionalData @{ ThemeName = $Name } -ScriptBlock {
        $newTheme = @{ Name = $Name; Colors = @{} }
        if ($script:Themes.ContainsKey($BaseTheme)) { $newTheme.Colors = $script:Themes[$BaseTheme].Colors.Clone() }
        foreach ($colorKey in $Colors.Keys) { $newTheme.Colors[$colorKey] = $Colors[$colorKey] }
        $script:Themes[$Name] = $newTheme
        Write-Log -Level Info -Message "Created new theme: $Name"
        return $newTheme
    }
}

function Export-TuiTheme {
    param([Parameter(Mandatory)] [string]$ThemeName, [Parameter(Mandatory)] [string]$Path)
    Invoke-WithErrorHandling -Component "ThemeManager.ExportTheme" -Context "Exporting theme to JSON" -AdditionalData @{ ThemeName = $ThemeName; FilePath = $Path } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $theme = $script:Themes[$ThemeName]
            $exportTheme = @{ Name = $theme.Name; Colors = @{} }
            foreach ($colorKey in $theme.Colors.Keys) { $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString() }
            $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
            Write-Log -Level Info -Message "Exported theme '$ThemeName' to: $Path"
        } else {
            Write-Log -Level Warning -Message "Cannot export theme. Theme not found: $ThemeName"
        }
    }
}

function Import-TuiTheme {
    param([Parameter(Mandatory)] [string]$Path)
    Invoke-WithErrorHandling -Component "ThemeManager.ImportTheme" -Context "Importing theme from JSON" -AdditionalData @{ FilePath = $Path } -ScriptBlock {
        if (Test-Path $Path) {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
            $theme = @{ Name = $importedTheme.Name; Colors = @{} }
            foreach ($colorKey in $importedTheme.Colors.Keys) {
                $theme.Colors[$colorKey] = [System.Enum]::Parse([System.ConsoleColor], $importedTheme.Colors[$colorKey], $true)
            }
            $script:Themes[$theme.Name] = $theme
            Write-Log -Level Info -Message "Imported theme: $($theme.Name)"
            return $theme
        } else {
            Write-Log -Level Warning -Message "Cannot import theme. File not found: $Path"
            return $null
        }
    }
}
# --- END OF ORIGINAL FILE: modules\theme-manager\theme-manager.psm1 ---


# --- START OF ORIGINAL FILE: components\ui-classes\ui-classes.psm1 ---
# ==============================================================================
# PMC Terminal v5 - Base UI Class Hierarchy
# Provides the foundational classes for all UI components with NCurses compositor support.
# ==============================================================================









# --- Enhanced UI Element with Buffer Management ---
class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [bool] $IsFocused = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer = $null
    [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{}

    # Constructor
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with name
    UIElement([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [ArgumentException]::new("UIElement name cannot be null or empty.")
        }
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with position and size
    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Buffer")
    }

    # Get absolute screen position
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # Add child component
    [void] AddChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
        }
    }

    # Remove child component
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
            $this.RequestRedraw()
        }
    }

    # Request redraw for this component and parents
    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
    }

    # Resize the component and its buffer
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Resize($newWidth, $newHeight)
        }
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # Move the component
    [void] Move([int]$newX, [int]$newY) {
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
    }

    # Check if point is within component bounds
    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge $this.X -and $x -lt ($this.X + $this.Width) -and 
                $y -ge $this.Y -and $y -lt ($this.Y + $this.Height))
    }

    # Get child at specific point (relative to this component)
    [UIElement] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $this.X, $y - $this.Y)) {
                return $child
            }
        }
        return $null
    }

    # Virtual methods for subclasses to override
    [void] OnRender() {
        # Default implementation - clear buffer
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Override in subclasses
    }

    [void] OnMove([int]$newX, [int]$newY) {
        # Override in subclasses
    }

    [void] OnFocus() {
        # Override in subclasses
    }

    [void] OnBlur() {
        # Override in subclasses
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Override in subclasses - return true if input was handled
        return $false
    }

    # Main render method with error handling - calls _RenderContent and renders children
    [void] Render() {
        Invoke-WithErrorHandling -Component $this.Name -Context "Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            $this._RenderContent()
        } -AdditionalData @{ ComponentType = $this.GetType().Name }
    }

    # Protected render implementation - can be overridden by subclasses
    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }

        # Render this component to its private buffer
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer) {
                $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }
            
            $this.OnRender()
            $this._needs_redraw = $false
        }

        # Render children to their buffers, then composite onto parent
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
    }

    # Get the final rendered buffer
    [TuiBuffer] GetBuffer() {
        return $this._private_buffer
    }
    
    [string] ToString() {
        return "$($this.GetType().Name): $($this.Name)"
    }
}

# --- Base Component (can contain children) ---
class Component : UIElement {
    Component([string]$name) : base($name) {
    }

    # AI: Default implementation renders all visible children to buffer
    hidden [void] _RenderContent() {
        # Call parent implementation for buffer management
        ([UIElement]$this)._RenderContent()
    }
}

# Note: Panel class is now defined in layout\panels-class.psm1

# --- Base Screen (top-level container) ---
class Screen : UIElement {
    [hashtable]$Services
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[UIElement]]$Panels
    hidden [System.Collections.Generic.Dictionary[string, string]]$EventSubscriptions

    Screen([string]$name, [hashtable]$services) : base($name) {
        if (-not $services) { throw [ArgumentNullException]::new("services") }
        
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
    }
    
    [void] Initialize() { }
    [void] OnEnter() { }
    [void] OnExit() { }
    [void] OnResume() { }
    [void] HandleInput([System.ConsoleKeyInfo]$key) { }

    [void] Cleanup() {
        foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -SubscriberId $kvp.Value
            }
            catch {
                Write-Log -Level Warning -Message "Failed to unregister event '$($kvp.Key)' for screen '$($this.Name)'."
            }
        }
        $this.EventSubscriptions.Clear()
        $this.Panels.Clear()
        Write-Log -Level Debug -Message "Cleaned up screen: $($this.Name)"
    }
    
    [void] AddPanel([UIElement]$panel) {
        if (-not $panel) { throw [ArgumentNullException]::new("panel") }
        $this.Panels.Add($panel)
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($eventName)) { throw [ArgumentException]::new("Event name cannot be null or empty.") }
        if (-not $action) { throw [ArgumentNullException]::new("action") }
        
        # AI: Fixed parameter name from -Action to -Handler to match event-system.psm1 function signature
        $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
        $this.EventSubscriptions[$eventName] = $subscriptionId
    }
    
    # AI: Override _RenderContent to render all panels to buffer
    hidden [void] _RenderContent() {
        # Call base implementation for buffer management
        ([UIElement]$this)._RenderContent()
        
        # Render all panels in the screen to the back-buffer
        foreach ($panel in $this.Panels) {
            if ($panel.Visible) {
                $panel.Render()
            }
        }
    }
}
# --- END OF ORIGINAL FILE: components\ui-classes\ui-classes.psm1 ---


# --- START OF ORIGINAL FILE: layout\panels-class\panels-class.psm1 ---
# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

# Import TUI primitives and base classes





#region Panel Class - Basic Layout Container
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $this.ContentX
            $child.Y = $currentY
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $currentX
            $child.Y = $this.ContentY
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        # Calculate grid dimensions
        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            # Adjust size for last column/row
            $width = if ($col -eq ($cols - 1)) { 
                $this.ContentX + $this.ContentWidth - $x 
            } else { 
                $cellWidth 
            }
            $height = if ($row -eq ($rows - 1)) { 
                $this.ContentY + $this.ContentHeight - $y 
            } else { 
                $cellHeight 
            }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    # Set border style and update content bounds
    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    # Enable/disable border
    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    # Set title
    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    # Check if point is within content area
    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    # Get content bounds as hashtable
    [hashtable] GetContentBounds() {
        return @{
            X = $this.ContentX
            Y = $this.ContentY
            Width = $this.ContentWidth
            Height = $this.ContentHeight
        }
    }
    
    # Alias for compatibility with migrated components
    [hashtable] GetContentArea() {
        return $this.GetContentBounds()
    }
    
    # Write text to buffer at specified position
    [void] WriteToBuffer([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ($null -eq $this._private_buffer) { return }
        Write-TuiText -Buffer $this._private_buffer -X $x -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
    }
    
    # Draw a box to buffer
    [void] DrawBoxToBuffer([int]$x, [int]$y, [int]$width, [int]$height, [ConsoleColor]$borderColor, [ConsoleColor]$bgColor) {
        if ($null -eq $this._private_buffer) { return }
        Write-TuiBox -Buffer $this._private_buffer -X $x -Y $y -Width $width -Height $height `
            -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
    }

    # Clear content area only
    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return }

        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    # Main render implementation - override from UIElement
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }

        # Clear entire buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this._private_buffer.Clear($bgCell)

        # Draw border if enabled
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }

        # Fill content area
        $this.ClearContent()
    }

    # Handle focus for focusable panels
    [void] OnFocus() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Cyan
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Gray
            $this.RequestRedraw()
        }
    }

    # Find first focusable child
    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    # Get all focusable children (recursive)
    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        
        return $focusable
    }

    # Basic input handling - delegate to focused child
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # If this panel can focus and is focused, handle some basic navigation
        if ($this.CanFocus -and $this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
            }
        }

        # Delegate to children
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }

        return $false
    }

    # String representation
    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}
#endregion

#region Specialized Panel Types

# Scrollable Panel - supports content larger than visible area
class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    # Constructor
    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    # Set virtual content size
    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        
        # Create virtual buffer if needed
        if ($width -gt 0 -and $height -gt 0) {
            $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        
        $this.RequestRedraw()
    }

    # Scroll to position
    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        
        $this.RequestRedraw()
    }

    # Scroll by delta
    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    # Handle scrolling input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }

        return ([Panel]$this).HandleInput($keyInfo)
    }

    # Render with scrolling support
    [void] OnRender() {
        # Render base panel
        ([Panel]$this).OnRender()

        # Render virtual content if available
        if ($null -ne $this._virtual_buffer) {
            # Create a sub-buffer view of the virtual content
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            
            # Blend visible content onto our buffer
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }

        # Draw scrollbars if enabled and needed
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    # Draw scrollbar indicators
    [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return }

        # Vertical scrollbar
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
        }

        # Horizontal scrollbar
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    # Get virtual content buffer for external drawing
    [TuiBuffer] GetVirtualBuffer() {
        return $this._virtual_buffer
    }
}

# Group Panel - collapsible panel with header
class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    # Toggle collapsed state
    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)  # Just header + border
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        
        # Update child visibility
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        
        $this.RequestRedraw()
    }

    # Handle collapse/expand input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }

        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        
        return $false
    }

    # Render with collapse indicator
    [void] OnRender() {
        ([Panel]$this).OnRender()

        # Draw collapse/expand indicator in title area
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            $this._private_buffer.SetCell(2, 0, $indicatorCell)
        }
    }
}
#endregion

# Export the Panel classes
# --- END OF ORIGINAL FILE: layout\panels-class\panels-class.psm1 ---


# --- START OF ORIGINAL FILE: components\navigation-class\navigation-class.psm1 ---
# Navigation Component Classes Module for PMC Terminal v5
# Phase 1 Migration Complete - Proper UIElement inheritance and Panel integration








# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        $display = "[$($this.Key)] "
        
        if ($this.Enabled) {
            $display += $this.Label
        }
        else {
            $display += "$($this.Label) (Disabled)"
        }
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            $display += " - $($this.Description)"
        }
        
        return $display
    }
}

# AI: REFACTORED - NavigationMenu now properly inherits from UIElement
class NavigationMenu : UIElement {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    [bool] $IsFocused = $false
    
    NavigationMenu([string]$name) : base() {
        $this.Name = $name
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.SelectedIndex = 0
        $this.Width = 30
        $this.Height = 10
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base() {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Name = $name
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.SelectedIndex = 0
        $this.Width = 30
        $this.Height = 10
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) { 
            throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") 
        }
        $this.Items.Add($item)
        $this.RequestRedraw()
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { 
            [void]$this.Items.Remove($item)
            $this.RequestRedraw()
        }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { 
                $item.Execute() 
            }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
        $this.RequestRedraw()
    }

    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", { 
                    $this.Services.Navigation.GoTo("/tasks", @{mode="new"}) 
                }))
                $this.AddItem([NavigationItem]::new("P", "Projects", { 
                    $this.Services.Navigation.GoTo("/projects", @{}) 
                }))
                $this.AddItem([NavigationItem]::new("S", "Settings", { 
                    $this.Services.Navigation.GoTo("/settings", @{}) 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("Q", "Quit", { 
                    $this.Services.Navigation.RequestExit() 
                }))
            }
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", { 
                    Write-Host "New task not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("E", "Edit", { 
                    Write-Host "Edit not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("D", "Delete", { 
                    Write-Host "Delete not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("F", "Filter", { 
                    Write-Host "Filter not implemented" 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
            }
            default {
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
                $this.AddItem([NavigationItem]::new("H", "Home", { 
                    $this.Services.Navigation.GoTo("/dashboard", @{}) 
                }))
            }
        }
    }
    
    # AI: REFACTORED - Now uses Panel buffer integration
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear our buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Get visible items
            $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
            if ($visibleItems.Count -eq 0) { return }
            
            if ($this.Orientation -eq "Horizontal") { 
                $this.RenderHorizontal($visibleItems) 
            }
            else { 
                $this.RenderVertical($visibleItems) 
            }
            
        } catch { 
            Write-Log -Level Error -Message "NavigationMenu render error for '$($this.Name)': $_" 
        }
    }
    
    hidden [void] RenderHorizontal([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) { return }
        
        $menuText = ""
        $isFirst = $true
        foreach ($item in $items) {
            if ($null -eq $item) { continue }
            
            if (-not $isFirst) {
                $menuText += $this.Separator
            }
            $menuText += "[$($item.Key)] $($item.Label)"
            $isFirst = $false
        }
        
        # Write to our private buffer
        $this._private_buffer.WriteString(0, 0, $menuText, [ConsoleColor]::White, [ConsoleColor]::Black)
    }
    
    hidden [void] RenderVertical([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) { return }
        
        # Ensure SelectedIndex is within bounds
        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {
            $this.SelectedIndex = 0
        }
        
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($null -eq $item) { continue }
            
            $prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }
            $menuText = "$prefix[$($item.Key)] $($item.Label)"
            
            # Pad text to clear the full line width
            if ($menuText.Length -lt $this.Width) {
                $menuText = $menuText.PadRight($this.Width)
            }
            
            $fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                [ConsoleColor]::Black 
            } else { 
                [ConsoleColor]::White 
            }
            $bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                [ConsoleColor]::White 
            } else { 
                [ConsoleColor]::Black 
            }
            
            # Write to our private buffer
            $this._private_buffer.WriteString(0, $i, $menuText, $fg, $bg)
        }
    }
    
    # AI: REFACTORED - Updated input handling for new architecture
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
            if ($visibleItems.Count -eq 0) { return $false }
            
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt ($visibleItems.Count - 1)) {
                        $this.SelectedIndex++
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $visibleItems.Count) {
                        $selectedItem = $visibleItems[$this.SelectedIndex]
                        if ($selectedItem.Enabled -and $selectedItem.Key -ne "-") {
                            $selectedItem.Execute()
                        }
                    }
                    return $true
                }
                default {
                    # Check for direct key matches
                    $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
                    $matchingItem = $this.Items.Find({param($x) $x.Key -eq $keyChar})
                    if ($matchingItem -and $matchingItem.Enabled -and $matchingItem.Visible) {
                        $matchingItem.Execute()
                        return $true
                    }
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "NavigationMenu input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    # AI: NEW - Focus management
    [void] OnFocus() {
        $this.IsFocused = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        $this.IsFocused = $false
        $this.RequestRedraw()
    }
}
# --- END OF ORIGINAL FILE: components\navigation-class\navigation-class.psm1 ---


# --- START OF ORIGINAL FILE: components\tui-components\tui-components.psm1 ---
####\components\tui-components.psm1
# TUI Component Library - Phase 1 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering





#region Core UI Components

# AI: REFACTORED - LabelComponent now properly inherits from UIElement
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor
    
    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $this.Text -ForegroundColor $fg

        } catch { 
            Write-Log -Level Error -Message "Label render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false # Labels don't handle input
    }
}

# AI: REFACTORED - ButtonComponent updated for buffer-based rendering
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick
    
    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
        $this.Text = "Button"
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer, not the parent's.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))

            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            $bgColor = $this.IsPressed ? [ConsoleColor]::Yellow : [ConsoleColor]::Black
            $fgColor = $this.IsPressed ? [ConsoleColor]::Black : $borderColor
            
            # Render border to own buffer
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
            
            # Render text centered in own buffer
            $textX = [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = [Math]::Floor(($this.Height - 1) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -ForegroundColor $fgColor -BackgroundColor $bgColor

        } catch { 
            Write-Log -Level Error -Message "Button render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsPressed = $true
                $this.RequestRedraw()
                
                if ($this.OnClick) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock { & $this.OnClick }
                }
                
                Start-Sleep -Milliseconds 50 # Visual feedback for press
                $this.IsPressed = $false
                $this.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "Button input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: REFACTORED - TextBoxComponent with buffer-based rendering
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.MaxLength = 100
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)

            # Display text or placeholder
            $displayText = $this.Text ?? ""
            $textColor = [ConsoleColor]::White
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = $this.Placeholder ?? "" 
                $textColor = [ConsoleColor]::DarkGray
            }
            
            $maxDisplayLength = $this.Width - 2
            if ($displayText.Length > $maxDisplayLength) { 
                $displayText = $displayText.Substring(0, $maxDisplayLength) 
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayText -ForegroundColor $textColor
            
            # Draw cursor if focused
            if ($this.IsFocused -and ($this.CursorPosition -le $displayText.Length)) {
                $cursorX = 1 + $this.CursorPosition
                # Only draw cursor if it's within the visible area
                # AI: FIX - Changed '<' to '-lt' to avoid PowerShell parser ambiguity
                if ($cursorX -lt ($this.Width - 1)) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" -ForegroundColor [ConsoleColor]::Yellow
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "TextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition ?? 0
            $originalText = $currentText
            $handled = $true
            
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $currentText = $currentText.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    } 
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $currentText.Length) { 
                        $currentText = $currentText.Remove($cursorPos, 1) 
                    } 
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- } 
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $currentText.Length) { $cursorPos++ } 
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $currentText.Length }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) { 
                        $currentText = $currentText.Insert($cursorPos, $key.KeyChar)
                        $cursorPos++ 
                    } else { 
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                if ($currentText -ne $originalText -or $cursorPos -ne $this.CursorPosition) {
                    $this.Text = $currentText
                    $this.CursorPosition = $cursorPos
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $currentText 
                        }
                    }
                    $this.RequestRedraw()
                }
            }
            return $handled
        } catch { 
            Write-Log -Level Error -Message "TextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
}

# AI: NEW - CheckBoxComponent converted from functional to class-based
class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange
    
    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $checkbox = $this.Checked ? "[X]" : "[ ]"
            $displayText = "$checkbox $($this.Text)"
            
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $displayText -ForegroundColor $fg
            
        } catch { 
            Write-Log -Level Error -Message "CheckBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Checked = -not $this.Checked
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $this.Checked 
                    } 
                }
                $this.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "CheckBox input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: NEW - RadioButtonComponent converted from functional to class-based
class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange
    
    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $radio = $this.Selected ? "(●)" : "( )"
            $displayText = "$radio $($this.Text)"

            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $displayText -ForegroundColor $fg

        } catch { 
            Write-Log -Level Error -Message "RadioButton render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if (-not $this.Selected) {
                    # AI: Unselect other radio buttons in the same group
                    if ($this.Parent -and $this.GroupName) {
                        $siblingRadios = $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        }
                        foreach ($radio in $siblingRadios) {
                            $radio.Selected = $false
                        }
                    }
                    
                    $this.Selected = $true
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $this.Selected 
                        } 
                    }
                    $this.Parent.RequestRedraw()
                }
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "RadioButton input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $label = [LabelComponent]::new($name)
    
    $label.X = $Props.X ?? $label.X
    $label.Y = $Props.Y ?? $label.Y
    $label.Width = $Props.Width ?? $label.Width
    $label.Height = $Props.Height ?? $label.Height
    $label.Visible = $Props.Visible ?? $label.Visible
    $label.ZIndex = $Props.ZIndex ?? $label.ZIndex
    $label.Text = $Props.Text ?? $label.Text
    $label.ForegroundColor = $Props.ForegroundColor ?? $label.ForegroundColor
    
    return $label
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $button = [ButtonComponent]::new($name)
    
    $button.X = $Props.X ?? $button.X
    $button.Y = $Props.Y ?? $button.Y
    $button.Width = $Props.Width ?? $button.Width
    $button.Height = $Props.Height ?? $button.Height
    $button.Visible = $Props.Visible ?? $button.Visible
    $button.ZIndex = $Props.ZIndex ?? $button.ZIndex
    $button.Text = $Props.Text ?? $button.Text
    $button.OnClick = $Props.OnClick ?? $button.OnClick
    
    return $button
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [TextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Text = $Props.Text ?? $textBox.Text
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLength = $Props.MaxLength ?? $textBox.MaxLength
    $textBox.CursorPosition = $Props.CursorPosition ?? $textBox.CursorPosition
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    return $textBox
}

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $checkBox = [CheckBoxComponent]::new($name)
    
    $checkBox.X = $Props.X ?? $checkBox.X
    $checkBox.Y = $Props.Y ?? $checkBox.Y
    $checkBox.Width = $Props.Width ?? $checkBox.Width
    $checkBox.Height = $Props.Height ?? $checkBox.Height
    $checkBox.Visible = $Props.Visible ?? $checkBox.Visible
    $checkBox.ZIndex = $Props.ZIndex ?? $checkBox.ZIndex
    $checkBox.Text = $Props.Text ?? $checkBox.Text
    $checkBox.Checked = $Props.Checked ?? $checkBox.Checked
    $checkBox.OnChange = $Props.OnChange ?? $checkBox.OnChange
    
    return $checkBox
}

function New-TuiRadioButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $radioButton = [RadioButtonComponent]::new($name)
    
    $radioButton.X = $Props.X ?? $radioButton.X
    $radioButton.Y = $Props.Y ?? $radioButton.Y
    $radioButton.Width = $Props.Width ?? $radioButton.Width
    $radioButton.Height = $Props.Height ?? $radioButton.Height
    $radioButton.Visible = $Props.Visible ?? $radioButton.Visible
    $radioButton.ZIndex = $Props.ZIndex ?? $radioButton.ZIndex
    $radioButton.Text = $Props.Text ?? $radioButton.Text
    $radioButton.Selected = $Props.Selected ?? $radioButton.Selected
    $radioButton.GroupName = $Props.GroupName ?? $radioButton.GroupName
    $radioButton.OnChange = $Props.OnChange ?? $radioButton.OnChange
    
    return $radioButton
}

#endregion
# --- END OF ORIGINAL FILE: components\tui-components\tui-components.psm1 ---


# --- START OF ORIGINAL FILE: components\advanced-data-components\advanced-data-components.psm1 ---
# Advanced Data Components Module for PMC Terminal v5
# Phase 1 Migration Complete - Enhanced data display with proper UIElement inheritance








#region Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

# AI: REFACTORED - Table now properly inherits from UIElement
class Table : UIElement {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    [bool]$IsFocused = $false
    
    Table([string]$name) : base() {
        $this.Name = $name
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        $this.Data = @()
        $this.SelectedIndex = 0
        $this.IsFocusable = $true
        $this.Width = 60
        $this.Height = 15
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
        $this.RequestRedraw()
    }
    
    [void] SetData([object[]]$data) {
        $this.Data = if ($null -eq $data) { @() } else { @($data) }
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -ge $dataCount) {
            $this.SelectedIndex = [Math]::Max(0, $dataCount - 1)
        }
        $this.RequestRedraw()
    }
    
    [void] SelectNext() {
        $dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -lt ($dataCount - 1)) {
            $this.SelectedIndex++
            $this.RequestRedraw()
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
            $this.RequestRedraw()
        }
    }
    
    [object] GetSelectedItem() {
        if ($null -eq $this.Data) { return $null }
        
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        
        if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {
            return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }
        }
        return $null
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Draw border if enabled
            if ($this.ShowBorder) {
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                    -BorderStyle "Single" -BorderColor ([ConsoleColor]::Gray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            $currentY = if ($this.ShowBorder) { 1 } else { 0 }
            $contentWidth = if ($this.ShowBorder) { $this.Width - 2 } else { $this.Width }
            $renderX = if ($this.ShowBorder) { 1 } else { 0 }
            
            # Header
            if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
                $headerLine = ""
                foreach ($col in $this.Columns) {
                    $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                    $headerLine += $headerText + " "
                }
                
                if ($headerLine.TrimEnd().Length -gt $contentWidth) {
                    $headerLine = $headerLine.Substring(0, $contentWidth)
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $headerLine.TrimEnd() `
                    -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
                $currentY++
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY `
                    -Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $contentWidth)) `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
                $currentY++
            }
            
            # Data rows
            $dataToRender = @()
            if ($null -ne $this.Data) {
                $dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }
            }
            
            for ($i = 0; $i -lt $dataToRender.Count; $i++) {
                $row = $dataToRender[$i]
                if ($null -eq $row) { continue }
                
                $rowLine = ""
                $isSelected = ($i -eq $this.SelectedIndex)
                
                foreach ($col in $this.Columns) {
                    $cellValue = ""
                    if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                        $cellValue = $row[$col.Key]?.ToString() ?? ""
                    } elseif ($row.PSObject.Properties[$col.Key]) {
                        $cellValue = $row.($col.Key)?.ToString() ?? ""
                    }
                    
                    $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                    $rowLine += $cellText + " "
                }
                
                $finalLine = $rowLine.TrimEnd()
                if ($isSelected) {
                    $finalLine = "> $finalLine"
                } else {
                    $finalLine = "  $finalLine"
                }
                
                $fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
                $bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
                
                if ($finalLine.Length -gt $contentWidth) {
                    $finalLine = $finalLine.Substring(0, $contentWidth)
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $finalLine `
                    -ForegroundColor $fg -BackgroundColor $bg
                $currentY++
                
                # Don't exceed available space
                if ($currentY -ge ($this.Height - 1)) { break }
            }
            
            if ($dataToRender.Count -eq 0) {
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text "  No data to display" `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
        } catch { 
            Write-Log -Level Error -Message "Table render error for '$($this.Name)': $_" 
        }
    }
    
    # AI: REFACTORED - Updated input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this.SelectPrevious()
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $this.SelectNext()
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $selectedItem = $this.GetSelectedItem()
                    if ($null -ne $selectedItem) {
                        # Trigger selection event or action
                        Write-Log -Level Debug -Message "Table item selected: $($selectedItem)"
                    }
                    return $true
                }
            }
        } catch { 
            Write-Log -Level Error -Message "Table input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    [void] OnFocus() {
        $this.IsFocused = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        $this.IsFocused = $false
        $this.RequestRedraw()
    }
}

# AI: DELETED - Obsolete DataTableComponent class was here and has been removed.

#endregion

#region Factory Functions

function New-TuiTable {
    # AI: REFACTORED - Creates a proper Table instance
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Table_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $table = [Table]::new($name)
    
    if ($Props.Columns) {
        $table.SetColumns($Props.Columns)
    }
    if ($Props.Data) {
        $table.SetData($Props.Data)
    }

    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader
    $table.Visible = $Props.Visible ?? $table.Visible
    
    return $table
}

#endregion
# --- END OF ORIGINAL FILE: components\advanced-data-components\advanced-data-components.psm1 ---


# --- START OF ORIGINAL FILE: components\advanced-input-components\advanced-input-components.psm1 ---
# Advanced Input Components - Phase 2 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering





#region Advanced Input Classes

# AI: REFACTORED - MultilineTextBox converted from functional to class-based
class MultilineTextBoxComponent : UIElement {
    [string[]]$Lines = @("")
    [string]$Placeholder = "Enter text..."
    [int]$MaxLines = 10
    [int]$MaxLineLength = 100
    [int]$CurrentLine = 0
    [int]$CursorPosition = 0
    [int]$ScrollOffsetY = 0
    [bool]$WordWrap = $true
    [scriptblock]$OnChange
    
    MultilineTextBoxComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 40
        $this.Height = 10
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Calculate visible area
            $textAreaHeight = $this.Height - 2
            $textAreaWidth = $this.Width - 2
            $startLine = $this.ScrollOffsetY
            $endLine = [Math]::Min($this.Lines.Count - 1, $startLine + $textAreaHeight - 1)
            
            # AI: Render text lines
            for ($i = $startLine; $i -le $endLine; $i++) {
                if ($i -ge $this.Lines.Count) { break }
                
                $line = $this.Lines[$i] ?? ""
                $displayLine = $line
                if ($displayLine.Length -gt $textAreaWidth) {
                    $displayLine = $displayLine.Substring(0, $textAreaWidth)
                }
                
                $lineY = 1 + ($i - $startLine)
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y $lineY -Text $displayLine `
                    -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            # AI: Show placeholder if empty and not focused
            if ($this.Lines.Count -eq 1 -and [string]::IsNullOrEmpty($this.Lines[0]) -and -not $this.IsFocused) {
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $this.Placeholder `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            # AI: Draw cursor if focused
            if ($this.IsFocused) {
                $cursorLine = $this.CurrentLine - $this.ScrollOffsetY
                if ($cursorLine -ge 0 -and $cursorLine -lt $textAreaHeight) {
                    $cursorX = 1 + $this.CursorPosition
                    $cursorY = 1 + $cursorLine
                    if ($cursorX -lt $this.Width - 1) {
                        Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y $cursorY -Text "_" `
                            -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                    }
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentLineText = $this.Lines[$this.CurrentLine] ?? ""
            $originalLines = $this.Lines.Clone()
            $handled = $true
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = $this.Lines[$this.CurrentLine].Length
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.CursorPosition++
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $currentLineText.Length }
                ([ConsoleKey]::Enter) {
                    if ($this.Lines.Count -lt $this.MaxLines) {
                        $beforeCursor = $currentLineText.Substring(0, $this.CursorPosition)
                        $afterCursor = $currentLineText.Substring($this.CursorPosition)
                        
                        $this.Lines[$this.CurrentLine] = $beforeCursor
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($afterCursor) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0 -and $this.Lines.Count -gt 1) {
                        $previousLine = $this.Lines[$this.CurrentLine - 1]
                        $this.CursorPosition = $previousLine.Length
                        $this.Lines[$this.CurrentLine - 1] = $previousLine + $currentLineText
                        $this.Lines = @($this.Lines[0..($this.CurrentLine - 1)]) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        $this.CurrentLine--
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition, 1)
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $nextLine = $this.Lines[$this.CurrentLine + 1]
                        $this.Lines[$this.CurrentLine] = $currentLineText + $nextLine
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($this.Lines[($this.CurrentLine + 2)..($this.Lines.Count - 1)])
                    }
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentLineText.Length -lt $this.MaxLineLength) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.OnChange -and -not $this._ArraysEqual($originalLines, $this.Lines)) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Lines 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _UpdateScrolling() {
        $textAreaHeight = $this.Height - 2
        if ($this.CurrentLine -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CurrentLine
        } elseif ($this.CurrentLine -ge ($this.ScrollOffsetY + $textAreaHeight)) {
            $this.ScrollOffsetY = $this.CurrentLine - $textAreaHeight + 1
        }
    }
    
    hidden [bool] _ArraysEqual([string[]]$array1, [string[]]$array2) {
        if ($array1.Count -ne $array2.Count) { return $false }
        for ($i = 0; $i -lt $array1.Count; $i++) {
            if ($array1[$i] -ne $array2[$i]) { return $false }
        }
        return $true
    }
    
    [string] GetText() {
        return $this.Lines -join "`n"
    }
    
    [void] SetText([string]$text) {
        $this.Lines = if ([string]::IsNullOrEmpty($text)) { @("") } else { $text -split "`n" }
        $this.CurrentLine = 0
        $this.CursorPosition = 0
        $this.ScrollOffsetY = 0
        $this.RequestRedraw()
    }
}

# AI: REFACTORED - NumericInput converted from functional to class-based
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$Min = [double]::MinValue
    [double]$Max = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [string]$TextValue = "0"
    [int]$CursorPosition = 0
    [string]$Suffix = ""
    [scriptblock]$OnChange
    
    NumericInputComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display value with suffix
            $displayText = $this.TextValue + $this.Suffix
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw spinner arrows
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 0 -Text "▲" `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 2 -Text "▼" `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt $this.Width - 4) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" `
                        -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "NumericInput render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this._IncrementValue()
                }
                ([ConsoleKey]::DownArrow) {
                    $this._DecrementValue()
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) { 
                        $this.CursorPosition-- 
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) { 
                        $this.CursorPosition++ 
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this._ValidateAndUpdate()
                }
                default {
                    if ($key.KeyChar -and ($key.KeyChar -match '[\d\.\-]' -or 
                        ($key.KeyChar -eq '.' -and $this.DecimalPlaces -gt 0 -and -not $this.TextValue.Contains('.')))) {
                        $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "NumericInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _IncrementValue() {
        $newValue = [Math]::Min($this.Max, $this.Value + $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _DecrementValue() {
        $newValue = [Math]::Max($this.Min, $this.Value - $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _SetValue([double]$value) {
        $this.Value = $value
        $this.TextValue = $value.ToString("F$($this.DecimalPlaces)")
        $this.CursorPosition = $this.TextValue.Length
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newValue = [double]$this.TextValue
            $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
            $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
            
            $this._SetValue($newValue)
            return $true
        } catch {
            $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
            Write-Log -Level Warning -Message "NumericInput validation failed for '$($this.Name)': $_"
            return $false
        }
    }
}

# AI: REFACTORED - DateInput converted from functional to class-based
class DateInputComponent : UIElement {
    [DateTime]$Value = (Get-Date)
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [string]$Format = "yyyy-MM-dd"
    [string]$TextValue = ""
    [int]$CursorPosition = 0
    [bool]$ShowCalendar = $false
    [scriptblock]$OnChange
    
    DateInputComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.TextValue = $this.Value.ToString($this.Format)
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display date value
            $displayText = $this.TextValue
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw calendar icon
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text "📅" `
                -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt $this.Width - 4) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" `
                        -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "DateInput render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            if ($this.ShowCalendar) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) { $this.ShowCalendar = $false }
                    ([ConsoleKey]::LeftArrow) { $this.Value = $this.Value.AddDays(-1) }
                    ([ConsoleKey]::RightArrow) { $this.Value = $this.Value.AddDays(1) }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(-7) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(7) }
                    ([ConsoleKey]::Enter) { 
                        $this.ShowCalendar = $false
                        $this.TextValue = $this.Value.ToString($this.Format)
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::F4) { $this.ShowCalendar = $true }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(-1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::LeftArrow) {
                        if ($this.CursorPosition -gt 0) { $this.CursorPosition-- }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) { $this.CursorPosition++ }
                    }
                    ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                    ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                    ([ConsoleKey]::Backspace) {
                        if ($this.CursorPosition -gt 0) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                            $this.CursorPosition--
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                        }
                    }
                    ([ConsoleKey]::Enter) {
                        $this._ValidateAndUpdate()
                    }
                    default {
                        if ($key.KeyChar -and ($key.KeyChar -match '[\d\-\/]')) {
                            $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                            $this.CursorPosition++
                        } else {
                            $handled = $false
                        }
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "DateInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newDate = [DateTime]::ParseExact($this.TextValue, $this.Format, $null)
            if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                $this.Value = $newDate
                $this.TextValue = $newDate.ToString($this.Format)
                return $true
            }
        } catch {
            # Reset to current value on parse error
            $this.TextValue = $this.Value.ToString($this.Format)
            Write-Log -Level Warning -Message "DateInput validation failed for '$($this.Name)': $_"
        }
        return $false
    }
}

# AI: REFACTORED - ComboBox converted from functional to class-based
class ComboBoxComponent : UIElement {
    [object[]]$Items = @()
    [object]$SelectedItem = $null
    [int]$SelectedIndex = -1
    [string]$DisplayMember = "Display"
    [string]$ValueMember = "Value"
    [string]$Placeholder = "Select an item..."
    [bool]$IsDropDownOpen = $false
    [int]$MaxDropDownHeight = 6
    [int]$ScrollOffset = 0
    [scriptblock]$OnSelectionChanged
    
    ComboBoxComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 30
        $this.Height = 3
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw main combobox
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display selected item or placeholder
            $displayText = ""
            if ($this.SelectedItem) {
                if ($this.SelectedItem -is [string]) {
                    $displayText = $this.SelectedItem
                } elseif ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.DisplayMember)) {
                    $displayText = $this.SelectedItem[$this.DisplayMember]
                } else {
                    $displayText = $this.SelectedItem.ToString()
                }
            } else {
                $displayText = $this.Placeholder
            }
            
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength - 3) + "..."
            }
            
            $textColor = $this.SelectedItem ? [ConsoleColor]::White : [ConsoleColor]::DarkGray
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor $textColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw dropdown arrow
            $arrow = $this.IsDropDownOpen ? "▲" : "▼"
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text $arrow `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "ComboBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalSelection = $this.SelectedItem
            
            if ($this.IsDropDownOpen) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) {
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::Enter) {
                        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
                            $this.SelectedItem = $this.Items[$this.SelectedIndex]
                        }
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($this.SelectedIndex -gt 0) {
                            $this.SelectedIndex--
                            $this._UpdateScrolling()
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                            $this.SelectedIndex++
                            $this._UpdateScrolling()
                        }
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::Enter) { $this._OpenDropDown() }
                    ([ConsoleKey]::Spacebar) { $this._OpenDropDown() }
                    ([ConsoleKey]::DownArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::UpArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::F4) { $this._OpenDropDown() }
                    default { $handled = $false }
                }
            }
            
            if ($handled -and $this.SelectedItem -ne $originalSelection -and $this.OnSelectionChanged) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnSelectionChanged" -Context "Selection Change" -ScriptBlock { 
                    & $this.OnSelectionChanged -SelectedItem $this.SelectedItem 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "ComboBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _OpenDropDown() {
        if ($this.Items.Count -gt 0) {
            $this.IsDropDownOpen = $true
            $this._FindCurrentSelection()
        }
    }
    
    hidden [void] _FindCurrentSelection() {
        $this.SelectedIndex = -1
        if ($this.SelectedItem) {
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                if ($this._ItemsEqual($this.Items[$i], $this.SelectedItem)) {
                    $this.SelectedIndex = $i
                    break
                }
            }
        }
        if ($this.SelectedIndex -eq -1) { $this.SelectedIndex = 0 }
        $this._UpdateScrolling()
    }
    
    hidden [void] _UpdateScrolling() {
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $this.MaxDropDownHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $this.MaxDropDownHeight + 1
        }
    }
    
    hidden [bool] _ItemsEqual([object]$item1, [object]$item2) {
        if ($item1 -is [string] -and $item2 -is [string]) {
            return $item1 -eq $item2
        } elseif ($item1 -is [hashtable] -and $item2 -is [hashtable]) {
            return $item1[$this.ValueMember] -eq $item2[$this.ValueMember]
        } else {
            return $item1 -eq $item2
        }
    }
    
    [void] SetItems([object[]]$items) {
        $this.Items = $items
        $this.SelectedItem = $null
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.IsDropDownOpen = $false
        $this.RequestRedraw()
    }
    
    [object] GetSelectedValue() {
        if ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.ValueMember)) {
            return $this.SelectedItem[$this.ValueMember]
        }
        return $this.SelectedItem
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiMultilineTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "MultilineTextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [MultilineTextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLines = $Props.MaxLines ?? $textBox.MaxLines
    $textBox.MaxLineLength = $Props.MaxLineLength ?? $textBox.MaxLineLength
    $textBox.WordWrap = $Props.WordWrap ?? $textBox.WordWrap
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    if ($Props.Text) {
        $textBox.SetText($Props.Text)
    }
    
    return $textBox
}

function New-TuiNumericInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "NumericInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $numericInput = [NumericInputComponent]::new($name)
    
    $numericInput.X = $Props.X ?? $numericInput.X
    $numericInput.Y = $Props.Y ?? $numericInput.Y
    $numericInput.Width = $Props.Width ?? $numericInput.Width
    $numericInput.Height = $Props.Height ?? $numericInput.Height
    $numericInput.Visible = $Props.Visible ?? $numericInput.Visible
    $numericInput.ZIndex = $Props.ZIndex ?? $numericInput.ZIndex
    $numericInput.Value = $Props.Value ?? $numericInput.Value
    $numericInput.Min = $Props.Min ?? $numericInput.Min
    $numericInput.Max = $Props.Max ?? $numericInput.Max
    $numericInput.Step = $Props.Step ?? $numericInput.Step
    $numericInput.DecimalPlaces = $Props.DecimalPlaces ?? $numericInput.DecimalPlaces
    $numericInput.Suffix = $Props.Suffix ?? $numericInput.Suffix
    $numericInput.OnChange = $Props.OnChange ?? $numericInput.OnChange
    
    # Update text value based on initial value
    $numericInput.TextValue = $numericInput.Value.ToString("F$($numericInput.DecimalPlaces)")
    
    return $numericInput
}

function New-TuiDateInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DateInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $dateInput = [DateInputComponent]::new($name)
    
    $dateInput.X = $Props.X ?? $dateInput.X
    $dateInput.Y = $Props.Y ?? $dateInput.Y
    $dateInput.Width = $Props.Width ?? $dateInput.Width
    $dateInput.Height = $Props.Height ?? $dateInput.Height
    $dateInput.Visible = $Props.Visible ?? $dateInput.Visible
    $dateInput.ZIndex = $Props.ZIndex ?? $dateInput.ZIndex
    $dateInput.Value = $Props.Value ?? $dateInput.Value
    $dateInput.MinDate = $Props.MinDate ?? $dateInput.MinDate
    $dateInput.MaxDate = $Props.MaxDate ?? $dateInput.MaxDate
    $dateInput.Format = $Props.Format ?? $dateInput.Format
    $dateInput.OnChange = $Props.OnChange ?? $dateInput.OnChange
    
    # Update text value based on initial value
    $dateInput.TextValue = $dateInput.Value.ToString($dateInput.Format)
    
    return $dateInput
}

function New-TuiComboBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "ComboBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $comboBox = [ComboBoxComponent]::new($name)
    
    $comboBox.X = $Props.X ?? $comboBox.X
    $comboBox.Y = $Props.Y ?? $comboBox.Y
    $comboBox.Width = $Props.Width ?? $comboBox.Width
    $comboBox.Height = $Props.Height ?? $comboBox.Height
    $comboBox.Visible = $Props.Visible ?? $comboBox.Visible
    $comboBox.ZIndex = $Props.ZIndex ?? $comboBox.ZIndex
    $comboBox.DisplayMember = $Props.DisplayMember ?? $comboBox.DisplayMember
    $comboBox.ValueMember = $Props.ValueMember ?? $comboBox.ValueMember
    $comboBox.Placeholder = $Props.Placeholder ?? $comboBox.Placeholder
    $comboBox.MaxDropDownHeight = $Props.MaxDropDownHeight ?? $comboBox.MaxDropDownHeight
    $comboBox.OnSelectionChanged = $Props.OnSelectionChanged ?? $comboBox.OnSelectionChanged
    
    if ($Props.Items) {
        $comboBox.SetItems($Props.Items)
    }
    
    if ($Props.SelectedItem) {
        $comboBox.SelectedItem = $Props.SelectedItem
    }
    
    return $comboBox
}

#endregion
# --- END OF ORIGINAL FILE: components\advanced-input-components\advanced-input-components.psm1 ---


# --- START OF ORIGINAL FILE: modules\data-manager-class\data-manager-class.psm1 ---
# DataManager Class Definition
# Split from data-manager.psm1 to resolve class dependency issues



class DataManager {
    hidden [hashtable] $DataStore
    hidden [string] $DataFilePath
    hidden [bool] $AutoSaveEnabled = $true
    
    DataManager() {
        $this.DataStore = $script:Data
        $global:Data = $script:Data
        $this.DataFilePath = $script:DataPath
        $this.AutoSaveEnabled = $this.DataStore.Settings.AutoSave
    }

    [void] LoadData() { Load-UnifiedData }
    [void] SaveData() { Save-UnifiedData }
    
    [PmcTask] AddTask([string]$Title, [string]$Description, [string]$Priority, [string]$ProjectKey) { 
        return Add-PmcTask -Title $Title -Description $Description -Priority $Priority -Category $ProjectKey 
    }

    # AI: FIX - Changed method to accept a hashtable for flexible updates via splatting.
    [PmcTask] UpdateTask([hashtable]$UpdateParameters) {
        if (-not $UpdateParameters.ContainsKey('Task')) {
            throw [System.ArgumentException]::new("The 'UpdateParameters' hashtable must contain a 'Task' key with the task object to update.")
        }
        return Update-PmcTask @UpdateParameters
    }
    
    [void] RemoveTask([PmcTask]$Task) {
        Remove-PmcTask -Task $Task
    }
    
    [PmcTask[]] GetTasks() { 
        return Get-PmcTasks 
    }

    [PmcProject[]] GetProjects() { 
        return Get-PmcProjects 
    }
}
# --- END OF ORIGINAL FILE: modules\data-manager-class\data-manager-class.psm1 ---


# --- START OF ORIGINAL FILE: services\keybinding-service-class\keybinding-service-class.psm1 ---
# keybinding-service-class.psm1
# Contains only the KeybindingService class definition.



class KeybindingService {
    [hashtable] $KeyMap = @{}
    [hashtable] $GlobalHandlers = @{}
    [System.Collections.Generic.List[string]] $ContextStack
    [bool] $EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized"
    }
    
    KeybindingService([bool]$enableChords) {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.EnableChords = $enableChords
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized with chords: $enableChords"
    }
    
    hidden [void] InitializeDefaultBindings() {
        # AI: Standard application keybindings
        $this.KeyMap = @{
            "app.exit" = @{ Key = "Q"; Modifiers = @("Ctrl") }
            "app.help" = @{ Key = [System.ConsoleKey]::F1; Modifiers = @() }
            "nav.back" = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }
            "nav.up" = @{ Key = [System.ConsoleKey]::UpArrow; Modifiers = @() }
            "nav.down" = @{ Key = [System.ConsoleKey]::DownArrow; Modifiers = @() }
            "nav.left" = @{ Key = [System.ConsoleKey]::LeftArrow; Modifiers = @() }
            "nav.right" = @{ Key = [System.ConsoleKey]::RightArrow; Modifiers = @() }
            "nav.select" = @{ Key = [System.ConsoleKey]::Enter; Modifiers = @() }
            "nav.pageup" = @{ Key = [System.ConsoleKey]::PageUp; Modifiers = @() }
            "nav.pagedown" = @{ Key = [System.ConsoleKey]::PageDown; Modifiers = @() }
            "nav.home" = @{ Key = [System.ConsoleKey]::Home; Modifiers = @() }
            "nav.end" = @{ Key = [System.ConsoleKey]::End; Modifiers = @() }
            "nav.tab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @() }
            "nav.shifttab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @("Shift") }
            "edit.delete" = @{ Key = [System.ConsoleKey]::Delete; Modifiers = @() }
            "edit.backspace" = @{ Key = [System.ConsoleKey]::Backspace; Modifiers = @() }
            "edit.new" = @{ Key = "n"; Modifiers = @() }
            "edit.save" = @{ Key = "s"; Modifiers = @("Ctrl") }
            "app.refresh" = @{ Key = [System.ConsoleKey]::F5; Modifiers = @() }
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKey]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [char]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
        }
        
        $modifiers = @()
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) { $modifiers += "Ctrl" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) { $modifiers += "Alt" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) { $modifiers += "Shift" }

        $this.KeyMap[$actionName.ToLower()] = @{
            Key = $keyInfo.Key
            KeyChar = $keyInfo.KeyChar
            Modifiers = $modifiers
        }
        Write-Log -Level Debug -Message "Set keybinding for '$actionName': $($this.GetBindingDescription($actionName))"
    }
    
    [void] RemoveBinding([string]$actionName) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RemoveBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return
            }
            
            $normalizedName = $actionName.ToLower()
            if ($this.KeyMap.ContainsKey($normalizedName)) {
                $this.KeyMap.Remove($normalizedName)
                Write-Log -Level Debug -Message "Removed keybinding: $actionName"
            }
        }
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        return $this.IsAction($actionName, $keyInfo, $null)
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "IsAction:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return $false
            }
            
            $normalizedName = $actionName.ToLower()
            if (-not $this.KeyMap.ContainsKey($normalizedName)) {
                return $false
            }
            
            $binding = $this.KeyMap[$normalizedName]
            
            # Check if the key matches
            $keyMatches = $false
            if ($binding.Key -is [System.ConsoleKey]) {
                $keyMatches = ($keyInfo.Key -eq $binding.Key)
            }
            elseif ($binding.Key -is [char]) {
                $keyMatches = ($keyInfo.KeyChar -eq $binding.Key)
            }
            elseif ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
                # Character-based binding (case-insensitive)
                $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.KeyChar.ToString(), [System.StringComparison]::OrdinalIgnoreCase)
            }
            else {
                # Try string comparison for backward compatibility
                $keyString = $binding.Key.ToString()
                if ($keyString.Length -eq 1) {
                    $keyMatches = ($keyInfo.KeyChar.ToString().ToUpper() -eq $keyString.ToUpper())
                }
                else {
                    # Try to match against ConsoleKey enum
                    try {
                        $consoleKey = [System.ConsoleKey]::Parse([System.ConsoleKey], $keyString, $true)
                        $keyMatches = ($keyInfo.Key -eq $consoleKey)
                    }
                    catch {
                        $keyMatches = $false
                    }
                }
            }
            
            if (-not $keyMatches) {
                return $false
            }
            
            # Check modifiers
            $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
            $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
            $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
            
            $expectedCtrl = $binding.Modifiers -contains "Ctrl"
            $expectedAlt = $binding.Modifiers -contains "Alt"
            $expectedShift = $binding.Modifiers -contains "Shift"
            
            return ($hasCtrl -eq $expectedCtrl) -and ($hasAlt -eq $expectedAlt) -and ($hasShift -eq $expectedShift)
        }
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "GetAction" -ScriptBlock {
            foreach ($actionName in $this.KeyMap.Keys) {
                if ($this.IsAction($actionName, $keyInfo)) {
                    return $actionName
                }
            }
            return $null
        }
    }
    
    [void] RegisterGlobalHandler([string]$actionName, [scriptblock]$handler) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RegisterGlobalHandler:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            if ($null -eq $handler) {
                throw [System.ArgumentNullException]::new("handler", "Handler cannot be null")
            }
            
            $this.GlobalHandlers[$actionName.ToLower()] = $handler
            Write-Log -Level Debug -Message "Registered global handler: $actionName"
        }
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo) {
        return $this.HandleKey($keyInfo, $null)
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "HandleKey" -ScriptBlock {
            # Check all registered actions
            foreach ($action in $this.KeyMap.Keys) {
                if ($this.IsAction($action, $keyInfo, $context)) {
                    # Execute global handler if registered
                    if ($this.GlobalHandlers.ContainsKey($action)) {
                        Write-Log -Level Debug -Message "Executing global handler: $action"
                        try {
                            return & $this.GlobalHandlers[$action] -KeyInfo $keyInfo -Context $context
                        }
                        catch {
                            Write-Log -Level Error -Message "Global handler failed for '$action': $_"
                            return $null
                        }
                    }
                    
                    # Return the action name for the caller to handle
                    return $action
                }
            }
            
            return $null
        }
    }
    
    [void] PushContext([string]$context) {
        if (-not [string]::IsNullOrWhiteSpace($context)) {
            $this.ContextStack.Add($context)
            Write-Log -Level Debug -Message "Pushed keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
        }
    }
    
    [string] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $context = $this.ContextStack[-1]
            $this.ContextStack.RemoveAt($this.ContextStack.Count - 1)
            Write-Log -Level Debug -Message "Popped keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
            return $context
        }
        return $null
    }
    
    [string] GetCurrentContext() {
        if ($this.ContextStack.Count -gt 0) {
            return $this.ContextStack[-1]
        }
        return "global"
    }
    
    [string] GetBindingDescription([string]$actionName) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            return $null
        }
        
        $normalizedName = $actionName.ToLower()
        if (-not $this.KeyMap.ContainsKey($normalizedName)) {
            return "Unbound"
        }
        
        $binding = $this.KeyMap[$normalizedName]
        $keyStr = if ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
            $binding.KeyChar.ToString().ToUpper()
        } elseif ($binding.Key -is [System.ConsoleKey]) {
            $binding.Key.ToString()
        } else {
            $binding.Key.ToString().ToUpper()
        }
        
        if ($binding.Modifiers.Count -gt 0) {
            return "$($binding.Modifiers -join '+') + $keyStr"
        }
        
        return $keyStr
    }
    
    [hashtable] GetAllBindings() {
        return $this.GetAllBindings($false)
    }
    
    [hashtable] GetAllBindings([bool]$groupByCategory) {
        if (-not $groupByCategory) {
            return $this.KeyMap.Clone()
        }
        
        # Group by category (part before the dot)
        $grouped = @{}
        foreach ($action in $this.KeyMap.Keys) {
            $parts = $action.Split('.')
            $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
            if (-not $grouped.ContainsKey($category)) {
                $grouped[$category] = @{}
            }
            $grouped[$category][$action] = $this.KeyMap[$action]
        }
        
        return $grouped
    }
    
    [void] ExportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ExportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            $this.KeyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $path -Encoding UTF8
            Write-Log -Level Info -Message "Exported keybindings to: $path"
        }
    }
    
    [void] ImportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ImportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            if (-not (Test-Path $path)) {
                Write-Log -Level Warning -Message "Keybindings file not found: $path"
                return
            }
            
            try {
                $imported = Get-Content $path -Raw | ConvertFrom-Json
                foreach ($prop in $imported.PSObject.Properties) {
                    $bindingData = @{
                        Key = $prop.Value.Key
                        Modifiers = $prop.Value.Modifiers
                    }
                    if ($prop.Value.PSObject.Properties.Name -contains 'KeyChar') {
                        $bindingData['KeyChar'] = $prop.Value.KeyChar
                    }
                    $this.KeyMap[$prop.Name] = $bindingData
                }
                Write-Log -Level Info -Message "Imported keybindings from: $path"
            }
            catch {
                Write-Log -Level Error -Message "Failed to import keybindings from '$path': $_"
                throw
            }
        }
    }
}
# --- END OF ORIGINAL FILE: services\keybinding-service-class\keybinding-service-class.psm1 ---


# --- START OF ORIGINAL FILE: modules\dialog-system-class\dialog-system-class.psm1 ---
# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================









# Base Dialog Class - properly inheriting from UIElement
class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    [ConsoleColor] $BorderColor = [ConsoleColor]::Cyan
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [ConsoleColor] $MessageColor = [ConsoleColor]::Gray
    
    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 50
        $this.Height = 10
    }
    
    [void] Show() {
        $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
        $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 2)
        if ($null -eq $this._private_buffer -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
            $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        }
        $script:DialogState.CurrentDialog = $this
        # AI: FIX - Changed to event-based refresh to break circular dependency
        Publish-Event -EventName "TUI.RefreshRequested"
    }
    
    [void] Close() {
        $script:DialogState.CurrentDialog = $null
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        }
        # AI: FIX - Changed to event-based refresh to break circular dependency
        Publish-Event -EventName "TUI.RefreshRequested"
    }
    
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
            -BorderStyle "Single" -BorderColor $this.BorderColor -BackgroundColor [ConsoleColor]::Black -Title $this.Title
        if (-not [string]::IsNullOrWhiteSpace($this.Message)) { $this.RenderMessage() }
        $this.RenderDialogContent()
    }
    
    hidden [void] RenderMessage() {
        $messageY = 2; $messageX = 2; $maxWidth = $this.Width - 4
        $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
        foreach ($line in $wrappedLines) {
            if ($messageY -ge ($this.Height - 3)) { break }
            Write-TuiText -Buffer $this._private_buffer -X $messageX -Y $messageY -Text $line -ForegroundColor $this.MessageColor
            $messageY++
        }
    }
    
    [void] RenderDialogContent() { }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) { $this.OnCancel(); return $true }
        return $false
    }
    
    [void] OnConfirm() { $this.Close() }
    [void] OnCancel() { $this.Close() }
}

class AlertDialog : Dialog {
    [string] $ButtonText = "OK"
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title; $this.Message = $message; $this.Height = 10
        $this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))
    }
    [void] RenderDialogContent() {
        $buttonY = $this.Height - 2; $buttonLabel = "[ $($this.ButtonText) ]"
        $buttonX = [Math]::Floor(($this.Width - $buttonLabel.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY -Text $buttonLabel -ForegroundColor ([ConsoleColor]::Yellow)
    }
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) { $this.OnConfirm(); return $true }
        return ([Dialog]$this).HandleInput($key)
    }
}

class ConfirmDialog : Dialog {
    [scriptblock] $OnConfirmAction; [scriptblock] $OnCancelAction
    [string[]] $Buttons = @("Yes", "No"); [int] $SelectedButton = 0
    ConfirmDialog([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) : base("ConfirmDialog") {
        $this.Title = $title; $this.Message = $message; $this.OnConfirmAction = $onConfirm; $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10)); $this.Height = 10
    }
    [void] RenderDialogContent() {
        $buttonY = $this.Height - 3; $totalButtonWidth = ($this.Buttons.Count * 12) + (($this.Buttons.Count - 1) * 2)
        $buttonX = [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        for ($i = 0; $i -lt $this.Buttons.Count; $i++) {
            $isSelected = ($i -eq $this.SelectedButton)
            $buttonLabel = if ($isSelected) { "[ $($this.Buttons[$i]) ]" } else { "  $($this.Buttons[$i])  " }
            $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY -Text $buttonLabel -ForegroundColor $color
            $buttonX += 14
        }
    }
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) { $this.SelectedButton = [Math]::Max(0, $this.SelectedButton - 1); $this.RequestRedraw(); return $true }
            ([ConsoleKey]::RightArrow) { $this.SelectedButton = [Math]::Min($this.Buttons.Count - 1, $this.SelectedButton + 1); $this.RequestRedraw(); return $true }
            ([ConsoleKey]::Tab) { $this.SelectedButton = ($this.SelectedButton + 1) % $this.Buttons.Count; $this.RequestRedraw(); return $true }
            ([ConsoleKey]::Enter) { if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }; return $true }
            ([ConsoleKey]::Spacebar) { if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }; return $true }
        }
        return ([Dialog]$this).HandleInput($key)
    }
    [void] OnConfirm() { $this.Close(); if ($this.OnConfirmAction) { Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnConfirm" -ScriptBlock $this.OnConfirmAction } }
    [void] OnCancel() { $this.Close(); if ($this.OnCancelAction) { Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction } }
}

class InputDialog : Dialog {
    [string] $Prompt = ""
    [string] $InputValue = ""
    [int] $CursorPosition = 0
    [scriptblock] $OnSubmitAction
    [scriptblock] $OnCancelAction
    
    InputDialog([string]$title, [string]$prompt, [scriptblock]$onSubmit, [scriptblock]$onCancel) : base("InputDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.OnSubmitAction = $onSubmit
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $prompt.Length + 20))
        $this.Height = 12
    }
    
    [void] SetDefaultValue([string]$value) {
        $this.InputValue = $value
        $this.CursorPosition = $value.Length
    }
    
    [void] RenderDialogContent() {
        # Render prompt
        $promptY = 3
        $promptX = 4
        Write-TuiText -Buffer $this._private_buffer -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor [ConsoleColor]::White
        
        # Render input box
        $inputY = 5
        $inputX = 4
        $inputWidth = $this.Width - 8
        
        # Input box border
        Write-TuiBox -Buffer $this._private_buffer -X $inputX -Y $inputY -Width $inputWidth -Height 3 `
            -BorderStyle "Single" -BorderColor [ConsoleColor]::DarkGray
        
        # Input value
        $displayValue = $this.InputValue
        if ($displayValue.Length -gt ($inputWidth - 3)) {
            $displayValue = $displayValue.Substring($displayValue.Length - ($inputWidth - 3))
        }
        Write-TuiText -Buffer $this._private_buffer -X ($inputX + 1) -Y ($inputY + 1) -Text $displayValue `
            -ForegroundColor [ConsoleColor]::Yellow
        
        # Render buttons
        $buttonY = $this.Height - 3
        $okLabel = "[ OK ]"
        $cancelLabel = "[ Cancel ]"
        $totalWidth = $okLabel.Length + $cancelLabel.Length + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        Write-TuiText -Buffer $this._private_buffer -X $startX -Y $buttonY -Text $okLabel `
            -ForegroundColor [ConsoleColor]::Green
        Write-TuiText -Buffer $this._private_buffer -X ($startX + $okLabel.Length + 4) -Y $buttonY `
            -Text $cancelLabel -ForegroundColor [ConsoleColor]::Gray
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) {
                $this.OnSubmit()
                return $true
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
                return $true
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.InputValue.Length) {
                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition, 1)
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.InputValue.Length) {
                    $this.CursorPosition++
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Home) {
                $this.CursorPosition = 0
                $this.RequestRedraw()
                return $true
            }
            ([ConsoleKey]::End) {
                $this.CursorPosition = $this.InputValue.Length
                $this.RequestRedraw()
                return $true
            }
            default {
                if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or 
                    $key.KeyChar -in @(' ', '.', '-', '_', '@', '!', '?', ',', ';', ':', '/', '\', '(', ')', '[', ']', '{', '}')) {
                    $this.InputValue = $this.InputValue.Insert($this.CursorPosition, $key.KeyChar)
                    $this.CursorPosition++
                    $this.RequestRedraw()
                    return $true
                }
            }
        }
        return ([Dialog]$this).HandleInput($key)
    }
    
    [void] OnSubmit() {
        $this.Close()
        if ($this.OnSubmitAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnSubmit" -ScriptBlock {
                & $this.OnSubmitAction $this.InputValue
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

class ProgressDialog : Dialog {
    [int] $PercentComplete = 0
    [string] $StatusText = ""
    [bool] $ShowCancel = $false
    [bool] $IsCancelled = $false
    
    ProgressDialog([string]$title, [string]$message) : base("ProgressDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Width = 60
        $this.Height = 10
    }
    
    [void] UpdateProgress([int]$percent, [string]$status = "") {
        $this.PercentComplete = [Math]::Max(0, [Math]::Min(100, $percent))
        if ($status) { $this.StatusText = $status }
        $this.RequestRedraw()
    }
    
    [void] RenderDialogContent() {
        # Progress bar
        $barY = 4
        $barX = 4
        $barWidth = $this.Width - 8
        $filledWidth = [Math]::Floor($barWidth * ($this.PercentComplete / 100.0))
        
        # Bar background
        Write-TuiText -Buffer $this._private_buffer -X $barX -Y $barY `
            -Text ('─' * $barWidth) -ForegroundColor [ConsoleColor]::DarkGray
        
        # Filled portion
        if ($filledWidth -gt 0) {
            Write-TuiText -Buffer $this._private_buffer -X $barX -Y $barY `
                -Text ('█' * $filledWidth) -ForegroundColor [ConsoleColor]::Green
        }
        
        # Percentage text
        $percentText = "$($this.PercentComplete)%"
        $percentX = [Math]::Floor(($this.Width - $percentText.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $percentX -Y ($barY + 1) `
            -Text $percentText -ForegroundColor [ConsoleColor]::White
        
        # Status text
        if ($this.StatusText) {
            $statusY = $barY + 3
            $maxStatusWidth = $this.Width - 8
            if ($this.StatusText.Length -gt $maxStatusWidth) {
                $displayStatus = $this.StatusText.Substring(0, $maxStatusWidth - 3) + "..."
            } else {
                $displayStatus = $this.StatusText
            }
            $statusX = [Math]::Floor(($this.Width - $displayStatus.Length) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $statusX -Y $statusY `
                -Text $displayStatus -ForegroundColor [ConsoleColor]::Gray
        }
        
        # Cancel button if enabled
        if ($this.ShowCancel) {
            $buttonY = $this.Height - 2
            $cancelLabel = "[ Cancel ]"
            $buttonX = [Math]::Floor(($this.Width - $cancelLabel.Length) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY `
                -Text $cancelLabel -ForegroundColor [ConsoleColor]::Yellow
        }
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($this.ShowCancel -and $key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            $this.IsCancelled = $true
            $this.Close()
            return $true
        }
        return $false
    }
}

class ListDialog : Dialog {
    [string] $Prompt = ""
    [string[]] $Items = @()
    [int] $SelectedIndex = 0
    [int] $ScrollOffset = 0
    [int] $VisibleItems = 10
    [bool] $AllowMultiple = $false
    [System.Collections.Generic.HashSet[int]] $SelectedIndices
    [scriptblock] $OnSelectAction
    [scriptblock] $OnCancelAction
    
    ListDialog([string]$title, [string]$prompt, [string[]]$items, [scriptblock]$onSelect, [scriptblock]$onCancel) : base("ListDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.Items = $items
        $this.OnSelectAction = $onSelect
        $this.OnCancelAction = $onCancel
        $this.SelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
        
        # Calculate dimensions
        $maxItemWidth = ($items | Measure-Object -Property Length -Maximum).Maximum
        $this.Width = [Math]::Min(80, [Math]::Max(40, $maxItemWidth + 10))
        $this.VisibleItems = [Math]::Min(10, $items.Count)
        $this.Height = $this.VisibleItems + 8
    }
    
    [void] RenderDialogContent() {
        # Render prompt
        if ($this.Prompt) {
            $promptY = 2
            $promptX = 4
            Write-TuiText -Buffer $this._private_buffer -X $promptX -Y $promptY `
                -Text $this.Prompt -ForegroundColor [ConsoleColor]::White
        }
        
        # List area
        $listY = 4
        $listX = 4
        $listWidth = $this.Width - 8
        
        # Render visible items
        $endIndex = [Math]::Min($this.ScrollOffset + $this.VisibleItems, $this.Items.Count)
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $relativeY = $listY + ($i - $this.ScrollOffset)
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex)
            $isChecked = $this.SelectedIndices.Contains($i)
            
            # Truncate if too long
            if ($item.Length -gt ($listWidth - 4)) {
                $item = $item.Substring(0, $listWidth - 7) + "..."
            }
            
            # Format item
            $prefix = ""
            if ($this.AllowMultiple) {
                $prefix = if ($isChecked) { "[x] " } else { "[ ] " }
            }
            $displayText = "$prefix$item"
            
            # Colors
            $fg = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            $bg = if ($isSelected) { [ConsoleColor]::DarkGray } else { [ConsoleColor]::Black }
            
            # Clear line and write
            Write-TuiText -Buffer $this._private_buffer -X $listX -Y $relativeY `
                -Text (' ' * $listWidth) -BackgroundColor $bg
            Write-TuiText -Buffer $this._private_buffer -X $listX -Y $relativeY `
                -Text $displayText -ForegroundColor $fg -BackgroundColor $bg
        }
        
        # Scroll indicators
        if ($this.ScrollOffset -gt 0) {
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 5) -Y $listY `
                -Text "▲" -ForegroundColor [ConsoleColor]::DarkGray
        }
        if ($endIndex -lt $this.Items.Count) {
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 5) -Y ($listY + $this.VisibleItems - 1) `
                -Text "▼" -ForegroundColor [ConsoleColor]::DarkGray
        }
        
        # Instructions
        $instructY = $this.Height - 3
        $instructions = if ($this.AllowMultiple) { 
            "Space: Toggle, Enter: Confirm, Esc: Cancel" 
        } else { 
            "Enter: Select, Esc: Cancel" 
        }
        $instructX = [Math]::Floor(($this.Width - $instructions.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $instructX -Y $instructY `
            -Text $instructions -ForegroundColor [ConsoleColor]::DarkGray
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    if ($this.SelectedIndex -lt $this.ScrollOffset) {
                        $this.ScrollOffset = $this.SelectedIndex
                    }
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                    $this.SelectedIndex++
                    if ($this.SelectedIndex -ge ($this.ScrollOffset + $this.VisibleItems)) {
                        $this.ScrollOffset = $this.SelectedIndex - $this.VisibleItems + 1
                    }
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Spacebar) {
                if ($this.AllowMultiple) {
                    if ($this.SelectedIndices.Contains($this.SelectedIndex)) {
                        [void]$this.SelectedIndices.Remove($this.SelectedIndex)
                    } else {
                        [void]$this.SelectedIndices.Add($this.SelectedIndex)
                    }
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                $this.OnSelect()
                return $true
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
                return $true
            }
        }
        return $false
    }
    
    [void] OnSelect() {
        $this.Close()
        if ($this.OnSelectAction) {
            if ($this.AllowMultiple) {
                $selectedItems = @()
                foreach ($index in $this.SelectedIndices) {
                    $selectedItems += $this.Items[$index]
                }
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction $selectedItems
                }
            } else {
                $selectedItem = $this.Items[$this.SelectedIndex]
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction $selectedItem
                }
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ListDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Helper function for word wrapping
function Get-WordWrappedLines {
    param([string]$Text, [int]$MaxWidth)
    
    $lines = @()
    $words = $Text -split '\s+'
    $currentLine = ""
    
    foreach ($word in $words) {
        if ($currentLine.Length -eq 0) {
            $currentLine = $word
        } elseif (($currentLine.Length + 1 + $word.Length) -le $MaxWidth) {
            $currentLine += " " + $word
        } else {
            $lines += $currentLine
            $currentLine = $word
        }
    }
    
    if ($currentLine.Length -gt 0) {
        $lines += $currentLine
    }
    
    return $lines
}

$script:DialogState = @{ CurrentDialog = $null; DialogStack = [System.Collections.Stack]::new() }

function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        Subscribe-Event -EventName "Confirm.Request" -Handler { param($EventData)
            $params = $EventData.Data; Show-ConfirmDialog @params }
        Subscribe-Event -EventName "Alert.Show" -Handler { param($EventData)
            $params = $EventData.Data; Show-AlertDialog @params }
        Subscribe-Event -EventName "Input.Request" -Handler { param($EventData)
            $params = $EventData.Data; Show-InputDialog @params }
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

function Show-AlertDialog { param([string]$Title="Alert", [string]$Message); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock { ([AlertDialog]::new($Title, $Message)).Show() } }
function Show-ConfirmDialog { param([string]$Title="Confirm", [string]$Message, [scriptblock]$OnConfirm, [scriptblock]$OnCancel={}); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock { ([ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)).Show() } }
function Show-InputDialog { param([string]$Title="Input", [string]$Prompt, [string]$DefaultValue="", [scriptblock]$OnSubmit, [scriptblock]$OnCancel={}); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock { $d = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel); if ($DefaultValue) { $d.SetDefaultValue($DefaultValue) }; $d.Show() } }
function Show-ProgressDialog { param([string]$Title="Progress", [string]$Message="Processing...", [int]$PercentComplete=0, [switch]$ShowCancel); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock { $d = [ProgressDialog]::new($Title, $Message); $d.PercentComplete = $PercentComplete; $d.ShowCancel = $ShowCancel; $d.Show(); return $d } }
function Show-ListDialog { param([string]$Title="Select Item", [string]$Prompt="Choose an item:", [string[]]$Items, [scriptblock]$OnSelect, [scriptblock]$OnCancel={}, [switch]$AllowMultiple); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock { $d = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel); $d.AllowMultiple = $AllowMultiple; $d.Show() } }
function Close-TuiDialog { Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock { if ($script:DialogState.CurrentDialog) { $script:DialogState.CurrentDialog.Close() } } }
# --- END OF ORIGINAL FILE: modules\dialog-system-class\dialog-system-class.psm1 ---


# --- START OF ORIGINAL FILE: screens\dashboard-screen\dashboard-screen.psm1 ---
####\screens\dashboard\dashboard-screen.psm1
# ==============================================================================
# PMC Terminal v5 - NCurses Dashboard Screen
# Main entry screen with buffer-based rendering
# ==============================================================================

# AI: PHASE 3 REFACTORED - NCurses buffer-based architecture








class DashboardScreen : Screen {
    # --- Core Architecture ---
    [hashtable] $Services
    [Panel] $MainPanel
    [Panel] $SummaryPanel
    [Panel] $MenuPanel
    [Panel] $StatusPanel
    [NavigationMenu] $MainMenu
    [System.Collections.Generic.List[UIElement]] $Components

    # --- State Management ---
    [object[]] $Tasks = @()
    [int] $TotalTasks = 0
    [int] $CompletedTasks = 0
    [int] $PendingTasks = 0

    # --- Constructor ---
    DashboardScreen([hashtable]$services) : base("DashboardScreen", $services) {
        $this.Name = "DashboardScreen"
        $this.Services = $services
        $this.Components = [System.Collections.Generic.List[UIElement]]::new()
        $this.IsFocusable = $true
        $this.Enabled = $true
        $this.Visible = $true
        $this.Tasks = @()
        
        Write-Log -Level Info -Message "Creating DashboardScreen with NCurses architecture"
    }

    # --- Initialization ---
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "Initialize" -ScriptBlock {
            # AI: PHASE 3 - Create main panel structure
            $this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "PMC Terminal v5 - Dashboard")
            $this.MainPanel.HasBorder = $true
            $this.MainPanel.BorderStyle = "Double"
            $this.MainPanel.BorderColor = [ConsoleColor]::Cyan
            $this.MainPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MainPanel.TitleColor = [ConsoleColor]::White
            $this.MainPanel.Name = "MainDashboardPanel"
            $this.AddChild($this.MainPanel)
            
            # AI: PHASE 3 - Summary panel (left side)
            $this.SummaryPanel = [Panel]::new(2, 2, 45, 12, "Task Summary")
            $this.SummaryPanel.HasBorder = $true
            $this.SummaryPanel.BorderStyle = "Single"
            $this.SummaryPanel.BorderColor = [ConsoleColor]::Green
            $this.SummaryPanel.BackgroundColor = [ConsoleColor]::Black
            $this.SummaryPanel.Name = "SummaryPanel"
            $this.MainPanel.AddChild($this.SummaryPanel)
            
            # AI: PHASE 3 - Menu panel (right side)
            $this.MenuPanel = [Panel]::new(49, 2, 50, 15, "Main Menu")
            $this.MenuPanel.HasBorder = $true
            $this.MenuPanel.BorderStyle = "Single"
            $this.MenuPanel.BorderColor = [ConsoleColor]::Yellow
            $this.MenuPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MenuPanel.Name = "MenuPanel"
            $this.MainPanel.AddChild($this.MenuPanel)
            
            # AI: PHASE 3 - Status panel (bottom)
            $this.StatusPanel = [Panel]::new(2, 19, 116, 8, "System Status")
            $this.StatusPanel.HasBorder = $true
            $this.StatusPanel.BorderStyle = "Single"
            $this.StatusPanel.BorderColor = [ConsoleColor]::Magenta
            $this.StatusPanel.BackgroundColor = [ConsoleColor]::Black
            $this.StatusPanel.Name = "StatusPanel"
            $this.MainPanel.AddChild($this.StatusPanel)
            
            # AI: PHASE 3 - Create navigation menu
            $this.MainMenu = [NavigationMenu]::new("MainMenu", $this.Services)
            $this.MainMenu.Move(1, 1)  # Inside menu panel
            $this.MainMenu.Resize(48, 13)
            $this.BuildMainMenu()
            $this.MenuPanel.AddChild($this.MainMenu)
            
            # AI: PHASE 3 - Load initial data and update display
            $this.RefreshData()
            $this.UpdateDisplay()
            
            Write-Log -Level Info -Message "DashboardScreen initialized with NCurses architecture"
        }
    }

    # --- Menu Building ---
    hidden [void] BuildMainMenu() {
        try {
            $this.MainMenu.AddItem([NavigationItem]::new("1", "Task Management", { 
                $this.Services.Navigation.GoTo("/tasks", @{}) 
            }))
            $this.MainMenu.AddItem([NavigationItem]::new("2", "Project Management", { 
                $this.Services.Navigation.GoTo("/projects", @{}) 
            }))
            $this.MainMenu.AddItem([NavigationItem]::new("3", "Settings", { 
                $this.Services.Navigation.GoTo("/settings", @{}) 
            }))
            $this.MainMenu.AddSeparator()
            $this.MainMenu.AddItem([NavigationItem]::new("Q", "Quit Application", { 
                $this.Services.Navigation.RequestExit() 
            }))
            
            Write-Log -Level Debug -Message "Main menu built with $($this.MainMenu.Items.Count) items"
        } catch {
            Write-Log -Level Error -Message "Failed to build main menu: $_"
        }
    }

    # --- Data Management ---
    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "RefreshData" -ScriptBlock {
            # AI: PHASE 3 - Safe data loading
            $this.Tasks = @()
            $this.TotalTasks = 0
            $this.CompletedTasks = 0
            $this.PendingTasks = 0
            
            if ($null -eq $this.Services.DataManager) {
                Write-Log -Level Warning -Message "DataManager service not available"
                return
            }
            
            try {
                $taskData = $this.Services.DataManager.GetTasks()
                $this.Tasks = if ($null -eq $taskData) { @() } else { @($taskData) }
                
                # AI: PHASE 3 - Calculate statistics
                $this.TotalTasks = $this.Tasks.Count
                
                if ($this.TotalTasks -gt 0) {
                    try {
                        $completedTasks = @($this.Tasks | Where-Object { 
                            $null -ne $_ -and $_.Status -eq [TaskStatus]::Completed 
                        })
                        $this.CompletedTasks = $completedTasks.Count
                        $this.PendingTasks = $this.TotalTasks - $this.CompletedTasks
                    } catch {
                        # AI: PHASE 3 - Fallback for enum issues
                        Write-Log -Level Warning -Message "TaskStatus enum not available, using string comparison"
                        $completedTasks = @($this.Tasks | Where-Object { 
                            $null -ne $_ -and ($_.Status -eq "Completed" -or $_.Status -eq 2)
                        })
                        $this.CompletedTasks = $completedTasks.Count
                        $this.PendingTasks = $this.TotalTasks - $this.CompletedTasks
                    }
                }
                
                Write-Log -Level Debug -Message "Dashboard data refreshed - $($this.TotalTasks) tasks loaded"
            } catch {
                Write-Log -Level Warning -Message "Failed to load tasks: $_"
                $this.Tasks = @()
            }
        }
    }

    hidden [void] UpdateDisplay() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "UpdateDisplay" -ScriptBlock {
            # AI: PHASE 3 - Update summary panel
            $this.UpdateSummaryPanel()
            
            # AI: PHASE 3 - Update status panel
            $this.UpdateStatusPanel()
            
            $this.RequestRedraw()
        }
    }

    hidden [void] UpdateSummaryPanel() {
        if ($null -eq $this.SummaryPanel) { return }
        
        # AI: PHASE 3 - Clear summary panel content area
        $this.ClearPanelContent($this.SummaryPanel)
        
        # AI: PHASE 3 - Write summary information
        $summaryLines = @(
            "Task Overview",
            "═══════════════",
            "",
            "Total Tasks:    $($this.TotalTasks)",
            "Completed:      $($this.CompletedTasks)",
            "Pending:        $($this.PendingTasks)",
            "",
            "Progress: $($this.GetProgressBar())",
            "",
            "Use number keys or",
            "arrow keys + Enter"
        )
        
        for ($i = 0; $i -lt $summaryLines.Count; $i++) {
            $color = if ($i -eq 0) { [ConsoleColor]::White } elseif ($i -eq 1) { [ConsoleColor]::Gray } else { [ConsoleColor]::Cyan }
            $this.WriteTextToPanel($this.SummaryPanel, $summaryLines[$i], 1, $i, $color)
        }
    }

    hidden [void] UpdateStatusPanel() {
        if ($null -eq $this.StatusPanel) { return }
        
        # AI: PHASE 3 - Clear status panel content area
        $this.ClearPanelContent($this.StatusPanel)
        
        # AI: PHASE 3 - Write system status information
        $statusLines = @(
            "System Information",
            "════════════════════",
            "",
            # AI: FIX - Use $global scope for automatic variables inside class methods
            "PowerShell Version: $($global:PSVersionTable.PSVersion)",
            "Platform:           $($global:PSVersionTable.Platform)",
            "Memory Usage:       $($this.GetMemoryUsage())",
            "Current Time:       $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        )
        
        for ($i = 0; $i -lt $statusLines.Count; $i++) {
            $color = if ($i -eq 0) { [ConsoleColor]::White } elseif ($i -eq 1) { [ConsoleColor]::Gray } else { [ConsoleColor]::Green }
            $this.WriteTextToPanel($this.StatusPanel, $statusLines[$i], 1, $i, $color)
        }
    }

    # --- Helper Methods ---
    hidden [string] GetProgressBar() {
        if ($this.TotalTasks -eq 0) { return "No tasks" }
        
        $percentage = [Math]::Round(($this.CompletedTasks / $this.TotalTasks) * 100)
        $barLength = 20
        $filledLength = [Math]::Round(($percentage / 100) * $barLength)
        $bar = "█" * $filledLength + "░" * ($barLength - $filledLength)
        return "$bar $percentage%"
    }

    hidden [string] GetMemoryUsage() {
        try {
            # AI: FIX - Use $global scope for automatic variables inside class methods
            $process = Get-Process -Id $global:PID
            $memoryMB = [Math]::Round($process.WorkingSet64 / 1MB, 2)
            return "$memoryMB MB"
        } catch {
            return "Unknown"
        }
    }

    hidden [void] ClearPanelContent([Panel]$panel) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $panel.BackgroundColor)
        for ($y = $panel.ContentY; $y -lt ($panel.ContentY + $panel.ContentHeight); $y++) {
            for ($x = $panel.ContentX; $x -lt ($panel.ContentX + $panel.ContentWidth); $x++) {
                $panel._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    hidden [void] WriteTextToPanel([Panel]$panel, [string]$text, [int]$x, [int]$y, [ConsoleColor]$color) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        if ($y -ge $panel.ContentHeight) { return }
        
        $chars = $text.ToCharArray()
        for ($i = 0; $i -lt $chars.Length -and ($x + $i) -lt $panel.ContentWidth; $i++) {
            $cell = [TuiCell]::new($chars[$i], $color, $panel.BackgroundColor)
            $panel._private_buffer.SetCell($panel.ContentX + $x + $i, $panel.ContentY + $y, $cell)
        }
    }

    # --- Input Handling ---
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "HandleInput" -ScriptBlock {
            # AI: PHASE 3 - Handle hotkeys first
            $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
            if ($keyChar -match '^[123Q]$') {
                Write-Log -Level Debug -Message "Processing hotkey: $keyChar"
                try {
                    $this.MainMenu.ExecuteAction($keyChar)
                    return $true
                } catch {
                    Write-Log -Level Error -Message "Failed to execute menu action: $_"
                }
            }
            
            # AI: PHASE 3 - Handle navigation keys
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.MainMenu.SelectedIndex -gt 0) {
                        $this.MainMenu.SelectedIndex--
                        $this.RequestRedraw()
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.MainMenu.SelectedIndex -lt ($this.MainMenu.Items.Count - 1)) {
                        $this.MainMenu.SelectedIndex++
                        $this.RequestRedraw()
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    try {
                        $selectedItem = $this.MainMenu.Items[$this.MainMenu.SelectedIndex]
                        if ($selectedItem -and $selectedItem.Enabled) {
                            Write-Log -Level Debug -Message "Executing selected menu item: $($selectedItem.Key)"
                            $selectedItem.Execute()
                            return $true
                        }
                    } catch {
                        Write-Log -Level Error -Message "Failed to execute selected menu item: $_"
                    }
                }
                ([ConsoleKey]::Escape) {
                    Write-Log -Level Debug -Message "Escape pressed - requesting exit"
                    try {
                        $this.Services.Navigation.RequestExit()
                        return $true
                    } catch {
                        Write-Log -Level Error -Message "Failed to request exit: $_"
                    }
                }
                ([ConsoleKey]::F5) {
                    # AI: PHASE 3 - Refresh data on F5
                    $this.RefreshData()
                    $this.UpdateDisplay()
                    return $true
                }
            }
        }
        return $false
    }

    # --- NCurses Rendering ---
    [void] _RenderContent() {
        # AI: PHASE 3 - Buffer-based rendering
        if ($null -eq $this._private_buffer) { return }
        
        # AI: PHASE 3 - Clear buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black)
        $this._private_buffer.Clear($bgCell)
        
        # AI: PHASE 3 - Render all child components
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
            }
        }
    }

    # --- Lifecycle Methods ---
    [void] OnEnter() {
        $this.RefreshData()
        $this.UpdateDisplay()
        Write-Log -Level Debug -Message "DashboardScreen entered"
    }

    [void] OnExit() {
        Write-Log -Level Debug -Message "DashboardScreen exited"
    }

    [void] OnDeactivate() {
        $this.Cleanup()
        Write-Log -Level Debug -Message "DashboardScreen deactivated"
    }

    [void] Cleanup() {
        $this.Components.Clear()
        $this.Children.Clear()
        Write-Log -Level Debug -Message "DashboardScreen cleaned up"
    }
}
# --- END OF ORIGINAL FILE: screens\dashboard-screen\dashboard-screen.psm1 ---


# --- START OF ORIGINAL FILE: screens\task-list-screen\task-list-screen.psm1 ---
# ==============================================================================
# PMC Terminal v5 - NCurses Task List Screen
# Displays and manages tasks with buffer-based rendering
# ==============================================================================

# AI: PHASE 3 REFACTORED - NCurses buffer-based architecture









class TaskListScreen : Screen {
    # --- Core Architecture ---
    [hashtable] $Services
    [Panel] $MainPanel
    [Panel] $HeaderPanel
    [Panel] $TablePanel
    [Panel] $FooterPanel
    [Table] $TaskTable
    [System.Collections.Generic.List[UIElement]] $Components

    # --- State Management ---
    [string] $FilterStatus = "All"
    [object[]] $AllTasks = @()
    [object[]] $FilteredTasks = @()
    [int] $SelectedIndex = 0

    # --- Constructor ---
    TaskListScreen([hashtable]$services) : base("TaskListScreen", $services) {
        $this.Name = "TaskListScreen"
        $this.Services = $services
        $this.Components = [System.Collections.Generic.List[UIElement]]::new()
        $this.IsFocusable = $true
        $this.Enabled = $true
        $this.Visible = $true
    }

    # --- Initialization ---
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # AI: PHASE 3 - Create main panel structure
            $this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "Task List")
            $this.MainPanel.HasBorder = $true
            $this.MainPanel.BorderStyle = "Double"
            $this.MainPanel.BorderColor = [ConsoleColor]::Gray
            $this.MainPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MainPanel.Name = "MainTaskPanel"
            $this.AddChild($this.MainPanel)
            
            # AI: PHASE 3 - Header panel for title and filter info
            $this.HeaderPanel = [Panel]::new(1, 1, 118, 3, "")
            $this.HeaderPanel.HasBorder = $false
            $this.HeaderPanel.BackgroundColor = [ConsoleColor]::Black
            $this.HeaderPanel.Name = "HeaderPanel"
            $this.MainPanel.AddChild($this.HeaderPanel)
            
            # AI: PHASE 3 - Table panel for task data
            $this.TablePanel = [Panel]::new(1, 4, 118, 22, "")
            $this.TablePanel.HasBorder = $true
            $this.TablePanel.BorderStyle = "Single"
            $this.TablePanel.BorderColor = [ConsoleColor]::DarkGray
            $this.TablePanel.BackgroundColor = [ConsoleColor]::Black
            $this.TablePanel.Name = "TablePanel"
            $this.MainPanel.AddChild($this.TablePanel)
            
            # AI: PHASE 3 - Footer panel for navigation help
            $this.FooterPanel = [Panel]::new(1, 26, 118, 3, "")
            $this.FooterPanel.HasBorder = $false
            $this.FooterPanel.BackgroundColor = [ConsoleColor]::Black
            $this.FooterPanel.Name = "FooterPanel"
            $this.MainPanel.AddChild($this.FooterPanel)
            
            # AI: PHASE 3 - Create task table component
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.Move(1, 1)  # Inside table panel
            $this.TaskTable.Resize(116, 20)

            # AI: FIX - Use proper TableColumn class instances
            $columns = @(
                [TableColumn]::new('Title', 'Task Title', 50),
                [TableColumn]::new('Status', 'Status', 15),
                [TableColumn]::new('Priority', 'Priority', 12),
                [TableColumn]::new('GetDueDateString', 'Due Date', 15) # Use method for display
            )
            $this.TaskTable.SetColumns($columns)
            
            $this.TablePanel.AddChild($this.TaskTable)
            
            # AI: PHASE 3 - Load initial data
            $this.RefreshData()
            $this.UpdateDisplay()
            
            Write-Log -Level Info -Message "TaskListScreen initialized with NCurses architecture"
        }
    }

    # --- Data Management ---
    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            # AI: PHASE 3 - Safe data loading with error handling
            try {
                $this.AllTasks = @($this.Services.DataManager.GetTasks())
                if ($null -eq $this.AllTasks) { $this.AllTasks = @() }
            } catch {
                Write-Log -Level Warning -Message "Failed to load tasks: $_"
                $this.AllTasks = @()
            }
            
            # AI: PHASE 3 - Apply current filter
            $this.FilteredTasks = switch ($this.FilterStatus) {
                "Active" { @($this.AllTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed }) }
                "Completed" { @($this.AllTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed }) }
                default { $this.AllTasks }
            }
            
            # AI: PHASE 3 - Update table data
            $this.TaskTable.SetData($this.FilteredTasks)
            
            # AI: PHASE 3 - Adjust selection if needed
            if ($this.SelectedIndex -ge $this.FilteredTasks.Count) {
                $this.SelectedIndex = [Math]::Max(0, $this.FilteredTasks.Count - 1)
            }
            
            $this.RequestRedraw()
        }
    }

    hidden [void] UpdateDisplay() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "UpdateDisplay" -ScriptBlock {
            # AI: PHASE 3 - Update header text
            $headerText = "Filter: $($this.FilterStatus) | Total: $($this.FilteredTasks.Count) tasks"
            $this.WriteTextToPanel($this.HeaderPanel, $headerText, 0, 0, [ConsoleColor]::White)
            
            # AI: PHASE 3 - Update footer navigation text
            $footerText = "[↑↓]Navigate [Space]Toggle [N]ew [E]dit [D]elete [F]ilter [Esc]Back"
            $this.WriteTextToPanel($this.FooterPanel, $footerText, 0, 0, [ConsoleColor]::Yellow)
            
            # AI: PHASE 3 - Update table selection
            $this.TaskTable.SelectedIndex = $this.SelectedIndex
            
            $this.RequestRedraw()
        }
    }

    # --- Helper Methods ---
    hidden [void] WriteTextToPanel([Panel]$panel, [string]$text, [int]$x, [int]$y, [ConsoleColor]$color) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        
        $chars = $text.ToCharArray()
        for ($i = 0; $i -lt $chars.Length -and ($x + $i) -lt $panel.ContentWidth; $i++) {
            $cell = [TuiCell]::new($chars[$i], $color, $panel.BackgroundColor)
            $panel._private_buffer.SetCell($panel.ContentX + $x + $i, $panel.ContentY + $y, $cell)
        }
    }

    # --- Input Handling ---
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $this.UpdateDisplay()
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt ($this.FilteredTasks.Count - 1) -and $this.FilteredTasks.Count -gt 0) {
                        $this.SelectedIndex++
                        $this.UpdateDisplay()
                        return $true
                    }
                }
                ([ConsoleKey]::Spacebar) {
                    $this.ToggleSelectedTask()
                    return $true
                }
                ([ConsoleKey]::Escape) {
                    $this.NavigateBack()
                    return $true
                }
                default {
                    $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
                    switch ($keyChar) {
                        'N' { $this.ShowNewTaskDialog(); return $true }
                        'E' { $this.EditSelectedTask(); return $true }
                        'D' { $this.DeleteSelectedTask(); return $true }
                        'F' { $this.CycleFilter(); return $true }
                    }
                }
            }
        }
        return $false
    }

    # --- Task Actions ---
    hidden [void] ToggleSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        try {
            $newCompletedStatus = $task.Status -ne [TaskStatus]::Completed
            
            $this.Services.DataManager.UpdateTask(@{
                Task = $task
                Completed = $newCompletedStatus
            })
            
            $this.RefreshData()
            $this.UpdateDisplay()
        } catch {
            Write-Log -Level Error -Message "Failed to toggle task: $_"
        }
    }

    hidden [void] ShowNewTaskDialog() {
        Write-Log -Level Info -Message "New task dialog requested"
        
        $dataManager = $this.Services.DataManager
        $refreshCallback = { $this.RefreshData(); $this.UpdateDisplay() }.GetNewClosure()
        
        try {
            Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {
                param($Value)
                if (-not [string]::IsNullOrWhiteSpace($Value)) {
                    # AI: FIX - This now uses correct method call syntax with positional arguments.
                    $newTask = $dataManager.AddTask($Value, "", "medium", "General")
                    Write-Log -Level Info -Message "Created new task: $($newTask.Title)"
                    & $refreshCallback
                }
            }
        } catch {
            Write-Log -Level Error -Message "Failed to show new task dialog: $_"
        }
    }

    hidden [void] EditSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        Write-Log -Level Info -Message "Edit task requested for: $($task.Title)"
        
        $refreshCallback = { $this.RefreshData(); $this.UpdateDisplay() }.GetNewClosure()
        try {
            Show-InputDialog -Title "Edit Task" -Prompt "New title:" -DefaultValue $task.Title -OnSubmit {
                param($Value)
                if (-not [string]::IsNullOrWhiteSpace($Value)) {
                    $this.Services.DataManager.UpdateTask(@{
                        Task = $task
                        Title = $Value
                    })
                    & $refreshCallback
                }
            }
        } catch {
             Write-Log -Level Error -Message "Failed to show edit task dialog: $_"
        }
    }

    hidden [void] DeleteSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        Write-Log -Level Info -Message "Delete task requested for: $($task.Title)"
        
        $refreshCallback = { $this.RefreshData(); $this.UpdateDisplay() }.GetNewClosure()
        try {
            Show-ConfirmDialog -Title "Delete Task" -Message "Are you sure you want to delete `"$($task.Title)`"?" -OnConfirm {
                $this.Services.DataManager.RemoveTask($task)
                & $refreshCallback
            }
        } catch {
             Write-Log -Level Error -Message "Failed to show delete confirm dialog: $_"
        }
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
        $this.UpdateDisplay()
    }

    hidden [void] NavigateBack() {
        try {
            $this.Services.Navigation.PopScreen()
        } catch {
            Write-Log -Level Error -Message "Failed to navigate back: $_"
        }
    }

    # --- NCurses Rendering ---
    [void] _RenderContent() {
        # AI: PHASE 3 - Buffer-based rendering
        if ($null -eq $this._private_buffer) { return }
        
        # AI: PHASE 3 - Clear buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black)
        $this._private_buffer.Clear($bgCell)
        
        # AI: PHASE 3 - Render all child components
        # Call the base class's _RenderContent which handles compositing children.
        ([UIElement]$this)._RenderContent()
    }
    
    # --- Lifecycle Methods ---
    [void] OnEnter() {
        $this.RefreshData()
        $this.UpdateDisplay()
        Write-Log -Level Debug -Message "TaskListScreen entered"
    }

    [void] OnExit() {
        Write-Log -Level Debug -Message "TaskListScreen exited"
    }

    [void] Cleanup() {
        $this.Components.Clear()
        $this.Children.Clear()
        Write-Log -Level Debug -Message "TaskListScreen cleaned up"
    }
}
# --- END OF ORIGINAL FILE: screens\task-list-screen\task-list-screen.psm1 ---


# --- START OF ORIGINAL FILE: services\navigation-service-class\navigation-service-class.psm1 ---
# navigation-service-class.psm1
# Contains only the NavigationService and ScreenFactory class definitions.



class ScreenFactory {
    hidden [hashtable] $Services
    hidden [hashtable] $ScreenTypes = @{}
    
    ScreenFactory([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        Write-Log -Level Debug -Message "ScreenFactory initialized"
    }
    
    [void] RegisterScreen([string]$name, [type]$screenType) {
        if (-not ($screenType -eq [Screen] -or $screenType.IsSubclassOf([Screen]))) { 
            throw "Screen type '$($screenType.Name)' must inherit from the Screen class." 
        }
        $this.ScreenTypes[$name] = $screenType
        Write-Log -Level Info -Message "Registered screen factory: $name -> $($screenType.Name)"
    }
    
    [Screen] CreateScreen([string]$screenName, [hashtable]$parameters) {
        $screenType = $this.ScreenTypes[$screenName]
        if (-not $screenType) {
            throw "Unknown screen type: '$screenName'. Available screens: $($this.ScreenTypes.Keys -join ', ')"
        }
        
        try {
            $screen = $screenType::new($this.Services)
            if ($parameters) {
                foreach ($key in $parameters.Keys) { 
                    $screen.State[$key] = $parameters[$key] 
                }
            }
            Write-Log -Level Info -Message "Created screen: $screenName"
            return $screen
        } catch {
            Write-Log -Level Error -Message "Failed to create screen '$screenName': $($_.Exception.Message)"
            throw
        }
    }
    
    [string[]] GetRegisteredScreens() {
        return @($this.ScreenTypes.Keys)
    }
}

class NavigationService {
    [System.Collections.Generic.Stack[Screen]] $ScreenStack
    [ScreenFactory] $ScreenFactory
    [Screen] $CurrentScreen
    [hashtable] $Services
    [hashtable] $RouteMap = @{}
    
    NavigationService([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        $this.ScreenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.ScreenFactory = [ScreenFactory]::new($services)
        $this.InitializeRoutes()
        Write-Log -Level Info -Message "NavigationService initialized"
    }
    
    hidden [void] InitializeRoutes() {
        $this.RouteMap = @{
            "/" = "DashboardScreen"
            "/dashboard" = "DashboardScreen"
            "/tasks" = "TaskListScreen"
        }
        Write-Log -Level Debug -Message "Routes initialized: $($this.RouteMap.Keys -join ', ')"
    }
    
    [void] RegisterScreenClass([string]$name, [type]$screenType) {
        $this.ScreenFactory.RegisterScreen($name, $screenType)
    }
    
    [void] GoTo([string]$path, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "GoTo:$path" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) { 
                throw [System.ArgumentException]::new("Path cannot be empty.") 
            }
            if ($path -eq "/exit") { 
                $this.RequestExit()
                return 
            }
            
            $screenName = $this.RouteMap[$path]
            if (-not $screenName) {
                $availableRoutes = $this.RouteMap.Keys -join ', '
                throw "Unknown route: '$path'. Available routes: $availableRoutes"
            }
            
            Write-Log -Level Info -Message "Navigating to: $path -> $screenName"
            $this.PushScreen($screenName, $parameters)
        }
    }
    
    [void] PushScreen([string]$screenName, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "PushScreen:$screenName" -ScriptBlock {
            Write-Log -Level Info -Message "Pushing screen: $screenName"
            
            if ($this.CurrentScreen) {
                Write-Log -Level Debug -Message "Exiting current screen: $($this.CurrentScreen.Name)"
                $this.CurrentScreen.OnExit()
                $this.ScreenStack.Push($this.CurrentScreen)
            }
            
            Write-Log -Level Debug -Message "Creating new screen: $screenName"
            $newScreen = $this.ScreenFactory.CreateScreen($screenName, $parameters)
            $this.CurrentScreen = $newScreen
            
            Write-Log -Level Debug -Message "Initializing screen: $screenName"
            $newScreen.Initialize()
            $newScreen.OnEnter()
            
            if (Get-Command "Push-Screen" -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Pushing screen to TUI engine"
                Push-Screen -Screen $newScreen
            } else {
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $newScreen
                    Request-TuiRefresh
                }
            }
            
            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{ Screen = $screenName; Action = "Push" }
            Write-Log -Level Info -Message "Successfully pushed screen: $screenName"
        }
    }
    
    [bool] PopScreen() {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "PopScreen" -ScriptBlock {
            if ($this.ScreenStack.Count -eq 0) { 
                Write-Log -Level Warning -Message "Cannot pop screen: stack is empty"
                return $false 
            }
            
            Write-Log -Level Info -Message "Popping screen"
            $this.CurrentScreen?.OnExit()
            $this.CurrentScreen = $this.ScreenStack.Pop()
            $this.CurrentScreen?.OnResume()
            
            if (Get-Command "Pop-Screen" -ErrorAction SilentlyContinue) {
                Pop-Screen
            } else {
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $this.CurrentScreen
                    Request-TuiRefresh
                }
            }
            
            Publish-Event -EventName "Navigation.ScreenPopped" -Data @{ Screen = $this.CurrentScreen.Name }
            return $true
        }
    }
    
    [void] RequestExit() {
        Write-Log -Level Info -Message "Exit requested"
        while ($this.PopScreen()) {} # Pop all screens
        $this.CurrentScreen?.OnExit()
        if (Get-Command "Stop-TuiEngine" -ErrorAction SilentlyContinue) {
            Stop-TuiEngine
        }
        Publish-Event -EventName "Application.Exit"
    }
    
    [Screen] GetCurrentScreen() { return $this.CurrentScreen }
    [bool] IsValidRoute([string]$path) { return $this.RouteMap.ContainsKey($path) }
    
    [void] ListRegisteredScreens() {
        $screens = $this.ScreenFactory.GetRegisteredScreens()
        Write-Log -Level Info -Message "Registered screens: $($screens -join ', ')"
        Write-Host "Registered screens: $($screens -join ', ')" -ForegroundColor Green
    }
    
    [void] ListAvailableRoutes() {
        $routes = $this.RouteMap.Keys
        Write-Log -Level Info -Message "Available routes: $($routes -join ', ')"
        Write-Host "Available routes: $($routes -join ', ')" -ForegroundColor Green
    }
}
# --- END OF ORIGINAL FILE: services\navigation-service-class\navigation-service-class.psm1 ---


# --- START OF ORIGINAL FILE: modules\data-manager\data-manager.psm1 ---
####\modules\data-manager.psm1
# Data Manager Module
# Unified data persistence and CRUD operations with event integration

# AI: FIX - Corrected relative paths for all dependencies.







# Module-level state variables
$script:Data = @{
    Projects = New-Object System.Collections.ArrayList
    Tasks = New-Object System.Collections.ArrayList
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    time_entries = @() # underscore format for action compatibility
    timers = @()       # for action compatibility
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system, loads data, and returns a service instance.
    #>
    [CmdletBinding()]
    param()
    
    return Invoke-WithErrorHandling -Component "DataManager.Initialize" -Context "DataManager initialization" -ScriptBlock {
        $dataDirectory = Split-Path $script:DataPath -Parent
        if (-not (Test-Path $dataDirectory)) {
            New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
            Write-Log -Level Info -Message "Created data directory: $dataDirectory"
        }
        
        if (-not (Test-Path $script:BackupPath)) {
            New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
            Write-Log -Level Info -Message "Created backup directory: $script:BackupPath"
        }
        
        Load-UnifiedData
        Initialize-DataEventHandlers
        
        Write-Log -Level Info -Message "DataManager initialized successfully"
        return [DataManager]::new()
    }
}

function Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads application data from disk into strongly-typed objects.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.LoadData" -Context "Loading unified data from disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            try {
                $loadedData = Get-Content -Path $script:DataPath -Raw | ConvertFrom-Json -AsHashtable
                
                if ($loadedData -is [hashtable]) {
                    if ($loadedData.Tasks) {
                        $script:Data.Tasks.Clear()
                        foreach ($taskData in $loadedData.Tasks) {
                            if ($taskData -is [hashtable]) { 
                                $task = [PSCustomObject]$taskData
                                $task.PSObject.TypeNames.Insert(0, 'PmcTask')
                                $script:Data.Tasks.Add($task) | Out-Null
                            }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Tasks.Count) tasks as PmcTask objects"
                    }
                    
                    if ($loadedData.Projects -is [hashtable]) {
                        $script:Data.Projects.Clear()
                        foreach ($projectKey in $loadedData.Projects.Keys) {
                            $projectData = $loadedData.Projects[$projectKey]
                            if ($projectData -is [hashtable]) { $script:Data.Projects.Add([PmcProject]::FromLegacyFormat($projectData)) }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Projects.Count) projects as PmcProject objects"
                    }
                    
                    foreach ($key in 'TimeEntries', 'ActiveTimers', 'TodoTemplates', 'Settings', 'time_entries', 'timers') {
                        if ($loadedData.ContainsKey($key)) { $script:Data[$key] = $loadedData[$key] }
                    }
                    
                    $global:Data = $script:Data
                    Write-Log -Level Info -Message "Data loaded successfully from disk"
                } else {
                    Write-Log -Level Warning -Message "Invalid data format in file, using defaults"
                    $global:Data = $script:Data
                }
            } catch {
                Write-Log -Level Error -Message "Failed to parse data file: $_"
                $global:Data = $script:Data
            }
        } else {
            Write-Log -Level Info -Message "No existing data file found, using defaults"
            $global:Data = $script:Data
        }
        
        $script:LastSaveTime = Get-Date
    }
}

function Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves application data to disk with backup rotation.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.SaveData" -Context "Saving unified data to disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
            Copy-Item -Path $script:DataPath -Destination (Join-Path $script:BackupPath $backupName) -Force
            
            $backups = Get-ChildItem -Path $script:BackupPath -Filter "pmc-data_*.json" | Sort-Object LastWriteTime -Descending
            if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                $backups | Select-Object -Skip $script:Data.Settings.BackupCount | Remove-Item -Force
            }
        }
        
        $dataToSave = @{
            Tasks = @($script:Data.Tasks | ForEach-Object { $_.ToLegacyFormat() })
            Projects = @{}
            TimeEntries = $script:Data.TimeEntries
            ActiveTimers = $script:Data.ActiveTimers
            TodoTemplates = $script:Data.TodoTemplates
            Settings = $script:Data.Settings
            time_entries = $script:Data.time_entries
            timers = $script:Data.timers
        }
        
        foreach ($project in $script:Data.Projects) { $dataToSave.Projects[$project.Key] = $project.ToLegacyFormat() }
        
        $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $script:DataPath -Encoding UTF8
        $script:LastSaveTime = Get-Date; $script:DataModified = $false
        Write-Log -Level Debug -Message "Data saved successfully"
    }
}

#region Task Management Functions

function Add-PmcTask {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [ValidateNotNullOrEmpty()] [string]$Title,
        [string]$Description = "",
        [ValidateSet("low", "medium", "high")] [string]$Priority = "medium",
        [string]$Category = "General",
        [string]$DueDate = ""
    )
    
    return Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task" -ScriptBlock {
        if ([string]::IsNullOrWhiteSpace($Title)) { throw [StateMutationException]::new("Task title cannot be empty", @{ Title = $Title }) }
        
        $taskPriority = [TaskPriority]::$Priority
        $newTask = [PmcTask]::new($Title, $Description, $taskPriority, $Category)
        
        if ($DueDate -and $DueDate -ne "N/A") {
            try { $newTask.DueDate = [datetime]::Parse($DueDate) } catch { Write-Log -Level Warning -Message "Invalid due date format: $DueDate" }
        }
        
        $script:Data.Tasks.Add($newTask); $script:DataModified = $true
        Write-Log -Level Info -Message "Created task '$($newTask.Title)' with ID $($newTask.Id)"
        
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        
        Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Created"; TaskId = $newTask.Id; Task = $newTask }
        return $newTask
    }
}

function Update-PmcTask {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [PmcTask]$Task,
        [string]$Title, [string]$Description, [ValidateSet("low", "medium", "high")] [string]$Priority,
        [string]$Category, [string]$DueDate, [bool]$Completed, [ValidateRange(0, 100)] [int]$Progress
    )
    
    return Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating task" -ScriptBlock {
        $managedTask = $script:Data.Tasks.Find({$_.Id -eq $Task.Id})
        if (-not $managedTask) { throw [StateMutationException]::new("Task not found in data store", @{ TaskId = $Task.Id }) }
        
        $updatedFields = @()
        if ($PSBoundParameters.ContainsKey('Title')) { $managedTask.Title = $Title.Trim(); $updatedFields += "Title" }
        if ($PSBoundParameters.ContainsKey('Description')) { $managedTask.Description = $Description; $updatedFields += "Description" }
        if ($PSBoundParameters.ContainsKey('Priority')) { $managedTask.Priority = [TaskPriority]::$Priority; $updatedFields += "Priority" }
        if ($PSBoundParameters.ContainsKey('Category')) { $managedTask.ProjectKey = $Category; $managedTask.Category = $Category; $updatedFields += "Category" }
        if ($PSBoundParameters.ContainsKey('DueDate')) {
            try { $managedTask.DueDate = ($DueDate -and $DueDate -ne "N/A") ? [datetime]::Parse($DueDate) : $null } catch { Write-Log -Level Warning -Message "Invalid due date format: $DueDate" }
            $updatedFields += "DueDate"
        }
        if ($PSBoundParameters.ContainsKey('Progress')) { $managedTask.UpdateProgress($Progress); $updatedFields += "Progress" }
        if ($PSBoundParameters.ContainsKey('Completed')) {
            if ($Completed) { $managedTask.Complete() } else { $managedTask.Status = [TaskStatus]::Pending; $managedTask.Completed = $false; $managedTask.Progress = 0 }
            $updatedFields += "Completed"
        }
        
        $managedTask.UpdatedAt = [datetime]::Now; $script:DataModified = $true
        Write-Log -Level Info -Message "Updated task $($managedTask.Id) - Fields: $($updatedFields -join ', ')"
        
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        
        Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Updated"; TaskId = $managedTask.Id; Task = $managedTask; UpdatedFields = $updatedFields }
        return $managedTask
    }
}

function Remove-PmcTask {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [PmcTask]$Task)
    
    return Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task" -ScriptBlock {
        $taskToRemove = $script:Data.Tasks.Find({$_.Id -eq $Task.Id})
        if ($taskToRemove) {
            $script:Data.Tasks.Remove($taskToRemove) | Out-Null; $script:DataModified = $true
            Write-Log -Level Info -Message "Deleted task $($Task.Id)"
            if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Deleted"; TaskId = $Task.Id; Task = $Task }
            return $true
        }
        Write-Log -Level Warning -Message "Task not found with ID $($Task.Id)"; return $false
    }
}

function Get-PmcTasks {
    [CmdletBinding()]
    param([bool]$Completed, [ValidateSet("low", "medium", "high")] [string]$Priority, [string]$Category)
    
    return Invoke-WithErrorHandling -Component "DataManager.GetTasks" -Context "Retrieving tasks" -ScriptBlock {
        $tasks = $script:Data.Tasks
        if ($PSBoundParameters.ContainsKey('Completed')) { $tasks = $tasks | Where-Object { $_.Completed -eq $Completed } }
        if ($Priority) { $priorityEnum = [TaskPriority]::$Priority; $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum } }
        if ($Category) { $tasks = $tasks | Where-Object { $_.ProjectKey -eq $Category -or $_.Category -eq $Category } }
        return @($tasks)
    }
}

#endregion

#region Project Management Functions

function Get-PmcProjects { [CmdletBinding()] param() return @($script:Data.Projects) }
function Get-PmcProject { [CmdletBinding()] param([Parameter(Mandatory)] [string]$Key) return $script:Data.Projects.Find({$_.Key -eq $Key}) }

function Add-PmcProject {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [PmcProject]$Project)
    
    return Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding project" -ScriptBlock {
        if ($script:Data.Projects.Exists({$_.Key -eq $Project.Key})) { throw [StateMutationException]::new("Project with key '$($Project.Key)' already exists", @{ ProjectKey = $Project.Key }) }
        
        $script:Data.Projects.Add($Project); $script:DataModified = $true
        Write-Log -Level Info -Message "Created project '$($Project.Name)' with key $($Project.Key)"
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Created"; ProjectKey = $Project.Key; Project = $Project }
        return $Project
    }
}

#endregion

#region DataManager Class Definition

# DataManager class moved to data-manager-class.psm1 to resolve dependency issues

#endregion

#region Private Helper Functions

function Initialize-DataEventHandlers {
    Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -Context "Initializing data event handlers" -ScriptBlock {
        $null = Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Refreshed"; Tasks = @($script:Data.Tasks) }
        }
        Write-Log -Level Debug -Message "Data event handlers initialized"
    }
}

#endregion
# --- END OF ORIGINAL FILE: modules\data-manager\data-manager.psm1 ---


# --- START OF ORIGINAL FILE: services\keybinding-service\keybinding-service.psm1 ---
# keybinding-service.psm1
# Contains only the factory function for creating KeybindingService instances.



function New-KeybindingService {
    <#
    .SYNOPSIS
    Creates a new instance of the KeybindingService class.
    #>
    [CmdletBinding()]
    param(
        [switch]$EnableChords
    )
    
    if ($EnableChords) {
        return [KeybindingService]::new($true)
    }
    else {
        return [KeybindingService]::new()
    }
}
# --- END OF ORIGINAL FILE: services\keybinding-service\keybinding-service.psm1 ---


# --- START OF ORIGINAL FILE: services\navigation-service\navigation-service.psm1 ---
# navigation-service-functions.psm1
# Contains only the factory function for the NavigationService.



function Initialize-NavigationService {
    param([hashtable]$Services)
    if (-not $Services) { throw [System.ArgumentNullException]::new("Services") }
    return [NavigationService]::new($Services)
}
# --- END OF ORIGINAL FILE: services\navigation-service\navigation-service.psm1 ---


# --- START OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---
# TUI Engine v5.1 - NCurses Compositor Edition
# Implements NCurses-style compositor with private buffers and TuiCell rendering






#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    CompositorBuffer = $null    # AI: NEW - Master compositor buffer (TuiBuffer)
    PreviousCompositorBuffer = $null # AI: NEW - Buffer for diffing against the main compositor
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
    CompositorMode  = $true     # AI: NEW - Enable NCurses-style rendering
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.1 (NCurses Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        # AI: ENHANCED - Create both legacy buffers and new TuiBuffer compositor
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        $global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new($Width, $Height, "PreviousCompositor")
        
        # Initialize legacy buffers for compatibility
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        # AI: FIX - Subscribe to refresh requests to decouple dialog system
        Subscribe-Event -EventName "TUI.RefreshRequested" -Handler {
            Request-TuiRefresh
        } -Source "TuiEngine"

        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height; CompositorMode = $global:TuiState.CompositorMode }
        Write-Log -Level Info -Message "TUI Engine v5.1 initialized successfully (Compositor Mode: $($global:TuiState.CompositorMode))"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent) {
        try { 
            # AI: ENHANCED - Better class detection for UIElement-based components
            if ($focusedComponent -is [UIElement]) {
                # New UIElement-based component
                $focusedComponent.HandleInput($keyInfo)
            }
            elseif ($focusedComponent.PSObject.TypeNames -contains 'UIElement' -or $focusedComponent.GetType().IsSubclassOf([UIElement])) {
                # Class-based component (legacy detection)
                if ($focusedComponent.PSObject.Methods.Name -contains 'HandleInput') {
                    $focusedComponent.HandleInput($keyInfo)
                }
            }
            elseif ($focusedComponent.HandleInput) {
                # Functional component with HandleInput scriptblock
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return }
            }
        } catch { 
            Write-Warning "Component input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for component '$($focusedComponent.Name)': $_"
        }
    }
    
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            # AI: ENHANCED - Support for UIElement-based screens
            if ($currentScreen -is [UIElement]) {
                # New UIElement-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen -is [Screen]) {
                # Legacy class-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen.HandleInput) {
                # Hashtable/functional screen - use scriptblock invocation
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { Stop-TuiEngine }
                }
            }
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([object]$InitialScreen)  # AI: Accept both UIElement and hashtable screens
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

# AI: REWRITTEN - NCurses Compositor Render-Frame
function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        if ($global:TuiState.CompositorMode -and $null -ne $global:TuiState.CompositorBuffer) {
            # AI: NEW - NCurses-style compositor rendering
            Render-FrameCompositor
        } else {
            # AI: LEGACY - Fall back to old rendering for compatibility
            Render-FrameLegacy
        }
        
        # AI: NEW - After rendering, copy the current compositor state to the previous state buffer for the next frame's diff.
        if ($global:TuiState.CompositorMode) {
            $global:TuiState.PreviousCompositorBuffer.Clear()
            $global:TuiState.PreviousCompositorBuffer.BlendBuffer($global:TuiState.CompositorBuffer, 0, 0)
        }
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    # AI: NEW - NCurses-style compositor rendering pipeline
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                if ($global:TuiState.CurrentScreen -is [UIElement]) {
                    # New UIElement-based screen - render to its private buffer
                    $global:TuiState.CurrentScreen.Render()
                    
                    # Composite screen buffer onto master compositor
                    $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                    if ($null -ne $screenBuffer) {
                        $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                    }
                } else {
                    # Legacy screen - render directly (will be deprecated)
                    $global:TuiState.CurrentScreen.Render()
                }
            }
        }
        
        # 3. Render dialogs on top
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog -is [UIElement]) {
                    # New UIElement-based dialog
                    $dialog.Render()
                    $dialogBuffer = $dialog.GetBuffer()
                    if ($null -ne $dialogBuffer) {
                        $pos = $dialog.GetAbsolutePosition()
                        $global:TuiState.CompositorBuffer.BlendBuffer($dialogBuffer, $pos.X, $pos.Y)
                    }
                } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                    # Class-based dialog with Render() method
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    # Functional/hashtable dialog with Render scriptblock
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
        # Fall back to legacy rendering
        Render-FrameLegacy
    }
}

function Render-CompositorToConsole {
    # AI: REWRITTEN - True TuiBuffer-to-TuiBuffer diffing.
    $outputBuilder = [System.Text.StringBuilder]::new(20000)
    $currentBuffer = $global:TuiState.CompositorBuffer
    $previousBuffer = $global:TuiState.PreviousCompositorBuffer
    $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1

    try {
        for ($y = 0; $y -lt $currentBuffer.Height; $y++) {
            $rowChanged = $false
            for ($x = 0; $x -lt $currentBuffer.Width; $x++) {
                $newCell = $currentBuffer.GetCell($x, $y)
                $oldCell = $previousBuffer.GetCell($x, $y)
                
                if ($forceFullRender -or $newCell.DiffersFrom($oldCell)) {
                    if (-not $rowChanged) {
                        [void]$outputBuilder.Append("`e[$($y + 1);1H")
                        # On the first change in a row, we must move the cursor.
                        # For subsequent changes, we need to move it again if there was a gap.
                        if ($x > 0) { [void]$outputBuilder.Append("`e[$($y + 1);$($x + 1)H") }
                        $rowChanged = $true
                    }

                    if ($newCell.ForegroundColor -ne $lastFG -or $newCell.BackgroundColor -ne $lastBG) {
                        $fgCode = Get-AnsiColorCode $newCell.ForegroundColor
                        $bgCode = Get-AnsiColorCode $newCell.BackgroundColor -IsBackground $true
                        [void]$outputBuilder.Append("`e[${fgCode};${bgCode}m")
                        $lastFG = $newCell.ForegroundColor
                        $lastBG = $newCell.BackgroundColor
                    }
                    [void]$outputBuilder.Append($newCell.Char)
                } elseif ($rowChanged) {
                    # If a change occurred in this row previously, but this cell is the same,
                    # we need to move the cursor to the next potential change point.
                    [void]$outputBuilder.Append("`e[$($y + 1);$($x + 2)H")
                }
            }
        }
        
        # Reset colors at the end
        if ($lastFG -ne -1) { [void]$outputBuilder.Append("`e[0m") }
        
        if ($outputBuilder.Length -gt 10) {
            [Console]::Write($outputBuilder.ToString())
        }
    } catch {
        Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Render-FrameLegacy {
    # AI: LEGACY - Original rendering code for compatibility
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component $global:TuiState.CurrentScreen.Name -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
            }
        }
        
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog.GetType().IsSubclassOf([UIElement]) -or $dialog -is [UIElement]) {
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        Render-BufferOptimized
        
    } catch {
        Write-Log -Level Error -Message "Legacy rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    # AI: ENHANCED - Accept both UIElement and legacy screen objects
    param([object]$Screen)
    if (-not $Screen) { return }
    
    $screenName = if ($Screen -is [UIElement]) { $Screen.Name } elseif ($Screen -is [Screen]) { $Screen.Name } else { $Screen.Name }
    Write-Log -Level Debug -Message "Pushing screen: $screenName"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($global:TuiState.CurrentScreen) {
            # Handle exit for current screen
            if ($global:TuiState.CurrentScreen -is [UIElement]) {
                # New UIElement-based screen
                # No explicit OnExit method - handled by framework
            } elseif ($global:TuiState.CurrentScreen -is [Screen]) {
                # Legacy class-based screen
                $global:TuiState.CurrentScreen.OnExit()
            } elseif ($global:TuiState.CurrentScreen.OnExit) {
                # Functional screen
                $global:TuiState.CurrentScreen.OnExit.Invoke()
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # Initialize new screen
        if ($Screen -is [UIElement]) {
            # New UIElement-based screen - ensure it's sized to fit screen
            if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) {  # Default size
                $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            }
            # Trigger initial render
            $Screen.RequestRedraw()
        } elseif ($Screen -is [Screen]) {
            # Legacy class-based screen
            $Screen.OnEnter()
        } elseif ($Screen.Init) { 
            # Functional screen
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $screenName }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$screenName': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $global:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering - Legacy Support
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:TuiState.BufferWidth) { break }
        if ($currentX -ge 0) { $global:TuiState.BackBuffer[$Y, $currentX] = @{ Char = $char; FG = $ForegroundColor; BG = $BackgroundColor } }
        $currentX++
    }
}

function Write-BufferBox {
    param([int]$X, [int]$Y, [int]$Width, [int]$Height, [string]$BorderStyle = "Single", [ConsoleColor]$BorderColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, [string]$Title = "")
    $borders = Get-BorderChars -Style $BorderStyle
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    if ($Title) {
        $titleText = " $Title "; if ($titleText.Length -gt ($Width-2)) { $titleText = " $($Title.Substring(0,[Math]::Max(0,$Width-5)))... " }
        Write-BufferString -X ($X + [Math]::Floor(($Width - $titleText.Length) / 2)) -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function Render-BufferOptimized {
    $outputBuilder = [System.Text.StringBuilder]::new(20000); $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 0
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $backCell = $global:TuiState.BackBuffer[$y, $x]; $frontCell = $global:TuiState.FrontBuffer[$y, $x]
                if (-not $forceFullRender -and $backCell.Char -eq $frontCell.Char -and $backCell.FG -eq $frontCell.FG -and $backCell.BG -eq $frontCell.BG) { continue }
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) { $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null }
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG; $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null; $lastFG = $backCell.FG; $lastBG = $backCell.BG
                }
                $outputBuilder.Append($backCell.Char) | Out-Null
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = $backCell.Char; FG = $backCell.FG; BG = $backCell.BG }
            }
        }
        $outputBuilder.Append("`e[0m") | Out-Null
        if ($outputBuilder.Length -gt 0) { [Console]::Write($outputBuilder.ToString()) }
    } catch { Write-Warning "Render error: $_" }
}
#endregion

#region Component System - Enhanced for UIElement
function Initialize-ComponentSystem { $global:TuiState.Components = @(); $global:TuiState.FocusedComponent = $null }

function Register-Component { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    $global:TuiState.Components += $Component
    
    # Initialize component based on type
    if ($Component -is [UIElement]) {
        # New UIElement-based component - no explicit init needed
        Write-Log -Level Debug -Message "Registered UIElement component: $($Component.Name)"
    } elseif ($Component.Init) { 
        try { & $Component.Init -self $Component } catch { Write-Warning "Component init error: $_" } 
    }
    return $Component 
}

function Set-ComponentFocus { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) { return }
    
    # Blur current component
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    
    # Set new focused component
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    
    # Focus new component
    if ($null -ne $Component) {
        if ($Component -is [UIElement]) {
            $Component.OnFocus()
        } else {
            $Component.OnFocus?.Invoke()
        }
    }
    
    Request-TuiRefresh 
}

function Clear-ComponentFocus { 
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    $global:TuiState.FocusedComponent = $null
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $null }
    Request-TuiRefresh 
}

# AI: ENHANCED - Support UIElement focusable detection
function Get-NextFocusableComponent { 
    param([object]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = @()
    
    function Find-Focusable([object]$Comp) { 
        if ($Comp -is [UIElement]) {
            # New UIElement-based component
            if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
                $focusableComponents += $Comp
            }
            # Check children
            foreach ($child in $Comp.Children) {
                Find-Focusable $child
            }
        } else {
            # Legacy component
            if ($Comp.IsFocusable -eq $true -and $Comp.Visible -ne $false) { 
                $focusableComponents += $Comp 
            }
            if ($Comp.Children) { 
                foreach ($c in $Comp.Children) { Find-Focusable $c } 
            }
        }
    }
    
    # Find focusable components in current screen
    if ($global:TuiState.CurrentScreen -is [UIElement]) {
        Find-Focusable $global:TuiState.CurrentScreen
    } elseif ($global:TuiState.CurrentScreen.Components) { 
        foreach ($c in $global:TuiState.CurrentScreen.Components.Values) { Find-Focusable $c } 
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by tab index and position
    $sorted = $focusableComponents | Sort-Object { 
        if ($_ -is [UIElement]) {
            $_.TabIndex * 10000 + $_.Y * 100 + $_.X
        } else {
            ($_.TabIndex ?? 0) * 10000 + ($_.Y ?? 0) * 100 + ($_.X ?? 0)
        }
    }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Handle-TabNavigation { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

# AI: LEGACY - Helper functions maintained for compatibility
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Move-Focus { param([bool]$Reverse = $false); Handle-TabNavigation -Reverse $Reverse }

function Get-CurrentDialog {
    # AI: REFACTORED - This function now directly and reliably accesses the dialog state
    # from the single, class-based dialog system.
    try {
        if (Get-Module -Name 'dialog-system-class' -ErrorAction SilentlyContinue) {
            # This retrieves the $script:DialogState variable from the specified module's scope.
            return (Get-Module -Name 'dialog-system-class').SessionState.PSVariable.Get('DialogState').Value.CurrentDialog
        }
    } catch {
        Write-Log -Level Error -Message "Critical error accessing dialog system state: $_"
    }
    return $null
}

function Handle-DialogInput {
    param([System.ConsoleKeyInfo]$Key)
    # AI: REFACTORED - Simplified to work only with the new UIElement-based dialogs.
    try {
        $dialog = Get-CurrentDialog
        if ($dialog -and $dialog -is [UIElement]) {
            # All dialogs are now UIElements and have a HandleInput method.
            return $dialog.HandleInput($Key)
        }
    } catch {
        Write-Log -Level Error -Message "Error handling dialog input: $_"
    }
    return $false
}

function Update-DialogSystem {
    # Dialog system handles its own updates if loaded
}

function Stop-AllTuiAsyncJobs {
    Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)"
}
#endregion

#region Layout Management & Utilities
function Initialize-LayoutEngines { $global:TuiState.Layouts = @{} }
function Get-BorderChars { param([string]$Style); $styles = @{ Single=@{TopLeft='┌';TopRight='┐';BottomLeft='└';BottomRight='┘';Horizontal='─';Vertical='│'}; Double=@{TopLeft='╔';TopRight='╗';BottomLeft='╚';BottomRight='╝';Horizontal='═';Vertical='║'}; Rounded=@{TopLeft='╭';TopRight='╮';BottomLeft='╰';BottomRight='╯';Horizontal='─';Vertical='│'} }; return $styles[$Style] ?? $styles.Single }
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Get-WordWrappedLines { param([string]$Text, [int]$MaxWidth); if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }; $lines = @(); $words = $Text -split '\s+'; $sb = [System.Text.StringBuilder]::new(); foreach ($word in $words) { if ($sb.Length -eq 0) { [void]$sb.Append($word) } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) { [void]$sb.Append(' ').Append($word) } else { $lines += $sb.ToString(); [void]$sb.Clear().Append($word) } }; if ($sb.Length -gt 0) { $lines += $sb.ToString() }; return $lines }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }

# AI: NEW - Compositor helper functions
function Get-ThemeColor {
    param([string]$ColorName)
    # Simple theme color mapping - can be enhanced later
    $themeColors = @{
        Background = [ConsoleColor]::Black
        Foreground = [ConsoleColor]::White
        Border = [ConsoleColor]::Gray
        Focus = [ConsoleColor]::Cyan
        Highlight = [ConsoleColor]::Yellow
    }
    return $themeColors[$ColorName] ?? [ConsoleColor]::Black
}
#endregion
# --- END OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---


# --- START OF ORIGINAL FILE: modules\tui-framework\tui-framework.psm1 ---
# TUI Framework Integration Module
# Contains utility functions for interacting with the TUI engine and components.
# AI: FIX - Added all missing dependencies.




$script:TuiAsyncJobs = @()

function Invoke-TuiMethod {
    <# .SYNOPSIS Safely invokes a method on a TUI component. #>
    param(
        [Parameter(Mandatory)] [hashtable]$Component,
        [Parameter(Mandatory)] [string]$MethodName,
        [Parameter()] [hashtable]$Arguments = @{}
    )
    if (-not $Component) { return }
    $method = $Component[$MethodName]
    if (-not ($method -is [scriptblock])) { return }

    $Arguments['self'] = $Component
    Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock { & $method @Arguments }
}

function Initialize-TuiFramework {
    Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {
        if (-not $global:TuiState) { throw "TUI Engine must be initialized before the TUI Framework." }
        Write-Log -Level Info -Message "TUI Framework initialized."
    }
}

function Invoke-TuiAsync {
    <# .SYNOPSIS Executes a script block asynchronously with job management. #>
    param(
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [string]$JobName = "TuiAsyncJob_$(Get-Random)",
        [hashtable]$ArgumentList = @{}
    )
    Invoke-WithErrorHandling -Component "TuiFramework.Async" -Context "Starting async job: $JobName" -ScriptBlock {
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList -Name $JobName
        $script:TuiAsyncJobs += $job
        Write-Log -Level Debug -Message "Started async job: $JobName" -Data @{ JobId = $job.Id }
        return $job
    }
}

function Get-TuiAsyncResults {
    <# .SYNOPSIS Checks for completed async jobs and returns their results. #>
    param([switch]$RemoveCompleted = $true)
    Invoke-WithErrorHandling -Component "TuiFramework.AsyncResults" -Context "Checking async job results" -ScriptBlock {
        $results = @()
        $completedJobs = $script:TuiAsyncJobs | Where-Object { $_.State -in @('Completed', 'Failed', 'Stopped') }
        
        foreach ($job in $completedJobs) {
            $results += @{
                JobId = $job.Id; JobName = $job.Name; State = $job.State
                Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job } else { $null }
                Error = if ($job.State -eq 'Failed') { $job.ChildJobs[0].JobStateInfo.Reason } else { $null }
            }
            Write-Log -Level Debug -Message "Async job completed: $($job.Name)" -Data @{ JobId = $job.Id; State = $job.State }
        }
        
        if ($RemoveCompleted -and $completedJobs.Count -gt 0) {
            foreach ($job in $completedJobs) {
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                $script:TuiAsyncJobs = $script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id }
            }
        }
        return $results
    }
}

function Stop-AllTuiAsyncJobs {
    Invoke-WithErrorHandling -Component "TuiFramework.StopAsync" -Context "Stopping all async jobs" -ScriptBlock {
        foreach ($job in $script:TuiAsyncJobs) {
            try {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                Write-Log -Level Debug -Message "Stopped async job: $($job.Name)"
            } catch {
                Write-Log -Level Warning -Message "Failed to stop job $($job.Name): $_"
            }
        }
        $script:TuiAsyncJobs = @()
        Write-Log -Level Info -Message "All TUI async jobs stopped."
    }
}

function Request-TuiRefresh {
    if ($global:TuiState.RequestRefresh) { & $global:TuiState.RequestRefresh }
    else { Publish-Event -EventName "TUI.RefreshRequested" }
}

function Get-TuiState { return $global:TuiState }

function Test-TuiState {
    param([switch]$ThrowOnError)
    $isValid = $global:TuiState -and $global:TuiState.Running -and $global:TuiState.CurrentScreen
    if (-not $isValid -and $ThrowOnError) { throw "TUI state is not properly initialized. Call Initialize-TuiEngine first." }
    return $isValid
}
# --- END OF ORIGINAL FILE: modules\tui-framework\tui-framework.psm1 ---


# --- START OF MAIN EXECUTION LOGIC (from _CLASSY-MAIN.ps1) ---
try {
    Write-Host "`n=== PMC Terminal v5 - Starting (Classy Loader) ===" -ForegroundColor Cyan
    Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)" -ForegroundColor DarkGray
    
    # Initialize core services that have no dependencies
    Write-Host "`nInitializing services..." -ForegroundColor Yellow
    Initialize-Logger -Level $(if ($Debug) { "Debug" } else { "Info" })
    Initialize-EventSystem
    Initialize-ThemeManager
    
    # Create the service container
    $services = @{}
    
    # Initialize services that depend on others, passing the container
    $services.KeybindingService = New-KeybindingService
    $services.DataManager = Initialize-DataManager
    
    # NavigationService needs the $services container to pass to screens
    $services.Navigation = Initialize-NavigationService -Services $services
    
    # Register screen classes with the navigation service
    $services.Navigation.RegisterScreenClass("DashboardScreen", [DashboardScreen])
    $services.Navigation.RegisterScreenClass("TaskListScreen", [TaskListScreen])
    
    # Initialize the dialog system
    Initialize-DialogSystem
    
    Write-Host "All services initialized!" -ForegroundColor Green
    
    if (-not $SkipLogo) {
        Write-Host @"
    
    ╔═══════════════════════════════════════╗
    ║      PMC Terminal v5.0                ║
    ║      PowerShell Management Console    ║
    ╚═══════════════════════════════════════╝
    
"@ -ForegroundColor Cyan
    }
    
    # Initialize the TUI Engine which orchestrates the UI
    Write-Host "Starting TUI Engine..." -ForegroundColor Yellow
    Initialize-TuiEngine
    
    # Create and initialize the first screen
    $dashboard = [DashboardScreen]::new($services)
    $dashboard.Initialize()
    
    # Push the screen to the engine and start the main loop
    Push-Screen -Screen $dashboard
    Start-TuiLoop
    
} catch {
    Write-Host "`n=== FATAL ERROR ===" -ForegroundColor Red
    Write-Host "An error occurred during application startup."
    Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack Trace:" -ForegroundColor DarkRed
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
    
    Write-Host "`nPress any key to exit..." -ForegroundColor Yellow
    if ($Host.UI.RawUI) {
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    }
    exit 1
} finally {
    # Cleanup logic if needed
    Pop-Location -ErrorAction SilentlyContinue
   
}
# --- END OF MAIN EXECUTION LOGIC ---




####\one.ps1
# ==================================================================================
# PMC Terminal v5 - MONOLITHIC SCRIPT
#
# This file is automatically generated by Create-Monolith.ps1.
# DO NOT EDIT THIS FILE DIRECTLY.
# Edit the source files in their respective directories and re-run the builder.
# ==================================================================================

using namespace System.Text
using namespace System.Management.Automation
using namespace System

#Requires -Version 7.0
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Consolidated 'using namespace' statements



# --- START OF ORIGINAL FILE: modules\logger\logger.psm1 ---


# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------
$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------
function ConvertTo-SerializableObject {
    param([object]$Object)
    if ($null -eq $Object) { return $null }
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'
    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)
        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) { [void]$visited.Add($InputObject) }
        switch ($InputObject.GetType().Name) {
            'Hashtable' { $r = @{}; foreach ($k in $InputObject.Keys) { try { $r[$k] = Convert-Internal $InputObject[$k] ($Depth+1) } catch { $r[$k] = "<Err>" } }; return $r }
            'PSCustomObject' { $r = @{}; foreach ($p in $InputObject.PSObject.Properties) { try { if ($p.MemberType -ne 'ScriptMethod') { $r[$p.Name] = Convert-Internal $p.Value ($Depth+1) } } catch { $r[$p.Name] = "<Err>" } }; return $r }
            'Object[]' { $r = @(); for ($i=0; $i -lt [Math]::Min($InputObject.Count,10); $i++) { try { $r += Convert-Internal $InputObject[$i] ($Depth+1) } catch { $r += "<Err>" } }; if($InputObject.Count -gt 10) { $r += "<...>" }; return $r }
            default { try { if ($InputObject -is [ValueType] -or $InputObject -is [string] -or $InputObject -is [datetime]) { return $InputObject } else { return $InputObject.ToString() } } catch { return "<Err>" } }
        }
    }
    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------
function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Debug"
    )
    if ([string]::IsNullOrWhiteSpace($LogDirectory) -or [string]::IsNullOrWhiteSpace($LogFileName)) { Write-Warning "Invalid logger parameters."; return }
    try {
        if (-not (Test-Path $LogDirectory)) { New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null }
        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true
        Write-Log -Level Info -Message "Logger initialized" -Data @{ LogPath = $script:LogPath; PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS; PID = $PID } -Force
    } catch { Write-Warning "Failed to initialize logger: $_"; $script:LogInitialized = $false }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")] [string]$Level = "Info",
        [Parameter(Mandatory)] [string]$Message,
        [object]$Data,
        [switch]$Force
    )
    if (-not $script:LogInitialized -and -not $Force) { return }
    $levelPriority = @{ Debug=0; Trace=0; Verbose=1; Info=2; Warning=3; Error=4; Fatal=5 }
    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }
    try {
        $caller = (Get-PSCallStack)[1]
        $logContext = @{
            Timestamp = (Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"); Level = $Level; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
            CallDepth = $script:CallDepth; Message = $Message; Caller = @{ Command = $caller.Command; Location = $caller.Location; ScriptName = $caller.ScriptName; LineNumber = $caller.ScriptLineNumber }
        }
        if ($PSBoundParameters.ContainsKey('Data')) { $logContext.UserData = if ($Data -is [Exception]) { @{ Type="Exception"; Message=$Data.Message; StackTrace=$Data.StackTrace; InnerException=$Data.InnerException.Message } } else { ConvertTo-SerializableObject -Object $Data } }
        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) { "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)" } else { $caller.Command }
        $logEntry = "$($logContext.Timestamp) [$($Level.PadRight(7))] $indent [$callerInfo] $Message"
        if ($PSBoundParameters.ContainsKey('Data')) { $logEntry += if ($Data -is [Exception]) { "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)" } else { try { "`n${indent}  Data: $(ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue)" } catch { "`n${indent}  Data: $($Data.ToString())" } } }
        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) { $script:LogQueue.RemoveRange(0, 1000) }
        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) { Move-Item $script:LogPath ($script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log") -Force }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch { Write-Host "LOG WRITE FAILED: $logEntry`nError: $_" -ForegroundColor Yellow }
        }
        if ($Level -in @('Error', 'Fatal', 'Warning')) { Write-Host $logEntry -ForegroundColor ($Level -in @('Error', 'Fatal') ? 'Red' : 'Yellow') }
    } catch { try { $errorEntry = "$(Get-Date -Format 'o') [LOGGER ERROR] Failed to log: $_"; if ($script:LogPath) { Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8 }; Write-Host $errorEntry -ForegroundColor Red } catch { Write-Host "CRITICAL: Logger failed: $_" -ForegroundColor Red } }
}

function Trace-FunctionEntry { [CmdletBinding()] param([string]$FunctionName, [object]$Parameters); if (-not $script:TraceAllCalls) { return }; $script:CallDepth++; Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{ Parameters=$Parameters; Action="FunctionEntry" } }
function Trace-FunctionExit { [CmdletBinding()] param([string]$FunctionName, [object]$ReturnValue, [switch]$WithError); if (-not $script:TraceAllCalls) { return }; Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{ ReturnValue=$ReturnValue; Action=($WithError ? "FunctionExitWithError" : "FunctionExit"); HasError=$WithError.IsPresent }; $script:CallDepth = [Math]::Max(0, $script:CallDepth - 1) }
function Trace-Step { [CmdletBinding()] param([string]$StepName, [object]$StepData, [string]$Module); $caller = (Get-PSCallStack)[1]; $moduleInfo = $Module ?? ($caller.ScriptName ? [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) : "Unknown"); Write-Log -Level Debug -Message "STEP: $StepName" -Data @{ StepData=$StepData; Module=$moduleInfo; Action="Step" } }
function Trace-StateChange { [CmdletBinding()] param([string]$StateType, [object]$OldValue, [object]$NewValue, [string]$PropertyPath); Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{ StateType=$StateType; PropertyPath=$PropertyPath; OldValue=$OldValue; NewValue=$NewValue; Action="StateChange" } }
function Trace-ComponentLifecycle { [CmdletBinding()] param([string]$ComponentType, [string]$ComponentId, [ValidateSet('Create','Initialize','Render','Update','Destroy')] [string]$Phase, [object]$ComponentData); Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{ ComponentType=$ComponentType; ComponentId=$ComponentId; Phase=$Phase; ComponentData=$ComponentData; Action="ComponentLifecycle" } }
function Trace-ServiceCall { [CmdletBinding()] param([string]$ServiceName, [string]$MethodName, [object]$Parameters, [object]$Result, [switch]$IsError); Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{ ServiceName=$ServiceName; MethodName=$MethodName; Parameters=$Parameters; Result=$Result; Action=($IsError ? "ServiceCallError" : "ServiceCall"); IsError=$IsError.IsPresent } }

function Get-LogEntries {
    [CmdletBinding()]
    param([int]$Count = 100, [string]$Level, [string]$Module, [string]$Action)
    try {
        $entries = $script:LogQueue.ToArray()
        if ($Level) { $entries = $entries | Where-Object { $_.Level -eq $Level } }
        if ($Module) { $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") } }
        if ($Action) { $entries = $entries | Where-Object { $_.UserData.Action -eq $Action } }
        return $entries | Select-Object -Last $Count
    } catch { Write-Warning "Error getting log entries: $_"; return @() }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)
    try {
        $callStack = Get-PSCallStack; $trace = @()
        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { $call = $callStack[$i]; $trace += @{ Level=$i-1; Command=$call.Command; Location=$call.Location; ScriptName=$call.ScriptName; LineNumber=$call.ScriptLineNumber } }
        return $trace
    } catch { Write-Warning "Error getting call trace: $_"; return @() }
}

function Clear-LogQueue { try { $script:LogQueue.Clear(); Write-Log -Level Info -Message "In-memory log queue cleared" } catch { Write-Warning "Error clearing log queue: $_" } }
function Set-LogLevel { [CmdletBinding()] param([Parameter(Mandatory)] [ValidateSet("Debug","Verbose","Info","Warning","Error","Fatal","Trace")] [string]$Level); try { $oldLevel = $script:LogLevel; $script:LogLevel = $Level; Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force } catch { Write-Warning "Error setting log level to '$Level': $_" } }
function Enable-CallTracing { $script:TraceAllCalls = $true; Write-Log -Level Info -Message "Call tracing enabled" -Force }
function Disable-CallTracing { $script:TraceAllCalls = $false; Write-Log -Level Info -Message "Call tracing disabled" -Force }
function Get-LogPath { return $script:LogPath }

function Get-LogStatistics {
    [CmdletBinding()]
    param()
    try {
        $stats = [PSCustomObject]@{ TotalEntries=$script:LogQueue.Count; LogPath=$script:LogPath; LogLevel=$script:LogLevel; CallTracingEnabled=$script:TraceAllCalls; LogFileSize=($script:LogPath -and (Test-Path $script:LogPath) ? (Get-Item $script:LogPath).Length : 0); EntriesByLevel=@{}; EntriesByModule=@{}; EntriesByAction=@{} }
        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level; if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level]=0 }; $stats.EntriesByLevel[$level]++
            if ($entry.Caller.ScriptName) { $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName); if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module]=0 }; $stats.EntriesByModule[$module]++ }
            if ($entry.UserData.Action) { $action = $entry.UserData.Action; if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action]=0 }; $stats.EntriesByAction[$action]++ }
        }
        return $stats
    } catch { Write-Warning "Error getting log statistics: $_"; return [PSCustomObject]@{} }
}

# --- END OF ORIGINAL FILE: modules\logger\logger.psm1 ---


# --- START OF ORIGINAL FILE: modules\exceptions\exceptions.psm1 ---


# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
#
# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

try {
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException) {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
    }
} catch {
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}

# ------------------------------------------------------------------------------
# Error Handling Wrapper
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Component,
        
        [Parameter(Mandatory)]
        [string]$Context,
        
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock
    )
    
    try {
        return & $ScriptBlock
    }
    catch {
        Write-Log -Level Error -Message "$Context failed: $_" -Component $Component
        throw
    }
}

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

function _Identify-HeliosComponent {
    param([System.Management.Automation.ErrorRecord]$ErrorRecord)
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName ?? (Get-PSCallStack | Where-Object ScriptName | Select-Object -First 1).ScriptName
        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        $componentMap = @{
            'tui-engine' = 'TUI Engine'; 'navigation' = 'Navigation Service'; 'keybindings' = 'Keybinding Service'
            'task-service' = 'Task Service'; 'helios-components' = 'Helios UI Components'; 'helios-panels' = 'Helios UI Panels'
            'dashboard-screen' = 'Dashboard Screen'; 'task-screen' = 'Task Screen'; 'exceptions' = 'Exception Module'
            'logger' = 'Logger Module'; 'Start-PMCTerminal' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") { return $componentMap[$pattern] }
        }
        return "Unknown ($fileName)"
    } catch { return "Component Identification Failed" }
}

function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp = Get-Date -Format "o"; Summary = $ErrorRecord.Exception.Message; Type = $ErrorRecord.Exception.GetType().FullName
            Category = $ErrorRecord.CategoryInfo.Category.ToString(); TargetObject = $ErrorRecord.TargetObject
            ScriptName = $ErrorRecord.InvocationInfo.ScriptName; LineNumber = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line = $ErrorRecord.InvocationInfo.Line; PositionMessage = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace = $ErrorRecord.Exception.StackTrace; InnerExceptions = @(); AdditionalContext = $AdditionalContext
            SystemContext = @{
                ProcessId = $PID; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{ Message = $innerEx.Message; Type = $innerEx.GetType().FullName; StackTrace = $innerEx.StackTrace }
            $innerEx = $innerEx.InnerException
        }
        return $errorInfo
    } catch {
        return [PSCustomObject]@{ Timestamp = Get-Date -Format "o"; Summary = "CRITICAL: Error analysis failed."; OriginalError = $ErrorRecord.Exception.Message; AnalysisError = $_.Exception.Message; Type = "ErrorAnalysisFailure" }
    }
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$Component,
        [Parameter(Mandatory)] [string]$Context,
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [hashtable]$AdditionalData = @{}
    )

    if (-not $ScriptBlock) { throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null." }
    $Component = [string]::IsNullOrWhiteSpace($Component) ? "Unknown Component" : $Component
    $Context = [string]::IsNullOrWhiteSpace($Context) ? "Unknown Operation" : $Context

    try {
        return (& $ScriptBlock)
    }
    catch {
        $originalErrorRecord = $_
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = ($Component -ne "Unknown Component") ? $Component : $identifiedComponent

        $errorContext = @{ Operation = $Context }
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)" -Data $detailedError
        }

        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) { $script:ErrorHistory.RemoveAt(0) }

        $contextHashtable = @{
            Operation = $Context; Timestamp = $detailedError.Timestamp; LineNumber = $detailedError.LineNumber
            ScriptName = $detailedError.ScriptName ?? "Unknown"
        }
        
        foreach ($key in $AdditionalData.Keys) {
            $value = $AdditionalData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) { $contextHashtable[$key] = $value }
        }
        
        $heliosException = New-Object Helios.HeliosException($originalErrorRecord.Exception.Message, $finalComponent, $contextHashtable, $originalErrorRecord.Exception)
        throw $heliosException
    }
}

function Get-ErrorHistory {
    [CmdletBinding()]
    param([int]$Count = 25)
    
    $total = $script:ErrorHistory.Count
    if ($Count -ge $total) { return $script:ErrorHistory }
    $start = $total - $Count
    return $script:ErrorHistory.GetRange($start, $Count)
}

# --- END OF ORIGINAL FILE: modules\exceptions\exceptions.psm1 ---


# --- START OF ORIGINAL FILE: modules\models\models.psm1 ---


# ==============================================================================
# PMC Terminal v5 - Core Data Models
# Defines all core business entity classes with built-in validation.
# ==============================================================================



#region Enums

enum TaskStatus { Pending; InProgress; Completed; Cancelled }
enum TaskPriority { Low; Medium; High }
enum BillingType { Billable; NonBillable }

#endregion

#region Base Validation Class
class ValidationBase {
    static [void] ValidateNotEmpty([string]$value, [string]$parameterName) {
        if ([string]::IsNullOrWhiteSpace($value)) {
            throw [System.ArgumentException]::new("Parameter '$($parameterName)' cannot be null or empty.")
        }
    }
}
#endregion

#region Core Model Classes

class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()
    [string]$Title
    [string]$Description
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [string]$ProjectKey = "General"
    [string]$Category
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now
    [Nullable[datetime]]$DueDate
    [string[]]$Tags = @()
    [int]$Progress = 0
    [bool]$Completed = $false

    PmcTask() {}
    PmcTask([string]$title) { [ValidationBase]::ValidateNotEmpty($title, "Title"); $this.Title = $title }
    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title; $this.Description = $description; $this.Priority = $priority
        $this.ProjectKey = $projectKey; $this.Category = $projectKey
    }

    [void] Complete() {
        $this.Status = [TaskStatus]::Completed; $this.Completed = $true
        $this.Progress = 100; $this.UpdatedAt = [datetime]::Now
    }

    [void] UpdateProgress([int]$newProgress) {
        if ($newProgress -lt 0 -or $newProgress -gt 100) { throw "Progress must be between 0 and 100." }
        $this.Progress = $newProgress
        $this.Status = $newProgress -eq 100 ? [TaskStatus]::Completed : $newProgress -gt 0 ? [TaskStatus]::InProgress : [TaskStatus]::Pending
        $this.Completed = ($this.Status -eq [TaskStatus]::Completed)
        $this.UpdatedAt = [datetime]::Now
    }
    
    [string] GetDueDateString() { return $this.DueDate ? $this.DueDate.Value.ToString("yyyy-MM-dd") : "N/A" }

    [hashtable] ToLegacyFormat() {
        return @{
            id = $this.Id; title = $this.Title; description = $this.Description
            completed = $this.Completed; priority = $this.Priority.ToString().ToLower()
            project = $this.ProjectKey; due_date = $this.DueDate ? $this.GetDueDateString() : $null
            created_at = $this.CreatedAt.ToString("o"); updated_at = $this.UpdatedAt.ToString("o")
        }
    }

    static [PmcTask] FromLegacyFormat([hashtable]$legacyData) {
        $task = [PmcTask]::new()
        $task.Id = $legacyData.id ?? $task.Id
        $task.Title = $legacyData.title
        $task.Description = $legacyData.description
        if ($legacyData.priority) { try { $task.Priority = [TaskPriority]::$($legacyData.priority) } catch {} }
        $task.ProjectKey = $legacyData.project ?? $legacyData.Category ?? "General"
        $task.Category = $task.ProjectKey
        if ($legacyData.created_at) { try { $task.CreatedAt = [datetime]::Parse($legacyData.created_at) } catch {} }
        if ($legacyData.updated_at) { try { $task.UpdatedAt = [datetime]::Parse($legacyData.updated_at) } catch {} }
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") { try { $task.DueDate = [datetime]::Parse($legacyData.due_date) } catch {} }
        if ($legacyData.completed -is [bool] -and $legacyData.completed) { $task.Complete() }
        return $task
    }
}

class PmcProject : ValidationBase {
    [string]$Key = ([Guid]::NewGuid().ToString().Split('-')[0]).ToUpper()
    [string]$Name
    [string]$Client
    [BillingType]$BillingType = [BillingType]::NonBillable
    [double]$Rate = 0.0
    [double]$Budget = 0.0
    [bool]$Active = $true
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now

    PmcProject() {}
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key"); [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key; $this.Name = $name
    }

    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key; Name = $this.Name; Client = $this.Client
            BillingType = $this.BillingType.ToString(); Rate = $this.Rate; Budget = $this.Budget
            Active = $this.Active; CreatedAt = $this.CreatedAt.ToString("o")
        }
    }

    static [PmcProject] FromLegacyFormat([hashtable]$legacyData) {
        $project = [PmcProject]::new()
        $project.Key = $legacyData.Key ?? $project.Key
        $project.Name = $legacyData.Name
        $project.Client = $legacyData.Client
        if ($legacyData.Rate) { $project.Rate = [double]$legacyData.Rate }
        if ($legacyData.Budget) { $project.Budget = [double]$legacyData.Budget }
        if ($legacyData.Active -is [bool]) { $project.Active = $legacyData.Active }
        if ($legacyData.BillingType) { try { $project.BillingType = [BillingType]::$($legacyData.BillingType) } catch {} }
        if ($legacyData.CreatedAt) { try { $project.CreatedAt = [datetime]::Parse($legacyData.CreatedAt) } catch {} }
        $project.UpdatedAt = $project.CreatedAt
        return $project
    }
}

#endregion

# AI: Export everything including enums for PowerShell 7+

# --- END OF ORIGINAL FILE: modules\models\models.psm1 ---


# --- START OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---


# TUI Primitives v5.0 - NCurses Compositor Foundation
# Provides core TuiCell class and primitive drawing operations
# CORRECTED ORDERING: TuiAnsiHelper is defined BEFORE TuiCell to resolve parse-time dependency.



#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int] GetForegroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()]
    }

    static [int] GetBackgroundCode([ConsoleColor]$color) {
        return [TuiAnsiHelper]::ColorMap[$color.ToString()] + 10
    }

    static [string] Reset() {
        return "`e[0m"
    }

    static [string] Bold() {
        return "`e[1m"
    }

    static [string] Underline() {
        return "`e[4m"
    }

    static [string] Italic() {
        return "`e[3m"
    }
}
#endregion

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    [ConsoleColor] $ForegroundColor = [ConsoleColor]::White
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = ""
    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() {
        $this.Char = ' '
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Character constructor
    TuiCell([char]$char) {
        $this.Char = $char
        $this.ForegroundColor = [ConsoleColor]::White
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    # Full constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }

    # Style constructor
    TuiCell([char]$char, [ConsoleColor]$fg, [ConsoleColor]$bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }

    # Copy constructor
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.StyleFlags = $other.StyleFlags
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Create a styled copy
    [TuiCell] WithStyle([ConsoleColor]$fg, [ConsoleColor]$bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    # Create a character copy
    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # Blend this cell with another (higher Z-index wins)
    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return $other }
        if ($other.ZIndex -eq $this.ZIndex -and $other.Char -ne ' ') { return $other }
        return $this
    }

    # Check if this cell differs from another
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic)
    }

    # Generate ANSI escape sequence for this cell
    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Color codes - This now works because TuiAnsiHelper is known to the parser.
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append("`e[${fgCode};${bgCode}")
        
        # Style codes
        if ($this.Bold) { [void]$sb.Append(";1") }
        if ($this.Underline) { [void]$sb.Append(";4") }
        if ($this.Italic) { [void]$sb.Append(";3") }
        
        [void]$sb.Append("m").Append($this.Char)
        return $sb.ToString()
    }

    # Convert to legacy buffer format for compatibility
    [hashtable] ToLegacyFormat() {
        return @{
            Char = $this.Char
            FG = $this.ForegroundColor
            BG = $this.BackgroundColor
        }
    }

    # String representation
    [string] ToString() {
        return "TuiCell($($this.Char), $($this.ForegroundColor), $($this.BackgroundColor))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    # Constructor
    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0 -or $height -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }
        
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
    }

    # Clear buffer with default cell
    [void] Clear() {
        $this.Clear([TuiCell]::new())
    }

    # Clear buffer with specific cell
    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    # Get cell at position (safe)
    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {
            return [TuiCell]::new()  # Return empty cell for out-of-bounds
        }
        return $this.Cells[$y, $x]
    }

    # Set cell at position (safe)
    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height -and $null -ne $cell) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    # Write string to buffer
    [void] WriteString([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
    }

    # Blend another buffer onto this one at specified position
    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        if ($null -eq $other) { return }

        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
    }

    # Create a sub-buffer view (read-only)
    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        
        return $subBuffer
    }

    # Resize buffer (content is preserved where possible)
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) {
            throw [ArgumentException]::new("Buffer dimensions must be positive")
        }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()

        # Copy existing content
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }

        $this.IsDirty = $true
    }
}
#endregion

#region Drawing Primitives - High-Level Drawing Functions
function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    
    $cell = [TuiCell]::new(' ', $ForegroundColor, $BackgroundColor)
    $cell.Bold = $Bold
    $cell.Underline = $Underline
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0) {
            $charCell = [TuiCell]::new($cell)
            $charCell.Char = $char
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$BorderStyle = "Single",
        [ConsoleColor]$BorderColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }
    
    $borders = Get-TuiBorderChars -Style $BorderStyle
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Side borders and fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        $currentY = $Y + $i
        
        # Left border
        Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill
        $fillText = ' ' * ($Width - 2)
        Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -BackgroundColor $BackgroundColor
        
        # Right border
        Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $bottomLine -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
}

function Get-TuiBorderChars {
    param([string]$Style = "Single")
    
    $styles = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
        Thick = @{
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'
            Horizontal = '━'; Vertical = '┃'
        }
    }
    
    return $styles[$Style] ?? $styles.Single
}
#endregion

# Export all functions
#Export-ModuleMember -Function 'Write-TuiText', 'Write-TuiBox', 'Get-TuiBorderChars'

# --- END OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---


# --- START OF ORIGINAL FILE: modules\event-system\event-system.psm1 ---


# Event System Module
# Provides pub/sub event functionality for decoupled communication

# AI: FIX - Corrected relative paths for all dependencies.

$script:EventHandlers = @{}
$script:EventHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxEventHistory = 100

function Initialize-EventSystem {
    <# .SYNOPSIS Initializes the event system for the application #>
    Invoke-WithErrorHandling -Component "EventSystem.Initialize" -Context "Initializing event system" -ScriptBlock {
        $script:EventHandlers = @{}
        $script:EventHistory = [System.Collections.Generic.List[object]]::new()
        Write-Verbose "Event system initialized"
    }
}

function Publish-Event {
    <#
    .SYNOPSIS Publishes an event to all registered handlers
    .PARAMETER EventName The name of the event to publish
    .PARAMETER Data Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter()] [hashtable]$Data = @{}
    )
    Invoke-WithErrorHandling -Component "EventSystem.PublishEvent" -Context "Publishing event '$EventName'" -ScriptBlock {
        $eventRecord = @{ EventName = $EventName; Data = $Data; Timestamp = Get-Date }
        
        $script:EventHistory.Add($eventRecord)
        if ($script:EventHistory.Count -gt $script:MaxEventHistory) { $script:EventHistory.RemoveAt(0) }
        
        if ($script:EventHandlers.ContainsKey($EventName)) {
            foreach ($handler in $script:EventHandlers[$EventName]) {
                try {
                    $eventData = @{ EventName = $EventName; Data = $Data; Timestamp = $eventRecord.Timestamp }
                    & $handler.ScriptBlock -EventData $eventData
                } catch {
                    Write-Log -Level Warning -Message "Error in event handler for '$EventName' (ID: $($handler.HandlerId)): $_"
                }
            }
        }
        Write-Verbose "Published event: $EventName"
    } -AdditionalData @{ EventName = $EventName; EventData = $Data }
}

function Subscribe-Event {
    <#
    .SYNOPSIS Subscribes to an event with a handler
    .PARAMETER EventName The name of the event to subscribe to
    .PARAMETER Handler The script block to execute
    .PARAMETER HandlerId Optional unique identifier for the handler
    .PARAMETER Source Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter(Mandatory)] [scriptblock]$Handler,
        [Parameter()] [string]$HandlerId = [Guid]::NewGuid().ToString(),
        [Parameter()] [string]$Source
    )
    return Invoke-WithErrorHandling -Component "EventSystem.SubscribeEvent" -Context "Subscribing to event '$EventName'" -ScriptBlock {
        if (-not $script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers[$EventName] = @() }
        
        $handlerInfo = @{ HandlerId = $HandlerId; ScriptBlock = $Handler; SubscribedAt = Get-Date; Source = $Source }
        $script:EventHandlers[$EventName] += $handlerInfo
        
        Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
        return $HandlerId
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId; Source = $Source }
}

function Unsubscribe-Event {
    <#
    .SYNOPSIS Unsubscribes from an event
    .PARAMETER EventName The name of the event (optional if HandlerId is provided)
    .PARAMETER HandlerId The unique identifier of the handler to remove
    #>
    param(
        [Parameter()] [string]$EventName,
        [Parameter(Mandatory)] [string]$HandlerId
    )
    Invoke-WithErrorHandling -Component "EventSystem.UnsubscribeEvent" -Context "Unsubscribing from event '$EventName' (Handler: $HandlerId)" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($script:EventHandlers[$EventName].Count -eq 0) { $script:EventHandlers.Remove($EventName) }
                Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
            }
        } else {
            $found = $false
            foreach ($eventKey in @($script:EventHandlers.Keys)) {
                $handlers = $script:EventHandlers[$eventKey]
                $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($newHandlers.Count -lt $handlers.Count) {
                    $found = $true
                    $script:EventHandlers[$eventKey] = if ($newHandlers.Count -eq 0) { $script:EventHandlers.Remove($eventKey) } else { $newHandlers }
                    Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"; break
                }
            }
            if (-not $found) { Write-Warning "Handler ID not found: $HandlerId" }
        }
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId }
}

function Get-EventHandlers {
    <# .SYNOPSIS Gets all registered event handlers #>
    param([Parameter()] [string]$EventName)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHandlers" -Context "Getting event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { return $script:EventHandlers[$EventName] ?? @() }
        else { return $script:EventHandlers }
    }
}

function Clear-EventHandlers {
    <# .SYNOPSIS Clears all event handlers for a specific event or all events #>
    param([Parameter()] [string]$EventName)
    Invoke-WithErrorHandling -Component "EventSystem.ClearEventHandlers" -Context "Clearing event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { if ($script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers.Remove($EventName); Write-Verbose "Cleared handlers for event: $EventName" } } 
        else { $script:EventHandlers = @{}; Write-Verbose "Cleared all event handlers" }
    }
}

function Get-EventHistory {
    <# .SYNOPSIS Gets the event history #>
    param([Parameter()] [string]$EventName, [Parameter()] [int]$Last = 0)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHistory" -Context "Getting event history for '$EventName'" -ScriptBlock {
        $history = $script:EventHistory
        if ($EventName) { $history = $history | Where-Object { $_.EventName -eq $EventName } }
        if ($Last -gt 0) { $history = $history | Select-Object -Last $Last }
        return $history
    }
}

function Remove-ComponentEventHandlers {
    <# .SYNOPSIS Removes all event handlers associated with a specific component #>
    param([Parameter(Mandatory)] [string]$ComponentId)
    Invoke-WithErrorHandling -Component "EventSystem.RemoveComponentEventHandlers" -Context "Removing event handlers for component '$ComponentId'" -ScriptBlock {
        $removedCount = 0
        foreach ($eventName in @($script:EventHandlers.Keys)) {
            $initialCount = $script:EventHandlers[$eventName].Count
            $script:EventHandlers[$eventName] = @($script:EventHandlers[$eventName] | Where-Object { $_.Source -ne $ComponentId })
            $removedCount += $initialCount - $script:EventHandlers[$eventName].Count
            if ($script:EventHandlers[$eventName].Count -eq 0) { $script:EventHandlers.Remove($eventName) }
        }
        Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
    }
}

# --- END OF ORIGINAL FILE: modules\event-system\event-system.psm1 ---


# --- START OF ORIGINAL FILE: modules\theme-manager\theme-manager.psm1 ---


# FILE: modules/theme-manager.psm1
# PURPOSE: Provides theming and color management for the TUI.
#

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{ Name="Modern"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::White; Primary=[ConsoleColor]::White; Secondary=[ConsoleColor]::Gray; Accent=[ConsoleColor]::Cyan; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::Yellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Blue; Header=[ConsoleColor]::Cyan; Border=[ConsoleColor]::DarkGray; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::Cyan; Subtle=[ConsoleColor]::DarkGray; Keyword=[ConsoleColor]::Blue; String=[ConsoleColor]::Green; Number=[ConsoleColor]::Magenta; Comment=[ConsoleColor]::DarkGray } }
    Dark   = @{ Name="Dark"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::Gray; Primary=[ConsoleColor]::Gray; Secondary=[ConsoleColor]::DarkGray; Accent=[ConsoleColor]::DarkCyan; Success=[ConsoleColor]::DarkGreen; Warning=[ConsoleColor]::DarkYellow; Error=[ConsoleColor]::DarkRed; Info=[ConsoleColor]::DarkBlue; Header=[ConsoleColor]::DarkCyan; Border=[ConsoleColor]::DarkGray; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::Cyan; Subtle=[ConsoleColor]::DarkGray; Keyword=[ConsoleColor]::DarkBlue; String=[ConsoleColor]::DarkGreen; Number=[ConsoleColor]::DarkMagenta; Comment=[ConsoleColor]::DarkGray } }
    Light  = @{ Name="Light"; Colors=@{ Background=[ConsoleColor]::White; Foreground=[ConsoleColor]::Black; Primary=[ConsoleColor]::Black; Secondary=[ConsoleColor]::DarkGray; Accent=[ConsoleColor]::Blue; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::DarkYellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Blue; Header=[ConsoleColor]::Blue; Border=[ConsoleColor]::Gray; Selection=[ConsoleColor]::Cyan; Highlight=[ConsoleColor]::Yellow; Subtle=[ConsoleColor]::Gray; Keyword=[ConsoleColor]::Blue; String=[ConsoleColor]::Green; Number=[ConsoleColor]::Magenta; Comment=[ConsoleColor]::Gray } }
    Retro  = @{ Name="Retro"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::Green; Primary=[ConsoleColor]::Green; Secondary=[ConsoleColor]::DarkGreen; Accent=[ConsoleColor]::Yellow; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::Yellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Cyan; Header=[ConsoleColor]::Yellow; Border=[ConsoleColor]::DarkGreen; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::White; Subtle=[ConsoleColor]::DarkGreen; Keyword=[ConsoleColor]::Yellow; String=[ConsoleColor]::Cyan; Number=[ConsoleColor]::White; Comment=[ConsoleColor]::DarkGreen } }
}

function Initialize-ThemeManager {
    Invoke-WithErrorHandling -Component "ThemeManager.Initialize" -Context "Initializing theme service" -ScriptBlock {
        Set-TuiTheme -ThemeName "Modern"
        Write-Log -Level Info -Message "Theme manager initialized."
    }
}

function Set-TuiTheme {
    param([Parameter(Mandatory)] [string]$ThemeName)
    Invoke-WithErrorHandling -Component "ThemeManager.SetTheme" -Context "Setting active TUI theme" -AdditionalData @{ ThemeName = $ThemeName } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $script:CurrentTheme = $script:Themes[$ThemeName]
            if ($Host.UI.RawUI) {
                $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
                $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
            }
            Write-Log -Level Debug -Message "Theme set to: $ThemeName"
            Publish-Event -EventName "Theme.Changed" -Data @{ ThemeName = $ThemeName; Theme = $script:CurrentTheme }
        } else {
            Write-Log -Level Warning -Message "Theme not found: $ThemeName"
        }
    }
}

function Get-ThemeColor {
    param([Parameter(Mandatory)] [string]$ColorName, [ConsoleColor]$Default = [ConsoleColor]::Gray)
    try {
        return $script:CurrentTheme.Colors[$ColorName] ?? $Default
    } catch {
        Write-Log -Level Warning -Message "Error in Get-ThemeColor for '$ColorName'. Returning default. Error: $_"
        return $Default
    }
}

function Get-TuiTheme {
    Invoke-WithErrorHandling -Component "ThemeManager.GetTheme" -Context "Retrieving current theme" -ScriptBlock {
        return $script:CurrentTheme
    }
}

function Get-AvailableThemes {
    Invoke-WithErrorHandling -Component "ThemeManager.GetAvailableThemes" -Context "Retrieving available themes" -ScriptBlock {
        return $script:Themes.Keys | Sort-Object
    }
}

function New-TuiTheme {
    param([Parameter(Mandatory)] [string]$Name, [string]$BaseTheme = "Modern", [hashtable]$Colors = @{})
    Invoke-WithErrorHandling -Component "ThemeManager.NewTheme" -Context "Creating new theme" -AdditionalData @{ ThemeName = $Name } -ScriptBlock {
        $newTheme = @{ Name = $Name; Colors = @{} }
        if ($script:Themes.ContainsKey($BaseTheme)) { $newTheme.Colors = $script:Themes[$BaseTheme].Colors.Clone() }
        foreach ($colorKey in $Colors.Keys) { $newTheme.Colors[$colorKey] = $Colors[$colorKey] }
        $script:Themes[$Name] = $newTheme
        Write-Log -Level Info -Message "Created new theme: $Name"
        return $newTheme
    }
}

function Export-TuiTheme {
    param([Parameter(Mandatory)] [string]$ThemeName, [Parameter(Mandatory)] [string]$Path)
    Invoke-WithErrorHandling -Component "ThemeManager.ExportTheme" -Context "Exporting theme to JSON" -AdditionalData @{ ThemeName = $ThemeName; FilePath = $Path } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $theme = $script:Themes[$ThemeName]
            $exportTheme = @{ Name = $theme.Name; Colors = @{} }
            foreach ($colorKey in $theme.Colors.Keys) { $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString() }
            $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
            Write-Log -Level Info -Message "Exported theme '$ThemeName' to: $Path"
        } else {
            Write-Log -Level Warning -Message "Cannot export theme. Theme not found: $ThemeName"
        }
    }
}

function Import-TuiTheme {
    param([Parameter(Mandatory)] [string]$Path)
    Invoke-WithErrorHandling -Component "ThemeManager.ImportTheme" -Context "Importing theme from JSON" -AdditionalData @{ FilePath = $Path } -ScriptBlock {
        if (Test-Path $Path) {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
            $theme = @{ Name = $importedTheme.Name; Colors = @{} }
            foreach ($colorKey in $importedTheme.Colors.Keys) {
                $theme.Colors[$colorKey] = [System.Enum]::Parse([System.ConsoleColor], $importedTheme.Colors[$colorKey], $true)
            }
            $script:Themes[$theme.Name] = $theme
            Write-Log -Level Info -Message "Imported theme: $($theme.Name)"
            return $theme
        } else {
            Write-Log -Level Warning -Message "Cannot import theme. File not found: $Path"
            return $null
        }
    }
}

# --- END OF ORIGINAL FILE: modules\theme-manager\theme-manager.psm1 ---


# --- START OF ORIGINAL FILE: components\ui-classes\ui-classes.psm1 ---


# ==============================================================================
# PMC Terminal v5 - Base UI Class Hierarchy
# Provides the foundational classes for all UI components with NCurses compositor support.
# ==============================================================================

# --- Enhanced UI Element with Buffer Management ---
class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [bool] $IsFocused = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer = $null
    [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{}

    # Constructor
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with name
    UIElement([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [ArgumentException]::new("UIElement name cannot be null or empty.")
        }
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with position and size
    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Buffer")
    }

    # Get absolute screen position
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # Add child component
    [void] AddChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
        }
    }

    # Remove child component
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
            $this.RequestRedraw()
        }
    }

    # Request redraw for this component and parents
    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
    }

    # Resize the component and its buffer
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Resize($newWidth, $newHeight)
        }
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # Move the component
    [void] Move([int]$newX, [int]$newY) {
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
    }

    # Check if point is within component bounds
    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge $this.X -and $x -lt ($this.X + $this.Width) -and 
                $y -ge $this.Y -and $y -lt ($this.Y + $this.Height))
    }

    # Get child at specific point (relative to this component)
    [UIElement] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $this.X, $y - $this.Y)) {
                return $child
            }
        }
        return $null
    }

    # Virtual methods for subclasses to override
    [void] OnRender() {
        # Default implementation - clear buffer
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Override in subclasses
    }

    [void] OnMove([int]$newX, [int]$newY) {
        # Override in subclasses
    }

    [void] OnFocus() {
        # Override in subclasses
    }

    [void] OnBlur() {
        # Override in subclasses
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Override in subclasses - return true if input was handled
        return $false
    }

    # Main render method with error handling - calls _RenderContent and renders children
    [void] Render() {
        Invoke-WithErrorHandling -Component $this.Name -Context "Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            $this._RenderContent()
        } -AdditionalData @{ ComponentType = $this.GetType().Name }
    }

    # Protected render implementation - can be overridden by subclasses
    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }

        # Render this component to its private buffer
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer) {
                $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }
            
            $this.OnRender()
            $this._needs_redraw = $false
        }

        # Render children to their buffers, then composite onto parent
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
    }

    # Get the final rendered buffer
    [TuiBuffer] GetBuffer() {
        return $this._private_buffer
    }
    
    [string] ToString() {
        return "$($this.GetType().Name): $($this.Name)"
    }
}

# --- Base Component (can contain children) ---
class Component : UIElement {
    Component([string]$name) : base($name) {
    }

    # AI: Default implementation renders all visible children to buffer
    hidden [void] _RenderContent() {
        # Call parent implementation for buffer management
        ([UIElement]$this)._RenderContent()
    }
}

# Note: Panel class is now defined in layout\panels-class.psm1

# --- Base Screen (top-level container) ---
class Screen : UIElement {
    [hashtable]$Services
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[UIElement]]$Panels
    hidden [System.Collections.Generic.Dictionary[string, string]]$EventSubscriptions

    Screen([string]$name, [hashtable]$services) : base($name) {
        if (-not $services) { throw [ArgumentNullException]::new("services") }
        
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
    }
    
    [void] Initialize() { }
    [void] OnEnter() { }
    [void] OnExit() { }
    [void] OnResume() { }
    [void] HandleInput([System.ConsoleKeyInfo]$key) { }

    [void] Cleanup() {
        foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -SubscriberId $kvp.Value
            }
            catch {
                Write-Log -Level Warning -Message "Failed to unregister event '$($kvp.Key)' for screen '$($this.Name)'."
            }
        }
        $this.EventSubscriptions.Clear()
        $this.Panels.Clear()
        Write-Log -Level Debug -Message "Cleaned up screen: $($this.Name)"
    }
    
    [void] AddPanel([UIElement]$panel) {
        if (-not $panel) { throw [ArgumentNullException]::new("panel") }
        $this.Panels.Add($panel)
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($eventName)) { throw [ArgumentException]::new("Event name cannot be null or empty.") }
        if (-not $action) { throw [ArgumentNullException]::new("action") }
        
        # AI: Fixed parameter name from -Action to -Handler to match event-system.psm1 function signature
        $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
        $this.EventSubscriptions[$eventName] = $subscriptionId
    }
    
    # AI: Override _RenderContent to render all panels to buffer
    hidden [void] _RenderContent() {
        # Call base implementation for buffer management
        ([UIElement]$this)._RenderContent()
        
        # Render all panels in the screen to the back-buffer
        foreach ($panel in $this.Panels) {
            if ($panel.Visible) {
                $panel.Render()
            }
        }
    }
}

# --- END OF ORIGINAL FILE: components\ui-classes\ui-classes.psm1 ---


# --- START OF ORIGINAL FILE: layout\panels-class\panels-class.psm1 ---


# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

# Import TUI primitives and base classes
#region Panel Class - Basic Layout Container
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $this.ContentX
            $child.Y = $currentY
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $currentX
            $child.Y = $this.ContentY
            
            # Last child gets remaining space
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        # Calculate grid dimensions
        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            # Adjust size for last column/row
            $width = if ($col -eq ($cols - 1)) { 
                $this.ContentX + $this.ContentWidth - $x 
            } else { 
                $cellWidth 
            }
            $height = if ($row -eq ($rows - 1)) { 
                $this.ContentY + $this.ContentHeight - $y 
            } else { 
                $cellHeight 
            }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    # Set border style and update content bounds
    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    # Enable/disable border
    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    # Set title
    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    # Check if point is within content area
    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    # Get content bounds as hashtable
    [hashtable] GetContentBounds() {
        return @{
            X = $this.ContentX
            Y = $this.ContentY
            Width = $this.ContentWidth
            Height = $this.ContentHeight
        }
    }
    
    # Alias for compatibility with migrated components
    [hashtable] GetContentArea() {
        return $this.GetContentBounds()
    }
    
    # Write text to buffer at specified position
    [void] WriteToBuffer([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        if ($null -eq $this._private_buffer) { return }
        Write-TuiText -Buffer $this._private_buffer -X $x -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
    }
    
    # Draw a box to buffer
    [void] DrawBoxToBuffer([int]$x, [int]$y, [int]$width, [int]$height, [ConsoleColor]$borderColor, [ConsoleColor]$bgColor) {
        if ($null -eq $this._private_buffer) { return }
        Write-TuiBox -Buffer $this._private_buffer -X $x -Y $y -Width $width -Height $height `
            -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
    }

    # Clear content area only
    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return }

        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    # Main render implementation - override from UIElement
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }

        # Clear entire buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this._private_buffer.Clear($bgCell)

        # Draw border if enabled
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }

        # Fill content area
        $this.ClearContent()
    }

    # Handle focus for focusable panels
    [void] OnFocus() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Cyan
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            $this.BorderColor = [ConsoleColor]::Gray
            $this.RequestRedraw()
        }
    }

    # Find first focusable child
    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    # Get all focusable children (recursive)
    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        
        return $focusable
    }

    # Basic input handling - delegate to focused child
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # If this panel can focus and is focused, handle some basic navigation
        if ($this.CanFocus -and $this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
            }
        }

        # Delegate to children
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }

        return $false
    }

    # String representation
    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}
#endregion

#region Specialized Panel Types

# Scrollable Panel - supports content larger than visible area
class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    # Constructor
    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    # Set virtual content size
    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        
        # Create virtual buffer if needed
        if ($width -gt 0 -and $height -gt 0) {
            $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        
        $this.RequestRedraw()
    }

    # Scroll to position
    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        
        $this.RequestRedraw()
    }

    # Scroll by delta
    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    # Handle scrolling input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }

        return ([Panel]$this).HandleInput($keyInfo)
    }

    # Render with scrolling support
    [void] OnRender() {
        # Render base panel
        ([Panel]$this).OnRender()

        # Render virtual content if available
        if ($null -ne $this._virtual_buffer) {
            # Create a sub-buffer view of the virtual content
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            
            # Blend visible content onto our buffer
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }

        # Draw scrollbars if enabled and needed
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    # Draw scrollbar indicators
    [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return }

        # Vertical scrollbar
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
        }

        # Horizontal scrollbar
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, [ConsoleColor]::Gray, $this.BackgroundColor)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    # Get virtual content buffer for external drawing
    [TuiBuffer] GetVirtualBuffer() {
        return $this._virtual_buffer
    }
}

# Group Panel - collapsible panel with header
class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    # Toggle collapsed state
    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)  # Just header + border
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        
        # Update child visibility
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        
        $this.RequestRedraw()
    }

    # Handle collapse/expand input
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }

        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        
        return $false
    }

    # Render with collapse indicator
    [void] OnRender() {
        ([Panel]$this).OnRender()

        # Draw collapse/expand indicator in title area
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            $this._private_buffer.SetCell(2, 0, $indicatorCell)
        }
    }
}
#endregion

# --- END OF ORIGINAL FILE: layout\panels-class\panels-class.psm1 ---


# --- START OF ORIGINAL FILE: components\navigation-class\navigation-class.psm1 ---


# Navigation Component Classes Module for PMC Terminal v5
# Phase 1 Migration Complete - Proper UIElement inheritance and Panel integration

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        $display = "[$($this.Key)] "
        
        if ($this.Enabled) {
            $display += $this.Label
        }
        else {
            $display += "$($this.Label) (Disabled)"
        }
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            $display += " - $($this.Description)"
        }
        
        return $display
    }
}

# AI: REFACTORED - NavigationMenu now properly inherits from UIElement
class NavigationMenu : UIElement {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    [bool] $IsFocused = $false
    
    NavigationMenu([string]$name) : base() {
        $this.Name = $name
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.SelectedIndex = 0
        $this.Width = 30
        $this.Height = 10
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base() {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Name = $name
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.SelectedIndex = 0
        $this.Width = 30
        $this.Height = 10
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({param($x) $x.Key -eq $item.Key})) { 
            throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") 
        }
        $this.Items.Add($item)
        $this.RequestRedraw()
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { 
            [void]$this.Items.Remove($item)
            $this.RequestRedraw()
        }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({param($x) $x.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { 
                $item.Execute() 
            }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
        $this.RequestRedraw()
    }

    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", { 
                    $this.Services.Navigation.GoTo("/tasks", @{mode="new"}) 
                }))
                $this.AddItem([NavigationItem]::new("P", "Projects", { 
                    $this.Services.Navigation.GoTo("/projects", @{}) 
                }))
                $this.AddItem([NavigationItem]::new("S", "Settings", { 
                    $this.Services.Navigation.GoTo("/settings", @{}) 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("Q", "Quit", { 
                    $this.Services.Navigation.RequestExit() 
                }))
            }
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", { 
                    Write-Host "New task not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("E", "Edit", { 
                    Write-Host "Edit not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("D", "Delete", { 
                    Write-Host "Delete not implemented" 
                }))
                $this.AddItem([NavigationItem]::new("F", "Filter", { 
                    Write-Host "Filter not implemented" 
                }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
            }
            default {
                $this.AddItem([NavigationItem]::new("B", "Back", { 
                    $this.Services.Navigation.PopScreen() 
                }))
                $this.AddItem([NavigationItem]::new("H", "Home", { 
                    $this.Services.Navigation.GoTo("/dashboard", @{}) 
                }))
            }
        }
    }
    
    # AI: REFACTORED - Now uses Panel buffer integration
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear our buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Get visible items
            $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
            if ($visibleItems.Count -eq 0) { return }
            
            if ($this.Orientation -eq "Horizontal") { 
                $this.RenderHorizontal($visibleItems) 
            }
            else { 
                $this.RenderVertical($visibleItems) 
            }
            
        } catch { 
            Write-Log -Level Error -Message "NavigationMenu render error for '$($this.Name)': $_" 
        }
    }
    
    hidden [void] RenderHorizontal([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) { return }
        
        $menuText = ""
        $isFirst = $true
        foreach ($item in $items) {
            if ($null -eq $item) { continue }
            
            if (-not $isFirst) {
                $menuText += $this.Separator
            }
            $menuText += "[$($item.Key)] $($item.Label)"
            $isFirst = $false
        }
        
        # Write to our private buffer
        $this._private_buffer.WriteString(0, 0, $menuText, [ConsoleColor]::White, [ConsoleColor]::Black)
    }
    
    hidden [void] RenderVertical([object[]]$items) {
        if ($null -eq $items -or $items.Count -eq 0) { return }
        
        # Ensure SelectedIndex is within bounds
        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $items.Count) {
            $this.SelectedIndex = 0
        }
        
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($null -eq $item) { continue }
            
            $prefix = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { " > " } else { "   " }
            $menuText = "$prefix[$($item.Key)] $($item.Label)"
            
            # Pad text to clear the full line width
            if ($menuText.Length -lt $this.Width) {
                $menuText = $menuText.PadRight($this.Width)
            }
            
            $fg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                [ConsoleColor]::Black 
            } else { 
                [ConsoleColor]::White 
            }
            $bg = if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") { 
                [ConsoleColor]::White 
            } else { 
                [ConsoleColor]::Black 
            }
            
            # Write to our private buffer
            $this._private_buffer.WriteString(0, $i, $menuText, $fg, $bg)
        }
    }
    
    # AI: REFACTORED - Updated input handling for new architecture
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            $visibleItems = @($this.Items | Where-Object { $null -ne $_ -and $_.Visible })
            if ($visibleItems.Count -eq 0) { return $false }
            
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt ($visibleItems.Count - 1)) {
                        $this.SelectedIndex++
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $visibleItems.Count) {
                        $selectedItem = $visibleItems[$this.SelectedIndex]
                        if ($selectedItem.Enabled -and $selectedItem.Key -ne "-") {
                            $selectedItem.Execute()
                        }
                    }
                    return $true
                }
                default {
                    # Check for direct key matches
                    $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
                    $matchingItem = $this.Items.Find({param($x) $x.Key -eq $keyChar})
                    if ($matchingItem -and $matchingItem.Enabled -and $matchingItem.Visible) {
                        $matchingItem.Execute()
                        return $true
                    }
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "NavigationMenu input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    # AI: NEW - Focus management
    [void] OnFocus() {
        $this.IsFocused = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        $this.IsFocused = $false
        $this.RequestRedraw()
    }
}

# --- END OF ORIGINAL FILE: components\navigation-class\navigation-class.psm1 ---


# --- START OF ORIGINAL FILE: components\tui-components\tui-components.psm1 ---


####\components\tui-components.psm1
# TUI Component Library - Phase 1 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

#region Core UI Components

# AI: REFACTORED - LabelComponent now properly inherits from UIElement
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor
    
    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $this.Text -ForegroundColor $fg

        } catch { 
            Write-Log -Level Error -Message "Label render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false # Labels don't handle input
    }
}

# AI: REFACTORED - ButtonComponent updated for buffer-based rendering
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick
    
    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
        $this.Text = "Button"
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer, not the parent's.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))

            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            $bgColor = $this.IsPressed ? [ConsoleColor]::Yellow : [ConsoleColor]::Black
            $fgColor = $this.IsPressed ? [ConsoleColor]::Black : $borderColor
            
            # Render border to own buffer
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
            
            # Render text centered in own buffer
            $textX = [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = [Math]::Floor(($this.Height - 1) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -ForegroundColor $fgColor -BackgroundColor $bgColor

        } catch { 
            Write-Log -Level Error -Message "Button render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.IsPressed = $true
                $this.RequestRedraw()
                
                if ($this.OnClick) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock { & $this.OnClick }
                }
                
                Start-Sleep -Milliseconds 50 # Visual feedback for press
                $this.IsPressed = $false
                $this.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "Button input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: REFACTORED - TextBoxComponent with buffer-based rendering
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.MaxLength = 100
    }
    
    [void] OnRender() {
        # AI: REFACTORED - Renders to its own private buffer.
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)

            # Display text or placeholder
            $displayText = $this.Text ?? ""
            $textColor = [ConsoleColor]::White
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = $this.Placeholder ?? "" 
                $textColor = [ConsoleColor]::DarkGray
            }
            
            $maxDisplayLength = $this.Width - 2
            if ($displayText.Length > $maxDisplayLength) { 
                $displayText = $displayText.Substring(0, $maxDisplayLength) 
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayText -ForegroundColor $textColor
            
            # Draw cursor if focused
            if ($this.IsFocused -and ($this.CursorPosition -le $displayText.Length)) {
                $cursorX = 1 + $this.CursorPosition
                # Only draw cursor if it's within the visible area
                # AI: FIX - Changed '<' to '-lt' to avoid PowerShell parser ambiguity
                if ($cursorX -lt ($this.Width - 1)) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" -ForegroundColor [ConsoleColor]::Yellow
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "TextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition ?? 0
            $originalText = $currentText
            $handled = $true
            
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $currentText = $currentText.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    } 
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $currentText.Length) { 
                        $currentText = $currentText.Remove($cursorPos, 1) 
                    } 
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- } 
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $currentText.Length) { $cursorPos++ } 
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $currentText.Length }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) { 
                        $currentText = $currentText.Insert($cursorPos, $key.KeyChar)
                        $cursorPos++ 
                    } else { 
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                if ($currentText -ne $originalText -or $cursorPos -ne $this.CursorPosition) {
                    $this.Text = $currentText
                    $this.CursorPosition = $cursorPos
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $currentText 
                        }
                    }
                    $this.RequestRedraw()
                }
            }
            return $handled
        } catch { 
            Write-Log -Level Error -Message "TextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
}

# AI: NEW - CheckBoxComponent converted from functional to class-based
class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange
    
    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $checkbox = $this.Checked ? "[X]" : "[ ]"
            $displayText = "$checkbox $($this.Text)"
            
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $displayText -ForegroundColor $fg
            
        } catch { 
            Write-Log -Level Error -Message "CheckBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Checked = -not $this.Checked
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                        & $this.OnChange -NewValue $this.Checked 
                    } 
                }
                $this.RequestRedraw()
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "CheckBox input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

# AI: NEW - RadioButtonComponent converted from functional to class-based
class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange
    
    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $fg = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::White
            $radio = $this.Selected ? "(●)" : "( )"
            $displayText = "$radio $($this.Text)"

            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $displayText -ForegroundColor $fg

        } catch { 
            Write-Log -Level Error -Message "RadioButton render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if (-not $this.Selected) {
                    # AI: Unselect other radio buttons in the same group
                    if ($this.Parent -and $this.GroupName) {
                        $siblingRadios = $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        }
                        foreach ($radio in $siblingRadios) {
                            $radio.Selected = $false
                        }
                    }
                    
                    $this.Selected = $true
                    if ($this.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { 
                            & $this.OnChange -NewValue $this.Selected 
                        } 
                    }
                    $this.Parent.RequestRedraw()
                }
                return $true
            }
        } catch { 
            Write-Log -Level Error -Message "RadioButton input error for '$($this.Name)': $_" 
        }
        return $false
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $label = [LabelComponent]::new($name)
    
    $label.X = $Props.X ?? $label.X
    $label.Y = $Props.Y ?? $label.Y
    $label.Width = $Props.Width ?? $label.Width
    $label.Height = $Props.Height ?? $label.Height
    $label.Visible = $Props.Visible ?? $label.Visible
    $label.ZIndex = $Props.ZIndex ?? $label.ZIndex
    $label.Text = $Props.Text ?? $label.Text
    $label.ForegroundColor = $Props.ForegroundColor ?? $label.ForegroundColor
    
    return $label
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $button = [ButtonComponent]::new($name)
    
    $button.X = $Props.X ?? $button.X
    $button.Y = $Props.Y ?? $button.Y
    $button.Width = $Props.Width ?? $button.Width
    $button.Height = $Props.Height ?? $button.Height
    $button.Visible = $Props.Visible ?? $button.Visible
    $button.ZIndex = $Props.ZIndex ?? $button.ZIndex
    $button.Text = $Props.Text ?? $button.Text
    $button.OnClick = $Props.OnClick ?? $button.OnClick
    
    return $button
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [TextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Text = $Props.Text ?? $textBox.Text
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLength = $Props.MaxLength ?? $textBox.MaxLength
    $textBox.CursorPosition = $Props.CursorPosition ?? $textBox.CursorPosition
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    return $textBox
}

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $checkBox = [CheckBoxComponent]::new($name)
    
    $checkBox.X = $Props.X ?? $checkBox.X
    $checkBox.Y = $Props.Y ?? $checkBox.Y
    $checkBox.Width = $Props.Width ?? $checkBox.Width
    $checkBox.Height = $Props.Height ?? $checkBox.Height
    $checkBox.Visible = $Props.Visible ?? $checkBox.Visible
    $checkBox.ZIndex = $Props.ZIndex ?? $checkBox.ZIndex
    $checkBox.Text = $Props.Text ?? $checkBox.Text
    $checkBox.Checked = $Props.Checked ?? $checkBox.Checked
    $checkBox.OnChange = $Props.OnChange ?? $checkBox.OnChange
    
    return $checkBox
}

function New-TuiRadioButton {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $radioButton = [RadioButtonComponent]::new($name)
    
    $radioButton.X = $Props.X ?? $radioButton.X
    $radioButton.Y = $Props.Y ?? $radioButton.Y
    $radioButton.Width = $Props.Width ?? $radioButton.Width
    $radioButton.Height = $Props.Height ?? $radioButton.Height
    $radioButton.Visible = $Props.Visible ?? $radioButton.Visible
    $radioButton.ZIndex = $Props.ZIndex ?? $radioButton.ZIndex
    $radioButton.Text = $Props.Text ?? $radioButton.Text
    $radioButton.Selected = $Props.Selected ?? $radioButton.Selected
    $radioButton.GroupName = $Props.GroupName ?? $radioButton.GroupName
    $radioButton.OnChange = $Props.OnChange ?? $radioButton.OnChange
    
    return $radioButton
}

#endregion

# --- END OF ORIGINAL FILE: components\tui-components\tui-components.psm1 ---


# --- START OF ORIGINAL FILE: components\advanced-data-components\advanced-data-components.psm1 ---


# Advanced Data Components Module for PMC Terminal v5
# Phase 1 Migration Complete - Enhanced data display with proper UIElement inheritance

#region Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

# AI: REFACTORED - Table now properly inherits from UIElement
class Table : UIElement {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    [bool]$IsFocused = $false
    
    Table([string]$name) : base() {
        $this.Name = $name
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        $this.Data = @()
        $this.SelectedIndex = 0
        $this.IsFocusable = $true
        $this.Width = 60
        $this.Height = 15
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
        $this.RequestRedraw()
    }
    
    [void] SetData([object[]]$data) {
        $this.Data = if ($null -eq $data) { @() } else { @($data) }
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -ge $dataCount) {
            $this.SelectedIndex = [Math]::Max(0, $dataCount - 1)
        }
        $this.RequestRedraw()
    }
    
    [void] SelectNext() {
        $dataCount = if ($null -eq $this.Data) { 0 } elseif ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        if ($this.SelectedIndex -lt ($dataCount - 1)) {
            $this.SelectedIndex++
            $this.RequestRedraw()
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
            $this.RequestRedraw()
        }
    }
    
    [object] GetSelectedItem() {
        if ($null -eq $this.Data) { return $null }
        
        $dataCount = if ($this.Data -is [array]) { $this.Data.Count } else { 1 }
        
        if ($dataCount -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $dataCount) {
            return if ($this.Data -is [array]) { $this.Data[$this.SelectedIndex] } else { $this.Data }
        }
        return $null
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            # Draw border if enabled
            if ($this.ShowBorder) {
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                    -BorderStyle "Single" -BorderColor ([ConsoleColor]::Gray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            $currentY = if ($this.ShowBorder) { 1 } else { 0 }
            $contentWidth = if ($this.ShowBorder) { $this.Width - 2 } else { $this.Width }
            $renderX = if ($this.ShowBorder) { 1 } else { 0 }
            
            # Header
            if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
                $headerLine = ""
                foreach ($col in $this.Columns) {
                    $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                    $headerLine += $headerText + " "
                }
                
                if ($headerLine.TrimEnd().Length -gt $contentWidth) {
                    $headerLine = $headerLine.Substring(0, $contentWidth)
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $headerLine.TrimEnd() `
                    -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
                $currentY++
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY `
                    -Text ("-" * [Math]::Min($headerLine.TrimEnd().Length, $contentWidth)) `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
                $currentY++
            }
            
            # Data rows
            $dataToRender = @()
            if ($null -ne $this.Data) {
                $dataToRender = if ($this.Data -is [array]) { $this.Data } else { @($this.Data) }
            }
            
            for ($i = 0; $i -lt $dataToRender.Count; $i++) {
                $row = $dataToRender[$i]
                if ($null -eq $row) { continue }
                
                $rowLine = ""
                $isSelected = ($i -eq $this.SelectedIndex)
                
                foreach ($col in $this.Columns) {
                    $cellValue = ""
                    if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                        $cellValue = $row[$col.Key]?.ToString() ?? ""
                    } elseif ($row.PSObject.Properties[$col.Key]) {
                        $cellValue = $row.($col.Key)?.ToString() ?? ""
                    }
                    
                    $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                    $rowLine += $cellText + " "
                }
                
                $finalLine = $rowLine.TrimEnd()
                if ($isSelected) {
                    $finalLine = "> $finalLine"
                } else {
                    $finalLine = "  $finalLine"
                }
                
                $fg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
                $bg = if ($isSelected) { [ConsoleColor]::White } else { [ConsoleColor]::Black }
                
                if ($finalLine.Length -gt $contentWidth) {
                    $finalLine = $finalLine.Substring(0, $contentWidth)
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text $finalLine `
                    -ForegroundColor $fg -BackgroundColor $bg
                $currentY++
                
                # Don't exceed available space
                if ($currentY -ge ($this.Height - 1)) { break }
            }
            
            if ($dataToRender.Count -eq 0) {
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text "  No data to display" `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
        } catch { 
            Write-Log -Level Error -Message "Table render error for '$($this.Name)': $_" 
        }
    }
    
    # AI: REFACTORED - Updated input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        try {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this.SelectPrevious()
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $this.SelectNext()
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $selectedItem = $this.GetSelectedItem()
                    if ($null -ne $selectedItem) {
                        # Trigger selection event or action
                        Write-Log -Level Debug -Message "Table item selected: $($selectedItem)"
                    }
                    return $true
                }
            }
        } catch { 
            Write-Log -Level Error -Message "Table input error for '$($this.Name)': $_" 
        }
        
        return $false
    }
    
    [void] OnFocus() {
        $this.IsFocused = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        $this.IsFocused = $false
        $this.RequestRedraw()
    }
}

# AI: DELETED - Obsolete DataTableComponent class was here and has been removed.

#endregion

#region Factory Functions

function New-TuiTable {
    # AI: REFACTORED - Creates a proper Table instance
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "Table_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $table = [Table]::new($name)
    
    if ($Props.Columns) {
        $table.SetColumns($Props.Columns)
    }
    if ($Props.Data) {
        $table.SetData($Props.Data)
    }

    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader
    $table.Visible = $Props.Visible ?? $table.Visible
    
    return $table
}

#endregion

# --- END OF ORIGINAL FILE: components\advanced-data-components\advanced-data-components.psm1 ---


# --- START OF ORIGINAL FILE: components\advanced-input-components\advanced-input-components.psm1 ---


# Advanced Input Components - Phase 2 Migration Complete
# All components now inherit from UIElement and use buffer-based rendering

#region Advanced Input Classes

# AI: REFACTORED - MultilineTextBox converted from functional to class-based
class MultilineTextBoxComponent : UIElement {
    [string[]]$Lines = @("")
    [string]$Placeholder = "Enter text..."
    [int]$MaxLines = 10
    [int]$MaxLineLength = 100
    [int]$CurrentLine = 0
    [int]$CursorPosition = 0
    [int]$ScrollOffsetY = 0
    [bool]$WordWrap = $true
    [scriptblock]$OnChange
    
    MultilineTextBoxComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 40
        $this.Height = 10
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Calculate visible area
            $textAreaHeight = $this.Height - 2
            $textAreaWidth = $this.Width - 2
            $startLine = $this.ScrollOffsetY
            $endLine = [Math]::Min($this.Lines.Count - 1, $startLine + $textAreaHeight - 1)
            
            # AI: Render text lines
            for ($i = $startLine; $i -le $endLine; $i++) {
                if ($i -ge $this.Lines.Count) { break }
                
                $line = $this.Lines[$i] ?? ""
                $displayLine = $line
                if ($displayLine.Length -gt $textAreaWidth) {
                    $displayLine = $displayLine.Substring(0, $textAreaWidth)
                }
                
                $lineY = 1 + ($i - $startLine)
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y $lineY -Text $displayLine `
                    -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            # AI: Show placeholder if empty and not focused
            if ($this.Lines.Count -eq 1 -and [string]::IsNullOrEmpty($this.Lines[0]) -and -not $this.IsFocused) {
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $this.Placeholder `
                    -ForegroundColor ([ConsoleColor]::DarkGray) -BackgroundColor ([ConsoleColor]::Black)
            }
            
            # AI: Draw cursor if focused
            if ($this.IsFocused) {
                $cursorLine = $this.CurrentLine - $this.ScrollOffsetY
                if ($cursorLine -ge 0 -and $cursorLine -lt $textAreaHeight) {
                    $cursorX = 1 + $this.CursorPosition
                    $cursorY = 1 + $cursorLine
                    if ($cursorX -lt $this.Width - 1) {
                        Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y $cursorY -Text "_" `
                            -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                    }
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $currentLineText = $this.Lines[$this.CurrentLine] ?? ""
            $originalLines = $this.Lines.Clone()
            $handled = $true
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = $this.Lines[$this.CurrentLine].Length
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.CursorPosition++
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $currentLineText.Length }
                ([ConsoleKey]::Enter) {
                    if ($this.Lines.Count -lt $this.MaxLines) {
                        $beforeCursor = $currentLineText.Substring(0, $this.CursorPosition)
                        $afterCursor = $currentLineText.Substring($this.CursorPosition)
                        
                        $this.Lines[$this.CurrentLine] = $beforeCursor
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($afterCursor) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    } elseif ($this.CurrentLine -gt 0 -and $this.Lines.Count -gt 1) {
                        $previousLine = $this.Lines[$this.CurrentLine - 1]
                        $this.CursorPosition = $previousLine.Length
                        $this.Lines[$this.CurrentLine - 1] = $previousLine + $currentLineText
                        $this.Lines = @($this.Lines[0..($this.CurrentLine - 1)]) + @($this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)])
                        $this.CurrentLine--
                        $this._UpdateScrolling()
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition, 1)
                    } elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $nextLine = $this.Lines[$this.CurrentLine + 1]
                        $this.Lines[$this.CurrentLine] = $currentLineText + $nextLine
                        $this.Lines = @($this.Lines[0..$this.CurrentLine]) + @($this.Lines[($this.CurrentLine + 2)..($this.Lines.Count - 1)])
                    }
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentLineText.Length -lt $this.MaxLineLength) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.OnChange -and -not $this._ArraysEqual($originalLines, $this.Lines)) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Lines 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "MultilineTextBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _UpdateScrolling() {
        $textAreaHeight = $this.Height - 2
        if ($this.CurrentLine -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CurrentLine
        } elseif ($this.CurrentLine -ge ($this.ScrollOffsetY + $textAreaHeight)) {
            $this.ScrollOffsetY = $this.CurrentLine - $textAreaHeight + 1
        }
    }
    
    hidden [bool] _ArraysEqual([string[]]$array1, [string[]]$array2) {
        if ($array1.Count -ne $array2.Count) { return $false }
        for ($i = 0; $i -lt $array1.Count; $i++) {
            if ($array1[$i] -ne $array2[$i]) { return $false }
        }
        return $true
    }
    
    [string] GetText() {
        return $this.Lines -join "`n"
    }
    
    [void] SetText([string]$text) {
        $this.Lines = if ([string]::IsNullOrEmpty($text)) { @("") } else { $text -split "`n" }
        $this.CurrentLine = 0
        $this.CursorPosition = 0
        $this.ScrollOffsetY = 0
        $this.RequestRedraw()
    }
}

# AI: REFACTORED - NumericInput converted from functional to class-based
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$Min = [double]::MinValue
    [double]$Max = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [string]$TextValue = "0"
    [int]$CursorPosition = 0
    [string]$Suffix = ""
    [scriptblock]$OnChange
    
    NumericInputComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display value with suffix
            $displayText = $this.TextValue + $this.Suffix
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw spinner arrows
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 0 -Text "▲" `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 2 -Text "▼" `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt $this.Width - 4) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" `
                        -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "NumericInput render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this._IncrementValue()
                }
                ([ConsoleKey]::DownArrow) {
                    $this._DecrementValue()
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) { 
                        $this.CursorPosition-- 
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) { 
                        $this.CursorPosition++ 
                    }
                }
                ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this._ValidateAndUpdate()
                }
                default {
                    if ($key.KeyChar -and ($key.KeyChar -match '[\d\.\-]' -or 
                        ($key.KeyChar -eq '.' -and $this.DecimalPlaces -gt 0 -and -not $this.TextValue.Contains('.')))) {
                        $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "NumericInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _IncrementValue() {
        $newValue = [Math]::Min($this.Max, $this.Value + $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _DecrementValue() {
        $newValue = [Math]::Max($this.Min, $this.Value - $this.Step)
        $this._SetValue($newValue)
    }
    
    hidden [void] _SetValue([double]$value) {
        $this.Value = $value
        $this.TextValue = $value.ToString("F$($this.DecimalPlaces)")
        $this.CursorPosition = $this.TextValue.Length
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newValue = [double]$this.TextValue
            $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
            $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
            
            $this._SetValue($newValue)
            return $true
        } catch {
            $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
            Write-Log -Level Warning -Message "NumericInput validation failed for '$($this.Name)': $_"
            return $false
        }
    }
}

# AI: REFACTORED - DateInput converted from functional to class-based
class DateInputComponent : UIElement {
    [DateTime]$Value = (Get-Date)
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [string]$Format = "yyyy-MM-dd"
    [string]$TextValue = ""
    [int]$CursorPosition = 0
    [bool]$ShowCalendar = $false
    [scriptblock]$OnChange
    
    DateInputComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.TextValue = $this.Value.ToString($this.Format)
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display date value
            $displayText = $this.TextValue
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor ([ConsoleColor]::White) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw calendar icon
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text "📅" `
                -ForegroundColor ([ConsoleColor]::Cyan) -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw cursor if focused
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt $this.Width - 4) {
                    Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y 1 -Text "_" `
                        -ForegroundColor ([ConsoleColor]::Yellow) -BackgroundColor ([ConsoleColor]::Black)
                }
            }
            
        } catch { 
            Write-Log -Level Error -Message "DateInput render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalValue = $this.Value
            
            if ($this.ShowCalendar) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) { $this.ShowCalendar = $false }
                    ([ConsoleKey]::LeftArrow) { $this.Value = $this.Value.AddDays(-1) }
                    ([ConsoleKey]::RightArrow) { $this.Value = $this.Value.AddDays(1) }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(-7) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(7) }
                    ([ConsoleKey]::Enter) { 
                        $this.ShowCalendar = $false
                        $this.TextValue = $this.Value.ToString($this.Format)
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::F4) { $this.ShowCalendar = $true }
                    ([ConsoleKey]::UpArrow) { $this.Value = $this.Value.AddDays(1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::DownArrow) { $this.Value = $this.Value.AddDays(-1); $this.TextValue = $this.Value.ToString($this.Format) }
                    ([ConsoleKey]::LeftArrow) {
                        if ($this.CursorPosition -gt 0) { $this.CursorPosition-- }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) { $this.CursorPosition++ }
                    }
                    ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
                    ([ConsoleKey]::End) { $this.CursorPosition = $this.TextValue.Length }
                    ([ConsoleKey]::Backspace) {
                        if ($this.CursorPosition -gt 0) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                            $this.CursorPosition--
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($this.CursorPosition -lt $this.TextValue.Length) {
                            $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                        }
                    }
                    ([ConsoleKey]::Enter) {
                        $this._ValidateAndUpdate()
                    }
                    default {
                        if ($key.KeyChar -and ($key.KeyChar -match '[\d\-\/]')) {
                            $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                            $this.CursorPosition++
                        } else {
                            $handled = $false
                        }
                    }
                }
            }
            
            if ($handled -and $this.Value -ne $originalValue -and $this.OnChange) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -Context "Change Event" -ScriptBlock { 
                    & $this.OnChange -NewValue $this.Value 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "DateInput input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [bool] _ValidateAndUpdate() {
        try {
            $newDate = [DateTime]::ParseExact($this.TextValue, $this.Format, $null)
            if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                $this.Value = $newDate
                $this.TextValue = $newDate.ToString($this.Format)
                return $true
            }
        } catch {
            # Reset to current value on parse error
            $this.TextValue = $this.Value.ToString($this.Format)
            Write-Log -Level Warning -Message "DateInput validation failed for '$($this.Name)': $_"
        }
        return $false
    }
}

# AI: REFACTORED - ComboBox converted from functional to class-based
class ComboBoxComponent : UIElement {
    [object[]]$Items = @()
    [object]$SelectedItem = $null
    [int]$SelectedIndex = -1
    [string]$DisplayMember = "Display"
    [string]$ValueMember = "Value"
    [string]$Placeholder = "Select an item..."
    [bool]$IsDropDownOpen = $false
    [int]$MaxDropDownHeight = 6
    [int]$ScrollOffset = 0
    [scriptblock]$OnSelectionChanged
    
    ComboBoxComponent([string]$name) : base() {
        $this.Name = $name
        $this.IsFocusable = $true
        $this.Width = 30
        $this.Height = 3
    }
    
    # AI: REFACTORED - Now uses UIElement buffer system
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
            
            $borderColor = $this.IsFocused ? [ConsoleColor]::Yellow : [ConsoleColor]::Gray
            
            # AI: Draw main combobox
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Display selected item or placeholder
            $displayText = ""
            if ($this.SelectedItem) {
                if ($this.SelectedItem -is [string]) {
                    $displayText = $this.SelectedItem
                } elseif ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.DisplayMember)) {
                    $displayText = $this.SelectedItem[$this.DisplayMember]
                } else {
                    $displayText = $this.SelectedItem.ToString()
                }
            } else {
                $displayText = $this.Placeholder
            }
            
            $maxDisplayLength = $this.Width - 6
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength - 3) + "..."
            }
            
            $textColor = $this.SelectedItem ? [ConsoleColor]::White : [ConsoleColor]::DarkGray
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText `
                -ForegroundColor $textColor -BackgroundColor ([ConsoleColor]::Black)
            
            # AI: Draw dropdown arrow
            $arrow = $this.IsDropDownOpen ? "▲" : "▼"
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text $arrow `
                -ForegroundColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
            
        } catch { 
            Write-Log -Level Error -Message "ComboBox render error for '$($this.Name)': $_" 
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $originalSelection = $this.SelectedItem
            
            if ($this.IsDropDownOpen) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) {
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::Enter) {
                        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
                            $this.SelectedItem = $this.Items[$this.SelectedIndex]
                        }
                        $this.IsDropDownOpen = $false
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($this.SelectedIndex -gt 0) {
                            $this.SelectedIndex--
                            $this._UpdateScrolling()
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                            $this.SelectedIndex++
                            $this._UpdateScrolling()
                        }
                    }
                    default { $handled = $false }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::Enter) { $this._OpenDropDown() }
                    ([ConsoleKey]::Spacebar) { $this._OpenDropDown() }
                    ([ConsoleKey]::DownArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::UpArrow) { $this._OpenDropDown() }
                    ([ConsoleKey]::F4) { $this._OpenDropDown() }
                    default { $handled = $false }
                }
            }
            
            if ($handled -and $this.SelectedItem -ne $originalSelection -and $this.OnSelectionChanged) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnSelectionChanged" -Context "Selection Change" -ScriptBlock { 
                    & $this.OnSelectionChanged -SelectedItem $this.SelectedItem 
                }
                $this.RequestRedraw()
            }
            
            return $handled
        } catch { 
            Write-Log -Level Error -Message "ComboBox input error for '$($this.Name)': $_"
            return $false 
        }
    }
    
    hidden [void] _OpenDropDown() {
        if ($this.Items.Count -gt 0) {
            $this.IsDropDownOpen = $true
            $this._FindCurrentSelection()
        }
    }
    
    hidden [void] _FindCurrentSelection() {
        $this.SelectedIndex = -1
        if ($this.SelectedItem) {
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                if ($this._ItemsEqual($this.Items[$i], $this.SelectedItem)) {
                    $this.SelectedIndex = $i
                    break
                }
            }
        }
        if ($this.SelectedIndex -eq -1) { $this.SelectedIndex = 0 }
        $this._UpdateScrolling()
    }
    
    hidden [void] _UpdateScrolling() {
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $this.MaxDropDownHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $this.MaxDropDownHeight + 1
        }
    }
    
    hidden [bool] _ItemsEqual([object]$item1, [object]$item2) {
        if ($item1 -is [string] -and $item2 -is [string]) {
            return $item1 -eq $item2
        } elseif ($item1 -is [hashtable] -and $item2 -is [hashtable]) {
            return $item1[$this.ValueMember] -eq $item2[$this.ValueMember]
        } else {
            return $item1 -eq $item2
        }
    }
    
    [void] SetItems([object[]]$items) {
        $this.Items = $items
        $this.SelectedItem = $null
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.IsDropDownOpen = $false
        $this.RequestRedraw()
    }
    
    [object] GetSelectedValue() {
        if ($this.SelectedItem -is [hashtable] -and $this.SelectedItem.ContainsKey($this.ValueMember)) {
            return $this.SelectedItem[$this.ValueMember]
        }
        return $this.SelectedItem
    }
}

#endregion

#region Factory Functions

# AI: Updated factories to return class instances

function New-TuiMultilineTextBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "MultilineTextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $textBox = [MultilineTextBoxComponent]::new($name)
    
    $textBox.X = $Props.X ?? $textBox.X
    $textBox.Y = $Props.Y ?? $textBox.Y
    $textBox.Width = $Props.Width ?? $textBox.Width
    $textBox.Height = $Props.Height ?? $textBox.Height
    $textBox.Visible = $Props.Visible ?? $textBox.Visible
    $textBox.ZIndex = $Props.ZIndex ?? $textBox.ZIndex
    $textBox.Placeholder = $Props.Placeholder ?? $textBox.Placeholder
    $textBox.MaxLines = $Props.MaxLines ?? $textBox.MaxLines
    $textBox.MaxLineLength = $Props.MaxLineLength ?? $textBox.MaxLineLength
    $textBox.WordWrap = $Props.WordWrap ?? $textBox.WordWrap
    $textBox.OnChange = $Props.OnChange ?? $textBox.OnChange
    
    if ($Props.Text) {
        $textBox.SetText($Props.Text)
    }
    
    return $textBox
}

function New-TuiNumericInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "NumericInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $numericInput = [NumericInputComponent]::new($name)
    
    $numericInput.X = $Props.X ?? $numericInput.X
    $numericInput.Y = $Props.Y ?? $numericInput.Y
    $numericInput.Width = $Props.Width ?? $numericInput.Width
    $numericInput.Height = $Props.Height ?? $numericInput.Height
    $numericInput.Visible = $Props.Visible ?? $numericInput.Visible
    $numericInput.ZIndex = $Props.ZIndex ?? $numericInput.ZIndex
    $numericInput.Value = $Props.Value ?? $numericInput.Value
    $numericInput.Min = $Props.Min ?? $numericInput.Min
    $numericInput.Max = $Props.Max ?? $numericInput.Max
    $numericInput.Step = $Props.Step ?? $numericInput.Step
    $numericInput.DecimalPlaces = $Props.DecimalPlaces ?? $numericInput.DecimalPlaces
    $numericInput.Suffix = $Props.Suffix ?? $numericInput.Suffix
    $numericInput.OnChange = $Props.OnChange ?? $numericInput.OnChange
    
    # Update text value based on initial value
    $numericInput.TextValue = $numericInput.Value.ToString("F$($numericInput.DecimalPlaces)")
    
    return $numericInput
}

function New-TuiDateInput {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DateInput_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $dateInput = [DateInputComponent]::new($name)
    
    $dateInput.X = $Props.X ?? $dateInput.X
    $dateInput.Y = $Props.Y ?? $dateInput.Y
    $dateInput.Width = $Props.Width ?? $dateInput.Width
    $dateInput.Height = $Props.Height ?? $dateInput.Height
    $dateInput.Visible = $Props.Visible ?? $dateInput.Visible
    $dateInput.ZIndex = $Props.ZIndex ?? $dateInput.ZIndex
    $dateInput.Value = $Props.Value ?? $dateInput.Value
    $dateInput.MinDate = $Props.MinDate ?? $dateInput.MinDate
    $dateInput.MaxDate = $Props.MaxDate ?? $dateInput.MaxDate
    $dateInput.Format = $Props.Format ?? $dateInput.Format
    $dateInput.OnChange = $Props.OnChange ?? $dateInput.OnChange
    
    # Update text value based on initial value
    $dateInput.TextValue = $dateInput.Value.ToString($dateInput.Format)
    
    return $dateInput
}

function New-TuiComboBox {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "ComboBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $comboBox = [ComboBoxComponent]::new($name)
    
    $comboBox.X = $Props.X ?? $comboBox.X
    $comboBox.Y = $Props.Y ?? $comboBox.Y
    $comboBox.Width = $Props.Width ?? $comboBox.Width
    $comboBox.Height = $Props.Height ?? $comboBox.Height
    $comboBox.Visible = $Props.Visible ?? $comboBox.Visible
    $comboBox.ZIndex = $Props.ZIndex ?? $comboBox.ZIndex
    $comboBox.DisplayMember = $Props.DisplayMember ?? $comboBox.DisplayMember
    $comboBox.ValueMember = $Props.ValueMember ?? $comboBox.ValueMember
    $comboBox.Placeholder = $Props.Placeholder ?? $comboBox.Placeholder
    $comboBox.MaxDropDownHeight = $Props.MaxDropDownHeight ?? $comboBox.MaxDropDownHeight
    $comboBox.OnSelectionChanged = $Props.OnSelectionChanged ?? $comboBox.OnSelectionChanged
    
    if ($Props.Items) {
        $comboBox.SetItems($Props.Items)
    }
    
    if ($Props.SelectedItem) {
        $comboBox.SelectedItem = $Props.SelectedItem
    }
    
    return $comboBox
}

#endregion

# --- END OF ORIGINAL FILE: components\advanced-input-components\advanced-input-components.psm1 ---


# --- START OF ORIGINAL FILE: modules\data-manager-class\data-manager-class.psm1 ---


# DataManager Class Definition
# Split from data-manager.psm1 to resolve class dependency issues

class DataManager {
    hidden [hashtable] $DataStore
    hidden [string] $DataFilePath
    hidden [bool] $AutoSaveEnabled = $true
    
    DataManager() {
        $this.DataStore = $script:Data
        $global:Data = $script:Data
        $this.DataFilePath = $script:DataPath
        $this.AutoSaveEnabled = $this.DataStore.Settings.AutoSave
    }

    [void] LoadData() { Load-UnifiedData }
    [void] SaveData() { Save-UnifiedData }
    
    [PmcTask] AddTask([string]$Title, [string]$Description, [string]$Priority, [string]$ProjectKey) { 
        return Add-PmcTask -Title $Title -Description $Description -Priority $Priority -Category $ProjectKey 
    }

    # AI: FIX - Changed method to accept a hashtable for flexible updates via splatting.
    [PmcTask] UpdateTask([hashtable]$UpdateParameters) {
        if (-not $UpdateParameters.ContainsKey('Task')) {
            throw [System.ArgumentException]::new("The 'UpdateParameters' hashtable must contain a 'Task' key with the task object to update.")
        }
        return Update-PmcTask @UpdateParameters
    }
    
    [void] RemoveTask([PmcTask]$Task) {
        Remove-PmcTask -Task $Task
    }
    
    [PmcTask[]] GetTasks() { 
        return Get-PmcTasks 
    }

    [PmcProject[]] GetProjects() { 
        return Get-PmcProjects 
    }
}

# --- END OF ORIGINAL FILE: modules\data-manager-class\data-manager-class.psm1 ---


# --- START OF ORIGINAL FILE: services\keybinding-service-class\keybinding-service-class.psm1 ---


# keybinding-service-class.psm1
# Contains only the KeybindingService class definition.

class KeybindingService {
    [hashtable] $KeyMap = @{}
    [hashtable] $GlobalHandlers = @{}
    [System.Collections.Generic.List[string]] $ContextStack
    [bool] $EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized"
    }
    
    KeybindingService([bool]$enableChords) {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.EnableChords = $enableChords
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized with chords: $enableChords"
    }
    
    hidden [void] InitializeDefaultBindings() {
        # AI: Standard application keybindings
        $this.KeyMap = @{
            "app.exit" = @{ Key = "Q"; Modifiers = @("Ctrl") }
            "app.help" = @{ Key = [System.ConsoleKey]::F1; Modifiers = @() }
            "nav.back" = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }
            "nav.up" = @{ Key = [System.ConsoleKey]::UpArrow; Modifiers = @() }
            "nav.down" = @{ Key = [System.ConsoleKey]::DownArrow; Modifiers = @() }
            "nav.left" = @{ Key = [System.ConsoleKey]::LeftArrow; Modifiers = @() }
            "nav.right" = @{ Key = [System.ConsoleKey]::RightArrow; Modifiers = @() }
            "nav.select" = @{ Key = [System.ConsoleKey]::Enter; Modifiers = @() }
            "nav.pageup" = @{ Key = [System.ConsoleKey]::PageUp; Modifiers = @() }
            "nav.pagedown" = @{ Key = [System.ConsoleKey]::PageDown; Modifiers = @() }
            "nav.home" = @{ Key = [System.ConsoleKey]::Home; Modifiers = @() }
            "nav.end" = @{ Key = [System.ConsoleKey]::End; Modifiers = @() }
            "nav.tab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @() }
            "nav.shifttab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @("Shift") }
            "edit.delete" = @{ Key = [System.ConsoleKey]::Delete; Modifiers = @() }
            "edit.backspace" = @{ Key = [System.ConsoleKey]::Backspace; Modifiers = @() }
            "edit.new" = @{ Key = "n"; Modifiers = @() }
            "edit.save" = @{ Key = "s"; Modifiers = @("Ctrl") }
            "app.refresh" = @{ Key = [System.ConsoleKey]::F5; Modifiers = @() }
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKey]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [char]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
        }
        
        $modifiers = @()
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) { $modifiers += "Ctrl" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) { $modifiers += "Alt" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) { $modifiers += "Shift" }

        $this.KeyMap[$actionName.ToLower()] = @{
            Key = $keyInfo.Key
            KeyChar = $keyInfo.KeyChar
            Modifiers = $modifiers
        }
        Write-Log -Level Debug -Message "Set keybinding for '$actionName': $($this.GetBindingDescription($actionName))"
    }
    
    [void] RemoveBinding([string]$actionName) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RemoveBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return
            }
            
            $normalizedName = $actionName.ToLower()
            if ($this.KeyMap.ContainsKey($normalizedName)) {
                $this.KeyMap.Remove($normalizedName)
                Write-Log -Level Debug -Message "Removed keybinding: $actionName"
            }
        }
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        return $this.IsAction($actionName, $keyInfo, $null)
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "IsAction:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return $false
            }
            
            $normalizedName = $actionName.ToLower()
            if (-not $this.KeyMap.ContainsKey($normalizedName)) {
                return $false
            }
            
            $binding = $this.KeyMap[$normalizedName]
            
            # Check if the key matches
            $keyMatches = $false
            if ($binding.Key -is [System.ConsoleKey]) {
                $keyMatches = ($keyInfo.Key -eq $binding.Key)
            }
            elseif ($binding.Key -is [char]) {
                $keyMatches = ($keyInfo.KeyChar -eq $binding.Key)
            }
            elseif ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
                # Character-based binding (case-insensitive)
                $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.KeyChar.ToString(), [System.StringComparison]::OrdinalIgnoreCase)
            }
            else {
                # Try string comparison for backward compatibility
                $keyString = $binding.Key.ToString()
                if ($keyString.Length -eq 1) {
                    $keyMatches = ($keyInfo.KeyChar.ToString().ToUpper() -eq $keyString.ToUpper())
                }
                else {
                    # Try to match against ConsoleKey enum
                    try {
                        $consoleKey = [System.ConsoleKey]::Parse([System.ConsoleKey], $keyString, $true)
                        $keyMatches = ($keyInfo.Key -eq $consoleKey)
                    }
                    catch {
                        $keyMatches = $false
                    }
                }
            }
            
            if (-not $keyMatches) {
                return $false
            }
            
            # Check modifiers
            $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
            $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
            $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
            
            $expectedCtrl = $binding.Modifiers -contains "Ctrl"
            $expectedAlt = $binding.Modifiers -contains "Alt"
            $expectedShift = $binding.Modifiers -contains "Shift"
            
            return ($hasCtrl -eq $expectedCtrl) -and ($hasAlt -eq $expectedAlt) -and ($hasShift -eq $expectedShift)
        }
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "GetAction" -ScriptBlock {
            foreach ($actionName in $this.KeyMap.Keys) {
                if ($this.IsAction($actionName, $keyInfo)) {
                    return $actionName
                }
            }
            return $null
        }
    }
    
    [void] RegisterGlobalHandler([string]$actionName, [scriptblock]$handler) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RegisterGlobalHandler:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            if ($null -eq $handler) {
                throw [System.ArgumentNullException]::new("handler", "Handler cannot be null")
            }
            
            $this.GlobalHandlers[$actionName.ToLower()] = $handler
            Write-Log -Level Debug -Message "Registered global handler: $actionName"
        }
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo) {
        return $this.HandleKey($keyInfo, $null)
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "HandleKey" -ScriptBlock {
            # Check all registered actions
            foreach ($action in $this.KeyMap.Keys) {
                if ($this.IsAction($action, $keyInfo, $context)) {
                    # Execute global handler if registered
                    if ($this.GlobalHandlers.ContainsKey($action)) {
                        Write-Log -Level Debug -Message "Executing global handler: $action"
                        try {
                            return & $this.GlobalHandlers[$action] -KeyInfo $keyInfo -Context $context
                        }
                        catch {
                            Write-Log -Level Error -Message "Global handler failed for '$action': $_"
                            return $null
                        }
                    }
                    
                    # Return the action name for the caller to handle
                    return $action
                }
            }
            
            return $null
        }
    }
    
    [void] PushContext([string]$context) {
        if (-not [string]::IsNullOrWhiteSpace($context)) {
            $this.ContextStack.Add($context)
            Write-Log -Level Debug -Message "Pushed keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
        }
    }
    
    [string] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $context = $this.ContextStack[-1]
            $this.ContextStack.RemoveAt($this.ContextStack.Count - 1)
            Write-Log -Level Debug -Message "Popped keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
            return $context
        }
        return $null
    }
    
    [string] GetCurrentContext() {
        if ($this.ContextStack.Count -gt 0) {
            return $this.ContextStack[-1]
        }
        return "global"
    }
    
    [string] GetBindingDescription([string]$actionName) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            return $null
        }
        
        $normalizedName = $actionName.ToLower()
        if (-not $this.KeyMap.ContainsKey($normalizedName)) {
            return "Unbound"
        }
        
        $binding = $this.KeyMap[$normalizedName]
        $keyStr = if ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
            $binding.KeyChar.ToString().ToUpper()
        } elseif ($binding.Key -is [System.ConsoleKey]) {
            $binding.Key.ToString()
        } else {
            $binding.Key.ToString().ToUpper()
        }
        
        if ($binding.Modifiers.Count -gt 0) {
            return "$($binding.Modifiers -join '+') + $keyStr"
        }
        
        return $keyStr
    }
    
    [hashtable] GetAllBindings() {
        return $this.GetAllBindings($false)
    }
    
    [hashtable] GetAllBindings([bool]$groupByCategory) {
        if (-not $groupByCategory) {
            return $this.KeyMap.Clone()
        }
        
        # Group by category (part before the dot)
        $grouped = @{}
        foreach ($action in $this.KeyMap.Keys) {
            $parts = $action.Split('.')
            $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
            if (-not $grouped.ContainsKey($category)) {
                $grouped[$category] = @{}
            }
            $grouped[$category][$action] = $this.KeyMap[$action]
        }
        
        return $grouped
    }
    
    [void] ExportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ExportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            $this.KeyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $path -Encoding UTF8
            Write-Log -Level Info -Message "Exported keybindings to: $path"
        }
    }
    
    [void] ImportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ImportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            if (-not (Test-Path $path)) {
                Write-Log -Level Warning -Message "Keybindings file not found: $path"
                return
            }
            
            try {
                $imported = Get-Content $path -Raw | ConvertFrom-Json
                foreach ($prop in $imported.PSObject.Properties) {
                    $bindingData = @{
                        Key = $prop.Value.Key
                        Modifiers = $prop.Value.Modifiers
                    }
                    if ($prop.Value.PSObject.Properties.Name -contains 'KeyChar') {
                        $bindingData['KeyChar'] = $prop.Value.KeyChar
                    }
                    $this.KeyMap[$prop.Name] = $bindingData
                }
                Write-Log -Level Info -Message "Imported keybindings from: $path"
            }
            catch {
                Write-Log -Level Error -Message "Failed to import keybindings from '$path': $_"
                throw
            }
        }
    }
}

# --- END OF ORIGINAL FILE: services\keybinding-service-class\keybinding-service-class.psm1 ---


# --- START OF ORIGINAL FILE: services\navigation-service-class\navigation-service-class.psm1 ---


# navigation-service-class.psm1
# Contains only the NavigationService and ScreenFactory class definitions.

class ScreenFactory {
    hidden [hashtable] $Services
    hidden [hashtable] $ScreenTypes = @{}
    
    ScreenFactory([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        Write-Log -Level Debug -Message "ScreenFactory initialized"
    }
    
    [void] RegisterScreen([string]$name, [type]$screenType) {
        if (-not $screenType.IsSubclassOf([Screen])) { 
            throw "Screen type '$($screenType.Name)' must inherit from the Screen class." 
        }
        $this.ScreenTypes[$name] = $screenType
        Write-Log -Level Info -Message "Registered screen factory: $name -> $($screenType.Name)"
    }
    
    [Screen] CreateScreen([string]$screenName, [hashtable]$parameters) {
        $screenType = $this.ScreenTypes[$screenName]
        if (-not $screenType) {
            throw "Unknown screen type: '$screenName'. Available screens: $($this.ScreenTypes.Keys -join ', ')"
        }
        
        try {
            $screen = $screenType::new($this.Services)
            if ($parameters) {
                foreach ($key in $parameters.Keys) { 
                    $screen.State[$key] = $parameters[$key] 
                }
            }
            Write-Log -Level Info -Message "Created screen: $screenName"
            return $screen
        } catch {
            Write-Log -Level Error -Message "Failed to create screen '$screenName': $($_.Exception.Message)"
            throw
        }
    }
    
    [string[]] GetRegisteredScreens() {
        return @($this.ScreenTypes.Keys)
    }
}

class NavigationService {
    [System.Collections.Generic.Stack[Screen]] $ScreenStack
    [ScreenFactory] $ScreenFactory
    [Screen] $CurrentScreen
    [hashtable] $Services
    [hashtable] $RouteMap = @{}
    
    NavigationService([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        $this.ScreenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.ScreenFactory = [ScreenFactory]::new($services)
        $this.InitializeRoutes()
        Write-Log -Level Info -Message "NavigationService initialized"
    }
    
    hidden [void] InitializeRoutes() {
        $this.RouteMap = @{
            "/" = "DashboardScreen"
            "/dashboard" = "DashboardScreen"
            "/tasks" = "TaskListScreen"
        }
        Write-Log -Level Debug -Message "Routes initialized: $($this.RouteMap.Keys -join ', ')"
    }
    
    [void] RegisterScreenClass([string]$name, [type]$screenType) {
        $this.ScreenFactory.RegisterScreen($name, $screenType)
    }
    
    [void] GoTo([string]$path, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "GoTo:$path" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) { 
                throw [System.ArgumentException]::new("Path cannot be empty.") 
            }
            if ($path -eq "/exit") { 
                $this.RequestExit()
                return 
            }
            
            $screenName = $this.RouteMap[$path]
            if (-not $screenName) {
                $availableRoutes = $this.RouteMap.Keys -join ', '
                throw "Unknown route: '$path'. Available routes: $availableRoutes"
            }
            
            Write-Log -Level Info -Message "Navigating to: $path -> $screenName"
            $this.PushScreen($screenName, $parameters)
        }
    }
    
    [void] PushScreen([string]$screenName, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "PushScreen:$screenName" -ScriptBlock {
            Write-Log -Level Info -Message "Pushing screen: $screenName"
            
            if ($this.CurrentScreen) {
                Write-Log -Level Debug -Message "Exiting current screen: $($this.CurrentScreen.Name)"
                $this.CurrentScreen.OnExit()
                $this.ScreenStack.Push($this.CurrentScreen)
            }
            
            Write-Log -Level Debug -Message "Creating new screen: $screenName"
            $newScreen = $this.ScreenFactory.CreateScreen($screenName, $parameters)
            $this.CurrentScreen = $newScreen
            
            Write-Log -Level Debug -Message "Initializing screen: $screenName"
            $newScreen.Initialize()
            $newScreen.OnEnter()
            
            if (Get-Command "Push-Screen" -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Pushing screen to TUI engine"
                Push-Screen -Screen $newScreen
            } else {
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $newScreen
                    Request-TuiRefresh
                }
            }
            
            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{ Screen = $screenName; Action = "Push" }
            Write-Log -Level Info -Message "Successfully pushed screen: $screenName"
        }
    }
    
    [bool] PopScreen() {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "PopScreen" -ScriptBlock {
            if ($this.ScreenStack.Count -eq 0) { 
                Write-Log -Level Warning -Message "Cannot pop screen: stack is empty"
                return $false 
            }
            
            Write-Log -Level Info -Message "Popping screen"
            $this.CurrentScreen?.OnExit()
            $this.CurrentScreen = $this.ScreenStack.Pop()
            $this.CurrentScreen?.OnResume()
            
            if (Get-Command "Pop-Screen" -ErrorAction SilentlyContinue) {
                Pop-Screen
            } else {
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $this.CurrentScreen
                    Request-TuiRefresh
                }
            }
            
            Publish-Event -EventName "Navigation.ScreenPopped" -Data @{ Screen = $this.CurrentScreen.Name }
            return $true
        }
    }
    
    [void] RequestExit() {
        Write-Log -Level Info -Message "Exit requested"
        while ($this.PopScreen()) {} # Pop all screens
        $this.CurrentScreen?.OnExit()
        if (Get-Command "Stop-TuiEngine" -ErrorAction SilentlyContinue) {
            Stop-TuiEngine
        }
        Publish-Event -EventName "Application.Exit"
    }
    
    [Screen] GetCurrentScreen() { return $this.CurrentScreen }
    [bool] IsValidRoute([string]$path) { return $this.RouteMap.ContainsKey($path) }
    
    [void] ListRegisteredScreens() {
        $screens = $this.ScreenFactory.GetRegisteredScreens()
        Write-Log -Level Info -Message "Registered screens: $($screens -join ', ')"
        Write-Host "Registered screens: $($screens -join ', ')" -ForegroundColor Green
    }
    
    [void] ListAvailableRoutes() {
        $routes = $this.RouteMap.Keys
        Write-Log -Level Info -Message "Available routes: $($routes -join ', ')"
        Write-Host "Available routes: $($routes -join ', ')" -ForegroundColor Green
    }
}

# --- END OF ORIGINAL FILE: services\navigation-service-class\navigation-service-class.psm1 ---


# --- START OF ORIGINAL FILE: modules\dialog-system-class\dialog-system-class.psm1 ---


# ==============================================================================
# PMC Terminal v5 - Class-Based Dialog System
# Implements dialogs as proper UIElement classes following the unified architecture
# ==============================================================================

# Base Dialog Class - properly inheriting from UIElement
class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    [ConsoleColor] $BorderColor = [ConsoleColor]::Cyan
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [ConsoleColor] $MessageColor = [ConsoleColor]::Gray
    
    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 50
        $this.Height = 10
    }
    
    [void] Show() {
        $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
        $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 2)
        if ($null -eq $this._private_buffer -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
            $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        }
        $script:DialogState.CurrentDialog = $this
        # AI: FIX - Changed to event-based refresh to break circular dependency
        Publish-Event -EventName "TUI.RefreshRequested"
    }
    
    [void] Close() {
        $script:DialogState.CurrentDialog = $null
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        }
        # AI: FIX - Changed to event-based refresh to break circular dependency
        Publish-Event -EventName "TUI.RefreshRequested"
    }
    
    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black))
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
            -BorderStyle "Single" -BorderColor $this.BorderColor -BackgroundColor [ConsoleColor]::Black -Title $this.Title
        if (-not [string]::IsNullOrWhiteSpace($this.Message)) { $this.RenderMessage() }
        $this.RenderDialogContent()
    }
    
    hidden [void] RenderMessage() {
        $messageY = 2; $messageX = 2; $maxWidth = $this.Width - 4
        $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
        foreach ($line in $wrappedLines) {
            if ($messageY -ge ($this.Height - 3)) { break }
            Write-TuiText -Buffer $this._private_buffer -X $messageX -Y $messageY -Text $line -ForegroundColor $this.MessageColor
            $messageY++
        }
    }
    
    [void] RenderDialogContent() { }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) { $this.OnCancel(); return $true }
        return $false
    }
    
    [void] OnConfirm() { $this.Close() }
    [void] OnCancel() { $this.Close() }
}

class AlertDialog : Dialog {
    [string] $ButtonText = "OK"
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title; $this.Message = $message; $this.Height = 10
        $this.Width = [Math]::Min(80, [Math]::Max(40, $message.Length + 10))
    }
    [void] RenderDialogContent() {
        $buttonY = $this.Height - 2; $buttonLabel = "[ $($this.ButtonText) ]"
        $buttonX = [Math]::Floor(($this.Width - $buttonLabel.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY -Text $buttonLabel -ForegroundColor ([ConsoleColor]::Yellow)
    }
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) { $this.OnConfirm(); return $true }
        return ([Dialog]$this).HandleInput($key)
    }
}

class ConfirmDialog : Dialog {
    [scriptblock] $OnConfirmAction; [scriptblock] $OnCancelAction
    [string[]] $Buttons = @("Yes", "No"); [int] $SelectedButton = 0
    ConfirmDialog([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) : base("ConfirmDialog") {
        $this.Title = $title; $this.Message = $message; $this.OnConfirmAction = $onConfirm; $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $message.Length + 10)); $this.Height = 10
    }
    [void] RenderDialogContent() {
        $buttonY = $this.Height - 3; $totalButtonWidth = ($this.Buttons.Count * 12) + (($this.Buttons.Count - 1) * 2)
        $buttonX = [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        for ($i = 0; $i -lt $this.Buttons.Count; $i++) {
            $isSelected = ($i -eq $this.SelectedButton)
            $buttonLabel = if ($isSelected) { "[ $($this.Buttons[$i]) ]" } else { "  $($this.Buttons[$i])  " }
            $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY -Text $buttonLabel -ForegroundColor $color
            $buttonX += 14
        }
    }
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) { $this.SelectedButton = [Math]::Max(0, $this.SelectedButton - 1); $this.RequestRedraw(); return $true }
            ([ConsoleKey]::RightArrow) { $this.SelectedButton = [Math]::Min($this.Buttons.Count - 1, $this.SelectedButton + 1); $this.RequestRedraw(); return $true }
            ([ConsoleKey]::Tab) { $this.SelectedButton = ($this.SelectedButton + 1) % $this.Buttons.Count; $this.RequestRedraw(); return $true }
            ([ConsoleKey]::Enter) { if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }; return $true }
            ([ConsoleKey]::Spacebar) { if ($this.SelectedButton -eq 0) { $this.OnConfirm() } else { $this.OnCancel() }; return $true }
        }
        return ([Dialog]$this).HandleInput($key)
    }
    [void] OnConfirm() { $this.Close(); if ($this.OnConfirmAction) { Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnConfirm" -ScriptBlock $this.OnConfirmAction } }
    [void] OnCancel() { $this.Close(); if ($this.OnCancelAction) { Invoke-WithErrorHandling -Component "ConfirmDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction } }
}

class InputDialog : Dialog {
    [string] $Prompt = ""
    [string] $InputValue = ""
    [int] $CursorPosition = 0
    [scriptblock] $OnSubmitAction
    [scriptblock] $OnCancelAction
    
    InputDialog([string]$title, [string]$prompt, [scriptblock]$onSubmit, [scriptblock]$onCancel) : base("InputDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.OnSubmitAction = $onSubmit
        $this.OnCancelAction = $onCancel
        $this.Width = [Math]::Min(80, [Math]::Max(50, $prompt.Length + 20))
        $this.Height = 12
    }
    
    [void] SetDefaultValue([string]$value) {
        $this.InputValue = $value
        $this.CursorPosition = $value.Length
    }
    
    [void] RenderDialogContent() {
        # Render prompt
        $promptY = 3
        $promptX = 4
        Write-TuiText -Buffer $this._private_buffer -X $promptX -Y $promptY -Text $this.Prompt -ForegroundColor [ConsoleColor]::White
        
        # Render input box
        $inputY = 5
        $inputX = 4
        $inputWidth = $this.Width - 8
        
        # Input box border
        Write-TuiBox -Buffer $this._private_buffer -X $inputX -Y $inputY -Width $inputWidth -Height 3 `
            -BorderStyle "Single" -BorderColor [ConsoleColor]::DarkGray
        
        # Input value
        $displayValue = $this.InputValue
        if ($displayValue.Length -gt ($inputWidth - 3)) {
            $displayValue = $displayValue.Substring($displayValue.Length - ($inputWidth - 3))
        }
        Write-TuiText -Buffer $this._private_buffer -X ($inputX + 1) -Y ($inputY + 1) -Text $displayValue `
            -ForegroundColor [ConsoleColor]::Yellow
        
        # Render buttons
        $buttonY = $this.Height - 3
        $okLabel = "[ OK ]"
        $cancelLabel = "[ Cancel ]"
        $totalWidth = $okLabel.Length + $cancelLabel.Length + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        Write-TuiText -Buffer $this._private_buffer -X $startX -Y $buttonY -Text $okLabel `
            -ForegroundColor [ConsoleColor]::Green
        Write-TuiText -Buffer $this._private_buffer -X ($startX + $okLabel.Length + 4) -Y $buttonY `
            -Text $cancelLabel -ForegroundColor [ConsoleColor]::Gray
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) {
                $this.OnSubmit()
                return $true
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
                return $true
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.InputValue.Length) {
                    $this.InputValue = $this.InputValue.Remove($this.CursorPosition, 1)
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.InputValue.Length) {
                    $this.CursorPosition++
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Home) {
                $this.CursorPosition = 0
                $this.RequestRedraw()
                return $true
            }
            ([ConsoleKey]::End) {
                $this.CursorPosition = $this.InputValue.Length
                $this.RequestRedraw()
                return $true
            }
            default {
                if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or 
                    $key.KeyChar -in @(' ', '.', '-', '_', '@', '!', '?', ',', ';', ':', '/', '\', '(', ')', '[', ']', '{', '}')) {
                    $this.InputValue = $this.InputValue.Insert($this.CursorPosition, $key.KeyChar)
                    $this.CursorPosition++
                    $this.RequestRedraw()
                    return $true
                }
            }
        }
        return ([Dialog]$this).HandleInput($key)
    }
    
    [void] OnSubmit() {
        $this.Close()
        if ($this.OnSubmitAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnSubmit" -ScriptBlock {
                & $this.OnSubmitAction $this.InputValue
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "InputDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

class ProgressDialog : Dialog {
    [int] $PercentComplete = 0
    [string] $StatusText = ""
    [bool] $ShowCancel = $false
    [bool] $IsCancelled = $false
    
    ProgressDialog([string]$title, [string]$message) : base("ProgressDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Width = 60
        $this.Height = 10
    }
    
    [void] UpdateProgress([int]$percent, [string]$status = "") {
        $this.PercentComplete = [Math]::Max(0, [Math]::Min(100, $percent))
        if ($status) { $this.StatusText = $status }
        $this.RequestRedraw()
    }
    
    [void] RenderDialogContent() {
        # Progress bar
        $barY = 4
        $barX = 4
        $barWidth = $this.Width - 8
        $filledWidth = [Math]::Floor($barWidth * ($this.PercentComplete / 100.0))
        
        # Bar background
        Write-TuiText -Buffer $this._private_buffer -X $barX -Y $barY `
            -Text ('─' * $barWidth) -ForegroundColor [ConsoleColor]::DarkGray
        
        # Filled portion
        if ($filledWidth -gt 0) {
            Write-TuiText -Buffer $this._private_buffer -X $barX -Y $barY `
                -Text ('█' * $filledWidth) -ForegroundColor [ConsoleColor]::Green
        }
        
        # Percentage text
        $percentText = "$($this.PercentComplete)%"
        $percentX = [Math]::Floor(($this.Width - $percentText.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $percentX -Y ($barY + 1) `
            -Text $percentText -ForegroundColor [ConsoleColor]::White
        
        # Status text
        if ($this.StatusText) {
            $statusY = $barY + 3
            $maxStatusWidth = $this.Width - 8
            if ($this.StatusText.Length -gt $maxStatusWidth) {
                $displayStatus = $this.StatusText.Substring(0, $maxStatusWidth - 3) + "..."
            } else {
                $displayStatus = $this.StatusText
            }
            $statusX = [Math]::Floor(($this.Width - $displayStatus.Length) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $statusX -Y $statusY `
                -Text $displayStatus -ForegroundColor [ConsoleColor]::Gray
        }
        
        # Cancel button if enabled
        if ($this.ShowCancel) {
            $buttonY = $this.Height - 2
            $cancelLabel = "[ Cancel ]"
            $buttonX = [Math]::Floor(($this.Width - $cancelLabel.Length) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY `
                -Text $cancelLabel -ForegroundColor [ConsoleColor]::Yellow
        }
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($this.ShowCancel -and $key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            $this.IsCancelled = $true
            $this.Close()
            return $true
        }
        return $false
    }
}

class ListDialog : Dialog {
    [string] $Prompt = ""
    [string[]] $Items = @()
    [int] $SelectedIndex = 0
    [int] $ScrollOffset = 0
    [int] $VisibleItems = 10
    [bool] $AllowMultiple = $false
    [System.Collections.Generic.HashSet[int]] $SelectedIndices
    [scriptblock] $OnSelectAction
    [scriptblock] $OnCancelAction
    
    ListDialog([string]$title, [string]$prompt, [string[]]$items, [scriptblock]$onSelect, [scriptblock]$onCancel) : base("ListDialog") {
        $this.Title = $title
        $this.Prompt = $prompt
        $this.Items = $items
        $this.OnSelectAction = $onSelect
        $this.OnCancelAction = $onCancel
        $this.SelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
        
        # Calculate dimensions
        $maxItemWidth = ($items | Measure-Object -Property Length -Maximum).Maximum
        $this.Width = [Math]::Min(80, [Math]::Max(40, $maxItemWidth + 10))
        $this.VisibleItems = [Math]::Min(10, $items.Count)
        $this.Height = $this.VisibleItems + 8
    }
    
    [void] RenderDialogContent() {
        # Render prompt
        if ($this.Prompt) {
            $promptY = 2
            $promptX = 4
            Write-TuiText -Buffer $this._private_buffer -X $promptX -Y $promptY `
                -Text $this.Prompt -ForegroundColor [ConsoleColor]::White
        }
        
        # List area
        $listY = 4
        $listX = 4
        $listWidth = $this.Width - 8
        
        # Render visible items
        $endIndex = [Math]::Min($this.ScrollOffset + $this.VisibleItems, $this.Items.Count)
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $relativeY = $listY + ($i - $this.ScrollOffset)
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex)
            $isChecked = $this.SelectedIndices.Contains($i)
            
            # Truncate if too long
            if ($item.Length -gt ($listWidth - 4)) {
                $item = $item.Substring(0, $listWidth - 7) + "..."
            }
            
            # Format item
            $prefix = ""
            if ($this.AllowMultiple) {
                $prefix = if ($isChecked) { "[x] " } else { "[ ] " }
            }
            $displayText = "$prefix$item"
            
            # Colors
            $fg = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::Gray }
            $bg = if ($isSelected) { [ConsoleColor]::DarkGray } else { [ConsoleColor]::Black }
            
            # Clear line and write
            Write-TuiText -Buffer $this._private_buffer -X $listX -Y $relativeY `
                -Text (' ' * $listWidth) -BackgroundColor $bg
            Write-TuiText -Buffer $this._private_buffer -X $listX -Y $relativeY `
                -Text $displayText -ForegroundColor $fg -BackgroundColor $bg
        }
        
        # Scroll indicators
        if ($this.ScrollOffset -gt 0) {
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 5) -Y $listY `
                -Text "▲" -ForegroundColor [ConsoleColor]::DarkGray
        }
        if ($endIndex -lt $this.Items.Count) {
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 5) -Y ($listY + $this.VisibleItems - 1) `
                -Text "▼" -ForegroundColor [ConsoleColor]::DarkGray
        }
        
        # Instructions
        $instructY = $this.Height - 3
        $instructions = if ($this.AllowMultiple) { 
            "Space: Toggle, Enter: Confirm, Esc: Cancel" 
        } else { 
            "Enter: Select, Esc: Cancel" 
        }
        $instructX = [Math]::Floor(($this.Width - $instructions.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $instructX -Y $instructY `
            -Text $instructions -ForegroundColor [ConsoleColor]::DarkGray
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    if ($this.SelectedIndex -lt $this.ScrollOffset) {
                        $this.ScrollOffset = $this.SelectedIndex
                    }
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                    $this.SelectedIndex++
                    if ($this.SelectedIndex -ge ($this.ScrollOffset + $this.VisibleItems)) {
                        $this.ScrollOffset = $this.SelectedIndex - $this.VisibleItems + 1
                    }
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Spacebar) {
                if ($this.AllowMultiple) {
                    if ($this.SelectedIndices.Contains($this.SelectedIndex)) {
                        [void]$this.SelectedIndices.Remove($this.SelectedIndex)
                    } else {
                        [void]$this.SelectedIndices.Add($this.SelectedIndex)
                    }
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                $this.OnSelect()
                return $true
            }
            ([ConsoleKey]::Escape) {
                $this.OnCancel()
                return $true
            }
        }
        return $false
    }
    
    [void] OnSelect() {
        $this.Close()
        if ($this.OnSelectAction) {
            if ($this.AllowMultiple) {
                $selectedItems = @()
                foreach ($index in $this.SelectedIndices) {
                    $selectedItems += $this.Items[$index]
                }
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction $selectedItems
                }
            } else {
                $selectedItem = $this.Items[$this.SelectedIndex]
                Invoke-WithErrorHandling -Component "ListDialog" -Context "OnSelect" -ScriptBlock {
                    & $this.OnSelectAction $selectedItem
                }
            }
        }
    }
    
    [void] OnCancel() {
        $this.Close()
        if ($this.OnCancelAction) {
            Invoke-WithErrorHandling -Component "ListDialog" -Context "OnCancel" -ScriptBlock $this.OnCancelAction
        }
    }
}

# Helper function for word wrapping
function Get-WordWrappedLines {
    param([string]$Text, [int]$MaxWidth)
    
    $lines = @()
    $words = $Text -split '\s+'
    $currentLine = ""
    
    foreach ($word in $words) {
        if ($currentLine.Length -eq 0) {
            $currentLine = $word
        } elseif (($currentLine.Length + 1 + $word.Length) -le $MaxWidth) {
            $currentLine += " " + $word
        } else {
            $lines += $currentLine
            $currentLine = $word
        }
    }
    
    if ($currentLine.Length -gt 0) {
        $lines += $currentLine
    }
    
    return $lines
}

$script:DialogState = @{ CurrentDialog = $null; DialogStack = [System.Collections.Stack]::new() }

function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem" -Context "Initialize" -ScriptBlock {
        Subscribe-Event -EventName "Confirm.Request" -Handler { param($EventData)
            $params = $EventData.Data; Show-ConfirmDialog @params }
        Subscribe-Event -EventName "Alert.Show" -Handler { param($EventData)
            $params = $EventData.Data; Show-AlertDialog @params }
        Subscribe-Event -EventName "Input.Request" -Handler { param($EventData)
            $params = $EventData.Data; Show-InputDialog @params }
        Write-Log -Level Info -Message "Class-based Dialog System initialized"
    }
}

function Show-AlertDialog { param([string]$Title="Alert", [string]$Message); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowAlertDialog" -ScriptBlock { ([AlertDialog]::new($Title, $Message)).Show() } }
function Show-ConfirmDialog { param([string]$Title="Confirm", [string]$Message, [scriptblock]$OnConfirm, [scriptblock]$OnCancel={}); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowConfirmDialog" -ScriptBlock { ([ConfirmDialog]::new($Title, $Message, $OnConfirm, $OnCancel)).Show() } }
function Show-InputDialog { param([string]$Title="Input", [string]$Prompt, [string]$DefaultValue="", [scriptblock]$OnSubmit, [scriptblock]$OnCancel={}); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowInputDialog" -ScriptBlock { $d = [InputDialog]::new($Title, $Prompt, $OnSubmit, $OnCancel); if ($DefaultValue) { $d.SetDefaultValue($DefaultValue) }; $d.Show() } }
function Show-ProgressDialog { param([string]$Title="Progress", [string]$Message="Processing...", [int]$PercentComplete=0, [switch]$ShowCancel); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowProgressDialog" -ScriptBlock { $d = [ProgressDialog]::new($Title, $Message); $d.PercentComplete = $PercentComplete; $d.ShowCancel = $ShowCancel; $d.Show(); return $d } }
function Show-ListDialog { param([string]$Title="Select Item", [string]$Prompt="Choose an item:", [string[]]$Items, [scriptblock]$OnSelect, [scriptblock]$OnCancel={}, [switch]$AllowMultiple); Invoke-WithErrorHandling -Component "DialogSystem" -Context "ShowListDialog" -ScriptBlock { $d = [ListDialog]::new($Title, $Prompt, $Items, $OnSelect, $OnCancel); $d.AllowMultiple = $AllowMultiple; $d.Show() } }
function Close-TuiDialog { Invoke-WithErrorHandling -Component "DialogSystem" -Context "CloseDialog" -ScriptBlock { if ($script:DialogState.CurrentDialog) { $script:DialogState.CurrentDialog.Close() } } }

# --- END OF ORIGINAL FILE: modules\dialog-system-class\dialog-system-class.psm1 ---


# --- START OF ORIGINAL FILE: modules\data-manager\data-manager.psm1 ---


####\modules\data-manager.psm1
# Data Manager Module
# Unified data persistence and CRUD operations with event integration

# AI: FIX - Corrected relative paths for all dependencies.
# $ErrorActionPreference = "Stop"  # This causes silent failures during dot-sourcing

# Module-level state variables
$script:Data = @{
    Projects = New-Object System.Collections.ArrayList
    Tasks = New-Object System.Collections.ArrayList
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    time_entries = @() # underscore format for action compatibility
    timers = @()       # for action compatibility
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system, loads data, and returns a service instance.
    #>
    [CmdletBinding()]
    param()
    
    return Invoke-WithErrorHandling -Component "DataManager.Initialize" -Context "DataManager initialization" -ScriptBlock {
        $dataDirectory = Split-Path $script:DataPath -Parent
        if (-not (Test-Path $dataDirectory)) {
            New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
            Write-Log -Level Info -Message "Created data directory: $dataDirectory"
        }
        
        if (-not (Test-Path $script:BackupPath)) {
            New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
            Write-Log -Level Info -Message "Created backup directory: $script:BackupPath"
        }
        
        Load-UnifiedData
        Initialize-DataEventHandlers
        
        Write-Log -Level Info -Message "DataManager initialized successfully"
        return [DataManager]::new()
    }
}

function Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads application data from disk into strongly-typed objects.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.LoadData" -Context "Loading unified data from disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            try {
                $loadedData = Get-Content -Path $script:DataPath -Raw | ConvertFrom-Json -AsHashtable
                
                if ($loadedData -is [hashtable]) {
                    if ($loadedData.Tasks) {
                        $script:Data.Tasks.Clear()
                        foreach ($taskData in $loadedData.Tasks) {
                            if ($taskData -is [hashtable]) { 
                                $task = [PSCustomObject]$taskData
                                $task.PSObject.TypeNames.Insert(0, 'PmcTask')
                                $script:Data.Tasks.Add($task) | Out-Null
                            }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Tasks.Count) tasks as PmcTask objects"
                    }
                    
                    if ($loadedData.Projects -is [hashtable]) {
                        $script:Data.Projects.Clear()
                        foreach ($projectKey in $loadedData.Projects.Keys) {
                            $projectData = $loadedData.Projects[$projectKey]
                            if ($projectData -is [hashtable]) { $script:Data.Projects.Add([PmcProject]::FromLegacyFormat($projectData)) }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Projects.Count) projects as PmcProject objects"
                    }
                    
                    foreach ($key in 'TimeEntries', 'ActiveTimers', 'TodoTemplates', 'Settings', 'time_entries', 'timers') {
                        if ($loadedData.ContainsKey($key)) { $script:Data[$key] = $loadedData[$key] }
                    }
                    
                    $global:Data = $script:Data
                    Write-Log -Level Info -Message "Data loaded successfully from disk"
                } else {
                    Write-Log -Level Warning -Message "Invalid data format in file, using defaults"
                    $global:Data = $script:Data
                }
            } catch {
                Write-Log -Level Error -Message "Failed to parse data file: $_"
                $global:Data = $script:Data
            }
        } else {
            Write-Log -Level Info -Message "No existing data file found, using defaults"
            $global:Data = $script:Data
        }
        
        $script:LastSaveTime = Get-Date
    }
}

function Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves application data to disk with backup rotation.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.SaveData" -Context "Saving unified data to disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
            Copy-Item -Path $script:DataPath -Destination (Join-Path $script:BackupPath $backupName) -Force
            
            $backups = Get-ChildItem -Path $script:BackupPath -Filter "pmc-data_*.json" | Sort-Object LastWriteTime -Descending
            if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                $backups | Select-Object -Skip $script:Data.Settings.BackupCount | Remove-Item -Force
            }
        }
        
        $dataToSave = @{
            Tasks = @($script:Data.Tasks | ForEach-Object { $_.ToLegacyFormat() })
            Projects = @{}
            TimeEntries = $script:Data.TimeEntries
            ActiveTimers = $script:Data.ActiveTimers
            TodoTemplates = $script:Data.TodoTemplates
            Settings = $script:Data.Settings
            time_entries = $script:Data.time_entries
            timers = $script:Data.timers
        }
        
        foreach ($project in $script:Data.Projects) { $dataToSave.Projects[$project.Key] = $project.ToLegacyFormat() }
        
        $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $script:DataPath -Encoding UTF8
        $script:LastSaveTime = Get-Date; $script:DataModified = $false
        Write-Log -Level Debug -Message "Data saved successfully"
    }
}

#region Task Management Functions

function Add-PmcTask {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [ValidateNotNullOrEmpty()] [string]$Title,
        [string]$Description = "",
        [ValidateSet("low", "medium", "high")] [string]$Priority = "medium",
        [string]$Category = "General",
        [string]$DueDate = ""
    )
    
    return Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task" -ScriptBlock {
        if ([string]::IsNullOrWhiteSpace($Title)) { throw [StateMutationException]::new("Task title cannot be empty", @{ Title = $Title }) }
        
        $taskPriority = [TaskPriority]::$Priority
        $newTask = [PmcTask]::new($Title, $Description, $taskPriority, $Category)
        
        if ($DueDate -and $DueDate -ne "N/A") {
            try { $newTask.DueDate = [datetime]::Parse($DueDate) } catch { Write-Log -Level Warning -Message "Invalid due date format: $DueDate" }
        }
        
        $script:Data.Tasks.Add($newTask); $script:DataModified = $true
        Write-Log -Level Info -Message "Created task '$($newTask.Title)' with ID $($newTask.Id)"
        
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        
        Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Created"; TaskId = $newTask.Id; Task = $newTask }
        return $newTask
    }
}

function Update-PmcTask {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [PmcTask]$Task,
        [string]$Title, [string]$Description, [ValidateSet("low", "medium", "high")] [string]$Priority,
        [string]$Category, [string]$DueDate, [bool]$Completed, [ValidateRange(0, 100)] [int]$Progress
    )
    
    return Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating task" -ScriptBlock {
        $managedTask = $script:Data.Tasks.Find({$_.Id -eq $Task.Id})
        if (-not $managedTask) { throw [StateMutationException]::new("Task not found in data store", @{ TaskId = $Task.Id }) }
        
        $updatedFields = @()
        if ($PSBoundParameters.ContainsKey('Title')) { $managedTask.Title = $Title.Trim(); $updatedFields += "Title" }
        if ($PSBoundParameters.ContainsKey('Description')) { $managedTask.Description = $Description; $updatedFields += "Description" }
        if ($PSBoundParameters.ContainsKey('Priority')) { $managedTask.Priority = [TaskPriority]::$Priority; $updatedFields += "Priority" }
        if ($PSBoundParameters.ContainsKey('Category')) { $managedTask.ProjectKey = $Category; $managedTask.Category = $Category; $updatedFields += "Category" }
        if ($PSBoundParameters.ContainsKey('DueDate')) {
            try { $managedTask.DueDate = ($DueDate -and $DueDate -ne "N/A") ? [datetime]::Parse($DueDate) : $null } catch { Write-Log -Level Warning -Message "Invalid due date format: $DueDate" }
            $updatedFields += "DueDate"
        }
        if ($PSBoundParameters.ContainsKey('Progress')) { $managedTask.UpdateProgress($Progress); $updatedFields += "Progress" }
        if ($PSBoundParameters.ContainsKey('Completed')) {
            if ($Completed) { $managedTask.Complete() } else { $managedTask.Status = [TaskStatus]::Pending; $managedTask.Completed = $false; $managedTask.Progress = 0 }
            $updatedFields += "Completed"
        }
        
        $managedTask.UpdatedAt = [datetime]::Now; $script:DataModified = $true
        Write-Log -Level Info -Message "Updated task $($managedTask.Id) - Fields: $($updatedFields -join ', ')"
        
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        
        Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Updated"; TaskId = $managedTask.Id; Task = $managedTask; UpdatedFields = $updatedFields }
        return $managedTask
    }
}

function Remove-PmcTask {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [PmcTask]$Task)
    
    return Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task" -ScriptBlock {
        $taskToRemove = $script:Data.Tasks.Find({$_.Id -eq $Task.Id})
        if ($taskToRemove) {
            $script:Data.Tasks.Remove($taskToRemove) | Out-Null; $script:DataModified = $true
            Write-Log -Level Info -Message "Deleted task $($Task.Id)"
            if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Deleted"; TaskId = $Task.Id; Task = $Task }
            return $true
        }
        Write-Log -Level Warning -Message "Task not found with ID $($Task.Id)"; return $false
    }
}

function Get-PmcTasks {
    [CmdletBinding()]
    param([bool]$Completed, [ValidateSet("low", "medium", "high")] [string]$Priority, [string]$Category)
    
    return Invoke-WithErrorHandling -Component "DataManager.GetTasks" -Context "Retrieving tasks" -ScriptBlock {
        $tasks = $script:Data.Tasks
        if ($PSBoundParameters.ContainsKey('Completed')) { $tasks = $tasks | Where-Object { $_.Completed -eq $Completed } }
        if ($Priority) { $priorityEnum = [TaskPriority]::$Priority; $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum } }
        if ($Category) { $tasks = $tasks | Where-Object { $_.ProjectKey -eq $Category -or $_.Category -eq $Category } }
        return @($tasks)
    }
}

#endregion

#region Project Management Functions

function Get-PmcProjects { [CmdletBinding()] param() return @($script:Data.Projects) }
function Get-PmcProject { [CmdletBinding()] param([Parameter(Mandatory)] [string]$Key) return $script:Data.Projects.Find({$_.Key -eq $Key}) }

function Add-PmcProject {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [PmcProject]$Project)
    
    return Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding project" -ScriptBlock {
        if ($script:Data.Projects.Exists({$_.Key -eq $Project.Key})) { throw [StateMutationException]::new("Project with key '$($Project.Key)' already exists", @{ ProjectKey = $Project.Key }) }
        
        $script:Data.Projects.Add($Project); $script:DataModified = $true
        Write-Log -Level Info -Message "Created project '$($Project.Name)' with key $($Project.Key)"
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Created"; ProjectKey = $Project.Key; Project = $Project }
        return $Project
    }
}

#endregion

#region DataManager Class Definition

# DataManager class moved to data-manager-class.psm1 to resolve dependency issues

#endregion

#region Private Helper Functions

function Initialize-DataEventHandlers {
    Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -Context "Initializing data event handlers" -ScriptBlock {
        $null = Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Refreshed"; Tasks = @($script:Data.Tasks) }
        }
        Write-Log -Level Debug -Message "Data event handlers initialized"
    }
}

#endregion

# --- END OF ORIGINAL FILE: modules\data-manager\data-manager.psm1 ---


# --- START OF ORIGINAL FILE: services\keybinding-service\keybinding-service.psm1 ---


# keybinding-service.psm1
# Contains only the factory function for creating KeybindingService instances.

function New-KeybindingService {
    <#
    .SYNOPSIS
    Creates a new instance of the KeybindingService class.
    #>
    [CmdletBinding()]
    param(
        [switch]$EnableChords
    )
    
    if ($EnableChords) {
        return [KeybindingService]::new($true)
    }
    else {
        return [KeybindingService]::new()
    }
}

# --- END OF ORIGINAL FILE: services\keybinding-service\keybinding-service.psm1 ---


# --- START OF ORIGINAL FILE: services\navigation-service\navigation-service.psm1 ---


# navigation-service-functions.psm1
# Contains only the factory function for the NavigationService.

function Initialize-NavigationService {
    param([hashtable]$Services)
    if (-not $Services) { throw [System.ArgumentNullException]::new("Services") }
    return [NavigationService]::new($Services)
}

# --- END OF ORIGINAL FILE: services\navigation-service\navigation-service.psm1 ---


# --- START OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---


# TUI Engine v5.1 - NCurses Compositor Edition
# Implements NCurses-style compositor with private buffers and TuiCell rendering

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    CompositorBuffer = $null    # AI: NEW - Master compositor buffer (TuiBuffer)
    PreviousCompositorBuffer = $null # AI: NEW - Buffer for diffing against the main compositor
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
    CompositorMode  = $true     # AI: NEW - Enable NCurses-style rendering
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine v5.1 (NCurses Compositor): ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        
        # AI: ENHANCED - Create both legacy buffers and new TuiBuffer compositor
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($Width, $Height, "MainCompositor")
        $global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new($Width, $Height, "PreviousCompositor")
        
        # Initialize legacy buffers for compatibility
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        # AI: FIX - Subscribe to refresh requests to decouple dialog system
        Subscribe-Event -EventName "TUI.RefreshRequested" -Handler {
            Request-TuiRefresh
        } -Source "TuiEngine"

        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height; CompositorMode = $global:TuiState.CompositorMode }
        Write-Log -Level Info -Message "TUI Engine v5.1 initialized successfully (Compositor Mode: $($global:TuiState.CompositorMode))"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent) {
        try { 
            # AI: ENHANCED - Better class detection for UIElement-based components
                        if ($focusedComponent -is [UIElement]) {
                # New UIElement-based component
                $focusedComponent.HandleInput($keyInfo)
            }
            elseif ($focusedComponent.PSObject.TypeNames -contains 'UIElement' -or $focusedComponent.GetType().IsSubclassOf([UIElement])) {
                # Class-based component (legacy detection)
                if ($focusedComponent.PSObject.Methods.Name -contains 'HandleInput') {
                    $focusedComponent.HandleInput($keyInfo)
                }
            }
            elseif ($focusedComponent.HandleInput) {
                # Functional component with HandleInput scriptblock
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return }
            }
        } catch { 
            Write-Warning "Component input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for component '$($focusedComponent.Name)': $_"
        }
    }
    
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            # AI: ENHANCED - Support for UIElement-based screens
            if ($currentScreen -is [UIElement]) {
                # New UIElement-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen -is [Screen]) {
                # Legacy class-based screen
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen.HandleInput) {
                # Hashtable/functional screen - use scriptblock invocation
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { Stop-TuiEngine }
                }
            }
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([object]$InitialScreen)  # AI: Accept both UIElement and hashtable screens
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

# AI: REWRITTEN - NCurses Compositor Render-Frame
function Render-Frame {
    try {
        $global:TuiState.RenderStats.FrameCount++
        
        if ($global:TuiState.CompositorMode -and $null -ne $global:TuiState.CompositorBuffer) {
            # AI: NEW - NCurses-style compositor rendering
            Render-FrameCompositor
        } else {
            # AI: LEGACY - Fall back to old rendering for compatibility
            Render-FrameLegacy
        }
        
        # AI: NEW - After rendering, copy the current compositor state to the previous state buffer for the next frame's diff.
        if ($global:TuiState.CompositorMode) {
            $global:TuiState.PreviousCompositorBuffer.Clear()
            $global:TuiState.PreviousCompositorBuffer.BlendBuffer($global:TuiState.CompositorBuffer, 0, 0)
        }
        
        # Position the cursor out of the way to prevent visual artifacts
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Log -Level Error -Message "A fatal error occurred during Render-Frame: $_" -Data $_
    }
}

function Render-FrameCompositor {
    # AI: NEW - NCurses-style compositor rendering pipeline
    try {
        # 1. Clear the master compositor buffer
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, (Get-ThemeColor "Background"))
        $global:TuiState.CompositorBuffer.Clear($clearCell)
        
        # 2. Render current screen to its private buffer, then composite
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component ($global:TuiState.CurrentScreen.Name ?? "Screen") -Context "Screen Render" -ScriptBlock {
                if ($global:TuiState.CurrentScreen -is [UIElement]) {
                    # New UIElement-based screen - render to its private buffer
                    $global:TuiState.CurrentScreen.Render()
                    
                    # Composite screen buffer onto master compositor
                    $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
                    if ($null -ne $screenBuffer) {
                        $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                    }
                } else {
                    # Legacy screen - render directly (will be deprecated)
                    $global:TuiState.CurrentScreen.Render()
                }
            }
        }
        
        # 3. Render dialogs on top
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog -is [UIElement]) {
                    # New UIElement-based dialog
                    $dialog.Render()
                    $dialogBuffer = $dialog.GetBuffer()
                    if ($null -ne $dialogBuffer) {
                        $pos = $dialog.GetAbsolutePosition()
                        $global:TuiState.CompositorBuffer.BlendBuffer($dialogBuffer, $pos.X, $pos.Y)
                    }
                } elseif ($dialog.GetType().IsSubclassOf([UIElement])) {
                    # Class-based dialog with Render() method
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    # Functional/hashtable dialog with Render scriptblock
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        # 4. Convert TuiBuffer to console output with optimal diffing
        Render-CompositorToConsole
        
    } catch {
        Write-Log -Level Error -Message "Compositor rendering failed: $_" -Data $_
        # Fall back to legacy rendering
        Render-FrameLegacy
    }
}

function Render-CompositorToConsole {
    # AI: REWRITTEN - True TuiBuffer-to-TuiBuffer diffing.
    $outputBuilder = [System.Text.StringBuilder]::new(20000)
    $currentBuffer = $global:TuiState.CompositorBuffer
    $previousBuffer = $global:TuiState.PreviousCompositorBuffer
    $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 1

    try {
        for ($y = 0; $y -lt $currentBuffer.Height; $y++) {
            $rowChanged = $false
            for ($x = 0; $x -lt $currentBuffer.Width; $x++) {
                $newCell = $currentBuffer.GetCell($x, $y)
                $oldCell = $previousBuffer.GetCell($x, $y)
                
                if ($forceFullRender -or $newCell.DiffersFrom($oldCell)) {
                    if (-not $rowChanged) {
                        [void]$outputBuilder.Append("`e[$($y + 1);1H")
                        # On the first change in a row, we must move the cursor.
                        # For subsequent changes, we need to move it again if there was a gap.
                        if ($x > 0) { [void]$outputBuilder.Append("`e[$($y + 1);$($x + 1)H") }
                        $rowChanged = $true
                    }

                    if ($newCell.ForegroundColor -ne $lastFG -or $newCell.BackgroundColor -ne $lastBG) {
                        $fgCode = Get-AnsiColorCode $newCell.ForegroundColor
                        $bgCode = Get-AnsiColorCode $newCell.BackgroundColor -IsBackground $true
                        [void]$outputBuilder.Append("`e[${fgCode};${bgCode}m")
                        $lastFG = $newCell.ForegroundColor
                        $lastBG = $newCell.BackgroundColor
                    }
                    [void]$outputBuilder.Append($newCell.Char)
                } elseif ($rowChanged) {
                    # If a change occurred in this row previously, but this cell is the same,
                    # we need to move the cursor to the next potential change point.
                    [void]$outputBuilder.Append("`e[$($y + 1);$($x + 2)H")
                }
            }
        }
        
        # Reset colors at the end
        if ($lastFG -ne -1) { [void]$outputBuilder.Append("`e[0m") }
        
        if ($outputBuilder.Length -gt 10) {
            [Console]::Write($outputBuilder.ToString())
        }
    } catch {
        Write-Log -Level Error -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}

function Render-FrameLegacy {
    # AI: LEGACY - Original rendering code for compatibility
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        if ($global:TuiState.CurrentScreen) {
            Invoke-WithErrorHandling -Component $global:TuiState.CurrentScreen.Name -Context "Screen Render" -ScriptBlock {
                $global:TuiState.CurrentScreen.Render()
            }
        }
        
        $dialog = Get-CurrentDialog
        if ($dialog) {
            Invoke-WithErrorHandling -Component ($dialog.Name ?? $dialog.Type ?? "Dialog") -Context "Dialog Render" -ScriptBlock {
                if ($dialog.GetType().IsSubclassOf([UIElement]) -or $dialog -is [UIElement]) {
                    $dialog.Render()
                } elseif ($dialog -is [hashtable] -and $dialog.Render) {
                    & $dialog.Render -self $dialog
                } else {
                    Write-Log -Level Warning -Message "Unknown dialog type: $($dialog.GetType().Name)"
                }
            }
        }
        
        Render-BufferOptimized
        
    } catch {
        Write-Log -Level Error -Message "Legacy rendering failed: $_" -Data $_
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    # AI: ENHANCED - Accept both UIElement and legacy screen objects
    param([object]$Screen)
    if (-not $Screen) { return }
    
    $screenName = if ($Screen -is [UIElement]) { $Screen.Name } elseif ($Screen -is [Screen]) { $Screen.Name } else { $Screen.Name }
    Write-Log -Level Debug -Message "Pushing screen: $screenName"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($global:TuiState.CurrentScreen) {
            # Handle exit for current screen
            if ($global:TuiState.CurrentScreen -is [UIElement]) {
                # New UIElement-based screen
                # No explicit OnExit method - handled by framework
            } elseif ($global:TuiState.CurrentScreen -is [Screen]) {
                # Legacy class-based screen
                $global:TuiState.CurrentScreen.OnExit()
            } elseif ($global:TuiState.CurrentScreen.OnExit) {
                # Functional screen
                $global:TuiState.CurrentScreen.OnExit.Invoke()
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # Initialize new screen
        if ($Screen -is [UIElement]) {
            # New UIElement-based screen - ensure it's sized to fit screen
            if ($Screen.Width -eq 10 -and $Screen.Height -eq 3) {  # Default size
                $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            }
            # Trigger initial render
            $Screen.RequestRedraw()
        } elseif ($Screen -is [Screen]) {
            # Legacy class-based screen
            $Screen.OnEnter()
        } elseif ($Screen.Init) { 
            # Functional screen
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $screenName }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$screenName': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $global:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering - Legacy Support
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:TuiState.BufferWidth) { break }
        if ($currentX -ge 0) { $global:TuiState.BackBuffer[$Y, $currentX] = @{ Char = $char; FG = $ForegroundColor; BG = $BackgroundColor } }
        $currentX++
    }
}

function Write-BufferBox {
    param([int]$X, [int]$Y, [int]$Width, [int]$Height, [string]$BorderStyle = "Single", [ConsoleColor]$BorderColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, [string]$Title = "")
    $borders = Get-BorderChars -Style $BorderStyle
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    if ($Title) {
        $titleText = " $Title "; if ($titleText.Length -gt ($Width-2)) { $titleText = " $($Title.Substring(0,[Math]::Max(0,$Width-5)))... " }
        Write-BufferString -X ($X + [Math]::Floor(($Width - $titleText.Length) / 2)) -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function Render-BufferOptimized {
    $outputBuilder = [System.Text.StringBuilder]::new(20000); $lastFG = -1; $lastBG = -1
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 0
    try {
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $backCell = $global:TuiState.BackBuffer[$y, $x]; $frontCell = $global:TuiState.FrontBuffer[$y, $x]
                if (-not $forceFullRender -and $backCell.Char -eq $frontCell.Char -and $backCell.FG -eq $frontCell.FG -and $backCell.BG -eq $frontCell.BG) { continue }
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) { $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null }
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG; $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null; $lastFG = $backCell.FG; $lastBG = $backCell.BG
                }
                $outputBuilder.Append($backCell.Char) | Out-Null
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = $backCell.Char; FG = $backCell.FG; BG = $backCell.BG }
            }
        }
        $outputBuilder.Append("`e[0m") | Out-Null
        if ($outputBuilder.Length -gt 0) { [Console]::Write($outputBuilder.ToString()) }
    } catch { Write-Warning "Render error: $_" }
}
#endregion

#region Component System - Enhanced for UIElement
function Initialize-ComponentSystem { $global:TuiState.Components = @(); $global:TuiState.FocusedComponent = $null }

function Register-Component { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    $global:TuiState.Components += $Component
    
    # Initialize component based on type
    if ($Component -is [UIElement]) {
        # New UIElement-based component - no explicit init needed
        Write-Log -Level Debug -Message "Registered UIElement component: $($Component.Name)"
    } elseif ($Component.Init) { 
        try { & $Component.Init -self $Component } catch { Write-Warning "Component init error: $_" } 
    }
    return $Component 
}

function Set-ComponentFocus { 
    param([object]$Component)  # AI: Accept both UIElement and hashtable components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) { return }
    
    # Blur current component
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    
    # Set new focused component
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $Component }
    $global:TuiState.FocusedComponent = $Component
    
    # Focus new component
    if ($null -ne $Component) {
        if ($Component -is [UIElement]) {
            $Component.OnFocus()
        } else {
            $Component.OnFocus?.Invoke()
        }
    }
    
    Request-TuiRefresh 
}

function Clear-ComponentFocus { 
    if ($null -ne $global:TuiState.FocusedComponent) {
        if ($global:TuiState.FocusedComponent -is [UIElement]) {
            $global:TuiState.FocusedComponent.OnBlur()
        } else {
            $global:TuiState.FocusedComponent.OnBlur?.Invoke()
        }
    }
    $global:TuiState.FocusedComponent = $null
    if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.LastFocusedComponent = $null }
    Request-TuiRefresh 
}

# AI: ENHANCED - Support UIElement focusable detection
function Get-NextFocusableComponent { 
    param([object]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = @()
    
    function Find-Focusable([object]$Comp) { 
        if ($Comp -is [UIElement]) {
            # New UIElement-based component
            if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
                $focusableComponents += $Comp
            }
            # Check children
            foreach ($child in $Comp.Children) {
                Find-Focusable $child
            }
        } else {
            # Legacy component
            if ($Comp.IsFocusable -eq $true -and $Comp.Visible -ne $false) { 
                $focusableComponents += $Comp 
            }
            if ($Comp.Children) { 
                foreach ($c in $Comp.Children) { Find-Focusable $c } 
            }
        }
    }
    
    # Find focusable components in current screen
    if ($global:TuiState.CurrentScreen -is [UIElement]) {
        Find-Focusable $global:TuiState.CurrentScreen
    } elseif ($global:TuiState.CurrentScreen.Components) { 
        foreach ($c in $global:TuiState.CurrentScreen.Components.Values) { Find-Focusable $c } 
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by tab index and position
    $sorted = $focusableComponents | Sort-Object { 
        if ($_ -is [UIElement]) {
            $_.TabIndex * 10000 + $_.Y * 100 + $_.X
        } else {
            ($_.TabIndex ?? 0) * 10000 + ($_.Y ?? 0) * 100 + ($_.X ?? 0)
        }
    }
    
    if ($Reverse) { [Array]::Reverse($sorted) }
    
    $currentIndex = [array]::IndexOf($sorted, $CurrentComponent)
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        return $sorted[0] 
    } 
}

function Handle-TabNavigation { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

# AI: LEGACY - Helper functions maintained for compatibility
function Get-FocusedComponent { return $global:TuiState.FocusedComponent }
function Move-Focus { param([bool]$Reverse = $false); Handle-TabNavigation -Reverse $Reverse }

function Get-CurrentDialog {
    # AI: REFACTORED - This function now directly and reliably accesses the dialog state
    # from the single, class-based dialog system.
    try {
        if (Get-Command 'Initialize-DialogSystem' -ErrorAction SilentlyContinue) {
            # This retrieves the $script:DialogState variable from the script's scope.
            return $script:DialogState.CurrentDialog
        }
    } catch {
        Write-Log -Level Error -Message "Critical error accessing dialog system state: $_"
    }
    return $null
}

function Handle-DialogInput {
    param([System.ConsoleKeyInfo]$Key)
    # AI: REFACTORED - Simplified to work only with the new UIElement-based dialogs.
    try {
        $dialog = Get-CurrentDialog
        if ($dialog -and $dialog -is [UIElement]) {
            # All dialogs are now UIElements and have a HandleInput method.
            return $dialog.HandleInput($Key)
        }
    } catch {
        Write-Log -Level Error -Message "Error handling dialog input: $_"
    }
    return $false
}

function Update-DialogSystem {
    # Dialog system handles its own updates if loaded
}

function Stop-AllTuiAsyncJobs {
    Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)"
}
#endregion

#region Layout Management & Utilities
function Initialize-LayoutEngines { $global:TuiState.Layouts = @{} }
function Get-BorderChars { param([string]$Style); $styles = @{ Single=@{TopLeft='┌';TopRight='┐';BottomLeft='└';BottomRight='┘';Horizontal='─';Vertical='│'}; Double=@{TopLeft='╔';TopRight='╗';BottomLeft='╚';BottomRight='╝';Horizontal='═';Vertical='║'}; Rounded=@{TopLeft='╭';TopRight='╮';BottomLeft='╰';BottomRight='╯';Horizontal='─';Vertical='│'} }; return $styles[$Style] ?? $styles.Single }
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Get-WordWrappedLines { param([string]$Text, [int]$MaxWidth); if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }; $lines = @(); $words = $Text -split '\s+'; $sb = [System.Text.StringBuilder]::new(); foreach ($word in $words) { if ($sb.Length -eq 0) { [void]$sb.Append($word) } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) { [void]$sb.Append(' ').Append($word) } else { $lines += $sb.ToString(); [void]$sb.Clear().Append($word) } }; if ($sb.Length -gt 0) { $lines += $sb.ToString() }; return $lines }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $global:TuiState.Running = $false; $global:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }

# AI: NEW - Compositor helper functions
function Get-ThemeColor {
    param([string]$ColorName)
    # Simple theme color mapping - can be enhanced later
    $themeColors = @{
        Background = [ConsoleColor]::Black
        Foreground = [ConsoleColor]::White
        Border = [ConsoleColor]::Gray
        Focus = [ConsoleColor]::Cyan
        Highlight = [ConsoleColor]::Yellow
    }
    return $themeColors[$ColorName] ?? [ConsoleColor]::Black
}
#endregion

# --- END OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---


# --- START OF ORIGINAL FILE: modules\tui-framework\tui-framework.psm1 ---


# TUI Framework Integration Module
# Contains utility functions for interacting with the TUI engine and components.
# AI: FIX - Added all missing dependencies.

$script:TuiAsyncJobs = @()

function Invoke-TuiMethod {
    <# .SYNOPSIS Safely invokes a method on a TUI component. #>
    param(
        [Parameter(Mandatory)] [hashtable]$Component,
        [Parameter(Mandatory)] [string]$MethodName,
        [Parameter()] [hashtable]$Arguments = @{}
    )
    if (-not $Component) { return }
    $method = $Component[$MethodName]
    if (-not ($method -is [scriptblock])) { return }

    $Arguments['self'] = $Component
    Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock { & $method @Arguments }
}

function Initialize-TuiFramework {
    Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {
        if (-not $global:TuiState) { throw "TUI Engine must be initialized before the TUI Framework." }
        Write-Log -Level Info -Message "TUI Framework initialized."
    }
}

function Invoke-TuiAsync {
    <# .SYNOPSIS Executes a script block asynchronously with job management. #>
    param(
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [string]$JobName = "TuiAsyncJob_$(Get-Random)",
        [hashtable]$ArgumentList = @{}
    )
    Invoke-WithErrorHandling -Component "TuiFramework.Async" -Context "Starting async job: $JobName" -ScriptBlock {
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList -Name $JobName
        $script:TuiAsyncJobs += $job
        Write-Log -Level Debug -Message "Started async job: $JobName" -Data @{ JobId = $job.Id }
        return $job
    }
}

function Get-TuiAsyncResults {
    <# .SYNOPSIS Checks for completed async jobs and returns their results. #>
    param([switch]$RemoveCompleted = $true)
    Invoke-WithErrorHandling -Component "TuiFramework.AsyncResults" -Context "Checking async job results" -ScriptBlock {
        $results = @()
        $completedJobs = $script:TuiAsyncJobs | Where-Object { $_.State -in @('Completed', 'Failed', 'Stopped') }
        
        foreach ($job in $completedJobs) {
            $results += @{
                JobId = $job.Id; JobName = $job.Name; State = $job.State
                Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job } else { $null }
                Error = if ($job.State -eq 'Failed') { $job.ChildJobs[0].JobStateInfo.Reason } else { $null }
            }
            Write-Log -Level Debug -Message "Async job completed: $($job.Name)" -Data @{ JobId = $job.Id; State = $job.State }
        }
        
        if ($RemoveCompleted -and $completedJobs.Count -gt 0) {
            foreach ($job in $completedJobs) {
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                $script:TuiAsyncJobs = $script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id }
            }
        }
        return $results
    }
}

function Stop-AllTuiAsyncJobs {
    Invoke-WithErrorHandling -Component "TuiFramework.StopAsync" -Context "Stopping all async jobs" -ScriptBlock {
        foreach ($job in $script:TuiAsyncJobs) {
            try {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                Write-Log -Level Debug -Message "Stopped async job: $($job.Name)"
            } catch {
                Write-Log -Level Warning -Message "Failed to stop job $($job.Name): $_"
            }
        }
        $script:TuiAsyncJobs = @()
        Write-Log -Level Info -Message "All TUI async jobs stopped."
    }
}

function Request-TuiRefresh {
    if ($global:TuiState.RequestRefresh) { & $global:TuiState.RequestRefresh }
    else { Publish-Event -EventName "TUI.RefreshRequested" }
}

function Get-TuiState { return $global:TuiState }

function Test-TuiState {
    param([switch]$ThrowOnError)
    $isValid = $global:TuiState -and $global:TuiState.Running -and $global:TuiState.CurrentScreen
    if (-not $isValid -and $ThrowOnError) { throw "TUI state is not properly initialized. Call Initialize-TuiEngine first." }
    return $isValid
}

# --- END OF ORIGINAL FILE: modules\tui-framework\tui-framework.psm1 ---


# --- START OF ORIGINAL FILE: screens\dashboard-screen\dashboard-screen.psm1 ---


####\screens\dashboard\dashboard-screen.psm1
# ==============================================================================
# PMC Terminal v5 - NCurses Dashboard Screen
# Main entry screen with buffer-based rendering
# ==============================================================================

# AI: PHASE 3 REFACTORED - NCurses buffer-based architecture
class DashboardScreen : UIElement {
    # --- Core Architecture ---
    [hashtable] $Services
    [Panel] $MainPanel
    [Panel] $SummaryPanel
    [Panel] $MenuPanel
    [Panel] $StatusPanel
    [NavigationMenu] $MainMenu
    [System.Collections.Generic.List[UIElement]] $Components

    # --- State Management ---
    [object[]] $Tasks = @()
    [int] $TotalTasks = 0
    [int] $CompletedTasks = 0
    [int] $PendingTasks = 0

    # --- Constructor ---
    DashboardScreen([hashtable]$services) : base(0, 0, 120, 30) {
        $this.Name = "DashboardScreen"
        $this.Services = $services
        $this.Components = [System.Collections.Generic.List[UIElement]]::new()
        $this.IsFocusable = $true
        $this.Enabled = $true
        $this.Visible = $true
        $this.Tasks = @()
        
        Write-Log -Level Info -Message "Creating DashboardScreen with NCurses architecture"
    }

    # --- Initialization ---
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "Initialize" -ScriptBlock {
            # AI: PHASE 3 - Create main panel structure
            $this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "PMC Terminal v5 - Dashboard")
            $this.MainPanel.HasBorder = $true
            $this.MainPanel.BorderStyle = "Double"
            $this.MainPanel.BorderColor = [ConsoleColor]::Cyan
            $this.MainPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MainPanel.TitleColor = [ConsoleColor]::White
            $this.MainPanel.Name = "MainDashboardPanel"
            $this.AddChild($this.MainPanel)
            
            # AI: PHASE 3 - Summary panel (left side)
            $this.SummaryPanel = [Panel]::new(2, 2, 45, 12, "Task Summary")
            $this.SummaryPanel.HasBorder = $true
            $this.SummaryPanel.BorderStyle = "Single"
            $this.SummaryPanel.BorderColor = [ConsoleColor]::Green
            $this.SummaryPanel.BackgroundColor = [ConsoleColor]::Black
            $this.SummaryPanel.Name = "SummaryPanel"
            $this.MainPanel.AddChild($this.SummaryPanel)
            
            # AI: PHASE 3 - Menu panel (right side)
            $this.MenuPanel = [Panel]::new(49, 2, 50, 15, "Main Menu")
            $this.MenuPanel.HasBorder = $true
            $this.MenuPanel.BorderStyle = "Single"
            $this.MenuPanel.BorderColor = [ConsoleColor]::Yellow
            $this.MenuPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MenuPanel.Name = "MenuPanel"
            $this.MainPanel.AddChild($this.MenuPanel)
            
            # AI: PHASE 3 - Status panel (bottom)
            $this.StatusPanel = [Panel]::new(2, 19, 116, 8, "System Status")
            $this.StatusPanel.HasBorder = $true
            $this.StatusPanel.BorderStyle = "Single"
            $this.StatusPanel.BorderColor = [ConsoleColor]::Magenta
            $this.StatusPanel.BackgroundColor = [ConsoleColor]::Black
            $this.StatusPanel.Name = "StatusPanel"
            $this.MainPanel.AddChild($this.StatusPanel)
            
            # AI: PHASE 3 - Create navigation menu
            $this.MainMenu = [NavigationMenu]::new("MainMenu")
            $this.MainMenu.Move(1, 1)  # Inside menu panel
            $this.MainMenu.Resize(48, 13)
            $this.BuildMainMenu()
            $this.MenuPanel.AddChild($this.MainMenu)
            
            # AI: PHASE 3 - Load initial data and update display
            $this.RefreshData()
            $this.UpdateDisplay()
            
            Write-Log -Level Info -Message "DashboardScreen initialized with NCurses architecture"
        }
    }

    # --- Menu Building ---
    hidden [void] BuildMainMenu() {
        try {
            $this.MainMenu.AddItem([NavigationItem]::new("1", "Task Management", { 
                $this.Services.Navigation.GoTo("/tasks", @{}) 
            }))
            $this.MainMenu.AddItem([NavigationItem]::new("2", "Project Management", { 
                $this.Services.Navigation.GoTo("/projects", @{}) 
            }))
            $this.MainMenu.AddItem([NavigationItem]::new("3", "Settings", { 
                $this.Services.Navigation.GoTo("/settings", @{}) 
            }))
            $this.MainMenu.AddSeparator()
            $this.MainMenu.AddItem([NavigationItem]::new("Q", "Quit Application", { 
                $this.Services.Navigation.RequestExit() 
            }))
            
            Write-Log -Level Debug -Message "Main menu built with $($this.MainMenu.Items.Count) items"
        } catch {
            Write-Log -Level Error -Message "Failed to build main menu: $_"
        }
    }

    # --- Data Management ---
    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "RefreshData" -ScriptBlock {
            # AI: PHASE 3 - Safe data loading
            $this.Tasks = @()
            $this.TotalTasks = 0
            $this.CompletedTasks = 0
            $this.PendingTasks = 0
            
            if ($null -eq $this.Services.DataManager) {
                Write-Log -Level Warning -Message "DataManager service not available"
                return
            }
            
            try {
                $taskData = $this.Services.DataManager.GetTasks()
                $this.Tasks = if ($null -eq $taskData) { @() } else { @($taskData) }
                
                # AI: PHASE 3 - Calculate statistics
                $this.TotalTasks = $this.Tasks.Count
                
                if ($this.TotalTasks -gt 0) {
                    try {
                        $completedTasks = @($this.Tasks | Where-Object { 
                            $null -ne $_ -and $_.Status -eq [TaskStatus]::Completed 
                        })
                        $this.CompletedTasks = $completedTasks.Count
                        $this.PendingTasks = $this.TotalTasks - $this.CompletedTasks
                    } catch {
                        # AI: PHASE 3 - Fallback for enum issues
                        Write-Log -Level Warning -Message "TaskStatus enum not available, using string comparison"
                        $completedTasks = @($this.Tasks | Where-Object { 
                            $null -ne $_ -and ($_.Status -eq "Completed" -or $_.Status -eq 2)
                        })
                        $this.CompletedTasks = $completedTasks.Count
                        $this.PendingTasks = $this.TotalTasks - $this.CompletedTasks
                    }
                }
                
                Write-Log -Level Debug -Message "Dashboard data refreshed - $($this.TotalTasks) tasks loaded"
            } catch {
                Write-Log -Level Warning -Message "Failed to load tasks: $_"
                $this.Tasks = @()
            }
        }
    }

    hidden [void] UpdateDisplay() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "UpdateDisplay" -ScriptBlock {
            # AI: PHASE 3 - Update summary panel
            $this.UpdateSummaryPanel()
            
            # AI: PHASE 3 - Update status panel
            $this.UpdateStatusPanel()
            
            $this.RequestRedraw()
        }
    }

    hidden [void] UpdateSummaryPanel() {
        if ($null -eq $this.SummaryPanel) { return }
        
        # AI: PHASE 3 - Clear summary panel content area
        $this.ClearPanelContent($this.SummaryPanel)
        
        # AI: PHASE 3 - Write summary information
        $summaryLines = @(
            "Task Overview",
            "═══════════════",
            "",
            "Total Tasks:    $($this.TotalTasks)",
            "Completed:      $($this.CompletedTasks)",
            "Pending:        $($this.PendingTasks)",
            "",
            "Progress: $($this.GetProgressBar())",
            "",
            "Use number keys or",
            "arrow keys + Enter"
        )
        
        for ($i = 0; $i -lt $summaryLines.Count; $i++) {
            $color = if ($i -eq 0) { [ConsoleColor]::White } elseif ($i -eq 1) { [ConsoleColor]::Gray } else { [ConsoleColor]::Cyan }
            $this.WriteTextToPanel($this.SummaryPanel, $summaryLines[$i], 1, $i, $color)
        }
    }

    hidden [void] UpdateStatusPanel() {
        if ($null -eq $this.StatusPanel) { return }
        
        # AI: PHASE 3 - Clear status panel content area
        $this.ClearPanelContent($this.StatusPanel)
        
        # AI: PHASE 3 - Write system status information
        $statusLines = @(
            "System Information",
            "════════════════════",
            "",
            # AI: FIX - Use $global scope for automatic variables inside class methods
            "PowerShell Version: $($global:PSVersionTable.PSVersion)",
            "Platform:           $($global:PSVersionTable.Platform)",
            "Memory Usage:       $($this.GetMemoryUsage())",
            "Current Time:       $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        )
        
        for ($i = 0; $i -lt $statusLines.Count; $i++) {
            $color = if ($i -eq 0) { [ConsoleColor]::White } elseif ($i -eq 1) { [ConsoleColor]::Gray } else { [ConsoleColor]::Green }
            $this.WriteTextToPanel($this.StatusPanel, $statusLines[$i], 1, $i, $color)
        }
    }

    # --- Helper Methods ---
    hidden [string] GetProgressBar() {
        if ($this.TotalTasks -eq 0) { return "No tasks" }
        
        $percentage = [Math]::Round(($this.CompletedTasks / $this.TotalTasks) * 100)
        $barLength = 20
        $filledLength = [Math]::Round(($percentage / 100) * $barLength)
        $bar = "█" * $filledLength + "░" * ($barLength - $filledLength)
        return "$bar $percentage%"
    }

    hidden [string] GetMemoryUsage() {
        try {
            # AI: FIX - Use $global scope for automatic variables inside class methods
            $process = Get-Process -Id $global:PID
            $memoryMB = [Math]::Round($process.WorkingSet64 / 1MB, 2)
            return "$memoryMB MB"
        } catch {
            return "Unknown"
        }
    }

    hidden [void] ClearPanelContent([Panel]$panel) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $panel.BackgroundColor)
        for ($y = $panel.ContentY; $y -lt ($panel.ContentY + $panel.ContentHeight); $y++) {
            for ($x = $panel.ContentX; $x -lt ($panel.ContentX + $panel.ContentWidth); $x++) {
                $panel._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
    }

    hidden [void] WriteTextToPanel([Panel]$panel, [string]$text, [int]$x, [int]$y, [ConsoleColor]$color) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        if ($y -ge $panel.ContentHeight) { return }
        
        $chars = $text.ToCharArray()
        for ($i = 0; $i -lt $chars.Length -and ($x + $i) -lt $panel.ContentWidth; $i++) {
            $cell = [TuiCell]::new($chars[$i], $color, $panel.BackgroundColor)
            $panel._private_buffer.SetCell($panel.ContentX + $x + $i, $panel.ContentY + $y, $cell)
        }
    }

    # --- Input Handling ---
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "HandleInput" -ScriptBlock {
            # AI: PHASE 3 - Handle hotkeys first
            $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
            if ($keyChar -match '^[123Q]$') {
                Write-Log -Level Debug -Message "Processing hotkey: $keyChar"
                try {
                    $this.MainMenu.ExecuteAction($keyChar)
                    return $true
                } catch {
                    Write-Log -Level Error -Message "Failed to execute menu action: $_"
                }
            }
            
            # AI: PHASE 3 - Handle navigation keys
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.MainMenu.SelectedIndex -gt 0) {
                        $this.MainMenu.SelectedIndex--
                        $this.RequestRedraw()
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.MainMenu.SelectedIndex -lt ($this.MainMenu.Items.Count - 1)) {
                        $this.MainMenu.SelectedIndex++
                        $this.RequestRedraw()
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    try {
                        $selectedItem = $this.MainMenu.Items[$this.MainMenu.SelectedIndex]
                        if ($selectedItem -and $selectedItem.Enabled) {
                            Write-Log -Level Debug -Message "Executing selected menu item: $($selectedItem.Key)"
                            $selectedItem.Execute()
                            return $true
                        }
                    } catch {
                        Write-Log -Level Error -Message "Failed to execute selected menu item: $_"
                    }
                }
                ([ConsoleKey]::Escape) {
                    Write-Log -Level Debug -Message "Escape pressed - requesting exit"
                    try {
                        $this.Services.Navigation.RequestExit()
                        return $true
                    } catch {
                        Write-Log -Level Error -Message "Failed to request exit: $_"
                    }
                }
                ([ConsoleKey]::F5) {
                    # AI: PHASE 3 - Refresh data on F5
                    $this.RefreshData()
                    $this.UpdateDisplay()
                    return $true
                }
            }
        }
        return $false
    }

    # --- NCurses Rendering ---
    [void] _RenderContent() {
        # AI: PHASE 3 - Buffer-based rendering
        if ($null -eq $this._private_buffer) { return }
        
        # AI: PHASE 3 - Clear buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black)
        $this._private_buffer.Clear($bgCell)
        
        # AI: PHASE 3 - Render all child components
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
            }
        }
    }

    # --- Lifecycle Methods ---
    [void] OnEnter() {
        $this.RefreshData()
        $this.UpdateDisplay()
        Write-Log -Level Debug -Message "DashboardScreen entered"
    }

    [void] OnExit() {
        Write-Log -Level Debug -Message "DashboardScreen exited"
    }

    [void] OnDeactivate() {
        $this.Cleanup()
        Write-Log -Level Debug -Message "DashboardScreen deactivated"
    }

    [void] Cleanup() {
        $this.Components.Clear()
        $this.Children.Clear()
        Write-Log -Level Debug -Message "DashboardScreen cleaned up"
    }
}

# --- END OF ORIGINAL FILE: screens\dashboard-screen\dashboard-screen.psm1 ---


# --- START OF ORIGINAL FILE: screens\task-list-screen\task-list-screen.psm1 ---


# ==============================================================================
# PMC Terminal v5 - NCurses Task List Screen
# Displays and manages tasks with buffer-based rendering
# ==============================================================================

# AI: PHASE 3 REFACTORED - NCurses buffer-based architecture
class TaskListScreen : UIElement {
    # --- Core Architecture ---
    [hashtable] $Services
    [Panel] $MainPanel
    [Panel] $HeaderPanel
    [Panel] $TablePanel
    [Panel] $FooterPanel
    [Table] $TaskTable
    [System.Collections.Generic.List[UIElement]] $Components

    # --- State Management ---
    [string] $FilterStatus = "All"
    [object[]] $AllTasks = @()
    [object[]] $FilteredTasks = @()
    [int] $SelectedIndex = 0

    # --- Constructor ---
    TaskListScreen([hashtable]$services) : base(0, 0, 120, 30) {
        $this.Name = "TaskListScreen"
        $this.Services = $services
        $this.Components = [System.Collections.Generic.List[UIElement]]::new()
        $this.IsFocusable = $true
        $this.Enabled = $true
        $this.Visible = $true
    }

    # --- Initialization ---
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # AI: PHASE 3 - Create main panel structure
            $this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "Task List")
            $this.MainPanel.HasBorder = $true
            $this.MainPanel.BorderStyle = "Double"
            $this.MainPanel.BorderColor = [ConsoleColor]::Gray
            $this.MainPanel.BackgroundColor = [ConsoleColor]::Black
            $this.MainPanel.Name = "MainTaskPanel"
            $this.AddChild($this.MainPanel)
            
            # AI: PHASE 3 - Header panel for title and filter info
            $this.HeaderPanel = [Panel]::new(1, 1, 118, 3, "")
            $this.HeaderPanel.HasBorder = $false
            $this.HeaderPanel.BackgroundColor = [ConsoleColor]::Black
            $this.HeaderPanel.Name = "HeaderPanel"
            $this.MainPanel.AddChild($this.HeaderPanel)
            
            # AI: PHASE 3 - Table panel for task data
            $this.TablePanel = [Panel]::new(1, 4, 118, 22, "")
            $this.TablePanel.HasBorder = $true
            $this.TablePanel.BorderStyle = "Single"
            $this.TablePanel.BorderColor = [ConsoleColor]::DarkGray
            $this.TablePanel.BackgroundColor = [ConsoleColor]::Black
            $this.TablePanel.Name = "TablePanel"
            $this.MainPanel.AddChild($this.TablePanel)
            
            # AI: PHASE 3 - Footer panel for navigation help
            $this.FooterPanel = [Panel]::new(1, 26, 118, 3, "")
            $this.FooterPanel.HasBorder = $false
            $this.FooterPanel.BackgroundColor = [ConsoleColor]::Black
            $this.FooterPanel.Name = "FooterPanel"
            $this.MainPanel.AddChild($this.FooterPanel)
            
            # AI: PHASE 3 - Create task table component
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.Move(1, 1)  # Inside table panel
            $this.TaskTable.Resize(116, 20)

            # AI: FIX - Use proper TableColumn class instances
            $columns = @(
                [TableColumn]::new('Title', 'Task Title', 50),
                [TableColumn]::new('Status', 'Status', 15),
                [TableColumn]::new('Priority', 'Priority', 12),
                [TableColumn]::new('GetDueDateString', 'Due Date', 15) # Use method for display
            )
            $this.TaskTable.SetColumns($columns)
            
            $this.TablePanel.AddChild($this.TaskTable)
            
            # AI: PHASE 3 - Load initial data
            $this.RefreshData()
            $this.UpdateDisplay()
            
            Write-Log -Level Info -Message "TaskListScreen initialized with NCurses architecture"
        }
    }

    # --- Data Management ---
    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            # AI: PHASE 3 - Safe data loading with error handling
            try {
                $this.AllTasks = @($this.Services.DataManager.GetTasks())
                if ($null -eq $this.AllTasks) { $this.AllTasks = @() }
            } catch {
                Write-Log -Level Warning -Message "Failed to load tasks: $_"
                $this.AllTasks = @()
            }
            
            # AI: PHASE 3 - Apply current filter
            $this.FilteredTasks = switch ($this.FilterStatus) {
                "Active" { @($this.AllTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed }) }
                "Completed" { @($this.AllTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed }) }
                default { $this.AllTasks }
            }
            
            # AI: PHASE 3 - Update table data
            $this.TaskTable.SetData($this.FilteredTasks)
            
            # AI: PHASE 3 - Adjust selection if needed
            if ($this.SelectedIndex -ge $this.FilteredTasks.Count) {
                $this.SelectedIndex = [Math]::Max(0, $this.FilteredTasks.Count - 1)
            }
            
            $this.RequestRedraw()
        }
    }

    hidden [void] UpdateDisplay() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "UpdateDisplay" -ScriptBlock {
            # AI: PHASE 3 - Update header text
            $headerText = "Filter: $($this.FilterStatus) | Total: $($this.FilteredTasks.Count) tasks"
            $this.WriteTextToPanel($this.HeaderPanel, $headerText, 0, 0, [ConsoleColor]::White)
            
            # AI: PHASE 3 - Update footer navigation text
            $footerText = "[↑↓]Navigate [Space]Toggle [N]ew [E]dit [D]elete [F]ilter [Esc]Back"
            $this.WriteTextToPanel($this.FooterPanel, $footerText, 0, 0, [ConsoleColor]::Yellow)
            
            # AI: PHASE 3 - Update table selection
            $this.TaskTable.SelectedIndex = $this.SelectedIndex
            
            $this.RequestRedraw()
        }
    }

    # --- Helper Methods ---
    hidden [void] WriteTextToPanel([Panel]$panel, [string]$text, [int]$x, [int]$y, [ConsoleColor]$color) {
        if ($null -eq $panel -or $null -eq $panel._private_buffer) { return }
        
        $chars = $text.ToCharArray()
        for ($i = 0; $i -lt $chars.Length -and ($x + $i) -lt $panel.ContentWidth; $i++) {
            $cell = [TuiCell]::new($chars[$i], $color, $panel.BackgroundColor)
            $panel._private_buffer.SetCell($panel.ContentX + $x + $i, $panel.ContentY + $y, $cell)
        }
    }

    # --- Input Handling ---
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $this.UpdateDisplay()
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt ($this.FilteredTasks.Count - 1) -and $this.FilteredTasks.Count -gt 0) {
                        $this.SelectedIndex++
                        $this.UpdateDisplay()
                        return $true
                    }
                }
                ([ConsoleKey]::Spacebar) {
                    $this.ToggleSelectedTask()
                    return $true
                }
                ([ConsoleKey]::Escape) {
                    $this.NavigateBack()
                    return $true
                }
                default {
                    $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
                    switch ($keyChar) {
                        'N' { $this.ShowNewTaskDialog(); return $true }
                        'E' { $this.EditSelectedTask(); return $true }
                        'D' { $this.DeleteSelectedTask(); return $true }
                        'F' { $this.CycleFilter(); return $true }
                    }
                }
            }
        }
        return $false
    }

    # --- Task Actions ---
    hidden [void] ToggleSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        try {
            $newCompletedStatus = $task.Status -ne [TaskStatus]::Completed
            
            $this.Services.DataManager.UpdateTask(@{
                Task = $task
                Completed = $newCompletedStatus
            })
            
            $this.RefreshData()
            $this.UpdateDisplay()
        } catch {
            Write-Log -Level Error -Message "Failed to toggle task: $_"
        }
    }

    hidden [void] ShowNewTaskDialog() {
        Write-Log -Level Info -Message "New task dialog requested"
        
        $dataManager = $this.Services.DataManager
        $refreshCallback = { $this.RefreshData(); $this.UpdateDisplay() }.GetNewClosure()
        
        try {
            Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {
                param($Value)
                if (-not [string]::IsNullOrWhiteSpace($Value)) {
                    # AI: FIX - This now uses correct method call syntax with positional arguments.
                    $newTask = $dataManager.AddTask($Value, "", "medium", "General")
                    Write-Log -Level Info -Message "Created new task: $($newTask.Title)"
                    & $refreshCallback
                }
            }
        } catch {
            Write-Log -Level Error -Message "Failed to show new task dialog: $_"
        }
    }

    hidden [void] EditSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        Write-Log -Level Info -Message "Edit task requested for: $($task.Title)"
        
        $refreshCallback = { $this.RefreshData(); $this.UpdateDisplay() }.GetNewClosure()
        try {
            Show-InputDialog -Title "Edit Task" -Prompt "New title:" -DefaultValue $task.Title -OnSubmit {
                param($Value)
                if (-not [string]::IsNullOrWhiteSpace($Value)) {
                    $this.Services.DataManager.UpdateTask(@{
                        Task = $task
                        Title = $Value
                    })
                    & $refreshCallback
                }
            }
        } catch {
             Write-Log -Level Error -Message "Failed to show edit task dialog: $_"
        }
    }

    hidden [void] DeleteSelectedTask() {
        if ($this.FilteredTasks.Count -eq 0 -or $this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.FilteredTasks.Count) {
            return
        }
        
        $task = $this.FilteredTasks[$this.SelectedIndex]
        if ($null -eq $task) { return }
        
        Write-Log -Level Info -Message "Delete task requested for: $($task.Title)"
        
        $refreshCallback = { $this.RefreshData(); $this.UpdateDisplay() }.GetNewClosure()
        try {
            Show-ConfirmDialog -Title "Delete Task" -Message "Are you sure you want to delete `"$($task.Title)`"?" -OnConfirm {
                $this.Services.DataManager.RemoveTask($task)
                & $refreshCallback
            }
        } catch {
             Write-Log -Level Error -Message "Failed to show delete confirm dialog: $_"
        }
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
        $this.UpdateDisplay()
    }

    hidden [void] NavigateBack() {
        try {
            $this.Services.Navigation.PopScreen()
        } catch {
            Write-Log -Level Error -Message "Failed to navigate back: $_"
        }
    }

    # --- NCurses Rendering ---
    [void] _RenderContent() {
        # AI: PHASE 3 - Buffer-based rendering
        if ($null -eq $this._private_buffer) { return }
        
        # AI: PHASE 3 - Clear buffer
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, [ConsoleColor]::Black)
        $this._private_buffer.Clear($bgCell)
        
        # AI: PHASE 3 - Render all child components
        # Call the base class's _RenderContent which handles compositing children.
        ([UIElement]$this)._RenderContent()
    }
    
    # --- Lifecycle Methods ---
    [void] OnEnter() {
        $this.RefreshData()
        $this.UpdateDisplay()
        Write-Log -Level Debug -Message "TaskListScreen entered"
    }

    [void] OnExit() {
        Write-Log -Level Debug -Message "TaskListScreen exited"
    }

    [void] Cleanup() {
        $this.Components.Clear()
        $this.Children.Clear()
        Write-Log -Level Debug -Message "TaskListScreen cleaned up"
    }
}

# --- END OF ORIGINAL FILE: screens\task-list-screen\task-list-screen.psm1 ---


# --- START OF ORIGINAL FILE: _CLASSY-MAIN.ps1 ---


# _CLASSY-MAIN.ps1 (Corrected and Final)
#
# This script uses the modern 'using module' syntax, which is the correct
# way to load PowerShell modules and their classes in PS 7+.
# The load order has been fixed to resolve all class and function dependencies.
#
#Requires -Version 7.0

# ==============================================================================
# STAGE 1: MODULE LOADING (Handled by PowerShell Engine)
# 'using module' statements MUST be at the very top of the script.
# PowerShell parses these first, ensuring all types are available before
# any script code is executed. The order is critical for dependencies.
# ==============================================================================

# Layer 0: Core Primitives & Models (No internal dependencies)
# Layer 1: Foundational Systems (Depend on Layer 0)
# Layer 2: Layout & Core Components (Depend on Layer 1)
# Layer 3: Advanced Components & Data/Service Classes (Depend on previous layers)
# Layer 4: Service Implementation & TUI Engine (Depend on classes and primitives)
# Layer 5: Application Screens (The final layer, depends on all others)
# ==============================================================================
# STAGE 2: APPLICATION BOOTSTRAP
# All modules are now loaded and all functions/classes are available.
# ==============================================================================
param (
    [switch]$Debug,
    [switch]$SkipLogo
)

# Set execution context
Set-Location $PSScriptRoot

try {
    Write-Host "`n=== PMC Terminal v5 - Starting (Classy Loader) ===" -ForegroundColor Cyan
    Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)" -ForegroundColor DarkGray
    
    # Initialize core services that have no dependencies
    Write-Host "`nInitializing services..." -ForegroundColor Yellow
    Initialize-Logger -Level $(if ($Debug) { "Debug" } else { "Info" })
    Initialize-EventSystem
    Initialize-ThemeManager
    
    # Create the service container
    $services = @{}
    
    # Initialize services that depend on others, passing the container
    $services.KeybindingService = New-KeybindingService
    $services.DataManager = Initialize-DataManager
    
    # NavigationService needs the $services container to pass to screens
    $services.Navigation = Initialize-NavigationService -Services $services
    
    # Register screen classes with the navigation service
    $services.Navigation.RegisterScreenClass("DashboardScreen", [DashboardScreen])
    $services.Navigation.RegisterScreenClass("TaskListScreen", [TaskListScreen])
    
    # Initialize the dialog system
    Initialize-DialogSystem
    
    Write-Host "All services initialized!" -ForegroundColor Green
    
    if (-not $SkipLogo) {
        Write-Host @"
    
    ╔═══════════════════════════════════════╗
    ║      PMC Terminal v5.0                ║
    ║      PowerShell Management Console    ║
    ╚═══════════════════════════════════════╝
    
"@ -ForegroundColor Cyan
    }
    
    # Initialize the TUI Engine which orchestrates the UI
    Write-Host "Starting TUI Engine..." -ForegroundColor Yellow
    Initialize-TuiEngine
    
    # Create and initialize the first screen
    $dashboard = [DashboardScreen]::new($services)
    $dashboard.Initialize()
    
    # Push the screen to the engine and start the main loop
    Push-Screen -Screen $dashboard
    Start-TuiLoop
    
} catch {
    Write-Host "`n=== FATAL ERROR ===" -ForegroundColor Red
    Write-Host "An error occurred during application startup."
    Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack Trace:" -ForegroundColor DarkRed
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
    
    Write-Host "`nPress any key to exit..." -ForegroundColor Yellow
    if ($Host.UI.RawUI) {
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    }
    exit 1
} finally {
    # Cleanup logic if needed
    Pop-Location -ErrorAction SilentlyContinue
   
}

# --- END 


