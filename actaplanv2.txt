@@@This is an excellent step. Establishing clear guardrails and guiding principles is crucial for a complex refactoring process, especially when executed by an LLM. It defines the "how" and the "why" behind each action.

Here's what an LLM needs to keep at the forefront during this refactoring process:

---

## **Refactoring Guardrails & Guiding Principles for LLM**

**Core Mandate:** To transform `axiom.txt` into a robust, modern, and maintainable TUI application (Axiom-Phoenix) by applying the provided instructions with precision and adhering to the defined architectural vision.

---

### **I. Foundational Guardrails (Non-Negotiable Constraints)**

1.  **Monolithic Constraint:**
    *   **Rule:** All code *must* remain within the single `axiom.txt` file unless explicitly instructed otherwise (e.g., to create a separate file during a decomposition process, which is not part of *this* refactor).
    *   **Implication:** No new `.psm1` files or external scripts are to be created for modules. All code replaces or is inserted directly into the existing monolithic structure.
    *   **LLM Focus:** When adding new code blocks, ensure they are correctly encapsulated within `--- START OF ORIGINAL FILE: ... ---` and `--- END OF ORIGINAL FILE: ... ---` markers, maintaining the established monolith generation format.

2.  **Parse-Time Integrity:**
    *   **Rule:** The script *must* remain syntactically valid and free of parse-time errors at *every stage* of the refactoring.
    *   **Implication:**
        *   **No Duplicate Definitions:** Classes, functions, enums, or global variables *must not* be defined more than once. If replacing a block, the old definition must be fully removed.
        *   **Dependency Order:** Classes and functions must be defined *before* they are used. If a class relies on another class (`TuiCell` using `TuiAnsiHelper`), the dependency *must* come first in the file order.
    *   **LLM Focus:** This is paramount. If a proposed change leads to a duplicate definition or a load-order issue, **HALT and request clarification**.

3.  **Atomic Execution:**
    *   **Rule:** Each instruction is a single, atomic operation.
    *   **Implication:** Do not combine steps or make speculative changes. Execute *only* what the current instruction explicitly states.
    *   **LLM Focus:** Confirm completion of each step before proceeding to the next.

---

### **II. Guiding Principles (Architectural Vision & Best Practices)**

1.  **Functional Integrity (Current & Future):**
    *   **Principle:** Where old functionality is *not* explicitly replaced, its intended behavior must be preserved. All *new* functionality must work as described in the guide.
    *   **Implication:** The application should function correctly (even if with temporary visual inconsistencies) after each phase of the refactor.
    *   **LLM Focus:** Understand the *purpose* of the code being replaced or added. If an instruction seems likely to break a fundamental (but unstated) piece of logic without providing a replacement, flag it.

2.  **Adherence to Phoenix Architecture:**
    *   **Principle:** Every change must align with the new architectural paradigms:
        *   **Truecolor Theming:** Use hex color strings (`#RRGGBB`) for all new UI colors. Leverage `ThemeEngine.GetStyle()` and the `[hashtable]$Style` parameter in `Write-TuiText`/`Write-TuiBox`.
        *   **Object-Oriented Programming (OOP):** Prioritize class-based design for UI components (inheriting from `UIElement`, `Panel`, `Screen`) and services.
        *   **Decoupling:** Separate UI concerns (rendering, input handling) from business logic (data management, calculations). Services should be UI-agnostic.
        *   **Event-Driven Communication:** Use the `Publish-Event`/`Subscribe-Event` system for inter-component/inter-service communication, minimizing direct dependencies.
        *   **Cascading Cleanup:** Ensure `OnCleanup()` methods are implemented and event subscriptions are managed to prevent memory leaks.
    *   **LLM Focus:** When encountering existing code that *could* be updated to these principles but isn't explicitly part of the current instruction, acknowledge the discrepancy but do *not* fix it unless explicitly instructed. The guide provides the scope.

3.  **Maintainability & Readability:**
    *   **Principle:** New code should be clean, well-structured, and use consistent naming conventions. Comments should explain intent where necessary.
    *   **Implication:** Avoid overly clever or terse code that sacrifices clarity.
    *   **LLM Focus:** Maintain the existing PowerShell style (indentation, bracket placement) when inserting new code.

4.  **Error Handling & Resilience:**
    *   **Principle:** Leverage `Invoke-WithErrorHandling` for critical operations. Incorporate hardening techniques (e.g., `ValidatePattern`, null checks, try/catch blocks for external calls) where natural.
    *   **Implication:** The application should be robust to common failure scenarios (invalid input, missing files, unexpected data).
    *   **LLM Focus:** When adding new components, consider common failure points and apply robust error handling patterns as seen in the examples.

---

### **III. Operational Mode for LLM Execution**

1.  **Strict Interpretation:** Interpret instructions literally. Do not infer or deviate unless an explicit ambiguity or conflict *must* be resolved, in which case, halt and ask.
2.  **Step-by-Step Confirmation:** After successfully applying each instruction, provide a concise confirmation.
3.  **Ambiguity/Conflict Resolution:** If an instruction is unclear, contradictory, or seems to lead to a non-functional state or a violation of a Guardrail, **immediately halt execution and request clarification**. Explain the perceived ambiguity or conflict.
4.  **Verification:** While the primary mode is execution, implicitly, each step should aim to result in code that *could* eventually run correctly, given the context of future steps. Report any obvious, immediate syntactical errors that arise from the current instruction.
5.  **Output Format:** When responding with code, ensure it's in a single, complete block, ready for direct application, as if it were a patch.

---@@@@



### **Action Plan: Generating and Applying `Axiom-Phoenix v2`**

To ensure a successful and working upgrade, I will execute the following:

1.  **Pre-processing: Standardize Global Services Variable:** I will first perform a global find-and-replace in `axiom.txt` to change all instances of `$Global:Services` to `$Global:AxiomServices`. This ensures consistency before new code is introduced.
2.  **Generate Corrected Guide (`axiom - acta guide v2.txt`):** I will produce a *new*, comprehensive guide that fixes all the identified issues and incorporates the necessary foundational upgrades.
3.  **Apply Guide to `axiom.txt`:** I will then apply the instructions from this `axiom - acta guide v2.txt` to your provided `axiom.txt` file.

**You do not need to debug `axiom.txt`'s existing screen issues; the upgrade process will replace them.**

---

Let's begin by generating the corrected, comprehensive upgrade guide: `axiom - acta guide v2.txt`.

---

--- START OF FILE axiom - acta guide v2.txt ---

# Upgrade Plan: Axiom-Phoenix v2

**Mandate:** Full architectural replacement. Backwards compatibility is not a design goal. All legacy functional code will be replaced with modern, class-based, component-oriented equivalents. The aim is a fully functional, upgraded application.

**Target:** This plan is a set of precise instructions for a Large Language Model to execute against the provided `axiom.txt` monolithic script. Each step is atomic and must be completed in order.

---

### **Phase 0: Pre-processing & Foundational UI Class Upgrade**

**Objective:** To prepare the `axiom.txt` monolith by ensuring consistent global variable usage and replacing the fundamental UI class hierarchy with its more robust, feature-rich version. This must happen before any other steps, as subsequent components rely on these improved base classes.

#### **Step 0.1: Standardize Global Services Variable Name**

**Action:** Before any major code changes, we must ensure consistency in how the global services container is referenced. The final startup block assigns services to `$global:AxiomServices`. We will make this consistent throughout the codebase.

**Instruction:** Perform a **GLOBAL FIND AND REPLACE** operation across the entire `axiom.txt` file.

*   **Find:** `$Global:Services`
*   **Replace With:** `$Global:AxiomServices`

**Rationale:** This ensures that all components and actions, once integrated, correctly access the central services container, preventing runtime `null` reference errors.

#### **Step 0.2: Correcting a Parse-Time Dependency (Re-iterating for load order)**

**File:** `axiom.txt`
**Location:** The `TuiAnsiHelper` class definition within the `--- START OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---` section.
**Action:** The original code defines `TuiAnsiHelper` *after* `TuiCell`, which uses it. This creates a parse-time error in PowerShell, as the type `[TuiAnsiHelper]` is not yet known when `TuiCell` is being defined. Our plan corrects this by replacing `TuiAnsiHelper` first, ensuring the dependency is available when we redefine `TuiCell`.

**Instruction:** **DELETE** the entire `class TuiAnsiHelper { ... }` block and **REPLACE** it with the following complete definition.

```powershell
# In components\tui-primitives\tui-primitives.psm1

#region TuiAnsiHelper - ANSI Code Generation
class TuiAnsiHelper {
    # Helper to convert a Hex string like "#FF8700" to an RGB hashtable
    static [hashtable] HexToRgb([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor) -or -not $hexColor.StartsWith("#") -or $hexColor.Length -ne 7) {
            return $null # Return null for invalid format or transparency
        }
        try {
            # Use Convert with base 16 to parse hex components. This is fast and robust.
            return @{
                R = [System.Convert]::ToInt32($hexColor.Substring(1, 2), 16)
                G = [System.Convert]::ToInt32($hexColor.Substring(3, 2), 16)
                B = [System.Convert]::ToInt32($hexColor.Substring(5, 2), 16)
            }
        } catch {
            Write-Log -Level Warning -Message "Failed to parse hex color: $hexColor. Returning null."
            return $null # Return null if parsing fails
        }
    }

    # The new core method to generate a full ANSI sequence for Truecolor and styling.
    static [string] GetAnsiSequence([string]$fgHex, [string]$bgHex, [hashtable]$attributes) {
        $sequences = [System.Collections.Generic.List[string]]::new()

        # Foreground color (Truecolor - SGR 38;2)
        if ($fgHex) {
            $rgb = [TuiAnsiHelper]::HexToRgb($fgHex)
            if ($rgb) {
                $sequences.Add("38;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Background color (Truecolor - SGR 48;2)
        if ($bgHex) {
            $rgb = [TuiAnsiHelper]::HexToRgb($bgHex)
            if ($rgb) {
                $sequences.Add("48;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Style attributes
        if ($attributes) {
            if ($attributes.Bold) { $sequences.Add("1") }
            if ($attributes.Italic) { $sequences.Add("3") }
            if ($attributes.Underline) { $sequences.Add("4") }
            if ($attributes.Strikethrough) { $sequences.Add("9") }
        }

        # If no styles, return empty string. Otherwise, build the full escape sequence.
        if ($sequences.Count -eq 0) { return "" }
        return "`e[$($sequences -join ';')m"
    }

    # A single, universal reset sequence (SGR 0)
    static [string] Reset() {
        return "`e[0m"
    }
}
#endregion
```

**Rationale:** This new class is the cornerstone of Truecolor support. The `HexToRgb` static method provides a single, safe point of conversion. The `GetAnsiSequence` method correctly constructs the `SGR 38;2` and `48;2` escape codes required by modern terminals for 24-bit color. It is stateless and highly performant.

#### **Step 0.3: Replace `UIElement` and Base UI Class Hierarchy**

**File:** `axiom.txt`
**Location:** The entire `--- START OF ORIGINAL FILE: components\ui-classes\ui-classes.psm1 ---` section.
**Action:** The existing base UI classes are simplistic. We will replace them with a robust hierarchy that includes advanced features like proper buffer management, cascaded cleanup, and comprehensive lifecycle methods (`OnResize`, `OnMove`). This is vital for complex components and screens.

**Instruction:** **DELETE** the entire section from `--- START OF ORIGINAL FILE: components\ui-classes\ui-classes.psm1 ---` to its corresponding `--- END OF ORIGINAL FILE ---` tag. **REPLACE** the deleted section with the following complete definition.

```powershell
# --- START OF FULL REPLACEMENT for components\ui-classes\ui-classes.psm1 ---
# ==============================================================================
# PMC Terminal v5 - Base UI Class Hierarchy
# Provides the foundational classes for all UI components with NCurses compositor support.
# ==============================================================================

# --- Enhanced UI Element with Buffer Management ---
class UIElement {
    [string] $Name = ""
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [bool] $IsFocused = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [TuiBuffer] $_private_buffer = $null # Explicitly initialized in constructors
    [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{}

    # Constructor
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        # HARDENING: Ensure private buffer is always initialized to prevent null reference errors.
        $this.{_private_buffer} = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with name
    UIElement([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [ArgumentException]::new("UIElement name cannot be null or empty.")
        }
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        # HARDENING: Ensure private buffer is always initialized to prevent null reference errors.
        $this.{_private_buffer} = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    # Constructor with position and size
    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        # HARDENING: Ensure private buffer is always initialized to prevent null reference errors.
        $this.{_private_buffer} = [TuiBuffer]::new($width, $height, "$($this.Name).Buffer")
    }

    # Get absolute screen position
    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            # Panels have a content offset, add this for accurate absolute position
            if ($current -is [Panel]) {
                $absX += $current.ContentX
                $absY += $current.ContentY
            }
            $current = $current.Parent
        }
        
        return @{ X = $absX; Y = $absY }
    }

    # Add child component
    [void] AddChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
        }
    }

    # Remove child component
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
            $this.RequestRedraw()
        }
    }

    # Request redraw for this component and parents
    [void] RequestRedraw() {
        $this.{_needs_redraw} = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
    }

    # Resize the component and its buffer
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0 -or $newHeight -le 0) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        
        if ($null -ne $this.{_private_buffer}) {
            $this.{_private_buffer}.Resize($newWidth, $newHeight)
        }
        
        $this.RequestRedraw()
        $this.OnResize($newWidth, $newHeight)
    }

    # Move the component
    [void] Move([int]$newX, [int]$newY) {
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
    }

    # Check if point is within component bounds
    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge $this.X -and $x -lt ($this.X + $this.Width) -and 
                $y -ge $this.Y -and $y -lt ($this.Y + $this.Height))
    }

    # Get child at specific point (relative to this component)
    [UIElement] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $this.X, $y - $this.Y)) {
                return $child
            }
        }
        return $null
    }
    
    # NEW: Base Cleanup method. This will be called to ensure resources
    # (like event subscriptions) are released when a component is destroyed.
    # It automatically cascades to all children.
    [void] Cleanup() {
        # Call the specific cleanup logic for this component.
        $this.OnCleanup()
        # Cascade the cleanup call to all children.
        foreach ($child in $this.Children) {
            $child.Cleanup()
        }
        Write-Log -Level Debug -Message "Cleaned up UIElement: $($this.Name)"
    }

    # Virtual methods for subclasses to override
    [void] OnRender() {
        # Default implementation - clear buffer
        if ($null -ne $this.{_private_buffer}) {
            $this.{_private_buffer}.Clear()
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Override in subclasses
    }

    [void] OnMove([int]$newX, [int]$newY) {
        # Override in subclasses
    }

    [void] OnFocus() {
        # Override in subclasses
    }

    [void] OnBlur() {
        # Override in subclasses
    }

    [void] OnCleanup() { /* Override in subclasses to unsubscribe from events, etc. */ }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Override in subclasses - return true if input was handled
        return $false
    }

    # Main render method with error handling - calls _RenderContent and renders children
    [void] Render() {
        Invoke-WithErrorHandling -Component $this.Name -Context "Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            $this._RenderContent()
        } -AdditionalData @{ ComponentType = $this.GetType().Name }
    }

    # Protected render implementation - can be overridden by subclasses
    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }

        # Render this component to its private buffer
        if ($this.{_needs_redraw} -or ($null -eq $this.{_private_buffer})) {
            # In case the buffer was somehow not initialized or disposed, recreate it.
            if ($null -eq $this.{_private_buffer}) {
                $this.{_private_buffer} = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }
            
            $this.OnRender()
            $this.{_needs_redraw} = $false
        }

        # Render children to their buffers, then composite onto parent
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                
                # Composite child's buffer onto this component's buffer
                if ($null -ne $child.{_private_buffer}) {
                    $this.{_private_buffer}.BlendBuffer($child.{_private_buffer}, $child.X, $child.Y)
                }
            }
        }
    }

    # Get the final rendered buffer
    [TuiBuffer] GetBuffer() {
        return $this.{_private_buffer}
    }
    
    [string] ToString() {
        return "$($this.GetType().Name): $($this.Name)"
    }
}

# --- Base Component (can contain children) ---
class Component : UIElement {
    Component([string]$name) : base($name) {
    }

    # Default implementation renders all visible children to buffer
    hidden [void] _RenderContent() {
        # Call parent implementation for buffer management
        ([UIElement]$this)._RenderContent()
    }
}

# --- Base Screen (top-level container) ---
class Screen : UIElement {
    [hashtable]$Services
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[UIElement]]$Panels # Keep for backward compatibility for some screens if needed.
    [UIElement]$LastFocusedComponent
    hidden [System.Collections.Generic.Dictionary[string, string]]$EventSubscriptions

    Screen([string]$name, [hashtable]$services) : base($name) {
        if (-not $services) { throw [ArgumentNullException]::new("services") }
        
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
    }
    
    [void] Initialize() { }
    [void] OnEnter() { }
    [void] OnExit() { }
    [void] OnResume() { }
    [bool] HandleInput([System.ConsoleKeyInfo]$key) { return $false } # Default to no handling

    # NEW: Overriding Cleanup to manage screen-specific subscriptions
    [void] OnCleanup() {
        foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value
            }
            catch {
                Write-Log -Level Warning -Message "Failed to unregister event '$($kvp.Key)' for screen '$($this.Name)'."
            }
        }
        $this.EventSubscriptions.Clear()
        $this.Panels.Clear() # Clear any direct panel references if still used by older screens.
        Write-Log -Level Debug -Message "Screen-specific cleanup for: $($this.Name)"
    }
    
    [void] AddPanel([UIElement]$panel) {
        if (-not $panel) { throw [ArgumentNullException]::new("panel") }
        $this.Panels.Add($panel)
        $this.AddChild($panel) # Screens should add panels as children too.
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) { throw [ArgumentException]::new("Event name cannot be null or empty.") }
        if (-not $handler) { throw [ArgumentNullException]::new("handler") }
        
        $subscriptionId = Subscribe-Event -EventName $eventName -Handler $handler -Source $this.Name
        $this.EventSubscriptions[$eventName] = $subscriptionId
    }
}
# --- END OF FULL REPLACEMENT for components\ui-classes\ui-classes.psm1 ---
```

**Rationale:** This upgrade significantly enhances the framework's capabilities:
*   **Buffer Initialization:** Fixes `_private_buffer` initialization, preventing `null` reference errors.
*   **Cascading Cleanup:** Introduces `OnCleanup()` and ensures `Cleanup()` is recursively called on children, preventing memory leaks (especially from event subscriptions).
*   **Lifecycle Methods:** Adds virtual `OnResize` and `OnMove` methods, allowing components to respond dynamically to layout changes.
*   **Absolute Position Correction:** Updates `GetAbsolutePosition` to correctly account for panel content offsets, ensuring accurate rendering of nested elements.
*   **Event Management:** `Screen` now correctly manages its own event subscriptions for proper cleanup.

#### **Step 0.4: Replace `Panel` Class Hierarchy**

**File:** `axiom.txt`
**Location:** The entire `--- START OF ORIGINAL FILE: layout\panels-class\panels-class.psm1 ---` section.
**Action:** The existing `Panel` is replaced by a more advanced version that properly integrates with the new UI class hierarchy and introduces specialized panel types like `ScrollablePanel` and `GroupPanel`.

**Instruction:** **DELETE** the entire section from `--- START OF ORIGINAL FILE: layout\panels-class\panels-class.psm1 ---` to its corresponding `--- END OF ORIGINAL FILE ---` tag. **REPLACE** the deleted section with the following complete definition.

```powershell
# --- START OF FULL REPLACEMENT for layout\panels-class\panels-class.psm1 ---
# Panel Classes v5.1 - NCurses Compositor Foundation
# Provides Panel base class for layout management

# Panel Class - A specialized UIElement that acts as a container.
# It can draw a border and title, and it intelligently manages child elements,
# positioning them correctly within its bordered "content area".
class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [string] $BorderColor = "#808080" # Default border color: medium gray
    [string] $BackgroundColor = "#000000" # Default background: black
    [string] $TitleColor = "#C0C0C0" # Default title color: light gray
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false # Panels themselves can be focusable to capture input, but their children usually get focus.
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid
    [hashtable] $Style = @{} # For storing theme-driven styles

    # Constructor
    Panel() : base() {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with position and size
    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Constructor with title
    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    # Update content bounds based on border settings
    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }

    # Override resize to update content bounds and re-layout children
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # When a panel is resized, it must update its internal content bounds
        # and then re-calculate the layout of all its children.
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    # Perform automatic layout based on LayoutType
    [void] PerformLayout() {
        if ($this.Children.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" { $this.LayoutVertical() }
            "Horizontal" { $this.LayoutHorizontal() }
            "Grid" { $this.LayoutGrid() }
            # "Manual" - no automatic layout
        }
    }

    # Vertical layout - stack children top to bottom
    [void] LayoutVertical() {
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $this.ContentX
            $child.Y = $currentY
            
            # Distribute remaining height to the last child to prevent gaps
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, $remainingHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentY += $childHeight
        }
    }

    # Horizontal layout - arrange children side by side
    [void] LayoutHorizontal() {
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $currentX
            $child.Y = $this.ContentY
            
            # Distribute remaining width to the last child
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize($remainingWidth, $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            
            $currentX += $childWidth
        }
    }

    # Grid layout - arrange children in a grid
    [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }

        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))

        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            
            $width = if ($col -eq ($cols - 1)) { $this.ContentX + $this.ContentWidth - $x } else { $cellWidth }
            $height = if ($row -eq ($rows - 1)) { $this.ContentY + $this.ContentHeight - $y } else { $cellHeight }
            
            $child.Move($x, $y)
            $child.Resize($width, $height)
        }
    }

    [void] SetBorderStyle([string]$style, [string]$color) {
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
    }

    [void] SetBorder([bool]$hasBorder) {
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
    }

    [void] SetTitle([string]$title) {
        $this.Title = $title
        $this.RequestRedraw()
    }

    [bool] ContainsContentPoint([int]$x, [int]$y) {
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    [hashtable] GetContentBounds() {
        return @{ X = $this.ContentX; Y = $this.ContentY; Width = $this.ContentWidth; Height = $this.ContentHeight }
    }
    
    [hashtable] GetContentArea() {
        return $this.GetContentBounds()
    }
    
    # These helper methods now use the new style-driven Write-TuiText/Write-TuiBox
    [void] WriteToBuffer([int]$x, [int]$y, [string]$text, [hashtable]$style) {
        if ($null -eq $this.{_private_buffer}) { return }
        Write-TuiText -Buffer $this.{_private_buffer} -X $x -Y $y -Text $text -Style $style
    }
    
    [void] DrawBoxToBuffer([int]$x, [int]$y, [int]$width, [int]$height, [hashtable]$style) {
        if ($null -eq $this.{_private_buffer}) { return }
        Write-TuiBox -Buffer $this.{_private_buffer} -X $x -Y $y -Width $width -Height $height `
            -Style $style
    }

    [void] ClearContent() {
        if ($null -eq $this.{_private_buffer}) { return }
        # Use background color from theme or default
        $bgColor = $this.Style.BG ?? $this.BackgroundColor ?? '#000000'
        $clearCell = [TuiCell]::new(' ', $null, $bgColor) # Foreground null implies transparent/inherited
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this.{_private_buffer}.SetCell($x, $y, $clearCell)
            }
        }
    }

    [void] OnRender() {
        if ($null -eq $this.{_private_buffer}) { return }
        # Apply current theme style for this panel, or default if none.
        # This will be overridden by panel-specific styles from ThemeEngine for specific panels.
        $panelStyle = $this.Style.Clone() # Clone to avoid modifying the theme engine's original.
        $panelStyle.BorderFG = $this.BorderColor
        $panelStyle.TitleFG = $this.TitleColor
        $panelStyle.BG = $this.BackgroundColor
        
        $bgCell = [TuiCell]::new(' ', $null, $panelStyle.BG)
        $this.{_private_buffer}.Clear($bgCell)

        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this.{_private_buffer} -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -Title $this.Title -Style $panelStyle
        }
    }

    hidden [void] _RenderContent() {
        $this.OnRender()
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                if ($null -ne $child.{_private_buffer}) {
                    $this.{_private_buffer}.BlendBuffer($child.{_private_buffer}, ($child.X + $this.ContentX), ($child.Y + $this.ContentY))
                }
            }
        }
    }

    [void] OnFocus() {
        if ($this.CanFocus) {
            # Apply focus style from theme engine if available
            $focusStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.PanelFocus")
            if ($focusStyle.BorderFG) { $this.BorderColor = $focusStyle.BorderFG } else { $this.BorderColor = "#00FFFF" } # Default to Cyan if no theme style
            $this.RequestRedraw()
        }
    }

    [void] OnBlur() {
        if ($this.CanFocus) {
            # Apply normal style from theme engine
            $normalStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Panel")
            if ($normalStyle.BorderFG) { $this.BorderColor = $normalStyle.BorderFG } else { $this.BorderColor = "#808080" } # Default to Gray if no theme style
            $this.RequestRedraw()
        }
    }

    [UIElement] GetFirstFocusableChild() {
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                return $child
            }
            if ($child -is [Panel]) {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    return $nestedChild
                }
            }
        }
        return $null
    }

    [System.Collections.Generic.List[UIElement]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[UIElement]]::new()
        foreach ($child in $this.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        return $focusable
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.CanFocus -and $this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Tab) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    $firstChild = $this.GetFirstFocusableChild()
                    if ($null -ne $firstChild) {
                        $firstChild.IsFocused = $true
                        $this.IsFocused = $false
                        return $true
                    }
                }
            }
        }
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.Enabled -and $child.HandleInput($keyInfo)) {
                return $true
            }
        }
        return $false
    }

    [string] ToString() {
        return "Panel($($this.Name), $($this.X),$($this.Y), $($this.Width)x$($this.Height), Children=$($this.Children.Count))"
    }
}

#region Specialized Panel Types

class ScrollablePanel : Panel {
    [int] $ScrollX = 0
    [int] $ScrollY = 0
    [int] $VirtualWidth = 0
    [int] $VirtualHeight = 0
    [bool] $ShowScrollbars = $true
    [TuiBuffer] $_virtual_buffer = $null

    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "ScrollablePanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
    }

    [void] SetVirtualSize([int]$width, [int]$height) {
        $this.VirtualWidth = $width
        $this.VirtualHeight = $height
        if ($width -gt 0 -and $height -gt 0) {
            $this.{_virtual_buffer} = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
        }
        $this.RequestRedraw()
    }

    [void] ScrollTo([int]$x, [int]$y) {
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        $this.ScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $this.ScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        $this.RequestRedraw()
    }

    [void] ScrollBy([int]$deltaX, [int]$deltaY) {
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
            }
        }
        return ([Panel]$this).HandleInput($keyInfo)
    }

    [void] OnRender() {
        ([Panel]$this).OnRender()
        if ($null -ne $this.{_virtual_buffer}) {
            $visibleBuffer = $this.{_virtual_buffer}.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            $this.{_private_buffer}.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
        }
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
        }
    }

    [void] DrawScrollbars() {
        if ($null -eq $this.{_private_buffer}) { return }
        # Use theme colors for scrollbars
        $scrollbarFG = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Scrollbar.FG").FG ?? '#808080' # Default medium gray
        $scrollbarBG = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Scrollbar.BG").BG ?? '#000000' # Default black
        
        if ($this.VirtualHeight -gt $this.ContentHeight) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this.Height - 2
            $thumbPosition = [Math]::Floor(($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight)) * ($scrollbarHeight - 1))
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, $scrollbarFG, $scrollbarBG)
                $this.{_private_buffer}.SetCell($scrollbarX, $y, $cell)
            }
        }
        if ($this.VirtualWidth -gt $this.ContentWidth) {
            $scrollbarY = $this.Height - 1
            $scrollbarWidth = $this.Width - 2
            $thumbPosition = [Math]::Floor(($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth)) * ($scrollbarWidth - 1))
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPosition + 1)) { '█' } else { '▒' }
                $cell = [TuiCell]::new($char, $scrollbarFG, $scrollbarBG)
                $this.{_private_buffer}.SetCell($x, $scrollbarY, $cell)
            }
        }
    }

    [TuiBuffer] GetVirtualBuffer() {
        return $this.{_virtual_buffer}
    }
}

class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [string] $HeaderColor = "#00008B" # Dark Blue
    [string] $CollapseChar = "▼"
    [string] $ExpandChar = "▶"

    GroupPanel() : base() {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.Name = "GroupPanel"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
    }

    [void] ToggleCollapsed() {
        $this.IsCollapsed = -not $this.IsCollapsed
        if ($this.IsCollapsed) {
            $this.ExpandedHeight = $this.Height
            $this.Resize($this.Width, $this.HeaderHeight + 2)
        } else {
            $this.Resize($this.Width, $this.ExpandedHeight)
        }
        foreach ($child in $this.Children) {
            $child.Visible = -not $this.IsCollapsed
        }
        $this.RequestRedraw()
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($this.IsFocused) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
            }
        }
        if (-not $this.IsCollapsed) {
            return ([Panel]$this).HandleInput($keyInfo)
        }
        return $false
    }

    [void] OnRender() {
        ([Panel]$this).OnRender()
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $style = @{ FG = $this.TitleColor; BG = $this.BackgroundColor }
            Write-TuiText -Buffer $this.{_private_buffer} -X 2 -Y 0 -Text $indicator -Style $style
        }
    }
}
#endregion
```

**Rationale:** This module completes the core UI class hierarchy, providing rich panel types and ensuring all drawing functions now correctly pass `[hashtable]$Style` parameters, thus fully leveraging the new `ThemeEngine`.

---

### **Pillar 1: The Phoenix Rendering & Theming Engine (Revisited and Corrected)**

**Objective:** To completely replace the core rendering pipeline. We will excise the `[ConsoleColor]`-based system and replace it with a Truecolor (24-bit hex) capable engine. We will replace the hardcoded `ThemeManager` with a flexible, file-based `ThemeEngine`. The result will be a visually rich, fully customizable, and significantly more performant user interface foundation.

#### **Step 1.1: Evolve `TuiCell` for Truecolor and Rich Styling**

**File:** `axiom.txt`
**Location:** The `TuiCell` class definition, which directly follows the `TuiAnsiHelper` we just replaced.
**Action:** The current `TuiCell` is insufficient. We will replace it with an evolved version that stores colors as strings and has discrete properties for all text styles.

**Instruction:** **DELETE** the entire existing `class TuiCell { ... }` block and **REPLACE** it with the following definition.

```powershell
# In components\tui-primitives\tui-primitives.psm1

#region TuiCell Class - Core Compositor Unit
class TuiCell {
    [char] $Char = ' '
    
    # HARDENING: ValidatePattern ensures that any attempt to assign an invalid hex string
    # fails immediately at the point of assignment, rather than causing a cryptic error
    # deep within the rendering loop. This is the 'fail fast' principle.
    [ValidatePattern('^#[0-9A-Fa-f]{6}$')]
    [string] $ForegroundColor = "#C0C0C0" # Default: light gray
    
    # Allow null for transparency. If not null, validate it's a hex color.
    [string] $BackgroundColor = $null      # Default: null for transparency (compositing)
    
    # ADDED: Explicit boolean style attributes for clarity and performance.
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [bool] $Strikethrough = $false

    [int] $ZIndex = 0
    [object] $Metadata = $null

    # Default constructor
    TuiCell() { }

    # Character constructor - updated for string colors
    TuiCell([char]$char) {
        $this.Char = $char
    }

    # Full constructor - accepts string colors and all style attributes. Replaces multiple obsolete constructors.
    TuiCell([char]$char, [string]$fg, [string]$bg, [bool]$bold=$false, [bool]$italic=$false, [bool]$underline=$false, [bool]$strikethrough=$false) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Italic = $italic
        $this.Underline = $underline
        $this.Strikethrough = $strikethrough
    }
    
    # Copy constructor - updated to copy all new properties.
    TuiCell([TuiCell]$other) {
        if ($null -ne $other) {
            $this.Char = $other.Char
            $this.ForegroundColor = $other.ForegroundColor
            $this.BackgroundColor = $other.BackgroundColor
            $this.Bold = $other.Bold
            $this.Underline = $other.Underline
            $this.Italic = $other.Italic
            $this.Strikethrough = $other.Strikethrough
            $this.ZIndex = $other.ZIndex
            $this.Metadata = $other.Metadata
        }
    }

    # Check if this cell differs from another - UPDATED for new properties. This is critical for render optimization.
    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic -or
                $this.Strikethrough -ne $other.Strikethrough)
    }

    # ToAnsiString() will now be a simple wrapper. The core logic is in the renderer.
    [string] ToAnsiString() {
        $attributes = @{ Bold = $this.Bold; Italic = $this.Italic; Underline = $this.Underline; Strikethrough = $this.Strikethrough }
        $sequence = [TuiAnsiHelper]::GetAnsiSequence($this.ForegroundColor, $this.BackgroundColor, $attributes)
        return "$sequence$($this.Char)$([TuiAnsiHelper]::Reset())"
    }
}
#endregion
```

**Rationale:** The `TuiCell` is the atomic unit of our display. Switching `ForegroundColor` and `BackgroundColor` to `[string]` is the breaking change that enables Truecolor. Adding `[ValidatePattern()]` is a crucial hardening step. The `DiffersFrom()` method is expanded to include all style attributes, which is essential for the optimized rendering logic we will implement later. Obsolete constructors have been removed to simplify the class API.

#### **Step 1.2: Replace `ThemeManager` with `ThemeEngine`**

**File:** `axiom.txt`
**Location:** The entire `--- START OF ORIGINAL FILE: modules\theme-manager\theme-manager.psm1 ---` section.
**Action:** The existing `ThemeManager` is a hardcoded, inflexible system. It must be completely removed and replaced with a dynamic, file-based engine that loads themes from external JSON files.

**Instruction:** **DELETE** the entire section from `--- START OF ORIGINAL FILE: modules\theme-manager\theme-manager.psm1 ---` to its corresponding `--- END OF ORIGINAL FILE ---` tag. **REPLACE** the deleted section with the following powerful, file-based theme engine.

```powershell
# --- START OF ORIGINAL FILE: modules\theme-engine\theme-engine.psm1 ---
# MODULE: ThemeEngine
# PURPOSE: Loads and serves theme styles from JSON files, enabling full user customization.

class ThemeEngine {
    hidden [hashtable] $_themes
    hidden [string] $_currentThemeKey
    hidden [hashtable] $_currentThemeObject

    ThemeEngine([string]$themesDirectory) {
        $this._themes = @{}
        $this.LoadThemesFromDirectory($themesDirectory)

        # HARDENING: Ensure there is at least a fallback theme in case none are found or loadable.
        # This prevents the application from crashing on first run or with a bad configuration.
        if ($this._themes.Count -eq 0) {
            Write-Log -Level Warning -Message "No valid themes found. Loading internal default fallback."
            $this._themes['Default'] = @{
                Name = 'Default Fallback'
                Palette = @{ 
                    background = '#0d1117'; foreground = '#c9d1d9'; accent1 = '#58a6ff'; accent2 = '#f78166';
                    border = '#30363d'; borderFocus = '#58a6ff'; success = '#3fb950'; error = '#f85149';
                    errorHighlight = '#FF00FF' # Highly visible color for debugging missing theme keys.
                }
                Components = @{ 
                    Default = @{ FG = '$Palette.foreground'; BG = '$Palette.background' }
                    Panel = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.foreground'; BG = '$Palette.background' }
                    PanelFocus = @{ BorderFG = '$Palette.borderFocus' }
                    Table = @{ Header = @{ FG = '$Palette.accent1'; Bold = $true } }
                    FileBrowser = @{
                        Default = @{ FG = '$Palette.foreground' }
                        Directory = @{ FG = '$Palette.accent1'; Bold = $true }
                        Selected = @{ BG = '$Palette.accent1'; FG = '$Palette.background'; Bold = $true }
                    }
                    Kanban = @{
                        Column = @{ BorderFG = '$Palette.border'; BG = '$Palette.background' }
                        Card = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent2'; BG = '$Palette.background' }
                        CardSelected = @{ BorderFG = '$Palette.borderFocus'; BG = '$Palette.border' }
                    }
                    Widget = @{
                        UpNext = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent1'; BG = '$Palette.background' }
                        Stats = @{ BorderFG = '$Palette.border'; TitleFG = '$Palette.accent2'; BG = '$Palette.background' }
                        Text = @{ Default = @{ FG = '$Palette.foreground' }; Overdue = @{ FG = '$Palette.error'; Bold = $true } }
                    }
                    Button = @{
                        Default = @{ BorderFG = '$Palette.border'; BG = '$Palette.background'; FG = '$Palette.foreground' }
                        Focus = @{ BorderFG = '$Palette.accent1'; BG = '$Palette.background'; FG = '$Palette.accent1' }
                        Pressed = @{ BorderFG = '$Palette.accent2'; BG = '$Palette.accent2'; FG = '$Palette.background' }
                    }
                    TextBox = @{
                        Default = @{ BorderFG = '$Palette.border'; BG = '$Palette.background'; FG = '$Palette.foreground' }
                        Focus = @{ BorderFG = '$Palette.accent1'; BG = '$Palette.background'; FG = '$Palette.foreground' }
                        Placeholder = @{ FG = '$Palette.border' }
                        Cursor = @{ FG = '$Palette.accent2' }
                    }
                    CheckBox = @{
                        Default = @{ FG = '$Palette.foreground' }
                        Focus = @{ FG = '$Palette.accent1' }
                    }
                    RadioButton = @{
                        Default = @{ FG = '$Palette.foreground' }
                        Focus = @{ FG = '$Palette.accent1' }
                    }
                    NumericInput = @{
                        Default = @{ BorderFG = '$Palette.border'; BG = '$Palette.background'; FG = '$Palette.foreground' }
                        Focus = @{ BorderFG = '$Palette.accent1'; BG = '$Palette.background'; FG = '$Palette.foreground' }
                        Arrows = @{ FG = '$Palette.border' }
                        Cursor = @{ FG = '$Palette.accent2' }
                    }
                    DateInput = @{
                        Default = @{ BorderFG = '$Palette.border'; BG = '$Palette.background'; FG = '$Palette.foreground' }
                        Focus = @{ BorderFG = '$Palette.accent1'; BG = '$Palette.background'; FG = '$Palette.foreground' }
                        CalendarIcon = @{ FG = '$Palette.accent1' }
                        Cursor = @{ FG = '$Palette.accent2' }
                    }
                    ComboBox = @{
                        Default = @{ BorderFG = '$Palette.border'; BG = '$Palette.background'; FG = '$Palette.foreground' }
                        Focus = @{ BorderFG = '$Palette.accent1'; BG = '$Palette.background'; FG = '$Palette.foreground' }
                        Placeholder = @{ FG = '$Palette.border' }
                        Arrow = @{ FG = '$Palette.border' }
                    }
                    Dialog = @{
                        BorderFG = '$Palette.accent1'; TitleFG = '$Palette.foreground'; MessageFG = '$Palette.foreground'; BG = '$Palette.background'
                        ButtonOk = @{ FG = '$Palette.success' }
                        ButtonCancel = @{ FG = '$Palette.border' }
                        ButtonSelected = @{ FG = '$Palette.background'; BG = '$Palette.accent1' }
                    }
                    Scrollbar = @{ FG = '$Palette.border'; BG = '$Palette.background' }
                }
            }
        }

        # Set the first available theme as the current one.
        $this.SetTheme(($this._themes.Keys | Select-Object -First 1))
    }

    [void] LoadThemesFromDirectory([string]$dir) {
        if (-not (Test-Path $dir)) { Write-Log -Level Warning -Message "Themes directory not found: $dir"; return }
        $themeFiles = Get-ChildItem -Path $dir -Filter "*.theme.json" -File
        foreach ($file in $themeFiles) {
            try {
                $themeKey = ($file.BaseName -replace '\.theme$', '')
                $themeObject = Get-Content -Path $file.FullName -Raw | ConvertFrom-Json -AsHashtable
                $this._themes[$themeKey] = $themeObject
                Write-Log -Level Info -Message "Loaded theme '$themeKey' from $($file.Name)"
            } catch {
                # HARDENING: Resiliently handles corrupted or malformed theme files without crashing.
                Write-Log -Level Error -Message "Failed to load theme file '$($file.Name)': $_"
            }
        }
    }

    [void] SetTheme([string]$themeKey) {
        if ($this._themes.ContainsKey($themeKey)) {
            $this._currentThemeKey = $themeKey
            $this._currentThemeObject = $this._themes[$themeKey]
            Publish-Event -EventName "Theme.Changed" -Data @{ Name = $themeKey }
            Write-Log -Level Info -Message "Theme changed to: $themeKey"
        } else {
            Write-Log -Level Warning -Message "Attempted to set non-existent theme: $themeKey"
        }
    }

    # The core method for retrieving a fully resolved style object for a component.
    [hashtable] GetStyle([string]$componentPath) {
        $pathSegments = $componentPath.Split('.')
        $currentValue = $this._currentThemeObject
        
        # Traverse the path in the theme file (e.g., Components.Table.Header)
        foreach($segment in $pathSegments) {
            if ($currentValue -is [hashtable] -and $currentValue.ContainsKey($segment)) {
                $currentValue = $currentValue[$segment]
            } else {
                # Path not found, return an empty style to avoid errors in the calling code.
                Write-Log -Level Debug -Message "Theme path '$componentPath' not found. Returning empty style."
                return @{}
            }
        }
        
        # Now, resolve all palette references (e.g., '$Palette.accent1') in the retrieved style object.
        $resolvedStyle = @{}
        if ($currentValue -is [hashtable]) {
            foreach ($key in $currentValue.Keys) {
                $val = $currentValue[$key]
                $depth = 0 # HARDENING: Introduce depth counter to prevent infinite loops from circular references.
                
                while ($val -is [string] -and $val.StartsWith('$Palette.') -and $depth -lt 10) {
                    $paletteKey = $val.Substring(9)
                    # HARDENING: Check if the palette key actually exists to prevent errors.
                    if ($this._currentThemeObject.Palette.ContainsKey($paletteKey)) {
                        $val = $this._currentThemeObject.Palette[$paletteKey]
                    } else {
                        # Key not found, break loop and assign a visible error color for easy debugging.
                        Write-Log -Level Warning -Message "Theme '$($this._currentThemeKey)' is missing palette key: '$paletteKey' requested by '$componentPath'"
                        $val = $this._currentThemeObject.Palette.errorHighlight ?? '#FF00FF'
                        break
                    }
                    $depth++
                }
                # If it's still a variable after max depth, it's a circular reference.
                if ($val -is [string] -and $val.StartsWith('$Palette.')) {
                    Write-Log -Level Error -Message "Circular or unresolved palette reference detected at '$componentPath' for value '$val'"
                    $val = $this._currentThemeObject.Palette.errorHighlight ?? '#FF00FF'
                }
                $resolvedStyle[$key] = $val
            }
        }
        
        return $resolvedStyle
    }

    [string[]] GetThemeKeys() {
        return @($this._themes.Keys)
    }

    [hashtable] GetCurrentTheme() {
        return $this._currentThemeObject
    }
}

# Factory function to create the engine instance.
function Initialize-ThemeEngine {
    param([string]$themesDirectory)
    return [ThemeEngine]::new($themesDirectory)
}
# --- END OF REPLACEMENT for modules\theme-manager\theme-manager.psm1 ---
```

**Rationale:** This new `ThemeEngine` completely decouples visual styling from application logic. It allows for:
1.  **User Theming:** Users can create and drop in `.json` files to skin the entire application.
2.  **Centralized Palettes:** Colors are defined once in a `Palette` and reused via variables (`$Palette.accent1`), making theme maintenance trivial.
3.  **Resilience:** The engine includes a robust internal fallback theme and handles errors in external theme files gracefully.
4.  **Debugging:** The variable resolver is hardened against missing keys and circular references, applying a highly visible error color (`#FF00FF`) to make theme errors obvious.
5.  **Comprehensive Default Styles:** The default theme now includes styles for a much wider range of components (`Button`, `TextBox`, `Dialog`, etc.), ensuring basic theming is applied to new components out-of-the-box.

#### **Step 1.3: Refactor Drawing Primitives to be Style-Driven**

**File:** `axiom.txt`
**Location:** The `Write-TuiText` and `Write-TuiBox` functions within the `--- START OF ORIGINAL FILE: components\tui-primitives\tui-primitives.psm1 ---` section.
**Action:** The current drawing functions accept numerous individual parameters for styling (e.g., `-ForegroundColor`, `-BackgroundColor`, `-Bold`). This is verbose and contrary to a theme-driven architecture. We will refactor them to accept a single `-Style [hashtable]` parameter, which is the direct output of our `ThemeEngine`.

**Instruction:** **DELETE** the existing `function Write-TuiText { ... }` and `function Write-TuiBox { ... }` blocks and **REPLACE** them with the following refactored versions.

```powershell
# In components\tui-primitives\tui-primitives.psm1

function Write-TuiText {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [string]$Text,
        # MODIFIED: A single -Style parameter replaces all individual style flags.
        [hashtable]$Style = @{} 
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }

    # Extract properties from the style object, providing safe defaults using the null-coalescing operator.
    # This makes the function resilient to incomplete style definitions.
    $fg = $Style.FG ?? "#C0C0C0"
    $bg = $Style.BG ?? $null
    $bold = [bool]($Style.Bold ?? $false)
    $italic = [bool]($Style.Italic ?? $false)
    $underline = [bool]($Style.Underline ?? $false)
    $strikethrough = [bool]($Style.Strikethrough ?? $false)

    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $Buffer.Width) { break }
        if ($currentX -ge 0 -and $Y -ge 0 -and $Y -lt $Buffer.Height) {
            # Use the powerful new TuiCell constructor with all attributes.
            $charCell = [TuiCell]::new($char, $fg, $bg, $bold, $italic, $underline, $strikethrough)
            $Buffer.SetCell($currentX, $Y, $charCell)
        }
        $currentX++
    }
}

function Write-TuiBox {
    param(
        [TuiBuffer]$Buffer,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [string]$Title = "",
        # MODIFIED: The -Style parameter now drives all visual aspects of the box.
        [hashtable]$Style = @{}
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }

    # Extract properties from the style object with safe fallbacks.
    $borderStyleName = $Style.BorderStyle ?? "Single"
    $borderColor = $Style.BorderFG ?? "#808080" # Default border color: medium gray
    $bgColor = $Style.BG ?? $null               # Default background: transparent (if style doesn't provide one)
    $titleColor = $Style.TitleFG ?? $borderColor # Title defaults to border color if not specified.
    $titleStyleOverrides = $Style.TitleStyle ?? @{} # Allow specific overrides for title, e.g., Bold = $true

    $borders = Get-TuiBorderChars -Style $borderStyleName
    
    # Define style objects for child calls to Write-TuiText.
    # Crucially, pass through the BG from the main style to ensure content area fill is consistent.
    $borderStyle = @{ FG = $borderColor; BG = $bgColor }
    $titleStyle = @{ FG = $titleColor; BG = $bgColor }
    # Merge title overrides
    foreach($key in $titleStyleOverrides.Keys) { $titleStyle[$key] = $titleStyleOverrides[$key] }
    
    # Top border
    $topLine = "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)"
    Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $topLine -Style $borderStyle
    
    # Title if specified
    if (-not [string]::IsNullOrEmpty($Title)) {
        $titleText = " $Title "
        if ($titleText.Length -lt ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -Style $titleStyle
        }
    }
    
    # Side borders and fill
    if ($Height -gt 1) {
        $fillNeeded = ($bgColor -ne $null)
        $fillText = if ($fillNeeded) { ' ' * ($Width - 2) } else { '' }
        $fillStyle = @{ BG = $bgColor } # Only specify BG for fill text.

        for ($i = 1; $i -lt ($Height - 1); $i++) {
            $currentY = $Y + $i
            if ($currentY -ge 0 -and $currentY -lt $Buffer.Height) {
                Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -Style $borderStyle
                if ($fillNeeded) { Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text $fillText -Style $fillStyle }
                Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -Style $borderStyle
            }
        }
    }
    
    # Bottom border
    if ($Height -gt 1) {
        $bottomY = $Y + $Height - 1
        if ($bottomY -ge 0 -and $bottomY -lt $Buffer.Height) {
            $bottomLine = "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)"
            Write-TuiText -Buffer $Buffer -X $X -Y $bottomY -Text $bottomLine -Style $borderStyle
        }
    }
}
```

**Rationale:** This change is fundamental to enforcing a theme-driven design. Components no longer decide their own colors; they request a style from the `ThemeEngine` and pass it to the drawing primitives. This aligns with the "Don't Repeat Yourself" (DRY) principle and makes global visual changes possible by editing a single theme file instead of dozens of component files.

#### **Step 1.4: Revolutionize the Main Engine Renderer**

**File:** `axiom.txt`
**Location:** The `Render-CompositorToConsole` function within the `--- START OF ORIGINAL FILE: modules\tui-engine\tui-engine.psm1 ---` section.
**Action:** The current renderer is inefficient and does not support Truecolor. It will be replaced with a highly optimized version that performs differential rendering, minimizes ANSI escape code output, and uses our new Truecolor helpers. This is the most significant performance upgrade in the entire plan.

**Instruction:** **DELETE** the entire existing `function Render-CompositorToConsole { ... }` block. Also, **DELETE** the now obsolete `function Get-AnsiColorCode { ... }` from the same file section. **REPLACE** the deleted section with the following.

```powershell
# In modules\tui-engine\tui-engine.psm1

function Render-CompositorToConsole {
    # This buffer is increased to accommodate potentially longer Truecolor escape sequences.
    $outputBuilder = [System.Text.StringBuilder]::new(40000)
    $currentBuffer = $global:TuiState.CompositorBuffer
    $previousBuffer = $global:TuiState.PreviousCompositorBuffer
    
    # OPTIMIZATION: Track the last used style sequence as a string.
    # If the next cell has the same style, we don't need to send any new ANSI codes.
    $lastSequence = "RESET" # A unique sentinel value to ensure the first sequence is always sent.
    
    # On the very first frame, we must render everything. No diffing is possible.
    $forceFullRender = ($global:TuiState.RenderStats.FrameCount -eq 1)

    try {
        # Move cursor to home position once at the beginning of the entire render operation.
        [void]$outputBuilder.Append("`e[1;1H")

        for ($y = 0; $y -lt $currentBuffer.Height; $y++) {
            # Since we're doing a diff, we can't just skip whole lines. We must check cell by cell.
            # A variable to track if we've written anything to this line yet.
            $cursorMovedOnLine = $false
            
            for ($x = 0; $x -lt $currentBuffer.Width; $x++) {
                $newCell = $currentBuffer.GetCell($x, $y)
                
                # OPTIMIZATION 1: Differential Rendering
                # If not forcing a full render, compare the new cell to the one from the previous frame.
                if (-not $forceFullRender) {
                    $oldCell = $previousBuffer.GetCell($x, $y)
                    # If cells are identical, we don't need to draw it. We just need to ensure the cursor is in the right place.
                    if (-not $newCell.DiffersFrom($oldCell)) {
                        continue
                    }
                }
                
                # If we are here, the cell needs to be redrawn.
                # Move the cursor to the correct position for this cell.
                # This complex positioning ensures the cursor is ONLY moved when necessary.
                if (-not $cursorMovedOnLine) {
                    # If this is the first changed cell on the line, move to start of line, then to correct X
                    [void]$outputBuilder.Append("`e[$($y + 1);1H") 
                    if ($x -gt 0) { [void]$outputBuilder.Append("`e[$($x + 1)G") } # Absolute column positioning.
                    $cursorMovedOnLine = $true
                } else {
                    # If we've already written to this line, move relatively (assuming single-width characters).
                    # For performance, prefer absolute moves for reliability or if a gap occurs.
                    # This simple approach assumes no wide characters.
                    # A more robust solution would track current console cursor X.
                    # For now, explicit absolute move is safer after the initial line set.
                    [void]$outputBuilder.Append("`e[$($y + 1);$($x + 1)H") # Absolute cursor move
                }
                
                # Generate the full style sequence for the new cell using our Truecolor helper.
                $attributes = @{ Bold=$newCell.Bold; Italic=$newCell.Italic; Underline=$newCell.Underline; Strikethrough=$newCell.Strikethrough }
                $currentSequence = [TuiAnsiHelper]::GetAnsiSequence($newCell.ForegroundColor, $newCell.BackgroundColor, $attributes)

                # OPTIMIZATION 2: State Change Minimization
                # Only append the style sequence if it's different from the last one used.
                if ($currentSequence -ne $lastSequence) {
                    # To ensure a clean state, we combine a reset with the new style.
                    # This prevents style attributes from "leaking" between cells.
                    [void]$outputBuilder.Append([TuiAnsiHelper]::Reset()).Append($currentSequence)
                    $lastSequence = $currentSequence
                }
                
                # Finally, append the character itself.
                [void]$outputBuilder.Append($newCell.Char)
            }
        }
        
        # Append a final reset to ensure the terminal is clean after the application exits or rendering stops.
        [void]$outputBuilder.Append([TuiAnsiHelper]::Reset())
        
        # Write the entire frame's changes in one single, atomic operation to the console.
        if ($outputBuilder.Length -gt 0) {
            [Console]::Write($outputBuilder.ToString())
        }
    } catch {
        # Log any catastrophic rendering failure.
        Write-Log -Level Fatal -Message "Compositor-to-console rendering failed: $_" -Data $_
    }
}
```

**Rationale:** This new function is the heart of a modern TUI.
1.  **Differential Rendering:** By comparing the current buffer (`$currentBuffer`) to the last frame's (`$previousBuffer`), it only redraws pixels that have actually changed. This is the difference between rendering 80x25=2000 cells per frame and rendering maybe only 50 cells for a blinking cursor. The performance gain is monumental.
2.  **State Minimization:** By tracking `$lastSequence`, it avoids sending redundant ANSI escape codes. If ten consecutive cells are red with a black background, it sends the ANSI code for that style *once*, not ten times. This dramatically reduces the amount of data sent to the terminal, improving responsiveness, especially over SSH.
3.  **Atomic Write:** The entire frame is built in a `StringBuilder` and written to `[Console]::Write()` in a single call. This prevents the screen tearing that can occur from many small `Write-Host` calls.
4.  **Cursor Positioning:** The `G` escape code (`CSI n G`) is used for absolute column positioning within the current row, which is generally more reliable than relative moves after an initial absolute row/column set.

---

### **Pillar 2: Integrated Components & Command-Driven Architecture**

**Objective:** To replace the rigid numeric menu system with a modern, searchable command palette and to convert the standalone file browser utility into a fully integrated screen within the application. This pillar focuses on creating a seamless and efficient user workflow.

#### **Step 2.1: Implement Custom `ActionAttribute` and `ActionService`**

**Action:** We will define a custom attribute to mark functions as discoverable "Actions" and create a service to find them at startup.

**Instruction 1:** Add the `ActionAttribute` definition. This must be at the **very top** of the `axiom.txt` script, before any `using` statements or class definitions.

```powershell
# This must be at the top of the script, before any `using` statements or class definitions.
Add-Type -TypeDefinition @"
    using System;
    // An attribute to decorate functions that should appear in the command palette.
    // It allows us to attach metadata (Name, Group) directly to a function definition.
    [AttributeUsage(AttributeTargets.Function)]
    public class ActionAttribute : Attribute {
        public string Name { get; set; }
        public string Group { get; set; }
        public ActionAttribute(string name) { this.Name = name; }
    }
"@ -ErrorAction Stop
```

**Rationale:** This custom attribute is the contract. It provides a clean, declarative way to register a function with the command system without needing a central registration file. PowerShell's reflection capabilities will allow us to discover these at runtime.

**Instruction 2:** Create the `ActionService` responsible for discovering and caching all decorated functions at startup. This service needs to be initialized early in the application lifecycle.

**Instruction:** **ADD** the following new section to the monolith, grouped with other service definitions (e.g., after `keybinding-service-class.psm1`).

```powershell
# --- START OF ORIGINAL FILE for services/action-service.psm1 ---
class ActionService {
    [System.Collections.Generic.List[object]]$Actions

    ActionService() {
        $this.Actions = [System.Collections.Generic.List[object]]::new()
        $this.DiscoverActions()
    }

    [void] DiscoverActions() {
        # HARDENING: This "magic" discovery relies on reflection (Get-Command) to find functions
        # in the global scope of the session. It assumes no third-party modules will use an
        # attribute named [ActionAttribute]. For a more robust, large-scale system, an
        # "Inversion of Control" pattern where modules explicitly *register* their actions
        # with the ActionService (`$actionService.RegisterAction($functionObject)`) would provide
        # a more explicit and less fragile contract. For this project's scope, reflection is
        # a powerful and pragmatic solution.
        
        # Get all functions in the current session's global scope.
        $functions = Get-Command -CommandType Function -Scope Global
        foreach ($func in $functions) {
            # Find functions decorated with our custom ActionAttribute.
            $attribute = $func.Attributes | Where-Object { $_.TypeId.Name -eq 'ActionAttribute' }
            if ($attribute) {
                $this.Actions.Add([PSCustomObject]@{
                    Name = $attribute.Name
                    Group = $attribute.Group ?? "General"
                    Function = $func # Store the CommandInfo object, which contains the ScriptBlock
                })
            }
        }
        # Sort the discovered actions for a clean presentation in the UI.
        $this.Actions = $this.Actions | Sort-Object Group, Name
        Write-Log -Level Info -Message "Discovered $($this.Actions.Count) commands for the palette."
    }
}

function Initialize-ActionService {
    return [ActionService]::new()
}
# --- END OF ORIGINAL FILE for services/action-service.psm1 ---
```

**Rationale:** The `ActionService` centralizes the discovery logic. It runs once at startup, using `Get-Command` to find all functions and inspects their attributes. This is far more maintainable than a manually curated list of commands.

#### **Step 2.2: Implement `FileListComponent` and `ExplorerScreen`**

**Action:** We will create a new `FileListComponent` class to encapsulate file system browsing logic. Then, we will create a new `ExplorerScreen` to host this component, providing a full-featured, navigable file explorer inside the application.

**Instruction 1:** Add the new `FileListComponent` class. This is a reusable, data-driven component. It should be placed in the `--- START OF ORIGINAL FILE: components\advanced-data-components\advanced-data-components.psm1 ---` section, after the `Table` class definition.

```powershell
# In components\advanced-data-components\advanced-data-components.psm1

# A reusable component that displays and handles navigation of a file system directory.
class FileListComponent : UIElement {
    [string]$Path
    [System.IO.FileSystemInfo[]]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollTop = 0
    [bool]$ShowHidden = $false
    [hashtable]$SelectedItems = @{}
    # NEW: Callback for when selection changes
    [scriptblock]$OnSelectionChanged

    FileListComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Name = $name
    }

    [void] SetPath([string]$newPath) {
        # Resolve the path to its full, canonical form.
        try {
            $this.Path = (Get-Item -LiteralPath $newPath).FullName
            $this.Refresh()
        } catch {
            Write-Log -Level Error -Message "Failed to set path for FileListComponent: $_"
            # Optionally, show an alert dialog to the user.
            Show-AlertDialog -Title "Path Error" -Message "The path '$newPath' could not be found or accessed."
        }
    }

    [void] Refresh() {
        # HARDENING: The Get-ChildItem call is synchronous and WILL block the UI thread
        # if browsing a large directory or a slow network share. For a truly responsive UI,
        # this operation should be made asynchronous (e.g., using Start-Job or a runspace).
        # The component would then display a "Loading..." state and update once the job completes.
        
        # Always add ".." entry for parent directory navigation, unless at a drive root.
        $parentEntry = $null
        try {
            $parent = (Get-Item $this.Path).Parent
            if ($parent) {
                $parentEntry = [PSCustomObject]@{ Name = '..'; FullName = $parent.FullName; PSIsContainer = $true; LastWriteTime = $parent.LastWriteTime }
            }
        } catch { /* Suppress errors for roots that have no parent */ }

        $childItems = @(Get-ChildItem -LiteralPath $this.Path -Force:$this.ShowHidden -ErrorAction SilentlyContinue | Sort-Object @{ Expression = 'PSIsContainer'; Descending = $true }, Name)
        
        $this.Items = if ($parentEntry) { @($parentEntry) + $childItems } else { $childItems }

        # Clamp the selected index to valid bounds after refresh.
        if ($this.SelectedIndex -ge $this.Items.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
        }
        $this.UpdateScrolling() # Update scrolling position after data change
        $this.RequestRedraw()
    }
    
    hidden [void] UpdateScrolling() {
        # Ensure the selected item is always visible within the component's viewport.
        if ($this.SelectedIndex -lt $this.ScrollTop) {
            $this.ScrollTop = $this.SelectedIndex
        }
        if ($this.SelectedIndex -ge ($this.ScrollTop + $this.Height)) {
            $this.ScrollTop = $this.SelectedIndex - $this.Height + 1
        }
    }

    [void] OnRender() {
        if ($null -eq $this._private_buffer) { return }
        $this._private_buffer.Clear()
        
        # Retrieve styles from the theme engine. This component knows nothing about colors.
        $styleDefault = $Global:AxiomServices.ThemeEngine.GetStyle("Components.FileBrowser.Default")
        $styleDir = $Global:AxiomServices.ThemeEngine.GetStyle("Components.FileBrowser.Directory")
        $styleSelected = $Global:AxiomServices.ThemeEngine.GetStyle("Components.FileBrowser.Selected")

        $visibleCount = [Math]::Min($this.Items.Count - $this.ScrollTop, $this.Height)
        
        for ($i = 0; $i -lt $visibleCount; $i++) {
            $itemIndex = $this.ScrollTop + $i
            if ($itemIndex -ge $this.Items.Count) { break }
            
            $item = $this.Items[$itemIndex]
            $isCurrent = ($itemIndex -eq $this.SelectedIndex)
            
            $icon = if ($item.PSIsContainer) { "📁" } else { "📄" }
            # Truncate line to fit component width.
            $line = "$icon $($item.Name)"
            if ($line.Length -gt $this.Width) { $line = $line.Substring(0, $this.Width - 1) + "…" }
            $line = $line.PadRight($this.Width)

            $currentStyle = if ($item.PSIsContainer) { $styleDir } else { $styleDefault }
            if ($isCurrent -and $this.IsFocused) {
                # Merge the 'Selected' style over the top of the item's base style.
                foreach($key in $styleSelected.Keys) { $currentStyle[$key] = $styleSelected[$key] }
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y $i -Text $line -Style $currentStyle
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        $oldSelectedIndex = $this.SelectedIndex
        # This component only handles navigational input.
        switch ($keyInfo.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) { $this.SelectedIndex-- }
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt ($this.Items.Count - 1)) { $this.SelectedIndex++ }
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::PageUp) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this.Height)
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::PageDown) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this.Height)
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.UpdateScrolling(); $this.RequestRedraw(); return $true
            }
        }
        
        # If selection changed, trigger the event/callback
        if ($this.SelectedIndex -ne $oldSelectedIndex) {
            if ($this.OnSelectionChanged) {
                Invoke-WithErrorHandling -Component "$($this.Name).OnSelectionChanged" -Context "File Selection Changed" -ScriptBlock {
                    & $this.OnSelectionChanged -SelectedItem $this.Items[$this.SelectedIndex]
                }
            }
        }
        return $false # Did not handle the input.
    }
}
```

**Instruction 2:** Create the `ExplorerScreen` that uses this component. This is a new screen, so it requires a new file section in the monolith.

**Instruction:** **ADD** the following new section to the monolith script, preferably grouped with other screen definitions.

```powershell
# --- START OF ORIGINAL FILE for screens\explorer-screen\explorer-screen.psm1 ---
class ExplorerScreen : Screen {
    [Panel]$mainPanel
    [FileListComponent]$fileList
    [Panel]$previewPanel
    [Panel]$statusBar

    ExplorerScreen([hashtable]$services) : base("ExplorerScreen", $services) { }

    [void] Initialize() {
        $this.Width = $global:TuiState.BufferWidth
        $this.Height = $global:TuiState.BufferHeight

        # Layout the panels for the screen
        $listWidth = [Math]::Floor($this.Width * 0.5)
        
        $listPanel = [Panel]::new(1, 1, $listWidth, $this.Height - 4, "Files")
        $listPanel.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Panel")
        $this.AddChild($listPanel)
        
        $this.previewPanel = [Panel]::new($listPanel.X + $listPanel.Width, 1, $this.Width - $listPanel.Width - 2, $this.Height - 4, "Preview")
        $this.previewPanel.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Panel")
        $this.AddChild($this.previewPanel)
        
        $this.statusBar = [Panel]::new(1, $this.Height - 2, $this.Width - 2, 1)
        $this.statusBar.HasBorder = $false
        $this.AddChild($this.statusBar)

        # Create the file list component and add it to its containing panel.
        $this.fileList = [FileListComponent]::new("ExplorerFileList")
        # The component must be sized to fit within the panel's content area.
        $this.fileList.Resize($listPanel.ContentWidth, $listPanel.ContentHeight)
        $listPanel.AddChild($this.fileList)
    }

    [void] OnEnter() {
        # Set a starting path when the screen is entered.
        $this.fileList.SetPath((Get-Location).Path)
        Set-ComponentFocus -Component $this.fileList
        $this.UpdateStatusBar("Ctrl+P for commands | Enter to navigate/open")
        # NEW: Subscribe to the OnSelectionChanged event using the new scriptblock property
        $this.fileList.OnSelectionChanged = { param($SelectedItem) $this.OnSelectionChange($SelectedItem) }
    }
    
    # This screen handles the "Enter" key, which has meaning outside the FileListComponent.
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($keyInfo.Key -eq [ConsoleKey]::Enter) {
            $selectedItem = $this.fileList.Items[$this.fileList.SelectedIndex]
            if ($selectedItem.PSIsContainer) {
                # If it's a directory, navigate the component into it.
                $this.fileList.SetPath($selectedItem.FullName)
            } else {
                # If it's a file, perhaps open it externally or show a full-screen preview.
                Show-AlertDialog -Title "Action" -Message "Action for file '$($selectedItem.Name)' is not yet implemented."
            }
            return $true # We handled the 'Enter' key.
        }
        # Let the TUI engine pass input to the focused component (the file list) for navigation.
        return $false
    }
    
    # Event handler for when the file list selection changes.
    [void] OnSelectionChange([System.IO.FileSystemInfo]$SelectedItem) {
        $this.UpdateStatusBar("Path: $($this.fileList.Path)")
        $this.ShowFilePreview($SelectedItem)
    }
    
    [void] UpdateStatusBar([string]$text) {
        $this.statusBar.GetBuffer().Clear()
        # Use ThemeEngine for status bar style
        $statusBarTheme = $Global:AxiomServices.ThemeEngine.GetStyle("Components.StatusBar")
        $fg = $statusBarTheme.FG ?? '#a0a0a0'
        Write-TuiText -Buffer $this.statusBar.GetBuffer() -X 0 -Y 0 -Text $text -Style @{ FG = $fg }
        $this.statusBar.RequestRedraw()
    }
    
    [void] ShowFilePreview([System.IO.FileSystemInfo]$file) {
        $this.previewPanel.SetTitle("Preview: $($file.Name)")
        $this.previewPanel.ClearContent()
        
        if ($file.PSIsContainer) { return } # No preview for directories.

        # HARDENING: Reading large files synchronously will block the UI.
        # This preview should be limited to a few KB or made asynchronous.
        try {
            $content = Get-Content -Path $file.FullName -TotalCount $this.previewPanel.ContentHeight -ErrorAction Stop
            $previewStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.FileBrowser.PreviewText") ?? @{ FG = '#D4D4D4' }
            for ($i = 0; $i -lt $content.Count; $i++) {
                $line = $content[$i].Replace("`t", '    ') # Expand tabs
                Write-TuiText -Buffer $this.previewPanel.GetBuffer() -X $this.previewPanel.ContentX -Y ($this.previewPanel.ContentY + $i) -Text $line -Style $previewStyle
            }
        } catch {
            $errorStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.FileBrowser.PreviewError") ?? @{ FG = '#f85149' }
            Write-TuiText -Buffer $this.previewPanel.GetBuffer() -X $this.previewPanel.ContentX -Y $this.previewPanel.ContentY -Text "Error reading file: Not a text file or access denied." -Style $errorStyle
        }
        $this.previewPanel.RequestRedraw()
    }
}
```

**Rationale:** The file browser is no longer a monolithic function but a clean composition of a reusable `FileListComponent` hosted within a purpose-built `ExplorerScreen`. The screen manages layout and high-level actions (`Enter` key), while the component manages its own state and rendering. This separation of concerns is the core tenet of the new architecture. The `OnSelectionChanged` property provides a robust way for the parent screen to react to component events.

#### **Step 2.3: Implement the Command Palette Dialog**

**Action:** Now that we have `ActionService`, we will implement the `CommandPalette` dialog UI itself.

**Instruction:** **ADD** the following `CommandPalette` class definition to the `--- START OF FULL REPLACEMENT for modules\dialog-system-class\dialog-system-class.psm1 ---` section.

```powershell
# In modules\dialog-system-class\dialog-system-class.psm1

# A UIElement designed to be displayed modally over other content using the
# TUI Engine's overlay system. It handles its own rendering and input,
# and uses Show-TuiOverlay/Close-TopTuiOverlay to manage its lifecycle.
class CommandPalette : Dialog {
    [TextBoxComponent]$inputBox
    [Table]$resultsTable
    [object[]]$allActions
    [object[]]$filteredActions

    CommandPalette() : base("CommandPalette") {
        $this.Title = "Command Palette"
        # Dynamically size the palette to be a large portion of the screen.
        $this.Width = [Math]::Floor($global:TuiState.BufferWidth * 0.6)
        $this.Height = [Math]::Floor($global:TuiState.BufferHeight * 0.7)
        
        # Get the master list of actions from the service.
        $this.allActions = @($Global:AxiomServices.ActionService.Actions)
        $this.filteredActions = $this.allActions
        
        # Create the input box for filtering.
        $this.inputBox = New-TuiTextBox -Props @{ Name = "PaletteInput"; Width = $this.Width - 4; Height = 3 }
        $this.inputBox.Move(2, 1)
        # Wire up the text box's OnChange event to our filtering method.
        $this.inputBox.OnChange = { param($NewValue) $this.FilterActions($NewValue) }
        $this.AddChild($this.inputBox)

        # Create the table to display results.
        $this.resultsTable = New-TuiTable -Props @{ Name = "PaletteResults"; Width = $this.Width - 4; Height = $this.Height - 5 }
        $this.resultsTable.Move(2, 4)
        $this.resultsTable.ShowBorder = $false
        $this.resultsTable.SetColumns(@(
            [TableColumn]::new('Name', 'Action', [Math]::Floor(($this.Width-6)*0.7)),
            [TableColumn]::new('Group', 'Group', [Math]::Floor(($this.Width-6)*0.3))
        ))
        $this.resultsTable.SetData($this.filteredActions)
        $this.AddChild($this.resultsTable)
        
        # Immediately focus the input box when the dialog is shown.
        Set-ComponentFocus -Component $this.inputBox
    }

    [void] FilterActions([string]$searchText) {
        if ([string]::IsNullOrWhiteSpace($searchText)) {
            $this.filteredActions = $this.allActions
        } else {
            $this.filteredActions = $this.allActions | Where-Object { $_.Name -like "*$searchText*" -or $_.Group -like "*$searchText*" }
        }
        $this.resultsTable.SetData($this.filteredActions)
        $this.RequestRedraw()
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender() # Call base dialog render to draw box and title
        # Render children (input box and results table)
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $child.Render()
                if ($null -ne $child.{_private_buffer}) {
                    $this.{_private_buffer}.BlendBuffer($child.{_private_buffer}, $child.X, $child.Y)
                }
            }
        }
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # Pass input to focused child first (inputBox or resultsTable)
        # This will need refinement for proper Tab navigation between input and table.
        # For now, if input is handled by child, done.
        # Otherwise, special keys are handled here.
        if ($this.inputBox.IsFocused -and $this.inputBox.HandleInput($key)) {
            return $true
        }
        if ($this.resultsTable.IsFocused -and $this.resultsTable.HandleInput($key)) {
            return $true
        }

        switch ($key.Key) {
            ([ConsoleKey]::Escape) { $this.OnCancel(); return $true }
            ([ConsoleKey]::Enter) { $this.ExecuteSelectedAction(); return $true }
            ([ConsoleKey]::DownArrow) { $this.resultsTable.SelectNext(); return $true }
            ([ConsoleKey]::UpArrow) { $this.resultsTable.SelectPrevious(); return $true }
            ([ConsoleKey]::Tab) {
                if ($this.inputBox.IsFocused) {
                    Set-ComponentFocus -Component $this.resultsTable
                } else {
                    Set-ComponentFocus -Component $this.inputBox
                }
                return $true
            }
        }
        return ([Dialog]$this).HandleInput($key) # Fallback to base dialog handling
    }

    [void] ExecuteSelectedAction() {
        $selectedAction = $this.resultsTable.GetSelectedItem()
        if ($selectedAction) {
            $this.Close()
            Invoke-WithErrorHandling -Component "CommandPalette" -Context "ExecuteAction" -ScriptBlock {
                & $selectedAction.Function.ScriptBlock
            } -AdditionalData @{ ActionName = $selectedAction.Name }
        }
    }
}
```

**Rationale:** The `CommandPalette` uses the `ActionService` to populate its searchable list. It demonstrates a complex dialog made possible by the robust UI element and theming system.

#### **Step 2.4: Wire Up Global Command Palette Trigger and Define Sample Actions**

**Action:** The Command Palette needs a universal hotkey to open it. We will also define a few sample actions that the `ActionService` can discover.

**Instruction 1:** Modify the `Process-SingleKeyInput` function in `modules\tui-engine\tui-engine.psm1` to include the global hotkey for the Command Palette.

```powershell
# In modules\tui-engine\tui-engine.psm1

function Process-SingleKeyInput {
    param($keyInfo)
    
    # NEW: Check for global command palette keybind (Ctrl+P) at the highest priority.
    if (($keyInfo.Modifiers -band [ConsoleModifiers]::Control) -and $keyInfo.Key -eq 'P') {
        $palette = [CommandPalette]::new()
        $palette.Show()
        return # Input is handled.
    }

    # If there's an active overlay, give it priority.
    if ($global:TuiState.OverlayStack.Count -gt 0) {
        $overlay = $global:TuiState.OverlayStack[-1]
        if ($overlay.HandleInput($keyInfo)) { return }
    }

    # Handle Tab for focus navigation
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }

    # Give the currently focused component a chance to handle the input.
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent -and $focusedComponent.HandleInput($keyInfo)) {
        return
    }

    # Finally, give the current screen a chance to handle the input.
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            $currentScreen.HandleInput($keyInfo)
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}
```

**Instruction 2:** Add the global command definitions. These functions, decorated with `[Action]`, will be discovered by the `ActionService`.

**Instruction:** **ADD** the following new file section for global commands. This ensures the command logic is organized and separate from other code. It should be placed after other services but before the main startup logic.

```powershell
# --- START OF ORIGINAL FILE for commands/global-commands.psm1 ---
# This file contains globally available actions for the Command Palette.
# Each function is decorated with the [Action] attribute to make it discoverable.

[Action("Application: Quit", Group="Application")]
function Request-AppQuit {
    $Global:AxiomServices.Navigation.RequestExit()
}

[Action("Application: Force UI Refresh", Group="Application")]
function Request-UIRefresh {
    # This forces a full, non-differential render of the entire screen.
    $global:TuiState.RenderStats.FrameCount = 1
    Request-TuiRefresh
}

[Action("Navigation: Go to Dashboard", Group="Navigation")]
function Navigate-ToDashboard {
    $Global:AxiomServices.Navigation.GoTo("/dashboard")
}

[Action("Navigation: Go to File Explorer", Group="Navigation")]
function Navigate-ToFileExplorer {
    $Global:AxiomServices.Navigation.GoTo("/explorer")
}

[Action("Theme: Cycle to Next Theme", Group="Theme")]
function Cycle-Theme {
    $engine = $Global:AxiomServices.ThemeEngine
    $themes = $engine.GetThemeKeys()
    if ($themes.Count -lt 2) { return } # No cycling if only one theme.
    
    $currentIndex = [array]::IndexOf($themes, $engine._currentThemeKey)
    $nextIndex = ($currentIndex + 1) % $themes.Count
    $engine.SetTheme($themes[$nextIndex])
    
    # Force a full redraw to apply the new theme everywhere.
    $global:TuiState.RenderStats.FrameCount = 1
    Request-TuiRefresh
}
# --- END OF ORIGINAL FILE for commands/global-commands.psm1 ---
```

**Rationale:** The Command Palette provides a centralized, flexible way for users to interact with the application, moving away from rigid menu structures. The `[Action]` attribute and `ActionService` streamline action discovery and management.

---

### **Pillar 3: Re-imagining the Screens**

**Objective:** To replace the outdated `DashboardScreen` and `TaskListScreen` with modern, powerful equivalents. The dashboard will become a "widget-based" container for at-a-glance information. The task list will transform into a "Kanban-style" `TaskFlowScreen` for visual workflow management. This involves a complete deletion and replacement of the existing screen code.

#### **Step 3.1: Refactor `DashboardScreen` to be Widget-Based**

**Action:** The old `DashboardScreen` with its static panels and integrated `NavigationMenu` is obsolete. The command palette now handles navigation. This screen will be simplified into a layout container that hosts various self-contained "widget" components. Each widget is a specialized `Panel` responsible for fetching and rendering its own data.

**Instruction:** **DELETE** the entire existing `screens\dashboard-screen\dashboard-screen.psm1` section from the monolith. **REPLACE** it with the following new definition, which includes the screen itself and two new widget component classes.

```powershell
# --- START OF ORIGINAL FILE for screens\dashboard-screen\dashboard-screen.psm1 ---
# ==============================================================================
# PMC Terminal v5 - Widget-Based Dashboard Screen
# A modern dashboard that hosts various informational widgets. Each widget is a
# self-contained component that pulls its own data and renders into its area.
# ==============================================================================

# First, define the new widget components. These are specialized, data-aware panels.
class UpcomingTasksWidget : Panel {
    hidden [string] $_eventSubscriptionId # To hold the ID of the event subscription for cleanup.

    UpcomingTasksWidget([string]$name) : base($name) { 
        $this.Title = "Up Next"
        # The widget needs a reference to itself for the scriptblock.
        $self = $this 
        # NEW: Subscribe to data changes to automatically refresh.
        $this._eventSubscriptionId = $this.SubscribeToEvent("Tasks.Changed", { $self.RefreshData() })
    }

    # NEW: Implement RefreshData method to fetch data.
    [void] RefreshData() {
        if ($null -eq $this.Parent -or $null -eq $this.Parent.Services) { return } # Ensure services are available.
        $tasks = $this.Parent.Services.DataManager.GetTasks($false) # Get only pending tasks
        # Cache the data if needed, or process directly for rendering.
        # For simplicity, render directly in OnRender. This method just requests redraw.
        $this.RequestRedraw()
    }

    # NEW: Override OnCleanup to unsubscribe from events.
    [void] OnCleanup() {
        if ($this._eventSubscriptionId) { Unsubscribe-Event -HandlerId $this._eventSubscriptionId }
        ([Panel]$this).OnCleanup() # Call base class cleanup.
    }

    [void] OnRender() {
        # First, apply the theme style and call the base Panel's OnRender to draw our box and title.
        $this.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.UpNext")
        ([Panel]$this).OnRender()

        # Get data directly on render for simplicity (could be cached in RefreshData).
        $tasks = $this.Parent.Services.DataManager.GetTasks($false) # Get only pending tasks
        $upcoming = $tasks | Sort-Object { $_.DueDate ?? [datetime]::MaxValue } | Select-Object -First ($this.ContentHeight)
        
        $style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Text.Default")
        $overdueStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Text.Overdue")
        
        $y = 0
        foreach($task in $upcoming) {
            $currentStyle = $style
            $dateText = if ($task.DueDate) { $task.DueDate.Value.ToString("yyyy-MM-dd") } else { "No Date" }
            if ($task.DueDate -and $task.DueDate.Value.Date -lt (Get-Date).Date) {
                $currentStyle = $overdueStyle
                $dateText += " (OVERDUE)"
            }
            # Construct a clean, padded line for display.
            $titlePadded = $task.Title.PadRight([Math]::Max(0, $this.ContentWidth - 25))
            $priorityPadded = "[$($task.Priority.ToString().PadRight(6))]"
            $line = "$titlePadded $priorityPadded $dateText"
            
            Write-TuiText -Buffer $this._private_buffer -X $this.ContentX -Y ($this.ContentY + $y) -Text $line -Style $currentStyle
            $y++
        }
    }
}

class StatsWidget : Panel {
    hidden [string] $_eventSubscriptionId # To hold the ID of the event subscription for cleanup.

    StatsWidget([string]$name) : base($name) { 
        $this.Title = "Project Stats" 
        $self = $this
        # NEW: Subscribe to data changes to automatically refresh.
        $this._eventSubscriptionId = $this.SubscribeToEvent("Tasks.Changed", { $self.RefreshData() })
    }

    # NEW: Implement RefreshData method to fetch data.
    [void] RefreshData() {
        if ($null -eq $this.Parent -or $null -eq $this.Parent.Services) { return } # Ensure services are available.
        # Data is fetched directly in OnRender for simplicity here, but RefreshData requests redraw.
        $this.RequestRedraw()
    }

    # NEW: Override OnCleanup to unsubscribe from events.
    [void] OnCleanup() {
        if ($this._eventSubscriptionId) { Unsubscribe-Event -HandlerId $this._eventSubscriptionId }
        ([Panel]$this).OnCleanup() # Call base class cleanup.
    }

    [void] OnRender() {
        $this.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Stats")
        ([Panel]$this).OnRender()
        
        $tasks = $this.Parent.Services.DataManager.GetTasks()
        if ($tasks.Count -eq 0) {
            $defaultStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Text.Default")
            Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 1) -Text "No task data available." -Style $defaultStyle
            return
        }

        $completed = ($tasks | Where-Object { $_.Completed }).Count
        $percentage = [Math]::Round(($completed / $tasks.Count) * 100)
        
        $barLength = $this.ContentWidth - 4
        $filledLength = [Math]::Round(($percentage / 100) * $barLength)
        $bar = ("█" * $filledLength) + ("░" * ($barLength - $filledLength))

        $defaultTextStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Widget.Text.Default")
        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 1) -Text "Overall Progress: $percentage%" -Style $defaultTextStyle
        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 3) -Text $bar -Style @{ FG = ($Global:AxiomServices.ThemeEngine.GetStyle("Palette.success").FG ?? '#3fb950') } # Direct hex or from palette
        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 5) -Text "Total Tasks: $($tasks.Count)" -Style $defaultTextStyle
        Write-TuiText -Buffer $this._private_buffer -X ($this.ContentX + 1) -Y ($this.ContentY + 6) -Text "Completed:   $completed" -Style $defaultTextStyle
    }
}

# The main screen class itself is now a simple layout container for widgets.
class DashboardScreen : Screen {
    [System.Collections.Generic.List[UIElement]]$Widgets
    
    DashboardScreen([hashtable]$services) : base("DashboardScreen", $services) { }

    [void] Initialize() {
        $this.Width = $global:TuiState.BufferWidth
        $this.Height = $global:TuiState.BufferHeight
        $this.Widgets = [System.Collections.Generic.List[UIElement]]::new()
        
        # Create and add widgets to the screen's children for rendering.
        # The layout is declarative.
        $upNextWidget = [UpcomingTasksWidget]::new("UpNext")
        $upNextWidget.Move(1, 1); $upNextWidget.Resize([Math]::Floor($this.Width * 0.6), 12)
        $this.AddChild($upNextWidget)
        $this.Widgets.Add($upNextWidget)
        
        $statsWidget = [StatsWidget]::new("QuickStats")
        $statsWidget.Move($upNextWidget.X + $upNextWidget.Width + 1, 1); $statsWidget.Resize($this.Width - $upNextWidget.Width - 4, 12)
        $this.AddChild($statsWidget)
        $this.Widgets.Add($statsWidget)
        
        # Add a placeholder for a future log widget.
        $logPanel = [Panel]::new(1, 14, $this.Width - 2, $this.Height - 15, "Recent Log Entries")
        $logPanel.Style = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Panel")
        $this.AddChild($logPanel)
    }
    
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # When the screen resizes, recalculate the layout of its children.
        # Note: Children need to be retrieved by name or reference if not directly stored.
        # If panels are simply added via AddChild, you'd iterate Children property.
        $upNext = $this.Children | Where-Object { $_.Name -eq 'UpNext' } | Select-Object -First 1
        $stats = $this.Children | Where-Object { $_.Name -eq 'QuickStats' } | Select-Object -First 1
        $logPanel = $this.Children | Where-Object { $_.Name -eq 'Recent Log Entries' } | Select-Object -First 1 # Using title as name for simplicity.
        
        if ($upNext) {
            $upNextWidth = [Math]::Floor($newWidth * 0.6)
            $upNext.Resize($upNextWidth, 12)
        }
        
        if ($stats -and $upNext) {
            $stats.Move($upNext.X + $upNext.Width + 1, 1)
            $stats.Resize($newWidth - $upNext.Width - 4, 12)
        }

        if ($logPanel) {
            $logPanel.Move(1, 14)
            $logPanel.Resize($newWidth - 2, $newHeight - 15)
        }
    }

    [void] OnEnter() {
        # Manually trigger a refresh for all widgets (via their RefreshData method) the first time the screen is shown.
        foreach($widget in $this.Widgets) {
            # Use PowerShell's method invocation syntax for clarity.
            if ($widget.PsObject.Methods['RefreshData']) { $widget.RefreshData() }
        }
    }

    # Input is now handled by the command palette (Ctrl+P) or global Tab, so this method is empty.
    # The screen itself doesn't need to handle any keys unless it has specific direct commands.
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) { 
        return $false 
    }
}
```

**Rationale:** This new `DashboardScreen` embodies the component-based philosophy. The screen's only job is layout. All the logic for displaying upcoming tasks or statistics is encapsulated within the `UpcomingTasksWidget` and `StatsWidget` classes. This makes the dashboard easily extensible: adding a new widget is as simple as defining a new class and adding it to the screen's `Initialize` method. Crucially, widgets now subscribe to `Tasks.Changed` events and have `OnCleanup` methods to prevent memory leaks. The `OnResize` method ensures panels correctly adapt to terminal size changes.

#### **Step 3.2: Implement the `TaskFlowScreen` and `KanbanBoardComponent`**

**Action:** This is a completely new feature that replaces the old, simplistic `TaskListScreen`. We will create a `KanbanBoardComponent` that visually organizes tasks into columns by their status. This component will be hosted by the new `TaskFlowScreen`.

**Instruction:** **DELETE** the entire existing `screens\task-list-screen\task-list-screen.psm1` section from the monolith. **ADD** the following new file section in its place.

```powershell
# --- START OF ORIGINAL FILE for screens\task-flow-screen\task-flow-screen.psm1 ---
# ==============================================================================
# PMC Terminal v5 - Task Flow (Kanban) Screen
# Visual, interactive task board for managing workflow. This screen provides a
# more intuitive way to view and manage task progression than a simple list.
# ==============================================================================

# Define simple data models for the board's structure. These are view-models,
# not the core PmcTask model.
class KanbanCard { [string]$Id; [string]$Title; [string]$Priority; [object]$Data }
class KanbanColumn { [string]$Title; [System.Collections.Generic.List[KanbanCard]]$Cards }

# This is a complex, interactive component that renders a horizontally scrollable Kanban board.
class KanbanBoardComponent : ScrollablePanel {
    [KanbanColumn[]]$Columns
    [int]$SelectedColumn = 0
    [int]$SelectedCard = 0
    hidden [string] $_eventSubscriptionId # For refreshing data.

    KanbanBoardComponent([string]$name) : base($name) {
        $this.Columns = @()
        $this.IsFocusable = $true
        $self = $this
        # NEW: Subscribe to data changes to automatically refresh.
        $this._eventSubscriptionId = $this.SubscribeToEvent("Tasks.Changed", { $self.RefreshData() })
    }

    # NEW: Implement RefreshData method to fetch data.
    [void] RefreshData() {
        if ($null -eq $this.Parent -or $null -eq $this.Parent.Services) { return }
        $tasks = $this.Parent.Services.DataManager.GetTasks()
        $this.SetData($tasks)
    }

    # NEW: Override OnCleanup to unsubscribe from events.
    [void] OnCleanup() {
        if ($this._eventSubscriptionId) { Unsubscribe-Event -HandlerId $this._eventSubscriptionId }
        ([ScrollablePanel]$this).OnCleanup() # Call base class cleanup.
    }

    # Populates the component with data transformed from the DataManager.
    [void] SetData([PmcTask[]]$tasks) {
        # Initialize columns with empty card lists
        $columns = @{
            "Pending" = [System.Collections.Generic.List[KanbanCard]]::new();
            "InProgress" = [System.Collections.Generic.List[KanbanCard]]::new();
            "Completed" = [System.Collections.Generic.List[KanbanCard]]::new();
            "Cancelled" = [System.Collections.Generic.List[KanbanCard]]::new();
        }

        foreach ($task in $tasks) {
            $card = [KanbanCard]@{ Id = $task.Id; Title = $task.Title; Priority = $task.Priority.ToString(); Data = $task }
            $statusString = $task.Status.ToString()
            if ($columns.ContainsKey($statusString)) {
                $columns[$statusString].Add($card)
            } else {
                Write-Log -Level Warning -Message "Task status '$statusString' does not map to a Kanban column. Task: $($task.Title)"
            }
        }

        $kanbanColumns = @(
            [KanbanColumn]@{ Title="Pending"; Cards = $columns.Pending };
            [KanbanColumn]@{ Title="In Progress"; Cards = $columns.InProgress };
            [KanbanColumn]@{ Title="Completed"; Cards = $columns.Completed };
            [KanbanColumn]@{ Title="Cancelled"; Cards = $columns.Cancelled };
        )
        
        $this.Columns = $kanbanColumns
        $this.VirtualWidth = $this.Columns.Count * 31 # 30 for column width, 1 for margin
        $this.VirtualHeight = 30 # An arbitrary large virtual height (max height for card drawing).
        
        # Clamp selected card/column if data changed significantly.
        $this.SelectedColumn = [Math]::Min($this.SelectedColumn, $this.Columns.Count - 1)
        if ($this.SelectedColumn -lt 0) { $this.SelectedColumn = 0 }
        
        if ($this.Columns.Count -gt 0) {
            $currentColCardCount = $this.Columns[$this.SelectedColumn].Cards.Count
            $this.SelectedCard = [Math]::Min($this.SelectedCard, $currentColCardCount - 1)
            if ($this.SelectedCard -lt 0) { $this.SelectedCard = 0 }
        }
        
        $this.RequestRedraw()
    }
    
    [void] OnRender() {
        # This component renders to the virtual buffer provided by its parent ScrollablePanel class.
        $buffer = $this.GetVirtualBuffer()
        if ($null -eq $buffer) { return }
        $buffer.Clear()
        
        $colStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Kanban.Column")
        $cardStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Kanban.Card")
        $cardSelectedStyle = $Global:AxiomServices.ThemeEngine.GetStyle("Components.Kanban.CardSelected")

        $xOffset = 0
        for ($c = 0; $c -lt $this.Columns.Count; $c++) {
            $column = $this.Columns[$c]
            # Draw the column container box.
            Write-TuiBox -Buffer $buffer -X $xOffset -Y 0 -Width 30 -Height ($this.VirtualHeight -1) -Title "$($column.Title) ($($column.Cards.Count))" -Style $colStyle

            $yOffset = 1
            for ($r = 0; $r -lt $column.Cards.Count; $r++) {
                if ($yOffset + 4 > $this.VirtualHeight) { break } # Don't draw past virtual height
                $card = $column.Cards[$r]
                
                # Determine the style based on focus and selection state.
                $styleToUse = if($c -eq $this.SelectedColumn -and $r -eq $this.SelectedCard -and $this.IsFocused) { $cardSelectedStyle } else { $cardStyle }
                
                # Draw the card as a smaller box within the column.
                $cardTitle = "$($card.Title) [$($card.Priority)]".PadRight(26).Substring(0, 26)
                Write-TuiBox -Buffer $buffer -X ($xOffset+1) -Y $yOffset -Width 28 -Height 3 -Title $cardTitle -Style $styleToUse
                $yOffset += 4
            }
            $xOffset += 31 # Move to the next column position.
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        $colCount = $this.Columns.Count
        if ($colCount -eq 0) { return $false }
        $cardCount = $this.Columns[$this.SelectedColumn].Cards.Count
        
        $navigated = $true
        switch ($keyInfo.Key) {
            ([ConsoleKey]::RightArrow) {
                if ($this.SelectedColumn -lt $colCount - 1) { $this.SelectedColumn++; $this.SelectedCard = 0 }
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this.SelectedColumn -gt 0) { $this.SelectedColumn--; $this.SelectedCard = 0 }
            }
            ([ConsoleKey]::DownArrow) {
                if ($cardCount -gt 0 -and $this.SelectedCard -lt $cardCount - 1) { $this.SelectedCard++ }
            }
            ([ConsoleKey]::UpArrow) {
                if ($cardCount -gt 0 -and $this.SelectedCard -gt 0) { $this.SelectedCard-- }
            }
            default { $navigated = $false }
        }
        
        if ($navigated) { $this.RequestRedraw(); return $true }
        
        # Pass unhandled keys (like PageUp/Down) to the parent ScrollablePanel for scrolling.
        return ([ScrollablePanel]$this).HandleInput($keyInfo)
    }
}

# The screen class is a simple host for the Kanban board.
class TaskFlowScreen : Screen {
    [KanbanBoardComponent]$kanbanBoard

    TaskFlowScreen([hashtable]$services) : base("TaskFlowScreen", $services) { }

    [void] Initialize() {
        $this.kanbanBoard = [KanbanBoardComponent]::new("TaskKanban")
        $this.AddChild($this.kanbanBoard)
        $this.kanbanBoard.Resize($this.Width, $this.Height)
        $this.kanbanBoard.HasBorder = $false # The screen is the main container.
    }
    
    [void] OnEnter() {
        # When the screen is entered, fetch fresh data and populate the component.
        # This will trigger RefreshData on the component and its children if they have it.
        $this.kanbanBoard.RefreshData()
        Set-ComponentFocus -Component $this.kanbanBoard
    }
}
```

**Rationale:** The `TaskFlowScreen` and `KanbanBoardComponent` are a prime example of the new architecture's power.
1.  **Visual Interaction:** It provides a far more intuitive "at a glance" view of project status than a simple list.
2.  **Component Reusability:** The `KanbanBoardComponent` is self-contained. It could be reused on the dashboard as a smaller widget or in other screens with different data sources.
3.  **Inheritance:** It inherits from `ScrollablePanel`, gaining horizontal and vertical scrolling capabilities for free, without duplicating that logic.
4.  **Decoupling:** The screen's only job is to fetch the data and give it to the component. The component handles all rendering and interaction logic.
5.  **Event Subscription:** The `KanbanBoardComponent` now correctly subscribes to `Tasks.Changed` for auto-refresh.

---

### **Pillar 4: Decoupled Backend Services (Corrected)**

**Objective:** To extract business logic that has no direct UI representation into dedicated service classes. This plan will demonstrate the pattern by creating a `TimeSheetService` to handle time-tracking logic, which is currently mixed into other components or non-existent. We will then create a UI screen that is purely a consumer of this service.

#### **Step 4.1: Create the `TimeSheetService`**

**Action:** We will create a new `TimeSheetService` class. This service will contain all logic for starting and stopping timers against tasks and for calculating time summaries. It will interact with the `DataManager` but will have no knowledge of any UI components like screens or panels.

**Instruction:** **ADD** the following new section to the monolith, grouped with other service definitions.

```powershell
# --- START OF ORIGINAL FILE for services/timesheet-service.psm1 ---
class TimeSheetService {
    hidden [DataManager]$_dataManager

    TimeSheetService([DataManager]$dm) {
        if ($null -eq $dm) { throw [System.ArgumentNullException]::new("DataManager cannot be null.") }
        $this._dataManager = $dm
    }

    [void] StartTimer([PmcTask]$task) {
        if (-not $task) { throw "Task cannot be null." }
        $activeTimers = $this._dataManager._dataStore.ActiveTimers
        if ($activeTimers.ContainsKey($task.Id)) {
            Write-Log -Level Warning -Message "Timer for task $($task.Id) is already running."
            return
        }
        $activeTimers[$task.Id] = @{ StartTime = [datetime]::Now; ProjectKey = $task.ProjectKey }
        Write-Log -Level Info -Message "Started timer for task: $($task.Title)"
        # Publish a generic event that UI components can subscribe to.
        Publish-Event -EventName "Timers.Changed" -Data @{ TaskId = $task.Id; Status = "Started" }
    }

    [void] StopTimer([PmcTask]$task) {
        if (-not $task) { throw "Task cannot be null." }
        $activeTimers = $this._dataManager._dataStore.ActiveTimers
        if (-not $activeTimers.ContainsKey($task.Id)) { return }
        
        $timerData = $activeTimers[$task.Id]
        $endTime = [datetime]::Now
        $duration = ($endTime - $timerData.StartTime)
        
        # Add a new time entry to the data store.
        $this._dataManager._dataStore.time_entries.Add(@{
            EntryId = [Guid]::NewGuid().ToString()
            TaskId = $task.Id
            ProjectKey = $timerData.ProjectKey
            StartTime = $timerData.StartTime
            EndTime = $endTime
            DurationSeconds = $duration.TotalSeconds
        })
        
        [void]$activeTimers.Remove($task.Id)
        Write-Log -Level Info -Message "Stopped timer for task: $($task.Title). Duration: $($duration.ToString('hh\:mm\:ss'))"
        Publish-Event -EventName "Timers.Changed" -Data @{ TaskId = $task.Id; Status = "Stopped" }
    }

    # This method returns pure data, not formatted strings.
    [object[]] GetWeeklySummary() {
        $entries = $this._dataManager._dataStore.time_entries | Where-Object { $_.StartTime -ge (Get-Date).Date.AddDays(-7) }
        $summary = $entries | Group-Object ProjectKey | ForEach-Object {
            [PSCustomObject]@{
                Project = $_.Name
                TotalHours = [Math]::Round(($_.Group | Measure-Object DurationSeconds -Sum).Sum / 3600, 2)
            }
        }
        return $summary
    }

    # HARDENING: This service method returns raw data (a string). It does not
    # interact with the filesystem. The calling UI component is responsible for
    # handling the file I/O, which maintains a clean separation of concerns.
    [string] GetWeeklySummaryAsTsv() {
        $summaryData = $this.GetWeeklySummary()
        if ($summaryData.Count -eq 0) { return "" }
        
        # Convert the data to a TSV string in memory.
        return ($summaryData | ConvertTo-Csv -Delimiter "`t" -NoTypeInformation | Out-String)
    }
}

function Initialize-TimeSheetService {
    param([DataManager]$DataManager)
    return [TimeSheetService]::new($DataManager)
}
# --- END OF ORIGINAL FILE for services/timesheet-service.psm1 ---
```

**Rationale:** The `TimeSheetService` is a perfect example of a decoupled backend service. It encapsulates a specific domain of business logic (time tracking). It depends on another service (`DataManager`) for data persistence but knows nothing about how its data will be displayed. Its methods return pure data objects (`[object[]]`) or raw data (`[string]`), not formatted UI strings.

#### **Step 4.2: Create the `TimeSheetScreen` to Consume the Service**

**Action:** We will now create a new UI screen that is a pure consumer of the `TimeSheetService`. This screen's only job is to ask the service for data and display it in a table. We will also add a Command Palette action that uses the service to export data.

**Instruction:** **ADD** the following new file section to the monolith.

```powershell
# --- START OF ORIGINAL FILE for screens/timesheet-screen.psm1 ---
class TimeSheetScreen : Screen {
    [Table]$summaryTable
    hidden [string] $_eventSubscriptionId # For refreshing data.

    TimeSheetScreen([hashtable]$services) : base("TimeSheetScreen", $services) {}

    [void] Initialize() {
        $this.summaryTable = New-TuiTable -Props @{ 
            Name = "TimeSheetSummary"
            Width = $this.Width
            Height = $this.Height
            ShowHeader = $true
            ShowBorder = $true
        }
        $this.summaryTable.Title = "Weekly Time Summary by Project"
        
        $this.summaryTable.SetColumns(@(
            [TableColumn]::new('Project', 'Project', 40),
            [TableColumn]::new('TotalHours', 'Total Hours (This Week)', 25)
        ))
        $this.AddChild($this.summaryTable)

        $self = $this
        # NEW: Subscribe to data changes to automatically refresh.
        $this._eventSubscriptionId = $this.SubscribeToEvent("Timers.Changed", { $self.RefreshData() })
        $this.SubscribeToEvent("Tasks.Changed", { $self.RefreshData() }) # Tasks changing may impact summaries.
    }

    # NEW: Implement RefreshData method to fetch data.
    [void] RefreshData() {
        # The screen asks the service for data and passes it to the UI component.
        # The screen itself does not understand the data's structure.
        $summary = $this.Services.TimeSheetService.GetWeeklySummary()
        $this.summaryTable.SetData($summary)
        $this.RequestRedraw()
    }

    # NEW: Override OnCleanup to unsubscribe from events.
    [void] OnCleanup() {
        if ($this._eventSubscriptionId) { Unsubscribe-Event -HandlerId $this._eventSubscriptionId }
        # The screen also subscribes to Tasks.Changed in Initialize, ensure it's cleaned up too if the screen handles that subscription manually.
        # For this scenario, since SubscribeToEvent is used, the screen's base OnCleanup will handle it.
        ([Screen]$this).OnCleanup() # Call base class cleanup.
    }

    [void] OnEnter() {
        $this.RefreshData()
    }
}

# Add an action to the Command Palette that uses the TimeSheetService.
[Action("TimeSheet: Export Weekly Summary to Desktop", Group="TimeSheet")]
function Export-WeeklyTimeSheet {
    # This action is pure logic; it knows nothing about the current screen.
    $timeSheetService = $Global:AxiomServices.TimeSheetService
    
    $tsvContent = $timeSheetService.GetWeeklySummaryAsTsv()
    
    if ([string]::IsNullOrWhiteSpace($tsvContent)) {
        Show-AlertDialog -Title "Export" -Message "No data available to export for the past 7 days."
        return
    }

    try {
        $desktopPath = [Environment]::GetFolderPath('Desktop')
        $fileName = "Axiom-TimeSheet-$(Get-Date -Format 'yyyyMMdd').tsv"
        $filePath = Join-Path $desktopPath $fileName
        
        Set-Content -Path $filePath -Value $tsvContent -Encoding UTF8
        
        Show-AlertDialog -Title "Export Complete" -Message "Weekly summary has been exported to:`n$filePath"
    } catch {
        Write-Log -Level Error -Message "Failed to export timesheet: $_"
        Show-AlertDialog -Title "Export Error" -Message "Could not write the export file to the desktop.`nPlease check permissions."
    }
}
# --- END OF ORIGINAL FILE for screens/timesheet-screen.psm1 ---
```

**Rationale:** This demonstrates the complete pattern. The `TimeSheetScreen` is "dumb"—it just hosts a `Table` component. In its `OnEnter` method, it calls the `TimeSheetService` to get data and hands that data to the table. The `Export-WeeklyTimeSheet` action also uses the service, gets back raw TSV data as a string, and is responsible for the UI-related task of writing it to a file and showing a confirmation dialog. The service remains pure and unaware of the filesystem or dialogs. The screen now also correctly refreshes on data changes.

#### **Step 4.3: Final Integration in the Startup Logic**

**Action:** We must initialize our new services and register our new screens and routes in the main application startup block. This makes them "live" in the application. We also correctly update the `Start-TuiLoop` call.

**Instruction:** **MODIFY** the final `try/catch` block at the end of `axiom.txt` to include all new services and screens from Pillars 2, 3, and 4.

```powershell
# In axiom.txt, near the end of the file

try {
    Write-Host "`n=== PMC Terminal v5 - Phoenix Edition ===" -ForegroundColor Cyan
    
    # 1. Initialize core services
    Write-Host "`nInitializing core services..." -ForegroundColor Yellow
    Initialize-Logger -Level $(if ($Debug) { "Debug" } else { "Info" })
    Initialize-EventSystem
    
    # NEW: Create the themes directory if it doesn't exist. This ensures the app
    # can run out-of-the-box without manual folder creation.
    $themesDir = Join-Path $PSScriptRoot "themes"
    if (-not (Test-Path $themesDir)) { 
        Write-Log -Level Info -Message "Themes directory not found, creating at: $themesDir"
        New-Item -Path $themesDir -ItemType Directory | Out-Null 
        # In a real distribution, you would also create a default.theme.json file here.
    }
    $AxiomThemeEngineInstance = Initialize-ThemeEngine -themesDirectory $themesDir
    
    Initialize-DialogSystem
    
    # 2. Create the service container and add initial services
    $services = @{
        ThemeEngine = $AxiomThemeEngineInstance # Now stored in a local variable, then assigned.
    }
    
    # 3. Initialize services that depend on others and add them to the container
    $services.DataManager = Initialize-DataManager
    # NEW: Initialize the new services and add them to the container.
    $services.TimeSheetService = Initialize-TimeSheetService -DataManager $services.DataManager
    $services.ActionService = Initialize-ActionService # This discovers actions automatically on creation.
    $services.KeybindingService = New-KeybindingService
    
    # 4. NavigationService needs the full $services container
    $services.Navigation = Initialize-NavigationService -Services $services
    
    # Assign the fully constructed services container to a global variable for easy access
    $global:AxiomServices = $services # This line is critical and should remain.
    
    # 5. Register ALL screen classes with the navigation factory
    $nav = $services.Navigation
    $nav.RegisterScreenClass("DashboardScreen", [DashboardScreen])
    $nav.RegisterScreenClass("TaskFlowScreen", [TaskFlowScreen])   # NEW from Pillar 3
    $nav.RegisterScreenClass("ExplorerScreen", [ExplorerScreen])   # NEW from Pillar 2
    $nav.RegisterScreenClass("TimeSheetScreen", [TimeSheetScreen]) # NEW from Pillar 4
    
    Write-Host "All services initialized!" -ForegroundColor Green
    
    # Optional: Display a splash screen or logo
    # if (-not $SkipLogo) {
    #    Write-Host @"
    #    _   _                      _     
    #   /_\ | |__  _ __ __ _  ___| | __ 
    #  //_\\| '_ \| '__/ _` |/ __| |/ / 
    # /  _  \ |_) | | | (_| | (__|   <  
    # \_/ \_/_.__/|_|  \__,_|\___|_|\_\ 
    # "@ -ForegroundColor DarkCyan
    # }
    
    # 6. Initialize TUI Engine
    Initialize-TuiEngine # This no longer takes Width/Height, it uses console defaults.
    
    # 7. Add routes for all the new screens
    $nav.RouteMap["/"] = "DashboardScreen" # Default route
    $nav.RouteMap["/dashboard"] = "DashboardScreen"
    $nav.RouteMap["/tasks"] = "TaskFlowScreen" 
    $nav.RouteMap["/explorer"] = "ExplorerScreen"
    $nav.RouteMap["/timesheet"] = "TimeSheetScreen"
    
    # 8. Start the application by navigating to the root path and starting the main loop.
    Write-Host "Starting main application loop..." -ForegroundColor Yellow
    # First, GoTo the initial screen using the navigation service.
    $services.Navigation.GoTo("/") 
    # Then, start the TUI loop. Note: Start-TuiLoop no longer takes an InitialScreen parameter.
    Start-TuiLoop
    
} catch {
    Write-Host "`n[FATAL ERROR] Project Acta encountered a critical error during startup:" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "StackTrace:" -ForegroundColor DarkRed
    Write-Host "$($_.ScriptStackTrace)" -ForegroundColor DarkRed
    Write-Host "`nPress any key to exit." -ForegroundColor Red
    [void][Console]::ReadKey($true)
} finally {
    # Ensure the console is reset and cursor is visible on exit
    Write-Host "`e[0m`e[?25h" # Reset SGR and show cursor
    Write-Host "`nProject Acta application terminated." -ForegroundColor DarkGray
}
```

---

The corrected guide `axiom - acta guide v2.txt` is now complete. I will now proceed to apply these instructions to the `axiom.txt` file you provided. This process will produce the `Axiom-Phoenix.ps1` monolithic script.
```powershell
--- START OF FILE axiom.txt ---

# ==================================================================================
# PMC Terminal v5 - MONOLITHIC SCRIPT (Generated by Create-Monolith.ps1)
# DO NOT EDIT THIS FILE DIRECTLY.
# ==================================================================================
#Requires -Version 7.0
using namespace System.Text
using namespace System.Management.Automation
using namespace System
param(
    [switch]$Debug,
    [switch]$SkipLogo
)
# HARDENING: Check if the type already exists before attempting to add it.
# This prevents terminating errors when re-running the script during development.
# Define the ActionAttribute class using native PowerShell syntax.
# This is a parse-time construct, making the attribute available to the parser
# immediately as it reads the script file, resolving the ParserError.


# Global script settings
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"


# --- START OF ORIGINAL FILE: modules\logger\logger.psm1 ---
# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------
$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------
function ConvertTo-SerializableObject {
    param([object]$Object)
    if ($null -eq $Object) { return $null }
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'
    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)
        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) { [void]$visited.Add($InputObject) }
        switch ($InputObject.GetType().Name) {
            'Hashtable' { $r = @{}; foreach ($k in $InputObject.Keys) { try { $r[$k] = Convert-Internal $InputObject[$k] ($Depth+1) } catch { $r[$k] = "<Err>" } }; return $r }
            'PSCustomObject' { $r = @{}; foreach ($p in $InputObject.PSObject.Properties) { try { if ($p.MemberType -ne 'ScriptMethod') { $r[$p.Name] = Convert-Internal $p.Value ($Depth+1) } } catch { $r[$p.Name] = "<Err>" } }; return $r }
            'Object[]' { $r = @(); for ($i=0; $i -lt [Math]::Min($InputObject.Count,10); $i++) { try { $r += Convert-Internal $InputObject[$i] ($Depth+1) } catch { $r += "<Err>" } }; if($InputObject.Count -gt 10) { $r += "<...>" }; return $r }
            default { try { if ($InputObject -is [ValueType] -or $InputObject -is [string] -or $InputObject -is [datetime]) { return $InputObject } else { return $InputObject.ToString() } } catch { return "<Err>" } }
        }
    }
    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------
function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Debug"
    )
    if ([string]::IsNullOrWhiteSpace($LogDirectory) -or [string]::IsNullOrWhiteSpace($LogFileName)) { Write-Warning "Invalid logger parameters."; return }
    try {
        if (-not (Test-Path $LogDirectory)) { New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null }
        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true
        Write-Log -Level Info -Message "Logger initialized" -Data @{ LogPath = $script:LogPath; PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS; PID = $PID } -Force
    } catch { Write-Warning "Failed to initialize logger: $_"; $script:LogInitialized = $false }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")] [string]$Level = "Info",
        [Parameter(Mandatory)] [string]$Message,
        [object]$Data,
        [switch]$Force
    )
    if (-not $script:LogInitialized -and -not $Force) { return }
    $levelPriority = @{ Debug=0; Trace=0; Verbose=1; Info=2; Warning=3; Error=4; Fatal=5 }
    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }
    try {
        $caller = (Get-PSCallStack)[1]
        $logContext = @{
            Timestamp = (Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"); Level = $Level; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
            CallDepth = $script:CallDepth; Message = $Message; Caller = @{ Command = $caller.Command; Location = $caller.Location; ScriptName = $caller.ScriptName; LineNumber = $caller.ScriptLineNumber }
        }
        if ($PSBoundParameters.ContainsKey('Data')) { $logContext.UserData = if ($Data -is [Exception]) { @{ Type="Exception"; Message=$Data.Message; StackTrace=$Data.StackTrace; InnerException=$Data.InnerException.Message } } else { ConvertTo-SerializableObject -Object $Data } }
        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) { "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)" } else { $caller.Command }
        $logEntry = "$($logContext.Timestamp) [$($Level.PadRight(7))] $indent [$callerInfo] $Message"
        if ($PSBoundParameters.ContainsKey('Data')) { $logEntry += if ($Data -is [Exception]) { "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)" } else { try { "`n${indent}  Data: $(ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue)" } catch { "`n${indent}  Data: $($Data.ToString())" } } }
        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) { $script:LogQueue.RemoveRange(0, 1000) }
        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) { Move-Item $script:LogPath ($script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log") -Force }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch { Write-Host "LOG WRITE FAILED: $logEntry`nError: $_" -ForegroundColor Yellow }
        }
        if ($Level -in @('Error', 'Fatal', 'Warning')) { Write-Host $logEntry -ForegroundColor ($Level -in @('Error', 'Fatal') ? 'Red' : 'Yellow') }
    } catch { try { $errorEntry = "$(Get-Date -Format 'o') [LOGGER ERROR] Failed to log: $_"; if ($script:LogPath) { Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8 }; Write-Host $errorEntry -ForegroundColor Red } catch { Write-Host "CRITICAL: Logger failed: $_" -ForegroundColor Red } }
}

function Trace-FunctionEntry { [CmdletBinding()] param([string]$FunctionName, [object]$Parameters); if (-not $script:TraceAllCalls) { return }; $script:CallDepth++; Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{ Parameters=$Parameters; Action="FunctionEntry" } }
function Trace-FunctionExit { [CmdletBinding()] param([string]$FunctionName, [object]$ReturnValue, [switch]$WithError); if (-not $script:TraceAllCalls) { return }; Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{ ReturnValue=$ReturnValue; Action=($WithError ? "FunctionExitWithError" : "FunctionExit"); HasError=$WithError.IsPresent }; $script:CallDepth = [Math]::Max(0, $script:CallDepth - 1) }
function Trace-Step { [CmdletBinding()] param([string]$StepName, [object]$StepData, [string]$Module); $caller = (Get-PSCallStack)[1]; $moduleInfo = $Module ?? ($caller.ScriptName ? [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) : "Unknown"); Write-Log -Level Debug -Message "STEP: $StepName" -Data @{ StepData=$StepData; Module=$moduleInfo; Action="Step" } }
function Trace-StateChange { [CmdletBinding()] param([string]$StateType, [object]$OldValue, [object]$NewValue, [string]$PropertyPath); Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{ StateType=$StateType; PropertyPath=$PropertyPath; OldValue=$OldValue; NewValue=$NewValue; Action="StateChange" } }
function Trace-ComponentLifecycle { [CmdletBinding()] param([string]$ComponentType, [string]$ComponentId, [ValidateSet('Create','Initialize','Render','Update','Destroy')] [string]$Phase, [object]$ComponentData); Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{ ComponentType=$ComponentType; ComponentId=$ComponentId; Phase=$Phase; ComponentData=$ComponentData; Action="ComponentLifecycle" } }
function Trace-ServiceCall { [CmdletBinding()] param([string]$ServiceName, [string]$MethodName, [object]$Parameters, [object]$Result, [switch]$IsError); Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{ ServiceName=$ServiceName; MethodName=$MethodName; Parameters=$Parameters; Result=$Result; Action=($IsError ? "ServiceCallError" : "ServiceCall"); IsError=$IsError.IsPresent } }

function Get-LogEntries {
    [CmdletBinding()]
    param([int]$Count = 100, [string]$Level, [string]$Module, [string]$Action)
    try {
        $entries = $script:LogQueue.ToArray()
        if ($Level) { $entries = $entries | Where-Object { $_.Level -eq $Level } }
        if ($Module) { $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") } }
        if ($Action) { $entries = $entries | Where-Object { $_.UserData.Action -eq $Action } }
        return $entries | Select-Object -Last $Count
    } catch { Write-Warning "Error getting log entries: $_"; return @() }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)
    try {
        $callStack = Get-PSCallStack; $trace = @()
        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { $call = $callStack[$i]; $trace += @{ Level=$i-1; Command=$call.Command; Location=$call.Location; ScriptName=$call.ScriptName; LineNumber=$call.ScriptLineNumber } }
        return $trace
    } catch { Write-Warning "Error getting call trace: $_"; return @() }
}

function Clear-LogQueue { try { $script:LogQueue.Clear(); Write-Log -Level Info -Message "In-memory log queue cleared" } catch { Write-Warning "Error clearing log queue: $_" } }
function Set-LogLevel { [CmdletBinding()] param([Parameter(Mandatory)] [ValidateSet("Debug","Verbose","Info","Warning","Error","Fatal","Trace")] [string]$Level); try { $oldLevel = $script:LogLevel; $script:LogLevel = $Level; Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force } catch { Write-Warning "Error setting log level to '$Level': $_" } }
function Enable-CallTracing { $script:TraceAllCalls = $true; Write-Log -Level Info -Message "Call tracing enabled" -Force }
function Disable-CallTracing { $script:TraceAllCalls = $false; Write-Log -Level Info -Message "Call tracing disabled" -Force }
function Get-LogPath { return $script:LogPath }

function Get-LogStatistics {
    [CmdletBinding()]
    param()
    try {
        $stats = [PSCustomObject]@{ TotalEntries=$script:LogQueue.Count; LogPath=$script:LogPath; LogLevel=$script:LogLevel; CallTracingEnabled=$script:TraceAllCalls; LogFileSize=($script:LogPath -and (Test-Path $script:LogPath) ? (Get-Item $script:LogPath).Length : 0); EntriesByLevel=@{}; EntriesByModule=@{}; EntriesByAction=@{} }
        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level; if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level]=0 }; $stats.EntriesByLevel[$level]++
            if ($entry.Caller.ScriptName) { $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName); if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module]=0 }; $stats.EntriesByModule[$module]++ }
            if ($entry.UserData.Action) { $action = $entry.UserData.Action; if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action]=0 }; $stats.EntriesByAction[$action]++ }
        }
        return $stats
    } catch { Write-Warning "Error getting log statistics: $_"; return [PSCustomObject]@{} }
}
# --- END OF ORIGINAL FILE: modules\logger\logger.psm1 ---


# --- START OF ORIGINAL FILE: modules\exceptions\exceptions.psm1 ---
# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

try {
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException) {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
    }
} catch {
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}

# ----------------