here is a comprehensive developer's guide. This document explains the core principles, provides step-by-step instructions for common tasks like creating new components and screens, and outlines best practices to maintain architectural integrity.

---

### **PMC Terminal v5: Developer's Guide**

This guide outlines the development philosophy and practices for the refactored PMC Terminal framework. Following these principles will ensure that new features and fixes are robust, maintainable, and integrate seamlessly with the existing architecture.

### **Core Architectural Principles: The "Why"**

1.  **The Component is King:** Everything visible on screen is a `UIElement` or inherits from it. This is the single, unifying principle of the framework.
2.  **Encapsulation and Self-Containment:** A component should only know how to render *itself* into its *own* private buffer. It should never draw outside its bounds or directly manipulate a parent's buffer.
3.  **Composition over Complexity:** Complex UIs are built by composing simple components. A `Screen` contains `Panel`s, and `Panel`s contain `Button`s, `Table`s, and other components. The framework handles combining them automatically.
4.  **Decoupled Communication via Events:** Services and components should not hold direct references to each other whenever possible. Use the `event-system` for communication.
    *   **Bad:** A button has a `$parentScreen.UpdateData()` method.
    *   **Good:** A button's `OnClick` handler calls `Publish-Event -EventName "Data.NeedsUpdate"`. The screen subscribes to this event and updates itself.
5.  **Services are "Headless":** Service modules (`data-manager`, `navigation-service`, etc.) manage state and logic. They **never** contain rendering code or directly interact with `[Console]`.

---

### **How-To Guides: The "How"**

#### **How to Create a New UI Component (e.g., a "Spinner")**

**Goal:** Create a simple `SpinnerComponent` that shows a spinning character (`|`, `/`, `-`, `\`).

1.  **Choose the Right File:** Open `components\tui-components.psm1` (for simple components) or create a new module if it's highly specialized.

2.  **Define the Class:** Start by inheriting from `UIElement`.

    ```powershell
    class SpinnerComponent : UIElement {
        # --- State Properties ---
        [int] $SpinnerIndex = 0
        [string[]] $SpinnerChars = @('|', '/', '-', '\')
        
        # --- Constructor ---
        SpinnerComponent([string]$name) : base($name) {
            $this.IsFocusable = $false # Not interactive
            $this.Width = 1
            $this.Height = 1
        }
        
        # --- Public Methods ---
        [void] Tick() {
            $this.SpinnerIndex = ($this.SpinnerIndex + 1) % $this.SpinnerChars.Count
            $this.RequestRedraw() # CRITICAL: Request a redraw after changing state
        }

        # --- Rendering Logic ---
        [void] OnRender() {
            # This is the only place this component draws.
            # It only draws into its own buffer.
            if ($null -eq $this._private_buffer) { return }

            $charToDraw = $this.SpinnerChars[$this.SpinnerIndex]

            # Write the current spinner character to our private buffer at (0, 0)
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $charToDraw -ForegroundColor 'Cyan'
        }
    }
    ```

3.  **Create a Factory Function (Optional but Recommended):** Add a function to create instances easily.

    ```powershell
    function New-TuiSpinner {
        param([hashtable]$Props = @{})
        $name = $Props.Name ?? "Spinner_$(Get-Random)"
        $spinner = [SpinnerComponent]::new($name)
        # Set common properties like X, Y, Visible from $Props
        $spinner.X = $Props.X ?? 0
        $spinner.Y = $Props.Y ?? 1
        return $spinner
    }
    ```

4.  **Export the Factory:** Add `New-TuiSpinner` to the `Export-ModuleMember` list at the end of the file.

5.  **Use it in a Screen:**
    *   `using module '..\..\components\tui-components.psm1'`
    *   In the screen's `Initialize` method:
        ```powershell
        $this.mySpinner = New-TuiSpinner -Props @{ X = 5; Y = 10 }
        $this.MainPanel.AddChild($this.mySpinner) # Add it to a container
        ```

#### **How to Create a New Screen (e.g., a "Help Screen")**

1.  **Create the File:** Create `screens\help\help-screen.psm1`.

2.  **Define the Class:** All screens inherit from `UIElement`. They are just top-level containers.

    ```powershell
    using module '..\..\components\ui-classes.psm1'
    using module '..\..\layout\panels-class.psm1'
    # ... other components you need ...
    
    class HelpScreen : UIElement {
        # --- Core Properties ---
        [hashtable] $Services
        [Panel] $MainPanel
        # ... other child elements ...

        # --- Constructor ---
        HelpScreen([hashtable]$services) : base(0, 0, $global:TuiState.BufferWidth, $global:TuiState.BufferHeight) {
            $this.Name = "HelpScreen"
            $this.Services = $services
            
            # Defer heavy lifting to Initialize()
        }

        # --- Initialization ---
        [void] Initialize() {
            # This is where you build the UI tree for this screen.
            $this.MainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "Help")
            $this.AddChild($this.MainPanel) # Add main panel as the root child

            $textPanel = [Panel]::new(1, 1, $this.Width - 2, $this.Height - 2, "Keybindings")
            $this.MainPanel.AddChild($textPanel)

            # You can write directly to panels, but it's better to use LabelComponents for structured text.
            $helpText = "Ctrl+Q - Quit`nEsc - Back`n..."
            $label = New-TuiLabel -Props @{ X=1; Y=1; Text=$helpText }
            $textPanel.AddChild($label)
        }

        # --- Input Handling ---
        [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
            # Handle screen-specific global keys. Component-specific input
            # is handled by the component itself (if it has focus).
            if ($keyInfo.Key -eq [ConsoleKey]::Escape) {
                $this.Services.Navigation.PopScreen()
                return $true
            }
            return $false
        }
    }
    ```

3.  **Register the Screen with the Navigation Service:**
    *   Open `_CLASSY-MAIN.ps1`.
    *   Add the `using module` statement: `using module '.\screens\help\help-screen.psm1'`
    *   Find the `Register Screen Classes` section and add:
        ```powershell
        $services.Navigation.RegisterScreenClass("HelpScreen", [HelpScreen])
        ```
    *   Add a route in `services\navigation-service-class.psm1`:
        ```powershell
        # In InitializeRoutes()
        $this.RouteMap["/help"] = "HelpScreen"
        ```

#### **How to Handle a Button Click**

1.  **Define the Action:** When creating the button, provide a script block for the `OnClick` property.

    ```powershell
    # In a screen's Initialize method
    $myButton = New-TuiButton -Props @{
        Text = "Refresh Data"
        OnClick = {
            # This code runs when the button is "clicked" (Enter/Space)
            Write-Log -Level Info -Message "Refresh button clicked!"
            Publish-Event -EventName "Dashboard.Refresh" 
        }
    }
    ```

2.  **Listen for the Event:** In the same screen class, subscribe to the event.

    ```powershell
    # In the constructor or Initialize method
    $this.SubscribeToEvent("Dashboard.Refresh", {
        # This code runs when the event is published
        $this.RefreshData()
        $this.UpdateDisplay()
    })
    
    # In OnExit() or Cleanup(), the subscriptions will be automatically cleaned up.
    ```
    *Why the event? This decouples the button from the screen. The button doesn't need to know *how* to refresh the screen, only that it needs to announce its intention.*

---

### **Guidelines and Best Practices**

#### **Rendering**

*   **DON'T** use `Write-Host`, `[Console]::Write`, or any direct console output inside a component or screen. The TUI engine handles all final rendering.
*   **DO** call `$this.RequestRedraw()` any time a component's state changes in a way that affects its appearance. This flags it and its parents as "dirty" for the next render frame.
*   **DON'T** try to calculate a component's absolute screen position for rendering. Always render to its own buffer at relative coordinates (usually `X=0, Y=0`). The parent `Panel` and the `UIElement` compositor will handle placing it correctly.
*   **DO** use the primitive drawing functions (`Write-TuiText`, `Write-TuiBox`) inside an `OnRender` method. They correctly draw to a `TuiBuffer`.

#### **State Management**

*   **DO** keep UI state (e.g., `$SelectedIndex`, `$IsCollapsed`) inside the component itself.
*   **DON'T** store shared application state (e.g., the list of all tasks, the current user) inside a UI component.
*   **DO** retrieve application state from services like `$this.Services.DataManager`.
*   **DO** use `$PSBoundParameters.ContainsKey('ParameterName')` inside functions to check if an optional parameter was actually provided. This is crucial for functions like `Update-PmcTask`.

#### **Fixes and Edits**

*   **Is it a visual bug?** The problem is likely in an `OnRender()` method. Is it drawing the wrong thing, or drawing outside its buffer?
*   **Is it an input bug?** Check the `HandleInput()` method of the focused component first, then the screen. Is it consuming the key and returning `$true`?
*   **Is data not saving/updating?** The issue is likely in `data-manager.psm1` or the code calling its functions. Check that you are passing the correct objects and that `Save-UnifiedData` is being called. Use the logger (`Write-Log -Data $myObject`) to inspect objects at different stages.
*   **Is the app crashing?** The `Invoke-WithErrorHandling` wrapper will log detailed information. Check the log file specified when `Initialize-Logger` is called. It will contain the component name, context, and a stack trace.
*   **Having trouble with a component?** Create a new, temporary screen that *only* contains that one component. This isolates it from other factors and makes debugging much simpler.