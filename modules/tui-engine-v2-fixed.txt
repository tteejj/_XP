# TUI Engine v5.0 - PowerShell 7+ Edition
# Implements a modern, reliable TUI rendering and input loop.

#region Core TUI State
$global:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine: ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $global:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }
        # AI: Global state is now directly available
        Write-Log -Level Info -Message "TUI Engine initialized successfully"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $global:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $global:TuiState.InputRunspace = $runspace
    $global:TuiState.InputPowerShell = $ps
    $global:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent) {
        try { 
            # AI: Fix for class-based components - check type and call appropriately
            if ($focusedComponent.PSObject.TypeNames -contains 'UIElement' -or $focusedComponent.GetType().IsSubclassOf([UIElement])) {
                # Class-based component
                if ($focusedComponent.PSObject.Methods.Name -contains 'HandleInput') {
                    $focusedComponent.HandleInput($keyInfo)
                }
            }
            elseif ($focusedComponent.HandleInput) {
                # Functional component with HandleInput scriptblock
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return }
            }
        } catch { 
            Write-Warning "Component input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for component '$($focusedComponent.Name)': $_"
        }
    }
    
    $currentScreen = $global:TuiState.CurrentScreen
    if ($currentScreen) {
        try {
            # AI: Fix for class-based screens - check if it's a class instance vs hashtable
            if ($currentScreen -is [Screen]) {
                # Class-based screen - call method directly
                $currentScreen.HandleInput($keyInfo)
            }
            elseif ($currentScreen.HandleInput) {
                # Hashtable/functional screen - use scriptblock invocation
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { Stop-TuiEngine }
                }
            }
        } catch { 
            Write-Warning "Screen input handler error: $_"
            Write-Log -Level Error -Message "HandleInput failed for screen '$($currentScreen.Name)': $_"
        }
    }
}

function Start-TuiLoop {
    param([hashtable]$InitialScreen)
    try {
        if (-not $global:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $global:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $global:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS
        
        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($global:TuiState.IsDirty -or $hadInput) { Render-Frame; $global:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $global:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $global:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

function Render-Frame {
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        # AI: CRITICAL FIX - New unified render approach for class-based screens
        if ($global:TuiState.CurrentScreen) {
            # Check if this is a class-based screen (has Panels property)
            if ($global:TuiState.CurrentScreen.PSObject.Properties.Name -contains 'Panels' -and 
                $global:TuiState.CurrentScreen -is [Screen]) {
                # Class-based screen - render directly using its Render method
                $screenOutput = $global:TuiState.CurrentScreen.Render()
                if (-not [string]::IsNullOrEmpty($screenOutput)) {
                    [Console]::Write($screenOutput)
                }
            }
            else {
                # Legacy functional screen - use the old component collection approach
                $renderQueue = [System.Collections.Generic.List[object]]::new()
                $collectComponents = {
                    param($component)
                    if (-not $component -or $component.Visible -eq $false) { return }
                    $renderQueue.Add($component)
                    if ($component.PSObject.Properties.Name -contains 'Children' -and $component.Children.Count -gt 0) {
                        if ($component.PSObject.Properties.Name -contains 'CalculateLayout') {
                            try { & $component.CalculateLayout -self $component } catch { Write-Log -Level Error -Message "Layout failed for '$($component.Name)'" }
                        }
                        foreach ($child in $component.Children) { & $script:collectComponents $child }
                    }
                }
                
                # Try to collect components from legacy structure
                if ($global:TuiState.CurrentScreen.Components) {
                    foreach ($c in $global:TuiState.CurrentScreen.Components.Values) {
                        & $collectComponents -component $c
                    }
                }
                
                # Sort and render legacy components
                $sortedQueue = $renderQueue | Sort-Object { $_.ZIndex ?? 0 }
                foreach ($component in $sortedQueue) {
                    if (-not ($component.PSObject.Properties.Name -contains 'Render')) { continue }
                    Invoke-WithErrorHandling -Component ($component.Name ?? $component.Type) -Context "Functional Render" -ScriptBlock { 
                        & $component.Render -self $component 
                    }
                }
            }
        }
        
        # Handle dialogs if present
        if ($dialog = Get-CurrentDialog) {
            # Render dialog on top
            if ($dialog -is [UIElement]) {
                $dialogOutput = $dialog.Render()
                if (-not [string]::IsNullOrEmpty($dialogOutput)) {
                    [Console]::Write($dialogOutput)
                }
            }
        }
        
        # AI: For buffer-based rendering (if used by legacy components)
        Render-BufferOptimized
        
        # Position cursor at bottom-right
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)
    } catch { 
        Write-Warning "Fatal Frame render error: $_"
        Write-Log -Level Error -Message "Render-Frame failed: $_"
    }
}

function Request-TuiRefresh { $global:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult)
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $global:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    # AI: Modified to accept both [Screen] objects and [hashtable] for compatibility
    param([object]$Screen)
    if (-not $Screen) { return }
    
    $screenName = if ($Screen -is [Screen]) { $Screen.Name } else { $Screen.Name }
    Write-Log -Level Debug -Message "Pushing screen: $screenName"
    
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($global:TuiState.CurrentScreen) {
            # AI: Fix for class-based screens - handle OnExit method
            if ($global:TuiState.CurrentScreen -is [Screen]) {
                $global:TuiState.CurrentScreen.OnExit()
            }
            elseif ($global:TuiState.CurrentScreen.OnExit) {
                $global:TuiState.CurrentScreen.OnExit.Invoke()
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # AI: Fix for class-based vs functional screens initialization
        if ($Screen -is [Screen]) {
            # Class-based screen - already initialized by factory
            $Screen.OnEnter()
        }
        elseif ($Screen.Init) { 
            # Functional screen
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $screenName }
    } catch { 
        Write-Warning "Push screen error: $_"
        Write-Log -Level Error -Message "Failed to push screen '$screenName': $_"
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $global:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $global:TuiState.CurrentScreen
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $global:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $global:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:Tu