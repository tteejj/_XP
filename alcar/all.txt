####\Base/Component.ps1
# Component - Enhanced base class for UI components
# Minimal overhead while providing better architecture

class Component {
    [string]$Name
    [int]$X = 0
    [int]$Y = 0
    [int]$Width = 10
    [int]$Height = 1
    [bool]$Visible = $true
    [bool]$IsFocusable = $false
    [bool]$IsFocused = $false
    
    # Performance optimization flags
    hidden [bool]$_needsRedraw = $true
    hidden [hashtable]$_renderCache = @{}
    hidden [int]$_lastWidth = -1
    hidden [int]$_lastHeight = -1
    
    # Component lifecycle hooks
    [scriptblock]$OnMount = $null
    [scriptblock]$OnUnmount = $null
    [scriptblock]$OnFocus = $null
    [scriptblock]$OnBlur = $null
    
    Component([string]$name) {
        $this.Name = $name
    }
    
    # Check if component needs redrawing
    [bool] NeedsRedraw() {
        return $this._needsRedraw -or 
               $this._lastWidth -ne $this.Width -or 
               $this._lastHeight -ne $this.Height
    }
    
    # Mark component for redraw
    [void] Invalidate() {
        $this._needsRedraw = $true
        $this._renderCache.Clear()
    }
    
    # Base render method to be overridden
    [void] Render([object]$buffer) {
        if (-not $this.Visible) { return }
        
        # Update size tracking
        $this._lastWidth = $this.Width
        $this._lastHeight = $this.Height
        
        # Call derived class render
        $this.OnRender($buffer)
        
        # Mark as rendered
        $this._needsRedraw = $false
    }
    
    # Override in derived classes
    [void] OnRender([object]$buffer) {
        # Base implementation does nothing
    }
    
    # Lifecycle methods
    [void] Mount() {
        if ($this.OnMount) {
            & $this.OnMount $this
        }
    }
    
    [void] Unmount() {
        if ($this.OnUnmount) {
            & $this.OnUnmount $this
        }
    }
    
    [void] Focus() {
        if ($this.IsFocusable) {
            $this.IsFocused = $true
            $this.Invalidate()
            if ($this.OnFocus) {
                & $this.OnFocus $this
            }
        }
    }
    
    [void] Blur() {
        if ($this.IsFocused) {
            $this.IsFocused = $false
            $this.Invalidate()
            if ($this.OnBlur) {
                & $this.OnBlur $this
            }
        }
    }
    
    # Input handling - override in derived classes
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
    
    # Helper method for bounds checking
    [bool] IsInBounds([int]$x, [int]$y) {
        return $x -ge $this.X -and 
               $x -lt ($this.X + $this.Width) -and
               $y -ge $this.Y -and 
               $y -lt ($this.Y + $this.Height)
    }
}

# Container component for managing child components
class Container : Component {
    hidden [System.Collections.ArrayList]$Children = [System.Collections.ArrayList]::new()
    hidden [int]$FocusedChildIndex = -1
    
    Container([string]$name) : base($name) {
    }
    
    [void] AddChild([Component]$child) {
        $this.Children.Add($child) | Out-Null
        $child.Mount()
        $this.Invalidate()
    }
    
    [void] RemoveChild([Component]$child) {
        $child.Unmount()
        $this.Children.Remove($child)
        $this.Invalidate()
    }
    
    [void] OnRender([object]$buffer) {
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.NeedsRedraw()) {
                # Create sub-buffer for child
                $childBuffer = [Buffer]::new($child.Width, $child.Height)
                $child.Render($childBuffer)
                
                # Copy child buffer to parent buffer at child position
                for ($y = 0; $y -lt $child.Height; $y++) {
                    for ($x = 0; $x -lt $child.Width; $x++) {
                        $cell = $childBuffer.GetCell($x, $y)
                        if ($cell) {
                            $buffer.SetCell($this.X + $child.X + $x, $this.Y + $child.Y + $y, $cell)
                        }
                    }
                }
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused child
        if ($this.FocusedChildIndex -ge 0 -and $this.FocusedChildIndex -lt $this.Children.Count) {
            $focusedChild = $this.Children[$this.FocusedChildIndex]
            if ($focusedChild.HandleInput($key)) {
                return $true
            }
        }
        
        # Handle tab navigation between focusable children
        if ($key.Key -eq [ConsoleKey]::Tab) {
            return $this.FocusNextChild($key.Modifiers -band [ConsoleModifiers]::Shift)
        }
        
        return $false
    }
    
    [bool] FocusNextChild([bool]$reverse = $false) {
        $focusableChildren = @()
        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            if ($this.Children[$i].IsFocusable) {
                $focusableChildren += $i
            }
        }
        
        if ($focusableChildren.Count -eq 0) { return $false }
        
        # Blur current child
        if ($this.FocusedChildIndex -ge 0) {
            $this.Children[$this.FocusedChildIndex].Blur()
        }
        
        # Find next focusable child
        $currentIndex = [Array]::IndexOf($focusableChildren, $this.FocusedChildIndex)
        if ($reverse) {
            $currentIndex--
            if ($currentIndex -lt 0) { $currentIndex = $focusableChildren.Count - 1 }
        } else {
            $currentIndex++
            if ($currentIndex -ge $focusableChildren.Count) { $currentIndex = 0 }
        }
        
        $this.FocusedChildIndex = $focusableChildren[$currentIndex]
        $this.Children[$this.FocusedChildIndex].Focus()
        
        return $true
    }
}


####\Base/Dialog.ps1
# Dialog Base Class - Modal dialog system for alcar

enum DialogResult {
    None
    OK
    Cancel
    Yes
    No
    Retry
    Abort
}

class Dialog : Screen {
    [string]$Message = ""
    [DialogResult]$Result = [DialogResult]::None
    [int]$DialogWidth = 50
    [int]$DialogHeight = 10
    [bool]$CenterOnScreen = $true
    [bool]$Modal = $true
    [bool]$ShowShadow = $true
    
    # Visual properties
    [string]$DialogBorderStyle = "Double"  # Single, Double, Rounded
    [string]$DialogBackgroundColor = ""
    [string]$DialogBorderColor = ""
    [string]$ShadowColor = ""
    
    # Position (if not centered)
    [int]$DialogX = 0
    [int]$DialogY = 0
    
    # Callbacks
    [scriptblock]$OnShown = $null
    [scriptblock]$OnClosed = $null
    
    Dialog() {
        $this.Title = "Dialog"
        $this.InitializeDialog()
    }
    
    Dialog([string]$title, [string]$message) {
        $this.Title = $title
        $this.Message = $message
        $this.InitializeDialog()
    }
    
    [void] InitializeDialog() {
        # Dialog-specific initialization
        $this.UpdateDialogPosition()
        
        # Common key bindings
        $this.BindKey([ConsoleKey]::Escape, { $this.Cancel() })
    }
    
    [void] UpdateDialogPosition() {
        if ($this.CenterOnScreen) {
            $screenWidth = [Console]::WindowWidth
            $screenHeight = [Console]::WindowHeight
            $this.DialogX = [int](($screenWidth - $this.DialogWidth) / 2)
            $this.DialogY = [int](($screenHeight - $this.DialogHeight) / 2)
        }
    }
    
    [DialogResult] ShowDialog() {
        # Store current screen state if modal
        if ($this.Modal -and $global:ScreenManager) {
            $global:ScreenManager.Push($this)
        }
        
        # Fire OnShown event
        if ($this.OnShown) {
            & $this.OnShown $this
        }
        
        # Run dialog
        $this.Active = $true
        while ($this.Active) {
            $this.ProcessInput()
            $this.Render()
        }
        
        # Fire OnClosed event
        if ($this.OnClosed) {
            & $this.OnClosed $this $this.Result
        }
        
        return $this.Result
    }
    
    [void] OK() {
        $this.Result = [DialogResult]::OK
        $this.Close()
    }
    
    [void] Cancel() {
        $this.Result = [DialogResult]::Cancel
        $this.Close()
    }
    
    [void] Close() {
        $this.Active = $false
        
        # Pop from screen manager if modal
        if ($this.Modal -and $global:ScreenManager) {
            $global:ScreenManager.Pop()
        }
    }
    
    [string] RenderContent() {
        $output = ""
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        # Draw overlay background if modal
        if ($this.Modal) {
            $overlayColor = [VT]::RGBBG(20, 20, 20)
            for ($y = 1; $y -le $height; $y++) {
                $output += [VT]::MoveTo(1, $y)
                $output += $overlayColor + (" " * $width) + [VT]::Reset()
            }
        }
        
        # Draw shadow if enabled
        if ($this.ShowShadow) {
            $shadowColorValue = ""
            if ([string]::IsNullOrEmpty($this.ShadowColor)) {
                $shadowColorValue = [VT]::RGBBG(10, 10, 10)
            } else {
                $shadowColorValue = $this.ShadowColor
            }
            for ($y = 1; $y -le $this.DialogHeight; $y++) {
                $output += [VT]::MoveTo($this.DialogX + 2, $this.DialogY + $y)
                $output += $shadowColorValue + (" " * $this.DialogWidth) + [VT]::Reset()
            }
        }
        
        # Draw dialog background
        $bgColorValue = ""
        if ([string]::IsNullOrEmpty($this.DialogBackgroundColor)) {
            $bgColorValue = [VT]::RGBBG(30, 30, 40)
        } else {
            $bgColorValue = $this.DialogBackgroundColor
        }
        for ($y = 0; $y -lt $this.DialogHeight; $y++) {
            $output += [VT]::MoveTo($this.DialogX, $this.DialogY + $y)
            $output += $bgColorValue + (" " * $this.DialogWidth) + [VT]::Reset()
        }
        
        # Draw border
        $borderColorValue = ""
        if ([string]::IsNullOrEmpty($this.DialogBorderColor)) {
            $borderColorValue = [VT]::RGB(100, 100, 150)
        } else {
            $borderColorValue = $this.DialogBorderColor
        }
        $output += $this.DrawDialogBorder($borderColorValue)
        
        # Draw title
        if ($this.Title) {
            $titleText = " $($this.Title) "
            $titleX = $this.DialogX + [int](($this.DialogWidth - $titleText.Length) / 2)
            $output += [VT]::MoveTo($titleX, $this.DialogY)
            $output += $borderColorValue + [VT]::Bold() + $titleText + [VT]::Reset()
        }
        
        # Draw message
        if ($this.Message) {
            $messageLines = $this.WrapText($this.Message, $this.DialogWidth - 4)
            $startY = $this.DialogY + 2
            
            foreach ($line in $messageLines) {
                $lineX = $this.DialogX + 2
                $output += [VT]::MoveTo($lineX, $startY)
                $output += [VT]::RGB(220, 220, 220) + $line + [VT]::Reset()
                $startY++
            }
        }
        
        # Draw dialog-specific content (override in derived classes)
        $output += $this.RenderDialogContent()
        
        return $output
    }
    
    [string] RenderDialogContent() {
        # Override in derived classes to add buttons, inputs, etc.
        return ""
    }
    
    [string] DrawDialogBorder([string]$color) {
        $output = ""
        
        $chars = switch ($this.DialogBorderStyle) {
            "Double" { @{TL="╔"; TR="╗"; BL="╚"; BR="╝"; H="═"; V="║"} }
            "Rounded" { @{TL="╭"; TR="╮"; BL="╰"; BR="╯"; H="─"; V="│"} }
            default { @{TL="┌"; TR="┐"; BL="└"; BR="┘"; H="─"; V="│"} }
        }
        
        # Top border
        $output += [VT]::MoveTo($this.DialogX, $this.DialogY)
        $output += $color + $chars.TL + ($chars.H * ($this.DialogWidth - 2)) + $chars.TR
        
        # Sides
        for ($y = 1; $y -lt $this.DialogHeight - 1; $y++) {
            $output += [VT]::MoveTo($this.DialogX, $this.DialogY + $y)
            $output += $color + $chars.V
            $output += [VT]::MoveTo($this.DialogX + $this.DialogWidth - 1, $this.DialogY + $y)
            $output += $color + $chars.V
        }
        
        # Bottom border
        $output += [VT]::MoveTo($this.DialogX, $this.DialogY + $this.DialogHeight - 1)
        $output += $color + $chars.BL + ($chars.H * ($this.DialogWidth - 2)) + $chars.BR
        
        $output += [VT]::Reset()
        return $output
    }
    
    [string[]] WrapText([string]$text, [int]$width) {
        $lines = @()
        $words = $text -split ' '
        $currentLine = ""
        
        foreach ($word in $words) {
            if ($currentLine.Length + $word.Length + 1 -le $width) {
                if ($currentLine) {
                    $currentLine += " " + $word
                } else {
                    $currentLine = $word
                }
            } else {
                if ($currentLine) {
                    $lines += $currentLine
                }
                $currentLine = $word
            }
        }
        
        if ($currentLine) {
            $lines += $currentLine
        }
        
        return $lines
    }
    
    # Helper method to draw buttons
    [string] DrawButton([string]$text, [int]$x, [int]$y, [bool]$isSelected) {
        $output = ""
        
        if ($isSelected) {
            $bgColor = [VT]::RGBBG(60, 60, 100)
            $fgColor = [VT]::RGB(255, 255, 255)
            $borderColor = [VT]::RGB(100, 200, 255)
        } else {
            $bgColor = [VT]::RGBBG(40, 40, 50)
            $fgColor = [VT]::RGB(200, 200, 200)
            $borderColor = [VT]::RGB(80, 80, 100)
        }
        
        $buttonWidth = $text.Length + 4
        
        # Button background
        $output += [VT]::MoveTo($x, $y)
        $output += $bgColor + (" " * $buttonWidth) + [VT]::Reset()
        
        # Button border
        $output += [VT]::MoveTo($x, $y)
        $output += $borderColor + "[" + [VT]::Reset()
        $output += [VT]::MoveTo($x + $buttonWidth - 1, $y)
        $output += $borderColor + "]" + [VT]::Reset()
        
        # Button text
        $output += [VT]::MoveTo($x + 2, $y)
        $output += $fgColor + $text + [VT]::Reset()
        
        return $output
    }
}


####\Base/Screen.ps1
# Base Screen Class for BOLT-AXIOM

class Screen {
    [string]$Title = "SCREEN"
    [bool]$Active = $true
    [hashtable]$KeyBindings = @{}
    [System.Collections.ArrayList]$StatusBarItems
    [bool]$NeedsRender = $true
    [Buffer]$Buffer  # Screen's own buffer
    static [Buffer]$CurrentBuffer  # Current frame buffer
    static [Buffer]$PreviousBuffer  # Previous frame buffer
    
    Screen() {
        $this.StatusBarItems = [System.Collections.ArrayList]::new()
        $this.InitializeKeyBindings()
    }
    
    # Override in derived classes
    [void] Initialize() { }
    [void] InitializeKeyBindings() { }
    [void] OnActivate() { }
    [void] OnDeactivate() { }
    
    # Main render - override in derived classes
    [void] Render() {
        # Build entire screen in memory first
        $sb = [System.Text.StringBuilder]::new(16384)  # Larger pre-allocation
        
        # Hide cursor and position at home only (no clear to prevent flicker)
        # Screens must draw complete backgrounds to overwrite previous content
        [void]$sb.Append("`e[?25l`e[H")
        
        # Render content
        [void]$sb.Append($this.RenderContent())
        [void]$sb.Append($this.RenderStatusBar())
        
        # Single atomic write operation
        [Console]::Write($sb.ToString())
        
        # Mark as rendered
        $this.NeedsRender = $false
    }
    
    # Render content to buffer - override in derived classes
    [void] RenderToBuffer([Buffer]$buffer) {
        # Default implementation - derived classes should override
        $content = $this.RenderContent()
        $statusBar = $this.RenderStatusBar()
        
        # This is a simple fallback - better to override in derived classes
        $lines = $content -split "`n"
        $y = 0
        foreach ($line in $lines) {
            if ($y -lt $buffer.Height - 1) {
                $buffer.WriteString(0, $y, $line, '#FFFFFF', '#000000')
                $y++
            }
        }
        
        # Status bar at bottom
        if ($statusBar) {
            $statusLines = $statusBar -split "`n"
            $buffer.WriteString(0, $buffer.Height - 1, $statusLines[0], '#FFFFFF', '#000000')
        }
    }
    
    # Differential rendering
    [void] RenderDifferential([Buffer]$current, [Buffer]$previous) {
        $sb = [System.Text.StringBuilder]::new(8192)
        $lastFG = ""
        $lastBG = ""
        
        # Hide cursor first
        [void]$sb.Append("`e[?25l")
        
        for ($y = 0; $y -lt $current.Height; $y++) {
            for ($x = 0; $x -lt $current.Width; $x++) {
                $currentCell = $current.GetCell($x, $y)
                $previousCell = $previous.GetCell($x, $y)
                
                if (-not $currentCell.Equals($previousCell)) {
                    # Move cursor if needed
                    [void]$sb.Append("`e[$($y + 1);$($x + 1)H")
                    
                    # Set colors if changed
                    if ($currentCell.FG -ne $lastFG -or $currentCell.BG -ne $lastBG) {
                        # Convert hex to RGB
                        $fg = $currentCell.FG
                        $bg = $currentCell.BG
                        if ($fg -match '^#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$') {
                            $r = [Convert]::ToInt32($Matches[1], 16)
                            $g = [Convert]::ToInt32($Matches[2], 16)
                            $b = [Convert]::ToInt32($Matches[3], 16)
                            [void]$sb.Append("`e[38;2;$r;$g;${b}m")
                        }
                        if ($bg -match '^#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$') {
                            $r = [Convert]::ToInt32($Matches[1], 16)
                            $g = [Convert]::ToInt32($Matches[2], 16)
                            $b = [Convert]::ToInt32($Matches[3], 16)
                            [void]$sb.Append("`e[48;2;$r;$g;${b}m")
                        }
                        $lastFG = $currentCell.FG
                        $lastBG = $currentCell.BG
                    }
                    
                    # Write character
                    [void]$sb.Append($currentCell.Char)
                }
            }
        }
        
        # Reset and write
        if ($sb.Length -gt 0) {
            [void]$sb.Append("`e[0m")
            [Console]::Write($sb.ToString())
        }
    }
    
    # Request a render on next loop iteration
    [void] RequestRender() {
        $this.NeedsRender = $true
    }
    
    # Override to provide screen content
    [string] RenderContent() {
        return ""
    }
    
    # Standard status bar
    [string] RenderStatusBar() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        $statusText = ""
        foreach ($item in $this.StatusBarItems) {
            if ($item.Key) {
                $statusText += "[$($item.Key)]$($item.Label) "
            } else {
                $statusText += "$($item.Label) "
            }
        }
        
        $output = [VT]::MoveTo(3, $height - 1)
        $output += [VT]::TextDim() + $statusText + [VT]::Reset()
        
        return $output
    }
    
    # Standard input handling
    [void] HandleInput([ConsoleKeyInfo]$key) {
        # Check key bindings first
        $binding = $null
        
        # Try special keys
        if ($key.Key -ne [ConsoleKey]::None) {
            $binding = $this.KeyBindings[$key.Key.ToString()]
        }
        
        # Try character keys
        if (-not $binding -and $key.KeyChar) {
            $binding = $this.KeyBindings[[string]$key.KeyChar]
        }
        
        # Execute binding
        if ($binding) {
            if ($binding -is [scriptblock]) {
                & $binding
            } else {
                $this.ExecuteAction($binding)
            }
            # Note: Render requests should be made by the action handlers
            # only when they actually change something
        }
    }
    
    # Override to handle named actions
    [void] ExecuteAction([string]$action) { }
    
    # Helper to add key binding
    [void] BindKey([object]$key, [object]$action) {
        if ($key -is [ConsoleKey]) {
            $this.KeyBindings[$key.ToString()] = $action
        } else {
            $this.KeyBindings[[string]$key] = $action
        }
    }
    
    # Helper to add status bar item
    [void] AddStatusItem([string]$key, [string]$label) {
        $this.StatusBarItems.Add(@{Key=$key; Label=$label}) | Out-Null
    }
}

# Dialog base class
class Dialog : Screen {
    [Screen]$ParentScreen
    [bool]$Modal = $true
    [int]$Width = 60
    [int]$Height = 10
    [int]$X
    [int]$Y
    
    Dialog([Screen]$parent) {
        $this.ParentScreen = $parent
        
        # Center dialog
        $screenWidth = [Console]::WindowWidth
        $screenHeight = [Console]::WindowHeight
        $this.X = [int](($screenWidth - $this.Width) / 2)
        $this.Y = [int](($screenHeight - $this.Height) / 2)
    }
    
    [string] RenderContent() {
        # Build complete dialog in memory
        $output = ""
        
        # First render parent screen if exists
        if ($this.ParentScreen) {
            $output += $this.ParentScreen.RenderContent()
        }
        
        # Draw dialog box on top
        $output += $this.DrawBox()
        return $output
    }
    
    # Override RenderToBuffer to handle parent screen properly
    [void] RenderToBuffer([Buffer]$buffer) {
        # First render parent screen if exists
        if ($this.ParentScreen) {
            $this.ParentScreen.RenderToBuffer($buffer)
        }
        
        # Now render dialog on top
        # Draw dialog box background
        $dialogY = $this.Y
        $dialogHeight = $this.Height
        $dialogX = $this.X
        $dialogWidth = $this.Width
        
        foreach ($yOffset in 0..($dialogHeight - 1)) {
            $currentY = $dialogY + $yOffset
            foreach ($xOffset in 0..($dialogWidth - 1)) {
                $currentX = $dialogX + $xOffset
                $buffer.SetCell($currentX, $currentY, ' ', '#FFFFFF', '#333333')
            }
        }
        
        # Draw borders
        # Top border
        $buffer.SetCell($this.X, $this.Y, '┌', '#FFFFFF', '#333333')
        foreach ($xOffset in 1..($this.Width - 2)) {
            $buffer.SetCell($this.X + $xOffset, $this.Y, '─', '#FFFFFF', '#333333')
        }
        $buffer.SetCell($this.X + $this.Width - 1, $this.Y, '┐', '#FFFFFF', '#333333')
        
        # Side borders
        foreach ($yOffset in 1..($this.Height - 2)) {
            $currentY = $this.Y + $yOffset
            $buffer.SetCell($this.X, $currentY, '│', '#FFFFFF', '#333333')
            $buffer.SetCell($this.X + $this.Width - 1, $currentY, '│', '#FFFFFF', '#333333')
        }
        
        # Bottom border
        $bottomY = $this.Y + $this.Height - 1
        $buffer.SetCell($this.X, $bottomY, '└', '#FFFFFF', '#333333')
        foreach ($xOffset in 1..($this.Width - 2)) {
            $buffer.SetCell($this.X + $xOffset, $bottomY, '─', '#FFFFFF', '#333333')
        }
        $buffer.SetCell($this.X + $this.Width - 1, $this.Y + $this.Height - 1, '┘', '#FFFFFF', '#333333')
        
        # Title
        if ($this.Title) {
            $titleX = $this.X + [int](($this.Width - $this.Title.Length - 2) / 2)
            $buffer.WriteString($titleX, $this.Y, " $($this.Title) ", '#FFFF00', '#333333')
        }
    }
    
    [string] DrawBox() {
        $output = ""
        
        # Clear the dialog area with background
        for ($i = 0; $i -lt $this.Height; $i++) {
            $output += [VT]::MoveTo($this.X, $this.Y + $i)
            $output += [VT]::RGBBG(51, 51, 51)  # Dark gray background
            $output += " " * $this.Width
        }
        
        # Top border
        $output += [VT]::MoveTo($this.X, $this.Y)
        $output += [VT]::Border()
        $output += [VT]::TL() + [VT]::H() * ($this.Width - 2) + [VT]::TR()
        
        # Sides and content
        for ($i = 1; $i -lt $this.Height - 1; $i++) {
            $output += [VT]::MoveTo($this.X, $this.Y + $i)
            $output += [VT]::V()
            $output += [VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $i)
            $output += [VT]::V()
        }
        
        # Bottom border
        $output += [VT]::MoveTo($this.X, $this.Y + $this.Height - 1)
        $output += [VT]::BL() + [VT]::H() * ($this.Width - 2) + [VT]::BR()
        
        # Title
        if ($this.Title) {
            $titleX = $this.X + [int](($this.Width - $this.Title.Length - 2) / 2)
            $output += [VT]::MoveTo($titleX, $this.Y)
            $output += [VT]::TextBright() + " $($this.Title) " + [VT]::Reset()
        }
        
        $output += [VT]::Reset()  # Ensure colors are reset
        return $output
    }
}


####\Components/Button.ps1
# Button Component - Interactive button with click events

class Button : Component {
    [string]$Text = "Button"
    [scriptblock]$OnClick = $null
    [bool]$IsPressed = $false
    [bool]$IsDefault = $false  # Default button (responds to Enter from anywhere)
    [bool]$IsCancel = $false   # Cancel button (responds to Escape)
    
    # Visual properties
    [bool]$ShowBorder = $true
    [string]$PressedColor = ""
    [string]$DisabledColor = ""
    [char]$AcceleratorPrefix = '&'  # For keyboard shortcuts like &Save
    hidden [char]$_accelerator = $null
    hidden [int]$_acceleratorIndex = -1
    
    Button([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Height = if ($this.ShowBorder) { 3 } else { 1 }
        $this.UpdateWidth()
    }
    
    [void] SetText([string]$text) {
        $this.Text = $text
        $this.ParseAccelerator()
        $this.UpdateWidth()
        $this.Invalidate()
    }
    
    [void] UpdateWidth() {
        # Auto-size based on text length
        $textLen = $this.GetDisplayText().Length
        $this.Width = [Math]::Max($textLen + 4, 10)  # Minimum width of 10
    }
    
    [string] GetDisplayText() {
        # Remove accelerator prefix for display
        if ($this._acceleratorIndex -ge 0) {
            return $this.Text.Replace("$($this.AcceleratorPrefix)", "")
        }
        return $this.Text
    }
    
    [void] ParseAccelerator() {
        $this._accelerator = $null
        $this._acceleratorIndex = -1
        
        $index = $this.Text.IndexOf($this.AcceleratorPrefix)
        if ($index -ge 0 -and $index -lt $this.Text.Length - 1) {
            $this._accelerator = [char]::ToUpper($this.Text[$index + 1])
            $this._acceleratorIndex = $index
        }
    }
    
    [void] Click() {
        if (-not $this.Enabled) { return }
        
        $this.IsPressed = $true
        $this.Invalidate()
        
        # Visual feedback delay
        Start-Sleep -Milliseconds 100
        
        if ($this.OnClick) {
            & $this.OnClick $this
        }
        
        $this.IsPressed = $false
        $this.Invalidate()
    }
    
    [void] OnRender([object]$buffer) {
        if (-not $this.Visible) { return }
        
        # Determine colors based on state
        $bgColor = ""
        $fgColor = ""
        $borderColor = ""
        
        if (-not $this.Enabled) {
            $bgColor = if ($this.DisabledColor) { $this.DisabledColor } else { [VT]::RGBBG(40, 40, 40) }
            $fgColor = [VT]::RGB(100, 100, 100)
            $borderColor = [VT]::RGB(60, 60, 60)
        } elseif ($this.IsPressed) {
            $bgColor = if ($this.PressedColor) { $this.PressedColor } else { [VT]::RGBBG(60, 60, 80) }
            $fgColor = [VT]::RGB(255, 255, 255)
            $borderColor = [VT]::RGB(150, 150, 200)
        } elseif ($this.IsFocused) {
            $bgColor = if ($this.BackgroundColor) { $this.BackgroundColor } else { [VT]::RGBBG(50, 50, 70) }
            $fgColor = [VT]::RGB(255, 255, 255)
            $borderColor = [VT]::RGB(100, 200, 255)
        } else {
            $bgColor = if ($this.BackgroundColor) { $this.BackgroundColor } else { [VT]::RGBBG(40, 40, 50) }
            $fgColor = if ($this.ForegroundColor) { $this.ForegroundColor } else { [VT]::RGB(200, 200, 200) }
            $borderColor = if ($this.BorderColor) { $this.BorderColor } else { [VT]::RGB(80, 80, 100) }
        }
        
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $this.DrawText($buffer, 0, $y, $bgColor + (" " * $this.Width) + [VT]::Reset())
        }
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $this.DrawBorder($buffer, $borderColor, $bgColor)
        }
        
        # Draw button text centered
        $displayText = $this.GetDisplayText()
        $textY = [int]($this.Height / 2)
        $textX = [int](($this.Width - $displayText.Length) / 2)
        
        if ($this._acceleratorIndex -ge 0) {
            # Draw text with underlined accelerator
            $beforeAccel = $displayText.Substring(0, $this._acceleratorIndex)
            $accelChar = $displayText[$this._acceleratorIndex]
            $afterAccel = if ($this._acceleratorIndex -lt $displayText.Length - 1) {
                $displayText.Substring($this._acceleratorIndex + 1)
            } else { "" }
            
            $x = $textX
            if ($beforeAccel) {
                $this.DrawText($buffer, $x, $textY, $fgColor + $beforeAccel)
                $x += $beforeAccel.Length
            }
            
            # Draw accelerator with underline
            $this.DrawText($buffer, $x, $textY, $fgColor + [VT]::Underline() + $accelChar + [VT]::Reset())
            $x++
            
            if ($afterAccel) {
                $this.DrawText($buffer, $x, $textY, $fgColor + $afterAccel)
            }
        } else {
            # Draw normal text
            $this.DrawText($buffer, $textX, $textY, $fgColor + $displayText)
        }
        
        # Add visual indicators for special buttons
        if ($this.IsDefault) {
            # Draw default indicator (brackets)
            $this.DrawText($buffer, 1, $textY, $fgColor + "[")
            $this.DrawText($buffer, $this.Width - 2, $textY, $fgColor + "]")
        }
        
        $this.DrawText($buffer, 0, 0, [VT]::Reset())
    }
    
    [void] DrawBorder([object]$buffer, [string]$borderColor, [string]$bgColor) {
        # Different border styles based on state
        $style = if ($this.IsPressed) { "Double" } else { "Single" }
        
        $chars = switch ($style) {
            "Double" { @{TL="╔"; TR="╗"; BL="╚"; BR="╝"; H="═"; V="║"} }
            default { @{TL="┌"; TR="┐"; BL="└"; BR="┘"; H="─"; V="│"} }
        }
        
        # Top border
        $this.DrawText($buffer, 0, 0, $borderColor + $chars.TL + ($chars.H * ($this.Width - 2)) + $chars.TR)
        
        # Sides
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $this.DrawText($buffer, 0, $y, $borderColor + $chars.V)
            $this.DrawText($buffer, $this.Width - 1, $y, $borderColor + $chars.V)
        }
        
        # Bottom border
        $this.DrawText($buffer, 0, $this.Height - 1, 
                      $borderColor + $chars.BL + ($chars.H * ($this.Width - 2)) + $chars.BR)
    }
    
    [void] DrawText([object]$buffer, [int]$x, [int]$y, [string]$text) {
        # Placeholder for alcar buffer integration
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.Enabled) { return $false }
        
        # Handle button activation
        if ($this.IsFocused) {
            if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Click()
                return $true
            }
        }
        
        # Handle accelerator key (Alt+Letter)
        if ($this._accelerator -and 
            ($key.Modifiers -band [ConsoleModifiers]::Alt) -and
            [char]::ToUpper($key.KeyChar) -eq $this._accelerator) {
            $this.Click()
            return $true
        }
        
        # Handle default button behavior
        if ($this.IsDefault -and $key.Key -eq [ConsoleKey]::Enter -and 
            -not ($key.Modifiers -band [ConsoleModifiers]::Alt)) {
            $this.Click()
            return $true
        }
        
        # Handle cancel button behavior  
        if ($this.IsCancel -and $key.Key -eq [ConsoleKey]::Escape) {
            $this.Click()
            return $true
        }
        
        return $false
    }
    
    [void] OnFocus() {
        $this.Invalidate()
    }
    
    [void] OnBlur() {
        $this.Invalidate()
    }
    
    # Static factory methods for common button types
    static [Button] CreateOK([string]$name) {
        $btn = [Button]::new($name)
        $btn.Text = "OK"
        $btn.IsDefault = $true
        return $btn
    }
    
    static [Button] CreateCancel([string]$name) {
        $btn = [Button]::new($name)
        $btn.Text = "Cancel"
        $btn.IsCancel = $true
        return $btn
    }
    
    static [Button] CreateYesNo([string]$name, [bool]$isYes) {
        $btn = [Button]::new($name)
        if ($isYes) {
            $btn.Text = "&Yes"
            $btn.IsDefault = $true
        } else {
            $btn.Text = "&No"
            $btn.IsCancel = $true
        }
        return $btn
    }
}


####\Components/CheckBox.ps1
# CheckBox Component - Boolean toggle input

class CheckBox : Component {
    [string]$Text = ""
    [bool]$Checked = $false
    [scriptblock]$OnChange = $null
    
    # Visual properties
    [string]$CheckedChar = "✓"
    [string]$UncheckedChar = " "
    [bool]$ShowBrackets = $true
    [string]$CheckedColor = ""
    [string]$TextAlignment = "Right"  # Left or Right of checkbox
    
    # Three-state support
    [bool]$ThreeState = $false
    [nullable[bool]]$CheckState = $false  # $null = indeterminate
    [string]$IndeterminateChar = "■"
    
    CheckBox([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Height = 1
        $this.UpdateWidth()
    }
    
    [void] SetText([string]$text) {
        $this.Text = $text
        $this.UpdateWidth()
        $this.Invalidate()
    }
    
    [void] UpdateWidth() {
        # Auto-size: checkbox (3) + space (1) + text
        $checkBoxWidth = if ($this.ShowBrackets) { 3 } else { 1 }
        $this.Width = $checkBoxWidth + 1 + $this.Text.Length
    }
    
    [void] Toggle() {
        if ($this.ThreeState) {
            # Cycle through: unchecked -> checked -> indeterminate -> unchecked
            if ($this.CheckState -eq $false) {
                $this.CheckState = $true
                $this.Checked = $true
            } elseif ($this.CheckState -eq $true) {
                $this.CheckState = $null  # Indeterminate
                $this.Checked = $false
            } else {
                $this.CheckState = $false
                $this.Checked = $false
            }
        } else {
            # Simple toggle
            $this.Checked = -not $this.Checked
            $this.CheckState = $this.Checked
        }
        
        if ($this.OnChange) {
            & $this.OnChange $this $this.CheckState
        }
        
        $this.Invalidate()
    }
    
    [void] SetChecked([bool]$checked) {
        $this.Checked = $checked
        $this.CheckState = $checked
        $this.Invalidate()
    }
    
    [void] SetIndeterminate() {
        if ($this.ThreeState) {
            $this.CheckState = $null
            $this.Checked = $false
            $this.Invalidate()
        }
    }
    
    [void] OnRender([object]$buffer) {
        if (-not $this.Visible) { return }
        
        # Determine colors
        $bgColor = if ($this.BackgroundColor) { $this.BackgroundColor } else { "" }
        $fgColor = if ($this.ForegroundColor) { $this.ForegroundColor } else { [VT]::RGB(200, 200, 200) }
        $checkColor = if ($this.CheckedColor) { $this.CheckedColor } else { [VT]::RGB(100, 255, 100) }
        
        if ($this.IsFocused) {
            $fgColor = [VT]::RGB(255, 255, 255)
        }
        
        if (-not $this.Enabled) {
            $fgColor = [VT]::RGB(100, 100, 100)
            $checkColor = [VT]::RGB(80, 80, 80)
        }
        
        # Build checkbox display
        $checkDisplay = ""
        if ($this.ShowBrackets) {
            $innerChar = if ($this.CheckState -eq $null) {
                $this.IndeterminateChar
            } elseif ($this.CheckState -eq $true) {
                $this.CheckedChar
            } else {
                $this.UncheckedChar
            }
            
            $checkDisplay = "[" + $innerChar + "]"
        } else {
            $checkDisplay = if ($this.CheckState -eq $null) {
                $this.IndeterminateChar
            } elseif ($this.CheckState -eq $true) {
                $this.CheckedChar
            } else {
                $this.UncheckedChar
            }
        }
        
        # Draw based on text alignment
        $x = 0
        if ($this.TextAlignment -eq "Right") {
            # Checkbox on left, text on right
            $this.DrawText($buffer, $x, 0, $bgColor)
            
            # Draw checkbox
            if ($this.CheckState -eq $true) {
                $this.DrawText($buffer, $x, 0, $checkColor + $checkDisplay + [VT]::Reset())
            } else {
                $this.DrawText($buffer, $x, 0, $fgColor + $checkDisplay + [VT]::Reset())
            }
            
            # Draw text
            if ($this.Text) {
                $x += $checkDisplay.Length + 1
                $this.DrawText($buffer, $x, 0, $fgColor + $this.Text + [VT]::Reset())
            }
        } else {
            # Text on left, checkbox on right
            if ($this.Text) {
                $this.DrawText($buffer, $x, 0, $fgColor + $this.Text + " " + [VT]::Reset())
                $x += $this.Text.Length + 1
            }
            
            # Draw checkbox
            if ($this.CheckState -eq $true) {
                $this.DrawText($buffer, $x, 0, $checkColor + $checkDisplay + [VT]::Reset())
            } else {
                $this.DrawText($buffer, $x, 0, $fgColor + $checkDisplay + [VT]::Reset())
            }
        }
    }
    
    [void] DrawText([object]$buffer, [int]$x, [int]$y, [string]$text) {
        # Placeholder for alcar buffer integration
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.Enabled -or -not $this.IsFocused) { return $false }
        
        switch ($key.Key) {
            ([ConsoleKey]::Spacebar) {
                $this.Toggle()
                return $true
            }
            ([ConsoleKey]::Enter) {
                $this.Toggle()
                return $true
            }
        }
        
        # Handle letter shortcuts (first letter of text)
        if ($this.Text -and $key.KeyChar) {
            $firstChar = [char]::ToUpper($this.Text[0])
            if ([char]::ToUpper($key.KeyChar) -eq $firstChar) {
                $this.Toggle()
                return $true
            }
        }
        
        return $false
    }
    
    [void] OnFocus() {
        $this.Invalidate()
    }
    
    [void] OnBlur() {
        $this.Invalidate()
    }
    
    # Static factory methods
    static [CheckBox] CreateThreeState([string]$name, [string]$text) {
        $cb = [CheckBox]::new($name)
        $cb.Text = $text
        $cb.ThreeState = $true
        return $cb
    }
    
    static [CheckBox] CreateSwitch([string]$name, [string]$text) {
        $cb = [CheckBox]::new($name)
        $cb.Text = $text
        $cb.ShowBrackets = $false
        $cb.CheckedChar = "ON "
        $cb.UncheckedChar = "OFF"
        $cb.CheckedColor = [VT]::RGB(100, 255, 100)
        return $cb
    }
}


####\Components/ComboBox.ps1
# ComboBox Component - Dropdown selection with optional editing

class ComboBox : Component {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = -1
    [string]$SelectedValue = ""
    [string]$DisplayProperty = ""  # For complex objects
    [string]$ValueProperty = ""    # For complex objects
    [bool]$IsEditable = $false
    [string]$Placeholder = "Select an item..."
    [scriptblock]$OnSelectionChanged = $null
    
    # Visual properties
    [bool]$ShowBorder = $true
    [int]$DropdownMaxHeight = 10
    [string]$DropdownColor = ""
    
    # Internal state
    hidden [bool]$_isOpen = $false
    hidden [int]$_highlightedIndex = -1
    hidden [string]$_searchText = ""
    hidden [System.Collections.ArrayList]$_filteredItems
    hidden [int]$_scrollOffset = 0
    
    ComboBox([string]$name) : base($name) {
        $this.Items = [System.Collections.ArrayList]::new()
        $this._filteredItems = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
        $this.Height = if ($this.ShowBorder) { 3 } else { 1 }
        $this.Width = 25
    }
    
    [void] SetItems([array]$items) {
        $this.Items.Clear()
        if ($items) {
            $this.Items.AddRange($items)
        }
        $this.SelectedIndex = -1
        $this.SelectedValue = ""
        $this._searchText = ""
        $this.Invalidate()
    }
    
    [void] SelectItem([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            
            $item = $this.Items[$index]
            $this.SelectedValue = $this.GetItemValue($item)
            
            if (-not $this.IsEditable) {
                $this._searchText = $this.GetItemDisplay($item)
            }
            
            if ($oldIndex -ne $index -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged $this $item
            }
        }
    }
    
    [string] GetItemDisplay([object]$item) {
        if ($null -eq $item) { return "" }
        
        if ($this.DisplayProperty -and $item.PSObject.Properties[$this.DisplayProperty]) {
            return $item.($this.DisplayProperty).ToString()
        }
        
        return $item.ToString()
    }
    
    [string] GetItemValue([object]$item) {
        if ($null -eq $item) { return "" }
        
        if ($this.ValueProperty -and $item.PSObject.Properties[$this.ValueProperty]) {
            return $item.($this.ValueProperty).ToString()
        }
        
        return $item.ToString()
    }
    
    [void] OpenDropdown() {
        $this._isOpen = $true
        $this.FilterItems()
        
        # Highlight current selection
        $this._highlightedIndex = -1
        if ($this.SelectedIndex -ge 0) {
            for ($i = 0; $i -lt $this._filteredItems.Count; $i++) {
                if ($this._filteredItems[$i].Index -eq $this.SelectedIndex) {
                    $this._highlightedIndex = $i
                    break
                }
            }
        }
        
        if ($this._highlightedIndex -eq -1 -and $this._filteredItems.Count -gt 0) {
            $this._highlightedIndex = 0
        }
        
        $this.Invalidate()
    }
    
    [void] CloseDropdown() {
        $this._isOpen = $false
        if (-not $this.IsEditable) {
            $this._searchText = if ($this.SelectedIndex -ge 0) {
                $this.GetItemDisplay($this.Items[$this.SelectedIndex])
            } else { "" }
        }
        $this.Invalidate()
    }
    
    [void] FilterItems() {
        $this._filteredItems.Clear()
        
        if ([string]::IsNullOrEmpty($this._searchText)) {
            # Show all items
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                $this._filteredItems.Add(@{
                    Index = $i
                    Item = $this.Items[$i]
                }) | Out-Null
            }
        } else {
            # Filter based on search text
            $searchLower = $this._searchText.ToLower()
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                $displayText = $this.GetItemDisplay($this.Items[$i]).ToLower()
                if ($displayText.Contains($searchLower)) {
                    $this._filteredItems.Add(@{
                        Index = $i
                        Item = $this.Items[$i]
                    }) | Out-Null
                }
            }
        }
        
        # Adjust highlighted index
        if ($this._highlightedIndex -ge $this._filteredItems.Count) {
            $this._highlightedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
        }
    }
    
    [void] OnRender([object]$buffer) {
        if (-not $this.Visible) { return }
        
        # Colors
        $bgColor = if ($this.BackgroundColor) { $this.BackgroundColor } else { [VT]::RGBBG(30, 30, 35) }
        $fgColor = if ($this.ForegroundColor) { $this.ForegroundColor } else { [VT]::RGB(220, 220, 220) }
        $borderColor = if ($this.BorderColor) { $this.BorderColor } else {
            if ($this.IsFocused) { [VT]::RGB(100, 200, 255) } else { [VT]::RGB(80, 80, 100) }
        }
        
        # Draw main box
        $this.DrawMainBox($buffer, $bgColor, $fgColor, $borderColor)
        
        # Draw dropdown if open
        if ($this._isOpen) {
            $this.DrawDropdown($buffer)
        }
    }
    
    [void] DrawMainBox([object]$buffer, [string]$bgColor, [string]$fgColor, [string]$borderColor) {
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $this.DrawText($buffer, 0, $y, $bgColor + (" " * $this.Width) + [VT]::Reset())
        }
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $this.DrawBorder($buffer, $borderColor)
        }
        
        # Content area
        $contentY = if ($this.ShowBorder) { 1 } else { 0 }
        $contentX = if ($this.ShowBorder) { 1 } else { 0 }
        $contentWidth = $this.Width - (if ($this.ShowBorder) { 3 } else { 1 })  # Space for arrow
        
        # Display text
        $displayText = ""
        if ($this.IsEditable) {
            $displayText = $this._searchText
        } elseif ($this.SelectedIndex -ge 0) {
            $displayText = $this.GetItemDisplay($this.Items[$this.SelectedIndex])
        }
        
        if ([string]::IsNullOrEmpty($displayText) -and -not $this._isOpen) {
            # Show placeholder
            $this.DrawText($buffer, $contentX, $contentY,
                          [VT]::RGB(100, 100, 120) + $this.Placeholder + [VT]::Reset())
        } else {
            # Show text
            if ($displayText.Length -gt $contentWidth) {
                $displayText = $displayText.Substring(0, $contentWidth - 3) + "..."
            }
            $this.DrawText($buffer, $contentX, $contentY, $fgColor + $displayText + [VT]::Reset())
        }
        
        # Draw dropdown arrow
        $arrowX = $this.Width - (if ($this.ShowBorder) { 2 } else { 1 })
        $arrow = if ($this._isOpen) { "▲" } else { "▼" }
        $arrowColor = if ($this.IsFocused) { [VT]::RGB(100, 200, 255) } else { [VT]::RGB(100, 100, 150) }
        $this.DrawText($buffer, $arrowX, $contentY, $arrowColor + $arrow + [VT]::Reset())
    }
    
    [void] DrawDropdown([object]$buffer) {
        $dropY = $this.Height
        $dropHeight = [Math]::Min($this._filteredItems.Count + 2, $this.DropdownMaxHeight)
        
        if ($dropHeight -lt 3) { $dropHeight = 3 }
        
        $dropBgColor = if ($this.DropdownColor) { $this.DropdownColor } else { [VT]::RGBBG(25, 25, 30) }
        $dropBorderColor = [VT]::RGB(80, 80, 100)
        
        # Draw dropdown background
        for ($y = 0; $y -lt $dropHeight; $y++) {
            $this.DrawText($buffer, 0, $dropY + $y, $dropBgColor + (" " * $this.Width) + [VT]::Reset())
        }
        
        # Draw dropdown border
        $this.DrawDropdownBorder($buffer, 0, $dropY, $this.Width, $dropHeight, $dropBorderColor)
        
        # Calculate visible items
        $visibleItems = $dropHeight - 2
        $this._scrollOffset = $this.CalculateScrollOffset($visibleItems)
        
        # Draw items
        $itemY = $dropY + 1
        for ($i = 0; $i -lt $visibleItems -and ($i + $this._scrollOffset) -lt $this._filteredItems.Count; $i++) {
            $filteredItem = $this._filteredItems[$i + $this._scrollOffset]
            $item = $filteredItem.Item
            $isHighlighted = ($i + $this._scrollOffset) -eq $this._highlightedIndex
            $isSelected = $filteredItem.Index -eq $this.SelectedIndex
            
            # Item colors
            if ($isHighlighted) {
                $itemBgColor = [VT]::RGBBG(60, 60, 100)
                $itemFgColor = [VT]::RGB(255, 255, 255)
            } elseif ($isSelected) {
                $itemBgColor = $dropBgColor
                $itemFgColor = [VT]::RGB(100, 200, 255)
            } else {
                $itemBgColor = $dropBgColor
                $itemFgColor = [VT]::RGB(200, 200, 200)
            }
            
            # Clear line and draw item
            $this.DrawText($buffer, 1, $itemY, $itemBgColor + (" " * ($this.Width - 2)) + [VT]::Reset())
            
            $itemText = $this.GetItemDisplay($item)
            if ($itemText.Length -gt $this.Width - 4) {
                $itemText = $itemText.Substring(0, $this.Width - 7) + "..."
            }
            
            $this.DrawText($buffer, 2, $itemY, $itemFgColor + $itemText + [VT]::Reset())
            $itemY++
        }
        
        # Draw scrollbar if needed
        if ($this._filteredItems.Count -gt $visibleItems) {
            $this.DrawScrollbar($buffer, $this.Width - 2, $dropY + 1, $visibleItems, 
                               $this._scrollOffset, $this._filteredItems.Count)
        }
    }
    
    [void] DrawBorder([object]$buffer, [string]$color) {
        $this.DrawText($buffer, 0, 0, $color + "┌" + ("─" * ($this.Width - 2)) + "┐" + [VT]::Reset())
        $this.DrawText($buffer, 0, 1, $color + "│" + [VT]::Reset())
        $this.DrawText($buffer, $this.Width - 1, 1, $color + "│" + [VT]::Reset())
        $this.DrawText($buffer, 0, 2, $color + "└" + ("─" * ($this.Width - 2)) + "┘" + [VT]::Reset())
    }
    
    [void] DrawDropdownBorder([object]$buffer, [int]$x, [int]$y, [int]$w, [int]$h, [string]$color) {
        # Top
        $this.DrawText($buffer, $x, $y, $color + "┌" + ("─" * ($w - 2)) + "┐" + [VT]::Reset())
        # Sides
        for ($i = 1; $i -lt $h - 1; $i++) {
            $this.DrawText($buffer, $x, $y + $i, $color + "│" + [VT]::Reset())
            $this.DrawText($buffer, $x + $w - 1, $y + $i, $color + "│" + [VT]::Reset())
        }
        # Bottom
        $this.DrawText($buffer, $x, $y + $h - 1, $color + "└" + ("─" * ($w - 2)) + "┘" + [VT]::Reset())
    }
    
    [void] DrawScrollbar([object]$buffer, [int]$x, [int]$y, [int]$height, [int]$offset, [int]$total) {
        $thumbSize = [Math]::Max(1, [int]($height * $height / $total))
        $thumbPos = [int](($height - $thumbSize) * $offset / ($total - $height))
        
        for ($i = 0; $i -lt $height; $i++) {
            $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "░" }
            $this.DrawText($buffer, $x, $y + $i, [VT]::RGB(60, 60, 80) + $char + [VT]::Reset())
        }
    }
    
    [int] CalculateScrollOffset([int]$visibleItems) {
        if ($this._filteredItems.Count -le $visibleItems) {
            return 0
        }
        
        if ($this._highlightedIndex -lt $this._scrollOffset) {
            return $this._highlightedIndex
        }
        elseif ($this._highlightedIndex -ge $this._scrollOffset + $visibleItems) {
            return $this._highlightedIndex - $visibleItems + 1
        }
        
        return $this._scrollOffset
    }
    
    [void] DrawText([object]$buffer, [int]$x, [int]$y, [string]$text) {
        # Placeholder for alcar buffer integration
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.Enabled -or -not $this.IsFocused) { return $false }
        
        if (-not $this._isOpen) {
            # Closed state
            switch ($key.Key) {
                ([ConsoleKey]::Enter) {
                    $this.OpenDropdown()
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if (-not $this.IsEditable) {
                        $this.OpenDropdown()
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    $this.OpenDropdown()
                    return $true
                }
                ([ConsoleKey]::UpArrow) {
                    $this.OpenDropdown()
                    return $true
                }
            }
            
            # Handle typing for editable combobox
            if ($this.IsEditable -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                $this._searchText += $key.KeyChar
                $this.OpenDropdown()
                $this.FilterItems()
                $this.Invalidate()
                return $true
            }
        } else {
            # Open state
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.CloseDropdown()
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($this._highlightedIndex -ge 0 -and 
                        $this._highlightedIndex -lt $this._filteredItems.Count) {
                        $filteredItem = $this._filteredItems[$this._highlightedIndex]
                        $this.SelectItem($filteredItem.Index)
                        $this.CloseDropdown()
                    }
                    return $true
                }
                ([ConsoleKey]::UpArrow) {
                    if ($this._highlightedIndex -gt 0) {
                        $this._highlightedIndex--
                        $this.Invalidate()
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this._highlightedIndex -lt $this._filteredItems.Count - 1) {
                        $this._highlightedIndex++
                        $this.Invalidate()
                    }
                    return $true
                }
                ([ConsoleKey]::Home) {
                    $this._highlightedIndex = 0
                    $this._scrollOffset = 0
                    $this.Invalidate()
                    return $true
                }
                ([ConsoleKey]::End) {
                    $this._highlightedIndex = $this._filteredItems.Count - 1
                    $this.Invalidate()
                    return $true
                }
                ([ConsoleKey]::PageUp) {
                    $pageSize = $this.DropdownMaxHeight - 2
                    $this._highlightedIndex = [Math]::Max(0, $this._highlightedIndex - $pageSize)
                    $this.Invalidate()
                    return $true
                }
                ([ConsoleKey]::PageDown) {
                    $pageSize = $this.DropdownMaxHeight - 2
                    $this._highlightedIndex = [Math]::Min($this._filteredItems.Count - 1, 
                                                         $this._highlightedIndex + $pageSize)
                    $this.Invalidate()
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.IsEditable -and $this._searchText.Length -gt 0) {
                        $this._searchText = $this._searchText.Substring(0, $this._searchText.Length - 1)
                        $this.FilterItems()
                        $this.Invalidate()
                        return $true
                    }
                }
            }
            
            # Handle typing in open dropdown
            if ($this.IsEditable -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                $this._searchText += $key.KeyChar
                $this.FilterItems()
                $this.Invalidate()
                return $true
            }
        }
        
        return $false
    }
    
    [void] OnFocus() {
        $this.Invalidate()
    }
    
    [void] OnBlur() {
        $this.CloseDropdown()
        $this.Invalidate()
    }
    
    # Static factory methods
    static [ComboBox] CreateYesNo([string]$name) {
        $combo = [ComboBox]::new($name)
        $combo.SetItems(@("Yes", "No"))
        return $combo
    }
    
    static [ComboBox] CreateFromEnum([string]$name, [Type]$enumType) {
        $combo = [ComboBox]::new($name)
        $values = [Enum]::GetValues($enumType)
        $combo.SetItems($values)
        return $combo
    }
}


####\Components/CommandPalette.ps1
# Command Palette Component - Quick command execution interface
# Inspired by VS Code's Ctrl+Shift+P functionality

class CommandPalette : Component {
    [System.Collections.ArrayList]$Commands
    [System.Collections.ArrayList]$FilteredCommands
    [string]$SearchText = ""
    [int]$SelectedIndex = 0
    [bool]$IsOpen = $false
    [int]$MaxHeight = 15
    [scriptblock]$OnExecute = $null
    [scriptblock]$OnCancel = $null
    
    # Visual settings
    [int]$Width = 60
    [int]$PaddingX = 2
    [int]$PaddingY = 1
    
    CommandPalette([string]$name) : base($name) {
        $this.Commands = [System.Collections.ArrayList]::new()
        $this.FilteredCommands = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] RegisterCommand([string]$name, [string]$description, [scriptblock]$action) {
        $this.Commands.Add(@{
            Name = $name
            Description = $description
            Action = $action
            SearchText = "$name $description".ToLower()
        }) | Out-Null
    }
    
    [void] RegisterCommands([array]$commands) {
        foreach ($cmd in $commands) {
            $this.RegisterCommand($cmd.Name, $cmd.Description, $cmd.Action)
        }
    }
    
    [void] Open() {
        $this.IsOpen = $true
        $this.SearchText = ""
        $this.SelectedIndex = 0
        $this.UpdateFilter()
        $this.Visible = $true
        $this.RequestFocus()
        $this.Invalidate()
    }
    
    [void] Close() {
        $this.IsOpen = $false
        $this.Visible = $false
        $this.SearchText = ""
        if ($this.OnCancel) {
            & $this.OnCancel
        }
        $this.Invalidate()
    }
    
    [void] UpdateFilter() {
        $this.FilteredCommands.Clear()
        
        if ([string]::IsNullOrEmpty($this.SearchText)) {
            $this.FilteredCommands.AddRange($this.Commands)
        } else {
            $searchLower = $this.SearchText.ToLower()
            $scored = @()
            
            foreach ($cmd in $this.Commands) {
                $score = $this.CalculateScore($cmd.SearchText, $searchLower)
                if ($score -gt 0) {
                    $scored += @{
                        Command = $cmd
                        Score = $score
                    }
                }
            }
            
            # Sort by score descending
            $sorted = $scored | Sort-Object -Property Score -Descending
            foreach ($item in $sorted) {
                $this.FilteredCommands.Add($item.Command) | Out-Null
            }
        }
        
        # Reset selection if out of bounds
        if ($this.SelectedIndex -ge $this.FilteredCommands.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this.FilteredCommands.Count - 1)
        }
    }
    
    [int] CalculateScore([string]$text, [string]$search) {
        # Simple fuzzy matching score
        $score = 0
        $textIndex = 0
        
        for ($i = 0; $i -lt $search.Length; $i++) {
            $char = $search[$i]
            $found = $false
            
            for ($j = $textIndex; $j -lt $text.Length; $j++) {
                if ($text[$j] -eq $char) {
                    $score += 10
                    if ($j -eq $textIndex) {
                        $score += 5  # Bonus for consecutive characters
                    }
                    $textIndex = $j + 1
                    $found = $true
                    break
                }
            }
            
            if (-not $found) {
                return 0  # Character not found
            }
        }
        
        # Bonus for exact match
        if ($text.Contains($search)) {
            $score += 50
        }
        
        # Bonus for match at beginning
        if ($text.StartsWith($search)) {
            $score += 100
        }
        
        return $score
    }
    
    [void] OnRender([object]$buffer) {
        if (-not $this.IsOpen -or -not $this.Visible) { return }
        
        # Calculate position (centered on screen)
        $screenWidth = [Console]::WindowWidth
        $screenHeight = [Console]::WindowHeight
        $paletteX = [int](($screenWidth - $this.Width) / 2)
        $paletteY = [int]($screenHeight * 0.2)  # 20% from top
        
        # Draw shadow
        $shadowColor = [VT]::RGB(20, 20, 20)
        for ($y = 1; $y -le $this.GetHeight(); $y++) {
            $this.DrawText($buffer, $paletteX + 2, $paletteY + $y, 
                          $shadowColor + (" " * $this.Width) + [VT]::Reset())
        }
        
        # Draw background
        $bgColor = [VT]::RGBBG(40, 40, 50)
        for ($y = 0; $y -lt $this.GetHeight(); $y++) {
            $this.DrawText($buffer, $paletteX, $paletteY + $y, 
                          $bgColor + (" " * $this.Width) + [VT]::Reset())
        }
        
        # Draw border
        $borderColor = [VT]::RGB(100, 150, 200)
        $this.DrawBorder($buffer, $paletteX, $paletteY, $this.Width, $this.GetHeight(), $borderColor)
        
        # Draw title
        $title = " Command Palette "
        $titleX = $paletteX + [int](($this.Width - $title.Length) / 2)
        $this.DrawText($buffer, $titleX, $paletteY, 
                      $borderColor + [VT]::Bold() + $title + [VT]::Reset())
        
        # Draw search box
        $searchY = $paletteY + 2
        $searchX = $paletteX + $this.PaddingX
        $searchWidth = $this.Width - ($this.PaddingX * 2)
        
        $this.DrawText($buffer, $searchX, $searchY, 
                      [VT]::RGB(150, 150, 150) + "Search: " + [VT]::Reset())
        
        $searchBoxX = $searchX + 8
        $searchBoxWidth = $searchWidth - 8
        $searchBg = if ($this.IsFocused) { [VT]::RGBBG(50, 50, 70) } else { [VT]::RGBBG(30, 30, 40) }
        $this.DrawText($buffer, $searchBoxX, $searchY,
                      $searchBg + $this.SearchText.PadRight($searchBoxWidth) + [VT]::Reset())
        
        # Draw filtered commands
        $listY = $searchY + 2
        $visibleItems = [Math]::Min($this.FilteredCommands.Count, $this.MaxHeight - 5)
        $scrollOffset = $this.CalculateScrollOffset($visibleItems)
        
        for ($i = 0; $i -lt $visibleItems; $i++) {
            $cmdIndex = $i + $scrollOffset
            if ($cmdIndex -ge $this.FilteredCommands.Count) { break }
            
            $cmd = $this.FilteredCommands[$cmdIndex]
            $itemY = $listY + $i
            $isSelected = ($cmdIndex -eq $this.SelectedIndex)
            
            if ($isSelected) {
                # Selected item background
                $this.DrawText($buffer, $paletteX + 1, $itemY,
                              [VT]::RGBBG(60, 60, 100) + (" " * ($this.Width - 2)) + [VT]::Reset())
            }
            
            # Command name
            $nameX = $paletteX + $this.PaddingX
            $nameColor = if ($isSelected) { [VT]::RGB(255, 255, 255) } else { [VT]::RGB(200, 200, 255) }
            $this.DrawText($buffer, $nameX, $itemY, $nameColor + $cmd.Name + [VT]::Reset())
            
            # Command description
            if ($cmd.Description) {
                $descX = $nameX + 25
                $descColor = if ($isSelected) { [VT]::RGB(200, 200, 200) } else { [VT]::RGB(150, 150, 150) }
                $maxDescLen = $this.Width - $descX + $paletteX - $this.PaddingX
                $desc = if ($cmd.Description.Length -gt $maxDescLen) {
                    $cmd.Description.Substring(0, $maxDescLen - 3) + "..."
                } else {
                    $cmd.Description
                }
                $this.DrawText($buffer, $descX, $itemY, $descColor + $desc + [VT]::Reset())
            }
            
            # Selection indicator
            if ($isSelected) {
                $this.DrawText($buffer, $paletteX + 1, $itemY,
                              [VT]::RGB(100, 200, 255) + "▶" + [VT]::Reset())
            }
        }
        
        # Draw scrollbar if needed
        if ($this.FilteredCommands.Count -gt $visibleItems) {
            $this.DrawScrollbar($buffer, $paletteX + $this.Width - 2, $listY, 
                               $visibleItems, $scrollOffset, $this.FilteredCommands.Count)
        }
        
        # Draw help text
        $helpY = $paletteY + $this.GetHeight() - 2
        $helpText = "↑↓ Navigate • Enter Select • Esc Cancel"
        $helpX = $paletteX + [int](($this.Width - $helpText.Length) / 2)
        $this.DrawText($buffer, $helpX, $helpY,
                      [VT]::RGB(100, 100, 100) + $helpText + [VT]::Reset())
        
        # Show cursor in search box
        $cursorX = $searchBoxX + $this.SearchText.Length
        if ($cursorX -lt $searchBoxX + $searchBoxWidth) {
            $this.DrawText($buffer, $cursorX, $searchY, [VT]::ShowCursor())
        }
    }
    
    [int] GetHeight() {
        $itemCount = [Math]::Min($this.FilteredCommands.Count, $this.MaxHeight - 5)
        return 5 + $itemCount + 2  # Border + search + items + help
    }
    
    [int] CalculateScrollOffset([int]$visibleItems) {
        if ($this.FilteredCommands.Count -le $visibleItems) {
            return 0
        }
        
        # Keep selected item visible
        if ($this.SelectedIndex -lt $visibleItems / 2) {
            return 0
        }
        elseif ($this.SelectedIndex -gt $this.FilteredCommands.Count - $visibleItems / 2) {
            return $this.FilteredCommands.Count - $visibleItems
        }
        else {
            return $this.SelectedIndex - [int]($visibleItems / 2)
        }
    }
    
    [void] DrawBorder([object]$buffer, [int]$x, [int]$y, [int]$w, [int]$h, [string]$color) {
        # Top border
        $this.DrawText($buffer, $x, $y, $color + "╭" + ("─" * ($w - 2)) + "╮" + [VT]::Reset())
        
        # Sides
        for ($i = 1; $i -lt $h - 1; $i++) {
            $this.DrawText($buffer, $x, $y + $i, $color + "│" + [VT]::Reset())
            $this.DrawText($buffer, $x + $w - 1, $y + $i, $color + "│" + [VT]::Reset())
        }
        
        # Bottom border
        $this.DrawText($buffer, $x, $y + $h - 1, $color + "╰" + ("─" * ($w - 2)) + "╯" + [VT]::Reset())
    }
    
    [void] DrawScrollbar([object]$buffer, [int]$x, [int]$y, [int]$height, [int]$offset, [int]$total) {
        $thumbSize = [Math]::Max(1, [int]($height * $height / $total))
        $thumbPos = [int](($height - $thumbSize) * $offset / ($total - $height))
        
        for ($i = 0; $i -lt $height; $i++) {
            $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "░" }
            $this.DrawText($buffer, $x, $y + $i, [VT]::RGB(80, 80, 100) + $char + [VT]::Reset())
        }
    }
    
    [void] DrawText([object]$buffer, [int]$x, [int]$y, [string]$text) {
        # Simplified for alcar - would integrate with buffer system
        # In production, this would write to the buffer
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsOpen) { return $false }
        
        switch ($key.Key) {
            ([ConsoleKey]::Escape) {
                $this.Close()
                return $true
            }
            ([ConsoleKey]::Enter) {
                if ($this.FilteredCommands.Count -gt 0 -and $this.SelectedIndex -ge 0) {
                    $cmd = $this.FilteredCommands[$this.SelectedIndex]
                    $this.Close()
                    
                    if ($cmd.Action) {
                        & $cmd.Action
                    }
                    
                    if ($this.OnExecute) {
                        & $this.OnExecute $cmd
                    }
                }
                return $true
            }
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $this.Invalidate()
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.FilteredCommands.Count - 1) {
                    $this.SelectedIndex++
                    $this.Invalidate()
                }
                return $true
            }
            ([ConsoleKey]::Backspace) {
                if ($this.SearchText.Length -gt 0) {
                    $this.SearchText = $this.SearchText.Substring(0, $this.SearchText.Length - 1)
                    $this.UpdateFilter()
                    $this.Invalidate()
                }
                return $true
            }
            default {
                if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or 
                    $key.KeyChar -eq ' ' -or [char]::IsPunctuation($key.KeyChar)) {
                    $this.SearchText += $key.KeyChar
                    $this.UpdateFilter()
                    $this.Invalidate()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    # Static helper to create a global command palette
    static [CommandPalette] CreateGlobal() {
        $palette = [CommandPalette]::new("GlobalCommandPalette")
        
        # Register default commands
        $palette.RegisterCommands(@(
            @{Name = "Tasks: View All"; Description = "Open task list"; Action = {
                $global:ScreenManager.Push([TaskScreen]::new())
            }},
            @{Name = "Projects: View All"; Description = "Open project list"; Action = {
                $global:ScreenManager.Push([ProjectsScreen]::new())
            }},
            @{Name = "File: Browse"; Description = "Open file browser"; Action = {
                $global:ScreenManager.Push([FileBrowserScreen]::new())
            }},
            @{Name = "Editor: New File"; Description = "Create new file in editor"; Action = {
                $global:ScreenManager.Push([TextEditorScreenV2]::new())
            }},
            @{Name = "View: Dashboard"; Description = "Return to dashboard"; Action = {
                $global:ScreenManager.Push([DashboardScreen]::new())
            }},
            @{Name = "Settings: Open"; Description = "Open settings"; Action = {
                $global:ScreenManager.Push([SettingsScreenV2]::new())
            }},
            @{Name = "App: Quit"; Description = "Exit application"; Action = {
                $global:ScreenManager.Quit()
            }}
        ))
        
        return $palette
    }
}


####\Components/ConfirmDialog.ps1
# ConfirmDialog Component - Yes/No confirmation dialog

class ConfirmDialog : Dialog {
    [string]$YesText = "Yes"
    [string]$NoText = "No"
    [bool]$DefaultToNo = $true
    hidden [int]$_selectedButton = 1  # 0=Yes, 1=No
    
    ConfirmDialog() : base() {
        $this.DialogWidth = 40
        $this.DialogHeight = 8
        $this.InitializeConfirmDialog()
    }
    
    ConfirmDialog([string]$title, [string]$message) : base($title, $message) {
        $this.DialogWidth = [Math]::Max(40, $message.Length + 4)
        $this.DialogHeight = 8
        $this.InitializeConfirmDialog()
    }
    
    [void] InitializeConfirmDialog() {
        # Set default selection
        $this._selectedButton = if ($this.DefaultToNo) { 1 } else { 0 }
        
        # Key bindings
        $this.BindKey([ConsoleKey]::LeftArrow, { $this.SelectPrevious() })
        $this.BindKey([ConsoleKey]::RightArrow, { $this.SelectNext() })
        $this.BindKey([ConsoleKey]::Tab, { $this.SelectNext() })
        $this.BindKey([ConsoleKey]::Enter, { $this.Confirm() })
        $this.BindKey('y', { $this.Yes() })
        $this.BindKey('n', { $this.No() })
    }
    
    [void] SelectPrevious() {
        if ($this._selectedButton -gt 0) {
            $this._selectedButton--
            $this.RequestRender()
        }
    }
    
    [void] SelectNext() {
        if ($this._selectedButton -lt 1) {
            $this._selectedButton++
            $this.RequestRender()
        }
    }
    
    [void] Confirm() {
        if ($this._selectedButton -eq 0) {
            $this.Yes()
        } else {
            $this.No()
        }
    }
    
    [void] Yes() {
        $this.Result = [DialogResult]::Yes
        $this.Close()
    }
    
    [void] No() {
        $this.Result = [DialogResult]::No
        $this.Close()
    }
    
    [string] RenderDialogContent() {
        $output = ""
        
        # Calculate button positions
        $buttonY = $this.DialogY + $this.DialogHeight - 3
        $totalButtonWidth = $this.YesText.Length + $this.NoText.Length + 10  # +4 per button, +2 space
        $startX = $this.DialogX + [int](($this.DialogWidth - $totalButtonWidth) / 2)
        
        # Draw Yes button
        $yesX = $startX
        $output += $this.DrawButton($this.YesText, $yesX, $buttonY, $this._selectedButton -eq 0)
        
        # Draw No button
        $noX = $startX + $this.YesText.Length + 6
        $output += $this.DrawButton($this.NoText, $noX, $buttonY, $this._selectedButton -eq 1)
        
        # Help text
        $helpY = $this.DialogY + $this.DialogHeight - 2
        $helpText = "Press Y/N or use arrows"
        $helpX = $this.DialogX + [int](($this.DialogWidth - $helpText.Length) / 2)
        $output += [VT]::MoveTo($helpX, $helpY)
        $output += [VT]::RGB(100, 100, 100) + $helpText + [VT]::Reset()
        
        return $output
    }
    
    # Static factory methods
    static [bool] Show([string]$title, [string]$message) {
        $dialog = [ConfirmDialog]::new($title, $message)
        $result = $dialog.ShowDialog()
        return $result -eq [DialogResult]::Yes
    }
    
    static [bool] ShowWarning([string]$message) {
        $dialog = [ConfirmDialog]::new("Warning", $message)
        $dialog.DialogBorderColor = [VT]::RGB(255, 200, 100)
        $dialog.DefaultToNo = $true
        $result = $dialog.ShowDialog()
        return $result -eq [DialogResult]::Yes
    }
    
    static [bool] ShowDelete([string]$itemName) {
        $message = "Are you sure you want to delete '$itemName'?"
        $dialog = [ConfirmDialog]::new("Confirm Delete", $message)
        $dialog.YesText = "Delete"
        $dialog.NoText = "Cancel"
        $dialog.DialogBorderColor = [VT]::RGB(255, 100, 100)
        $dialog.DefaultToNo = $true
        $result = $dialog.ShowDialog()
        return $result -eq [DialogResult]::Yes
    }
}


####\Components/DataGrid.ps1
# DataGrid Component - Advanced tabular data display with scrolling and selection

class DataColumn {
    [string]$Name
    [string]$Property
    [int]$Width
    [string]$Align = "Left"  # Left, Right, Center
    [scriptblock]$Format = $null
    [bool]$Sortable = $true
    
    DataColumn([string]$name, [string]$property, [int]$width) {
        $this.Name = $name
        $this.Property = $property
        $this.Width = $width
    }
}

class DataGrid : Component {
    [System.Collections.ArrayList]$Columns
    [System.Collections.ArrayList]$Data
    [int]$SelectedIndex = 0
    [int]$ScrollOffsetX = 0
    [int]$ScrollOffsetY = 0
    [bool]$ShowHeader = $true
    [bool]$ShowBorder = $true
    [bool]$ShowRowNumbers = $false
    [bool]$AllowSort = $true
    [string]$SortColumn = ""
    [bool]$SortAscending = $true
    
    # Visual settings
    [string]$HeaderColor = ""
    [string]$SelectedColor = ""
    [string]$AlternateRowColor = ""
    [bool]$AlternateRows = $true
    
    # Performance optimization
    hidden [hashtable]$_renderCache = @{}
    hidden [int]$_visibleRows = 0
    hidden [int]$_visibleColumns = 0
    
    DataGrid([string]$name) : base($name) {
        $this.Columns = [System.Collections.ArrayList]::new()
        $this.Data = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] AddColumn([DataColumn]$column) {
        $this.Columns.Add($column) | Out-Null
        $this.InvalidateCache()
    }
    
    [void] AddColumns([DataColumn[]]$columns) {
        foreach ($col in $columns) {
            $this.Columns.Add($col) | Out-Null
        }
        $this.InvalidateCache()
    }
    
    [void] SetData([array]$data) {
        $this.Data.Clear()
        if ($data) {
            $this.Data.AddRange($data)
        }
        $this.SelectedIndex = if ($data.Count -gt 0) { 0 } else { -1 }
        $this.ScrollOffsetY = 0
        $this.InvalidateCache()
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Data.Count) {
            return $this.Data[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] Sort([string]$columnProperty) {
        if (-not $this.AllowSort) { return }
        
        # Toggle sort direction if same column
        if ($this.SortColumn -eq $columnProperty) {
            $this.SortAscending = -not $this.SortAscending
        } else {
            $this.SortColumn = $columnProperty
            $this.SortAscending = $true
        }
        
        # Perform sort
        $sorted = if ($this.SortAscending) {
            $this.Data | Sort-Object -Property $columnProperty
        } else {
            $this.Data | Sort-Object -Property $columnProperty -Descending
        }
        
        $this.Data.Clear()
        $this.Data.AddRange($sorted)
        $this.InvalidateCache()
        $this.Invalidate()
    }
    
    [void] OnRender([object]$buffer) {
        # Calculate visible area
        $this._visibleRows = $this.Height - (if ($this.ShowBorder) { 2 } else { 0 }) - (if ($this.ShowHeader) { 1 } else { 0 })
        
        $currentY = 0
        
        # Draw border top
        if ($this.ShowBorder) {
            $this.DrawBorderLine($buffer, 0, $currentY, "top")
            $currentY++
        }
        
        # Draw header
        if ($this.ShowHeader) {
            $this.DrawHeader($buffer, 0, $currentY)
            $currentY++
        }
        
        # Draw data rows
        $this.DrawDataRows($buffer, 0, $currentY)
        
        # Draw border bottom
        if ($this.ShowBorder) {
            $this.DrawBorderLine($buffer, 0, $this.Height - 1, "bottom")
        }
        
        # Draw scrollbars if needed
        $this.DrawScrollbars($buffer)
    }
    
    [void] DrawHeader([object]$buffer, [int]$x, [int]$y) {
        $headerColorValue = ""
        if ($this.HeaderColor) {
            $headerColorValue = $this.HeaderColor
        } else {
            $headerColorValue = [VT]::RGB(150, 150, 200)
        }
        $line = ""
        
        # Row number column
        if ($this.ShowRowNumbers) {
            $line += " # ".PadRight(5)
            if ($this.ShowBorder) {
                $line += "│ "
            }
        }
        
        # Data columns
        $colX = 0
        foreach ($col in $this.Columns) {
            if ($colX -ge $this.ScrollOffsetX -and $colX -lt $this.ScrollOffsetX + $this._visibleColumns) {
                $headerText = $col.Name
                
                # Add sort indicator
                if ($this.AllowSort -and $col.Property -eq $this.SortColumn) {
                    $sortChar = if ($this.SortAscending) { "▲" } else { "▼" }
                    $headerText = $headerText.PadRight($col.Width - 2) + " $sortChar"
                } else {
                    $headerText = $headerText.PadRight($col.Width)
                }
                
                $line += $headerText
                
                # Column separator
                if ($this.Columns.IndexOf($col) -lt $this.Columns.Count - 1) {
                    $line += " │ "
                }
            }
            $colX++
        }
        
        # Draw the header line
        $this.DrawText($buffer, $x, $y, $headerColorValue + [VT]::Bold() + $line + [VT]::Reset())
        
        # Draw separator line if border enabled
        if ($this.ShowBorder) {
            $sepLine = ""
            if ($this.ShowRowNumbers) {
                $sepLine += "─" * 5 + "┼─"
            }
            
            foreach ($col in $this.Columns) {
                $sepLine += "─" * $col.Width
                if ($this.Columns.IndexOf($col) -lt $this.Columns.Count - 1) {
                    $sepLine += "─┼─"
                }
            }
            
            $this.DrawText($buffer, $x, $y + 1, [VT]::RGB(80, 80, 100) + $sepLine + [VT]::Reset())
        }
    }
    
    [void] DrawDataRows([object]$buffer, [int]$x, [int]$startY) {
        $endIndex = [Math]::Min($this.ScrollOffsetY + $this._visibleRows, $this.Data.Count)
        
        for ($i = $this.ScrollOffsetY; $i -lt $endIndex; $i++) {
            $row = $this.Data[$i]
            $y = $startY + ($i - $this.ScrollOffsetY)
            $isSelected = ($i -eq $this.SelectedIndex)
            
            # Row background
            if ($isSelected) {
                $bgColorValue = ""
                if ($this.SelectedColor) {
                    $bgColorValue = $this.SelectedColor
                } else {
                    $bgColorValue = [VT]::RGBBG(40, 40, 80)
                }
                $this.DrawText($buffer, $x, $y, $bgColorValue + (" " * $this.Width) + [VT]::Reset())
            } elseif ($this.AlternateRows -and ($i % 2 -eq 1)) {
                $altColorValue = ""
                if ($this.AlternateRowColor) {
                    $altColorValue = $this.AlternateRowColor
                } else {
                    $altColorValue = [VT]::RGBBG(25, 25, 30)
                }
                $this.DrawText($buffer, $x, $y, $altColorValue + (" " * $this.Width) + [VT]::Reset())
            }
            
            # Build row content
            $line = ""
            
            # Row number
            if ($this.ShowRowNumbers) {
                $rowNum = ($i + 1).ToString().PadLeft(4)
                $line += $rowNum + " "
                if ($this.ShowBorder) {
                    $line += "│ "
                }
            }
            
            # Data columns
            foreach ($col in $this.Columns) {
                $value = ""
                
                try {
                    # Get property value
                    $rawValue = $row.($col.Property)
                    
                    # Format value
                    if ($col.Format) {
                        $value = & $col.Format $rawValue
                    } else {
                        $value = if ($null -ne $rawValue) { $rawValue.ToString() } else { "" }
                    }
                    
                    # Align and truncate
                    if ($value.Length -gt $col.Width) {
                        $value = $value.Substring(0, $col.Width - 3) + "..."
                    }
                    
                    $value = switch ($col.Align) {
                        "Right" { $value.PadLeft($col.Width) }
                        "Center" { 
                            $padding = $col.Width - $value.Length
                            $leftPad = [int]($padding / 2)
                            $rightPad = $padding - $leftPad
                            (" " * $leftPad) + $value + (" " * $rightPad)
                        }
                        default { $value.PadRight($col.Width) }
                    }
                } catch {
                    $value = "ERR".PadRight($col.Width)
                }
                
                $line += $value
                
                # Column separator
                if ($this.Columns.IndexOf($col) -lt $this.Columns.Count - 1) {
                    $line += " │ "
                }
            }
            
            # Draw the row
            $textColor = if ($isSelected) { [VT]::RGB(255, 255, 255) } else { [VT]::RGB(200, 200, 200) }
            $this.DrawText($buffer, $x, $y, $textColor + $line + [VT]::Reset())
        }
    }
    
    [void] DrawBorderLine([object]$buffer, [int]$x, [int]$y, [string]$position) {
        $borderColor = [VT]::RGB(80, 80, 120)
        $line = ""
        
        switch ($position) {
            "top" {
                $line = "┌" + ("─" * ($this.Width - 2)) + "┐"
            }
            "bottom" {
                $line = "└" + ("─" * ($this.Width - 2)) + "┘"
            }
        }
        
        $this.DrawText($buffer, $x, $y, $borderColor + $line + [VT]::Reset())
    }
    
    [void] DrawScrollbars([object]$buffer) {
        # Vertical scrollbar
        if ($this.Data.Count -gt $this._visibleRows) {
            $scrollbarX = $this.Width - 1
            $scrollbarHeight = $this._visibleRows
            $scrollbarY = if ($this.ShowBorder) { 1 } else { 0 }
            if ($this.ShowHeader) { $scrollbarY++ }
            
            $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $scrollbarHeight / $this.Data.Count))
            $thumbPos = [int](($scrollbarHeight - $thumbSize) * $this.ScrollOffsetY / ($this.Data.Count - $this._visibleRows))
            
            for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "░" }
                $this.DrawText($buffer, $scrollbarX, $scrollbarY + $i, 
                              [VT]::RGB(60, 60, 80) + $char + [VT]::Reset())
            }
        }
    }
    
    [void] DrawText([object]$buffer, [int]$x, [int]$y, [string]$text) {
        # Placeholder for alcar buffer integration
    }
    
    [void] InvalidateCache() {
        $this._renderCache.Clear()
        $this._needsRedraw = $true
    }
    
    [void] EnsureVisible() {
        # Vertical scrolling
        if ($this.SelectedIndex -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffsetY + $this._visibleRows) {
            $this.ScrollOffsetY = $this.SelectedIndex - $this._visibleRows + 1
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $handled = $true
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Data.Count - 1) {
                    $this.SelectedIndex++
                    $handled = $true
                }
            }
            ([ConsoleKey]::PageUp) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this._visibleRows)
                $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY - $this._visibleRows)
                $handled = $true
            }
            ([ConsoleKey]::PageDown) {
                $this.SelectedIndex = [Math]::Min($this.Data.Count - 1, $this.SelectedIndex + $this._visibleRows)
                $handled = $true
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.ScrollOffsetY = 0
                $handled = $true
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Data.Count - 1
                $handled = $true
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this.ScrollOffsetX -gt 0) {
                    $this.ScrollOffsetX--
                    $handled = $true
                }
            }
            ([ConsoleKey]::RightArrow) {
                # Calculate max horizontal scroll
                $totalWidth = 0
                foreach ($col in $this.Columns) {
                    $totalWidth += $col.Width + 3  # Include separators
                }
                if ($this.ScrollOffsetX -lt $totalWidth - $this.Width) {
                    $this.ScrollOffsetX++
                    $handled = $true
                }
            }
        }
        
        # Handle column sorting with number keys
        if ($key.KeyChar -ge '1' -and $key.KeyChar -le '9') {
            $colIndex = [int]($key.KeyChar.ToString()) - 1
            if ($colIndex -lt $this.Columns.Count) {
                $col = $this.Columns[$colIndex]
                if ($col.Sortable) {
                    $this.Sort($col.Property)
                    $handled = $true
                }
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
        }
        
        return $handled
    }
}


####\Components/DateInput.ps1
# DateInput Component - Date selection with calendar popup

class DateInput : Component {
    [DateTime]$Value = [DateTime]::Today
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [string]$Format = "yyyy-MM-dd"
    [scriptblock]$OnChange = $null
    
    # Visual properties
    [bool]$ShowBorder = $true
    [bool]$ShowCalendarIcon = $true
    
    # Calendar state
    hidden [bool]$_showCalendar = $false
    hidden [DateTime]$_viewMonth
    hidden [int]$_selectedDay
    
    DateInput([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        if ($this.ShowBorder) {
            $this.Height = 3
        } else {
            $this.Height = 1
        }
        $this._viewMonth = $this.Value
        $this._selectedDay = $this.Value.Day
    }
    
    [void] SetValue([DateTime]$date) {
        if ($date -ge $this.MinDate -and $date -le $this.MaxDate) {
            $oldValue = $this.Value
            $this.Value = $date
            $this._viewMonth = $date
            $this._selectedDay = $date.Day
            
            if ($this.OnChange -and $oldValue -ne $date) {
                & $this.OnChange $this $date
            }
            
            $this.Invalidate()
        }
    }
    
    [void] ToggleCalendar() {
        $this._showCalendar = -not $this._showCalendar
        
        # Adjust component height for calendar
        if ($this._showCalendar) {
            $this.Height = if ($this.ShowBorder) { 12 } else { 10 }
        } else {
            if ($this.ShowBorder) {
            $this.Height = 3
        } else {
            $this.Height = 1
        }
        }
        
        $this.Invalidate()
    }
    
    [void] OnRender([object]$buffer) {
        if (-not $this.Visible) { return }
        
        # Colors
        $bgColor = if ($this.BackgroundColor) { $this.BackgroundColor } else { [VT]::RGBBG(30, 30, 35) }
        $fgColor = if ($this.ForegroundColor) { $this.ForegroundColor } else { [VT]::RGB(220, 220, 220) }
        $borderColor = if ($this.BorderColor) { $this.BorderColor } else {
            if ($this.IsFocused) { [VT]::RGB(100, 200, 255) } else { [VT]::RGB(80, 80, 100) }
        }
        
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $this.DrawText($buffer, 0, $y, $bgColor + (" " * $this.Width) + [VT]::Reset())
        }
        
        # Draw main input box
        if ($this.ShowBorder) {
            $this.DrawBorder($buffer, $borderColor, 0, 0, $this.Width, 3)
        }
        
        # Draw date value
        $dateStr = $this.Value.ToString($this.Format)
        $contentY = if ($this.ShowBorder) { 1 } else { 0 }
        $contentX = if ($this.ShowBorder) { 1 } else { 0 }
        $this.DrawText($buffer, $contentX, $contentY, $fgColor + $dateStr + [VT]::Reset())
        
        # Draw calendar icon
        if ($this.ShowCalendarIcon) {
            $iconX = $this.Width - (if ($this.ShowBorder) { 2 } else { 1 })
            $iconColor = if ($this._showCalendar) { [VT]::RGB(255, 200, 100) } else { [VT]::RGB(100, 100, 150) }
            $this.DrawText($buffer, $iconX, $contentY, $iconColor + "📅" + [VT]::Reset())
        }
        
        # Draw calendar if open
        if ($this._showCalendar) {
            $calendarY = if ($this.ShowBorder) { 3 } else { 1 }
            $this.DrawCalendar($buffer, 0, $calendarY)
        }
    }
    
    [void] DrawCalendar([object]$buffer, [int]$startX, [int]$startY) {
        $calendarWidth = $this.Width
        $calendarHeight = 9
        
        # Calendar colors
        $calBgColor = [VT]::RGBBG(25, 25, 30)
        $calBorderColor = [VT]::RGB(80, 80, 100)
        $headerColor = [VT]::RGB(255, 200, 100)
        $dayHeaderColor = [VT]::RGB(150, 150, 150)
        $normalDayColor = [VT]::RGB(200, 200, 200)
        $selectedDayColor = [VT]::RGB(255, 255, 255)
        $selectedBgColor = [VT]::RGBBG(60, 60, 100)
        $todayColor = [VT]::RGB(100, 255, 100)
        $otherMonthColor = [VT]::RGB(80, 80, 80)
        
        # Draw calendar background
        for ($y = 0; $y -lt $calendarHeight; $y++) {
            $this.DrawText($buffer, $startX, $startY + $y, $calBgColor + (" " * $calendarWidth) + [VT]::Reset())
        }
        
        # Draw calendar border
        $this.DrawBorder($buffer, $calBorderColor, $startX, $startY, $calendarWidth, $calendarHeight)
        
        # Month/Year header
        $monthYearStr = $this._viewMonth.ToString("MMMM yyyy")
        $headerX = $startX + [int](($calendarWidth - $monthYearStr.Length) / 2)
        $this.DrawText($buffer, $headerX, $startY + 1, $headerColor + $monthYearStr + [VT]::Reset())
        
        # Navigation arrows
        $this.DrawText($buffer, $startX + 1, $startY + 1, $headerColor + "◄" + [VT]::Reset())
        $this.DrawText($buffer, $startX + $calendarWidth - 2, $startY + 1, $headerColor + "►" + [VT]::Reset())
        
        # Day headers
        $dayHeaders = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
        $dayX = $startX + 2
        foreach ($day in $dayHeaders) {
            $this.DrawText($buffer, $dayX, $startY + 2, $dayHeaderColor + $day + [VT]::Reset())
            $dayX += 3
        }
        
        # Calendar days
        $firstDay = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, 1)
        $startDayOfWeek = [int]$firstDay.DayOfWeek
        $daysInMonth = [DateTime]::DaysInMonth($this._viewMonth.Year, $this._viewMonth.Month)
        $today = [DateTime]::Today
        
        # Previous month days
        $prevMonth = $this._viewMonth.AddMonths(-1)
        $daysInPrevMonth = [DateTime]::DaysInMonth($prevMonth.Year, $prevMonth.Month)
        $prevMonthDay = $daysInPrevMonth - $startDayOfWeek + 1
        
        $currentDay = 1
        $nextMonthDay = 1
        
        for ($week = 0; $week -lt 6; $week++) {
            for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                $dayX = $startX + 2 + ($dayOfWeek * 3)
                $dayY = $startY + 3 + $week
                
                $dayStr = ""
                $dayColor = $normalDayColor
                $dayBgColor = $calBgColor
                
                if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) {
                    # Previous month
                    $dayStr = $prevMonthDay.ToString().PadLeft(2)
                    $dayColor = $otherMonthColor
                    $prevMonthDay++
                } elseif ($currentDay -le $daysInMonth) {
                    # Current month
                    $dayStr = $currentDay.ToString().PadLeft(2)
                    $currentDate = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, $currentDay)
                    
                    # Highlight selected day
                    if ($currentDate -eq $this.Value) {
                        $dayColor = $selectedDayColor
                        $dayBgColor = $selectedBgColor
                    }
                    # Highlight today
                    elseif ($currentDate -eq $today) {
                        $dayColor = $todayColor
                    }
                    
                    $currentDay++
                } else {
                    # Next month
                    $dayStr = $nextMonthDay.ToString().PadLeft(2)
                    $dayColor = $otherMonthColor
                    $nextMonthDay++
                }
                
                if ($dayStr) {
                    $this.DrawText($buffer, $dayX, $dayY, $dayBgColor + $dayColor + $dayStr + [VT]::Reset())
                }
            }
        }
    }
    
    [void] DrawBorder([object]$buffer, [string]$color, [int]$x, [int]$y, [int]$w, [int]$h) {
        # Top
        $this.DrawText($buffer, $x, $y, $color + "┌" + ("─" * ($w - 2)) + "┐" + [VT]::Reset())
        
        # Sides
        for ($i = 1; $i -lt $h - 1; $i++) {
            $this.DrawText($buffer, $x, $y + $i, $color + "│" + [VT]::Reset())
            $this.DrawText($buffer, $x + $w - 1, $y + $i, $color + "│" + [VT]::Reset())
        }
        
        # Bottom
        $this.DrawText($buffer, $x, $y + $h - 1, $color + "└" + ("─" * ($w - 2)) + "┘" + [VT]::Reset())
    }
    
    [void] DrawText([object]$buffer, [int]$x, [int]$y, [string]$text) {
        # Placeholder for alcar buffer integration
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.Enabled -or -not $this.IsFocused) { return $false }
        
        if (-not $this._showCalendar) {
            # Closed state
            switch ($key.Key) {
                ([ConsoleKey]::Enter) {
                    $this.ToggleCalendar()
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    $this.ToggleCalendar()
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $this.ToggleCalendar()
                    return $true
                }
            }
        } else {
            # Calendar open
            $oldValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this._showCalendar = $false
                    if ($this.ShowBorder) {
            $this.Height = 3
        } else {
            $this.Height = 1
        }
                    $this.Invalidate()
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    # Confirm selection
                    $this._showCalendar = $false
                    if ($this.ShowBorder) {
            $this.Height = 3
        } else {
            $this.Height = 1
        }
                    $this.Invalidate()
                    return $true
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Previous month
                        $this._viewMonth = $this._viewMonth.AddMonths(-1)
                        if ($this._viewMonth.Month -eq $this.Value.Month -and 
                            $this._viewMonth.Year -eq $this.Value.Year) {
                            $this._selectedDay = $this.Value.Day
                        } else {
                            $this._selectedDay = 1
                        }
                    } else {
                        # Previous day
                        $newDate = $this.Value.AddDays(-1)
                        if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                            $this.Value = $newDate
                            $this._viewMonth = $newDate
                            $this._selectedDay = $newDate.Day
                        }
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Next month
                        $this._viewMonth = $this._viewMonth.AddMonths(1)
                        if ($this._viewMonth.Month -eq $this.Value.Month -and 
                            $this._viewMonth.Year -eq $this.Value.Year) {
                            $this._selectedDay = $this.Value.Day
                        } else {
                            $this._selectedDay = 1
                        }
                    } else {
                        # Next day
                        $newDate = $this.Value.AddDays(1)
                        if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                            $this.Value = $newDate
                            $this._viewMonth = $newDate
                            $this._selectedDay = $newDate.Day
                        }
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    # Previous week
                    $newDate = $this.Value.AddDays(-7)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._viewMonth = $newDate
                        $this._selectedDay = $newDate.Day
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    # Next week
                    $newDate = $this.Value.AddDays(7)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._viewMonth = $newDate
                        $this._selectedDay = $newDate.Day
                    }
                }
                ([ConsoleKey]::Home) {
                    # First day of month
                    $newDate = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, 1)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._selectedDay = 1
                    }
                }
                ([ConsoleKey]::End) {
                    # Last day of month
                    $lastDay = [DateTime]::DaysInMonth($this._viewMonth.Year, $this._viewMonth.Month)
                    $newDate = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, $lastDay)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._selectedDay = $lastDay
                    }
                }
                ([ConsoleKey]::T) {
                    # Today
                    $today = [DateTime]::Today
                    if ($today -ge $this.MinDate -and $today -le $this.MaxDate) {
                        $this.Value = $today
                        $this._viewMonth = $today
                        $this._selectedDay = $today.Day
                    }
                }
            }
            
            if ($oldValue -ne $this.Value -and $this.OnChange) {
                & $this.OnChange $this $this.Value
            }
            
            $this.Invalidate()
            return $true
        }
        
        return $false
    }
    
    [void] OnFocus() {
        $this.Invalidate()
    }
    
    [void] OnBlur() {
        if ($this._showCalendar) {
            $this.ToggleCalendar()
        }
        $this.Invalidate()
    }
    
    # Static factory methods
    static [DateInput] CreateBirthDate([string]$name) {
        $input = [DateInput]::new($name)
        $input.MinDate = [DateTime]::new(1900, 1, 1)
        $input.MaxDate = [DateTime]::Today
        return $input
    }
    
    static [DateInput] CreateFutureDate([string]$name) {
        $input = [DateInput]::new($name)
        $input.MinDate = [DateTime]::Today
        $input.MaxDate = [DateTime]::Today.AddYears(10)
        return $input
    }
}


####\Components/ListBox.ps1
# ListBox Component - Optimized for alcar
# Minimal overhead, fast rendering, virtual scrolling

class ListBox : Component {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$HasBorder = $true
    [string]$BorderColor = ""
    [string]$SelectedColor = ""
    [scriptblock]$ItemFormatter = $null
    [scriptblock]$OnSelectionChanged = $null
    
    # Performance optimization
    hidden [int]$_visibleItems = 0
    hidden [bool]$_needsScrollbarUpdate = $true
    
    ListBox([string]$name) : base($name) {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] SetItems([array]$items) {
        $this.Items.Clear()
        $this.Items.AddRange($items)
        $this.SelectedIndex = if ($items.Count -gt 0) { 0 } else { -1 }
        $this.ScrollOffset = 0
        $this.Invalidate()
    }
    
    [void] AddItem([object]$item) {
        $this.Items.Add($item) | Out-Null
        if ($this.SelectedIndex -eq -1) {
            $this.SelectedIndex = 0
        }
        $this.Invalidate()
    }
    
    [void] Clear() {
        $this.Items.Clear()
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] OnRender([object]$buffer) {
        if ($this.HasBorder) {
            $this.DrawBorder($buffer)
            $this._visibleItems = $this.Height - 2
            $contentX = 1
            $contentY = 1
            $contentWidth = $this.Width - 2
        } else {
            $this._visibleItems = $this.Height
            $contentX = 0
            $contentY = 0
            $contentWidth = $this.Width
        }
        
        # Ensure selected item is visible
        $this.EnsureVisible()
        
        # Render visible items only (virtual scrolling)
        $endIndex = [Math]::Min($this.ScrollOffset + $this._visibleItems, $this.Items.Count)
        
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $item = $this.Items[$i]
            $y = $contentY + ($i - $this.ScrollOffset)
            
            # Format item text
            $text = if ($this.ItemFormatter) {
                & $this.ItemFormatter $item
            } else {
                $item.ToString()
            }
            
            # Truncate if too long
            if ($text.Length -gt $contentWidth - 1) {
                $text = $text.Substring(0, $contentWidth - 4) + "..."
            }
            
            # Draw item
            $isSelected = ($i -eq $this.SelectedIndex)
            if ($isSelected) {
                # Selected item
                $bgColor = if ($this.SelectedColor) { $this.SelectedColor } else { [VT]::RGBBG(40, 40, 80) }
                $fgColor = [VT]::RGB(255, 255, 255)
                
                # Fill entire line
                $line = $bgColor + $fgColor + " " + $text.PadRight($contentWidth - 1) + [VT]::Reset()
                $this.DrawText($buffer, $contentX, $y, $line)
            } else {
                # Normal item
                $this.DrawText($buffer, $contentX + 1, $y, $text)
            }
        }
        
        # Draw scrollbar if needed
        if ($this.Items.Count -gt $this._visibleItems -and $this.HasBorder) {
            $this.DrawScrollbar($buffer)
        }
    }
    
    [void] DrawBorder([object]$buffer) {
        $borderColorValue = if ($this.BorderColor) { $this.BorderColor } else { 
            if ($this.IsFocused) { [VT]::RGB(100, 200, 255) } else { [VT]::RGB(100, 100, 150) }
        }
        
        # Top border
        $this.DrawText($buffer, 0, 0, $borderColorValue + "┌" + ("─" * ($this.Width - 2)) + "┐" + [VT]::Reset())
        
        # Sides
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $this.DrawText($buffer, 0, $y, $borderColorValue + "│" + [VT]::Reset())
            $this.DrawText($buffer, $this.Width - 1, $y, $borderColorValue + "│" + [VT]::Reset())
        }
        
        # Bottom border
        $this.DrawText($buffer, 0, $this.Height - 1, $borderColorValue + "└" + ("─" * ($this.Width - 2)) + "┘" + [VT]::Reset())
    }
    
    [void] DrawScrollbar([object]$buffer) {
        $scrollbarX = $this.Width - 2
        $scrollbarHeight = $this._visibleItems
        
        # Calculate thumb size and position
        $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $scrollbarHeight / $this.Items.Count))
        $maxScroll = $this.Items.Count - $this._visibleItems
        $thumbPos = if ($maxScroll -gt 0) {
            [int](($scrollbarHeight - $thumbSize) * $this.ScrollOffset / $maxScroll)
        } else { 0 }
        
        # Draw scrollbar track and thumb
        for ($i = 0; $i -lt $scrollbarHeight; $i++) {
            $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
            $color = [VT]::RGB(100, 100, 150)
            $this.DrawText($buffer, $scrollbarX, $i + 1, $color + $char + [VT]::Reset())
        }
    }
    
    [void] DrawText([object]$buffer, [int]$x, [int]$y, [string]$text) {
        # For alcar, we'll render directly to output
        # This is a simplified approach - in production you'd use the buffer
        # The parent screen will collect these outputs
    }
    
    [void] EnsureVisible() {
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $this._visibleItems) {
            $this.ScrollOffset = $this.SelectedIndex - $this._visibleItems + 1
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $handled = $true
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    $handled = $true
                }
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $handled = $true
            }
            ([ConsoleKey]::PageUp) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this._visibleItems)
                $handled = $true
            }
            ([ConsoleKey]::PageDown) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this._visibleItems)
                $handled = $true
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged $this $this.SelectedIndex
            }
        }
        
        return $handled
    }
}


####\Components/MultilineTextBox.ps1
# MultilineTextBox Component - Multi-line text editor

class MultilineTextBox : Component {
    [System.Collections.ArrayList]$Lines
    [int]$CursorLine = 0
    [int]$CursorColumn = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [bool]$ReadOnly = $false
    [bool]$WordWrap = $false
    [int]$TabSize = 4
    [scriptblock]$OnChange = $null
    [scriptblock]$OnLineChange = $null
    
    # Visual properties
    [bool]$ShowBorder = $true
    [bool]$ShowLineNumbers = $false
    [bool]$ShowScrollbars = $true
    [int]$LineNumberWidth = 4
    
    # Text management
    hidden [int]$_maxLineLength = 0
    hidden [bool]$_modified = $false
    
    MultilineTextBox([string]$name) : base($name) {
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Lines.Add("") | Out-Null
        $this.IsFocusable = $true
        $this.Width = 40
        $this.Height = 10
    }
    
    [void] SetText([string]$text) {
        $this.Lines.Clear()
        
        if ([string]::IsNullOrEmpty($text)) {
            $this.Lines.Add("") | Out-Null
        } else {
            $textLines = $text -split "`r?`n"
            foreach ($line in $textLines) {
                $this.Lines.Add($line) | Out-Null
            }
        }
        
        $this.CursorLine = 0
        $this.CursorColumn = 0
        $this.ScrollOffsetY = 0
        $this.ScrollOffsetX = 0
        $this._modified = $false
        $this.UpdateMaxLineLength()
        $this.Invalidate()
    }
    
    [string] GetText() {
        return $this.Lines -join "`n"
    }
    
    [void] UpdateMaxLineLength() {
        $this._maxLineLength = 0
        foreach ($line in $this.Lines) {
            if ($line.Length -gt $this._maxLineLength) {
                $this._maxLineLength = $line.Length
            }
        }
    }
    
    [void] InsertText([string]$text) {
        if ($this.ReadOnly) { return }
        
        $currentLine = $this.Lines[$this.CursorLine]
        
        # Handle newlines
        if ($text -eq "`n") {
            # Split current line at cursor
            $before = $currentLine.Substring(0, $this.CursorColumn)
            $after = if ($this.CursorColumn -lt $currentLine.Length) {
                $currentLine.Substring($this.CursorColumn)
            } else { "" }
            
            $this.Lines[$this.CursorLine] = $before
            $this.Lines.Insert($this.CursorLine + 1, $after)
            
            $this.CursorLine++
            $this.CursorColumn = 0
        } else {
            # Insert text at cursor position
            $this.Lines[$this.CursorLine] = $currentLine.Insert($this.CursorColumn, $text)
            $this.CursorColumn += $text.Length
        }
        
        $this._modified = $true
        $this.UpdateMaxLineLength()
        
        if ($this.OnChange) {
            & $this.OnChange $this $this.GetText()
        }
        if ($this.OnLineChange) {
            & $this.OnLineChange $this $this.CursorLine $this.Lines[$this.CursorLine]
        }
        
        $this.Invalidate()
    }
    
    [void] DeleteChar([bool]$backspace) {
        if ($this.ReadOnly) { return }
        
        if ($backspace) {
            # Backspace
            if ($this.CursorColumn -gt 0) {
                $currentLine = $this.Lines[$this.CursorLine]
                $this.Lines[$this.CursorLine] = $currentLine.Remove($this.CursorColumn - 1, 1)
                $this.CursorColumn--
            } elseif ($this.CursorLine -gt 0) {
                # Merge with previous line
                $previousLine = $this.Lines[$this.CursorLine - 1]
                $currentLine = $this.Lines[$this.CursorLine]
                $this.CursorColumn = $previousLine.Length
                $this.Lines[$this.CursorLine - 1] = $previousLine + $currentLine
                $this.Lines.RemoveAt($this.CursorLine)
                $this.CursorLine--
            }
        } else {
            # Delete
            $currentLine = $this.Lines[$this.CursorLine]
            if ($this.CursorColumn -lt $currentLine.Length) {
                $this.Lines[$this.CursorLine] = $currentLine.Remove($this.CursorColumn, 1)
            } elseif ($this.CursorLine -lt $this.Lines.Count - 1) {
                # Merge with next line
                $nextLine = $this.Lines[$this.CursorLine + 1]
                $this.Lines[$this.CursorLine] = $currentLine + $nextLine
                $this.Lines.RemoveAt($this.CursorLine + 1)
            }
        }
        
        $this._modified = $true
        $this.UpdateMaxLineLength()
        
        if ($this.OnChange) {
            & $this.OnChange $this $this.GetText()
        }
        
        $this.Invalidate()
    }
    
    [void] EnsureCursorVisible() {
        # Calculate content area
        if ($this.ShowBorder) {
            $contentHeight = $this.Height - 2
            $contentWidth = $this.Width - 2
        } else {
            $contentHeight = $this.Height
            $contentWidth = $this.Width
        }
        
        if ($this.ShowLineNumbers) {
            $contentWidth -= $this.LineNumberWidth + 1
        }
        
        # Vertical scrolling
        if ($this.CursorLine -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CursorLine
        } elseif ($this.CursorLine -ge $this.ScrollOffsetY + $contentHeight) {
            $this.ScrollOffsetY = $this.CursorLine - $contentHeight + 1
        }
        
        # Horizontal scrolling
        if ($this.CursorColumn -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $this.CursorColumn
        } elseif ($this.CursorColumn -ge $this.ScrollOffsetX + $contentWidth) {
            $this.ScrollOffsetX = $this.CursorColumn - $contentWidth + 1
        }
    }
    
    [void] OnRender([object]$buffer) {
        if (-not $this.Visible) { return }
        
        # Colors
        $bgColor = if ($this.BackgroundColor) { $this.BackgroundColor } else { [VT]::RGBBG(30, 30, 35) }
        $fgColor = if ($this.ForegroundColor) { $this.ForegroundColor } else { [VT]::RGB(220, 220, 220) }
        $borderColor = if ($this.BorderColor) { $this.BorderColor } else {
            if ($this.IsFocused) { [VT]::RGB(100, 200, 255) } else { [VT]::RGB(80, 80, 100) }
        }
        $lineNumColor = [VT]::RGB(100, 100, 120)
        
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $this.DrawText($buffer, 0, $y, $bgColor + (" " * $this.Width) + [VT]::Reset())
        }
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $this.DrawBorder($buffer, $borderColor)
        }
        
        # Calculate content area
        $contentY = if ($this.ShowBorder) { 1 } else { 0 }
        $contentX = if ($this.ShowBorder) { 1 } else { 0 }
        if ($this.ShowBorder) {
            $contentHeight = $this.Height - 2
            $contentWidth = $this.Width - 2
        } else {
            $contentHeight = $this.Height
            $contentWidth = $this.Width
        }
        
        # Adjust for line numbers
        $textStartX = $contentX
        if ($this.ShowLineNumbers) {
            $textStartX += $this.LineNumberWidth + 1
            $contentWidth -= $this.LineNumberWidth + 1
        }
        
        # Ensure cursor is visible
        $this.EnsureCursorVisible()
        
        # Draw visible lines
        for ($y = 0; $y -lt $contentHeight; $y++) {
            $lineIndex = $y + $this.ScrollOffsetY
            if ($lineIndex -ge $this.Lines.Count) { break }
            
            # Draw line number if enabled
            if ($this.ShowLineNumbers) {
                $lineNum = ($lineIndex + 1).ToString().PadLeft($this.LineNumberWidth)
                $this.DrawText($buffer, $contentX, $contentY + $y, 
                              $lineNumColor + $lineNum + " " + [VT]::Reset())
            }
            
            # Draw line content
            $line = $this.Lines[$lineIndex]
            $visibleText = ""
            
            if ($line.Length -gt $this.ScrollOffsetX) {
                $endPos = [Math]::Min($this.ScrollOffsetX + $contentWidth, $line.Length)
                $visibleText = $line.Substring($this.ScrollOffsetX, $endPos - $this.ScrollOffsetX)
            }
            
            if ($visibleText) {
                $this.DrawText($buffer, $textStartX, $contentY + $y, 
                              $fgColor + $visibleText + [VT]::Reset())
            }
        }
        
        # Draw cursor if focused
        if ($this.IsFocused -and -not $this.ReadOnly) {
            $cursorScreenY = $contentY + ($this.CursorLine - $this.ScrollOffsetY)
            $cursorScreenX = $textStartX + ($this.CursorColumn - $this.ScrollOffsetX)
            
            if ($cursorScreenY -ge $contentY -and $cursorScreenY -lt $contentY + $contentHeight -and
                $cursorScreenX -ge $textStartX -and $cursorScreenX -lt $textStartX + $contentWidth) {
                
                $charUnderCursor = ' '
                if ($this.CursorLine -lt $this.Lines.Count) {
                    $line = $this.Lines[$this.CursorLine]
                    if ($this.CursorColumn -lt $line.Length) {
                        $charUnderCursor = $line[$this.CursorColumn]
                    }
                }
                
                $this.DrawText($buffer, $cursorScreenX, $cursorScreenY,
                              [VT]::RGBBG(220, 220, 220) + [VT]::RGB(30, 30, 35) + 
                              $charUnderCursor + [VT]::Reset())
            }
        }
        
        # Draw scrollbars if needed
        if ($this.ShowScrollbars) {
            # Vertical scrollbar
            if ($this.Lines.Count -gt $contentHeight) {
                $this.DrawVerticalScrollbar($buffer, $this.Width - 1, $contentY, 
                                           $contentHeight, $this.ScrollOffsetY, $this.Lines.Count)
            }
            
            # Horizontal scrollbar
            if ($this._maxLineLength -gt $contentWidth) {
                $this.DrawHorizontalScrollbar($buffer, $textStartX, $this.Height - 1,
                                            $contentWidth, $this.ScrollOffsetX, $this._maxLineLength)
            }
        }
    }
    
    [void] DrawBorder([object]$buffer, [string]$color) {
        # Top
        $this.DrawText($buffer, 0, 0, $color + "┌" + ("─" * ($this.Width - 2)) + "┐" + [VT]::Reset())
        
        # Sides
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $this.DrawText($buffer, 0, $y, $color + "│" + [VT]::Reset())
            $this.DrawText($buffer, $this.Width - 1, $y, $color + "│" + [VT]::Reset())
        }
        
        # Bottom
        $this.DrawText($buffer, 0, $this.Height - 1, 
                      $color + "└" + ("─" * ($this.Width - 2)) + "┘" + [VT]::Reset())
    }
    
    [void] DrawVerticalScrollbar([object]$buffer, [int]$x, [int]$y, [int]$height, [int]$offset, [int]$total) {
        $thumbSize = [Math]::Max(1, [int]($height * $height / $total))
        $maxOffset = $total - $height
        $thumbPos = if ($maxOffset -gt 0) {
            [int](($height - $thumbSize) * $offset / $maxOffset)
        } else { 0 }
        
        for ($i = 0; $i -lt $height; $i++) {
            $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "░" }
            $this.DrawText($buffer, $x, $y + $i, [VT]::RGB(60, 60, 80) + $char + [VT]::Reset())
        }
    }
    
    [void] DrawHorizontalScrollbar([object]$buffer, [int]$x, [int]$y, [int]$width, [int]$offset, [int]$total) {
        $thumbSize = [Math]::Max(1, [int]($width * $width / $total))
        $maxOffset = $total - $width
        $thumbPos = if ($maxOffset -gt 0) {
            [int](($width - $thumbSize) * $offset / $maxOffset)
        } else { 0 }
        
        for ($i = 0; $i -lt $width; $i++) {
            $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "░" }
            $this.DrawText($buffer, $x + $i, $y, [VT]::RGB(60, 60, 80) + $char + [VT]::Reset())
        }
    }
    
    [void] DrawText([object]$buffer, [int]$x, [int]$y, [string]$text) {
        # Placeholder for alcar buffer integration
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.Enabled -or -not $this.IsFocused) { return $false }
        
        $handled = $true
        
        switch ($key.Key) {
            # Navigation
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorColumn -gt 0) {
                    $this.CursorColumn--
                } elseif ($this.CursorLine -gt 0) {
                    $this.CursorLine--
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
            }
            ([ConsoleKey]::RightArrow) {
                $currentLine = $this.Lines[$this.CursorLine]
                if ($this.CursorColumn -lt $currentLine.Length) {
                    $this.CursorColumn++
                } elseif ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.CursorLine++
                    $this.CursorColumn = 0
                }
            }
            ([ConsoleKey]::UpArrow) {
                if ($this.CursorLine -gt 0) {
                    $this.CursorLine--
                    $currentLine = $this.Lines[$this.CursorLine]
                    $this.CursorColumn = [Math]::Min($this.CursorColumn, $currentLine.Length)
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.CursorLine++
                    $currentLine = $this.Lines[$this.CursorLine]
                    $this.CursorColumn = [Math]::Min($this.CursorColumn, $currentLine.Length)
                }
            }
            ([ConsoleKey]::Home) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    # Go to beginning of document
                    $this.CursorLine = 0
                    $this.CursorColumn = 0
                } else {
                    # Go to beginning of line
                    $this.CursorColumn = 0
                }
            }
            ([ConsoleKey]::End) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    # Go to end of document
                    $this.CursorLine = $this.Lines.Count - 1
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                } else {
                    # Go to end of line
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
            }
            ([ConsoleKey]::PageUp) {
                $pageSize = $this.Height - (if ($this.ShowBorder) { 2 } else { 0 })
                $this.CursorLine = [Math]::Max(0, $this.CursorLine - $pageSize)
                $currentLine = $this.Lines[$this.CursorLine]
                $this.CursorColumn = [Math]::Min($this.CursorColumn, $currentLine.Length)
            }
            ([ConsoleKey]::PageDown) {
                $pageSize = $this.Height - (if ($this.ShowBorder) { 2 } else { 0 })
                $this.CursorLine = [Math]::Min($this.Lines.Count - 1, $this.CursorLine + $pageSize)
                $currentLine = $this.Lines[$this.CursorLine]
                $this.CursorColumn = [Math]::Min($this.CursorColumn, $currentLine.Length)
            }
            
            # Editing
            ([ConsoleKey]::Enter) {
                if (-not $this.ReadOnly) {
                    $this.InsertText("`n")
                }
            }
            ([ConsoleKey]::Backspace) {
                if (-not $this.ReadOnly) {
                    $this.DeleteChar($true)
                }
            }
            ([ConsoleKey]::Delete) {
                if (-not $this.ReadOnly) {
                    $this.DeleteChar($false)
                }
            }
            ([ConsoleKey]::Tab) {
                if (-not $this.ReadOnly) {
                    $this.InsertText(" " * $this.TabSize)
                }
            }
            
            default {
                # Character input
                if (-not $this.ReadOnly -and $key.KeyChar -and 
                    [char]::IsControl($key.KeyChar) -eq $false) {
                    $this.InsertText($key.KeyChar.ToString())
                } else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            $this.EnsureCursorVisible()
            $this.Invalidate()
        }
        
        return $handled
    }
    
    [void] OnFocus() {
        $this.Invalidate()
    }
    
    [void] OnBlur() {
        $this.Invalidate()
    }
    
    # Static factory methods
    static [MultilineTextBox] CreateReadOnly([string]$name, [string]$text) {
        $textBox = [MultilineTextBox]::new($name)
        $textBox.SetText($text)
        $textBox.ReadOnly = $true
        return $textBox
    }
    
    static [MultilineTextBox] CreateWithLineNumbers([string]$name) {
        $textBox = [MultilineTextBox]::new($name)
        $textBox.ShowLineNumbers = $true
        return $textBox
    }
}


####\Components/NumericInput.ps1
# NumericInput Component - Number-only input with validation and spinners

class NumericInput : Component {
    [double]$Value = 0
    [double]$Minimum = [double]::MinValue
    [double]$Maximum = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [scriptblock]$OnChange = $null
    
    # Visual properties
    [bool]$ShowBorder = $true
    [bool]$ShowSpinners = $true
    [string]$Prefix = ""     # e.g., "$" for currency
    [string]$Suffix = ""     # e.g., "%" for percentage
    
    # Internal state
    hidden [string]$_textValue = "0"
    hidden [int]$_cursorPosition = 0
    hidden [bool]$_isEditing = $false
    
    NumericInput([string]$name) : base($name) {
        $this.IsFocusable = $true
        if ($this.ShowBorder) {
            $this.Height = 3
        } else {
            $this.Height = 1
        }
        $this.Width = 15
        $this.UpdateTextValue()
    }
    
    [void] SetValue([double]$value) {
        $this.Value = $this.ClampValue($value)
        $this.UpdateTextValue()
        $this.Invalidate()
    }
    
    [void] SetRange([double]$min, [double]$max) {
        $this.Minimum = $min
        $this.Maximum = $max
        $this.Value = $this.ClampValue($this.Value)
        $this.UpdateTextValue()
        $this.Invalidate()
    }
    
    [double] ClampValue([double]$value) {
        return [Math]::Max($this.Minimum, [Math]::Min($this.Maximum, $value))
    }
    
    [void] UpdateTextValue() {
        if ($this._isEditing) { return }
        
        if ($this.DecimalPlaces -eq 0) {
            $this._textValue = [Math]::Truncate($this.Value).ToString()
        } else {
            $this._textValue = $this.Value.ToString("F$($this.DecimalPlaces)")
        }
        
        $this._cursorPosition = $this._textValue.Length
    }
    
    [void] Increment() {
        $newValue = $this.Value + $this.Step
        if ($newValue -le $this.Maximum) {
            $oldValue = $this.Value
            $this.Value = $newValue
            $this.UpdateTextValue()
            
            if ($this.OnChange -and $oldValue -ne $this.Value) {
                & $this.OnChange $this $this.Value
            }
            
            $this.Invalidate()
        }
    }
    
    [void] Decrement() {
        $newValue = $this.Value - $this.Step
        if ($newValue -ge $this.Minimum) {
            $oldValue = $this.Value
            $this.Value = $newValue
            $this.UpdateTextValue()
            
            if ($this.OnChange -and $oldValue -ne $this.Value) {
                & $this.OnChange $this $this.Value
            }
            
            $this.Invalidate()
        }
    }
    
    [void] ParseAndValidate() {
        try {
            $parsedValue = [double]::Parse($this._textValue)
            $parsedValue = $this.ClampValue($parsedValue)
            
            $oldValue = $this.Value
            $this.Value = $parsedValue
            
            $this._isEditing = $false
            $this.UpdateTextValue()
            
            if ($this.OnChange -and $oldValue -ne $this.Value) {
                & $this.OnChange $this $this.Value
            }
        }
        catch {
            # Reset to valid value on parse error
            $this._isEditing = $false
            $this.UpdateTextValue()
        }
    }
    
    [void] OnRender([object]$buffer) {
        if (-not $this.Visible) { return }
        
        # Colors
        $bgColor = if ($this.BackgroundColor) { $this.BackgroundColor } else { [VT]::RGBBG(30, 30, 35) }
        $fgColor = if ($this.ForegroundColor) { $this.ForegroundColor } else { [VT]::RGB(220, 220, 220) }
        $borderColor = if ($this.BorderColor) { $this.BorderColor } else {
            if ($this.IsFocused) { [VT]::RGB(100, 200, 255) } else { [VT]::RGB(80, 80, 100) }
        }
        
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $this.DrawText($buffer, 0, $y, $bgColor + (" " * $this.Width) + [VT]::Reset())
        }
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $this.DrawBorder($buffer, $borderColor)
        }
        
        # Calculate content area
        $contentY = if ($this.ShowBorder) { 1 } else { 0 }
        $contentX = if ($this.ShowBorder) { 1 } else { 0 }
        $spinnerSpace = if ($this.ShowSpinners) { 3 } else { 0 }
        if ($this.ShowBorder) {
            $contentWidth = $this.Width - 2 - $spinnerSpace
        } else {
            $contentWidth = $this.Width - $spinnerSpace
        }
        
        # Build display text
        $displayText = $this.Prefix + $this._textValue + $this.Suffix
        
        # Ensure text fits
        if ($displayText.Length -gt $contentWidth) {
            # Scroll to keep cursor visible
            if ($this._isEditing) {
                $prefixLen = $this.Prefix.Length
                $cursorInDisplay = $prefixLen + $this._cursorPosition
                
                if ($cursorInDisplay -ge $contentWidth) {
                    $offset = $cursorInDisplay - $contentWidth + 1
                    $displayText = "..." + $displayText.Substring($offset + 3)
                } else {
                    $displayText = $displayText.Substring(0, $contentWidth - 3) + "..."
                }
            } else {
                $displayText = $displayText.Substring(0, $contentWidth - 3) + "..."
            }
        }
        
        # Draw text
        $this.DrawText($buffer, $contentX, $contentY, $fgColor + $displayText + [VT]::Reset())
        
        # Draw cursor if focused and editing
        if ($this.IsFocused -and $this._isEditing) {
            $cursorScreenX = $contentX + $this.Prefix.Length + $this._cursorPosition
            
            if ($cursorScreenX -ge $contentX -and $cursorScreenX -lt $contentX + $contentWidth) {
                $charUnderCursor = ' '
                if ($this._cursorPosition -lt $this._textValue.Length) {
                    $charUnderCursor = $this._textValue[$this._cursorPosition]
                }
                
                $this.DrawText($buffer, $cursorScreenX, $contentY,
                              [VT]::RGBBG(220, 220, 220) + [VT]::RGB(30, 30, 35) + 
                              $charUnderCursor + [VT]::Reset())
            }
        }
        
        # Draw spinners if enabled
        if ($this.ShowSpinners) {
            $spinnerX = $this.Width - (if ($this.ShowBorder) { 2 } else { 1 })
            $spinnerColor = if ($this.IsFocused) { [VT]::RGB(255, 200, 100) } else { [VT]::RGB(100, 100, 100) }
            
            # Up arrow
            $upEnabled = $this.Value -lt $this.Maximum
            $upColor = if ($upEnabled) { $spinnerColor } else { [VT]::RGB(60, 60, 60) }
            $this.DrawText($buffer, $spinnerX, $contentY, $upColor + "▲" + [VT]::Reset())
            
            # Down arrow (if height allows)
            if ($this.Height -ge 3) {
                $downY = if ($this.ShowBorder) { $this.Height - 2 } else { $this.Height - 1 }
                $downEnabled = $this.Value -gt $this.Minimum
                $downColor = if ($downEnabled) { $spinnerColor } else { [VT]::RGB(60, 60, 60) }
                $this.DrawText($buffer, $spinnerX, $downY, $downColor + "▼" + [VT]::Reset())
            }
        }
    }
    
    [void] DrawBorder([object]$buffer, [string]$color) {
        # Top
        $this.DrawText($buffer, 0, 0, $color + "┌" + ("─" * ($this.Width - 2)) + "┐" + [VT]::Reset())
        
        # Sides
        $this.DrawText($buffer, 0, 1, $color + "│" + [VT]::Reset())
        $this.DrawText($buffer, $this.Width - 1, 1, $color + "│" + [VT]::Reset())
        
        # Bottom
        $this.DrawText($buffer, 0, 2, $color + "└" + ("─" * ($this.Width - 2)) + "┘" + [VT]::Reset())
    }
    
    [void] DrawText([object]$buffer, [int]$x, [int]$y, [string]$text) {
        # Placeholder for alcar buffer integration
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.Enabled -or -not $this.IsFocused) { return $false }
        
        $handled = $true
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.Increment()
            }
            ([ConsoleKey]::DownArrow) {
                $this.Decrement()
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this._isEditing -and $this._cursorPosition -gt 0) {
                    $this._cursorPosition--
                    $this.Invalidate()
                } else {
                    $handled = $false
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this._isEditing -and $this._cursorPosition -lt $this._textValue.Length) {
                    $this._cursorPosition++
                    $this.Invalidate()
                } else {
                    $handled = $false
                }
            }
            ([ConsoleKey]::Home) {
                if ($this._isEditing) {
                    $this._cursorPosition = 0
                    $this.Invalidate()
                } else {
                    $handled = $false
                }
            }
            ([ConsoleKey]::End) {
                if ($this._isEditing) {
                    $this._cursorPosition = $this._textValue.Length
                    $this.Invalidate()
                } else {
                    $handled = $false
                }
            }
            ([ConsoleKey]::Backspace) {
                if (-not $this._isEditing) {
                    $this._isEditing = $true
                }
                
                if ($this._cursorPosition -gt 0) {
                    $this._textValue = $this._textValue.Remove($this._cursorPosition - 1, 1)
                    $this._cursorPosition--
                    $this.Invalidate()
                }
            }
            ([ConsoleKey]::Delete) {
                if (-not $this._isEditing) {
                    $this._isEditing = $true
                }
                
                if ($this._cursorPosition -lt $this._textValue.Length) {
                    $this._textValue = $this._textValue.Remove($this._cursorPosition, 1)
                    $this.Invalidate()
                }
            }
            ([ConsoleKey]::Enter) {
                if ($this._isEditing) {
                    $this.ParseAndValidate()
                    $this.Invalidate()
                } else {
                    $handled = $false
                }
            }
            ([ConsoleKey]::Escape) {
                if ($this._isEditing) {
                    # Cancel editing
                    $this._isEditing = $false
                    $this.UpdateTextValue()
                    $this.Invalidate()
                } else {
                    $handled = $false
                }
            }
            default {
                # Handle numeric input
                if ($key.KeyChar -and $key.KeyChar -match '[0-9.\-+]') {
                    if (-not $this._isEditing) {
                        $this._isEditing = $true
                        $this._textValue = ""
                        $this._cursorPosition = 0
                    }
                    
                    # Validate character
                    $canInsert = $true
                    
                    if ($key.KeyChar -eq '.') {
                        # Only one decimal point allowed
                        if ($this._textValue.Contains('.') -or $this.DecimalPlaces -eq 0) {
                            $canInsert = $false
                        }
                    } elseif ($key.KeyChar -match '[\-+]') {
                        # Only at beginning
                        if ($this._cursorPosition -ne 0 -or $this._textValue -match '[\-+]') {
                            $canInsert = $false
                        }
                    }
                    
                    if ($canInsert) {
                        $this._textValue = $this._textValue.Insert($this._cursorPosition, $key.KeyChar)
                        $this._cursorPosition++
                        $this.Invalidate()
                    }
                } else {
                    $handled = $false
                }
            }
        }
        
        return $handled
    }
    
    [void] OnFocus() {
        $this.Invalidate()
    }
    
    [void] OnBlur() {
        if ($this._isEditing) {
            $this.ParseAndValidate()
        }
        $this.Invalidate()
    }
    
    # Static factory methods
    static [NumericInput] CreatePercentage([string]$name) {
        $input = [NumericInput]::new($name)
        $input.Minimum = 0
        $input.Maximum = 100
        $input.Step = 1
        $input.Suffix = "%"
        return $input
    }
    
    static [NumericInput] CreateCurrency([string]$name) {
        $input = [NumericInput]::new($name)
        $input.Minimum = 0
        $input.DecimalPlaces = 2
        $input.Prefix = "$"
        $input.Step = 0.01
        return $input
    }
    
    static [NumericInput] CreateInteger([string]$name, [int]$min, [int]$max) {
        $input = [NumericInput]::new($name)
        $input.Minimum = $min
        $input.Maximum = $max
        $input.DecimalPlaces = 0
        $input.Step = 1
        return $input
    }
}


####\Components/Panel.ps1
# Panel Component - Simple container with optional border

class Panel : Container {
    [bool]$HasBorder = $true
    [string]$Title = ""
    [string]$BorderColor = ""
    [string]$BorderStyle = "Single"  # Single, Double, Rounded
    
    Panel([string]$name) : base($name) {
    }
    
    [void] OnRender([object]$buffer) {
        if ($this.HasBorder) {
            $this.DrawBorder($buffer)
        }
        
        # Render children with adjusted coordinates if border is present
        $offset = if ($this.HasBorder) { 1 } else { 0 }
        
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                # Adjust child position for border
                $originalX = $child.X
                $originalY = $child.Y
                $child.X += $offset
                $child.Y += $offset
                
                # Render child
                ([Component]$child).Render($buffer)
                
                # Restore position
                $child.X = $originalX
                $child.Y = $originalY
            }
        }
    }
    
    [void] DrawBorder([object]$buffer) {
        $color = if ($this.BorderColor) { $this.BorderColor } else {
            if ($this.IsFocused) { [VT]::RGB(100, 200, 255) } else { [VT]::RGB(100, 100, 150) }
        }
        
        # Get border characters based on style
        $chars = switch ($this.BorderStyle) {
            "Double" { @{TL="╔"; TR="╗"; BL="╚"; BR="╝"; H="═"; V="║"} }
            "Rounded" { @{TL="╭"; TR="╮"; BL="╰"; BR="╯"; H="─"; V="│"} }
            default { @{TL="┌"; TR="┐"; BL="└"; BR="┘"; H="─"; V="│"} }
        }
        
        # Top border
        $topLine = $color + $chars.TL + ($chars.H * ($this.Width - 2)) + $chars.TR + [VT]::Reset()
        # For alcar, we'll use direct rendering instead of buffer.SetText
        # $buffer.SetText($this.X, $this.Y, $topLine)
        
        # Title if present
        if ($this.Title) {
            $titleText = " $($this.Title) "
            $titleX = $this.X + 2
            # $buffer.SetText($titleX, $this.Y, $color + $titleText + [VT]::Reset())
        }
        
        # Sides
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            # $buffer.SetText($this.X, $this.Y + $y, $color + $chars.V + [VT]::Reset())
            # $buffer.SetText($this.X + $this.Width - 1, $this.Y + $y, $color + $chars.V + [VT]::Reset())
        }
        
        # Bottom border
        $bottomLine = $color + $chars.BL + ($chars.H * ($this.Width - 2)) + $chars.BR + [VT]::Reset()
        # $buffer.SetText($this.X, $this.Y + $this.Height - 1, $bottomLine)
    }
}


####\Components/TextBox.ps1
# TextBox Component - Single-line text input field

class TextBox : Component {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange = $null
    [scriptblock]$OnSubmit = $null
    
    # Visual properties
    [bool]$ShowBorder = $true
    [string]$PlaceholderColor = ""
    [bool]$ShowCursor = $true
    [bool]$PasswordMode = $false
    [char]$PasswordChar = '•'
    
    # Internal state
    hidden [int]$_scrollOffset = 0
    hidden [string]$_lastText = ""
    
    TextBox([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Height = if ($this.ShowBorder) { 3 } else { 1 }
        $this.Width = 20
    }
    
    [void] SetText([string]$text) {
        $this.Text = $text
        $this.CursorPosition = $text.Length
        $this._scrollOffset = 0
        $this.Invalidate()
    }
    
    [void] Clear() {
        $this.Text = ""
        $this.CursorPosition = 0
        $this._scrollOffset = 0
        $this.Invalidate()
    }
    
    [void] OnRender([object]$buffer) {
        if (-not $this.Visible) { return }
        
        # Determine colors
        $bgColorValue = ""
        if ($this.BackgroundColor) {
            $bgColorValue = $this.BackgroundColor
        } else {
            $bgColorValue = [VT]::RGBBG(30, 30, 35)
        }
        
        $fgColorValue = ""
        if ($this.ForegroundColor) {
            $fgColorValue = $this.ForegroundColor
        } else {
            $fgColorValue = [VT]::RGB(220, 220, 220)
        }
        
        $borderColorValue = ""
        if ($this.BorderColor) {
            $borderColorValue = $this.BorderColor
        } else {
            if ($this.IsFocused) {
                $borderColorValue = [VT]::RGB(100, 200, 255)
            } else {
                $borderColorValue = [VT]::RGB(80, 80, 100)
            }
        }
        
        $placeholderColorValue = ""
        if ($this.PlaceholderColor) {
            $placeholderColorValue = $this.PlaceholderColor
        } else {
            $placeholderColorValue = [VT]::RGB(100, 100, 120)
        }
        
        # Calculate content area
        if ($this.ShowBorder) {
            $contentY = 1
            $contentX = 1
        } else {
            $contentY = 0
            $contentX = 0
        }
        if ($this.ShowBorder) {
            $contentWidth = $this.Width - 2
        } else {
            $contentWidth = $this.Width
        }
        
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $this.DrawText($buffer, 0, $y, $bgColorValue + (" " * $this.Width) + [VT]::Reset())
        }
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $this.DrawBorder($buffer, $borderColorValue)
        }
        
        # Calculate visible text with scroll offset
        $this.UpdateScrollOffset($contentWidth)
        
        # Draw content
        if ($this.Text.Length -eq 0 -and $this.Placeholder) {
            # Show placeholder
            $placeholderText = if ($this.Placeholder.Length -gt $contentWidth) {
                $this.Placeholder.Substring(0, $contentWidth - 3) + "..."
            } else {
                $this.Placeholder
            }
            $this.DrawText($buffer, $contentX, $contentY, 
                          $placeholderColorValue + $placeholderText + [VT]::Reset())
        } else {
            # Show text (with password masking if enabled)
            $displayText = if ($this.PasswordMode) {
                $this.PasswordChar * $this.Text.Length
            } else {
                $this.Text
            }
            
            # Get visible portion
            $visibleText = ""
            if ($displayText.Length -gt $this._scrollOffset) {
                $endIndex = [Math]::Min($displayText.Length, $this._scrollOffset + $contentWidth)
                $visibleText = $displayText.Substring($this._scrollOffset, $endIndex - $this._scrollOffset)
            }
            
            if ($visibleText) {
                $this.DrawText($buffer, $contentX, $contentY, 
                              $fgColorValue + $visibleText + [VT]::Reset())
            }
        }
        
        # Draw cursor if focused
        if ($this.IsFocused -and $this.ShowCursor) {
            $cursorScreenPos = $this.CursorPosition - $this._scrollOffset
            if ($cursorScreenPos -ge 0 -and $cursorScreenPos -lt $contentWidth) {
                $cursorX = $contentX + $cursorScreenPos
                
                # Get character under cursor
                $charUnderCursor = ' '
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $charUnderCursor = if ($this.PasswordMode) { 
                        $this.PasswordChar 
                    } else { 
                        $this.Text[$this.CursorPosition] 
                    }
                }
                
                # Draw inverted cursor
                $this.DrawText($buffer, $cursorX, $contentY,
                              [VT]::RGBBG(220, 220, 220) + [VT]::RGB(30, 30, 35) + 
                              $charUnderCursor + [VT]::Reset())
            }
        }
    }
    
    [void] DrawBorder([object]$buffer, [string]$color) {
        # Top border
        $this.DrawText($buffer, 0, 0, $color + "┌" + ("─" * ($this.Width - 2)) + "┐" + [VT]::Reset())
        
        # Middle with sides
        $this.DrawText($buffer, 0, 1, $color + "│" + [VT]::Reset())
        $this.DrawText($buffer, $this.Width - 1, 1, $color + "│" + [VT]::Reset())
        
        # Bottom border
        $this.DrawText($buffer, 0, 2, $color + "└" + ("─" * ($this.Width - 2)) + "┘" + [VT]::Reset())
    }
    
    [void] UpdateScrollOffset([int]$visibleWidth) {
        # Ensure cursor stays visible
        if ($this.CursorPosition -lt $this._scrollOffset) {
            $this._scrollOffset = $this.CursorPosition
        } elseif ($this.CursorPosition -ge ($this._scrollOffset + $visibleWidth)) {
            $this._scrollOffset = $this.CursorPosition - $visibleWidth + 1
        }
        
        # Ensure scroll offset is valid
        $this._scrollOffset = [Math]::Max(0, $this._scrollOffset)
    }
    
    [void] DrawText([object]$buffer, [int]$x, [int]$y, [string]$text) {
        # Placeholder for alcar buffer integration
        # In production, this would integrate with the buffer system
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsFocused) { return $false }
        
        $handled = $true
        $oldText = $this.Text
        
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.CursorPosition++
                }
            }
            ([ConsoleKey]::Home) {
                $this.CursorPosition = 0
            }
            ([ConsoleKey]::End) {
                $this.CursorPosition = $this.Text.Length
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPosition, 1)
                }
            }
            ([ConsoleKey]::Enter) {
                if ($this.OnSubmit) {
                    & $this.OnSubmit $this $this.Text
                }
            }
            ([ConsoleKey]::Escape) {
                # Could implement cancel behavior
                $handled = $false
            }
            default {
                # Handle character input
                if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                    if ($this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    }
                } else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            # Fire OnChange event if text changed
            if ($oldText -ne $this.Text -and $this.OnChange) {
                & $this.OnChange $this $this.Text
            }
            
            $this.Invalidate()
        }
        
        return $handled
    }
    
    [void] OnFocus() {
        $this.ShowCursor = $true
        $this.Invalidate()
    }
    
    [void] OnBlur() {
        $this.ShowCursor = $false
        $this.Invalidate()
    }
    
    # Static factory method for common configurations
    static [TextBox] CreatePassword([string]$name) {
        $textBox = [TextBox]::new($name)
        $textBox.PasswordMode = $true
        $textBox.Placeholder = "Enter password..."
        return $textBox
    }
    
    static [TextBox] CreateSearch([string]$name) {
        $textBox = [TextBox]::new($name)
        $textBox.Placeholder = "Search..."
        $textBox.ShowBorder = $false
        $textBox.Width = 30
        return $textBox
    }
}


####\Core/Buffer.ps1
# Buffer class for double buffering
class Buffer {
    [object[,]]$Cells  # Array of Cell objects
    [int]$Width
    [int]$Height
    
    Buffer([int]$width, [int]$height) {
        $this.Width = $width
        $this.Height = $height
        $this.InitializeCells()
    }
    
    hidden [void] InitializeCells() {
        # Create a 2D array of objects first, then populate with Cell instances
        $this.Cells = New-Object 'object[,]' $this.Height,$this.Width
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y,$x] = [Cell]::new()
            }
        }
    }
    
    [void] Clear() {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y,$x].Char = ' '
                $this.Cells[$y,$x].FG = '#FFFFFF'
                $this.Cells[$y,$x].BG = '#000000'
            }
        }
    }
    
    [void] SetCell([int]$x, [int]$y, [char]$char, [string]$fg, [string]$bg) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height) {
            $this.Cells[$y,$x].Char = $char
            $this.Cells[$y,$x].FG = $fg
            $this.Cells[$y,$x].BG = $bg
        }
    }
    
    [Cell] GetCell([int]$x, [int]$y) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height) {
            return $this.Cells[$y,$x]
        }
        return [Cell]::new()
    }
    
    [void] WriteString([int]$x, [int]$y, [string]$text, [string]$fg, [string]$bg) {
        for ($i = 0; $i -lt $text.Length; $i++) {
            $this.SetCell($x + $i, $y, $text[$i], $fg, $bg)
        }
    }
}


####\Core/Cell.ps1
# Simple cell class for double buffering
class Cell {
    [char]$Char = ' '
    [string]$FG = '#FFFFFF'
    [string]$BG = '#000000'
    
    Cell() {}
    
    Cell([char]$char, [string]$fg, [string]$bg) {
        $this.Char = $char
        $this.FG = $fg
        $this.BG = $bg
    }
    
    [bool] Equals($other) {
        if ($null -eq $other) { return $false }
        return $this.Char -eq $other.Char -and 
               $this.FG -eq $other.FG -and 
               $this.BG -eq $other.BG
    }
    
    [void] CopyFrom($other) {
        $this.Char = $other.Char
        $this.FG = $other.FG
        $this.BG = $other.BG
    }
}


####\Core/dateparser.ps1
# Smart Date Parser for BOLT-AXIOM

class DateParser {
    static [datetime] Parse([string]$input) {
        if ([string]::IsNullOrWhiteSpace($input)) {
            return [datetime]::MinValue
        }
        
        # Remove any spaces or common separators
        $cleaned = $input -replace '[\s\-/.]', ''
        
        # Check for relative date (+d format)
        if ($cleaned -match '^\+(\d+)$') {
            $days = [int]$matches[1]
            return [datetime]::Today.AddDays($days)
        }
        
        # Check for yyyymmdd format
        if ($cleaned -match '^(\d{4})(\d{2})(\d{2})$') {
            $year = [int]$matches[1]
            $month = [int]$matches[2]
            $day = [int]$matches[3]
            
            try {
                return [datetime]::new($year, $month, $day)
            } catch {
                return [datetime]::MinValue
            }
        }
        
        # Check for shortcuts
        switch ($cleaned.ToLower()) {
            'today' { return [datetime]::Today }
            'tomorrow' { return [datetime]::Today.AddDays(1) }
            'nextweek' { return [datetime]::Today.AddDays(7) }
            'nextmonth' { return [datetime]::Today.AddMonths(1) }
        }
        
        # Try standard parse as fallback
        $result = [datetime]::MinValue
        if ([datetime]::TryParse($input, [ref]$result)) {
            return $result
        }
        
        return [datetime]::MinValue
    }
    
    static [string] Format([datetime]$date) {
        if ($date -eq [datetime]::MinValue) {
            return ""
        }
        
        # Show relative dates for near future
        $daysUntil = ($date.Date - [datetime]::Today).TotalDays
        
        if ($daysUntil -eq 0) {
            return "Today"
        } elseif ($daysUntil -eq 1) {
            return "Tomorrow"
        } elseif ($daysUntil -gt 0 -and $daysUntil -le 7) {
            return "+$([int]$daysUntil)d ($($date.ToString('MMM d')))"
        } elseif ($daysUntil -lt 0) {
            return "$([int]-$daysUntil)d ago ($($date.ToString('MMM d')))"
        } else {
            return $date.ToString('MMM d, yyyy')
        }
    }
}


####\Core/layout.ps1
# Three-Pane Layout Engine with Perfect Alignment

class Pane {
    [int]$X
    [int]$Y
    [int]$Width
    [int]$Height
    [string]$Title
    [bool]$Active
    [System.Collections.ArrayList]$Content
    
    Pane([int]$x, [int]$y, [int]$w, [int]$h, [string]$title) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $w
        $this.Height = $h
        $this.Title = $title
        $this.Active = $false
        $this.Content = [System.Collections.ArrayList]::new()
    }
    
    [string] DrawBorder() {
        $sb = [System.Text.StringBuilder]::new()
        $color = if ($this.Active) { [VT]::BorderActive() } else { [VT]::Border() }
        
        # Top border with title
        [void]$sb.Append([VT]::MoveTo($this.X, $this.Y))
        [void]$sb.Append($color)
        [void]$sb.Append([VT]::TL())
        
        if ($this.Title) {
            $titleText = " $($this.Title) "
            $titleWidth = $titleText.Length
            $borderWidth = $this.Width - 2
            $leftPad = [int](($borderWidth - $titleWidth) / 2)
            
            if ($leftPad -gt 0) {
                [void]$sb.Append([VT]::H() * $leftPad)
            }
            [void]$sb.Append([VT]::TextBright() + $titleText + $color)
            [void]$sb.Append([VT]::H() * ($borderWidth - $leftPad - $titleWidth))
        } else {
            [void]$sb.Append([VT]::H() * ($this.Width - 2))
        }
        
        [void]$sb.Append([VT]::TR())
        
        # Side borders
        for ($i = 1; $i -lt $this.Height - 1; $i++) {
            [void]$sb.Append([VT]::MoveTo($this.X, $this.Y + $i))
            [void]$sb.Append($color + [VT]::V())
            [void]$sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $i))
            [void]$sb.Append([VT]::V())
        }
        
        # Bottom border
        [void]$sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        [void]$sb.Append([VT]::BL())
        [void]$sb.Append([VT]::H() * ($this.Width - 2))
        [void]$sb.Append([VT]::BR())
        
        [void]$sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [string] DrawContent() {
        $sb = [System.Text.StringBuilder]::new()
        $contentY = $this.Y + 1
        $maxLines = $this.Height - 2
        
        for ($i = 0; $i -lt [Math]::Min($this.Content.Count, $maxLines); $i++) {
            [void]$sb.Append([VT]::MoveTo($this.X + 1, $contentY + $i))
            [void]$sb.Append($this.Content[$i])
        }
        
        return $sb.ToString()
    }
}

class ThreePaneLayout {
    [Pane]$LeftPane
    [Pane]$MiddlePane
    [Pane]$RightPane
    [int]$FocusedPane  # 0=left, 1=middle, 2=right
    [int]$Width
    [int]$Height
    
    ThreePaneLayout([int]$width, [int]$height, [int]$leftWidth, [int]$middleWidth) {
        $this.Width = $width
        $this.Height = $height
        $this.FocusedPane = 1  # Start with middle pane focused
        
        # Calculate positions ensuring perfect alignment
        $rightWidth = $width - $leftWidth - $middleWidth
        
        $this.LeftPane = [Pane]::new(1, 1, $leftWidth, $height - 2, "")
        $this.MiddlePane = [Pane]::new($leftWidth, 1, $middleWidth + 1, $height - 2, "")
        $this.RightPane = [Pane]::new($leftWidth + $middleWidth, 1, $rightWidth, $height - 2, "")
        
        # Set initial focus
        $this.MiddlePane.Active = $true
    }
    
    [void] SetFocus([int]$paneIndex) {
        $this.LeftPane.Active = $false
        $this.MiddlePane.Active = $false
        $this.RightPane.Active = $false
        
        switch ($paneIndex) {
            0 { $this.LeftPane.Active = $true }
            1 { $this.MiddlePane.Active = $true }
            2 { $this.RightPane.Active = $true }
        }
        $this.FocusedPane = $paneIndex
    }
    
    [string] DrawStatusBar([string]$content) {
        $sb = [System.Text.StringBuilder]::new()
        [void]$sb.Append([VT]::MoveTo(1, $this.Height - 1))
        [void]$sb.Append([VT]::Border())
        
        # Draw connected status bar
        [void]$sb.Append([VT]::L())
        [void]$sb.Append([VT]::H() * ($this.LeftPane.Width - 2))
        [void]$sb.Append([VT]::B())
        [void]$sb.Append([VT]::H() * ($this.MiddlePane.Width - 1))
        [void]$sb.Append([VT]::B())
        [void]$sb.Append([VT]::H() * ($this.RightPane.Width - 2))
        [void]$sb.Append([VT]::R())
        
        # Status content
        [void]$sb.Append([VT]::MoveTo(3, $this.Height - 1))
        [void]$sb.Append([VT]::TextDim() + $content)
        [void]$sb.Append([VT]::Reset())
        
        return $sb.ToString()
    }
    
    [string] Render() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Position at home (no clear)
        [void]$sb.Append([VT]::Home())
        
        # Draw panes
        [void]$sb.Append($this.LeftPane.DrawBorder())
        [void]$sb.Append($this.MiddlePane.DrawBorder())
        [void]$sb.Append($this.RightPane.DrawBorder())
        
        # Draw content
        [void]$sb.Append($this.LeftPane.DrawContent())
        [void]$sb.Append($this.MiddlePane.DrawContent())
        [void]$sb.Append($this.RightPane.DrawContent())
        
        return $sb.ToString()
    }
}


####\Core/layout2.ps1
# Improved Three-Pane Layout Engine with Perfect Alignment

class Pane {
    [int]$X
    [int]$Y
    [int]$Width
    [int]$Height
    [string]$Title
    [bool]$Active
    [bool]$Interactive = $true  # Can this pane receive focus?
    [System.Collections.ArrayList]$Content
    
    Pane([int]$x, [int]$y, [int]$w, [int]$h, [string]$title) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $w
        $this.Height = $h
        $this.Title = $title
        $this.Active = $false
        $this.Content = [System.Collections.ArrayList]::new()
    }
}

class ThreePaneLayout {
    [Pane]$LeftPane
    [Pane]$MiddlePane
    [Pane]$RightPane
    [int]$FocusedPane  # 0=left, 1=middle, 2=right
    [int]$Width
    [int]$Height
    
    ThreePaneLayout([int]$width, [int]$height, [int]$leftWidth, [int]$rightWidth) {
        $this.Width = $width
        $this.Height = $height
        $this.FocusedPane = 1  # Start with middle pane focused
        
        # Calculate middle width from remaining space
        $middleWidth = $width - $leftWidth - $rightWidth - 2  # -2 for borders
        
        # Create panes with exact positioning
        $this.LeftPane = [Pane]::new(1, 1, $leftWidth, $height - 3, "FILTERS")
        $this.MiddlePane = [Pane]::new($leftWidth + 1, 1, $middleWidth, $height - 3, "TASKS")
        $this.RightPane = [Pane]::new($leftWidth + $middleWidth + 1, 1, $rightWidth, $height - 3, "DETAIL")
        
        # Right pane is view-only
        $this.RightPane.Interactive = $false
        
        # Set initial focus
        $this.MiddlePane.Active = $true
    }
    
    [void] SetFocus([int]$paneIndex) {
        $this.LeftPane.Active = $false
        $this.MiddlePane.Active = $false
        $this.RightPane.Active = $false
        
        switch ($paneIndex) {
            0 { $this.LeftPane.Active = $true }
            1 { $this.MiddlePane.Active = $true }
            2 { $this.RightPane.Active = $true }
        }
        $this.FocusedPane = $paneIndex
    }
    
    [void] FocusNext() {
        # Only cycle between interactive panes
        if ($this.FocusedPane -eq 0) {
            $this.SetFocus(1)  # Left -> Middle
        } else {
            $this.SetFocus(0)  # Middle -> Left
        }
    }
    
    [void] FocusPrev() {
        # Same as next for 2 panes
        $this.FocusNext()
    }
    
    [string] Render() {
        $sb = [System.Text.StringBuilder]::new(8192)
        
        # Don't clear - parent screen handles that
        # Just draw the layout
        
        # Draw main frame
        [void]$sb.Append([VT]::MoveTo(1, 1))
        [void]$sb.Append([VT]::Border())
        [void]$sb.Append([VT]::TL())
        [void]$sb.Append([VT]::H() * ($this.Width - 2))
        [void]$sb.Append([VT]::TR())
        
        # Draw sides
        for ($y = 2; $y -lt $this.Height - 2; $y++) {
            [void]$sb.Append([VT]::MoveTo(1, $y))
            [void]$sb.Append([VT]::V())
            [void]$sb.Append([VT]::MoveTo($this.Width, $y))
            [void]$sb.Append([VT]::V())
        }
        
        # Draw bottom (leave space for status)
        [void]$sb.Append([VT]::MoveTo(1, $this.Height - 2))
        [void]$sb.Append([VT]::BL())
        [void]$sb.Append([VT]::H() * ($this.Width - 2))
        [void]$sb.Append([VT]::BR())
        
        # Draw pane dividers with proper connections
        # Left divider
        [void]$sb.Append([VT]::MoveTo($this.LeftPane.Width + 1, 1))
        [void]$sb.Append([VT]::T())  # Top connection
        
        for ($y = 2; $y -lt $this.Height - 2; $y++) {
            [void]$sb.Append([VT]::MoveTo($this.LeftPane.Width + 1, $y))
            [void]$sb.Append([VT]::V())
        }
        
        [void]$sb.Append([VT]::MoveTo($this.LeftPane.Width + 1, $this.Height - 2))
        [void]$sb.Append([VT]::B())  # Bottom connection
        
        # Right divider
        $rightDividerX = $this.LeftPane.Width + $this.MiddlePane.Width + 1
        [void]$sb.Append([VT]::MoveTo($rightDividerX, 1))
        [void]$sb.Append([VT]::T())  # Top connection
        
        for ($y = 2; $y -lt $this.Height - 2; $y++) {
            [void]$sb.Append([VT]::MoveTo($rightDividerX, $y))
            [void]$sb.Append([VT]::V())
        }
        
        [void]$sb.Append([VT]::MoveTo($rightDividerX, $this.Height - 2))
        [void]$sb.Append([VT]::B())  # Bottom connection
        
        # Draw pane titles
        $this.DrawPaneTitle($sb, $this.LeftPane)
        $this.DrawPaneTitle($sb, $this.MiddlePane)
        $this.DrawPaneTitle($sb, $this.RightPane)
        
        # Draw content
        $this.DrawPaneContent($sb, $this.LeftPane)
        $this.DrawPaneContent($sb, $this.MiddlePane)
        $this.DrawPaneContent($sb, $this.RightPane)
        
        [void]$sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] DrawPaneTitle([System.Text.StringBuilder]$sb, [Pane]$pane) {
        if (-not $pane.Title) { return }
        
        $color = if ($pane.Active) { [VT]::BorderActive() } else { [VT]::Border() }
        $titleText = " $($pane.Title) "
        $titleStart = $pane.X + [int](($pane.Width - $titleText.Length) / 2)
        
        [void]$sb.Append([VT]::MoveTo($titleStart, 1))
        [void]$sb.Append($color + [VT]::TextBright() + $titleText)
    }
    
    [void] DrawPaneContent([System.Text.StringBuilder]$sb, [Pane]$pane) {
        $contentY = 2
        $maxLines = $pane.Height - 1
        
        for ($i = 0; $i -lt [Math]::Min($pane.Content.Count, $maxLines); $i++) {
            [void]$sb.Append([VT]::MoveTo($pane.X + 1, $contentY + $i))
            [void]$sb.Append($pane.Content[$i])
        }
    }
    
    [string] DrawStatusBar([string]$content) {
        $sb = [System.Text.StringBuilder]::new()
        
        # Draw status inside the frame
        [void]$sb.Append([VT]::MoveTo(3, $this.Height - 1))
        [void]$sb.Append([VT]::TextDim() + $content)
        [void]$sb.Append([VT]::Reset())
        
        return $sb.ToString()
    }
}


####\Core/NavigationStandard.ps1
# Navigation Standard - Consistent arrow key behavior across alcar

enum NavigationMode {
    SinglePane     # Single list/content area
    MultiPane      # Multiple panes with Tab switching
    FormEditing    # Form with editable fields
    TextEditing    # Text editor mode
}

class NavigationStandard {
    static [hashtable] GetStandardBindings([NavigationMode]$mode, [Screen]$screen) {
        $bindings = @{}
        
        switch ($mode) {
            ([NavigationMode]::SinglePane) {
                # Single pane navigation (lists, menus)
                $bindings[[ConsoleKey]::UpArrow] = { $screen.MoveUp() }
                $bindings[[ConsoleKey]::DownArrow] = { $screen.MoveDown() }
                $bindings[[ConsoleKey]::LeftArrow] = { $screen.GoBack() }  # Exit/Back
                $bindings[[ConsoleKey]::RightArrow] = { $screen.SelectItem() }  # Enter/Select
                $bindings[[ConsoleKey]::Enter] = { $screen.SelectItem() }
                $bindings[[ConsoleKey]::Escape] = { $screen.GoBack() }
                $bindings[[ConsoleKey]::Backspace] = { $screen.GoBack() }
            }
            
            ([NavigationMode]::MultiPane) {
                # Multi-pane navigation (use Tab for pane switching)
                $bindings[[ConsoleKey]::UpArrow] = { $screen.MoveUp() }
                $bindings[[ConsoleKey]::DownArrow] = { $screen.MoveDown() }
                $bindings[[ConsoleKey]::Tab] = { $screen.NextPane() }
                $bindings[[ConsoleKey]::Enter] = { $screen.SelectItem() }
                $bindings[[ConsoleKey]::Escape] = { $screen.GoBack() }
                
                # Left/Right behavior depends on context
                $bindings[[ConsoleKey]::LeftArrow] = { 
                    if ($screen.CanMoveToPreviousPane()) {
                        $screen.PreviousPane()
                    } else {
                        $screen.GoBack()
                    }
                }
                $bindings[[ConsoleKey]::RightArrow] = { 
                    if ($screen.CanMoveToNextPane()) {
                        $screen.NextPane()
                    } else {
                        $screen.SelectItem()
                    }
                }
            }
            
            ([NavigationMode]::FormEditing) {
                # Form editing (settings, dialogs)
                $bindings[[ConsoleKey]::UpArrow] = { $screen.PreviousField() }
                $bindings[[ConsoleKey]::DownArrow] = { $screen.NextField() }
                $bindings[[ConsoleKey]::Tab] = { $screen.NextField() }
                $bindings[[ConsoleKey]::Enter] = { $screen.EditField() }
                $bindings[[ConsoleKey]::Spacebar] = { $screen.ToggleField() }
                $bindings[[ConsoleKey]::Escape] = { $screen.Cancel() }
                
                # Left/Right for value changes
                $bindings[[ConsoleKey]::LeftArrow] = { $screen.DecrementValue() }
                $bindings[[ConsoleKey]::RightArrow] = { $screen.IncrementValue() }
            }
            
            ([NavigationMode]::TextEditing) {
                # Text editing mode
                $bindings[[ConsoleKey]::UpArrow] = { $screen.MoveCursorUp() }
                $bindings[[ConsoleKey]::DownArrow] = { $screen.MoveCursorDown() }
                $bindings[[ConsoleKey]::LeftArrow] = { $screen.MoveCursorLeft() }
                $bindings[[ConsoleKey]::RightArrow] = { $screen.MoveCursorRight() }
                $bindings[[ConsoleKey]::Home] = { $screen.MoveCursorHome() }
                $bindings[[ConsoleKey]::End] = { $screen.MoveCursorEnd() }
                $bindings[[ConsoleKey]::Escape] = { $screen.ExitEditMode() }
            }
        }
        
        # Common bindings for all modes
        $bindings[[ConsoleKey]::PageUp] = { $screen.PageUp() }
        $bindings[[ConsoleKey]::PageDown] = { $screen.PageDown() }
        $bindings[[ConsoleKey]::Home] = { $screen.GoToTop() }
        $bindings[[ConsoleKey]::End] = { $screen.GoToBottom() }
        
        return $bindings
    }
    
    # Helper to apply standard navigation to a screen
    static [void] ApplyTo([Screen]$screen, [NavigationMode]$mode) {
        $bindings = [NavigationStandard]::GetStandardBindings($mode, $screen)
        
        foreach ($key in $bindings.Keys) {
            $screen.KeyBindings[$key] = $bindings[$key]
        }
    }
}

# Base class extensions for standard navigation methods
class NavigationScreen : Screen {
    [NavigationMode]$NavigationMode = [NavigationMode]::SinglePane
    [int]$CurrentPane = 0
    [int]$PaneCount = 1
    
    NavigationScreen() {
        # Apply standard navigation on construction
        [NavigationStandard]::ApplyTo($this, $this.NavigationMode)
    }
    
    # Default implementations (override as needed)
    [void] MoveUp() {
        # Override in derived classes
    }
    
    [void] MoveDown() {
        # Override in derived classes
    }
    
    [void] SelectItem() {
        # Override in derived classes
    }
    
    [void] GoBack() {
        $this.Active = $false
    }
    
    [void] NextPane() {
        if ($this.PaneCount -gt 1) {
            $this.CurrentPane = ($this.CurrentPane + 1) % $this.PaneCount
            $this.RequestRender()
        }
    }
    
    [void] PreviousPane() {
        if ($this.PaneCount -gt 1) {
            $this.CurrentPane = ($this.CurrentPane - 1)
            if ($this.CurrentPane -lt 0) {
                $this.CurrentPane = $this.PaneCount - 1
            }
            $this.RequestRender()
        }
    }
    
    [bool] CanMoveToNextPane() {
        return $this.PaneCount -gt 1 -and $this.CurrentPane -lt ($this.PaneCount - 1)
    }
    
    [bool] CanMoveToPreviousPane() {
        return $this.PaneCount -gt 1 -and $this.CurrentPane -gt 0
    }
    
    [void] PageUp() {
        # Override in derived classes
    }
    
    [void] PageDown() {
        # Override in derived classes
    }
    
    [void] GoToTop() {
        # Override in derived classes
    }
    
    [void] GoToBottom() {
        # Override in derived classes
    }
}

# Form navigation extensions
class FormScreen : NavigationScreen {
    [int]$CurrentField = 0
    [int]$FieldCount = 0
    
    FormScreen() {
        $this.NavigationMode = [NavigationMode]::FormEditing
        [NavigationStandard]::ApplyTo($this, $this.NavigationMode)
    }
    
    [void] NextField() {
        if ($this.CurrentField -lt $this.FieldCount - 1) {
            $this.CurrentField++
            $this.RequestRender()
        }
    }
    
    [void] PreviousField() {
        if ($this.CurrentField -gt 0) {
            $this.CurrentField--
            $this.RequestRender()
        }
    }
    
    [void] EditField() {
        # Override to implement field editing
    }
    
    [void] ToggleField() {
        # Override to implement toggle behavior
    }
    
    [void] IncrementValue() {
        # Override to implement value increment
    }
    
    [void] DecrementValue() {
        # Override to implement value decrement
    }
    
    [void] Cancel() {
        $this.GoBack()
    }
}


####\Core/RenderOptimizer.ps1
# Rendering Optimizer - Reduces flicker and improves performance

class RenderOptimizer {
    static [string]$LastFrame = ""
    static [bool]$UseAlternateBuffer = $true
    
    # Enter alternate screen buffer
    static [string] EnterAltBuffer() {
        if ([RenderOptimizer]::UseAlternateBuffer) {
            return "`e[?1049h"  # Save screen and use alternate buffer
        }
        return ""
    }
    
    # Exit alternate screen buffer
    static [string] ExitAltBuffer() {
        if ([RenderOptimizer]::UseAlternateBuffer) {
            return "`e[?1049l"  # Restore original screen
        }
        return ""
    }
    
    # Optimized render - only update changed parts
    static [string] OptimizedRender([string]$newFrame) {
        # For now, just return the new frame
        # Could implement diff algorithm later
        [RenderOptimizer]::LastFrame = $newFrame
        return $newFrame
    }
    
    # Clear with optimization
    static [string] SmartClear() {
        # Use home position only, no clear
        return "`e[H"
    }
    
    # Double buffer write
    static [void] WriteDoubleBuffered([string]$content) {
        # Build complete frame in memory
        $frame = [VT]::Hide()  # Hide cursor during update
        $frame += [VT]::Home()  # Go to top
        $frame += $content
        $frame += [VT]::Hide()  # Keep cursor hidden
        
        # Write entire frame at once
        [Console]::Write($frame)
    }
}


####\Core/ScreenManager.ps1
# Screen Manager - Handles navigation between screens

class ScreenManager {
    [System.Collections.Stack]$ScreenStack
    [Screen]$CurrentScreen
    [bool]$Running = $true
    
    ScreenManager() {
        $this.ScreenStack = [System.Collections.Stack]::new()
    }
    
    # Push a new screen onto the stack
    [void] Push([Screen]$screen) {
        if ($this.CurrentScreen) {
            $this.CurrentScreen.OnDeactivate()
            $this.ScreenStack.Push($this.CurrentScreen)
        }
        
        $this.CurrentScreen = $screen
        $this.CurrentScreen.OnActivate()
        $this.CurrentScreen.NeedsRender = $true
        
        # Don't render here - let the main loop handle it
    }
    
    # Pop current screen and return to previous
    [void] Pop() {
        if ($this.ScreenStack.Count -gt 0) {
            if ($this.CurrentScreen) {
                $this.CurrentScreen.OnDeactivate()
            }
            
            $this.CurrentScreen = $this.ScreenStack.Pop()
            $this.CurrentScreen.OnActivate()
            $this.CurrentScreen.NeedsRender = $true
        } else {
            # No more screens - exit
            $this.Running = $false
        }
    }
    
    # Replace current screen without pushing to stack
    [void] Replace([Screen]$screen) {
        if ($this.CurrentScreen) {
            $this.CurrentScreen.OnDeactivate()
        }
        
        $this.CurrentScreen = $screen
        $this.CurrentScreen.OnActivate()
        $this.CurrentScreen.NeedsRender = $true
    }
    
    # Clear all screens and set a new root
    [void] SetRoot([Screen]$screen) {
        $this.ScreenStack.Clear()
        
        if ($this.CurrentScreen) {
            $this.CurrentScreen.OnDeactivate()
        }
        
        $this.CurrentScreen = $screen
        $this.CurrentScreen.OnActivate()
        $this.CurrentScreen.NeedsRender = $true
        
        # Don't render here - let Run() handle initial render
    }
    
    # Main run loop
    [void] Run() {
        # Setup console with alternate screen buffer
        try {
            [Console]::CursorVisible = $false
        } catch {
            # Ignore cursor visibility errors
        }
        
        # Enter alternate screen buffer, hide cursor
        [Console]::Write("`e[?1049h`e[?25l")
        
        try {
            # Initial render
            if ($this.CurrentScreen) {
                $this.CurrentScreen.Render()
            }
            
            while ($this.Running -and $this.CurrentScreen) {
                # Check if screen is still active
                if (-not $this.CurrentScreen.Active) {
                    $this.Pop()
                    if ($this.CurrentScreen) {
                        $this.CurrentScreen.NeedsRender = $true
                    }
                    continue
                }
                
                # Handle input
                if ([Console]::KeyAvailable) {
                    $key = [Console]::ReadKey($true)
                    
                    # Global shortcuts
                    if ($key.Modifiers -eq [ConsoleModifiers]::Control -and $key.Key -eq [ConsoleKey]::Q) {
                        # Ctrl+Q - Quick exit
                        $this.Running = $false
                        continue
                    }
                    
                    # Let screen handle input
                    $this.CurrentScreen.HandleInput($key)
                }
                
                # Only render if needed
                if ($this.CurrentScreen.NeedsRender) {
                    $this.CurrentScreen.Render()
                }
                
                Start-Sleep -Milliseconds 50  # Increased to reduce flicker
            }
        } finally {
            # Cleanup - exit alternate buffer and restore cursor
            [Console]::Write("`e[?1049l`e[?25h")
            try {
                [Console]::CursorVisible = $true
            } catch {
                # Ignore cursor visibility errors
            }
        }
    }
    
    # Get screen depth
    [int] GetDepth() {
        return $this.ScreenStack.Count + 1
    }
    
    # Check if we can go back
    [bool] CanGoBack() {
        return $this.ScreenStack.Count -gt 0
    }
}

# Global screen manager instance
$global:ScreenManager = $null


####\Core/vt100.ps1
# VT100/ANSI Core for BOLT-AXIOM with True Color Support

class VT {
    # Cursor movement
    static [string] MoveTo([int]$x, [int]$y) { return "`e[$($y);$($x)H" }
    static [string] SavePos() { return "`e[s" }
    static [string] RestorePos() { return "`e[u" }
    static [string] Hide() { return "`e[?25l" }
    static [string] Show() { return "`e[?25h" }
    
    # Screen control
    static [string] Clear() { return "`e[H`e[2J" }  # Clear screen and home
    static [string] ClearLine() { return "`e[K" }
    static [string] Home() { return "`e[H" }      # Just home position
    static [string] ClearToEnd() { return "`e[J" }  # Clear from cursor to end
    
    # Basic styles
    static [string] Reset() { return "`e[0m" }
    static [string] Bold() { return "`e[1m" }
    static [string] Dim() { return "`e[2m" }
    
    # 24-bit True Color
    static [string] RGB([int]$r, [int]$g, [int]$b) { 
        return "`e[38;2;$r;$g;$($b)m" 
    }
    static [string] RGBBG([int]$r, [int]$g, [int]$b) { 
        return "`e[48;2;$r;$g;$($b)m" 
    }
    
    # Wireframe color palette (true color)
    static [string] Border() { return [VT]::RGB(0, 255, 255) }      # Cyan
    static [string] BorderDim() { return [VT]::RGB(0, 128, 128) }   # Dark cyan
    static [string] BorderActive() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Text() { return [VT]::RGB(192, 192, 192) }      # Light gray
    static [string] TextDim() { return [VT]::RGB(128, 128, 128) }   # Gray
    static [string] TextBright() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Accent() { return [VT]::RGB(0, 255, 0) }        # Green
    static [string] Warning() { return [VT]::RGB(255, 255, 0) }     # Yellow
    static [string] Error() { return [VT]::RGB(255, 0, 0) }         # Red
    static [string] Selected() { return [VT]::RGB(255, 255, 255) + [VT]::RGBBG(0, 64, 128) } # White on dark blue
    
    # Box drawing - single lines for speed
    static [string] TL() { return "┌" }     # Top left
    static [string] TR() { return "┐" }     # Top right
    static [string] BL() { return "└" }     # Bottom left
    static [string] BR() { return "┘" }     # Bottom right
    static [string] H() { return "─" }      # Horizontal
    static [string] V() { return "│" }      # Vertical
    static [string] Cross() { return "┼" }  # Cross
    static [string] T() { return "┬" }      # T down
    static [string] B() { return "┴" }      # T up
    static [string] L() { return "├" }      # T right
    static [string] R() { return "┤" }      # T left
    
    # Double lines for emphasis
    static [string] DTL() { return "╔" }
    static [string] DTR() { return "╗" }
    static [string] DBL() { return "╚" }
    static [string] DBR() { return "╝" }
    static [string] DH() { return "═" }
    static [string] DV() { return "║" }
}

# Layout measurement helpers
class Measure {
    static [int] TextWidth([string]$text) {
        # Remove ANSI sequences for accurate measurement
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        return $clean.Length
    }
    
    static [string] Truncate([string]$text, [int]$maxWidth) {
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        if ($clean.Length -le $maxWidth) { return $text }
        return $clean.Substring(0, $maxWidth - 3) + "..."
    }
    
    static [string] Pad([string]$text, [int]$width, [string]$align = "Left") {
        $textWidth = [Measure]::TextWidth($text)
        if ($textWidth -ge $width) { return [Measure]::Truncate($text, $width) }
        
        $padding = $width - $textWidth
        switch ($align) {
            "Left" { return $text + (" " * $padding) }
            "Right" { return (" " * $padding) + $text }
            "Center" { 
                $left = [int]($padding / 2)
                $right = $padding - $left
                return (" " * $left) + $text + (" " * $right)
            }
        }
        return $text
    }
}


####\FastComponents/FastButton.ps1
# FastButton - Zero-overhead button implementation

class FastButton : FastComponentBase {
    # Minimal state
    [string]$Text = "Button"
    [bool]$IsFocused = $false
    [bool]$IsPressed = $false
    [bool]$IsDefault = $false
    
    # Pre-computed render strings
    hidden [string]$_normalRender
    hidden [string]$_focusedRender
    hidden [string]$_pressedRender
    hidden [bool]$_needsRebuild = $true
    
    FastButton([int]$x, [int]$y, [string]$text) {
        $this.X = $x
        $this.Y = $y
        $this.Text = $text
        $this.Width = $text.Length + 4
        $this.Height = 1
        $this.BuildRenderStrings()
    }
    
    # Pre-build all render states
    [void] BuildRenderStrings() {
        $mt = $this.MT($this.X, $this.Y)
        
        # Normal state
        $this._normalRender = $mt + "`e[38;2;200;200;200m" + 
                             "[" + $this.Text + "]" + 
                             [FastComponentBase]::VTCache.Reset
        
        # Focused state
        $this._focusedRender = $mt + "`e[48;2;50;50;70m`e[38;2;255;255;255m" +
                              "[" + $this.Text + "]" +
                              [FastComponentBase]::VTCache.Reset
        
        # Pressed state
        $this._pressedRender = $mt + "`e[48;2;60;60;80m`e[38;2;255;255;255m" +
                              "[" + $this.Text + "]" +
                              [FastComponentBase]::VTCache.Reset
        
        $this._needsRebuild = $false
    }
    
    # Ultra-fast render - just return pre-built string
    [string] Render() {
        if (-not $this.Visible) { return "" }
        
        if ($this._needsRebuild) {
            $this.BuildRenderStrings()
        }
        
        if ($this.IsPressed) {
            return $this._pressedRender
        } elseif ($this.IsFocused) {
            return $this._focusedRender
        } else {
            return $this._normalRender
        }
    }
    
    # Direct input - Enter/Space to activate
    [bool] Input([ConsoleKey]$key) {
        if ($key -eq [ConsoleKey]::Enter -or $key -eq [ConsoleKey]::Spacebar) {
            $this.IsPressed = $true
            return $true
        }
        return $false
    }
    
    # Fast click check
    [bool] WasClicked() {
        if ($this.IsPressed) {
            $this.IsPressed = $false
            return $true
        }
        return $false
    }
    
    # Update position (triggers rebuild)
    [void] SetPosition([int]$x, [int]$y) {
        if ($this.X -ne $x -or $this.Y -ne $y) {
            $this.X = $x
            $this.Y = $y
            $this._needsRebuild = $true
        }
    }
}


####\FastComponents/FastCheckBox.ps1
# FastCheckBox - Minimal overhead checkbox

class FastCheckBox : FastComponentBase {
    # State
    [string]$Text = ""
    [bool]$Checked = $false
    [bool]$IsFocused = $false
    
    # Pre-computed
    hidden [string]$_checkedStr
    hidden [string]$_uncheckedStr
    
    FastCheckBox([int]$x, [int]$y, [string]$text) {
        $this.X = $x
        $this.Y = $y
        $this.Text = $text
        $this.Width = $text.Length + 4  # [x] + space + text
        $this.Height = 1
        $this.PrecomputeStrings()
    }
    
    [void] PrecomputeStrings() {
        $normalColor = "`e[38;2;200;200;200m"
        $focusColor = "`e[38;2;255;255;255m"
        $checkColor = "`e[38;2;100;255;100m"
        
        # Pre-build the checked/unchecked strings
        $this._checkedStr = "[" + $checkColor + "✓" + $normalColor + "] " + $this.Text
        $this._uncheckedStr = "[ ] " + $this.Text
    }
    
    # Direct render
    [string] Render() {
        if (-not $this.Visible) { return "" }
        
        $out = $this.MT($this.X, $this.Y)
        
        if ($this.IsFocused) {
            $out += "`e[38;2;255;255;255m"
        } else {
            $out += "`e[38;2;200;200;200m"
        }
        
        if ($this.Checked) {
            $out += $this._checkedStr
        } else {
            $out += $this._uncheckedStr
        }
        
        $out += [FastComponentBase]::VTCache.Reset
        return $out
    }
    
    # Direct input - space to toggle
    [bool] Input([ConsoleKey]$key) {
        if ($key -eq [ConsoleKey]::Spacebar) {
            $this.Checked = -not $this.Checked
            return $true
        }
        return $false
    }
    
    # Fast toggle
    [void] Toggle() {
        $this.Checked = -not $this.Checked
    }
}


####\FastComponents/FastComponentBase.ps1
# FastComponent Base - Minimal overhead, maximum speed
# Components compile to direct VT sequences, no virtual calls

class FastComponentBase {
    # Minimal state - only what's absolutely needed
    [int]$X
    [int]$Y
    [int]$Width
    [int]$Height
    [bool]$Visible = $true
    
    # Pre-compiled VT sequences for common operations
    static [hashtable]$VTCache = @{
        Reset = [VT]::Reset()
        MoveTo = @{}  # Cached MoveTo sequences
        Colors = @{}  # Cached color sequences
    }
    
    # Static initializer to pre-cache common sequences
    static FastComponentBase() {
        # Pre-cache common movements
        for ($row = 1; $row -le 50; $row++) {
            for ($col = 1; $col -le 100; $col++) {
                [FastComponentBase]::VTCache.MoveTo["$col,$row"] = "`e[$row;${col}H"
            }
        }
        
        # Pre-cache common colors
        [FastComponentBase]::VTCache.Colors['Selected'] = "`e[48;2;40;40;80m`e[38;2;255;255;255m"
        [FastComponentBase]::VTCache.Colors['Normal'] = "`e[48;2;30;30;35m`e[38;2;200;200;200m"
        [FastComponentBase]::VTCache.Colors['Focus'] = "`e[38;2;100;200;255m"
    }
    
    # Direct render - returns VT string, no method calls
    [string] Render() {
        # Override in derived classes
        return ""
    }
    
    # Direct input - returns true if handled, minimal checks
    [bool] Input([ConsoleKey]$key) {
        # Override in derived classes
        return $false
    }
    
    # Helper to get cached MoveTo sequence
    [string] MT([int]$xPos, [int]$yPos) {
        $key = "$xPos,$yPos"
        $cached = [FastComponentBase]::VTCache.MoveTo[$key]
        if ($cached) { return $cached }
        # Cache miss - generate and cache
        $seq = "`e[$yPos;${xPos}H"
        [FastComponentBase]::VTCache.MoveTo[$key] = $seq
        return $seq
    }
}


####\FastComponents/FastFileListBox.ps1
# FastFileListBox - Ultra-fast file browser list component
# Optimized for handling thousands of files with zero overhead

class FastFileListBox : FastComponentBase {
    # Core state
    [array]$Items = @()           # Pre-formatted display strings
    [array]$FileObjects = @()     # Actual FileInfo/DirectoryInfo objects
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$HasBorder = $true
    [bool]$IsFocused = $false
    
    # File browser specific
    [int]$LastSelectedIndex = -1  # For change detection
    [bool]$ShowIcons = $true
    [bool]$ShowSize = $true
    [bool]$ShowDate = $false
    
    # Pre-computed values
    hidden [int]$_visibleItems
    hidden [string]$_borderTop
    hidden [string]$_borderBottom
    hidden [hashtable]$_iconCache = @{
        ".ps1" = "🔷"
        ".txt" = "📄"
        ".md" = "📝"
        ".json" = "📋"
        ".xml" = "📋"
        ".jpg" = "🖼️"
        ".png" = "🖼️"
        ".mp3" = "🎵"
        ".mp4" = "🎬"
        ".zip" = "📦"
        ".exe" = "⚙️"
        "_default" = "📄"
        "_folder" = "📁"
    }
    
    FastFileListBox([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.PrecomputeBorders()
        if ($this.HasBorder) {
            $this._visibleItems = $height - 2
        } else {
            $this._visibleItems = $height
        }
    }
    
    [void] PrecomputeBorders() {
        $this._borderTop = "┌" + ("─" * ($this.Width - 2)) + "┐"
        $this._borderBottom = "└" + ("─" * ($this.Width - 2)) + "┘"
    }
    
    # Set files with pre-formatting
    [void] SetFiles([array]$fileObjects) {
        $this.FileObjects = $fileObjects
        $this.Items = @()
        
        foreach ($obj in $fileObjects) {
            $this.Items += $this.FormatFileItem($obj)
        }
        
        $this.SelectedIndex = if ($fileObjects.Count -gt 0) { 0 } else { -1 }
        $this.ScrollOffset = 0
        $this.LastSelectedIndex = -1
    }
    
    # Format file item once
    [string] FormatFileItem([object]$item) {
        if ($null -eq $item) { return "" }
        
        $icon = ""
        $name = ""
        $size = ""
        
        if ($item -is [System.IO.DirectoryInfo]) {
            $icon = $this._iconCache["_folder"]
            $name = $item.Name
            if ($name -eq "..") {
                $icon = "⬆️"
            }
        }
        elseif ($item -is [System.IO.FileInfo]) {
            $ext = $item.Extension.ToLower()
            $icon = if ($this._iconCache.ContainsKey($ext)) { 
                $this._iconCache[$ext] 
            } else { 
                $this._iconCache["_default"] 
            }
            $name = $item.Name
            
            if ($this.ShowSize) {
                $size = $this.FormatFileSize($item.Length)
            }
        }
        else {
            return $item.ToString()
        }
        
        # Build formatted string
        $result = ""
        if ($this.ShowIcons) {
            $result = "$icon "
        }
        
        # Truncate name if needed
        $maxNameLen = $this.Width - 4
        if ($this.ShowIcons) { $maxNameLen -= 2 }
        if ($this.ShowSize) { $maxNameLen -= 10 }
        
        if ($name.Length -gt $maxNameLen) {
            $name = $name.Substring(0, $maxNameLen - 3) + "..."
        }
        
        $result += $name
        
        if ($this.ShowSize -and $size) {
            $padding = $this.Width - $result.Length - $size.Length - 4
            if ($padding -gt 0) {
                $result += " " * $padding + $size
            }
        }
        
        return $result
    }
    
    [string] FormatFileSize([long]$bytes) {
        if ($bytes -lt 1024) { return "$bytes B" }
        if ($bytes -lt 1048576) { return "$([Math]::Round($bytes / 1024, 1)) KB" }
        if ($bytes -lt 1073741824) { return "$([Math]::Round($bytes / 1048576, 1)) MB" }
        return "$([Math]::Round($bytes / 1073741824, 1)) GB"
    }
    
    # Get selected file object
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.FileObjects.Count) {
            return $this.FileObjects[$this.SelectedIndex]
        }
        return $null
    }
    
    # Check if selection changed
    [bool] HasSelectionChanged() {
        if ($this.SelectedIndex -ne $this.LastSelectedIndex) {
            $this.LastSelectedIndex = $this.SelectedIndex
            return $true
        }
        return $false
    }
    
    # Direct render
    [string] Render() {
        if (-not $this.Visible -or $this.Items.Count -eq 0) { return "" }
        
        $out = [System.Text.StringBuilder]::new(4096)
        
        # Border color
        $borderColor = if ($this.IsFocused) { 
            [FastComponentBase]::VTCache.Colors['Focus'] 
        } else { 
            "`e[38;2;80;80;100m" 
        }
        
        # Draw top border
        if ($this.HasBorder) {
            [void]$out.Append($this.MT($this.X, $this.Y))
            [void]$out.Append($borderColor)
            [void]$out.Append($this._borderTop)
            [void]$out.Append([FastComponentBase]::VTCache.Reset)
        }
        
        # Ensure selected item is visible
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $this._visibleItems) {
            $this.ScrollOffset = $this.SelectedIndex - $this._visibleItems + 1
        }
        
        # Draw items
        if ($this.HasBorder) {
            $contentX = $this.X + 1
            $contentY = $this.Y + 1
            $contentWidth = $this.Width - 2
        } else {
            $contentX = $this.X
            $contentY = $this.Y
            $contentWidth = $this.Width
        }
        
        $endIndex = [Math]::Min($this.ScrollOffset + $this._visibleItems, $this.Items.Count)
        
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $y = $contentY + ($i - $this.ScrollOffset)
            
            # Draw item background
            [void]$out.Append($this.MT($this.X, $y))
            
            if ($this.HasBorder) {
                [void]$out.Append($borderColor)
                [void]$out.Append("│")
                [void]$out.Append([FastComponentBase]::VTCache.Reset)
            }
            
            [void]$out.Append($this.MT($contentX, $y))
            
            if ($i -eq $this.SelectedIndex) {
                [void]$out.Append([FastComponentBase]::VTCache.Colors['Selected'])
            } else {
                [void]$out.Append([FastComponentBase]::VTCache.Colors['Normal'])
            }
            
            # Pad and truncate item
            $item = $this.Items[$i]
            if ($item.Length -gt $contentWidth) {
                $item = $item.Substring(0, $contentWidth)
            } else {
                $item = $item.PadRight($contentWidth)
            }
            
            [void]$out.Append($item)
            [void]$out.Append([FastComponentBase]::VTCache.Reset)
            
            if ($this.HasBorder) {
                [void]$out.Append($this.MT($this.X + $this.Width - 1, $y))
                [void]$out.Append($borderColor)
                [void]$out.Append("│")
                [void]$out.Append([FastComponentBase]::VTCache.Reset)
            }
        }
        
        # Fill empty space
        for ($i = $endIndex - $this.ScrollOffset; $i -lt $this._visibleItems; $i++) {
            $y = $contentY + $i
            [void]$out.Append($this.MT($this.X, $y))
            
            if ($this.HasBorder) {
                [void]$out.Append($borderColor)
                [void]$out.Append("│")
                [void]$out.Append(" " * ($this.Width - 2))
                [void]$out.Append("│")
            } else {
                [void]$out.Append(" " * $this.Width)
            }
            
            [void]$out.Append([FastComponentBase]::VTCache.Reset)
        }
        
        # Draw bottom border
        if ($this.HasBorder) {
            [void]$out.Append($this.MT($this.X, $this.Y + $this.Height - 1))
            [void]$out.Append($borderColor)
            [void]$out.Append($this._borderBottom)
            [void]$out.Append([FastComponentBase]::VTCache.Reset)
        }
        
        return $out.ToString()
    }
    
    # Handle input
    [bool] Input([ConsoleKey]$key) {
        if ($this.Items.Count -eq 0) { return $false }
        
        switch ($key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    return $true
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    return $true
                }
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.ScrollOffset = 0
                return $true
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                return $true
            }
            ([ConsoleKey]::PageUp) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this._visibleItems)
                return $true
            }
            ([ConsoleKey]::PageDown) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this._visibleItems)
                return $true
            }
        }
        
        return $false
    }
}


####\FastComponents/FastListBox.ps1
# FastListBox - Zero-overhead listbox implementation

class FastListBox : FastComponentBase {
    # Minimal state
    [array]$Items = @()
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$HasBorder = $true
    [bool]$IsFocused = $false
    
    # Pre-computed values to avoid recalculation
    hidden [int]$_visibleItems
    hidden [string]$_borderTop
    hidden [string]$_borderBottom
    hidden [string]$_borderSide
    
    FastListBox([int]$x, [int]$y, [int]$width, [int]$height) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.PrecomputeBorders()
        if ($this.HasBorder) {
            $this._visibleItems = $height - 2
        } else {
            $this._visibleItems = $height
        }
    }
    
    [void] PrecomputeBorders() {
        # Pre-build border strings
        $this._borderTop = "┌" + ("─" * ($this.Width - 2)) + "┐"
        $this._borderBottom = "└" + ("─" * ($this.Width - 2)) + "┘"
        $this._borderSide = "│" + (" " * ($this.Width - 2)) + "│"
    }
    
    # Direct render - no method calls, just string building
    [string] Render() {
        if (-not $this.Visible -or $this.Items.Count -eq 0) { return "" }
        
        $out = [System.Text.StringBuilder]::new(2048)  # Pre-allocate
        
        # Colors based on focus
        $borderColor = if ($this.IsFocused) { 
            [FastComponentBase]::VTCache.Colors['Focus'] 
        } else { 
            "`e[38;2;80;80;100m" 
        }
        
        # Draw border if enabled
        if ($this.HasBorder) {
            # Top border
            [void]$out.Append($this.MT($this.X, $this.Y))
            [void]$out.Append($borderColor)
            [void]$out.Append($this._borderTop)
            
            # Side borders (will be overwritten by content)
            $endY = $this.Y + $this.Height - 1
            for ($y = $this.Y + 1; $y -lt $endY; $y++) {
                [void]$out.Append($this.MT($this.X, $y))
                [void]$out.Append($borderColor)
                [void]$out.Append($this._borderSide)
            }
            
            # Bottom border
            [void]$out.Append($this.MT($this.X, $endY))
            [void]$out.Append($borderColor)
            [void]$out.Append($this._borderBottom)
        }
        
        # Ensure selected item is visible (inline scroll calculation)
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $this._visibleItems) {
            $this.ScrollOffset = $this.SelectedIndex - $this._visibleItems + 1
        }
        
        # Draw items - direct loop, no method calls
        if ($this.HasBorder) {
            $contentX = $this.X + 1
            $contentY = $this.Y + 1
            $contentWidth = $this.Width - 2
        } else {
            $contentX = $this.X
            $contentY = $this.Y
            $contentWidth = $this.Width
        }
        
        $endIndex = [Math]::Min($this.ScrollOffset + $this._visibleItems, $this.Items.Count)
        
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $y = $contentY + ($i - $this.ScrollOffset)
            
            # Move to position
            [void]$out.Append($this.MT($contentX, $y))
            
            # Apply selection highlight
            if ($i -eq $this.SelectedIndex) {
                [void]$out.Append([FastComponentBase]::VTCache.Colors['Selected'])
            } else {
                [void]$out.Append([FastComponentBase]::VTCache.Colors['Normal'])
            }
            
            # Render item text (truncate if needed)
            $text = $this.Items[$i].ToString()
            if ($text.Length -gt $contentWidth) {
                $text = $text.Substring(0, $contentWidth - 3) + "..."
            } else {
                $text = $text.PadRight($contentWidth)
            }
            [void]$out.Append($text)
        }
        
        # Reset at end
        [void]$out.Append([FastComponentBase]::VTCache.Reset)
        
        return $out.ToString()
    }
    
    # Direct input handling - minimal checks
    [bool] Input([ConsoleKey]$key) {
        switch ($key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    return $true
                }
                return $false
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    return $true
                }
                return $false
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.ScrollOffset = 0
                return $true
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                return $true
            }
            ([ConsoleKey]::PageUp) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this._visibleItems)
                return $true
            }
            ([ConsoleKey]::PageDown) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this._visibleItems)
                return $true
            }
        }
        return $false
    }
    
    # Fast item access
    [object] GetSelected() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
}


####\FastComponents/FastMenu.ps1
# FastMenu - High-performance menu rendering

class FastMenu : FastComponentBase {
    # State
    [array]$Items = @()
    [int]$SelectedIndex = 0
    [bool]$IsFocused = $false
    
    # Pre-computed
    hidden [hashtable]$_itemCache = @{}
    hidden [int]$_maxWidth = 0
    
    FastMenu([int]$x, [int]$y, [array]$items) {
        $this.X = $x
        $this.Y = $y
        $this.Items = $items
        $this.Height = $items.Count
        $this.CalculateWidth()
        $this.PrecomputeItems()
    }
    
    [void] CalculateWidth() {
        $this._maxWidth = 0
        foreach ($item in $this.Items) {
            $len = $item.ToString().Length
            if ($len -gt $this._maxWidth) {
                $this._maxWidth = $len
            }
        }
        $this.Width = $this._maxWidth + 4  # Padding
    }
    
    [void] PrecomputeItems() {
        # Pre-render each item in normal state
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $text = $this.Items[$i].ToString().PadRight($this._maxWidth)
            $this._itemCache[$i] = "  " + $text + "  "
        }
    }
    
    # Direct render - optimized for vertical menus
    [string] Render() {
        if (-not $this.Visible -or $this.Items.Count -eq 0) { return "" }
        
        $out = [System.Text.StringBuilder]::new(1024)
        
        # Render each item
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            [void]$out.Append($this.MT($this.X, $this.Y + $i))
            
            if ($i -eq $this.SelectedIndex -and $this.IsFocused) {
                # Selected item - full highlight
                [void]$out.Append("`e[48;2;40;40;80m`e[38;2;255;255;255m")
                [void]$out.Append("▶ ")
                [void]$out.Append($this.Items[$i].ToString().PadRight($this._maxWidth))
                [void]$out.Append("  ")
            } else {
                # Normal item
                [void]$out.Append("`e[38;2;200;200;200m")
                [void]$out.Append($this._itemCache[$i])
            }
        }
        
        [void]$out.Append([FastComponentBase]::VTCache.Reset)
        return $out.ToString()
    }
    
    # Direct input
    [bool] Input([ConsoleKey]$key) {
        switch ($key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    return $true
                }
                # Wrap to bottom
                $this.SelectedIndex = $this.Items.Count - 1
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    return $true
                }
                # Wrap to top
                $this.SelectedIndex = 0
                return $true
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                return $true
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                return $true
            }
        }
        return $false
    }
    
    # Quick access by number key
    [bool] InputNumber([int]$num) {
        if ($num -gt 0 -and $num -le $this.Items.Count) {
            $this.SelectedIndex = $num - 1
            return $true
        }
        return $false
    }
    
    # Get selected item
    [object] GetSelected() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
}


####\FastComponents/FastPanel.ps1
# FastPanel - High-performance panel component with minimal overhead

class FastPanel : FastComponentBase {
    [string]$Title = ""
    [bool]$HasBorder = $true
    [string]$BorderStyle = "Single"  # Single, Double, Rounded
    [bool]$IsFocused = $false
    [System.Collections.ArrayList]$Children
    
    # Pre-cached border characters
    static [hashtable]$BorderChars = @{
        Single = @{TL="┌"; TR="┐"; BL="└"; BR="┘"; H="─"; V="│"}
        Double = @{TL="╔"; TR="╗"; BL="╚"; BR="╝"; H="═"; V="║"}
        Rounded = @{TL="╭"; TR="╮"; BL="╰"; BR="╯"; H="─"; V="│"}
    }
    
    FastPanel([string]$name) {
        $this.Children = [System.Collections.ArrayList]::new()
    }
    
    [void] AddChild([object]$child) {
        $this.Children.Add($child) | Out-Null
    }
    
    [string] Render() {
        if (-not $this.Visible) { return "" }
        
        $sb = [System.Text.StringBuilder]::new(2048)
        
        # Render border if enabled
        if ($this.HasBorder) {
            $chars = [FastPanel]::BorderChars[$this.BorderStyle]
            $color = if ($this.IsFocused) { 
                [FastComponentBase]::VTCache.Colors['Focus'] 
            } else { 
                [FastComponentBase]::VTCache.Colors['Normal'] 
            }
            
            # Top border
            [void]$sb.Append($this.MT($this.X, $this.Y))
            [void]$sb.Append($color)
            [void]$sb.Append($chars.TL)
            
            # Add title if present
            if ($this.Title) {
                [void]$sb.Append($chars.H)
                [void]$sb.Append(" $($this.Title) ")
                $titleLen = $this.Title.Length + 2
                [void]$sb.Append($chars.H * ($this.Width - $titleLen - 3))
            } else {
                [void]$sb.Append($chars.H * ($this.Width - 2))
            }
            
            [void]$sb.Append($chars.TR)
            [void]$sb.Append([FastComponentBase]::VTCache.Reset)
            
            # Sides
            for ($y = 1; $y -lt $this.Height - 1; $y++) {
                # Left side
                [void]$sb.Append($this.MT($this.X, $this.Y + $y))
                [void]$sb.Append($color)
                [void]$sb.Append($chars.V)
                [void]$sb.Append([FastComponentBase]::VTCache.Reset)
                
                # Right side
                [void]$sb.Append($this.MT($this.X + $this.Width - 1, $this.Y + $y))
                [void]$sb.Append($color)
                [void]$sb.Append($chars.V)
                [void]$sb.Append([FastComponentBase]::VTCache.Reset)
            }
            
            # Bottom border
            [void]$sb.Append($this.MT($this.X, $this.Y + $this.Height - 1))
            [void]$sb.Append($color)
            [void]$sb.Append($chars.BL)
            [void]$sb.Append($chars.H * ($this.Width - 2))
            [void]$sb.Append($chars.BR)
            [void]$sb.Append([FastComponentBase]::VTCache.Reset)
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                # Render child content (adjust for border if present)
                if ($child -is [FastComponentBase]) {
                    [void]$sb.Append($child.Render())
                }
            }
        }
        
        return $sb.ToString()
    }
    
    [bool] Input([ConsoleKey]$key) {
        # Pass input to focused child if any
        foreach ($child in $this.Children) {
            if ($child -is [FastComponentBase] -and $child.Input($key)) {
                return $true
            }
        }
        return $false
    }
}


####\FastComponents/FastTextBox.ps1
# FastTextBox - Minimal overhead text input

class FastTextBox : FastComponentBase {
    # State
    [string]$Text = ""
    [int]$CursorPos = 0
    [int]$ScrollOffset = 0
    [bool]$IsFocused = $false
    [int]$MaxLength = 100
    
    # Pre-computed
    hidden [string]$_border
    hidden [int]$_contentWidth
    
    FastTextBox([int]$x, [int]$y, [int]$width) {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = 3  # Fixed height for bordered input
        $this._contentWidth = $width - 2
        $this._border = "┌" + ("─" * ($width - 2)) + "┐"
    }
    
    # Direct render
    [string] Render() {
        if (-not $this.Visible) { return "" }
        
        $out = [System.Text.StringBuilder]::new(512)
        
        # Border color
        $borderColor = if ($this.IsFocused) {
            "`e[38;2;100;200;255m"
        } else {
            "`e[38;2;80;80;100m"
        }
        
        # Top border
        [void]$out.Append($this.MT($this.X, $this.Y))
        [void]$out.Append($borderColor)
        [void]$out.Append($this._border)
        
        # Content line
        [void]$out.Append($this.MT($this.X, $this.Y + 1))
        [void]$out.Append($borderColor)
        [void]$out.Append("│")
        
        # Calculate visible text (scroll if needed)
        if ($this.CursorPos -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.CursorPos
        } elseif ($this.CursorPos -ge $this.ScrollOffset + $this._contentWidth) {
            $this.ScrollOffset = $this.CursorPos - $this._contentWidth + 1
        }
        
        # Text content
        [void]$out.Append($this.MT($this.X + 1, $this.Y + 1))
        [void]$out.Append("`e[38;2;220;220;220m")
        
        $visibleText = ""
        if ($this.Text.Length -gt $this.ScrollOffset) {
            $len = [Math]::Min($this._contentWidth, $this.Text.Length - $this.ScrollOffset)
            $visibleText = $this.Text.Substring($this.ScrollOffset, $len)
        }
        [void]$out.Append($visibleText.PadRight($this._contentWidth))
        
        # Right border
        [void]$out.Append($this.MT($this.X + $this.Width - 1, $this.Y + 1))
        [void]$out.Append($borderColor)
        [void]$out.Append("│")
        
        # Bottom border
        [void]$out.Append($this.MT($this.X, $this.Y + 2))
        [void]$out.Append($borderColor)
        [void]$out.Append("└" + ("─" * ($this.Width - 2)) + "┘")
        
        # Cursor (if focused)
        if ($this.IsFocused) {
            $cursorScreenX = $this.X + 1 + ($this.CursorPos - $this.ScrollOffset)
            if ($cursorScreenX -ge $this.X + 1 -and $cursorScreenX -lt $this.X + $this.Width - 1) {
                [void]$out.Append($this.MT($cursorScreenX, $this.Y + 1))
                [void]$out.Append("`e[7m")  # Reverse video for cursor
                $charUnder = if ($this.CursorPos -lt $this.Text.Length) { 
                    $this.Text[$this.CursorPos] 
                } else { ' ' }
                [void]$out.Append($charUnder)
                [void]$out.Append("`e[27m")  # Reset reverse
            }
        }
        
        [void]$out.Append([FastComponentBase]::VTCache.Reset)
        return $out.ToString()
    }
    
    # Direct input
    [bool] Input([ConsoleKey]$key) {
        switch ($key) {
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorPos -gt 0) {
                    $this.CursorPos--
                    return $true
                }
                return $false
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.CursorPos -lt $this.Text.Length) {
                    $this.CursorPos++
                    return $true
                }
                return $false
            }
            ([ConsoleKey]::Home) {
                $this.CursorPos = 0
                $this.ScrollOffset = 0
                return $true
            }
            ([ConsoleKey]::End) {
                $this.CursorPos = $this.Text.Length
                return $true
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorPos -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPos - 1, 1)
                    $this.CursorPos--
                    return $true
                }
                return $false
            }
            ([ConsoleKey]::Delete) {
                if ($this.CursorPos -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPos, 1)
                    return $true
                }
                return $false
            }
        }
        return $false
    }
    
    # Fast character input (separate method for speed)
    [bool] InputChar([char]$char) {
        if ($this.Text.Length -lt $this.MaxLength) {
            $this.Text = $this.Text.Insert($this.CursorPos, $char)
            $this.CursorPos++
            return $true
        }
        return $false
    }
}


####\Models/Project.ps1
# Project Model - Simple project definition

class Project {
    [string]$Id
    [string]$Name
    [string]$Description
    [DateTime]$CreatedAt
    
    Project([string]$name) {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.Name = $name
        $this.Description = ""
        $this.CreatedAt = [DateTime]::Now
    }
}


####\Models/task.ps1
# Task model keeping Axiom's data structure

class Task {
    [string]$Id
    [string]$Title
    [string]$Description
    [string]$Status  # Pending, InProgress, Completed, Cancelled
    [string]$Priority  # Low, Medium, High
    [int]$Progress  # 0-100
    [string]$ProjectId
    [datetime]$CreatedDate
    [datetime]$ModifiedDate
    [datetime]$DueDate
    [string]$AssignedTo
    [System.Collections.ArrayList]$Tags
    [string]$ParentId  # For subtasks
    [System.Collections.ArrayList]$SubtaskIds  # Children
    [bool]$IsExpanded = $true  # For tree view
    [int]$Level = 0  # Nesting level for display
    
    Task() {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.CreatedDate = [datetime]::Now
        $this.ModifiedDate = [datetime]::Now
        $this.Status = "Pending"
        $this.Priority = "Medium"
        $this.Progress = 0
        $this.Tags = [System.Collections.ArrayList]::new()
        $this.SubtaskIds = [System.Collections.ArrayList]::new()
    }
    
    Task([string]$title) {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.Title = $title
        $this.CreatedDate = [datetime]::Now
        $this.ModifiedDate = [datetime]::Now
        $this.Status = "Pending"
        $this.Priority = "Medium"
        $this.Progress = 0
        $this.Tags = [System.Collections.ArrayList]::new()
        $this.SubtaskIds = [System.Collections.ArrayList]::new()
    }
    
    [string] GetStatusSymbol() {
        switch ($this.Status) {
            "Pending" { return "○" }
            "InProgress" { return "◐" }
            "Completed" { return "●" }
            "Cancelled" { return "✗" }
            default { return "?" }
        }
        return "?"
    }
    
    [string] GetStatusColor() {
        switch ($this.Status) {
            "Pending" { return [VT]::TextDim() }
            "InProgress" { return [VT]::Warning() }
            "Completed" { return [VT]::Accent() }
            "Cancelled" { return [VT]::Error() }
            default { return [VT]::Text() }
        }
        return [VT]::Text()
    }
    
    [string] GetPrioritySymbol() {
        switch ($this.Priority) {
            "Low" { return "↓" }
            "Medium" { return "→" }
            "High" { return "↑" }
            default { return "?" }
        }
        return "?"
    }
    
    [string] GetPriorityColor() {
        switch ($this.Priority) {
            "Low" { return [VT]::TextDim() }
            "Medium" { return [VT]::Text() }
            "High" { return [VT]::Error() }
            default { return [VT]::Text() }
        }
        return [VT]::Text()
    }
    
    [bool] IsOverdue() {
        return $this.DueDate -and $this.DueDate -lt [datetime]::Now -and $this.Status -ne "Completed"
    }
    
    [void] Update() {
        $this.ModifiedDate = [datetime]::Now
    }
}


####\Screens/DashboardScreen.ps1
# Dashboard Screen

class DashboardScreen : Screen {
    [hashtable]$Stats
    
    DashboardScreen() {
        $this.Title = "DASHBOARD"
        $this.Initialize()
    }
    
    [void] Initialize() {
        # Calculate stats
        $this.Stats = @{
            TotalTasks = 35
            CompletedTasks = 18
            InProgressTasks = 12
            PendingTasks = 5
            OverdueTasks = 3
            TodayTasks = 4
            WeekTasks = 9
        }
        
        # Key bindings
        $this.InitializeKeyBindings()
        
        # Status bar
        $this.UpdateStatusBar()
    }
    
    [void] InitializeKeyBindings() {
        $this.BindKey([ConsoleKey]::Escape, { $this.Active = $false })
        $this.BindKey([ConsoleKey]::Backspace, { $this.Active = $false })
        $this.BindKey('q', { $this.Active = $false })
        $this.BindKey('r', { $this.Refresh() })
    }
    
    [void] UpdateStatusBar() {
        $this.StatusBarItems.Clear()
        $this.AddStatusItem('r', 'refresh')
        $this.AddStatusItem('Esc', 'back')
    }
    
    [string] RenderContent() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        $output = ""
        
        # Clear background by drawing spaces everywhere
        for ($y = 1; $y -le $height; $y++) {
            $output += [VT]::MoveTo(1, $y)
            $output += " " * $width
        }
        
        # Draw border
        $output += $this.DrawBorder()
        
        # Title
        $titleText = "═══ DASHBOARD ═══"
        $titleX = [int](($width - $titleText.Length) / 2)
        $output += [VT]::MoveTo($titleX, 1)
        $output += [VT]::BorderActive() + $titleText + [VT]::Reset()
        
        # Layout widgets
        $widgetY = 4
        $widgetHeight = 8
        $widgetGap = 2
        
        # Task Summary Widget (left)
        $output += $this.DrawTaskSummary(3, $widgetY, 40, $widgetHeight)
        
        # Progress Widget (right)
        $output += $this.DrawProgressWidget(45, $widgetY, 40, $widgetHeight)
        
        # Timeline Widget (bottom left)
        $output += $this.DrawTimelineWidget(3, $widgetY + $widgetHeight + $widgetGap, 40, $widgetHeight)
        
        # Activity Widget (bottom right)
        $output += $this.DrawActivityWidget(45, $widgetY + $widgetHeight + $widgetGap, 40, $widgetHeight)
        
        return $output
    }
    
    [string] DrawBorder() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        $output = ""
        
        # Top border
        $output += [VT]::MoveTo(1, 1)
        $output += [VT]::Border()
        $output += [VT]::TL() + [VT]::H() * ($width - 2) + [VT]::TR()
        
        # Sides
        for ($y = 2; $y -lt $height - 1; $y++) {
            $output += [VT]::MoveTo(1, $y) + [VT]::V()
            $output += [VT]::MoveTo($width, $y) + [VT]::V()
        }
        
        # Bottom border
        $output += [VT]::MoveTo(1, $height - 1)
        $output += [VT]::BL() + [VT]::H() * ($width - 2) + [VT]::BR()
        
        return $output
    }
    
    [string] DrawWidget([int]$x, [int]$y, [int]$w, [int]$h, [string]$title) {
        $output = ""
        
        # Widget border
        $output += [VT]::MoveTo($x, $y)
        $output += [VT]::Border()
        $output += "┌" + ("─" * ($w - 2)) + "┐"
        
        for ($i = 1; $i -lt $h - 1; $i++) {
            $output += [VT]::MoveTo($x, $y + $i)
            $output += "│" + (" " * ($w - 2)) + "│"
        }
        
        $output += [VT]::MoveTo($x, $y + $h - 1)
        $output += "└" + ("─" * ($w - 2)) + "┘"
        
        # Title
        $titleX = $x + 2
        $output += [VT]::MoveTo($titleX, $y)
        $output += [VT]::TextBright() + " $title " + [VT]::Reset()
        
        return $output
    }
    
    [string] DrawTaskSummary([int]$x, [int]$y, [int]$w, [int]$h) {
        $output = $this.DrawWidget($x, $y, $w, $h, "TASK SUMMARY")
        
        # Content
        $contentY = $y + 2
        
        $output += [VT]::MoveTo($x + 3, $contentY++)
        $output += [VT]::Text() + "Total Tasks: " + [VT]::TextBright() + $this.Stats.TotalTasks
        
        $output += [VT]::MoveTo($x + 3, $contentY++)
        $output += [VT]::Accent() + "● Completed: " + $this.Stats.CompletedTasks
        
        $output += [VT]::MoveTo($x + 3, $contentY++)
        $output += [VT]::Warning() + "◐ In Progress: " + $this.Stats.InProgressTasks
        
        $output += [VT]::MoveTo($x + 3, $contentY++)
        $output += [VT]::TextDim() + "○ Pending: " + $this.Stats.PendingTasks
        
        $output += [VT]::MoveTo($x + 3, $contentY++)
        $output += [VT]::Error() + "✗ Overdue: " + $this.Stats.OverdueTasks
        
        return $output
    }
    
    [string] DrawProgressWidget([int]$x, [int]$y, [int]$w, [int]$h) {
        $output = $this.DrawWidget($x, $y, $w, $h, "COMPLETION")
        
        # Calculate percentage
        $percent = [int](($this.Stats.CompletedTasks / $this.Stats.TotalTasks) * 100)
        
        # Big percentage display
        $percentText = "$percent%"
        $textX = $x + [int](($w - $percentText.Length - 2) / 2)
        $output += [VT]::MoveTo($textX, $y + 3)
        $output += [VT]::Accent() + [VT]::TextBright()
        
        # Large text using block characters
        $output += "█▀▀▀█ █▀▀▀█ ▐▌  ▐▌"
        $output += [VT]::MoveTo($textX, $y + 4)
        $output += "█▄▄▄█ ▄▄▄▄█ ▐▌▄▄██"
        
        # Progress bar
        $barWidth = $w - 6
        $filled = [int](($percent / 100) * $barWidth)
        $output += [VT]::MoveTo($x + 3, $y + 6)
        $output += [VT]::Accent() + ("█" * $filled) + [VT]::TextDim() + ("░" * ($barWidth - $filled))
        
        return $output
    }
    
    [string] DrawTimelineWidget([int]$x, [int]$y, [int]$w, [int]$h) {
        $output = $this.DrawWidget($x, $y, $w, $h, "TIMELINE")
        
        $contentY = $y + 2
        
        $output += [VT]::MoveTo($x + 3, $contentY++)
        $output += [VT]::Warning() + "Today: " + [VT]::TextBright() + $this.Stats.TodayTasks + " tasks"
        
        $output += [VT]::MoveTo($x + 3, $contentY++)
        $output += [VT]::Text() + "This Week: " + [VT]::TextBright() + $this.Stats.WeekTasks + " tasks"
        
        $output += [VT]::MoveTo($x + 3, $contentY++)
        $output += [VT]::TextDim() + "Next Week: " + [VT]::Text() + "12 tasks"
        
        # Mini calendar view
        $output += [VT]::MoveTo($x + 3, $contentY + 1)
        $output += [VT]::TextDim() + "M  T  W  T  F  S  S"
        
        $output += [VT]::MoveTo($x + 3, $contentY + 2)
        $days = "2  3  " + [VT]::Warning() + "4" + [VT]::TextDim() + "  5  6  7  8"
        $output += $days
        
        return $output
    }
    
    [string] DrawActivityWidget([int]$x, [int]$y, [int]$w, [int]$h) {
        $output = $this.DrawWidget($x, $y, $w, $h, "RECENT ACTIVITY")
        
        $activities = @(
            @{Time="2m ago"; Action="Completed"; Task="Fix login bug"},
            @{Time="15m ago"; Action="Started"; Task="Review PR #234"},
            @{Time="1h ago"; Action="Created"; Task="Update docs"},
            @{Time="3h ago"; Action="Updated"; Task="Deploy staging"}
        )
        
        $contentY = $y + 2
        foreach ($activity in $activities) {
            if ($contentY -ge $y + $h - 1) { break }
            
            $output += [VT]::MoveTo($x + 3, $contentY++)
            $output += [VT]::TextDim() + $activity.Time + " " + 
                      [VT]::Text() + $activity.Action + " " +
                      [VT]::TextBright() + $activity.Task.Substring(0, [Math]::Min($activity.Task.Length, 15))
        }
        
        return $output
    }
    
    [void] Refresh() {
        # Simulate refresh
        $this.Stats.TotalTasks = Get-Random -Minimum 30 -Maximum 40
        $this.Stats.CompletedTasks = Get-Random -Minimum 15 -Maximum 25
        $this.Initialize()
    }
}


####\Screens/DeleteConfirmDialog.ps1
# Delete Confirmation Dialog

class DeleteConfirmDialog : Dialog {
    [string]$ItemName
    [bool]$Confirmed = $false
    
    DeleteConfirmDialog([Screen]$parent, [string]$itemName) : base($parent) {
        $this.Title = "DELETE CONFIRMATION"
        $this.ItemName = $itemName
        $this.Width = 50
        $this.Height = 7
        
        $this.InitializeKeyBindings()
    }
    
    [void] InitializeKeyBindings() {
        $this.BindKey('y', {
            $this.Confirmed = $true
            $this.Active = $false
            # Handle deletion after dialog closes
            if ($this.TaskToDelete -and $this.ParentTaskScreen) {
                $this.ParentTaskScreen.Tasks.Remove($this.TaskToDelete)
                $this.ParentTaskScreen.ApplyFilter()
                if ($this.ParentTaskScreen.TaskIndex -ge $this.ParentTaskScreen.FilteredTasks.Count -and $this.ParentTaskScreen.TaskIndex -gt 0) {
                    $this.ParentTaskScreen.TaskIndex--
                }
            }
        })
        
        $this.BindKey('n', {
            $this.Confirmed = $false
            $this.Active = $false
        })
        
        $this.BindKey([ConsoleKey]::Escape, {
            $this.Confirmed = $false
            $this.Active = $false
        })
        
        $this.BindKey([ConsoleKey]::LeftArrow, {
            $this.Confirmed = $false
            $this.Active = $false
        })
    }
    
    [string] RenderContent() {
        # Draw dialog box with red background
        $output = ""
        
        # Draw red box
        $output += [VT]::RGBBG(255, 0, 0) + [VT]::TextBright()
        
        # Top border
        $output += [VT]::MoveTo($this.X, $this.Y)
        $output += [VT]::TL() + [VT]::H() * ($this.Width - 2) + [VT]::TR()
        
        # Title line
        $output += [VT]::MoveTo($this.X, $this.Y + 1)
        $output += [VT]::V() + " DELETE CONFIRMATION".PadRight($this.Width - 2) + [VT]::V()
        
        # Item name
        $itemText = "Delete: " + $this.ItemName
        if ($itemText.Length -gt $this.Width - 4) {
            $itemText = $itemText.Substring(0, $this.Width - 7) + "..."
        }
        $output += [VT]::MoveTo($this.X, $this.Y + 2)
        $output += [VT]::V() + " $itemText".PadRight($this.Width - 2) + [VT]::V()
        
        # Warning
        $output += [VT]::MoveTo($this.X, $this.Y + 3)
        $output += [VT]::V() + " This cannot be undone!".PadRight($this.Width - 2) + [VT]::V()
        
        # Empty line
        $output += [VT]::MoveTo($this.X, $this.Y + 4)
        $output += [VT]::V() + " ".PadRight($this.Width - 2) + [VT]::V()
        
        # Prompt
        $output += [VT]::MoveTo($this.X, $this.Y + 5)
        $output += [VT]::V() + " [Y]es, delete   [N]o, cancel".PadRight($this.Width - 2) + [VT]::V()
        
        # Bottom border
        $output += [VT]::MoveTo($this.X, $this.Y + 6)
        $output += [VT]::BL() + [VT]::H() * ($this.Width - 2) + [VT]::BR()
        
        $output += [VT]::Reset()
        
        return $output
    }
}


####\Screens/EditDialog.ps1
# Edit Dialog - Full task editor

class EditDialog : Dialog {
    [Task]$Task
    [bool]$IsNew
    [int]$FieldIndex = 0
    [System.Collections.ArrayList]$Fields
    [bool]$EditMode = $false
    [string]$EditBuffer = ""
    [bool]$Saved = $false
    
    EditDialog([Screen]$parent, [Task]$task, [bool]$isNew) : base($parent) {
        $this.Task = $task
        $this.IsNew = $isNew
        $this.Title = if ($isNew) { "NEW TASK" } else { "EDIT TASK" }
        $this.Width = 70
        $this.Height = 20
        
        $this.InitializeFields()
        $this.InitializeKeyBindings()
        
        # Auto-focus title field for new tasks
        if ($this.IsNew) {
            $this.EditMode = $true
            $this.EditBuffer = $this.Task.Title
        }
    }
    
    [void] InitializeFields() {
        $this.Fields = [System.Collections.ArrayList]@(
            @{Name="Title"; Value=$this.Task.Title; Type="Text"},
            @{Name="Description"; Value=$this.Task.Description; Type="Multiline"},
            @{Name="Status"; Value=$this.Task.Status; Type="Choice"; Options=@("Pending", "InProgress", "Completed", "Cancelled")},
            @{Name="Priority"; Value=$this.Task.Priority; Type="Choice"; Options=@("Low", "Medium", "High")},
            @{Name="Progress"; Value=$this.Task.Progress; Type="Number"; Min=0; Max=100},
            @{Name="Due Date"; Value=$this.Task.DueDate; Type="Date"}
        )
    }
    
    [void] InitializeKeyBindings() {
        # Navigation
        $this.BindKey([ConsoleKey]::UpArrow, {
            if (-not $this.EditMode -and $this.FieldIndex -gt 0) {
                $this.FieldIndex--
            }
        })
        
        $this.BindKey([ConsoleKey]::DownArrow, {
            if (-not $this.EditMode -and $this.FieldIndex -lt $this.Fields.Count - 1) {
                $this.FieldIndex++
            }
        })
        
        # Edit mode
        $this.BindKey([ConsoleKey]::Enter, {
            if ($this.EditMode) {
                $this.SaveField()
                $this.EditMode = $false
            } else {
                $this.StartEdit()
                $this.EditMode = $true
            }
        })
        
        # Add subtask option for new tasks
        $this.BindKey('S', {
            if ($this.IsNew -and -not $this.EditMode) {
                # Save current task first
                $this.SaveTask()
                
                # Add to parent's task list if new
                if ($this.ParentTaskScreen -and $this.NewTask) {
                    $this.ParentTaskScreen.Tasks.Add($this.NewTask) | Out-Null
                }
                
                # Create subtask
                $subtask = New-Object -TypeName "Task" -ArgumentList "New Subtask"
                $subtask.ParentId = $this.Task.Id
                $this.Task.SubtaskIds.Add($subtask.Id) | Out-Null
                
                # Open new dialog for subtask
                $subtaskDialog = New-Object -TypeName "EditDialog" -ArgumentList $this.ParentScreen, $subtask, $true
                $subtaskDialog | Add-Member -NotePropertyName ParentTaskScreen -NotePropertyValue $this.ParentTaskScreen
                $subtaskDialog | Add-Member -NotePropertyName NewTask -NotePropertyValue $subtask
                $subtaskDialog | Add-Member -NotePropertyName ParentTask -NotePropertyValue $this.Task
                
                # Close this dialog and open subtask dialog
                $this.Saved = $true
                $this.Active = $false
                
                if ($this.ParentTaskScreen) {
                    $this.ParentTaskScreen.ApplyFilter()
                }
                
                $global:ScreenManager.Push($subtaskDialog)
            }
        })
        
        # Save/Cancel
        $this.BindKey([ConsoleKey]::F2, {
            $this.SaveTask()
            $this.Saved = $true
            $this.Active = $false
            
            # If this is a new task, add it to the parent's task list
            if ($this.IsNew -and $this.ParentTaskScreen -and $this.NewTask) {
                $this.ParentTaskScreen.Tasks.Add($this.NewTask) | Out-Null
            }
            
            # Refresh parent after save
            if ($this.ParentTaskScreen) {
                $this.ParentTaskScreen.ApplyFilter()
            }
        })
        
        $this.BindKey([ConsoleKey]::Escape, {
            if ($this.EditMode) {
                $this.EditMode = $false
                $this.EditBuffer = ""
            } else {
                $this.Active = $false
            }
        })
        
        # Choice field navigation or cancel
        $this.BindKey([ConsoleKey]::LeftArrow, {
            if (-not $this.EditMode) {
                $field = $this.Fields[$this.FieldIndex]
                if ($field.Type -eq "Choice") {
                    $this.ChangeChoice(-1)
                } else {
                    # Cancel dialog for non-choice fields
                    $this.Active = $false
                }
            }
        })
        
        $this.BindKey([ConsoleKey]::RightArrow, {
            if (-not $this.EditMode) {
                $this.ChangeChoice(1)
            }
        })
    }
    
    [string] RenderContent() {
        # Draw dialog
        $output = $this.DrawBox()
        
        # Draw fields
        $fieldY = $this.Y + 2
        $fieldCount = $this.Fields.Count
        for ($i = 0; $i -lt $fieldCount; $i++) {
            $y = $fieldY + ($i * 2)
            $field = $this.Fields[$i]
            $isSelected = $i -eq $this.FieldIndex
            
            # Label
            $output += [VT]::MoveTo($this.X + 3, $y)
            if ($isSelected) {
                $output += [VT]::Selected() + " > " + $field.Name + ":"
            } else {
                $output += [VT]::TextDim() + "   " + $field.Name + ":"
            }
            
            # Value
            $output += [VT]::MoveTo($this.X + 20, $y)
            
            if ($this.EditMode -and $isSelected) {
                # Edit mode
                $value = $this.EditBuffer + "▌"
                $output += [VT]::RGBBG(255, 255, 0) + [VT]::RGB(0, 0, 0) + " " + $value.PadRight(40) + " " + [VT]::Reset()
            } else {
                # Display mode
                $value = $this.FormatFieldValue($field)
                
                if ($isSelected) {
                    $output += [VT]::TextBright() + "[" + $value + "]"
                } else {
                    $output += [VT]::Text() + " " + $value
                }
            }
            
            $output += [VT]::Reset()
        }
        
        # Instructions
        $output += [VT]::MoveTo($this.X + 3, $this.Y + $this.Height - 2)
        $output += [VT]::TextDim()
        if ($this.EditMode) {
            $output += "[Enter] save field  [Esc] cancel edit"
        } else {
            $output += "[↑/↓] navigate  [Enter] edit  [F2] save all"
            if ($this.IsNew) {
                $output += "  [S] save & add subtask"
            }
            $output += "  [Esc/←] cancel"
        }
        
        $output += [VT]::Reset()
        return $output
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        # Handle edit mode typing
        if ($this.EditMode) {
            switch ($key.Key) {
                ([ConsoleKey]::Backspace) {
                    if ($this.EditBuffer.Length -gt 0) {
                        $this.EditBuffer = $this.EditBuffer.Substring(0, $this.EditBuffer.Length - 1)
                    }
                    return
                }
            }
            
            # Add character if printable
            if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or 
                $key.KeyChar -eq ' ' -or [char]::IsPunctuation($key.KeyChar) -or
                [char]::IsSymbol($key.KeyChar) -or $key.KeyChar -eq '-' -or
                $key.KeyChar -eq '+') {
                $this.EditBuffer += $key.KeyChar
                return
            }
        }
        
        # Normal key handling
        ([Screen]$this).HandleInput($key)
    }
    
    [string] FormatFieldValue([hashtable]$field) {
        switch ($field.Type) {
            "Date" {
                if ($field.Value -and $field.Value -ne [datetime]::MinValue) {
                    return [DateParser]::Format($field.Value)
                } else {
                    return "(not set) - use yyyymmdd or +days"
                }
            }
            "Number" {
                if ($field.Value) { return $field.Value.ToString() } else { return "0" }
            }
            default {
                if ($field.Value) { return $field.Value } else { return "(empty)" }
            }
        }
        return ""  # Ensure all paths return a value
    }
    
    [void] StartEdit() {
        $field = $this.Fields[$this.FieldIndex]
        $this.EditBuffer = if ($field.Value -and $field.Value -ne [datetime]::MinValue) {
            switch ($field.Type) {
                "Date" { $field.Value.ToString("yyyyMMdd") }
                "Number" { $field.Value.ToString() }
                default { $field.Value }
            }
        } else { "" }
    }
    
    [void] SaveField() {
        $field = $this.Fields[$this.FieldIndex]
        switch ($field.Type) {
            "Number" {
                $num = 0
                if ([int]::TryParse($this.EditBuffer, [ref]$num)) {
                    $field.Value = [Math]::Max($field.Min, [Math]::Min($field.Max, $num))
                }
            }
            "Date" {
                $field.Value = [DateParser]::Parse($this.EditBuffer)
            }
            default {
                $field.Value = $this.EditBuffer
            }
        }
        $this.EditBuffer = ""
    }
    
    [void] ChangeChoice([int]$direction) {
        $field = $this.Fields[$this.FieldIndex]
        if ($field.Type -eq "Choice") {
            $currentIndex = $field.Options.IndexOf($field.Value)
            $newIndex = $currentIndex + $direction
            if ($newIndex -ge 0 -and $newIndex -lt $field.Options.Count) {
                $field.Value = $field.Options[$newIndex]
            }
        }
    }
    
    [void] SaveTask() {
        foreach ($field in $this.Fields) {
            switch ($field.Name) {
                "Title" { $this.Task.Title = $field.Value }
                "Description" { $this.Task.Description = $field.Value }
                "Status" { $this.Task.Status = $field.Value }
                "Priority" { $this.Task.Priority = $field.Value }
                "Progress" { $this.Task.Progress = $field.Value }
                "Due Date" { $this.Task.DueDate = $field.Value }
            }
        }
        $this.Task.Update()
    }
}


####\Screens/editscreen.ps1
# Edit Screen for detailed task editing

class EditScreen {
    [Task]$Task
    [bool]$IsNew
    [int]$FieldIndex = 0
    [System.Collections.ArrayList]$Fields
    [bool]$EditMode = $false
    [string]$EditBuffer = ""
    [bool]$ShouldSave = $false
    [bool]$ShouldCancel = $false
    
    EditScreen([Task]$task, [bool]$isNew) {
        $this.Task = $task
        $this.IsNew = $isNew
        $this.InitializeFields()
    }
    
    [void] InitializeFields() {
        $this.Fields = [System.Collections.ArrayList]@(
            @{Name="Title"; Value=$this.Task.Title; Type="Text"},
            @{Name="Description"; Value=$this.Task.Description; Type="Multiline"},
            @{Name="Status"; Value=$this.Task.Status; Type="Choice"; Options=@("Pending", "InProgress", "Completed", "Cancelled")},
            @{Name="Priority"; Value=$this.Task.Priority; Type="Choice"; Options=@("Low", "Medium", "High")},
            @{Name="Progress"; Value=$this.Task.Progress; Type="Number"; Min=0; Max=100},
            @{Name="Due Date"; Value=$this.Task.DueDate; Type="Date"}
        )
    }
    
    [void] Render() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        # Position at home and draw frame
        $output = [VT]::Home()
        $output += [VT]::MoveTo(1, 1)
        $output += [VT]::Border()
        
        # Draw border
        $output += [VT]::TL() + [VT]::H() * ($width - 2) + [VT]::TR()
        
        for ($y = 2; $y -lt $height - 1; $y++) {
            $output += [VT]::MoveTo(1, $y) + [VT]::V()
            $output += [VT]::MoveTo($width, $y) + [VT]::V()
        }
        
        $output += [VT]::MoveTo(1, $height - 1)
        $output += [VT]::BL() + [VT]::H() * ($width - 2) + [VT]::BR()
        
        # Title
        $title = if ($this.IsNew) { " NEW TASK " } else { " EDIT TASK " }
        $titleX = [int](($width - $title.Length) / 2)
        $output += [VT]::MoveTo($titleX, 1) + [VT]::TextBright() + $title
        
        # Fields
        $y = 3
        for ($i = 0; $i -lt $this.Fields.Count; $i++) {
            $field = $this.Fields[$i]
            $isSelected = $i -eq $this.FieldIndex
            
            # Field label
            $output += [VT]::MoveTo(5, $y)
            if ($isSelected) {
                $output += [VT]::Selected() + " > " + $field.Name + ":"
            } else {
                $output += [VT]::TextDim() + "   " + $field.Name + ":"
            }
            
            # Field value
            $output += [VT]::MoveTo(20, $y)
            
            if ($this.EditMode -and $isSelected) {
                # Edit mode
                $value = $this.EditBuffer + "▌"
                $output += [VT]::RGBBG(255, 255, 0) + [VT]::RGB(0, 0, 0) + " " + $value.PadRight(40) + " " + [VT]::Reset()
            } else {
                # Display mode
                $value = switch ($field.Type) {
                    "Date" {
                        if ($field.Value -and $field.Value -ne [datetime]::MinValue) {
                            [DateParser]::Format($field.Value)
                        } else {
                            "(not set) - use yyyymmdd or +days"
                        }
                    }
                    "Number" {
                        if ($field.Value) { $field.Value.ToString() } else { "0" }
                    }
                    default {
                        if ($field.Value) { $field.Value } else { "(empty)" }
                    }
                }
                
                if ($isSelected) {
                    $output += [VT]::TextBright() + "[" + $value + "]"
                } else {
                    $output += [VT]::Text() + " " + $value
                }
            }
            
            $output += [VT]::Reset()
            $y += 2
        }
        
        # Instructions
        $output += [VT]::MoveTo(5, $height - 3)
        $output += [VT]::TextDim()
        if ($this.EditMode) {
            $output += "[Enter] save field  [Esc] cancel edit"
        } else {
            $output += "[↑/↓] navigate  [Enter] edit field  [F2] save task  [Esc] cancel"
        }
        
        $output += [VT]::Reset()
        [Console]::Write($output)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if ($this.EditMode) {
            switch ($key.Key) {
                ([ConsoleKey]::Enter) {
                    # Save field
                    $field = $this.Fields[$this.FieldIndex]
                    switch ($field.Type) {
                        "Number" {
                            $num = 0
                            if ([int]::TryParse($this.EditBuffer, [ref]$num)) {
                                $field.Value = [Math]::Max($field.Min, [Math]::Min($field.Max, $num))
                            }
                        }
                        "Date" {
                            $field.Value = [DateParser]::Parse($this.EditBuffer)
                        }
                        default {
                            $field.Value = $this.EditBuffer
                        }
                    }
                    $this.EditMode = $false
                    $this.EditBuffer = ""
                }
                ([ConsoleKey]::Escape) {
                    # Cancel edit
                    $this.EditMode = $false
                    $this.EditBuffer = ""
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.EditBuffer.Length -gt 0) {
                        $this.EditBuffer = $this.EditBuffer.Substring(0, $this.EditBuffer.Length - 1)
                    }
                }
                default {
                    # Add character
                    if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or 
                        $key.KeyChar -eq ' ' -or [char]::IsPunctuation($key.KeyChar) -or
                        [char]::IsSymbol($key.KeyChar) -or $key.KeyChar -eq '-') {
                        $this.EditBuffer += $key.KeyChar
                    }
                }
            }
        } else {
            # Navigation mode
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.FieldIndex -gt 0) {
                        $this.FieldIndex--
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.FieldIndex -lt $this.Fields.Count - 1) {
                        $this.FieldIndex++
                    }
                }
                ([ConsoleKey]::Enter) {
                    # Enter edit mode
                    $this.EditMode = $true
                    $field = $this.Fields[$this.FieldIndex]
                    $this.EditBuffer = if ($field.Value -and $field.Value -ne [datetime]::MinValue) {
                        switch ($field.Type) {
                            "Date" { $field.Value.ToString("yyyy-MM-dd") }
                            "Number" { $field.Value.ToString() }
                            default { $field.Value }
                        }
                    } else { "" }
                }
                ([ConsoleKey]::F2) {
                    # Save task
                    $this.SaveToTask()
                    $this.ShouldSave = $true
                }
                ([ConsoleKey]::Escape) {
                    # Cancel
                    $this.ShouldCancel = $true
                }
            }
            
            # Handle choice fields with left/right
            if ($key.Key -eq [ConsoleKey]::LeftArrow -or $key.Key -eq [ConsoleKey]::RightArrow) {
                $field = $this.Fields[$this.FieldIndex]
                if ($field.Type -eq "Choice") {
                    $currentIndex = $field.Options.IndexOf($field.Value)
                    if ($key.Key -eq [ConsoleKey]::LeftArrow -and $currentIndex -gt 0) {
                        $field.Value = $field.Options[$currentIndex - 1]
                    } elseif ($key.Key -eq [ConsoleKey]::RightArrow -and $currentIndex -lt $field.Options.Count - 1) {
                        $field.Value = $field.Options[$currentIndex + 1]
                    }
                }
            }
        }
    }
    
    [void] SaveToTask() {
        foreach ($field in $this.Fields) {
            switch ($field.Name) {
                "Title" { $this.Task.Title = $field.Value }
                "Description" { $this.Task.Description = $field.Value }
                "Status" { $this.Task.Status = $field.Value }
                "Priority" { $this.Task.Priority = $field.Value }
                "Progress" { $this.Task.Progress = $field.Value }
                "Due Date" { $this.Task.DueDate = $field.Value }
            }
        }
        $this.Task.Update()
    }
}


####\Screens/FileBrowserScreen.ps1
# FileBrowserScreen - Ranger-style three-column file browser

class FileBrowserScreen : Screen {
    # Panels
    hidden [FastPanel]$ParentPanel
    hidden [FastPanel]$CurrentPanel
    hidden [FastPanel]$PreviewPanel
    
    # ListBoxes
    hidden [FastFileListBox]$ParentList
    hidden [FastFileListBox]$CurrentList
    hidden [FastFileListBox]$PreviewList
    
    # State
    [string]$CurrentPath
    [int]$FocusedPanel = 1  # 0=parent, 1=current, 2=preview
    hidden [hashtable]$FileCache = @{}
    
    FileBrowserScreen() {
        $this.Title = "File Browser"
        $this.CurrentPath = (Get-Location).Path
        $this.Initialize()
    }
    
    [void] Initialize() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        $panelWidth = [int]($width / 3)
        
        # Parent directory panel
        $this.ParentPanel = [FastPanel]::new("ParentPanel")
        $this.ParentPanel.X = 0
        $this.ParentPanel.Y = 2
        $this.ParentPanel.Width = $panelWidth
        $this.ParentPanel.Height = $height - 4
        $this.ParentPanel.Title = "Parent"
        $this.ParentPanel.BorderStyle = "Single"
        
        $this.ParentList = [FastFileListBox]::new(1, 1, $panelWidth - 2, $height - 6)
        $this.ParentList.HasBorder = $false
        
        # Current directory panel
        $this.CurrentPanel = [FastPanel]::new("CurrentPanel")
        $this.CurrentPanel.X = $panelWidth
        $this.CurrentPanel.Y = 2
        $this.CurrentPanel.Width = $panelWidth
        $this.CurrentPanel.Height = $height - 4
        $this.CurrentPanel.Title = "Current"
        $this.CurrentPanel.BorderStyle = "Double"
        
        $this.CurrentList = [FastFileListBox]::new($panelWidth + 1, 3, $panelWidth - 2, $height - 6)
        $this.CurrentList.HasBorder = $false
        $this.CurrentList.IsFocused = $true
        
        # Preview panel
        $this.PreviewPanel = [FastPanel]::new("PreviewPanel")
        $this.PreviewPanel.X = $panelWidth * 2
        $this.PreviewPanel.Y = 2
        $this.PreviewPanel.Width = $width - ($panelWidth * 2)
        $this.PreviewPanel.Height = $height - 4
        $this.PreviewPanel.Title = "Preview"
        $this.PreviewPanel.BorderStyle = "Single"
        
        $this.PreviewList = [FastFileListBox]::new(($panelWidth * 2) + 1, 3, $this.PreviewPanel.Width - 2, $height - 6)
        $this.PreviewList.HasBorder = $false
        
        # Load initial directory
        $this.LoadDirectory($this.CurrentPath)
        
        # Key bindings
        $this.InitializeKeyBindings()
        
        # Status bar
        $this.UpdateStatusBar()
    }
    
    [void] InitializeKeyBindings() {
        # Navigation
        $this.BindKey([ConsoleKey]::UpArrow, { $this.NavigateUp() })
        $this.BindKey([ConsoleKey]::DownArrow, { $this.NavigateDown() })
        $this.BindKey([ConsoleKey]::LeftArrow, { $this.NavigateLeft() })
        $this.BindKey([ConsoleKey]::RightArrow, { $this.NavigateRight() })
        $this.BindKey([ConsoleKey]::Enter, { $this.OpenSelected() })
        $this.BindKey([ConsoleKey]::Backspace, { $this.NavigateUp() })
        
        # Quick navigation
        $this.BindKey('h', { $this.NavigateLeft() })
        $this.BindKey('j', { $this.NavigateDown() })
        $this.BindKey('k', { $this.NavigateUp() })
        $this.BindKey('l', { $this.NavigateRight() })
        $this.BindKey('g', { $this.GoToTop() })
        $this.BindKey('G', { $this.GoToBottom() })
        
        # File operations
        $this.BindKey('e', { $this.EditSelected() })
        $this.BindKey('v', { $this.ViewSelected() })
        $this.BindKey('/', { $this.StartSearch() })
        $this.BindKey('.', { $this.ToggleHidden() })
        
        # Exit
        $this.BindKey('q', { $this.Active = $false })
        $this.BindKey([ConsoleKey]::Escape, { $this.Active = $false })
    }
    
    [void] UpdateStatusBar() {
        $this.StatusBarItems.Clear()
        $this.AddStatusItem('hjkl/arrows', 'navigate')
        $this.AddStatusItem('enter', 'open')
        $this.AddStatusItem('e', 'edit')
        $this.AddStatusItem('v', 'view')
        $this.AddStatusItem('.', 'hidden')
        $this.AddStatusItem('q', 'quit')
        
        # Add path info
        $this.StatusBarItems.Add(@{
            Label = " Path: $($this.CurrentPath)"
            Align = "Right"
        }) | Out-Null
    }
    
    [string] RenderContent() {
        $output = ""
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        # Clear background
        for ($y = 1; $y -le $height; $y++) {
            $output += [VT]::MoveTo(1, $y)
            $output += " " * $width
        }
        
        # Title bar
        $titleBar = " RANGER-STYLE FILE BROWSER "
        $x = [int](($width - $titleBar.Length) / 2)
        $output += [VT]::MoveTo($x, 1)
        $output += [VT]::RGB(100, 200, 255) + $titleBar + [VT]::Reset()
        
        # Update panel focus indicators
        $this.UpdatePanelFocus()
        
        # Render panels (using simple rendering for now)
        $output += $this.RenderPanel($this.ParentPanel, $this.ParentList)
        $output += $this.RenderPanel($this.CurrentPanel, $this.CurrentList)
        $output += $this.RenderPanel($this.PreviewPanel, $this.PreviewList)
        
        return $output
    }
    
    [string] RenderPanel([Panel]$panel, [ListBox]$listbox) {
        $output = ""
        
        # Draw border
        $borderColor = if ($panel -eq $this.CurrentPanel -and $this.FocusedPanel -eq 1) {
            [VT]::RGB(100, 200, 255)
        } else {
            [VT]::RGB(100, 100, 150)
        }
        
        # Top border with title
        $output += [VT]::MoveTo($panel.X, $panel.Y)
        $output += $borderColor + "┌" + ("─" * ($panel.Width - 2)) + "┐" + [VT]::Reset()
        
        if ($panel.Title) {
            $titleText = " $($panel.Title) "
            $output += [VT]::MoveTo($panel.X + 2, $panel.Y)
            $output += $borderColor + $titleText + [VT]::Reset()
        }
        
        # Sides and content
        for ($y = 1; $y -lt $panel.Height - 1; $y++) {
            $output += [VT]::MoveTo($panel.X, $panel.Y + $y)
            $output += $borderColor + "│" + [VT]::Reset()
            $output += [VT]::MoveTo($panel.X + $panel.Width - 1, $panel.Y + $y)
            $output += $borderColor + "│" + [VT]::Reset()
        }
        
        # Bottom border
        $output += [VT]::MoveTo($panel.X, $panel.Y + $panel.Height - 1)
        $output += $borderColor + "└" + ("─" * ($panel.Width - 2)) + "┘" + [VT]::Reset()
        
        # Render list items
        $output += $this.RenderListBox($listbox, $panel.X + 1, $panel.Y + 1, $panel.Width - 2, $panel.Height - 2)
        
        return $output
    }
    
    [string] RenderListBox([ListBox]$listbox, [int]$x, [int]$y, [int]$width, [int]$height) {
        $output = ""
        
        # Calculate visible range
        $listbox.EnsureVisible()
        $endIndex = [Math]::Min($listbox.ScrollOffset + $height, $listbox.Items.Count)
        
        for ($i = $listbox.ScrollOffset; $i -lt $endIndex; $i++) {
            $item = $listbox.Items[$i]
            $itemY = $y + ($i - $listbox.ScrollOffset)
            
            # Format item
            $text = $this.FormatFileItem($item)
            if ($text.Length -gt $width - 1) {
                $text = $text.Substring(0, $width - 4) + "..."
            }
            
            $output += [VT]::MoveTo($x, $itemY)
            
            # Highlight selected item
            if ($i -eq $listbox.SelectedIndex) {
                $output += [VT]::RGBBG(40, 40, 80) + [VT]::RGB(255, 255, 255)
                $output += " " + $text.PadRight($width - 1)
                $output += [VT]::Reset()
            } else {
                $output += " " + $text
            }
        }
        
        # Scrollbar if needed
        if ($listbox.Items.Count -gt $height) {
            $this.RenderScrollbar($output, $x + $width - 1, $y, $height, $listbox.ScrollOffset, $listbox.Items.Count)
        }
        
        return $output
    }
    
    [string] FormatFileItem([object]$item) {
        if ($item -is [System.IO.DirectoryInfo]) {
            return "📁 " + $item.Name + "/"
        } elseif ($item -is [System.IO.FileInfo]) {
            $icon = $this.GetFileIcon($item.Extension)
            $size = $this.FormatFileSize($item.Length)
            return "$icon $($item.Name) ($size)"
        } elseif ($item -eq "..") {
            return "📁 ../"
        } else {
            return $item.ToString()
        }
    }
    
    [string] GetFileIcon([string]$extension) {
        switch ($extension.ToLower()) {
            ".ps1" { return "🔷" }
            ".txt" { return "📄" }
            ".md" { return "📝" }
            ".json" { return "📋" }
            ".xml" { return "📋" }
            ".jpg" { return "🖼️" }
            ".png" { return "🖼️" }
            ".mp3" { return "🎵" }
            ".mp4" { return "🎬" }
            ".zip" { return "📦" }
            ".exe" { return "⚙️" }
            default { return "📄" }
        }
        return "📄"  # Fallback return
    }
    
    [string] FormatFileSize([long]$bytes) {
        if ($bytes -lt 1024) { return "$bytes B" }
        if ($bytes -lt 1048576) { return "$([Math]::Round($bytes / 1024, 1)) KB" }
        if ($bytes -lt 1073741824) { return "$([Math]::Round($bytes / 1048576, 1)) MB" }
        return "$([Math]::Round($bytes / 1073741824, 1)) GB"
    }
    
    [void] LoadDirectory([string]$path) {
        try {
            $this.CurrentPath = [System.IO.Path]::GetFullPath($path)
            $this.CurrentPanel.Title = [System.IO.Path]::GetFileName($this.CurrentPath)
            if (-not $this.CurrentPanel.Title) {
                $this.CurrentPanel.Title = $this.CurrentPath
            }
            
            # Load parent directory
            $parent = [System.IO.Directory]::GetParent($this.CurrentPath)
            if ($parent) {
                $this.LoadParentDirectory($parent.FullName)
            } else {
                $this.ParentList.Clear()
            }
            
            # Load current directory
            $items = @()
            
            # Add parent directory link if not at root
            if ($parent) {
                $items += ".."
            }
            
            # Get directories
            $dirs = Get-ChildItem -Path $this.CurrentPath -Directory -Force | Sort-Object Name
            $items += $dirs
            
            # Get files
            $files = Get-ChildItem -Path $this.CurrentPath -File -Force | Sort-Object Name
            $items += $files
            
            $this.CurrentList.SetFiles($items)
            
            # Update preview
            $this.OnCurrentSelectionChanged()
            
            $this.RequestRender()
        }
        catch {
            Write-Error "Failed to load directory: $_"
        }
    }
    
    [void] LoadParentDirectory([string]$path) {
        try {
            $items = @()
            
            # Add grandparent if exists
            $grandparent = [System.IO.Directory]::GetParent($path)
            if ($grandparent) {
                $items += ".."
            }
            
            # Get directories
            $dirs = Get-ChildItem -Path $path -Directory -Force | Sort-Object Name
            $items += $dirs
            
            # Get files
            $files = Get-ChildItem -Path $path -File -Force | Sort-Object Name
            $items += $files
            
            $this.ParentList.SetFiles($items)
            
            # Select current directory in parent list
            $currentDirName = [System.IO.Path]::GetFileName($this.CurrentPath)
            for ($i = 0; $i -lt $this.ParentList.Items.Count; $i++) {
                $item = $this.ParentList.Items[$i]
                if ($item -is [System.IO.DirectoryInfo] -and $item.Name -eq $currentDirName) {
                    $this.ParentList.SelectedIndex = $i
                    break
                }
            }
        }
        catch {
            $this.ParentList.Clear()
        }
    }
    
    [void] OnCurrentSelectionChanged() {
        $selected = $this.CurrentList.GetSelectedItem()
        if (-not $selected) {
            $this.PreviewList.Clear()
            return
        }
        
        if ($selected -is [System.IO.DirectoryInfo]) {
            # Preview directory contents
            try {
                $items = @()
                $dirs = Get-ChildItem -Path $selected.FullName -Directory -Force | Select-Object -First 20 | Sort-Object Name
                $files = Get-ChildItem -Path $selected.FullName -File -Force | Select-Object -First 20 | Sort-Object Name
                $items += $dirs
                $items += $files
                $this.PreviewList.SetItems($items)
            }
            catch {
                $this.PreviewList.SetItems(@("Access denied"))
            }
        }
        elseif ($selected -is [System.IO.FileInfo]) {
            # Preview file contents
            $this.PreviewFile($selected.FullName)
        }
    }
    
    [void] PreviewFile([string]$path) {
        try {
            $ext = [System.IO.Path]::GetExtension($path).ToLower()
            
            # Text files - show content
            if ($ext -in @(".txt", ".md", ".ps1", ".json", ".xml", ".yml", ".yaml", ".ini", ".cfg")) {
                $lines = Get-Content -Path $path -TotalCount 50 -ErrorAction Stop
                $this.PreviewList.SetItems($lines)
            }
            # Binary files - show info
            else {
                $file = Get-Item $path
                $info = @(
                    "File: $($file.Name)",
                    "Size: $($this.FormatFileSize($file.Length))",
                    "Created: $($file.CreationTime)",
                    "Modified: $($file.LastWriteTime)",
                    "Extension: $($file.Extension)"
                )
                $this.PreviewList.SetItems($info)
            }
        }
        catch {
            $this.PreviewList.SetItems(@("Cannot preview file"))
        }
    }
    
    [void] UpdatePanelFocus() {
        # Update border colors based on focus
        $this.ParentPanel.IsFocused = ($this.FocusedPanel -eq 0)
        $this.CurrentPanel.IsFocused = ($this.FocusedPanel -eq 1)
        $this.PreviewPanel.IsFocused = ($this.FocusedPanel -eq 2)
    }
    
    # Navigation methods
    [void] NavigateUp() {
        switch ($this.FocusedPanel) {
            0 { $this.ParentList.HandleInput([System.ConsoleKeyInfo]::new([char]0, [ConsoleKey]::UpArrow, $false, $false, $false)) }
            1 { $this.CurrentList.HandleInput([System.ConsoleKeyInfo]::new([char]0, [ConsoleKey]::UpArrow, $false, $false, $false)) }
            2 { $this.PreviewList.HandleInput([System.ConsoleKeyInfo]::new([char]0, [ConsoleKey]::UpArrow, $false, $false, $false)) }
        }
        $this.RequestRender()
    }
    
    [void] NavigateDown() {
        switch ($this.FocusedPanel) {
            0 { $this.ParentList.HandleInput([System.ConsoleKeyInfo]::new([char]0, [ConsoleKey]::DownArrow, $false, $false, $false)) }
            1 { $this.CurrentList.HandleInput([System.ConsoleKeyInfo]::new([char]0, [ConsoleKey]::DownArrow, $false, $false, $false)) }
            2 { $this.PreviewList.HandleInput([System.ConsoleKeyInfo]::new([char]0, [ConsoleKey]::DownArrow, $false, $false, $false)) }
        }
        $this.RequestRender()
    }
    
    [void] NavigateLeft() {
        if ($this.FocusedPanel -gt 0) {
            $this.FocusedPanel--
        } else {
            # Go up one directory
            $parent = [System.IO.Directory]::GetParent($this.CurrentPath)
            if ($parent) {
                $this.LoadDirectory($parent.FullName)
            }
        }
        $this.RequestRender()
    }
    
    [void] NavigateRight() {
        if ($this.FocusedPanel -lt 2) {
            $this.FocusedPanel++
        } else {
            # Enter selected directory
            $this.OpenSelected()
        }
        $this.RequestRender()
    }
    
    [void] OpenSelected() {
        $selected = $this.CurrentList.GetSelectedItem()
        if ($selected -eq "..") {
            $parent = [System.IO.Directory]::GetParent($this.CurrentPath)
            if ($parent) {
                $this.LoadDirectory($parent.FullName)
            }
        }
        elseif ($selected -is [System.IO.DirectoryInfo]) {
            $this.LoadDirectory($selected.FullName)
        }
        elseif ($selected -is [System.IO.FileInfo]) {
            $this.EditSelected()
        }
    }
    
    [void] EditSelected() {
        $selected = $this.CurrentList.GetSelectedItem()
        if ($selected -is [System.IO.FileInfo]) {
            # Open text editor
            $editor = [TextEditorScreen]::new($selected.FullName)
            $global:ScreenManager.Push($editor)
        }
    }
    
    [void] ViewSelected() {
        # Similar to edit but read-only
        $this.EditSelected()
    }
    
    [void] GoToTop() {
        switch ($this.FocusedPanel) {
            0 { $this.ParentList.SelectedIndex = 0; $this.ParentList.ScrollOffset = 0 }
            1 { $this.CurrentList.SelectedIndex = 0; $this.CurrentList.ScrollOffset = 0 }
            2 { $this.PreviewList.SelectedIndex = 0; $this.PreviewList.ScrollOffset = 0 }
        }
        $this.RequestRender()
    }
    
    [void] GoToBottom() {
        switch ($this.FocusedPanel) {
            0 { $this.ParentList.SelectedIndex = $this.ParentList.Items.Count - 1 }
            1 { $this.CurrentList.SelectedIndex = $this.CurrentList.Items.Count - 1 }
            2 { $this.PreviewList.SelectedIndex = $this.PreviewList.Items.Count - 1 }
        }
        $this.RequestRender()
    }
    
    [void] StartSearch() {
        # TODO: Implement search functionality
        Write-Host "Search not yet implemented"
    }
    
    [void] ToggleHidden() {
        # TODO: Implement hidden file toggle
        Write-Host "Hidden file toggle not yet implemented"
    }
}


####\Screens/MainMenuScreen.ps1
# Main Menu Screen - Enhanced with left panel navigation

class MainMenuScreen : Screen {
    [System.Collections.ArrayList]$MenuItems
    [System.Collections.ArrayList]$MenuCategories
    [int]$SelectedIndex = 0
    [int]$SelectedCategory = 0
    [bool]$ShowCategories = $true
    hidden [int]$AnimationFrame = 0
    
    MainMenuScreen() {
        $this.Title = "ALCAR"
        $this.Initialize()
    }
    
    [void] Initialize() {
        # Menu categories for better organization
        $this.MenuCategories = [System.Collections.ArrayList]@(
            @{Name = "CORE"; Items = @()},
            @{Name = "TOOLS"; Items = @()},
            @{Name = "SYSTEM"; Items = @()}
        )
        
        # All menu items organized by category
        $this.MenuItems = [System.Collections.ArrayList]@(
            # CORE category
            @{
                Title = "Tasks"
                Category = 0
                Icon = "◈"
                Key = "T"
                Action = { 
                    $screen = [TaskScreen]::new()
                    $global:ScreenManager.Push($screen)
                }.GetNewClosure()
            },
            @{
                Title = "Projects"
                Category = 0
                Icon = "◈"
                Key = "P"
                Action = {
                    $screen = [ProjectsScreen]::new()
                    $global:ScreenManager.Push($screen)
                }.GetNewClosure()
            },
            @{
                Title = "Dashboard"
                Category = 0
                Icon = "◈"
                Key = "D"
                Action = {
                    $screen = [DashboardScreen]::new()
                    $global:ScreenManager.Push($screen)
                }.GetNewClosure()
            },
            # TOOLS category (ready for expansion)
            @{
                Title = "Calendar"
                Category = 1
                Icon = "◆"
                Key = "C"
                Action = {
                    # Placeholder for future calendar screen
                    Write-Host "Calendar not yet implemented"
                    Start-Sleep -Seconds 1
                }.GetNewClosure()
            },
            @{
                Title = "File Browser"
                Category = 1
                Icon = "◆"
                Key = "F"
                Action = {
                    $screen = [FileBrowserScreen]::new()
                    $global:ScreenManager.Push($screen)
                }.GetNewClosure()
            },
            @{
                Title = "Pomodoro"
                Category = 1
                Icon = "◆"
                Key = "O"
                Action = {
                    # Placeholder for future pomodoro timer
                    Write-Host "Pomodoro Timer not yet implemented"
                    Start-Sleep -Seconds 1
                }.GetNewClosure()
            },
            @{
                Title = "Text Editor"
                Category = 1
                Icon = "◆"
                Key = "E"
                Action = {
                    $screen = [TextEditorScreen]::new()
                    $global:ScreenManager.Push($screen)
                }.GetNewClosure()
            },
            @{
                Title = "Text Editor v2"
                Category = 1
                Icon = "◆"
                Key = "V"
                Action = {
                    $screen = [TextEditorScreenV2]::new()
                    $global:ScreenManager.Push($screen)
                }.GetNewClosure()
            },
            # SYSTEM category
            @{
                Title = "Settings"
                Category = 2
                Icon = "○"
                Key = "S"
                Action = {
                    $screen = [SettingsScreenV2]::new()
                    $global:ScreenManager.Push($screen)
                }.GetNewClosure()
            },
            @{
                Title = "About"
                Category = 2
                Icon = "○"
                Key = "A"
                Action = {
                    # Placeholder for about screen
                    Write-Host "ALCAR v1.0 - Advanced Linux Console Application Resource"
                    Start-Sleep -Seconds 2
                }.GetNewClosure()
            },
            @{
                Title = "Exit"
                Category = 2
                Icon = "●"
                Key = "Q"
                Action = {
                    $this.Active = $false
                }
            }
        )
        
        # Organize items into categories
        foreach ($item in $this.MenuItems) {
            $this.MenuCategories[$item.Category].Items += $item
        }
        
        # Key bindings
        $this.InitializeKeyBindings()
        
        # Status bar
        $this.UpdateStatusBar()
    }
    
    [void] InitializeKeyBindings() {
        $this.BindKey([ConsoleKey]::UpArrow, { $this.MoveUp(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::DownArrow, { $this.MoveDown(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::LeftArrow, { $this.MoveCategoryUp(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::RightArrow, { $this.MoveCategoryDown(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::Enter, { $this.SelectItem() })
        $this.BindKey([ConsoleKey]::Tab, { $this.ToggleCategoryView(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::Escape, { $this.Active = $false })
        
        # Quick access keys for all items
        foreach ($item in $this.MenuItems) {
            if ($item.Key) {
                $this.BindKey($item.Key.ToLower()[0], { 
                    param($key)
                    $this.QuickSelectByKey($key)
                }.GetNewClosure())
            }
        }
        
        $this.BindKey('q', { $this.Active = $false })
    }
    
    [void] UpdateStatusBar() {
        $this.StatusBarItems.Clear()
        $this.AddStatusItem('↑↓', 'navigate')
        $this.AddStatusItem('←→', 'category')
        $this.AddStatusItem('Enter', 'select')
        $this.AddStatusItem('Tab', 'toggle view')
        $this.AddStatusItem('Letter keys', 'quick access')
        $this.AddStatusItem('ESC/Q', 'quit')
    }
    
    [string] RenderContent() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        $output = ""
        
        # Clear background
        for ($y = 1; $y -le $height; $y++) {
            $output += [VT]::MoveTo(1, $y)
            $output += " " * $width
        }
        
        # Draw main border
        $output += $this.DrawBorder()
        
        # ALCAR title at top
        $output += $this.DrawCompactTitle()
        
        # Left panel for menu
        $leftPanelWidth = 30
        $output += $this.DrawLeftPanel($leftPanelWidth, $height)
        
        # Right content area
        $output += $this.DrawRightContent($leftPanelWidth + 2, $width - $leftPanelWidth - 3, $height)
        
        $output += [VT]::Reset()
        return $output
    }
    
    [string] DrawCompactTitle() {
        $width = [Console]::WindowWidth
        $output = ""
        
        # Compact ALCAR title
        $title = "═══╡ A L C A R ╞═══"
        $x = [Math]::Max(1, [int](($width - $title.Length) / 2))
        $output += [VT]::MoveTo($x, 2)
        $output += [VT]::RGB(100, 200, 255) + $title + [VT]::Reset()
        
        return $output
    }
    
    [string] DrawLeftPanel([int]$panelWidth, [int]$panelHeight) {
        $output = ""
        
        # Panel border
        for ($y = 4; $y -lt $panelHeight - 1; $y++) {
            $output += [VT]::MoveTo($panelWidth, $y)
            $output += [VT]::RGB(80, 80, 120) + "│" + [VT]::Reset()
        }
        
        # Menu items
        $menuY = 5
        $itemIndex = 0
        
        foreach ($category in $this.MenuCategories) {
            # Category header
            $output += [VT]::MoveTo(3, $menuY)
            if ($this.SelectedCategory -eq $this.MenuCategories.IndexOf($category)) {
                $output += [VT]::RGB(150, 200, 255) + "▼ " + $category.Name + [VT]::Reset()
            } else {
                $output += [VT]::RGB(100, 100, 150) + "▶ " + $category.Name + [VT]::Reset()
            }
            $menuY += 2
            
            # Show items if category is selected or all categories are shown
            if ($this.ShowCategories -or $this.SelectedCategory -eq $this.MenuCategories.IndexOf($category)) {
                foreach ($item in $category.Items) {
                    $isSelected = ($itemIndex -eq $this.SelectedIndex)
                    
                    $output += [VT]::MoveTo(5, $menuY)
                    
                    if ($isSelected) {
                        # Highlight bar
                        $output += [VT]::MoveTo(2, $menuY)
                        $output += [VT]::RGBBG(40, 40, 80) + " " * ($panelWidth - 3) + [VT]::Reset()
                        
                        $output += [VT]::MoveTo(5, $menuY)
                        $output += [VT]::RGB(255, 255, 255)
                        $output += $item.Icon + " " + $item.Title
                        $output += [VT]::Reset()
                        
                        # Key hint
                        if ($item.Key) {
                            $output += [VT]::MoveTo($panelWidth - 4, $menuY)
                            $output += [VT]::RGB(200, 200, 100) + "[" + $item.Key + "]" + [VT]::Reset()
                        }
                    } else {
                        $output += [VT]::RGB(150, 150, 150)
                        $output += $item.Icon + " " + $item.Title
                        
                        # Key hint (dimmed)
                        if ($item.Key) {
                            $output += [VT]::MoveTo($panelWidth - 4, $menuY)
                            $output += [VT]::RGB(80, 80, 80) + "[" + $item.Key + "]"
                        }
                        $output += [VT]::Reset()
                    }
                    
                    $menuY++
                    $itemIndex++
                }
                $menuY++ # Extra space after category
            }
        }
        
        return $output
    }
    
    [string] DrawRightContent([int]$startX, [int]$contentWidth, [int]$contentHeight) {
        $output = ""
        
        # Get selected item details
        $selectedItem = $this.GetSelectedItem()
        if (-not $selectedItem) { return $output }
        
        # Draw selection preview/info
        $centerY = [int]($contentHeight / 2) - 5
        $centerX = $startX + [int]($contentWidth / 2)
        
        # Item icon (large)
        $largeIcon = "◆"
        if ($selectedItem.Icon) { $largeIcon = $selectedItem.Icon }
        
        $output += [VT]::MoveTo($centerX - 1, $centerY)
        $output += [VT]::RGB(100, 200, 255)
        # Draw large version
        for ($i = 0; $i -lt 3; $i++) {
            $output += [VT]::MoveTo($centerX - 3, $centerY + $i)
            $output += "  $largeIcon $largeIcon $largeIcon  "
        }
        $output += [VT]::Reset()
        
        # Item title
        $output += [VT]::MoveTo($centerX - ([int]($selectedItem.Title.Length / 2)), $centerY + 5)
        $output += [VT]::RGB(255, 255, 255) + $selectedItem.Title.ToUpper() + [VT]::Reset()
        
        # Hint text
        $hint = "Press Enter to launch"
        if ($selectedItem.Key) {
            $hint = "Press Enter or '" + $selectedItem.Key + "' to launch"
        }
        $output += [VT]::MoveTo($centerX - ([int]($hint.Length / 2)), $centerY + 7)
        $output += [VT]::RGB(150, 150, 150) + $hint + [VT]::Reset()
        
        return $output
    }
    
    [string] DrawBorder() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        $output = ""
        $borderColor = [VT]::RGB(100, 100, 150)
        
        # Top border
        $output += [VT]::MoveTo(1, 1)
        $output += $borderColor
        $output += "╔" + ("═" * ($width - 2)) + "╗"
        
        # Sides
        for ($y = 2; $y -lt $height - 1; $y++) {
            $output += [VT]::MoveTo(1, $y) + "║"
            $output += [VT]::MoveTo($width, $y) + "║"
        }
        
        # Bottom border
        $output += [VT]::MoveTo(1, $height - 1)
        $output += "╚" + ("═" * ($width - 2)) + "╝"
        
        $output += [VT]::Reset()
        return $output
    }
    
    [object] GetSelectedItem() {
        $index = 0
        foreach ($category in $this.MenuCategories) {
            foreach ($item in $category.Items) {
                if ($index -eq $this.SelectedIndex) {
                    return $item
                }
                $index++
            }
        }
        return $null
    }
    
    [void] MoveUp() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
        } else {
            # Wrap to bottom
            $this.SelectedIndex = $this.GetTotalItemCount() - 1
        }
        $this.UpdateSelectedCategory()
    }
    
    [void] MoveDown() {
        $total = $this.GetTotalItemCount()
        if ($this.SelectedIndex -lt $total - 1) {
            $this.SelectedIndex++
        } else {
            # Wrap to top
            $this.SelectedIndex = 0
        }
        $this.UpdateSelectedCategory()
    }
    
    [void] MoveCategoryUp() {
        if ($this.SelectedCategory -gt 0) {
            $this.SelectedCategory--
            # Move to first item in category
            $this.SelectFirstInCategory()
        }
    }
    
    [void] MoveCategoryDown() {
        if ($this.SelectedCategory -lt $this.MenuCategories.Count - 1) {
            $this.SelectedCategory++
            # Move to first item in category
            $this.SelectFirstInCategory()
        }
    }
    
    [void] SelectFirstInCategory() {
        $index = 0
        for ($i = 0; $i -lt $this.SelectedCategory; $i++) {
            $index += $this.MenuCategories[$i].Items.Count
        }
        $this.SelectedIndex = $index
    }
    
    [void] UpdateSelectedCategory() {
        # Determine which category the selected index falls into
        $index = 0
        for ($i = 0; $i -lt $this.MenuCategories.Count; $i++) {
            $categorySize = $this.MenuCategories[$i].Items.Count
            if ($this.SelectedIndex -ge $index -and $this.SelectedIndex -lt ($index + $categorySize)) {
                $this.SelectedCategory = $i
                break
            }
            $index += $categorySize
        }
    }
    
    [int] GetTotalItemCount() {
        $total = 0
        foreach ($category in $this.MenuCategories) {
            $total += $category.Items.Count
        }
        return $total
    }
    
    [void] ToggleCategoryView() {
        $this.ShowCategories = -not $this.ShowCategories
    }
    
    [void] SelectItem() {
        $item = $this.GetSelectedItem()
        if ($item -and $item.Action) {
            & $item.Action
        }
    }
    
    [void] QuickSelectByKey([char]$key) {
        $upperKey = [char]::ToUpper($key)
        $index = 0
        foreach ($category in $this.MenuCategories) {
            foreach ($item in $category.Items) {
                if ($item.Key -and $item.Key[0] -eq $upperKey) {
                    $this.SelectedIndex = $index
                    $this.UpdateSelectedCategory()
                    $this.SelectItem()
                    return
                }
                $index++
            }
        }
    }
}


####\Screens/ProjectsScreen.ps1
# Projects Screen

class ProjectsScreen : Screen {
    [System.Collections.ArrayList]$Projects
    [int]$SelectedIndex = 0
    [ThreePaneLayout]$Layout
    
    ProjectsScreen() {
        $this.Title = "PROJECTS"
        $this.Initialize()
    }
    
    [void] Initialize() {
        # Setup layout
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        $this.Layout = [ThreePaneLayout]::new($width, $height, 25, 30)
        $this.Layout.LeftPane.Title = "PROJECTS"
        $this.Layout.MiddlePane.Title = "TASKS"
        $this.Layout.RightPane.Title = "DETAILS"
        
        # Start with left pane focused
        $this.Layout.SetFocus(0)
        
        # Sample projects
        $this.Projects = [System.Collections.ArrayList]@(
            @{
                Name = "BOLT-AXIOM"
                Description = "Terminal UI Framework"
                TaskCount = 15
                CompletedCount = 8
                Color = [VT]::RGB(0, 255, 255)
            },
            @{
                Name = "Personal Website"
                Description = "Portfolio and blog"
                TaskCount = 8
                CompletedCount = 3
                Color = [VT]::RGB(255, 128, 0)
            },
            @{
                Name = "Learning"
                Description = "Courses and tutorials"
                TaskCount = 12
                CompletedCount = 10
                Color = [VT]::RGB(128, 255, 0)
            }
        )
        
        # Key bindings
        $this.InitializeKeyBindings()
        
        # Status bar
        $this.UpdateStatusBar()
    }
    
    [void] InitializeKeyBindings() {
        $this.BindKey([ConsoleKey]::UpArrow, { $this.NavigateUp(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::DownArrow, { $this.NavigateDown(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::LeftArrow, { 
            # In left pane, go back to main menu
            if ($this.Layout.FocusedPane -eq 0) {
                $this.Active = $false
            }
        })
        $this.BindKey([ConsoleKey]::Enter, { $this.OpenProject() })
        $this.BindKey([ConsoleKey]::RightArrow, { 
            # Right arrow opens project when in left pane
            if ($this.Layout.FocusedPane -eq 0) {
                $this.OpenProject()
            }
        })
        $this.BindKey([ConsoleKey]::Escape, { $this.Active = $false })
        $this.BindKey([ConsoleKey]::Backspace, { $this.Active = $false })
        
        $this.BindKey('a', { $this.AddProject() })
        $this.BindKey('e', { $this.EditProject() })
        $this.BindKey('d', { $this.DeleteProject() })
        $this.BindKey('q', { $this.Active = $false })
    }
    
    [void] UpdateStatusBar() {
        $this.StatusBarItems.Clear()
        $this.AddStatusItem('↑↓', 'navigate')
        $this.AddStatusItem('Enter', 'open')
        $this.AddStatusItem('a', 'add')
        $this.AddStatusItem('e', 'edit')
        $this.AddStatusItem('d', 'delete')
        $this.AddStatusItem('Esc', 'back')
    }
    
    [string] RenderContent() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        $output = ""
        
        # Clear background by drawing spaces everywhere
        for ($y = 1; $y -le $height; $y++) {
            $output += [VT]::MoveTo(1, $y)
            $output += " " * $width
        }
        
        $this.UpdateLeftPane()
        $this.UpdateMiddlePane()
        $this.UpdateRightPane()
        
        $output += $this.Layout.Render()
        return $output
    }
    
    [void] UpdateLeftPane() {
        $this.Layout.LeftPane.Content.Clear()
        
        for ($i = 0; $i -lt $this.Projects.Count; $i++) {
            $project = $this.Projects[$i]
            $isSelected = $i -eq $this.SelectedIndex
            
            $line = ""
            if ($isSelected) {
                $line += [VT]::Selected() + " > "
            } else {
                $line += "   "
            }
            
            # Project name with color
            $line += $project.Color + "●" + [VT]::Reset() + " "
            $line += [VT]::TextBright() + $project.Name
            
            # Progress - only show if there's space
            $progress = if ($project.TaskCount -gt 0) { 
                [int](($project.CompletedCount / $project.TaskCount) * 100) 
            } else { 0 }
            
            $progressText = " $progress%"
            $availableWidth = $this.Layout.LeftPane.Width - 8  # Account for selection marker and padding
            $nameAndProgressLength = $project.Name.Length + $progressText.Length + 2  # +2 for bullet and space
            
            if ($nameAndProgressLength -le $availableWidth) {
                # Only add progress if it fits
                $padding = $availableWidth - $project.Name.Length - $progressText.Length - 2
                if ($padding -gt 0) {
                    $line += " " * $padding
                }
                
                if ($progress -eq 100) {
                    $line += [VT]::Accent() + $progressText
                } elseif ($progress -gt 50) {
                    $line += [VT]::Warning() + $progressText
                } else {
                    $line += [VT]::TextDim() + $progressText
                }
            }
            
            $line += [VT]::Reset()
            $this.Layout.LeftPane.Content.Add($line) | Out-Null
        }
    }
    
    [void] UpdateMiddlePane() {
        $this.Layout.MiddlePane.Content.Clear()
        
        if ($this.Projects.Count -eq 0) {
            $this.Layout.MiddlePane.Content.Add([VT]::TextDim() + " No projects") | Out-Null
            return
        }
        
        $project = $this.Projects[$this.SelectedIndex]
        $this.Layout.MiddlePane.Title = "TASKS - " + $project.Name
        
        # Sample tasks for the selected project
        $tasks = @(
            "Setup project structure",
            "Implement core features",
            "Write documentation",
            "Add unit tests",
            "Performance optimization"
        )
        
        foreach ($task in $tasks) {
            $line = " " + [VT]::TextDim() + "○ " + [VT]::Text() + $task
            $this.Layout.MiddlePane.Content.Add($line) | Out-Null
        }
    }
    
    [void] UpdateRightPane() {
        $this.Layout.RightPane.Content.Clear()
        
        if ($this.Projects.Count -eq 0) {
            return
        }
        
        $project = $this.Projects[$this.SelectedIndex]
        
        # Project details
        $this.Layout.RightPane.Content.Add($project.Color + " ● " + [VT]::TextBright() + $project.Name) | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " " + ("─" * ($this.Layout.RightPane.Width - 3))) | Out-Null
        $this.Layout.RightPane.Content.Add("") | Out-Null
        
        # Description
        $this.Layout.RightPane.Content.Add([VT]::Text() + " " + $project.Description) | Out-Null
        $this.Layout.RightPane.Content.Add("") | Out-Null
        
        # Statistics
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Tasks: " + [VT]::Text() + $project.TaskCount) | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Completed: " + [VT]::Accent() + $project.CompletedCount) | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Remaining: " + [VT]::Warning() + ($project.TaskCount - $project.CompletedCount)) | Out-Null
        
        # Progress bar
        $this.Layout.RightPane.Content.Add("") | Out-Null
        $progress = if ($project.TaskCount -gt 0) { 
            ($project.CompletedCount / $project.TaskCount) 
        } else { 0 }
        
        $barWidth = 20
        $filled = [int]($progress * $barWidth)
        $bar = $project.Color + ("█" * $filled) + [VT]::TextDim() + ("░" * ($barWidth - $filled))
        
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Progress: " + $bar + [VT]::Reset() + " " + ([int]($progress * 100)) + "%") | Out-Null
    }
    
    [void] NavigateUp() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
        }
    }
    
    [void] NavigateDown() {
        if ($this.SelectedIndex -lt $this.Projects.Count - 1) {
            $this.SelectedIndex++
        }
    }
    
    [void] OpenProject() {
        # Would open project-specific task view
        # For now, just go to task screen
        if ($global:ScreenManager) {
            $screen = New-Object TaskScreen
            $global:ScreenManager.Push($screen)
        }
    }
    
    [void] AddProject() {
        # Would show add project dialog
        Write-Host "`nAdd project not implemented yet" -ForegroundColor Yellow
        Start-Sleep -Seconds 1
    }
    
    [void] EditProject() {
        # Would show edit project dialog
        Write-Host "`nEdit project not implemented yet" -ForegroundColor Yellow
        Start-Sleep -Seconds 1
    }
    
    [void] DeleteProject() {
        # Would show delete confirmation
        Write-Host "`nDelete project not implemented yet" -ForegroundColor Yellow
        Start-Sleep -Seconds 1
    }
}


####\Screens/SettingsScreen_v2.ps1
# Settings Screen v2 - Comprehensive settings with extensive controls

class SettingsScreenV2 : Screen {
    [System.Collections.ArrayList]$Categories
    [System.Collections.ArrayList]$CurrentSettings
    [int]$CategoryIndex = 0
    [int]$SettingIndex = 0
    [int]$FocusedPane = 0  # 0=categories, 1=settings
    [hashtable]$Settings = @{}  # Actual settings storage
    [bool]$HasUnsavedChanges = $false
    
    SettingsScreenV2() {
        $this.Title = "ALCAR SETTINGS"
        $this.Initialize()
    }
    
    [void] Initialize() {
        # Load existing settings or use defaults
        $this.LoadSettings()
        
        # Setting categories with comprehensive options
        $this.Categories = [System.Collections.ArrayList]@(
            @{
                Name = "Interface"
                Icon = "◈"
                Settings = @(
                    @{Name="Theme"; Type="Choice"; Key="theme"; 
                      Value=$this.Settings.theme; 
                      Options=@("Dark", "Light", "Synthwave", "Matrix", "Dracula", "Solarized", "Nord", "Gruvbox")},
                    @{Name="Color Mode"; Type="Choice"; Key="colorMode"; 
                      Value=$this.Settings.colorMode; 
                      Options=@("16 Colors", "256 Colors", "True Color")},
                    @{Name="Border Style"; Type="Choice"; Key="borderStyle"; 
                      Value=$this.Settings.borderStyle; 
                      Options=@("Single", "Double", "Rounded", "ASCII", "Heavy", "None")},
                    @{Name="Show Icons"; Type="Bool"; Key="showIcons"; Value=$this.Settings.showIcons},
                    @{Name="Show Animations"; Type="Bool"; Key="animations"; Value=$this.Settings.animations},
                    @{Name="Animation Speed"; Type="Choice"; Key="animSpeed"; 
                      Value=$this.Settings.animSpeed; 
                      Options=@("None", "Slow", "Normal", "Fast", "Instant")},
                    @{Name="Status Bar"; Type="Bool"; Key="statusBar"; Value=$this.Settings.statusBar},
                    @{Name="Compact Mode"; Type="Bool"; Key="compactMode"; Value=$this.Settings.compactMode},
                    @{Name="High Contrast"; Type="Bool"; Key="highContrast"; Value=$this.Settings.highContrast}
                )
            },
            @{
                Name = "Navigation"
                Icon = "◆"
                Settings = @(
                    @{Name="Arrow Key Mode"; Type="Choice"; Key="arrowMode"; 
                      Value=$this.Settings.arrowMode; 
                      Options=@("Standard", "Vim-like", "Emacs-like", "Custom")},
                    @{Name="Left Arrow in Panels"; Type="Choice"; Key="leftArrowBehavior"; 
                      Value=$this.Settings.leftArrowBehavior; 
                      Options=@("Focus Parent", "Go Back", "Previous Item", "Do Nothing")},
                    @{Name="Right Arrow in Panels"; Type="Choice"; Key="rightArrowBehavior"; 
                      Value=$this.Settings.rightArrowBehavior; 
                      Options=@("Focus Child", "Enter Item", "Next Item", "Do Nothing")},
                    @{Name="Tab Behavior"; Type="Choice"; Key="tabBehavior"; 
                      Value=$this.Settings.tabBehavior; 
                      Options=@("Next Field", "Next Pane", "Cycle Windows", "Insert Tab")},
                    @{Name="Wrap Navigation"; Type="Bool"; Key="wrapNav"; Value=$this.Settings.wrapNav},
                    @{Name="Quick Jump"; Type="Bool"; Key="quickJump"; Value=$this.Settings.quickJump},
                    @{Name="Home/End Keys"; Type="Choice"; Key="homeEndKeys"; 
                      Value=$this.Settings.homeEndKeys; 
                      Options=@("List Bounds", "Screen Bounds", "Document Bounds", "Line Bounds")}
                )
            },
            @{
                Name = "Editor"
                Icon = "◆"
                Settings = @(
                    @{Name="Tab Width"; Type="Number"; Key="tabWidth"; Value=$this.Settings.tabWidth; Min=1; Max=8},
                    @{Name="Insert Spaces"; Type="Bool"; Key="insertSpaces"; Value=$this.Settings.insertSpaces},
                    @{Name="Word Wrap"; Type="Bool"; Key="wordWrap"; Value=$this.Settings.wordWrap},
                    @{Name="Show Line Numbers"; Type="Bool"; Key="lineNumbers"; Value=$this.Settings.lineNumbers},
                    @{Name="Highlight Current Line"; Type="Bool"; Key="highlightLine"; Value=$this.Settings.highlightLine},
                    @{Name="Syntax Highlighting"; Type="Bool"; Key="syntaxHighlight"; Value=$this.Settings.syntaxHighlight},
                    @{Name="Auto Indent"; Type="Bool"; Key="autoIndent"; Value=$this.Settings.autoIndent},
                    @{Name="Auto Pairs"; Type="Bool"; Key="autoPairs"; Value=$this.Settings.autoPairs},
                    @{Name="Show Whitespace"; Type="Bool"; Key="showWhitespace"; Value=$this.Settings.showWhitespace},
                    @{Name="Trim Trailing Space"; Type="Bool"; Key="trimWhitespace"; Value=$this.Settings.trimWhitespace}
                )
            },
            @{
                Name = "Tasks"
                Icon = "◆"
                Settings = @(
                    @{Name="Default View"; Type="Choice"; Key="taskView"; 
                      Value=$this.Settings.taskView; 
                      Options=@("List", "Tree", "Kanban", "Calendar", "Timeline")},
                    @{Name="Sort By"; Type="Choice"; Key="taskSort"; 
                      Value=$this.Settings.taskSort; 
                      Options=@("Priority", "Due Date", "Created", "Modified", "Title", "Status")},
                    @{Name="Group By"; Type="Choice"; Key="taskGroup"; 
                      Value=$this.Settings.taskGroup; 
                      Options=@("None", "Project", "Priority", "Status", "Due Date")},
                    @{Name="Show Completed"; Type="Bool"; Key="showCompleted"; Value=$this.Settings.showCompleted},
                    @{Name="Show Archived"; Type="Bool"; Key="showArchived"; Value=$this.Settings.showArchived},
                    @{Name="Auto Archive Days"; Type="Number"; Key="autoArchiveDays"; 
                      Value=$this.Settings.autoArchiveDays; Min=0; Max=365},
                    @{Name="Due Date Warning"; Type="Number"; Key="dueDateWarning"; 
                      Value=$this.Settings.dueDateWarning; Min=0; Max=30},
                    @{Name="Task Colors"; Type="Bool"; Key="taskColors"; Value=$this.Settings.taskColors}
                )
            },
            @{
                Name = "Performance"
                Icon = "⚡"
                Settings = @(
                    @{Name="Render Mode"; Type="Choice"; Key="renderMode"; 
                      Value=$this.Settings.renderMode; 
                      Options=@("Optimized", "Balanced", "Quality", "Minimal")},
                    @{Name="Buffer Strategy"; Type="Choice"; Key="bufferStrategy"; 
                      Value=$this.Settings.bufferStrategy; 
                      Options=@("Double Buffer", "Triple Buffer", "Direct", "Adaptive")},
                    @{Name="Max FPS"; Type="Number"; Key="maxFps"; Value=$this.Settings.maxFps; Min=10; Max=120},
                    @{Name="Lazy Loading"; Type="Bool"; Key="lazyLoad"; Value=$this.Settings.lazyLoad},
                    @{Name="Cache Size (MB)"; Type="Number"; Key="cacheSize"; 
                      Value=$this.Settings.cacheSize; Min=0; Max=1024},
                    @{Name="Virtual Scrolling"; Type="Bool"; Key="virtualScroll"; Value=$this.Settings.virtualScroll},
                    @{Name="Preload Items"; Type="Number"; Key="preloadItems"; 
                      Value=$this.Settings.preloadItems; Min=0; Max=100}
                )
            },
            @{
                Name = "Shortcuts"
                Icon = "⌨"
                Settings = @(
                    @{Name="Quick Add"; Type="Key"; Key="keyQuickAdd"; Value=$this.Settings.keyQuickAdd},
                    @{Name="Quick Search"; Type="Key"; Key="keyQuickSearch"; Value=$this.Settings.keyQuickSearch},
                    @{Name="Command Palette"; Type="Key"; Key="keyCommandPalette"; Value=$this.Settings.keyCommandPalette},
                    @{Name="Toggle Sidebar"; Type="Key"; Key="keyToggleSidebar"; Value=$this.Settings.keyToggleSidebar},
                    @{Name="Focus Next Pane"; Type="Key"; Key="keyNextPane"; Value=$this.Settings.keyNextPane},
                    @{Name="Save"; Type="Key"; Key="keySave"; Value=$this.Settings.keySave},
                    @{Name="Undo"; Type="Key"; Key="keyUndo"; Value=$this.Settings.keyUndo},
                    @{Name="Redo"; Type="Key"; Key="keyRedo"; Value=$this.Settings.keyRedo},
                    @{Name="Exit"; Type="Key"; Key="keyExit"; Value=$this.Settings.keyExit}
                )
            },
            @{
                Name = "Data & Storage"
                Icon = "💾"
                Settings = @(
                    @{Name="Data Path"; Type="Path"; Key="dataPath"; Value=$this.Settings.dataPath},
                    @{Name="Backup Path"; Type="Path"; Key="backupPath"; Value=$this.Settings.backupPath},
                    @{Name="Auto Save"; Type="Bool"; Key="autoSave"; Value=$this.Settings.autoSave},
                    @{Name="Save Interval (min)"; Type="Number"; Key="saveInterval"; 
                      Value=$this.Settings.saveInterval; Min=1; Max=60},
                    @{Name="Backup on Exit"; Type="Bool"; Key="backupOnExit"; Value=$this.Settings.backupOnExit},
                    @{Name="Backup Frequency"; Type="Choice"; Key="backupFreq"; 
                      Value=$this.Settings.backupFreq; 
                      Options=@("Never", "Hourly", "Daily", "Weekly", "Monthly")},
                    @{Name="Max Backups"; Type="Number"; Key="maxBackups"; 
                      Value=$this.Settings.maxBackups; Min=1; Max=100},
                    @{Name="Compress Backups"; Type="Bool"; Key="compressBackups"; Value=$this.Settings.compressBackups},
                    @{Name="Export Format"; Type="Choice"; Key="exportFormat"; 
                      Value=$this.Settings.exportFormat; 
                      Options=@("JSON", "CSV", "Markdown", "HTML", "XML")}
                )
            },
            @{
                Name = "Advanced"
                Icon = "⚙"
                Settings = @(
                    @{Name="Debug Mode"; Type="Bool"; Key="debugMode"; Value=$this.Settings.debugMode},
                    @{Name="Log Level"; Type="Choice"; Key="logLevel"; 
                      Value=$this.Settings.logLevel; 
                      Options=@("None", "Error", "Warning", "Info", "Debug", "Trace")},
                    @{Name="Log to File"; Type="Bool"; Key="logToFile"; Value=$this.Settings.logToFile},
                    @{Name="Network Timeout (s)"; Type="Number"; Key="networkTimeout"; 
                      Value=$this.Settings.networkTimeout; Min=1; Max=300},
                    @{Name="Encoding"; Type="Choice"; Key="encoding"; 
                      Value=$this.Settings.encoding; 
                      Options=@("UTF-8", "UTF-16", "ASCII", "Windows-1252")},
                    @{Name="Line Endings"; Type="Choice"; Key="lineEndings"; 
                      Value=$this.Settings.lineEndings; 
                      Options=@("Auto", "LF", "CRLF", "CR")},
                    @{Name="Experimental Features"; Type="Bool"; Key="experimental"; Value=$this.Settings.experimental}
                )
            }
        )
        
        # Load current category settings
        $this.LoadCategorySettings()
        
        # Key bindings
        $this.InitializeKeyBindings()
        
        # Status bar
        $this.UpdateStatusBar()
    }
    
    [void] LoadSettings() {
        # Default settings
        $this.Settings = @{
            # Interface
            theme = "Synthwave"
            colorMode = "256 Colors"
            borderStyle = "Single"
            showIcons = $true
            animations = $true
            animSpeed = "Normal"
            statusBar = $true
            compactMode = $false
            highContrast = $false
            
            # Navigation
            arrowMode = "Standard"
            leftArrowBehavior = "Go Back"
            rightArrowBehavior = "Enter Item"
            tabBehavior = "Next Pane"
            wrapNav = $true
            quickJump = $true
            homeEndKeys = "List Bounds"
            
            # Editor
            tabWidth = 4
            insertSpaces = $true
            wordWrap = $false
            lineNumbers = $true
            highlightLine = $true
            syntaxHighlight = $true
            autoIndent = $true
            autoPairs = $true
            showWhitespace = $false
            trimWhitespace = $true
            
            # Tasks
            taskView = "Tree"
            taskSort = "Priority"
            taskGroup = "Project"
            showCompleted = $false
            showArchived = $false
            autoArchiveDays = 30
            dueDateWarning = 3
            taskColors = $true
            
            # Performance
            renderMode = "Optimized"
            bufferStrategy = "Double Buffer"
            maxFps = 60
            lazyLoad = $true
            cacheSize = 64
            virtualScroll = $true
            preloadItems = 20
            
            # Shortcuts
            keyQuickAdd = "Ctrl+N"
            keyQuickSearch = "Ctrl+F"
            keyCommandPalette = "Ctrl+P"
            keyToggleSidebar = "Ctrl+B"
            keyNextPane = "Ctrl+Tab"
            keySave = "Ctrl+S"
            keyUndo = "Ctrl+Z"
            keyRedo = "Ctrl+Y"
            keyExit = "Ctrl+Q"
            
            # Data & Storage
            dataPath = "~/.alcar/data"
            backupPath = "~/.alcar/backups"
            autoSave = $true
            saveInterval = 5
            backupOnExit = $true
            backupFreq = "Daily"
            maxBackups = 10
            compressBackups = $true
            exportFormat = "JSON"
            
            # Advanced
            debugMode = $false
            logLevel = "Warning"
            logToFile = $false
            networkTimeout = 30
            encoding = "UTF-8"
            lineEndings = "Auto"
            experimental = $false
        }
        
        # TODO: Load from file if exists
    }
    
    [void] InitializeKeyBindings() {
        # Navigation
        $this.BindKey([ConsoleKey]::Tab, { $this.SwitchPane() })
        $this.BindKey([ConsoleKey]::UpArrow, { $this.NavigateUp() })
        $this.BindKey([ConsoleKey]::DownArrow, { $this.NavigateDown() })
        $this.BindKey([ConsoleKey]::LeftArrow, { $this.NavigateLeft() })
        $this.BindKey([ConsoleKey]::RightArrow, { $this.NavigateRight() })
        $this.BindKey([ConsoleKey]::PageUp, { $this.PageUp() })
        $this.BindKey([ConsoleKey]::PageDown, { $this.PageDown() })
        $this.BindKey([ConsoleKey]::Home, { $this.GoToTop() })
        $this.BindKey([ConsoleKey]::End, { $this.GoToBottom() })
        
        # Actions
        $this.BindKey([ConsoleKey]::Enter, { $this.EditSetting() })
        $this.BindKey([ConsoleKey]::Spacebar, { $this.ToggleSetting() })
        $this.BindKey([ConsoleKey]::Delete, { $this.ResetSetting() })
        $this.BindKey([ConsoleKey]::Escape, { $this.HandleEscape() })
        $this.BindKey([ConsoleKey]::Backspace, { $this.HandleEscape() })
        
        # Commands
        $this.KeyBindings[[ConsoleKey]::S] = {
            param($key)
            if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                $this.SaveSettings()
            } else {
                $this.QuickSearch('s')
            }
        }
        
        $this.KeyBindings[[ConsoleKey]::R] = {
            param($key)
            if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                $this.ReloadSettings()
            } else {
                $this.ResetAllSettings()
            }
        }
        
        $this.BindKey('/', { $this.StartSearch() })
        $this.BindKey('?', { $this.ShowHelp() })
        $this.BindKey('q', { $this.HandleEscape() })
    }
    
    [void] UpdateStatusBar() {
        $this.StatusBarItems.Clear()
        
        if ($this.HasUnsavedChanges) {
            $this.StatusBarItems.Add(@{
                Label = "● UNSAVED"
                Color = [VT]::RGB(255, 200, 100)
            }) | Out-Null
        }
        
        $this.AddStatusItem('Tab', 'switch pane')
        $this.AddStatusItem('↑↓', 'navigate')
        $this.AddStatusItem('←→', 'change')
        $this.AddStatusItem('Space', 'toggle')
        $this.AddStatusItem('Enter', 'edit')
        $this.AddStatusItem('Ctrl+S', 'save')
        $this.AddStatusItem('Del', 'reset')
        $this.AddStatusItem('/', 'search')
        $this.AddStatusItem('Esc', 'back')
    }
    
    [string] RenderContent() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        $output = ""
        
        # Clear background
        for ($y = 1; $y -le $height; $y++) {
            $output += [VT]::MoveTo(1, $y)
            $output += " " * $width
        }
        
        # Title with unsaved indicator
        $titleText = " ALCAR SETTINGS "
        if ($this.HasUnsavedChanges) {
            $titleText = " ALCAR SETTINGS * "
        }
        $titleX = [int](($width - $titleText.Length) / 2)
        $output += [VT]::MoveTo($titleX, 1)
        $output += [VT]::RGB(100, 200, 255) + [VT]::Bold() + $titleText + [VT]::Reset()
        
        # Three-column layout
        $leftWidth = 25
        $divider1X = $leftWidth
        $rightStart = $width - 35
        $divider2X = $rightStart - 1
        
        # Draw dividers
        $dividerColor = [VT]::RGB(80, 80, 120)
        for ($y = 2; $y -lt $height - 1; $y++) {
            $output += [VT]::MoveTo($divider1X, $y) + $dividerColor + "│" + [VT]::Reset()
            $output += [VT]::MoveTo($divider2X, $y) + $dividerColor + "│" + [VT]::Reset()
        }
        
        # Categories (left)
        $output += $this.DrawCategories(2, 3, $leftWidth - 3)
        
        # Settings (middle)
        $output += $this.DrawSettings($divider1X + 2, 3, $divider2X - $divider1X - 3)
        
        # Help/Preview (right)
        $output += $this.DrawHelp($rightStart, 3, 33)
        
        return $output
    }
    
    [string] DrawCategories([int]$x, [int]$y, [int]$w) {
        $output = ""
        
        $output += [VT]::MoveTo($x, $y)
        $output += [VT]::RGB(150, 150, 200) + [VT]::Bold() + "CATEGORIES" + [VT]::Reset()
        
        $y += 2
        
        for ($i = 0; $i -lt $this.Categories.Count; $i++) {
            $category = $this.Categories[$i]
            $isSelected = ($i -eq $this.CategoryIndex)
            $isFocused = ($this.FocusedPane -eq 0)
            
            $output += [VT]::MoveTo($x, $y + $i)
            
            if ($isSelected -and $isFocused) {
                $output += [VT]::RGBBG(40, 40, 80) + " " * $w + [VT]::Reset()
                $output += [VT]::MoveTo($x, $y + $i)
                $output += [VT]::RGB(255, 255, 255) + " ▶ "
            } elseif ($isSelected) {
                $output += [VT]::RGB(200, 200, 255) + " › "
            } else {
                $output += "   "
            }
            
            $output += $category.Icon + " " + $category.Name
            
            # Show count of modified settings
            $modifiedCount = 0
            foreach ($setting in $category.Settings) {
                if ($setting.Value -ne $this.Settings[$setting.Key]) {
                    $modifiedCount++
                }
            }
            if ($modifiedCount -gt 0) {
                $output += [VT]::RGB(255, 200, 100) + " ●" + [VT]::Reset()
            }
            
            $output += [VT]::Reset()
        }
        
        return $output
    }
    
    [string] DrawSettings([int]$x, [int]$y, [int]$w) {
        $output = ""
        
        $category = $this.Categories[$this.CategoryIndex]
        
        $output += [VT]::MoveTo($x, $y)
        $output += [VT]::RGB(150, 150, 200) + [VT]::Bold() 
        $output += $category.Icon + " " + $category.Name.ToUpper() + [VT]::Reset()
        
        $y += 2
        $visibleHeight = [Console]::WindowHeight - 6
        $scrollOffset = $this.CalculateScrollOffset($visibleHeight)
        
        for ($i = $scrollOffset; $i -lt [Math]::Min($scrollOffset + $visibleHeight, $this.CurrentSettings.Count); $i++) {
            $setting = $this.CurrentSettings[$i]
            $isSelected = ($i -eq $this.SettingIndex)
            $isFocused = ($this.FocusedPane -eq 1)
            $isModified = ($setting.Value -ne $this.Settings[$setting.Key])
            
            $displayY = $y + ($i - $scrollOffset)
            $output += [VT]::MoveTo($x, $displayY)
            
            # Highlight selected
            if ($isSelected -and $isFocused) {
                $output += [VT]::RGBBG(40, 40, 80) + " " * $w + [VT]::Reset()
                $output += [VT]::MoveTo($x, $displayY)
            }
            
            # Setting name
            if ($isModified) {
                $output += [VT]::RGB(255, 200, 100) + "● "
            } else {
                $output += "  "
            }
            
            $nameColor = if ($isSelected -and $isFocused) { 
                [VT]::RGB(255, 255, 255) 
            } else { 
                [VT]::RGB(200, 200, 200) 
            }
            $output += $nameColor + $setting.Name + [VT]::Reset()
            
            # Setting value
            $valueX = $x + 25
            $output += [VT]::MoveTo($valueX, $displayY)
            
            $output += $this.RenderSettingValue($setting, $isSelected -and $isFocused)
        }
        
        # Scroll indicator
        if ($this.CurrentSettings.Count -gt $visibleHeight) {
            $this.DrawScrollIndicator($output, $x + $w - 1, $y, $visibleHeight, 
                                     $scrollOffset, $this.CurrentSettings.Count)
        }
        
        return $output
    }
    
    [string] RenderSettingValue([hashtable]$setting, [bool]$isActive) {
        $output = ""
        
        switch ($setting.Type) {
            "Bool" {
                if ($setting.Value) {
                    $output += [VT]::RGB(100, 255, 100) + "[✓] ON"
                } else {
                    $output += [VT]::RGB(150, 150, 150) + "[ ] OFF"
                }
            }
            "Choice" {
                if ($isActive) {
                    $output += [VT]::RGB(100, 200, 255) + "◄ " + $setting.Value + " ►"
                } else {
                    $output += [VT]::RGB(200, 200, 255) + $setting.Value
                }
            }
            "Number" {
                if ($isActive) {
                    $output += [VT]::RGB(255, 200, 100) + "[ " + $setting.Value + " ]"
                } else {
                    $output += [VT]::RGB(255, 255, 200) + $setting.Value.ToString()
                }
            }
            "Key" {
                $output += [VT]::RGB(255, 150, 255) + $setting.Value
            }
            "Path" {
                $truncated = if ($setting.Value.Length -gt 30) {
                    "..." + $setting.Value.Substring($setting.Value.Length - 27)
                } else {
                    $setting.Value
                }
                $output += [VT]::RGB(150, 200, 255) + $truncated
            }
        }
        
        $output += [VT]::Reset()
        return $output
    }
    
    [string] DrawHelp([int]$x, [int]$y, [int]$w) {
        $output = ""
        
        $output += [VT]::MoveTo($x, $y)
        $output += [VT]::RGB(150, 150, 200) + [VT]::Bold() + "HELP" + [VT]::Reset()
        
        $y += 2
        
        if ($this.FocusedPane -eq 1 -and $this.CurrentSettings.Count -gt 0) {
            $setting = $this.CurrentSettings[$this.SettingIndex]
            
            # Setting name
            $output += [VT]::MoveTo($x, $y)
            $output += [VT]::RGB(255, 255, 255) + $setting.Name + [VT]::Reset()
            $y += 2
            
            # Setting description (would be loaded from help data)
            $descriptions = @{
                "theme" = "Visual theme for the interface"
                "arrowMode" = "How arrow keys behave in the UI"
                "leftArrowBehavior" = "Action when pressing left arrow in panels"
                "tabWidth" = "Number of spaces for tab character"
                "renderMode" = "Balance between quality and performance"
                "autoSave" = "Automatically save changes"
            }
            
            $desc = $descriptions[$setting.Key]
            if ($desc) {
                $output += [VT]::MoveTo($x, $y)
                $words = $desc -split ' '
                $line = ""
                foreach ($word in $words) {
                    if (($line + " " + $word).Length -gt $w) {
                        $output += [VT]::RGB(180, 180, 180) + $line + [VT]::Reset()
                        $y++
                        $output += [VT]::MoveTo($x, $y)
                        $line = $word
                    } else {
                        $line = if ($line) { $line + " " + $word } else { $word }
                    }
                }
                if ($line) {
                    $output += [VT]::RGB(180, 180, 180) + $line + [VT]::Reset()
                }
                $y += 2
            }
            
            # Current value
            $output += [VT]::MoveTo($x, $y)
            $output += [VT]::RGB(150, 150, 150) + "Current: " + [VT]::Reset()
            $output += $this.RenderSettingValue($setting, $false)
            $y += 1
            
            # Default value
            if ($setting.ContainsKey('Default')) {
                $output += [VT]::MoveTo($x, $y)
                $output += [VT]::RGB(150, 150, 150) + "Default: " + $setting.Default + [VT]::Reset()
                $y += 1
            }
            
            # Type-specific help
            $y += 1
            $output += [VT]::MoveTo($x, $y)
            switch ($setting.Type) {
                "Bool" {
                    $output += [VT]::RGB(100, 150, 100) + "Press SPACE to toggle" + [VT]::Reset()
                }
                "Choice" {
                    $output += [VT]::RGB(100, 150, 100) + "Use ← → to change" + [VT]::Reset()
                }
                "Number" {
                    $output += [VT]::RGB(100, 150, 100) + "Press ENTER to edit" + [VT]::Reset()
                    if ($setting.Min -or $setting.Max) {
                        $y++
                        $output += [VT]::MoveTo($x, $y)
                        $range = "Range: "
                        if ($setting.Min) { $range += $setting.Min }
                        $range += " - "
                        if ($setting.Max) { $range += $setting.Max }
                        $output += [VT]::RGB(150, 150, 150) + $range + [VT]::Reset()
                    }
                }
                "Key" {
                    $output += [VT]::RGB(100, 150, 100) + "Press ENTER to record" + [VT]::Reset()
                }
                "Path" {
                    $output += [VT]::RGB(100, 150, 100) + "Press ENTER to browse" + [VT]::Reset()
                }
            }
        } else {
            # General help
            $helpText = @(
                "",
                "Navigate categories with",
                "arrow keys when focused",
                "on the left panel.",
                "",
                "Press TAB to switch",
                "between panels.",
                "",
                "Modified settings show",
                "an orange dot (●).",
                "",
                "Press Ctrl+S to save",
                "all changes.",
                "",
                "Press Delete to reset",
                "a setting to default."
            )
            
            foreach ($line in $helpText) {
                $output += [VT]::MoveTo($x, $y)
                $output += [VT]::RGB(150, 150, 150) + $line + [VT]::Reset()
                $y++
            }
        }
        
        return $output
    }
    
    [int] CalculateScrollOffset([int]$visibleHeight) {
        if ($this.CurrentSettings.Count -le $visibleHeight) {
            return 0
        }
        
        # Keep selected item visible
        if ($this.SettingIndex -lt $visibleHeight / 2) {
            return 0
        }
        elseif ($this.SettingIndex -gt $this.CurrentSettings.Count - $visibleHeight / 2) {
            return $this.CurrentSettings.Count - $visibleHeight
        }
        else {
            return $this.SettingIndex - [int]($visibleHeight / 2)
        }
    }
    
    [void] LoadCategorySettings() {
        $category = $this.Categories[$this.CategoryIndex]
        $this.CurrentSettings = [System.Collections.ArrayList]$category.Settings
        
        # Update values from settings storage
        foreach ($setting in $this.CurrentSettings) {
            if ($this.Settings.ContainsKey($setting.Key)) {
                $setting.Value = $this.Settings[$setting.Key]
            }
        }
        
        $this.SettingIndex = 0
    }
    
    [void] SwitchPane() {
        $this.FocusedPane = 1 - $this.FocusedPane
        $this.RequestRender()
    }
    
    [void] NavigateUp() {
        if ($this.FocusedPane -eq 0) {
            if ($this.CategoryIndex -gt 0) {
                $this.CategoryIndex--
                $this.LoadCategorySettings()
            }
        } else {
            if ($this.SettingIndex -gt 0) {
                $this.SettingIndex--
            }
        }
        $this.RequestRender()
    }
    
    [void] NavigateDown() {
        if ($this.FocusedPane -eq 0) {
            if ($this.CategoryIndex -lt $this.Categories.Count - 1) {
                $this.CategoryIndex++
                $this.LoadCategorySettings()
            }
        } else {
            if ($this.SettingIndex -lt $this.CurrentSettings.Count - 1) {
                $this.SettingIndex++
            }
        }
        $this.RequestRender()
    }
    
    [void] NavigateLeft() {
        if ($this.FocusedPane -eq 1) {
            $this.ChangeSetting(-1)
        } else {
            $this.FocusedPane = 0
        }
        $this.RequestRender()
    }
    
    [void] NavigateRight() {
        if ($this.FocusedPane -eq 1) {
            $this.ChangeSetting(1)
        } else {
            $this.FocusedPane = 1
        }
        $this.RequestRender()
    }
    
    [void] PageUp() {
        if ($this.FocusedPane -eq 1) {
            $pageSize = [Console]::WindowHeight - 10
            $this.SettingIndex = [Math]::Max(0, $this.SettingIndex - $pageSize)
        } else {
            $this.CategoryIndex = 0
        }
        $this.RequestRender()
    }
    
    [void] PageDown() {
        if ($this.FocusedPane -eq 1) {
            $pageSize = [Console]::WindowHeight - 10
            $this.SettingIndex = [Math]::Min($this.CurrentSettings.Count - 1, $this.SettingIndex + $pageSize)
        } else {
            $this.CategoryIndex = $this.Categories.Count - 1
        }
        $this.RequestRender()
    }
    
    [void] GoToTop() {
        if ($this.FocusedPane -eq 1) {
            $this.SettingIndex = 0
        } else {
            $this.CategoryIndex = 0
            $this.LoadCategorySettings()
        }
        $this.RequestRender()
    }
    
    [void] GoToBottom() {
        if ($this.FocusedPane -eq 1) {
            $this.SettingIndex = $this.CurrentSettings.Count - 1
        } else {
            $this.CategoryIndex = $this.Categories.Count - 1
            $this.LoadCategorySettings()
        }
        $this.RequestRender()
    }
    
    [void] ToggleSetting() {
        if ($this.FocusedPane -eq 1 -and $this.CurrentSettings.Count -gt 0) {
            $setting = $this.CurrentSettings[$this.SettingIndex]
            
            if ($setting.Type -eq "Bool") {
                $setting.Value = -not $setting.Value
                $this.Settings[$setting.Key] = $setting.Value
                $this.HasUnsavedChanges = $true
                $this.UpdateStatusBar()
            } elseif ($setting.Type -eq "Choice") {
                $this.ChangeSetting(1)
            }
        }
        $this.RequestRender()
    }
    
    [void] ChangeSetting([int]$direction) {
        if ($this.FocusedPane -eq 1 -and $this.CurrentSettings.Count -gt 0) {
            $setting = $this.CurrentSettings[$this.SettingIndex]
            
            switch ($setting.Type) {
                "Choice" {
                    if ($setting.Options) {
                        $currentIndex = $setting.Options.IndexOf($setting.Value)
                        if ($currentIndex -eq -1) { $currentIndex = 0 }
                        
                        $newIndex = $currentIndex + $direction
                        if ($newIndex -lt 0) {
                            $newIndex = $setting.Options.Count - 1
                        } elseif ($newIndex -ge $setting.Options.Count) {
                            $newIndex = 0
                        }
                        
                        $setting.Value = $setting.Options[$newIndex]
                        $this.Settings[$setting.Key] = $setting.Value
                        $this.HasUnsavedChanges = $true
                        $this.UpdateStatusBar()
                    }
                }
                "Number" {
                    $step = if ($setting.Step) { $setting.Step } else { 1 }
                    $newValue = $setting.Value + ($direction * $step)
                    
                    if ($setting.Min -and $newValue -lt $setting.Min) {
                        $newValue = $setting.Min
                    }
                    if ($setting.Max -and $newValue -gt $setting.Max) {
                        $newValue = $setting.Max
                    }
                    
                    $setting.Value = $newValue
                    $this.Settings[$setting.Key] = $setting.Value
                    $this.HasUnsavedChanges = $true
                    $this.UpdateStatusBar()
                }
            }
        }
    }
    
    [void] EditSetting() {
        if ($this.FocusedPane -eq 1 -and $this.CurrentSettings.Count -gt 0) {
            $setting = $this.CurrentSettings[$this.SettingIndex]
            
            # TODO: Implement inline editors for different types
            # For now, just toggle or change
            switch ($setting.Type) {
                "Bool" { $this.ToggleSetting() }
                "Choice" { $this.ChangeSetting(1) }
                "Number" { 
                    # Would open number input dialog
                    Write-Host "`nNumber editing not yet implemented" -ForegroundColor Yellow
                    Start-Sleep -Seconds 1
                }
                "Key" {
                    # Would open key recording dialog
                    Write-Host "`nKey recording not yet implemented" -ForegroundColor Yellow
                    Start-Sleep -Seconds 1
                }
                "Path" {
                    # Would open path browser
                    Write-Host "`nPath browsing not yet implemented" -ForegroundColor Yellow
                    Start-Sleep -Seconds 1
                }
            }
        }
    }
    
    [void] ResetSetting() {
        if ($this.FocusedPane -eq 1 -and $this.CurrentSettings.Count -gt 0) {
            $setting = $this.CurrentSettings[$this.SettingIndex]
            
            # Reset to default value (would be loaded from defaults)
            # For now, just show message
            Write-Host "`nReset to default not yet implemented" -ForegroundColor Yellow
            Start-Sleep -Seconds 1
        }
    }
    
    [void] SaveSettings() {
        # TODO: Implement actual saving to file
        Write-Host "`nSettings saved successfully!" -ForegroundColor Green
        $this.HasUnsavedChanges = $false
        $this.UpdateStatusBar()
        Start-Sleep -Seconds 1
    }
    
    [void] ReloadSettings() {
        # TODO: Implement reloading from file
        Write-Host "`nSettings reloaded!" -ForegroundColor Cyan
        Start-Sleep -Seconds 1
    }
    
    [void] ResetAllSettings() {
        # TODO: Implement reset all with confirmation
        Write-Host "`nReset all settings not yet implemented" -ForegroundColor Yellow
        Start-Sleep -Seconds 1
    }
    
    [void] StartSearch() {
        # TODO: Implement setting search
        Write-Host "`nSetting search not yet implemented" -ForegroundColor Yellow
        Start-Sleep -Seconds 1
    }
    
    [void] ShowHelp() {
        # TODO: Show comprehensive help screen
        Write-Host "`nHelp screen not yet implemented" -ForegroundColor Yellow
        Start-Sleep -Seconds 1
    }
    
    [void] HandleEscape() {
        if ($this.HasUnsavedChanges) {
            # TODO: Show confirmation dialog
            Write-Host "`nYou have unsaved changes! Press ESC again to discard." -ForegroundColor Yellow
            Start-Sleep -Seconds 1
        } else {
            $this.Active = $false
        }
    }
}


####\Screens/SettingsScreen.ps1
# Settings Screen

class SettingsScreen : Screen {
    [System.Collections.ArrayList]$Categories
    [System.Collections.ArrayList]$CurrentSettings
    [int]$CategoryIndex = 0
    [int]$SettingIndex = 0
    [int]$FocusedPane = 0  # 0=categories, 1=settings
    
    SettingsScreen() {
        $this.Title = "SETTINGS"
        $this.Initialize()
    }
    
    [void] Initialize() {
        # Setting categories
        $this.Categories = [System.Collections.ArrayList]@(
            @{
                Name = "Appearance"
                Icon = "🎨"
                Settings = @(
                    @{Name="Theme"; Type="Choice"; Value="Synthwave"; Options=@("Dark", "Light", "Synthwave", "Matrix", "Dracula")},
                    @{Name="Show Icons"; Type="Bool"; Value=$true},
                    @{Name="Animation Speed"; Type="Choice"; Value="Normal"; Options=@("None", "Slow", "Normal", "Fast")},
                    @{Name="Border Style"; Type="Choice"; Value="Single"; Options=@("Single", "Double", "Rounded", "ASCII")}
                )
            },
            @{
                Name = "Behavior"
                Icon = "⚙️"
                Settings = @(
                    @{Name="Auto-save"; Type="Bool"; Value=$true},
                    @{Name="Confirm Delete"; Type="Bool"; Value=$true},
                    @{Name="Default View"; Type="Choice"; Value="Tree"; Options=@("List", "Tree", "Kanban")},
                    @{Name="Task Sorting"; Type="Choice"; Value="Priority"; Options=@("Priority", "Due Date", "Created", "Title")}
                )
            },
            @{
                Name = "Shortcuts"
                Icon = "⌨️"
                Settings = @(
                    @{Name="Quick Add"; Type="Key"; Value="Ctrl+N"},
                    @{Name="Quick Search"; Type="Key"; Value="Ctrl+F"},
                    @{Name="Toggle Menu"; Type="Key"; Value="Ctrl"},
                    @{Name="Exit"; Type="Key"; Value="Ctrl+Q"}
                )
            },
            @{
                Name = "Data"
                Icon = "💾"
                Settings = @(
                    @{Name="Data Path"; Type="Path"; Value="~/.boltaxiom/data"},
                    @{Name="Backup Frequency"; Type="Choice"; Value="Daily"; Options=@("Never", "Daily", "Weekly", "Monthly")},
                    @{Name="Export Format"; Type="Choice"; Value="JSON"; Options=@("JSON", "CSV", "Markdown")}
                )
            }
        )
        
        # Load current category settings
        $this.LoadCategorySettings()
        
        # Key bindings
        $this.InitializeKeyBindings()
        
        # Status bar
        $this.UpdateStatusBar()
    }
    
    [void] InitializeKeyBindings() {
        $this.BindKey([ConsoleKey]::Tab, { $this.SwitchPane() })
        $this.BindKey([ConsoleKey]::UpArrow, { $this.NavigateUp() })
        $this.BindKey([ConsoleKey]::DownArrow, { $this.NavigateDown() })
        $this.BindKey([ConsoleKey]::LeftArrow, { $this.NavigateLeft() })
        $this.BindKey([ConsoleKey]::RightArrow, { $this.NavigateRight() })
        $this.BindKey([ConsoleKey]::Enter, { $this.ToggleSetting() })
        $this.BindKey([ConsoleKey]::Spacebar, { $this.ToggleSetting() })
        $this.BindKey([ConsoleKey]::Escape, { $this.Active = $false })
        $this.BindKey([ConsoleKey]::Backspace, { $this.Active = $false })
        
        $this.BindKey('s', { $this.SaveSettings() })
        $this.BindKey('r', { $this.ResetDefaults() })
        $this.BindKey('q', { $this.Active = $false })
    }
    
    [void] UpdateStatusBar() {
        $this.StatusBarItems.Clear()
        $this.AddStatusItem('Tab', 'switch pane')
        $this.AddStatusItem('↑↓', 'navigate')
        $this.AddStatusItem('←→', 'change value')
        $this.AddStatusItem('Space', 'toggle')
        $this.AddStatusItem('s', 'save')
        $this.AddStatusItem('r', 'reset')
        $this.AddStatusItem('Esc', 'back')
    }
    
    [string] RenderContent() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        $output = ""
        
        # Clear background by drawing spaces everywhere
        for ($y = 1; $y -le $height; $y++) {
            $output += [VT]::MoveTo(1, $y)
            $output += " " * $width
        }
        
        # Draw border
        $output += $this.DrawBorder()
        
        # Title
        $titleText = "═══ SETTINGS ═══"
        $titleX = [int](($width - $titleText.Length) / 2)
        $output += [VT]::MoveTo($titleX, 1)
        $output += [VT]::BorderActive() + $titleText + [VT]::Reset()
        
        # Two-column layout
        $leftWidth = 30
        $dividerX = $leftWidth + 2
        
        # Draw divider
        for ($y = 2; $y -lt $height - 1; $y++) {
            $output += [VT]::MoveTo($dividerX, $y)
            $output += [VT]::Border() + "│"
        }
        
        # Categories (left)
        $output += $this.DrawCategories(3, 3, $leftWidth - 3)
        
        # Settings (right)
        $output += $this.DrawSettings($dividerX + 2, 3, $width - $dividerX - 4)
        
        return $output
    }
    
    [string] DrawBorder() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        $output = ""
        
        # Top border
        $output += [VT]::MoveTo(1, 1)
        $output += [VT]::Border()
        $output += [VT]::TL() + [VT]::H() * ($width - 2) + [VT]::TR()
        
        # Sides
        for ($y = 2; $y -lt $height - 1; $y++) {
            $output += [VT]::MoveTo(1, $y) + [VT]::V()
            $output += [VT]::MoveTo($width, $y) + [VT]::V()
        }
        
        # Bottom border
        $output += [VT]::MoveTo(1, $height - 1)
        $output += [VT]::BL() + [VT]::H() * ($width - 2) + [VT]::BR()
        
        return $output
    }
    
    [string] DrawCategories([int]$x, [int]$y, [int]$w) {
        $output = ""
        
        $output += [VT]::MoveTo($x, $y)
        $output += [VT]::TextBright() + "CATEGORIES" + [VT]::Reset()
        
        $y += 2
        
        for ($i = 0; $i -lt $this.Categories.Count; $i++) {
            $category = $this.Categories[$i]
            $isSelected = ($i -eq $this.CategoryIndex)
            $isFocused = ($this.FocusedPane -eq 0)
            
            $output += [VT]::MoveTo($x, $y + $i * 2)
            
            if ($isSelected -and $isFocused) {
                $output += [VT]::Selected() + " > "
            } elseif ($isSelected) {
                $output += [VT]::TextBright() + " > "
            } else {
                $output += "   "
            }
            
            $output += $category.Icon + " " + $category.Name
            $output += [VT]::Reset()
        }
        
        return $output
    }
    
    [string] DrawSettings([int]$x, [int]$y, [int]$w) {
        $output = ""
        
        $category = $this.Categories[$this.CategoryIndex]
        
        $output += [VT]::MoveTo($x, $y)
        $output += [VT]::TextBright() + $category.Icon + " " + $category.Name.ToUpper() + " SETTINGS" + [VT]::Reset()
        
        $y += 2
        
        for ($i = 0; $i -lt $this.CurrentSettings.Count; $i++) {
            $setting = $this.CurrentSettings[$i]
            $isSelected = ($i -eq $this.SettingIndex)
            $isFocused = ($this.FocusedPane -eq 1)
            
            $output += [VT]::MoveTo($x, $y + $i * 2)
            
            # Setting name
            if ($isSelected -and $isFocused) {
                $output += [VT]::Selected() + " "
            } else {
                $output += " "
            }
            
            $output += [VT]::Text() + $setting.Name + ": "
            
            # Setting value
            $valueX = $x + 20
            $output += [VT]::MoveTo($valueX, $y + $i * 2)
            
            switch ($setting.Type) {
                "Bool" {
                    if ($setting.Value) {
                        $output += [VT]::Accent() + "[✓] Enabled"
                    } else {
                        $output += [VT]::TextDim() + "[ ] Disabled"
                    }
                }
                "Choice" {
                    if ($isSelected -and $isFocused) {
                        $output += [VT]::Accent() + "< " + $setting.Value + " >"
                    } else {
                        $output += [VT]::TextBright() + $setting.Value
                    }
                }
                "Key" {
                    $output += [VT]::Warning() + $setting.Value
                }
                "Path" {
                    $output += [VT]::Text() + $setting.Value
                }
            }
            
            $output += [VT]::Reset()
        }
        
        return $output
    }
    
    [void] LoadCategorySettings() {
        $category = $this.Categories[$this.CategoryIndex]
        $this.CurrentSettings = [System.Collections.ArrayList]$category.Settings
        $this.SettingIndex = 0
    }
    
    [void] SwitchPane() {
        $this.FocusedPane = 1 - $this.FocusedPane
    }
    
    [void] NavigateUp() {
        if ($this.FocusedPane -eq 0) {
            if ($this.CategoryIndex -gt 0) {
                $this.CategoryIndex--
                $this.LoadCategorySettings()
            }
        } else {
            if ($this.SettingIndex -gt 0) {
                $this.SettingIndex--
            }
        }
    }
    
    [void] NavigateDown() {
        if ($this.FocusedPane -eq 0) {
            if ($this.CategoryIndex -lt $this.Categories.Count - 1) {
                $this.CategoryIndex++
                $this.LoadCategorySettings()
            }
        } else {
            if ($this.SettingIndex -lt $this.CurrentSettings.Count - 1) {
                $this.SettingIndex++
            }
        }
    }
    
    [void] NavigateLeft() {
        if ($this.FocusedPane -eq 1) {
            $this.ChangeSetting(-1)
        } else {
            $this.FocusedPane = 0
        }
    }
    
    [void] NavigateRight() {
        if ($this.FocusedPane -eq 1) {
            $this.ChangeSetting(1)
        } else {
            $this.FocusedPane = 1
        }
    }
    
    [void] ToggleSetting() {
        if ($this.FocusedPane -eq 1 -and $this.CurrentSettings.Count -gt 0) {
            $setting = $this.CurrentSettings[$this.SettingIndex]
            
            if ($setting.Type -eq "Bool") {
                $setting.Value = -not $setting.Value
            } elseif ($setting.Type -eq "Choice") {
                $this.ChangeSetting(1)
            }
        }
    }
    
    [void] ChangeSetting([int]$direction) {
        if ($this.FocusedPane -eq 1 -and $this.CurrentSettings.Count -gt 0) {
            $setting = $this.CurrentSettings[$this.SettingIndex]
            
            if ($setting.Type -eq "Choice" -and $setting.Options) {
                $currentIndex = $setting.Options.IndexOf($setting.Value)
                $newIndex = $currentIndex + $direction
                
                if ($newIndex -lt 0) {
                    $newIndex = $setting.Options.Count - 1
                } elseif ($newIndex -ge $setting.Options.Count) {
                    $newIndex = 0
                }
                
                $setting.Value = $setting.Options[$newIndex]
            }
        }
    }
    
    [void] SaveSettings() {
        Write-Host "`nSettings saved!" -ForegroundColor Green
        Start-Sleep -Seconds 1
    }
    
    [void] ResetDefaults() {
        Write-Host "`nReset to defaults!" -ForegroundColor Yellow
        Start-Sleep -Seconds 1
    }
}


####\Screens/taskscreen.ps1
# Task Management Screen with Three-Pane Layout

class TaskScreen {
    [ThreePaneLayout]$Layout
    [System.Collections.ArrayList]$Tasks
    [System.Collections.ArrayList]$Filters
    [int]$FilterIndex = 0
    [int]$TaskIndex = 0
    [string]$CurrentFilter = "All"
    [System.Collections.ArrayList]$FilteredTasks
    
    TaskScreen() {
        # Initialize layout with perfect column alignment
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        # Calculate pane widths for perfect alignment
        $leftWidth = 20
        $rightWidth = 30
        $middleWidth = $width - $leftWidth - $rightWidth
        
        $this.Layout = [ThreePaneLayout]::new($width, $height, $leftWidth, $middleWidth)
        $this.Layout.LeftPane.Title = "FILTERS"
        $this.Layout.MiddlePane.Title = "TASKS"
        $this.Layout.RightPane.Title = "DETAIL"
        
        # Initialize data
        $this.Tasks = [System.Collections.ArrayList]::new()
        $this.FilteredTasks = [System.Collections.ArrayList]::new()
        $this.InitializeFilters()
        $this.LoadTasks()
        $this.ApplyFilter()
    }
    
    [void] InitializeFilters() {
        $this.Filters = [System.Collections.ArrayList]@(
            @{Name="All"; Count=0; Filter={$true}},
            @{Name="Today"; Count=0; Filter={$_.DueDate.Date -eq [datetime]::Today}},
            @{Name="This Week"; Count=0; Filter={$_.DueDate -ge [datetime]::Today -and $_.DueDate -le [datetime]::Today.AddDays(7)}},
            @{Name="Overdue"; Count=0; Filter={$_.IsOverdue()}},
            @{Name="──────────"; Count=0; Filter=$null},  # Separator
            @{Name="Pending"; Count=0; Filter={$_.Status -eq "Pending"}},
            @{Name="In Progress"; Count=0; Filter={$_.Status -eq "InProgress"}},
            @{Name="Completed"; Count=0; Filter={$_.Status -eq "Completed"}}
        )
    }
    
    [void] LoadTasks() {
        # Load sample tasks for now
        $this.Tasks.Add([Task]::new("Fix login bug")) | Out-Null
        $this.Tasks[0].Status = "InProgress"
        $this.Tasks[0].Priority = "High"
        $this.Tasks[0].Progress = 75
        $this.Tasks[0].Description = "Users report intermittent login failures after the latest deployment."
        $this.Tasks[0].DueDate = [datetime]::Today
        
        $this.Tasks.Add([Task]::new("Review PR #234")) | Out-Null
        $this.Tasks[1].DueDate = [datetime]::Today.AddDays(-2)
        
        $this.Tasks.Add([Task]::new("Update documentation")) | Out-Null
        $this.Tasks[2].Priority = "Low"
        
        $this.Tasks.Add([Task]::new("Deploy to staging")) | Out-Null
        $this.Tasks[3].Status = "Completed"
        
        $this.Tasks.Add([Task]::new("Test new API endpoint")) | Out-Null
        $this.Tasks[4].DueDate = [datetime]::Today.AddDays(3)
    }
    
    [void] UpdateFilterCounts() {
        foreach ($filter in $this.Filters) {
            if ($filter.Filter) {
                $filter.Count = ($this.Tasks | Where-Object $filter.Filter).Count
            }
        }
    }
    
    [void] ApplyFilter() {
        $this.UpdateFilterCounts()
        $filter = $this.Filters[$this.FilterIndex]
        
        if ($filter.Filter) {
            $this.FilteredTasks = [System.Collections.ArrayList]@($this.Tasks | Where-Object $filter.Filter)
            $this.CurrentFilter = $filter.Name
        } else {
            $this.FilteredTasks = $this.Tasks
        }
        
        # Ensure task index is valid
        if ($this.TaskIndex -ge $this.FilteredTasks.Count) {
            $this.TaskIndex = [Math]::Max(0, $this.FilteredTasks.Count - 1)
        }
    }
    
    [void] UpdateLeftPane() {
        $this.Layout.LeftPane.Content.Clear()
        
        for ($i = 0; $i -lt $this.Filters.Count; $i++) {
            $filter = $this.Filters[$i]
            
            if ($filter.Name -eq "──────────") {
                $this.Layout.LeftPane.Content.Add([VT]::TextDim() + "─" * 18) | Out-Null
                continue
            }
            
            $line = ""
            if ($i -eq $this.FilterIndex -and $this.Layout.FocusedPane -eq 0) {
                $line += [VT]::Selected() + " > "
            } else {
                $line += "   "
            }
            
            $line += $filter.Name
            if ($filter.Count -gt 0) {
                $countText = " ($($filter.Count))"
                $padding = 15 - $filter.Name.Length
                if ($padding -gt 0) {
                    $line += " " * $padding
                }
                $line += [VT]::TextDim() + $countText
            }
            
            $line += [VT]::Reset()
            $this.Layout.LeftPane.Content.Add($line) | Out-Null
        }
    }
    
    [void] UpdateMiddlePane() {
        $this.Layout.MiddlePane.Content.Clear()
        $this.Layout.MiddlePane.Title = "TASKS - $($this.CurrentFilter) ($($this.FilteredTasks.Count))"
        
        # Column headers
        $header = [VT]::TextDim() + " S  TITLE" + " " * 20 + "PRI  PROG  DUE" + [VT]::Reset()
        $this.Layout.MiddlePane.Content.Add($header) | Out-Null
        $this.Layout.MiddlePane.Content.Add([VT]::TextDim() + "─" * ($this.Layout.MiddlePane.Width - 2) + [VT]::Reset()) | Out-Null
        
        # Task list
        for ($i = 0; $i -lt $this.FilteredTasks.Count; $i++) {
            $task = $this.FilteredTasks[$i]
            $line = ""
            
            # Selection indicator
            if ($i -eq $this.TaskIndex -and $this.Layout.FocusedPane -eq 1) {
                $line += [VT]::Selected()
            }
            
            # Status
            $line += " " + $task.GetStatusColor() + $task.GetStatusSymbol() + "  "
            
            # Title (truncated to fit)
            $titleWidth = $this.Layout.MiddlePane.Width - 20
            $title = [Measure]::Pad($task.Title, $titleWidth, "Left")
            if ($task.IsOverdue()) {
                $line += [VT]::Error() + $title
            } else {
                $line += [VT]::TextBright() + $title
            }
            
            # Priority
            $line += " " + $task.GetPriorityColor() + $task.GetPrioritySymbol() + "  "
            
            # Progress
            if ($task.Progress -gt 0) {
                $line += [VT]::Text() + $task.Progress.ToString().PadLeft(3) + "%"
            } else {
                $line += "    "
            }
            
            # Due date
            if ($task.DueDate) {
                $daysUntil = ($task.DueDate.Date - [datetime]::Today).Days
                if ($daysUntil -eq 0) {
                    $line += [VT]::Warning() + " Today"
                } elseif ($daysUntil -lt 0) {
                    $line += [VT]::Error() + " -$(-$daysUntil)d"
                } else {
                    $line += [VT]::Text() + " +${daysUntil}d"
                }
            }
            
            $line += [VT]::Reset()
            $this.Layout.MiddlePane.Content.Add($line) | Out-Null
        }
    }
    
    [void] UpdateRightPane() {
        $this.Layout.RightPane.Content.Clear()
        
        if ($this.FilteredTasks.Count -eq 0) {
            $this.Layout.RightPane.Content.Add([VT]::TextDim() + " No tasks") | Out-Null
            return
        }
        
        $task = $this.FilteredTasks[$this.TaskIndex]
        
        # Title
        $this.Layout.RightPane.Content.Add([VT]::TextBright() + " " + $task.Title) | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " " + "─" * ($this.Layout.RightPane.Width - 3)) | Out-Null
        $this.Layout.RightPane.Content.Add("") | Out-Null
        
        # Description
        if ($task.Description) {
            $words = $task.Description -split ' '
            $line = " "
            $maxWidth = $this.Layout.RightPane.Width - 3
            
            foreach ($word in $words) {
                if (($line + $word).Length -gt $maxWidth) {
                    $this.Layout.RightPane.Content.Add([VT]::Text() + $line) | Out-Null
                    $line = " $word"
                } else {
                    if ($line -eq " ") {
                        $line = " $word"
                    } else {
                        $line += " $word"
                    }
                }
            }
            if ($line.Trim()) {
                $this.Layout.RightPane.Content.Add([VT]::Text() + $line) | Out-Null
            }
            $this.Layout.RightPane.Content.Add("") | Out-Null
        }
        
        # Status
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Status: " + $task.GetStatusColor() + $task.Status) | Out-Null
        
        # Priority
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Priority: " + $task.GetPriorityColor() + $task.Priority + " " + $task.GetPrioritySymbol()) | Out-Null
        
        # Progress
        if ($task.Progress -gt 0) {
            $bar = "█" * [int]($task.Progress / 10) + "░" * [int]((100 - $task.Progress) / 10)
            $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Progress: " + [VT]::Accent() + $bar + " " + $task.Progress + "%") | Out-Null
        }
        
        # Due date
        if ($task.DueDate) {
            $dueText = $task.DueDate.ToString("MMM d, yyyy")
            if ($task.IsOverdue()) {
                $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Due: " + [VT]::Error() + $dueText + " (OVERDUE)") | Out-Null
            } else {
                $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Due: " + [VT]::Text() + $dueText) | Out-Null
            }
        }
        
        # Actions
        $this.Layout.RightPane.Content.Add("") | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " " + "─" * ($this.Layout.RightPane.Width - 3)) | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::Text() + " [Enter] edit") | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::Text() + " [t] log time") | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::Text() + " [s] change status") | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::Text() + " [p] change priority") | Out-Null
    }
    
    [void] Render() {
        $this.UpdateLeftPane()
        $this.UpdateMiddlePane()
        $this.UpdateRightPane()
        
        $output = $this.Layout.Render()
        $status = " [a]dd [d]elete [e]dit [space]toggle [p]riority [/]search [tab]switch pane [q]uit"
        $output += $this.Layout.DrawStatusBar($status)
        
        [Console]::Write($output)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Tab) {
                # Cycle through panes
                $this.Layout.SetFocus(($this.Layout.FocusedPane + 1) % 3)
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this.Layout.FocusedPane -gt 0) {
                    $this.Layout.SetFocus($this.Layout.FocusedPane - 1)
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.Layout.FocusedPane -lt 2) {
                    $this.Layout.SetFocus($this.Layout.FocusedPane + 1)
                }
            }
            ([ConsoleKey]::UpArrow) {
                switch ($this.Layout.FocusedPane) {
                    0 { # Filter pane
                        if ($this.FilterIndex -gt 0) {
                            $this.FilterIndex--
                            if ($this.Filters[$this.FilterIndex].Name -eq "──────────") {
                                $this.FilterIndex--
                            }
                            $this.ApplyFilter()
                        }
                    }
                    1 { # Task pane
                        if ($this.TaskIndex -gt 0) {
                            $this.TaskIndex--
                        }
                    }
                }
            }
            ([ConsoleKey]::DownArrow) {
                switch ($this.Layout.FocusedPane) {
                    0 { # Filter pane
                        if ($this.FilterIndex -lt $this.Filters.Count - 1) {
                            $this.FilterIndex++
                            if ($this.Filters[$this.FilterIndex].Name -eq "──────────") {
                                $this.FilterIndex++
                            }
                            $this.ApplyFilter()
                        }
                    }
                    1 { # Task pane
                        if ($this.TaskIndex -lt $this.FilteredTasks.Count - 1) {
                            $this.TaskIndex++
                        }
                    }
                }
            }
            ([ConsoleKey]::Enter) {
                if ($this.Layout.FocusedPane -eq 0) {
                    # Apply filter
                    $this.ApplyFilter()
                    $this.Layout.SetFocus(1)  # Move to task list
                }
            }
        }
        
        # Handle character keys
        switch ($key.KeyChar) {
            ' ' { # Toggle task status
                if ($this.FilteredTasks.Count -gt 0) {
                    $task = $this.FilteredTasks[$this.TaskIndex]
                    switch ($task.Status) {
                        "Pending" { $task.Status = "InProgress" }
                        "InProgress" { $task.Status = "Completed" }
                        "Completed" { $task.Status = "Pending" }
                    }
                    $task.Update()
                }
            }
            'p' { # Change priority
                if ($this.FilteredTasks.Count -gt 0) {
                    $task = $this.FilteredTasks[$this.TaskIndex]
                    switch ($task.Priority) {
                        "Low" { $task.Priority = "Medium" }
                        "Medium" { $task.Priority = "High" }
                        "High" { $task.Priority = "Low" }
                    }
                    $task.Update()
                }
            }
        }
    }
}


####\Screens/TaskScreen.ps1
# Task Management Screen - Refactored

class TaskScreen : Screen {
    # Layout
    [ThreePaneLayout]$Layout
    
    # Services
    hidden [TaskService]$TaskService
    hidden [ViewDefinitionService]$ViewService
    
    # Data
    [System.Collections.ArrayList]$Tasks
    [System.Collections.ArrayList]$FilteredTasks
    [System.Collections.ArrayList]$Filters
    
    # State
    [int]$FilterIndex = 0
    [int]$TaskIndex = 0
    [string]$CurrentFilter = "All"
    [bool]$ShowTree = $true
    
    # Inline edit
    [bool]$InlineEditMode = $false
    [Task]$EditingTask = $null
    [string]$EditBuffer = ""
    
    # Menu mode
    [bool]$MenuMode = $false
    [int]$MenuIndex = 0
    
    TaskScreen() {
        $this.Title = "TASK MANAGER"
        $this.Initialize()
    }
    
    [void] Initialize() {
        # Get services
        $this.TaskService = $global:ServiceContainer.GetService("TaskService")
        $this.ViewService = $global:ServiceContainer.GetService("ViewDefinitionService")
        
        # Setup layout
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        $this.Layout = [ThreePaneLayout]::new($width, $height, 18, 35)
        $this.Layout.LeftPane.Title = "FILTERS"
        $this.Layout.MiddlePane.Title = "TASKS"
        $this.Layout.RightPane.Title = "DETAIL"
        
        # Initialize data
        $this.Tasks = [System.Collections.ArrayList]::new()
        $this.FilteredTasks = [System.Collections.ArrayList]::new()
        $this.InitializeFilters()
        $this.LoadTasks()
        $this.ApplyFilter()
        
        # Setup key bindings
        $this.InitializeKeyBindings()
        
        # Setup status bar
        $this.UpdateStatusBar()
    }
    
    [void] InitializeKeyBindings() {
        # Navigation
        $this.BindKey([ConsoleKey]::Tab, { $this.Layout.FocusNext(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::UpArrow, { $this.NavigateUp(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::DownArrow, { $this.NavigateDown(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::LeftArrow, { $this.NavigateLeft(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::RightArrow, { $this.NavigateRight(); $this.RequestRender() })
        $this.BindKey([ConsoleKey]::Enter, { $this.HandleEnter(); $this.RequestRender() })
        
        # Actions (case-sensitive)
        $this.BindKey('a', { $this.AddTask(); $this.RequestRender() })
        $this.BindKey('A', { $this.AddTaskFull(); $this.RequestRender() })
        $this.BindKey('s', { $this.AddSubtask(); $this.RequestRender() })
        $this.BindKey('d', { $this.DeleteTask(); $this.RequestRender() })
        $this.BindKey('e', { $this.EditTaskInline(); $this.RequestRender() })
        $this.BindKey('E', { $this.EditTaskDetails(); $this.RequestRender() })
        $this.BindKey(' ', { $this.ToggleStatus(); $this.RequestRender() })
        $this.BindKey('p', { $this.CyclePriority(); $this.RequestRender() })
        $this.BindKey('x', { $this.ExpandCollapseAll(); $this.RequestRender() })
        $this.BindKey('q', { $this.Active = $false })
    }
    
    [void] UpdateStatusBar() {
        $this.StatusBarItems.Clear()
        
        if ($this.InlineEditMode) {
            $editType = if ($this.EditingTask.ParentId) { "SUBTASK" } else { "TASK" }
            $this.StatusBarItems.Add(@{
                Label = [VT]::RGBBG(255, 255, 0) + [VT]::RGB(0, 0, 0) + 
                       " >>> EDITING $($editType): " + $this.EditBuffer + " <<< " + 
                       [VT]::Reset()
            }) | Out-Null
            $this.StatusBarItems.Add(@{Label = "[Enter]save [Esc]cancel"}) | Out-Null
        } elseif ($this.MenuMode) {
            # Menu mode - not implemented in refactor yet
            $this.StatusBarItems.Add(@{Label = "Menu Mode"}) | Out-Null
        } else {
            # Normal mode
            $this.AddStatusItem('a/A', 'add/full')
            $this.AddStatusItem('s', 'subtask')
            $this.AddStatusItem('d', 'delete')
            $this.AddStatusItem('e/E', 'edit/full')
            $this.AddStatusItem(' ', 'toggle')
            $this.AddStatusItem('p', 'priority')
            $this.AddStatusItem('x', 'expand')
            $this.AddStatusItem('q', 'quit')
            $this.StatusBarItems.Add(@{Label = "[Tab]switch"}) | Out-Null
        }
    }
    
    [void] InitializeFilters() {
        $this.Filters = [System.Collections.ArrayList]@(
            @{Name="All"; Count=0; Filter={$true}},
            @{Name="Today"; Count=0; Filter={$_.DueDate -and $_.DueDate.Date -eq [datetime]::Today}},
            @{Name="This Week"; Count=0; Filter={$_.DueDate -and $_.DueDate -ge [datetime]::Today -and $_.DueDate -le [datetime]::Today.AddDays(7)}},
            @{Name="Overdue"; Count=0; Filter={$_.IsOverdue()}},
            @{Name="────────────"; Count=0; Filter=$null},
            @{Name="Pending"; Count=0; Filter={$_.Status -eq "Pending"}},
            @{Name="In Progress"; Count=0; Filter={$_.Status -eq "InProgress"}},
            @{Name="Completed"; Count=0; Filter={$_.Status -eq "Completed"}}
        )
    }
    
    [void] LoadTasks() {
        # Load tasks from service
        if ($this.TaskService) {
            $allTasks = $this.TaskService.GetAllTasks()
            $this.Tasks.Clear()
            foreach ($task in $allTasks) {
                $this.Tasks.Add($task) | Out-Null
            }
        }
        
        # If no tasks exist, add some sample tasks
        if ($this.Tasks.Count -eq 0) {
            # Sample tasks with subtasks
            $loginBug = $this.TaskService.AddTask("Fix login bug")
            $loginBug.Status = "InProgress"
            $loginBug.Priority = "High"
            $loginBug.Progress = 75
            $loginBug.Description = "Users report intermittent login failures after the latest deployment."
            $loginBug.DueDate = [datetime]::Today
            $this.TaskService.UpdateTask($loginBug)
            
            # Add subtasks
            $sub1 = $this.TaskService.AddTask("Reproduce the issue locally")
            $sub1.Status = "Completed"
            $sub1.ParentId = $loginBug.Id
            $this.TaskService.UpdateTask($sub1)
            $loginBug.SubtaskIds.Add($sub1.Id) | Out-Null
            
            $sub2 = $this.TaskService.AddTask("Debug authentication flow")
            $sub2.Status = "InProgress"
            $sub2.ParentId = $loginBug.Id
            $this.TaskService.UpdateTask($sub2)
            $loginBug.SubtaskIds.Add($sub2.Id) | Out-Null
            
            # More sample tasks...
            $task2 = $this.TaskService.AddTask("Review PR #234")
            $task2.DueDate = [datetime]::Today.AddDays(-2)
            $this.TaskService.UpdateTask($task2)
            
            $task3 = $this.TaskService.AddTask("Update documentation")
            $task3.Priority = "Low"
            $this.TaskService.UpdateTask($task3)
            
            # Reload tasks after adding samples
            $this.LoadTasks()
        }
    }
    
    [string] RenderContent() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        $output = ""
        
        # Clear background by drawing spaces everywhere
        for ($y = 1; $y -le $height; $y++) {
            $output += [VT]::MoveTo(1, $y)
            $output += " " * $width
        }
        
        # Update all panes first
        $this.UpdateLeftPane()
        $this.UpdateMiddlePane()
        $this.UpdateRightPane()
        
        # Render layout in one pass
        $output += $this.Layout.Render()
        
        return $output
    }
    
    # Override to use double buffering
    [void] RenderToBuffer([Buffer]$buffer) {
        # For now, fall back to string-based rendering
        # This ensures compatibility while providing the framework for optimization
        $content = $this.RenderContent()
        $statusBar = $this.RenderStatusBar()
        
        # Simple implementation - write the full screen
        $lines = ($content + $statusBar) -split "`n"
        $y = 0
        foreach ($line in $lines) {
            if ($y -lt $buffer.Height) {
                # Strip ANSI codes for now - proper parsing would be better
                $cleanLine = $line -replace '\x1b\[[0-9;]*m', ''
                for ($x = 0; $x -lt [Math]::Min($cleanLine.Length, $buffer.Width); $x++) {
                    $buffer.SetCell($x, $y, $cleanLine[$x], '#FFFFFF', '#000000')
                }
                $y++
            }
        }
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        # Handle inline edit mode first
        if ($this.InlineEditMode) {
            $this.HandleInlineEdit($key)
            $this.RequestRender()
            return
        }
        
        # Handle Ctrl for menu mode
        if ($key.Modifiers -eq [ConsoleModifiers]::Control) {
            $this.MenuMode = -not $this.MenuMode
            $this.UpdateStatusBar()
            $this.RequestRender()
            return
        }
        
        # Normal input handling
        ([Screen]$this).HandleInput($key)
    }
    
    [void] HandleInlineEdit([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) {
                # Save edit
                $this.EditingTask.Title = $this.EditBuffer
                $this.TaskService.UpdateTask($this.EditingTask)
                $this.InlineEditMode = $false
                $this.EditingTask = $null
                $this.EditBuffer = ""
                $this.UpdateStatusBar()
                $this.RequestRender()
            }
            ([ConsoleKey]::Escape) {
                # Cancel edit
                $this.InlineEditMode = $false
                $this.EditingTask = $null
                $this.EditBuffer = ""
                $this.UpdateStatusBar()
                $this.RequestRender()
            }
            ([ConsoleKey]::Backspace) {
                if ($this.EditBuffer.Length -gt 0) {
                    $this.EditBuffer = $this.EditBuffer.Substring(0, $this.EditBuffer.Length - 1)
                    $this.UpdateStatusBar()
                    $this.RequestRender()
                }
            }
            default {
                # Add character if printable
                if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or 
                    $key.KeyChar -eq ' ' -or [char]::IsPunctuation($key.KeyChar) -or
                    [char]::IsSymbol($key.KeyChar)) {
                    $this.EditBuffer += $key.KeyChar
                    $this.UpdateStatusBar()
                    $this.RequestRender()
                }
            }
        }
    }
    
    # Navigation methods
    [void] NavigateUp() {
        switch ($this.Layout.FocusedPane) {
            0 { # Filter pane
                if ($this.FilterIndex -gt 0) {
                    $this.FilterIndex--
                    if ($this.Filters[$this.FilterIndex].Name -like "───*") {
                        $this.FilterIndex--
                    }
                    $this.ApplyFilter()
                }
            }
            1 { # Task pane
                if ($this.TaskIndex -gt 0) {
                    $this.TaskIndex--
                }
            }
        }
    }
    
    [void] NavigateDown() {
        switch ($this.Layout.FocusedPane) {
            0 { # Filter pane
                if ($this.FilterIndex -lt $this.Filters.Count - 1) {
                    $this.FilterIndex++
                    if ($this.Filters[$this.FilterIndex].Name -like "───*") {
                        if ($this.FilterIndex -lt $this.Filters.Count - 1) {
                            $this.FilterIndex++
                        }
                    }
                    $this.ApplyFilter()
                }
            }
            1 { # Task pane
                if ($this.TaskIndex -lt $this.FilteredTasks.Count - 1) {
                    $this.TaskIndex++
                }
            }
        }
    }
    
    [void] NavigateLeft() {
        if ($this.Layout.FocusedPane -eq 1) {
            # Move focus to left pane
            $this.Layout.SetFocus(0)
        } elseif ($this.Layout.FocusedPane -eq 0) {
            # In left pane, go back to main menu
            $this.Active = $false
        }
    }
    
    [void] NavigateRight() {
        if ($this.Layout.FocusedPane -eq 0) {
            $this.Layout.SetFocus(1)
        }
    }
    
    [void] HandleEnter() {
        if ($this.Layout.FocusedPane -eq 0) {
            # Apply filter and move to task list
            $this.ApplyFilter()
            $this.Layout.SetFocus(1)
        } elseif ($this.Layout.FocusedPane -eq 1 -and $this.FilteredTasks.Count -gt 0) {
            # Toggle expand/collapse if task has children
            $task = $this.FilteredTasks[$this.TaskIndex]
            if ($task.SubtaskIds.Count -gt 0) {
                $task.IsExpanded = -not $task.IsExpanded
                $this.ApplyFilter()
                
                # Maintain selection
                for ($i = 0; $i -lt $this.FilteredTasks.Count; $i++) {
                    if ($this.FilteredTasks[$i].Id -eq $task.Id) {
                        $this.TaskIndex = $i
                        break
                    }
                }
            }
        }
    }
    
    # Action methods
    [void] AddTask() {
        $newTask = $this.TaskService.AddTask("")
        $this.Tasks.Add($newTask) | Out-Null
        $this.ApplyFilter()
        
        # Find and select
        for ($i = 0; $i -lt $this.FilteredTasks.Count; $i++) {
            if ($this.FilteredTasks[$i].Id -eq $newTask.Id) {
                $this.TaskIndex = $i
                break
            }
        }
        
        # Enter inline edit
        $this.InlineEditMode = $true
        $this.EditingTask = $newTask
        $this.EditBuffer = ""
        $this.Layout.SetFocus(1)
        $this.UpdateStatusBar()
    }
    
    [void] AddTaskFull() {
        # Create new task and open full edit dialog
        $newTask = $this.TaskService.AddTask("New Task")
        $dialog = New-Object -TypeName "EditDialog" -ArgumentList $this, $newTask, $true
        
        # Store reference to task list for adding after dialog
        $dialog | Add-Member -NotePropertyName ParentTaskScreen -NotePropertyValue $this
        $dialog | Add-Member -NotePropertyName NewTask -NotePropertyValue $newTask
        
        # Push dialog to screen manager
        $global:ScreenManager.Push($dialog)
    }
    
    [void] AddSubtask() {
        if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
            $parentTask = $this.FilteredTasks[$this.TaskIndex]
            
            $subtask = New-Object -TypeName "Task" -ArgumentList ""
            $subtask.ParentId = $parentTask.Id
            $this.Tasks.Add($subtask) | Out-Null
            $parentTask.SubtaskIds.Add($subtask.Id) | Out-Null
            $parentTask.IsExpanded = $true
            
            $this.ApplyFilter()
            
            # Find and select
            for ($i = 0; $i -lt $this.FilteredTasks.Count; $i++) {
                if ($this.FilteredTasks[$i].Id -eq $subtask.Id) {
                    $this.TaskIndex = $i
                    break
                }
            }
            
            # Enter inline edit
            $this.InlineEditMode = $true
            $this.EditingTask = $subtask
            $this.EditBuffer = ""
            $this.UpdateStatusBar()
        }
    }
    
    [void] DeleteTask() {
        if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
            $task = $this.FilteredTasks[$this.TaskIndex]
            $dialog = New-Object -TypeName "DeleteConfirmDialog" -ArgumentList $this, $task.Title
            
            # Store reference to task for deletion after dialog
            $dialog | Add-Member -NotePropertyName TaskToDelete -NotePropertyValue $task
            $dialog | Add-Member -NotePropertyName ParentTaskScreen -NotePropertyValue $this
            
            # Push dialog to screen manager
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditTaskInline() {
        if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
            $this.InlineEditMode = $true
            $this.EditingTask = $this.FilteredTasks[$this.TaskIndex]
            $this.EditBuffer = $this.EditingTask.Title
            $this.UpdateStatusBar()
            $this.RequestRender()
        }
    }
    
    [void] EditTaskDetails() {
        if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
            $task = $this.FilteredTasks[$this.TaskIndex]
            $dialog = New-Object -TypeName "EditDialog" -ArgumentList $this, $task, $false
            
            # Store reference to parent for refresh after dialog
            $dialog | Add-Member -NotePropertyName ParentTaskScreen -NotePropertyValue $this
            
            # Push dialog to screen manager
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] ToggleStatus() {
        if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
            $task = $this.FilteredTasks[$this.TaskIndex]
            switch ($task.Status) {
                "Pending" { $task.Status = "InProgress" }
                "InProgress" { $task.Status = "Completed" }
                "Completed" { $task.Status = "Pending" }
            }
            $task.Update()
        }
    }
    
    [void] CyclePriority() {
        if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
            $task = $this.FilteredTasks[$this.TaskIndex]
            switch ($task.Priority) {
                "Low" { $task.Priority = "Medium" }
                "Medium" { $task.Priority = "High" }
                "High" { $task.Priority = "Low" }
            }
            $task.Update()
        }
    }
    
    [void] UpdateMiddlePaneWithViewService() {
        # Use ViewDefinitionService for consistent formatting
        $view = $this.ViewService.GetView("TaskList")
        if (-not $view) { 
            # Fallback to standard rendering
            $this.UpdateMiddlePane()
            return 
        }
        
        # Headers from view definition
        $header = [VT]::TextDim() + " "
        foreach ($col in $view.Columns) {
            $header += $col.Name.PadRight($col.Width) + " "
        }
        $header += [VT]::Reset()
        $this.Layout.MiddlePane.Content.Add($header) | Out-Null
        
        $separatorWidth = [Math]::Max(10, $this.Layout.MiddlePane.Width - 2)
        $this.Layout.MiddlePane.Content.Add([VT]::TextDim() + ("─" * $separatorWidth) + [VT]::Reset()) | Out-Null
        
        # Render tasks using view definition
        for ($i = 0; $i -lt $this.FilteredTasks.Count; $i++) {
            $task = $this.FilteredTasks[$i]
            $line = ""
            
            # Selection highlighting
            if ($i -eq $this.TaskIndex -and $this.Layout.FocusedPane -eq 1) {
                if ($this.InlineEditMode -and $task.Id -eq $this.EditingTask.Id) {
                    $line += [VT]::RGBBG(255, 255, 0) + [VT]::RGB(0, 0, 0)
                } else {
                    $line += [VT]::Selected()
                }
            }
            
            # Use view definition to format row
            $line += " " + $view.FormatRow($task)
            $line += [VT]::Reset()
            
            $this.Layout.MiddlePane.Content.Add($line) | Out-Null
        }
    }
    
    [void] ExpandCollapseAll() {
        $allExpanded = $true
        foreach ($task in $this.Tasks) {
            if ($task.SubtaskIds.Count -gt 0 -and -not $task.IsExpanded) {
                $allExpanded = $false
                break
            }
        }
        
        foreach ($task in $this.Tasks) {
            if ($task.SubtaskIds.Count -gt 0) {
                $task.IsExpanded = -not $allExpanded
            }
        }
        
        $this.ApplyFilter()
    }
    
    # Filter and tree methods
    [void] ApplyFilter() {
        $this.UpdateFilterCounts()
        $filter = $this.Filters[$this.FilterIndex]
        
        if ($filter.Filter) {
            $this.FilteredTasks = [System.Collections.ArrayList]@($this.Tasks | Where-Object $filter.Filter)
            $this.CurrentFilter = $filter.Name
        } else {
            $this.FilteredTasks = $this.Tasks
        }
        
        # Build tree if enabled
        if ($this.ShowTree) {
            $this.FilteredTasks = $this.BuildTreeView($this.FilteredTasks)
        }
        
        # Ensure valid index
        if ($this.TaskIndex -ge $this.FilteredTasks.Count) {
            $this.TaskIndex = [Math]::Max(0, $this.FilteredTasks.Count - 1)
        }
    }
    
    [void] UpdateFilterCounts() {
        foreach ($filter in $this.Filters) {
            if ($filter.Filter) {
                $filter.Count = ($this.Tasks | Where-Object $filter.Filter).Count
            }
        }
    }
    
    [System.Collections.ArrayList] BuildTreeView([System.Collections.ArrayList]$tasks) {
        $tree = [System.Collections.ArrayList]::new()
        $taskDict = @{}
        
        foreach ($task in $tasks) {
            $taskDict[$task.Id] = $task
        }
        
        foreach ($task in $tasks) {
            if (-not $task.ParentId -or -not $taskDict.ContainsKey($task.ParentId)) {
                $task.Level = 0
                $tree.Add($task) | Out-Null
                if ($task.IsExpanded -and $task.SubtaskIds.Count -gt 0) {
                    $this.AddSubtasksToTree($tree, $task, $taskDict, 1)
                }
            }
        }
        
        return $tree
    }
    
    [void] AddSubtasksToTree([System.Collections.ArrayList]$tree, [Task]$parentTask, [hashtable]$taskDict, [int]$level) {
        foreach ($subtaskId in $parentTask.SubtaskIds) {
            if ($taskDict.ContainsKey($subtaskId)) {
                $subtask = $taskDict[$subtaskId]
                $subtask.Level = $level
                $tree.Add($subtask) | Out-Null
                
                if ($subtask.IsExpanded -and $subtask.SubtaskIds.Count -gt 0) {
                    $this.AddSubtasksToTree($tree, $subtask, $taskDict, $level + 1)
                }
            }
        }
    }
    
    # Pane update methods
    [void] UpdateLeftPane() {
        $this.Layout.LeftPane.Content.Clear()
        
        for ($i = 0; $i -lt $this.Filters.Count; $i++) {
            $filter = $this.Filters[$i]
            
            if ($filter.Name -like "───*") {
                $this.Layout.LeftPane.Content.Add([VT]::TextDim() + $filter.Name) | Out-Null
                continue
            }
            
            $line = ""
            if ($i -eq $this.FilterIndex -and $this.Layout.FocusedPane -eq 0) {
                $line += [VT]::Selected() + " > "
            } else {
                $line += "   "
            }
            
            $nameText = $filter.Name
            if ($filter.Count -gt 0) {
                $maxNameWidth = [Math]::Max(10, $this.Layout.LeftPane.Width - 8)
                if ($nameText.Length -gt $maxNameWidth) {
                    $nameText = $nameText.Substring(0, $maxNameWidth - 3) + "..."
                }
                $padding = [Math]::Max(0, $maxNameWidth - $nameText.Length)
                $line += $nameText + (" " * $padding) + [VT]::TextDim() + "($($filter.Count))"
            } else {
                $line += $nameText
            }
            
            $line += [VT]::Reset()
            $this.Layout.LeftPane.Content.Add($line) | Out-Null
        }
    }
    
    [void] UpdateMiddlePane() {
        $this.Layout.MiddlePane.Content.Clear()
        $this.Layout.MiddlePane.Title = "TASKS - $($this.CurrentFilter) ($($this.FilteredTasks.Count))"
        
        # Try to use ViewDefinitionService if available
        if ($this.ViewService) {
            $this.UpdateMiddlePaneWithViewService()
            return
        }
        
        # Calculate widths
        $titleWidth = $this.Layout.MiddlePane.Width - 25
        
        # Headers
        $header = [VT]::TextDim() + " S "
        $titlePadding = [Math]::Max(0, $titleWidth - 5)
        $header += "TITLE" + (" " * $titlePadding)
        $header += "PRI  PROG  DUE" + [VT]::Reset()
        $this.Layout.MiddlePane.Content.Add($header) | Out-Null
        $separatorWidth = [Math]::Max(10, $this.Layout.MiddlePane.Width - 2)
        $this.Layout.MiddlePane.Content.Add([VT]::TextDim() + ("─" * $separatorWidth) + [VT]::Reset()) | Out-Null
        
        # Tasks
        for ($i = 0; $i -lt $this.FilteredTasks.Count; $i++) {
            $task = $this.FilteredTasks[$i]
            $line = ""
            
            # Selection/edit mode
            if ($i -eq $this.TaskIndex -and $this.Layout.FocusedPane -eq 1) {
                if ($this.InlineEditMode -and $task.Id -eq $this.EditingTask.Id) {
                    $line += [VT]::RGBBG(255, 255, 0) + [VT]::RGB(0, 0, 0)
                } else {
                    $line += [VT]::Selected()
                }
            }
            
            # Status
            $line += " " + $task.GetStatusColor() + $task.GetStatusSymbol() + "  "
            
            # Title with tree
            $indent = ""
            if ($this.ShowTree -and $task.Level -gt 0) {
                for ($j = 0; $j -lt $task.Level; $j++) {
                    $indent += "  "
                }
                if ($task.SubtaskIds.Count -gt 0) {
                    $indent += if ($task.IsExpanded) { "▼ " } else { "▶ " }
                } else {
                    $indent += "• "
                }
            } elseif ($this.ShowTree -and $task.SubtaskIds.Count -gt 0) {
                $indent = if ($task.IsExpanded) { "▼ " } else { "▶ " }
            }
            
            if ($this.InlineEditMode -and $task.Id -eq $this.EditingTask.Id) {
                $editText = $this.EditBuffer
                if ($editText -eq "") {
                    $editText = "_"
                }
                $displayText = "» " + $editText + " █"
                $fullText = $indent + $displayText
                $paddedText = $fullText.PadRight($titleWidth)
                $line += $paddedText + [VT]::Reset()
            } else {
                $titleText = $indent + $task.Title
                $title = [Measure]::Pad($titleText, $titleWidth, "Left")
                if ($task.IsOverdue()) {
                    $line += [VT]::Error() + $title
                } else {
                    $line += [VT]::TextBright() + $title
                }
            }
            
            # Priority
            $line += " " + $task.GetPriorityColor() + $task.GetPrioritySymbol() + "  "
            
            # Progress
            if ($task.Progress -gt 0) {
                $line += [VT]::Text() + $task.Progress.ToString().PadLeft(3) + "%"
            } else {
                $line += "    "
            }
            
            # Due date
            if ($task.DueDate -and $task.DueDate -ne [datetime]::MinValue) {
                $daysUntil = [int]($task.DueDate.Date - [datetime]::Today).TotalDays
                if ($daysUntil -eq 0) {
                    $line += [VT]::Warning() + " Today"
                } elseif ($daysUntil -lt 0) {
                    $line += [VT]::Error() + " $($daysUntil)d"
                } else {
                    $line += [VT]::Text() + " +$($daysUntil)d"
                }
            } else {
                $line += "      "
            }
            
            $line += [VT]::Reset()
            $this.Layout.MiddlePane.Content.Add($line) | Out-Null
        }
    }
    
    [void] UpdateRightPane() {
        $this.Layout.RightPane.Content.Clear()
        
        if ($this.FilteredTasks.Count -eq 0) {
            $this.Layout.RightPane.Content.Add([VT]::TextDim() + " No tasks") | Out-Null
            return
        }
        
        $task = $this.FilteredTasks[$this.TaskIndex]
        
        # Title
        $this.Layout.RightPane.Content.Add([VT]::TextBright() + " " + $task.Title) | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " " + ("─" * ($this.Layout.RightPane.Width - 3))) | Out-Null
        $this.Layout.RightPane.Content.Add("") | Out-Null
        
        # Description
        if ($task.Description) {
            $words = $task.Description -split ' '
            $line = " "
            $maxWidth = $this.Layout.RightPane.Width - 3
            
            foreach ($word in $words) {
                if (($line + $word).Length -gt $maxWidth) {
                    $this.Layout.RightPane.Content.Add([VT]::Text() + $line) | Out-Null
                    $line = " $word"
                } else {
                    if ($line -eq " ") {
                        $line = " $word"
                    } else {
                        $line += " $word"
                    }
                }
            }
            if ($line.Trim()) {
                $this.Layout.RightPane.Content.Add([VT]::Text() + $line) | Out-Null
            }
            $this.Layout.RightPane.Content.Add("") | Out-Null
        }
        
        # Details
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Status: " + $task.GetStatusColor() + $task.Status) | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Priority: " + $task.GetPriorityColor() + $task.Priority + " " + $task.GetPrioritySymbol()) | Out-Null
        
        if ($task.Progress -gt 0) {
            $bar = "█" * [int]($task.Progress / 10) + "░" * [int]((100 - $task.Progress) / 10)
            $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Progress: " + [VT]::Accent() + $bar + " " + $task.Progress + "%") | Out-Null
        }
        
        if ($task.DueDate -and $task.DueDate -ne [datetime]::MinValue) {
            $dueText = $task.DueDate.ToString("MMM d, yyyy")
            if ($task.IsOverdue()) {
                $daysOverdue = [int]([datetime]::Today - $task.DueDate.Date).TotalDays
                $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Due: " + [VT]::Error() + $dueText + " ($daysOverdue days overdue)") | Out-Null
            } else {
                $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Due: " + [VT]::Text() + $dueText) | Out-Null
            }
        }
    }
}


####\Screens/taskscreen2.ps1
# Improved Task Management Screen

class TaskScreen {
    [ThreePaneLayout]$Layout
    [System.Collections.ArrayList]$Tasks
    [System.Collections.ArrayList]$Filters
    [int]$FilterIndex = 0
    [int]$TaskIndex = 0
    [string]$CurrentFilter = "All"
    [System.Collections.ArrayList]$FilteredTasks
    [bool]$MenuMode = $false
    [int]$MenuIndex = 0
    [System.Collections.ArrayList]$MenuItems
    [bool]$ShouldQuit = $false
    [bool]$EditMode = $false
    [Task]$EditingTask = $null
    [string]$EditBuffer = ""
    [bool]$ShowTree = $true  # Toggle between flat and tree view
    [EditScreen]$EditScreen = $null  # For detailed editing
    [bool]$ConfirmDelete = $false
    [Task]$TaskToDelete = $null
    
    TaskScreen() {
        # Initialize layout with better proportions
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        # Wider detail pane for better readability
        $leftWidth = 18
        $rightWidth = 35
        
        $this.Layout = [ThreePaneLayout]::new($width, $height, $leftWidth, $rightWidth)
        $this.Layout.LeftPane.Title = "FILTERS"
        $this.Layout.MiddlePane.Title = "TASKS"
        $this.Layout.RightPane.Title = "DETAIL"
        
        # Initialize data
        $this.Tasks = [System.Collections.ArrayList]::new()
        $this.FilteredTasks = [System.Collections.ArrayList]::new()
        $this.InitializeFilters()
        $this.InitializeMenu()
        $this.LoadTasks()
        $this.ApplyFilter()
    }
    
    [void] InitializeFilters() {
        $this.Filters = [System.Collections.ArrayList]@(
            @{Name="All"; Count=0; Filter={$true}},
            @{Name="Today"; Count=0; Filter={$_.DueDate -and $_.DueDate.Date -eq [datetime]::Today}},
            @{Name="This Week"; Count=0; Filter={$_.DueDate -and $_.DueDate -ge [datetime]::Today -and $_.DueDate -le [datetime]::Today.AddDays(7)}},
            @{Name="Overdue"; Count=0; Filter={$_.IsOverdue()}},
            @{Name="────────────"; Count=0; Filter=$null},  # Separator
            @{Name="Pending"; Count=0; Filter={$_.Status -eq "Pending"}},
            @{Name="In Progress"; Count=0; Filter={$_.Status -eq "InProgress"}},
            @{Name="Completed"; Count=0; Filter={$_.Status -eq "Completed"}}
        )
    }
    
    [void] InitializeMenu() {
        $this.MenuItems = [System.Collections.ArrayList]@(
            @{Key='a'; Label='add'; Action='Add'},
            @{Key='s'; Label='subtask'; Action='AddSubtask'},
            @{Key='d'; Label='delete'; Action='Delete'},
            @{Key='e'; Label='edit'; Action='Edit'},
            @{Key='E'; Label='details'; Action='EditDetails'},
            @{Key=' '; Label='toggle'; Action='Toggle'},
            @{Key='p'; Label='priority'; Action='Priority'},
            @{Key='x'; Label='expand'; Action='ExpandAll'},
            @{Key='q'; Label='quit'; Action='Quit'}
        )
    }
    
    [void] LoadTasks() {
        # Load sample tasks with subtasks
        $loginBug = [Task]::new("Fix login bug")
        $loginBug.Status = "InProgress"
        $loginBug.Priority = "High"
        $loginBug.Progress = 75
        $loginBug.Description = "Users report intermittent login failures after the latest deployment."
        $loginBug.DueDate = [datetime]::Today
        $this.Tasks.Add($loginBug) | Out-Null
        
        # Add subtasks for login bug
        $sub1 = [Task]::new("Reproduce the issue locally")
        $sub1.Status = "Completed"
        $sub1.ParentId = $loginBug.Id
        $this.Tasks.Add($sub1) | Out-Null
        $loginBug.SubtaskIds.Add($sub1.Id) | Out-Null
        
        $sub2 = [Task]::new("Debug authentication flow")
        $sub2.Status = "InProgress"
        $sub2.ParentId = $loginBug.Id
        $this.Tasks.Add($sub2) | Out-Null
        $loginBug.SubtaskIds.Add($sub2.Id) | Out-Null
        
        $sub3 = [Task]::new("Write unit tests")
        $sub3.Status = "Pending"
        $sub3.ParentId = $loginBug.Id
        $this.Tasks.Add($sub3) | Out-Null
        $loginBug.SubtaskIds.Add($sub3.Id) | Out-Null
        
        # PR Review task
        $prReview = [Task]::new("Review PR #234")
        $prReview.DueDate = [datetime]::Today.AddDays(-2)
        $this.Tasks.Add($prReview) | Out-Null
        
        # Documentation task with subtasks
        $docs = [Task]::new("Update documentation")
        $docs.Priority = "Low"
        $this.Tasks.Add($docs) | Out-Null
        
        $docSub1 = [Task]::new("Update API docs")
        $docSub1.ParentId = $docs.Id
        $this.Tasks.Add($docSub1) | Out-Null
        $docs.SubtaskIds.Add($docSub1.Id) | Out-Null
        
        $docSub2 = [Task]::new("Update user guide")
        $docSub2.ParentId = $docs.Id
        $this.Tasks.Add($docSub2) | Out-Null
        $docs.SubtaskIds.Add($docSub2.Id) | Out-Null
        
        # Simple tasks
        $this.Tasks.Add([Task]::new("Deploy to staging")) | Out-Null
        $this.Tasks[-1].Status = "Completed"
        
        $this.Tasks.Add([Task]::new("Test new API endpoint")) | Out-Null
        $this.Tasks[-1].DueDate = [datetime]::Today.AddDays(3)
    }
    
    [void] UpdateFilterCounts() {
        foreach ($filter in $this.Filters) {
            if ($filter.Filter) {
                $filter.Count = ($this.Tasks | Where-Object $filter.Filter).Count
            }
        }
    }
    
    [void] ApplyFilter() {
        $this.UpdateFilterCounts()
        $filter = $this.Filters[$this.FilterIndex]
        
        if ($filter.Filter) {
            $this.FilteredTasks = [System.Collections.ArrayList]@($this.Tasks | Where-Object $filter.Filter)
            $this.CurrentFilter = $filter.Name
        } else {
            $this.FilteredTasks = $this.Tasks
        }
        
        # Build tree structure if in tree mode
        if ($this.ShowTree) {
            $this.FilteredTasks = $this.BuildTreeView($this.FilteredTasks)
        }
        
        # Ensure task index is valid
        if ($this.TaskIndex -ge $this.FilteredTasks.Count) {
            $this.TaskIndex = [Math]::Max(0, $this.FilteredTasks.Count - 1)
        }
    }
    
    [System.Collections.ArrayList] BuildTreeView([System.Collections.ArrayList]$tasks) {
        $tree = [System.Collections.ArrayList]::new()
        $taskDict = @{}
        
        # Build dictionary for quick lookup
        foreach ($task in $tasks) {
            $taskDict[$task.Id] = $task
        }
        
        # Find root tasks and build tree recursively
        foreach ($task in $tasks) {
            if (-not $task.ParentId -or -not $taskDict.ContainsKey($task.ParentId)) {
                $task.Level = 0
                $tree.Add($task) | Out-Null
                if ($task.IsExpanded -and $task.SubtaskIds.Count -gt 0) {
                    $this.AddSubtasksToTree($tree, $task, $taskDict, 1)
                }
            }
        }
        
        return $tree
    }
    
    [void] AddSubtasksToTree([System.Collections.ArrayList]$tree, [Task]$parentTask, [hashtable]$taskDict, [int]$level) {
        foreach ($subtaskId in $parentTask.SubtaskIds) {
            if ($taskDict.ContainsKey($subtaskId)) {
                $subtask = $taskDict[$subtaskId]
                $subtask.Level = $level
                $tree.Add($subtask) | Out-Null
                
                if ($subtask.IsExpanded -and $subtask.SubtaskIds.Count -gt 0) {
                    $this.AddSubtasksToTree($tree, $subtask, $taskDict, $level + 1)
                }
            }
        }
    }
    
    [void] UpdateLeftPane() {
        $this.Layout.LeftPane.Content.Clear()
        
        for ($i = 0; $i -lt $this.Filters.Count; $i++) {
            $filter = $this.Filters[$i]
            
            if ($filter.Name -like "───*") {
                $this.Layout.LeftPane.Content.Add([VT]::TextDim() + $filter.Name) | Out-Null
                continue
            }
            
            $line = ""
            if ($i -eq $this.FilterIndex -and $this.Layout.FocusedPane -eq 0) {
                $line += [VT]::Selected() + " > "
            } else {
                $line += "   "
            }
            
            $nameText = $filter.Name
            if ($filter.Count -gt 0) {
                # Ensure name + count fits in pane width
                $maxNameWidth = $this.Layout.LeftPane.Width - 8  # Leave room for selection indicator and count
                if ($nameText.Length -gt $maxNameWidth) {
                    $nameText = $nameText.Substring(0, $maxNameWidth - 3) + "..."
                }
                $padding = $maxNameWidth - $nameText.Length
                $line += $nameText + (" " * $padding) + [VT]::TextDim() + "($($filter.Count))"
            } else {
                $line += $nameText
            }
            
            $line += [VT]::Reset()
            $this.Layout.LeftPane.Content.Add($line) | Out-Null
        }
    }
    
    [void] UpdateMiddlePane() {
        $this.Layout.MiddlePane.Content.Clear()
        $this.Layout.MiddlePane.Title = "TASKS - $($this.CurrentFilter) ($($this.FilteredTasks.Count))"
        
        # Calculate column widths
        $statusWidth = 3
        $titleWidth = $this.Layout.MiddlePane.Width - 25  # Leave room for other columns
        
        # Column headers
        $header = [VT]::TextDim() + " S "
        $titlePadding = [Math]::Max(0, $titleWidth - 5)
        $header += "TITLE" + (" " * $titlePadding)
        $header += "PRI  PROG  DUE" + [VT]::Reset()
        $this.Layout.MiddlePane.Content.Add($header) | Out-Null
        $separatorWidth = [Math]::Max(10, $this.Layout.MiddlePane.Width - 2)
        $this.Layout.MiddlePane.Content.Add([VT]::TextDim() + ("─" * $separatorWidth) + [VT]::Reset()) | Out-Null
        
        # Task list
        for ($i = 0; $i -lt $this.FilteredTasks.Count; $i++) {
            $task = $this.FilteredTasks[$i]
            $line = ""
            
            # Selection indicator
            if ($i -eq $this.TaskIndex -and $this.Layout.FocusedPane -eq 1) {
                if ($this.EditMode -and $task.Id -eq $this.EditingTask.Id) {
                    # Editing - use bright yellow background for entire line
                    $line += [VT]::RGBBG(255, 255, 0) + [VT]::RGB(0, 0, 0)
                } else {
                    $line += [VT]::Selected()
                }
            }
            
            # Status
            $line += " " + $task.GetStatusColor() + $task.GetStatusSymbol() + "  "
            
            # Title with tree indentation
            $indent = ""
            if ($this.ShowTree -and $task.Level -gt 0) {
                # Use string concatenation for indentation
                for ($j = 0; $j -lt $task.Level; $j++) {
                    $indent += "  "
                }
                # Add tree connector
                if ($task.SubtaskIds.Count -gt 0) {
                    $indent += if ($task.IsExpanded) { "▼ " } else { "▶ " }
                } else {
                    $indent += "• "
                }
            } elseif ($this.ShowTree -and $task.SubtaskIds.Count -gt 0) {
                # Root level with children
                $indent = if ($task.IsExpanded) { "▼ " } else { "▶ " }
            }
            
            if ($this.EditMode -and $task.Id -eq $this.EditingTask.Id) {
                # Show edit mode with VERY visible feedback
                $editText = $this.EditBuffer
                if ($editText -eq "") {
                    $editText = "_"  # Show placeholder for empty
                }
                
                # Add cursor
                $displayText = "» " + $editText + " █"
                
                # Ensure we don't exceed title width
                $maxLen = $titleWidth - $indent.Length - 4  # Account for markers
                if ($displayText.Length -gt $maxLen) {
                    $displayText = $displayText.Substring(0, $maxLen - 1) + "…"
                }
                
                # Build the full line with indent
                $fullText = $indent + $displayText
                $paddedText = $fullText.PadRight($titleWidth)
                
                # Apply BRIGHT yellow background for edit mode
                $line += [VT]::RGBBG(255, 255, 0) + [VT]::RGB(0, 0, 0) + $paddedText + [VT]::Reset()
            } else {
                $titleText = $indent + $task.Title
                $title = [Measure]::Pad($titleText, $titleWidth, "Left")
                if ($task.IsOverdue()) {
                    $line += [VT]::Error() + $title
                } else {
                    $line += [VT]::TextBright() + $title
                }
            }
            
            # Priority
            $line += " " + $task.GetPriorityColor() + $task.GetPrioritySymbol() + "  "
            
            # Progress
            if ($task.Progress -gt 0) {
                $line += [VT]::Text() + $task.Progress.ToString().PadLeft(3) + "%"
            } else {
                $line += "    "
            }
            
            # Due date (only if set)
            if ($task.DueDate -and $task.DueDate -ne [datetime]::MinValue) {
                $daysUntil = [int]($task.DueDate.Date - [datetime]::Today).TotalDays
                if ($daysUntil -eq 0) {
                    $line += [VT]::Warning() + " Today"
                } elseif ($daysUntil -lt 0) {
                    $line += [VT]::Error() + " $($daysUntil)d"
                } else {
                    $line += [VT]::Text() + " +$($daysUntil)d"
                }
            } else {
                $line += "      "  # Empty space for alignment
            }
            
            $line += [VT]::Reset()
            $this.Layout.MiddlePane.Content.Add($line) | Out-Null
        }
    }
    
    [void] UpdateRightPane() {
        $this.Layout.RightPane.Content.Clear()
        
        if ($this.FilteredTasks.Count -eq 0) {
            $this.Layout.RightPane.Content.Add([VT]::TextDim() + " No tasks") | Out-Null
            return
        }
        
        $task = $this.FilteredTasks[$this.TaskIndex]
        
        # Title
        $this.Layout.RightPane.Content.Add([VT]::TextBright() + " " + $task.Title) | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " " + "─" * ($this.Layout.RightPane.Width - 3)) | Out-Null
        $this.Layout.RightPane.Content.Add("") | Out-Null
        
        # Description (word wrap)
        if ($task.Description) {
            $words = $task.Description -split ' '
            $line = " "
            $maxWidth = $this.Layout.RightPane.Width - 3
            
            foreach ($word in $words) {
                if (($line + $word).Length -gt $maxWidth) {
                    $this.Layout.RightPane.Content.Add([VT]::Text() + $line) | Out-Null
                    $line = " $word"
                } else {
                    if ($line -eq " ") {
                        $line = " $word"
                    } else {
                        $line += " $word"
                    }
                }
            }
            if ($line.Trim()) {
                $this.Layout.RightPane.Content.Add([VT]::Text() + $line) | Out-Null
            }
            $this.Layout.RightPane.Content.Add("") | Out-Null
        }
        
        # Status
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Status: " + $task.GetStatusColor() + $task.Status) | Out-Null
        
        # Priority
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Priority: " + $task.GetPriorityColor() + $task.Priority + " " + $task.GetPrioritySymbol()) | Out-Null
        
        # Progress
        if ($task.Progress -gt 0) {
            $bar = "█" * [int]($task.Progress / 10) + "░" * [int]((100 - $task.Progress) / 10)
            $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Progress: " + [VT]::Accent() + $bar + " " + $task.Progress + "%") | Out-Null
        }
        
        # Due date
        if ($task.DueDate -and $task.DueDate -ne [datetime]::MinValue) {
            $dueText = $task.DueDate.ToString("MMM d, yyyy")
            if ($task.IsOverdue()) {
                $daysOverdue = [int]([datetime]::Today - $task.DueDate.Date).TotalDays
                $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Due: " + [VT]::Error() + $dueText + " ($daysOverdue days overdue)") | Out-Null
            } else {
                $this.Layout.RightPane.Content.Add([VT]::TextDim() + " Due: " + [VT]::Text() + $dueText) | Out-Null
            }
        }
        
        # Actions
        $this.Layout.RightPane.Content.Add("") | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::TextDim() + " " + "─" * ($this.Layout.RightPane.Width - 3)) | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::Text() + " [Enter] edit") | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::Text() + " [t] log time") | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::Text() + " [s] change status") | Out-Null
        $this.Layout.RightPane.Content.Add([VT]::Text() + " [p] change priority") | Out-Null
    }
    
    [void] Render() {
        # Show edit screen if active
        if ($this.EditScreen) {
            $this.EditScreen.Render()
            return
        }
        
        # Show delete confirmation if active
        if ($this.ConfirmDelete -and $this.TaskToDelete) {
            $this.RenderDeleteConfirmation()
            return
        }
        
        $this.UpdateLeftPane()
        $this.UpdateMiddlePane()
        $this.UpdateRightPane()
        
        $output = $this.Layout.Render()
        
        # Build status bar with menu highlighting
        $statusText = ""
        if ($this.EditMode) {
            # Edit mode status - VERY VISIBLE
            $editType = if ($this.EditingTask.ParentId) { "SUBTASK" } else { "TASK" }
            $statusText = [VT]::RGBBG(255, 255, 0) + [VT]::RGB(0, 0, 0) + " >>> EDITING $($editType): " + $this.EditBuffer + " <<< " + [VT]::Reset() + 
                         [VT]::TextBright() + " [Enter]save [Esc]cancel" + [VT]::Reset()
        } elseif ($this.MenuMode) {
            # Show menu with selection
            for ($i = 0; $i -lt $this.MenuItems.Count; $i++) {
                $item = $this.MenuItems[$i]
                if ($i -eq $this.MenuIndex) {
                    $statusText += [VT]::Selected() + " [$($item.Key)]$($item.Label) " + [VT]::Reset()
                } else {
                    $statusText += " [$($item.Key)]$($item.Label) "
                }
            }
            $statusText += [VT]::TextDim() + " [Ctrl]exit menu" + [VT]::Reset()
        } else {
            # Normal status
            foreach ($item in $this.MenuItems) {
                $statusText += "[$($item.Key)]$($item.Label) "
            }
            $statusText += "[Tab]switch [Ctrl]menu"
        }
        
        $output += $this.Layout.DrawStatusBar($statusText)
        
        [Console]::Write($output)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        # Handle edit screen first
        if ($this.EditScreen) {
            $this.EditScreen.HandleInput($key)
            
            # Check if edit screen is done
            if ($this.EditScreen.ShouldSave -or $this.EditScreen.ShouldCancel) {
                if ($this.EditScreen.ShouldCancel -and $this.EditScreen.IsNew) {
                    # Remove the new task if cancelled
                    $this.Tasks.Remove($this.EditScreen.Task)
                }
                if ($this.EditScreen.ShouldSave -and $this.EditScreen.IsNew) {
                    # For new tasks, refresh the filter
                    $this.ApplyFilter()
                }
                $this.EditScreen = $null
            }
            return
        }
        
        # Handle delete confirmation
        if ($this.ConfirmDelete) {
            switch ($key.KeyChar) {
                'y' {
                    # Confirm delete
                    $this.Tasks.Remove($this.TaskToDelete)
                    $this.ApplyFilter()
                    if ($this.TaskIndex -ge $this.FilteredTasks.Count -and $this.TaskIndex -gt 0) {
                        $this.TaskIndex--
                    }
                    $this.ConfirmDelete = $false
                    $this.TaskToDelete = $null
                }
                'n' {
                    # Cancel delete
                    $this.ConfirmDelete = $false
                    $this.TaskToDelete = $null
                }
            }
            return
        }
        
        # Handle edit mode
        if ($this.EditMode) {
            switch ($key.Key) {
                ([ConsoleKey]::Enter) {
                    # Save edit
                    $this.EditingTask.Title = $this.EditBuffer
                    $this.EditingTask.Update()
                    $this.EditMode = $false
                    $this.EditingTask = $null
                    $this.EditBuffer = ""
                    return
                }
                ([ConsoleKey]::Escape) {
                    # Cancel edit
                    $this.EditMode = $false
                    $this.EditingTask = $null
                    $this.EditBuffer = ""
                    return
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.EditBuffer.Length -gt 0) {
                        $this.EditBuffer = $this.EditBuffer.Substring(0, $this.EditBuffer.Length - 1)
                    }
                    return
                }
                default {
                    # Add character if printable
                    if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or 
                        $key.KeyChar -eq ' ' -or [char]::IsPunctuation($key.KeyChar) -or
                        [char]::IsSymbol($key.KeyChar)) {
                        $this.EditBuffer += $key.KeyChar
                    }
                    return
                }
            }
        }
        
        # Simple Ctrl detection - any key with Ctrl modifier toggles menu
        if ($key.Modifiers -eq [ConsoleModifiers]::Control) {
            $this.MenuMode = -not $this.MenuMode
            if ($this.MenuMode) {
                $this.MenuIndex = 0  # Reset to first item
            }
            return
        }
        
        # Handle menu mode navigation
        if ($this.MenuMode) {
            switch ($key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    if ($this.MenuIndex -gt 0) {
                        $this.MenuIndex--
                    }
                    return
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.MenuIndex -lt $this.MenuItems.Count - 1) {
                        $this.MenuIndex++
                    }
                    return
                }
                ([ConsoleKey]::Enter) {
                    # Execute menu action
                    $this.ExecuteMenuAction($this.MenuItems[$this.MenuIndex].Action)
                    $this.MenuMode = $false
                    return
                }
                ([ConsoleKey]::Escape) {
                    $this.MenuMode = $false
                    return
                }
            }
            
            # Also allow direct key press in menu mode
            foreach ($item in $this.MenuItems) {
                if ($key.KeyChar -ceq $item.Key) {
                    $this.ExecuteMenuAction($item.Action)
                    $this.MenuMode = $false
                    return
                }
            }
            return
        }
        
        # Normal mode navigation
        switch ($key.Key) {
            ([ConsoleKey]::Tab) {
                # Cycle between interactive panes only
                $this.Layout.FocusNext()
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this.Layout.FocusedPane -eq 1) {
                    $this.Layout.SetFocus(0)
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.Layout.FocusedPane -eq 0) {
                    $this.Layout.SetFocus(1)
                }
            }
            ([ConsoleKey]::UpArrow) {
                switch ($this.Layout.FocusedPane) {
                    0 { # Filter pane
                        if ($this.FilterIndex -gt 0) {
                            $this.FilterIndex--
                            if ($this.Filters[$this.FilterIndex].Name -like "───*") {
                                $this.FilterIndex--
                            }
                            $this.ApplyFilter()
                        }
                    }
                    1 { # Task pane
                        if ($this.TaskIndex -gt 0) {
                            $this.TaskIndex--
                        }
                    }
                }
            }
            ([ConsoleKey]::DownArrow) {
                switch ($this.Layout.FocusedPane) {
                    0 { # Filter pane
                        if ($this.FilterIndex -lt $this.Filters.Count - 1) {
                            $this.FilterIndex++
                            if ($this.Filters[$this.FilterIndex].Name -like "───*") {
                                if ($this.FilterIndex -lt $this.Filters.Count - 1) {
                                    $this.FilterIndex++
                                }
                            }
                            $this.ApplyFilter()
                        }
                    }
                    1 { # Task pane
                        if ($this.TaskIndex -lt $this.FilteredTasks.Count - 1) {
                            $this.TaskIndex++
                        }
                    }
                }
            }
            ([ConsoleKey]::Enter) {
                if ($this.Layout.FocusedPane -eq 0) {
                    # Apply filter and move to task list
                    $this.ApplyFilter()
                    $this.Layout.SetFocus(1)
                } elseif ($this.Layout.FocusedPane -eq 1 -and $this.FilteredTasks.Count -gt 0) {
                    # Toggle expand/collapse if task has children
                    $task = $this.FilteredTasks[$this.TaskIndex]
                    if ($task.SubtaskIds.Count -gt 0) {
                        $task.IsExpanded = -not $task.IsExpanded
                        $this.ApplyFilter()
                        
                        # Maintain selection on the same task
                        for ($i = 0; $i -lt $this.FilteredTasks.Count; $i++) {
                            if ($this.FilteredTasks[$i].Id -eq $task.Id) {
                                $this.TaskIndex = $i
                                break
                            }
                        }
                    }
                }
            }
        }
        
        # Handle character keys in normal mode
        if (-not $this.MenuMode) {
            foreach ($item in $this.MenuItems) {
                # Case-sensitive comparison for menu items
                if ($key.KeyChar -ceq $item.Key) {
                    $this.ExecuteMenuAction($item.Action)
                    return
                }
            }
        }
    }
    
    [void] ExecuteMenuAction([string]$action) {
        switch ($action) {
            'Toggle' {
                if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
                    $task = $this.FilteredTasks[$this.TaskIndex]
                    switch ($task.Status) {
                        "Pending" { $task.Status = "InProgress" }
                        "InProgress" { $task.Status = "Completed" }
                        "Completed" { $task.Status = "Pending" }
                    }
                    $task.Update()
                }
            }
            'ExpandAll' {
                # Toggle expand/collapse all
                $allExpanded = $true
                foreach ($task in $this.Tasks) {
                    if ($task.SubtaskIds.Count -gt 0 -and -not $task.IsExpanded) {
                        $allExpanded = $false
                        break
                    }
                }
                
                # Set opposite state for all
                foreach ($task in $this.Tasks) {
                    if ($task.SubtaskIds.Count -gt 0) {
                        $task.IsExpanded = -not $allExpanded
                    }
                }
                
                $this.ApplyFilter()
            }
            'Priority' {
                if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
                    $task = $this.FilteredTasks[$this.TaskIndex]
                    switch ($task.Priority) {
                        "Low" { $task.Priority = "Medium" }
                        "Medium" { $task.Priority = "High" }
                        "High" { $task.Priority = "Low" }
                    }
                    $task.Update()
                }
            }
            'Add' {
                # Create new task with inline edit (same as before)
                $newTask = [Task]::new("")
                $this.Tasks.Add($newTask) | Out-Null
                $this.ApplyFilter()
                
                # Find and select the new task
                for ($i = 0; $i -lt $this.FilteredTasks.Count; $i++) {
                    if ($this.FilteredTasks[$i].Id -eq $newTask.Id) {
                        $this.TaskIndex = $i
                        break
                    }
                }
                
                # Enter edit mode with empty buffer
                $this.EditMode = $true
                $this.EditingTask = $newTask
                $this.EditBuffer = ""
                
                # Make sure we're on the task pane
                $this.Layout.SetFocus(1)
            }
            'AddSubtask' {
                if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
                    $parentTask = $this.FilteredTasks[$this.TaskIndex]
                    $this.AddSubtask($parentTask)
                }
            }
            'Delete' {
                if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
                    $this.ConfirmDelete = $true
                    $this.TaskToDelete = $this.FilteredTasks[$this.TaskIndex]
                    # Force immediate re-render to show dialog
                    return
                }
            }
            'Edit' {
                if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
                    $this.EditMode = $true
                    $this.EditingTask = $this.FilteredTasks[$this.TaskIndex]
                    $this.EditBuffer = $this.EditingTask.Title
                }
            }
            'EditDetails' {
                if ($this.FilteredTasks.Count -gt 0 -and $this.Layout.FocusedPane -eq 1) {
                    $task = $this.FilteredTasks[$this.TaskIndex]
                    $this.EditScreen = [EditScreen]::new($task, $false)
                }
            }
            'Search' {
                # TODO: Implement search
            }
            'Quit' {
                $this.ShouldQuit = $true
            }
        }
    }
    
    # Removed AddTask method - now inline in ExecuteMenuAction
    
    [void] AddSubtask([Task]$parentTask) {
        # Create new subtask
        $subtask = [Task]::new("")
        $subtask.ParentId = $parentTask.Id
        
        # Add to tasks collection
        $this.Tasks.Add($subtask) | Out-Null
        
        # Add to parent's subtask list
        $parentTask.SubtaskIds.Add($subtask.Id) | Out-Null
        
        # Ensure parent is expanded
        $parentTask.IsExpanded = $true
        
        # Refresh view
        $this.ApplyFilter()
        
        # Find and select the new subtask
        for ($i = 0; $i -lt $this.FilteredTasks.Count; $i++) {
            if ($this.FilteredTasks[$i].Id -eq $subtask.Id) {
                $this.TaskIndex = $i
                break
            }
        }
        
        # Enter edit mode
        $this.EditMode = $true
        $this.EditingTask = $subtask
        $this.EditBuffer = ""
        
        # Make sure we're on the task pane
        $this.Layout.SetFocus(1)
    }
    
    [void] RenderDeleteConfirmation() {
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        # Clear and draw main screen first
        $this.UpdateLeftPane()
        $this.UpdateMiddlePane()
        $this.UpdateRightPane()
        $output = $this.Layout.Render()
        [Console]::Write($output)
        
        # Draw confirmation dialog over it
        $dialogWidth = 50
        $dialogHeight = 7
        $dialogX = [int](($width - $dialogWidth) / 2)
        $dialogY = [int](($height - $dialogHeight) / 2)
        
        # Draw dialog box
        $dialog = [VT]::MoveTo($dialogX, $dialogY)
        $dialog += [VT]::RGBBG(255, 0, 0) + [VT]::White()
        $dialog += [VT]::TL() + [VT]::H() * ($dialogWidth - 2) + [VT]::TR()
        
        # Title
        $dialog += [VT]::MoveTo($dialogX, $dialogY + 1)
        $dialog += [VT]::V() + " DELETE CONFIRMATION".PadRight($dialogWidth - 2) + [VT]::V()
        
        # Task name
        $dialog += [VT]::MoveTo($dialogX, $dialogY + 2)
        $taskName = $this.TaskToDelete.Title
        if ($taskName.Length -gt $dialogWidth - 4) {
            $taskName = $taskName.Substring(0, $dialogWidth - 7) + "..."
        }
        $dialog += [VT]::V() + " Delete: $taskName".PadRight($dialogWidth - 2) + [VT]::V()
        
        # Warning
        $warning = "This cannot be undone!"
        $dialog += [VT]::MoveTo($dialogX, $dialogY + 3)
        $dialog += [VT]::V() + " $warning".PadRight($dialogWidth - 2) + [VT]::V()
        
        # Prompt
        $dialog += [VT]::MoveTo($dialogX, $dialogY + 4)
        $dialog += [VT]::V() + " ".PadRight($dialogWidth - 2) + [VT]::V()
        
        $dialog += [VT]::MoveTo($dialogX, $dialogY + 5)
        $dialog += [VT]::V() + " [Y]es, delete   [N]o, cancel".PadRight($dialogWidth - 2) + [VT]::V()
        
        # Bottom border
        $dialog += [VT]::MoveTo($dialogX, $dialogY + 6)
        $dialog += [VT]::BL() + [VT]::H() * ($dialogWidth - 2) + [VT]::BR()
        
        $dialog += [VT]::Reset()
        [Console]::Write($dialog)
    }
}


####\Screens/TextEditorScreen_v2.ps1
# TextEditorScreen v2 - Enhanced with gap buffer algorithm and AxiomPhoenix improvements

class GapBuffer {
    hidden [char[]]$Buffer
    hidden [int]$GapStart
    hidden [int]$GapEnd
    hidden [int]$Capacity
    
    GapBuffer([int]$initialCapacity = 1024) {
        $this.Capacity = $initialCapacity
        $this.Buffer = New-Object char[] $this.Capacity
        $this.GapStart = 0
        $this.GapEnd = $this.Capacity
    }
    
    [int] get_Length() {
        return $this.Capacity - ($this.GapEnd - $this.GapStart)
    }
    
    [void] MoveGap([int]$position) {
        if ($position -eq $this.GapStart) { return }
        
        if ($position -lt $this.GapStart) {
            # Move gap left
            $count = $this.GapStart - $position
            [Array]::Copy($this.Buffer, $position, $this.Buffer, $this.GapEnd - $count, $count)
            $this.GapStart = $position
            $this.GapEnd -= $count
        } else {
            # Move gap right
            $count = $position - $this.GapStart
            [Array]::Copy($this.Buffer, $this.GapEnd, $this.Buffer, $this.GapStart, $count)
            $this.GapStart += $count
            $this.GapEnd += $count
        }
    }
    
    [void] Insert([int]$position, [char]$ch) {
        $this.MoveGap($position)
        
        # Expand buffer if needed
        if ($this.GapStart -eq $this.GapEnd) {
            $this.Expand()
        }
        
        $this.Buffer[$this.GapStart] = $ch
        $this.GapStart++
    }
    
    [void] Delete([int]$position) {
        $this.MoveGap($position)
        if ($this.GapEnd -lt $this.Capacity) {
            $this.GapEnd++
        }
    }
    
    [void] Expand() {
        $newCapacity = $this.Capacity * 2
        $newBuffer = New-Object char[] $newCapacity
        
        # Copy before gap
        [Array]::Copy($this.Buffer, 0, $newBuffer, 0, $this.GapStart)
        
        # Copy after gap
        $afterGapCount = $this.Capacity - $this.GapEnd
        [Array]::Copy($this.Buffer, $this.GapEnd, $newBuffer, $newCapacity - $afterGapCount, $afterGapCount)
        
        $this.GapEnd = $newCapacity - $afterGapCount
        $this.Buffer = $newBuffer
        $this.Capacity = $newCapacity
    }
    
    [char] GetChar([int]$position) {
        if ($position -lt $this.GapStart) {
            return $this.Buffer[$position]
        } else {
            return $this.Buffer[$position + ($this.GapEnd - $this.GapStart)]
        }
    }
    
    [string] ToString() {
        $result = New-Object System.Text.StringBuilder
        
        # Before gap
        for ($i = 0; $i -lt $this.GapStart; $i++) {
            [void]$result.Append($this.Buffer[$i])
        }
        
        # After gap
        for ($i = $this.GapEnd; $i -lt $this.Capacity; $i++) {
            [void]$result.Append($this.Buffer[$i])
        }
        
        return $result.ToString()
    }
}

class TextEditorScreenV2 : Screen {
    [string]$FilePath
    hidden [GapBuffer]$Buffer
    [int]$CursorPosition = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [bool]$Modified = $false
    [bool]$InsertMode = $true
    [string]$StatusMessage = ""
    
    # Editor settings
    [int]$TabWidth = 4
    [bool]$ShowLineNumbers = $true
    [int]$LineNumberWidth = 5
    
    # Undo/Redo stacks
    hidden [System.Collections.Generic.Stack[object]]$UndoStack
    hidden [System.Collections.Generic.Stack[object]]$RedoStack
    
    # Performance: pre-resolved colors
    hidden [hashtable]$Colors = @{}
    
    # Cached line information
    hidden [int[]]$LineStarts = @(0)
    hidden [bool]$LinesCacheDirty = $true
    
    TextEditorScreenV2([string]$filePath) {
        $this.FilePath = $filePath
        $this.Title = "Text Editor v2"
        $this.Buffer = [GapBuffer]::new()
        $this.UndoStack = [System.Collections.Generic.Stack[object]]::new()
        $this.RedoStack = [System.Collections.Generic.Stack[object]]::new()
        $this.Initialize()
    }
    
    TextEditorScreenV2() {
        $this.FilePath = ""
        $this.Title = "Text Editor v2 - New File"
        $this.Buffer = [GapBuffer]::new()
        $this.UndoStack = [System.Collections.Generic.Stack[object]]::new()
        $this.RedoStack = [System.Collections.Generic.Stack[object]]::new()
        $this.Initialize()
    }
    
    [void] Initialize() {
        # Pre-resolve theme colors for performance
        $this.Colors = @{
            Background = [VT]::RGB(30, 30, 30)
            Foreground = [VT]::RGB(212, 212, 212)
            LineNumber = [VT]::RGB(100, 100, 150)
            Keyword = [VT]::RGB(150, 150, 255)
            String = [VT]::RGB(200, 150, 100)
            Comment = [VT]::RGB(100, 150, 100)
            Modified = [VT]::RGB(255, 200, 100)
        }
        
        # Load file if specified
        if ($this.FilePath -and (Test-Path $this.FilePath)) {
            $this.LoadFile()
        }
        
        # Key bindings
        $this.InitializeKeyBindings()
        
        # Update status bar
        $this.UpdateStatusBar()
    }
    
    [void] LoadFile() {
        try {
            $content = Get-Content -Path $this.FilePath -Raw
            if ($content) {
                foreach ($char in $content.ToCharArray()) {
                    $this.Buffer.Insert($this.Buffer.Length, $char)
                }
            }
            $this.Title = "Text Editor v2 - $([System.IO.Path]::GetFileName($this.FilePath))"
            $this.Modified = $false
            $this.LinesCacheDirty = $true
            $this.UpdateLineStarts()
        }
        catch {
            $this.StatusMessage = "Error loading file: $_"
        }
    }
    
    [void] SaveFile() {
        if (-not $this.FilePath) {
            $this.StatusMessage = "No file name - use Ctrl+S to save as"
            return
        }
        
        try {
            $content = $this.Buffer.ToString()
            Set-Content -Path $this.FilePath -Value $content -NoNewline
            $this.Modified = $false
            $this.StatusMessage = "File saved"
            $this.UpdateStatusBar()
        }
        catch {
            $this.StatusMessage = "Error saving file: $_"
        }
    }
    
    [void] UpdateLineStarts() {
        if (-not $this.LinesCacheDirty) { return }
        
        $this.LineStarts = @(0)
        $length = $this.Buffer.Length
        
        for ($i = 0; $i -lt $length; $i++) {
            if ($this.Buffer.GetChar($i) -eq "`n") {
                $this.LineStarts += ($i + 1)
            }
        }
        
        $this.LinesCacheDirty = $false
    }
    
    [int] GetCurrentLine() {
        $this.UpdateLineStarts()
        
        for ($i = $this.LineStarts.Count - 1; $i -ge 0; $i--) {
            if ($this.CursorPosition -ge $this.LineStarts[$i]) {
                return $i
            }
        }
        return 0
    }
    
    [int] GetCurrentColumn() {
        $line = $this.GetCurrentLine()
        return $this.CursorPosition - $this.LineStarts[$line]
    }
    
    [void] InitializeKeyBindings() {
        # Navigation
        $this.BindKey([ConsoleKey]::UpArrow, { $this.MoveCursor(0, -1) })
        $this.BindKey([ConsoleKey]::DownArrow, { $this.MoveCursor(0, 1) })
        $this.BindKey([ConsoleKey]::LeftArrow, { $this.MoveCursorLeft() })
        $this.BindKey([ConsoleKey]::RightArrow, { $this.MoveCursorRight() })
        $this.BindKey([ConsoleKey]::Home, { $this.MoveCursorHome() })
        $this.BindKey([ConsoleKey]::End, { $this.MoveCursorEnd() })
        $this.BindKey([ConsoleKey]::PageUp, { $this.PageUp() })
        $this.BindKey([ConsoleKey]::PageDown, { $this.PageDown() })
        
        # Editing
        $this.BindKey([ConsoleKey]::Enter, { $this.InsertNewline() })
        $this.BindKey([ConsoleKey]::Backspace, { $this.Backspace() })
        $this.BindKey([ConsoleKey]::Delete, { $this.Delete() })
        $this.BindKey([ConsoleKey]::Tab, { $this.InsertTab() })
        
        # File operations
        $this.KeyBindings[[ConsoleKey]::S] = { 
            param($key)
            if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                $this.SaveFile()
            } else {
                $this.InsertChar('s')
            }
        }
        
        # Undo/Redo
        $this.KeyBindings[[ConsoleKey]::Z] = {
            param($key)
            if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                $this.Undo()
            } else {
                $this.InsertChar('z')
            }
        }
        
        $this.KeyBindings[[ConsoleKey]::Y] = {
            param($key)
            if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                $this.Redo()
            } else {
                $this.InsertChar('y')
            }
        }
        
        # Exit
        $this.BindKey([ConsoleKey]::Escape, { 
            if ($this.Modified) {
                $this.StatusMessage = "Unsaved changes! Press ESC again to quit"
            } else {
                $this.Active = $false
            }
        })
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        # Clear status message on any input
        if ($this.StatusMessage -and -not $this.StatusMessage.StartsWith("Unsaved")) {
            $this.StatusMessage = ""
        }
        
        # Check for bound keys first
        if ($this.KeyBindings.ContainsKey($key.Key)) {
            & $this.KeyBindings[$key.Key] $key
            return
        }
        
        # Insert characters
        if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
            $this.InsertChar($key.KeyChar)
        }
    }
    
    [void] InsertChar([char]$char) {
        # Record for undo
        $this.RecordUndo(@{
            Type = "Insert"
            Position = $this.CursorPosition
            Char = $char
        })
        
        $this.Buffer.Insert($this.CursorPosition, $char)
        $this.CursorPosition++
        $this.Modified = $true
        $this.LinesCacheDirty = $true
        $this.UpdateStatusBar()
        $this.RequestRender()
    }
    
    [void] Backspace() {
        if ($this.CursorPosition -gt 0) {
            $deletedChar = $this.Buffer.GetChar($this.CursorPosition - 1)
            
            $this.RecordUndo(@{
                Type = "Delete"
                Position = $this.CursorPosition - 1
                Char = $deletedChar
            })
            
            $this.CursorPosition--
            $this.Buffer.Delete($this.CursorPosition)
            $this.Modified = $true
            $this.LinesCacheDirty = $true
            $this.UpdateStatusBar()
            $this.RequestRender()
        }
    }
    
    [void] Delete() {
        if ($this.CursorPosition -lt $this.Buffer.Length) {
            $deletedChar = $this.Buffer.GetChar($this.CursorPosition)
            
            $this.RecordUndo(@{
                Type = "Delete"
                Position = $this.CursorPosition
                Char = $deletedChar
            })
            
            $this.Buffer.Delete($this.CursorPosition)
            $this.Modified = $true
            $this.LinesCacheDirty = $true
            $this.UpdateStatusBar()
            $this.RequestRender()
        }
    }
    
    [void] InsertNewline() {
        $this.InsertChar("`n")
    }
    
    [void] InsertTab() {
        for ($i = 0; $i -lt $this.TabWidth; $i++) {
            $this.InsertChar(' ')
        }
    }
    
    # Smart cursor movement from AxiomPhoenix
    [void] MoveCursorLeft() {
        if ($this.CursorPosition -gt 0) {
            $this.CursorPosition--
            
            # If we moved to a newline, go to end of previous line
            if ($this.CursorPosition -gt 0 -and $this.Buffer.GetChar($this.CursorPosition) -eq "`n") {
                $this.CursorPosition--
            }
        }
        $this.RequestRender()
    }
    
    [void] MoveCursorRight() {
        if ($this.CursorPosition -lt $this.Buffer.Length) {
            $this.CursorPosition++
            
            # If we moved past a newline, go to start of next line
            if ($this.CursorPosition -lt $this.Buffer.Length -and 
                $this.Buffer.GetChar($this.CursorPosition - 1) -eq "`n") {
                # Already at correct position
            }
        }
        $this.RequestRender()
    }
    
    [void] MoveCursorHome() {
        $line = $this.GetCurrentLine()
        $this.CursorPosition = $this.LineStarts[$line]
        $this.RequestRender()
    }
    
    [void] MoveCursorEnd() {
        $line = $this.GetCurrentLine()
        $nextLine = $line + 1
        
        if ($nextLine -lt $this.LineStarts.Count) {
            $this.CursorPosition = $this.LineStarts[$nextLine] - 1
        } else {
            $this.CursorPosition = $this.Buffer.Length
        }
        $this.RequestRender()
    }
    
    [void] MoveCursor([int]$dx, [int]$dy) {
        if ($dy -ne 0) {
            $currentLine = $this.GetCurrentLine()
            $currentColumn = $this.GetCurrentColumn()
            $targetLine = [Math]::Max(0, [Math]::Min($this.LineStarts.Count - 1, $currentLine + $dy))
            
            if ($targetLine -ne $currentLine) {
                # Move to target line, maintaining column if possible
                $targetLineStart = $this.LineStarts[$targetLine]
                $targetLineEnd = if ($targetLine + 1 -lt $this.LineStarts.Count) {
                    $this.LineStarts[$targetLine + 1] - 1
                } else {
                    $this.Buffer.Length
                }
                
                $targetLineLength = $targetLineEnd - $targetLineStart
                $this.CursorPosition = $targetLineStart + [Math]::Min($currentColumn, $targetLineLength)
            }
        }
        $this.RequestRender()
    }
    
    # Undo/Redo system
    [void] RecordUndo([hashtable]$action) {
        $this.UndoStack.Push($action)
        $this.RedoStack.Clear()
    }
    
    [void] Undo() {
        if ($this.UndoStack.Count -eq 0) {
            $this.StatusMessage = "Nothing to undo"
            return
        }
        
        $action = $this.UndoStack.Pop()
        
        switch ($action.Type) {
            "Insert" {
                $this.Buffer.Delete($action.Position)
                $this.CursorPosition = $action.Position
            }
            "Delete" {
                $this.Buffer.Insert($action.Position, $action.Char)
                $this.CursorPosition = $action.Position + 1
            }
        }
        
        $this.RedoStack.Push($action)
        $this.Modified = $true
        $this.LinesCacheDirty = $true
        $this.StatusMessage = "Undone"
        $this.UpdateStatusBar()
        $this.RequestRender()
    }
    
    [void] Redo() {
        if ($this.RedoStack.Count -eq 0) {
            $this.StatusMessage = "Nothing to redo"
            return
        }
        
        $action = $this.RedoStack.Pop()
        
        switch ($action.Type) {
            "Insert" {
                $this.Buffer.Insert($action.Position, $action.Char)
                $this.CursorPosition = $action.Position + 1
            }
            "Delete" {
                $this.Buffer.Delete($action.Position)
                $this.CursorPosition = $action.Position
            }
        }
        
        $this.UndoStack.Push($action)
        $this.Modified = $true
        $this.LinesCacheDirty = $true
        $this.StatusMessage = "Redone"
        $this.UpdateStatusBar()
        $this.RequestRender()
    }
    
    [void] UpdateStatusBar() {
        $this.StatusBarItems.Clear()
        
        # File info
        $fileName = if ($this.FilePath) { [System.IO.Path]::GetFileName($this.FilePath) } else { "New File" }
        $modifiedIndicator = if ($this.Modified) { "*" } else { "" }
        $this.StatusBarItems.Add(@{
            Label = "$fileName$modifiedIndicator"
        }) | Out-Null
        
        # Position info
        $line = $this.GetCurrentLine() + 1
        $col = $this.GetCurrentColumn() + 1
        $this.StatusBarItems.Add(@{
            Label = "Ln $line, Col $col"
        }) | Out-Null
        
        # Buffer info
        $this.StatusBarItems.Add(@{
            Label = "$($this.Buffer.Length) chars"
        }) | Out-Null
        
        # Mode
        $mode = if ($this.InsertMode) { "INSERT" } else { "OVERWRITE" }
        $this.StatusBarItems.Add(@{
            Label = $mode
        }) | Out-Null
        
        # Commands
        $this.AddStatusItem('Ctrl+S', 'save')
        $this.AddStatusItem('Ctrl+Z', 'undo')
        $this.AddStatusItem('Ctrl+Y', 'redo')
        $this.AddStatusItem('ESC', 'exit')
        
        # Status message
        if ($this.StatusMessage) {
            $this.StatusBarItems.Add(@{
                Label = $this.StatusMessage
                Align = "Right"
            }) | Out-Null
        }
    }
    
    [void] EnsureCursorVisible([int]$viewHeight, [int]$viewWidth) {
        $currentLine = $this.GetCurrentLine()
        $currentColumn = $this.GetCurrentColumn()
        
        # Smart scroll from AxiomPhoenix - minimal scrolling to keep cursor visible
        # Vertical scrolling
        if ($currentLine -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $currentLine
        }
        elseif ($currentLine -ge $this.ScrollOffsetY + $viewHeight) {
            $this.ScrollOffsetY = $currentLine - $viewHeight + 1
        }
        
        # Horizontal scrolling
        $effectiveWidth = $viewWidth - $this.LineNumberWidth
        if ($currentColumn -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $currentColumn
        }
        elseif ($currentColumn -ge $this.ScrollOffsetX + $effectiveWidth) {
            $this.ScrollOffsetX = $currentColumn - $effectiveWidth + 1
        }
    }
    
    [string] RenderContent() {
        $output = ""
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        # Clear background
        for ($y = 1; $y -le $height; $y++) {
            $output += [VT]::MoveTo(1, $y)
            $output += " " * $width
        }
        
        # Title bar
        $titleText = " $($this.Title) "
        $x = [int](($width - $titleText.Length) / 2)
        $output += [VT]::MoveTo($x, 1)
        $output += [VT]::RGB(100, 200, 255) + $titleText + [VT]::Reset()
        
        # Calculate visible area
        $editorY = 2
        $editorHeight = $height - 4
        $editorWidth = $width
        
        # Update line cache if needed
        $this.UpdateLineStarts()
        
        # Ensure cursor is visible
        $this.EnsureCursorVisible($editorHeight, $editorWidth)
        
        # Render visible lines
        $startLine = $this.ScrollOffsetY
        $endLine = [Math]::Min($startLine + $editorHeight, $this.LineStarts.Count)
        
        for ($lineNum = $startLine; $lineNum -lt $endLine; $lineNum++) {
            $y = $editorY + ($lineNum - $startLine)
            $output += [VT]::MoveTo(1, $y)
            
            # Line number
            if ($this.ShowLineNumbers) {
                $lineNumStr = ($lineNum + 1).ToString().PadLeft($this.LineNumberWidth - 1)
                $output += $this.Colors.LineNumber + $lineNumStr + " " + [VT]::Reset()
            }
            
            # Line content
            $lineStart = $this.LineStarts[$lineNum]
            $lineEnd = if ($lineNum + 1 -lt $this.LineStarts.Count) {
                $this.LineStarts[$lineNum + 1] - 1
            } else {
                $this.Buffer.Length
            }
            
            # Extract visible portion of line
            $x = if ($this.ShowLineNumbers) { $this.LineNumberWidth } else { 0 }
            for ($i = $lineStart + $this.ScrollOffsetX; $i -lt $lineEnd -and $x -lt $width; $i++) {
                $char = $this.Buffer.GetChar($i)
                if ($char -ne "`n") {
                    $output += $char
                    $x++
                }
            }
        }
        
        # Show cursor
        $cursorLine = $this.GetCurrentLine()
        $cursorColumn = $this.GetCurrentColumn()
        $cursorScreenX = 1 + $this.LineNumberWidth + $cursorColumn - $this.ScrollOffsetX
        $cursorScreenY = $editorY + $cursorLine - $this.ScrollOffsetY
        
        if ($cursorScreenX -ge 1 -and $cursorScreenX -le $width -and 
            $cursorScreenY -ge $editorY -and $cursorScreenY -lt $editorY + $editorHeight) {
            $output += [VT]::MoveTo($cursorScreenX, $cursorScreenY)
            $output += [VT]::ShowCursor()
        }
        
        return $output
    }
    
    [void] PageUp() {
        $pageSize = [Console]::WindowHeight - 6
        $currentLine = $this.GetCurrentLine()
        $targetLine = [Math]::Max(0, $currentLine - $pageSize)
        $this.CursorPosition = $this.LineStarts[$targetLine]
        $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY - $pageSize)
        $this.RequestRender()
    }
    
    [void] PageDown() {
        $pageSize = [Console]::WindowHeight - 6
        $currentLine = $this.GetCurrentLine()
        $targetLine = [Math]::Min($this.LineStarts.Count - 1, $currentLine + $pageSize)
        $this.CursorPosition = $this.LineStarts[$targetLine]
        $this.RequestRender()
    }
}


####\Screens/TextEditorScreen.ps1
# TextEditorScreen - Simple but functional text editor

class TextEditorScreen : Screen {
    [string]$FilePath
    [System.Collections.ArrayList]$Lines
    [int]$CursorX = 0
    [int]$CursorY = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [bool]$Modified = $false
    [bool]$InsertMode = $true
    [string]$StatusMessage = ""
    
    # Editor settings
    [int]$TabWidth = 4
    [bool]$ShowLineNumbers = $true
    [int]$LineNumberWidth = 5
    
    TextEditorScreen([string]$filePath) {
        $this.FilePath = $filePath
        $this.Title = "Text Editor"
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Initialize()
    }
    
    TextEditorScreen() {
        $this.FilePath = ""
        $this.Title = "Text Editor - New File"
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Lines.Add("") | Out-Null
        $this.Initialize()
    }
    
    [void] Initialize() {
        # Load file if specified
        if ($this.FilePath -and (Test-Path $this.FilePath)) {
            $this.LoadFile()
        } elseif (-not $this.Lines.Count) {
            $this.Lines.Add("") | Out-Null
        }
        
        # Key bindings
        $this.InitializeKeyBindings()
        
        # Update status bar
        $this.UpdateStatusBar()
    }
    
    [void] LoadFile() {
        try {
            $content = Get-Content -Path $this.FilePath -Raw
            if ($content) {
                $this.Lines.Clear()
                $lineArray = $content -split "`r?`n"
                foreach ($line in $lineArray) {
                    $this.Lines.Add($line) | Out-Null
                }
            } else {
                $this.Lines.Add("") | Out-Null
            }
            $this.Title = "Text Editor - $([System.IO.Path]::GetFileName($this.FilePath))"
            $this.Modified = $false
        }
        catch {
            $this.StatusMessage = "Error loading file: $_"
            $this.Lines.Add("") | Out-Null
        }
    }
    
    [void] SaveFile() {
        if (-not $this.FilePath) {
            $this.StatusMessage = "No file name - use Ctrl+S to save as"
            return
        }
        
        try {
            $content = $this.Lines -join "`n"
            Set-Content -Path $this.FilePath -Value $content -NoNewline
            $this.Modified = $false
            $this.StatusMessage = "File saved"
            $this.UpdateStatusBar()
        }
        catch {
            $this.StatusMessage = "Error saving file: $_"
        }
    }
    
    [void] InitializeKeyBindings() {
        # Navigation
        $this.BindKey([ConsoleKey]::UpArrow, { $this.MoveCursor(0, -1) })
        $this.BindKey([ConsoleKey]::DownArrow, { $this.MoveCursor(0, 1) })
        $this.BindKey([ConsoleKey]::LeftArrow, { $this.MoveCursor(-1, 0) })
        $this.BindKey([ConsoleKey]::RightArrow, { $this.MoveCursor(1, 0) })
        $this.BindKey([ConsoleKey]::Home, { $this.CursorX = 0; $this.RequestRender() })
        $this.BindKey([ConsoleKey]::End, { $this.CursorX = $this.Lines[$this.CursorY].Length; $this.RequestRender() })
        $this.BindKey([ConsoleKey]::PageUp, { $this.PageUp() })
        $this.BindKey([ConsoleKey]::PageDown, { $this.PageDown() })
        
        # Editing
        $this.BindKey([ConsoleKey]::Enter, { $this.InsertNewline() })
        $this.BindKey([ConsoleKey]::Backspace, { $this.Backspace() })
        $this.BindKey([ConsoleKey]::Delete, { $this.Delete() })
        $this.BindKey([ConsoleKey]::Tab, { $this.InsertTab() })
        
        # File operations - using Ctrl key combinations
        $this.KeyBindings[[ConsoleKey]::S] = { 
            param($key)
            if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                $this.SaveFile()
            } else {
                $this.InsertChar('s')
            }
        }
        
        $this.KeyBindings[[ConsoleKey]::Q] = {
            param($key)
            if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                if ($this.Modified) {
                    $this.StatusMessage = "Unsaved changes! Press Ctrl+Q again to quit"
                    if ($this.StatusMessage -eq "Unsaved changes! Press Ctrl+Q again to quit") {
                        $this.Active = $false
                    }
                } else {
                    $this.Active = $false
                }
            } else {
                $this.InsertChar('q')
            }
        }
        
        # Exit without Ctrl
        $this.BindKey([ConsoleKey]::Escape, { 
            if ($this.Modified) {
                $this.StatusMessage = "Unsaved changes! Press ESC again to quit"
            } else {
                $this.Active = $false
            }
        })
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        # Clear status message on any input
        if ($this.StatusMessage -and -not $this.StatusMessage.StartsWith("Unsaved")) {
            $this.StatusMessage = ""
        }
        
        # Check for bound keys first
        if ($this.KeyBindings.ContainsKey($key.Key)) {
            & $this.KeyBindings[$key.Key] $key
            return
        }
        
        # Insert characters
        if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
            $this.InsertChar($key.KeyChar)
        }
    }
    
    [void] UpdateStatusBar() {
        $this.StatusBarItems.Clear()
        
        # File info
        $fileName = if ($this.FilePath) { [System.IO.Path]::GetFileName($this.FilePath) } else { "New File" }
        $modifiedIndicator = if ($this.Modified) { "*" } else { "" }
        $this.StatusBarItems.Add(@{
            Label = "$fileName$modifiedIndicator"
        }) | Out-Null
        
        # Position info
        $this.StatusBarItems.Add(@{
            Label = "Line $($this.CursorY + 1)/$($this.Lines.Count), Col $($this.CursorX + 1)"
        }) | Out-Null
        
        # Mode
        $mode = if ($this.InsertMode) { "INSERT" } else { "OVERWRITE" }
        $this.StatusBarItems.Add(@{
            Label = $mode
        }) | Out-Null
        
        # Commands
        $this.AddStatusItem('Ctrl+S', 'save')
        $this.AddStatusItem('Ctrl+Q', 'quit')
        $this.AddStatusItem('ESC', 'exit')
        
        # Status message
        if ($this.StatusMessage) {
            $this.StatusBarItems.Add(@{
                Label = $this.StatusMessage
                Align = "Right"
            }) | Out-Null
        }
    }
    
    [string] RenderContent() {
        $output = ""
        $width = [Console]::WindowWidth
        $height = [Console]::WindowHeight
        
        # Clear background
        for ($y = 1; $y -le $height; $y++) {
            $output += [VT]::MoveTo(1, $y)
            $output += " " * $width
        }
        
        # Title bar
        $titleText = " $($this.Title) "
        $x = [int](($width - $titleText.Length) / 2)
        $output += [VT]::MoveTo($x, 1)
        $output += [VT]::RGB(100, 200, 255) + $titleText + [VT]::Reset()
        
        # Calculate visible area
        $editorY = 2
        $editorHeight = $height - 4  # Leave room for title and status bar
        $editorWidth = $width
        
        # Ensure cursor is visible
        $this.EnsureCursorVisible($editorHeight, $editorWidth)
        
        # Render lines
        $startLine = $this.ScrollOffsetY
        $endLine = [Math]::Min($startLine + $editorHeight, $this.Lines.Count)
        
        for ($i = $startLine; $i -lt $endLine; $i++) {
            $y = $editorY + ($i - $startLine)
            $output += [VT]::MoveTo(1, $y)
            
            # Line number
            if ($this.ShowLineNumbers) {
                $lineNum = ($i + 1).ToString().PadLeft($this.LineNumberWidth - 1)
                $output += [VT]::RGB(100, 100, 150) + $lineNum + " " + [VT]::Reset()
            }
            
            # Line content
            $line = $this.Lines[$i]
            $visibleLine = $this.GetVisibleLine($line, $this.ScrollOffsetX, $editorWidth - $this.LineNumberWidth)
            
            # Syntax highlighting (simple)
            if ($this.FilePath -like "*.ps1") {
                $visibleLine = $this.HighlightPowerShell($visibleLine)
            }
            
            $output += $visibleLine
        }
        
        # Show cursor
        $cursorScreenX = 1 + $this.LineNumberWidth + $this.CursorX - $this.ScrollOffsetX
        $cursorScreenY = $editorY + $this.CursorY - $this.ScrollOffsetY
        
        if ($cursorScreenX -ge 1 -and $cursorScreenX -le $width -and 
            $cursorScreenY -ge $editorY -and $cursorScreenY -lt $editorY + $editorHeight) {
            $output += [VT]::MoveTo($cursorScreenX, $cursorScreenY)
            $output += [VT]::ShowCursor()
        }
        
        return $output
    }
    
    [string] GetVisibleLine([string]$line, [int]$scrollX, [int]$maxWidth) {
        if ($scrollX -ge $line.Length) {
            return ""
        }
        
        $visibleLine = $line.Substring($scrollX)
        if ($visibleLine.Length -gt $maxWidth) {
            $visibleLine = $visibleLine.Substring(0, $maxWidth)
        }
        
        return $visibleLine
    }
    
    [string] HighlightPowerShell([string]$line) {
        # Simple PowerShell syntax highlighting
        $highlighted = $line
        
        # Comments
        if ($highlighted -match '^(\s*)(#.*)$') {
            return $Matches[1] + [VT]::RGB(100, 150, 100) + $Matches[2] + [VT]::Reset()
        }
        
        # Keywords (simple approach)
        $keywords = @('if', 'else', 'elseif', 'foreach', 'for', 'while', 'do', 'switch', 
                      'function', 'class', 'return', 'break', 'continue', 'try', 'catch', 'finally')
        
        foreach ($keyword in $keywords) {
            $pattern = "\b$keyword\b"
            if ($highlighted -match $pattern) {
                $highlighted = $highlighted -replace $pattern, ([VT]::RGB(150, 150, 255) + $keyword + [VT]::Reset())
            }
        }
        
        # Variables (simple)
        $highlighted = $highlighted -replace '(\$\w+)', ([VT]::RGB(255, 200, 100) + '$1' + [VT]::Reset())
        
        # Strings (very simple)
        $highlighted = $highlighted -replace '(".*?")', ([VT]::RGB(200, 150, 100) + '$1' + [VT]::Reset())
        $highlighted = $highlighted -replace "(\'.*?\')", ([VT]::RGB(200, 150, 100) + '$1' + [VT]::Reset())
        
        return $highlighted
    }
    
    [void] EnsureCursorVisible([int]$viewHeight, [int]$viewWidth) {
        # Vertical scrolling
        if ($this.CursorY -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CursorY
        } elseif ($this.CursorY -ge $this.ScrollOffsetY + $viewHeight) {
            $this.ScrollOffsetY = $this.CursorY - $viewHeight + 1
        }
        
        # Horizontal scrolling
        $effectiveWidth = $viewWidth - $this.LineNumberWidth
        if ($this.CursorX -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $this.CursorX
        } elseif ($this.CursorX -ge $this.ScrollOffsetX + $effectiveWidth) {
            $this.ScrollOffsetX = $this.CursorX - $effectiveWidth + 1
        }
    }
    
    # Cursor movement
    [void] MoveCursor([int]$dx, [int]$dy) {
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.Lines.Count - 1, $this.CursorY + $dy))
        
        if ($dx -ne 0) {
            $this.CursorX = [Math]::Max(0, $this.CursorX + $dx)
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        } else {
            # Vertical movement - try to maintain column
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        }
        
        $this.RequestRender()
    }
    
    [void] PageUp() {
        $pageSize = [Console]::WindowHeight - 6
        $this.CursorY = [Math]::Max(0, $this.CursorY - $pageSize)
        $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY - $pageSize)
        $this.RequestRender()
    }
    
    [void] PageDown() {
        $pageSize = [Console]::WindowHeight - 6
        $this.CursorY = [Math]::Min($this.Lines.Count - 1, $this.CursorY + $pageSize)
        $this.RequestRender()
    }
    
    # Editing operations
    [void] InsertChar([char]$char) {
        $line = $this.Lines[$this.CursorY]
        
        if ($this.InsertMode -or $this.CursorX -ge $line.Length) {
            # Insert mode
            $this.Lines[$this.CursorY] = $line.Insert($this.CursorX, $char)
        } else {
            # Overwrite mode
            $before = if ($this.CursorX -gt 0) { $line.Substring(0, $this.CursorX) } else { "" }
            $after = if ($this.CursorX + 1 -lt $line.Length) { $line.Substring($this.CursorX + 1) } else { "" }
            $this.Lines[$this.CursorY] = $before + $char + $after
        }
        
        $this.CursorX++
        $this.Modified = $true
        $this.UpdateStatusBar()
        $this.RequestRender()
    }
    
    [void] InsertNewline() {
        $line = $this.Lines[$this.CursorY]
        $before = if ($this.CursorX -gt 0) { $line.Substring(0, $this.CursorX) } else { "" }
        $after = if ($this.CursorX -lt $line.Length) { $line.Substring($this.CursorX) } else { "" }
        
        $this.Lines[$this.CursorY] = $before
        $this.Lines.Insert($this.CursorY + 1, $after)
        
        $this.CursorY++
        $this.CursorX = 0
        $this.Modified = $true
        $this.UpdateStatusBar()
        $this.RequestRender()
    }
    
    [void] Backspace() {
        if ($this.CursorX -gt 0) {
            # Delete character before cursor
            $line = $this.Lines[$this.CursorY]
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX - 1, 1)
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            # Join with previous line
            $prevLine = $this.Lines[$this.CursorY - 1]
            $currentLine = $this.Lines[$this.CursorY]
            $this.CursorX = $prevLine.Length
            $this.Lines[$this.CursorY - 1] = $prevLine + $currentLine
            $this.Lines.RemoveAt($this.CursorY)
            $this.CursorY--
        }
        
        $this.Modified = $true
        $this.UpdateStatusBar()
        $this.RequestRender()
    }
    
    [void] Delete() {
        $line = $this.Lines[$this.CursorY]
        
        if ($this.CursorX -lt $line.Length) {
            # Delete character at cursor
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX, 1)
        } elseif ($this.CursorY -lt $this.Lines.Count - 1) {
            # Join with next line
            $nextLine = $this.Lines[$this.CursorY + 1]
            $this.Lines[$this.CursorY] = $line + $nextLine
            $this.Lines.RemoveAt($this.CursorY + 1)
        }
        
        $this.Modified = $true
        $this.UpdateStatusBar()
        $this.RequestRender()
    }
    
    [void] InsertTab() {
        # Insert spaces instead of tab
        for ($i = 0; $i -lt $this.TabWidth; $i++) {
            $this.InsertChar(' ')
        }
    }
}


####\Services/ProjectService.ps1
# ProjectService - Business logic for project management
# Lightweight service focusing on project-related operations

class ProjectService {
    hidden [System.Collections.ArrayList]$Projects = [System.Collections.ArrayList]::new()
    hidden [string]$DataFile = "$HOME/.alcar/projects.json"
    
    ProjectService() {
        $this.LoadProjects()
    }
    
    [void] LoadProjects() {
        if (Test-Path $this.DataFile) {
            try {
                $json = Get-Content $this.DataFile -Raw
                $data = $json | ConvertFrom-Json
                $this.Projects.Clear()
                foreach ($projData in $data) {
                    $project = [Project]::new($projData.Name)
                    $project.Description = $projData.Description
                    $project.Id = $projData.Id
                    $this.Projects.Add($project) | Out-Null
                }
            }
            catch {
                Write-Error "Failed to load projects: $_"
            }
        }
        
        # Ensure default project exists
        if (-not ($this.Projects | Where-Object { $_.Name -eq "Default" })) {
            $default = [Project]::new("Default")
            $default.Description = "Default project for uncategorized tasks"
            $this.Projects.Add($default) | Out-Null
            $this.SaveProjects()
        }
    }
    
    [void] SaveProjects() {
        $dir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
        
        $data = @()
        foreach ($project in $this.Projects) {
            $data += @{
                Id = $project.Id
                Name = $project.Name
                Description = $project.Description
            }
        }
        
        $json = $data | ConvertTo-Json -Depth 10
        Set-Content -Path $this.DataFile -Value $json
    }
    
    [Project[]] GetAllProjects() {
        return $this.Projects.ToArray()
    }
    
    [Project] GetProject([string]$id) {
        return $this.Projects | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Project] GetProjectByName([string]$name) {
        return $this.Projects | Where-Object { $_.Name -eq $name } | Select-Object -First 1
    }
    
    [Project] AddProject([string]$name) {
        # Check if already exists
        $existing = $this.GetProjectByName($name)
        if ($existing) {
            return $existing
        }
        
        $project = [Project]::new($name)
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [void] UpdateProject([Project]$project) {
        $this.SaveProjects()
    }
    
    [void] DeleteProject([string]$id) {
        $project = $this.GetProject($id)
        if ($project -and $project.Name -ne "Default") {
            $this.Projects.Remove($project)
            $this.SaveProjects()
        }
    }
    
    [hashtable[]] GetProjectsWithStats([object]$taskService) {
        $result = @()
        
        foreach ($project in $this.Projects) {
            $tasks = $taskService.GetTasksByProject($project.Name)
            $completed = ($tasks | Where-Object { $_.Status -eq "Done" }).Count
            $total = $tasks.Count
            
            $result += @{
                Project = $project
                Name = $project.Name
                TaskCount = $total
                CompletedCount = $completed
                Progress = if ($total -gt 0) { $completed / $total } else { 0 }
            }
        }
        
        return $result
    }
}


####\Services/ServiceContainer.ps1
# ServiceContainer - Lightweight service layer for business logic separation
# Performance-focused implementation without heavy reflection

class ServiceContainer {
    hidden [hashtable]$Services = @{}
    hidden [hashtable]$Factories = @{}
    
    # Register a service instance
    [void] RegisterService([string]$name, [object]$instance) {
        $this.Services[$name] = $instance
    }
    
    # Register a factory for lazy initialization
    [void] RegisterFactory([string]$name, [scriptblock]$factory) {
        $this.Factories[$name] = $factory
    }
    
    # Get a service (lazy initialize if needed)
    [object] GetService([string]$name) {
        if ($this.Services.ContainsKey($name)) {
            return $this.Services[$name]
        }
        
        if ($this.Factories.ContainsKey($name)) {
            $instance = & $this.Factories[$name]
            $this.Services[$name] = $instance
            return $instance
        }
        
        return $null
    }
    
    # Check if service exists
    [bool] HasService([string]$name) {
        return $this.Services.ContainsKey($name) -or $this.Factories.ContainsKey($name)
    }
}

# Global service container instance
$global:ServiceContainer = [ServiceContainer]::new()

# Register core services
$global:ServiceContainer.RegisterFactory("TaskService", {
    . "$PSScriptRoot/TaskService.ps1"
    return [TaskService]::new()
})

$global:ServiceContainer.RegisterFactory("ProjectService", {
    . "$PSScriptRoot/ProjectService.ps1" 
    return [ProjectService]::new()
})

# ViewDefinitionService is already created as singleton
$global:ServiceContainer.RegisterService("ViewDefinitionService", $global:ViewDefinitionService)


####\Services/TaskService.ps1
# TaskService - Business logic for task management
# Separated from UI concerns for better architecture

class TaskService {
    hidden [System.Collections.ArrayList]$Tasks = [System.Collections.ArrayList]::new()
    hidden [string]$DataFile = "$HOME/.alcar/tasks.json"
    
    TaskService() {
        $this.LoadTasks()
    }
    
    [void] LoadTasks() {
        if (Test-Path $this.DataFile) {
            try {
                $json = Get-Content $this.DataFile -Raw
                $data = $json | ConvertFrom-Json
                $this.Tasks.Clear()
                foreach ($taskData in $data) {
                    $task = [Task]::new($taskData.Title)
                    $task.Status = $taskData.Status
                    $task.Description = $taskData.Description
                    if ($taskData.Project) {
                        $task.ProjectId = $taskData.Project
                    }
                    if ($taskData.DueDate) {
                        $task.DueDate = [DateTime]::Parse($taskData.DueDate)
                    }
                    if ($taskData.ParentId) {
                        $task.ParentId = $taskData.ParentId
                    }
                    $task.Id = $taskData.Id
                    $this.Tasks.Add($task) | Out-Null
                }
            }
            catch {
                Write-Error "Failed to load tasks: $_"
            }
        }
    }
    
    [void] SaveTasks() {
        $dir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
        
        $data = @()
        foreach ($task in $this.Tasks) {
            $data += @{
                Id = $task.Id
                Title = $task.Title
                Status = $task.Status
                Description = $task.Description
                Project = $task.ProjectId
                DueDate = if ($task.DueDate) { $task.DueDate.ToString("o") } else { $null }
                ParentId = $task.ParentId
            }
        }
        
        $json = $data | ConvertTo-Json -Depth 10
        Set-Content -Path $this.DataFile -Value $json
    }
    
    [Task[]] GetAllTasks() {
        return $this.Tasks.ToArray()
    }
    
    [Task[]] GetTasksByProject([string]$project) {
        return $this.Tasks | Where-Object { $_.ProjectId -eq $project }
    }
    
    [Task[]] GetSubtasks([string]$parentId) {
        return $this.Tasks | Where-Object { $_.ParentId -eq $parentId }
    }
    
    [Task] GetTask([string]$id) {
        return $this.Tasks | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Task] AddTask([string]$title) {
        $task = [Task]::new($title)
        $this.Tasks.Add($task) | Out-Null
        $this.SaveTasks()
        return $task
    }
    
    [Task] AddTask([Task]$task) {
        $this.Tasks.Add($task) | Out-Null
        $this.SaveTasks()
        return $task
    }
    
    [void] UpdateTask([Task]$task) {
        # Task is already in the list (reference type)
        $this.SaveTasks()
    }
    
    [void] DeleteTask([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            $this.Tasks.Remove($task)
            # Also remove subtasks
            $subtasks = $this.GetSubtasks($id)
            foreach ($subtask in $subtasks) {
                $this.Tasks.Remove($subtask)
            }
            $this.SaveTasks()
        }
    }
    
    [hashtable] GetTaskStats() {
        $total = $this.Tasks.Count
        $completed = ($this.Tasks | Where-Object { $_.Status -eq "Done" }).Count
        $inProgress = ($this.Tasks | Where-Object { $_.Status -eq "InProgress" }).Count
        $todo = ($this.Tasks | Where-Object { $_.Status -eq "Todo" }).Count
        
        return @{
            Total = $total
            Completed = $completed
            InProgress = $inProgress
            Todo = $todo
            CompletionRate = if ($total -gt 0) { [math]::Round($completed / $total * 100) } else { 0 }
        }
    }
}


####\Services/ViewDefinitionService.ps1
# ViewDefinitionService - Flexible data display configuration
# Minimal implementation focused on performance

class ViewDefinition {
    [string]$Name
    [hashtable[]]$Columns = @()
    [scriptblock]$Filter = $null
    [scriptblock]$Sort = $null
    [hashtable]$Cache = @{}
    
    ViewDefinition([string]$name) {
        $this.Name = $name
    }
    
    [void] AddColumn([string]$name, [string]$property, [int]$width, [scriptblock]$formatter = $null) {
        $this.Columns += @{
            Name = $name
            Property = $property
            Width = $width
            Formatter = $formatter
        }
    }
    
    [object[]] ApplyView([object[]]$data) {
        # Simple caching based on data count
        $cacheKey = "$($data.Count)"
        if ($this.Cache.ContainsKey($cacheKey)) {
            return $this.Cache[$cacheKey]
        }
        
        # Apply filter if defined
        if ($this.Filter) {
            $data = $data | Where-Object $this.Filter
        }
        
        # Apply sort if defined
        if ($this.Sort) {
            $data = $data | Sort-Object $this.Sort
        }
        
        # Cache and return
        $this.Cache[$cacheKey] = $data
        return $data
    }
    
    [string] FormatRow([object]$item) {
        $parts = @()
        foreach ($col in $this.Columns) {
            $value = $item.($col.Property)
            if ($col.Formatter) {
                $value = & $col.Formatter $value
            }
            $text = if ($null -eq $value) { "" } else { $value.ToString() }
            if ($text.Length -gt $col.Width) {
                $text = $text.Substring(0, $col.Width - 3) + "..."
            }
            $parts += $text.PadRight($col.Width)
        }
        return $parts -join " "
    }
}

class ViewDefinitionService {
    hidden [hashtable]$Views = @{}
    
    ViewDefinitionService() {
        $this.InitializeDefaultViews()
    }
    
    [void] InitializeDefaultViews() {
        # Task list view
        $taskView = [ViewDefinition]::new("TaskList")
        $taskView.AddColumn("Status", "Status", 3, { 
            param($s) 
            switch($s) {
                "Todo" { "[ ]" }
                "InProgress" { "[~]" }
                "Done" { "[✓]" }
                default { "[ ]" }
            }
        })
        $taskView.AddColumn("Title", "Title", 40, $null)
        $taskView.AddColumn("Due", "DueDate", 10, {
            param($d)
            if ($d) { $d.ToString("yyyy-MM-dd") } else { "" }
        })
        $taskView.Sort = { $_.Status, $_.DueDate }
        $this.Views["TaskList"] = $taskView
        
        # Project view
        $projectView = [ViewDefinition]::new("ProjectList")
        $projectView.AddColumn("Name", "Name", 30, $null)
        $projectView.AddColumn("Tasks", "TaskCount", 8, {
            param($c)
            "$c tasks"
        })
        $projectView.AddColumn("Progress", "Progress", 10, {
            param($p)
            $pct = [math]::Round($p * 100)
            "$pct%"
        })
        $this.Views["ProjectList"] = $projectView
    }
    
    [ViewDefinition] GetView([string]$name) {
        if ($this.Views.ContainsKey($name)) {
            return $this.Views[$name]
        }
        return $null
    }
    
    [void] RegisterView([ViewDefinition]$view) {
        $this.Views[$view.Name] = $view
    }
    
    [string[]] FormatData([string]$viewName, [object[]]$data) {
        $view = $this.GetView($viewName)
        if (-not $view) { return @() }
        
        $filteredData = $view.ApplyView($data)
        $result = @()
        foreach ($item in $filteredData) {
            $result += $view.FormatRow($item)
        }
        return $result
    }
}

# Global singleton instance
$global:ViewDefinitionService = [ViewDefinitionService]::new()


####\bolt.ps1
#!/usr/bin/env pwsh
# BOLT-AXIOM - The ONE launcher that works

param(
    [switch]$Debug
)

# Set error action preference
$ErrorActionPreference = 'Stop'

# Disable strict mode for class loading
Set-StrictMode -Off

try {
    Write-Host "Loading BOLT-AXIOM..." -ForegroundColor Cyan
    
    # Define loading order (dependencies first)
    $loadOrder = @(
        "Core",
        "Base",
        "Models",
        "Services",
        "Components",
        "FastComponents",
        "Screens"
    )
    
    # Load all files in correct order
    foreach ($folder in $loadOrder) {
        $folderPath = Join-Path $PSScriptRoot $folder
        if (-not (Test-Path $folderPath)) { 
            Write-Warning "Folder not found: $folder"
            continue 
        }
        
        if ($Debug) { Write-Host "Loading $folder..." -ForegroundColor Gray }
        
        # For Core folder, load vt100.ps1 first, then layout2.ps1
        if ($folder -eq "Core") {
            $vt100File = Join-Path $folderPath "vt100.ps1"
            if (Test-Path $vt100File) {
                if ($Debug) { Write-Host "  - Loading vt100.ps1 (priority)" -ForegroundColor DarkGray }
                . $vt100File
            }
            
            # Load Cell and Buffer for double buffering
            $cellFile = Join-Path $folderPath "Cell.ps1"
            if (Test-Path $cellFile) {
                if ($Debug) { Write-Host "  - Loading Cell.ps1" -ForegroundColor DarkGray }
                . $cellFile
            }
            
            $bufferFile = Join-Path $folderPath "Buffer.ps1"
            if (Test-Path $bufferFile) {
                if ($Debug) { Write-Host "  - Loading Buffer.ps1" -ForegroundColor DarkGray }
                . $bufferFile
            }
            
            $layout2File = Join-Path $folderPath "layout2.ps1"
            if (Test-Path $layout2File) {
                if ($Debug) { Write-Host "  - Loading layout2.ps1" -ForegroundColor DarkGray }
                . $layout2File
            }
            
            $dateparserFile = Join-Path $folderPath "dateparser.ps1"
            if (Test-Path $dateparserFile) {
                if ($Debug) { Write-Host "  - Loading dateparser.ps1" -ForegroundColor DarkGray }
                . $dateparserFile
            }
            
            $renderOptimizerFile = Join-Path $folderPath "RenderOptimizer.ps1"
            if (Test-Path $renderOptimizerFile) {
                if ($Debug) { Write-Host "  - Loading RenderOptimizer.ps1" -ForegroundColor DarkGray }
                . $renderOptimizerFile
            }
            
            # Skip the rest of Core files
            continue
        } elseif ($folder -eq "Base") {
            # Load Screen.ps1 first (base classes)
            $screenFile = Join-Path $folderPath "Screen.ps1"
            if (Test-Path $screenFile) {
                if ($Debug) { Write-Host "  - Loading Screen.ps1 (base classes)" -ForegroundColor DarkGray }
                . $screenFile
            }
            
            # Load Dialog base class (contains DialogResult enum)
            $dialogFile = Join-Path $folderPath "Dialog.ps1"
            if (Test-Path $dialogFile) {
                if ($Debug) { Write-Host "  - Loading Dialog.ps1 (dialog base)" -ForegroundColor DarkGray }
                . $dialogFile
            }
            
            # Load Component base class
            $componentFile = Join-Path $folderPath "Component.ps1"
            if (Test-Path $componentFile) {
                if ($Debug) { Write-Host "  - Loading Component.ps1 (component base)" -ForegroundColor DarkGray }
                . $componentFile
            }
            
            # Now load ScreenManager after base classes
            $screenManagerFile = Join-Path $PSScriptRoot "Core/ScreenManager.ps1"
            if (Test-Path $screenManagerFile) {
                if ($Debug) { Write-Host "  - Loading ScreenManager.ps1" -ForegroundColor DarkGray }
                . $screenManagerFile
            }
            
            # Load NavigationStandard after Screen class is defined
            $navigationStandardFile = Join-Path $PSScriptRoot "Core/NavigationStandard.ps1"
            if (Test-Path $navigationStandardFile) {
                if ($Debug) { Write-Host "  - Loading NavigationStandard.ps1" -ForegroundColor DarkGray }
                . $navigationStandardFile
            }
            
            continue
        } elseif ($folder -eq "Screens") {
            # Load dialog screens first
            $deleteConfirmFile = Join-Path $folderPath "DeleteConfirmDialog.ps1"
            if (Test-Path $deleteConfirmFile) {
                if ($Debug) { Write-Host "  - Loading DeleteConfirmDialog.ps1" -ForegroundColor DarkGray }
                . $deleteConfirmFile
            }
            
            $editDialogFile = Join-Path $folderPath "EditDialog.ps1"
            if (Test-Path $editDialogFile) {
                if ($Debug) { Write-Host "  - Loading EditDialog.ps1" -ForegroundColor DarkGray }
                . $editDialogFile
            }
            
            # Load all screens
            $screenFiles = @(
                "TaskScreen.ps1",
                "ProjectsScreen.ps1",
                "DashboardScreen.ps1",
                "SettingsScreen.ps1",
                "SettingsScreen_v2.ps1",
                "TextEditorScreen.ps1",
                "TextEditorScreen_v2.ps1",
                "FileBrowserScreen.ps1",
                "MainMenuScreen.ps1"
            )
            
            foreach ($screenFile in $screenFiles) {
                $fullPath = Join-Path $folderPath $screenFile
                if (Test-Path $fullPath) {
                    if ($Debug) { Write-Host "  - Loading $screenFile" -ForegroundColor DarkGray }
                    . $fullPath
                }
            }
            continue
        } elseif ($folder -eq "Services") {
            # Load services in specific order
            $serviceFiles = @(
                "ServiceContainer.ps1",
                "ViewDefinitionService.ps1",
                "TaskService.ps1",
                "ProjectService.ps1"
            )
            
            foreach ($serviceFile in $serviceFiles) {
                $fullPath = Join-Path $folderPath $serviceFile
                if (Test-Path $fullPath) {
                    if ($Debug) { Write-Host "  - Loading $serviceFile" -ForegroundColor DarkGray }
                    . $fullPath
                }
            }
            continue
        } elseif ($folder -eq "Components") {
            # Load all components except CommandPalette (which needs Screen types)
            $files = Get-ChildItem -Path $folderPath -Filter "*.ps1" | Where-Object { $_.Name -ne "CommandPalette.ps1" } | Sort-Object Name
            foreach ($file in $files) {
                if ($Debug) { Write-Host "  - Loading $($file.Name)" -ForegroundColor DarkGray }
                . $file.FullName
            }
            continue
        } elseif ($folder -eq "FastComponents") {
            # Load FastComponentBase first
            $baseFile = Join-Path $folderPath "FastComponentBase.ps1"
            if (Test-Path $baseFile) {
                if ($Debug) { Write-Host "  - Loading FastComponentBase.ps1 (base class)" -ForegroundColor DarkGray }
                . $baseFile
            }
            
            # Then load all other FastComponents
            $files = Get-ChildItem -Path $folderPath -Filter "*.ps1" | Where-Object { $_.Name -ne "FastComponentBase.ps1" } | Sort-Object Name
            foreach ($file in $files) {
                if ($Debug) { Write-Host "  - Loading $($file.Name)" -ForegroundColor DarkGray }
                . $file.FullName
            }
            continue
        } else {
            $files = Get-ChildItem -Path $folderPath -Filter "*.ps1" | Sort-Object Name
        }
        
        foreach ($file in $files) {
            if ($Debug) { Write-Host "  - Loading $($file.Name)" -ForegroundColor DarkGray }
            . $file.FullName
        }
    }
    
    # Load CommandPalette after all screens are loaded
    $commandPaletteFile = Join-Path $PSScriptRoot "Components/CommandPalette.ps1"
    if (Test-Path $commandPaletteFile) {
        if ($Debug) { Write-Host "Loading CommandPalette.ps1 (after screens)" -ForegroundColor DarkGray }
        . $commandPaletteFile
    }
    
    Write-Host "Framework loaded!" -ForegroundColor Green
    
    # Create and run screen manager
    $global:ScreenManager = [ScreenManager]::new()
    
    # Start with main menu
    $mainMenu = [MainMenuScreen]::new()
    $global:ScreenManager.SetRoot($mainMenu)
    
    # Run the application
    $global:ScreenManager.Run()
}
catch {
    Write-Host "`nError: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkGray
    Write-Host "`nPress any key to exit..." -ForegroundColor Yellow
    [Console]::ReadKey($true) | Out-Null
}
finally {
    # Cleanup is handled by ScreenManager
    Write-Host "BOLT ⚡" -ForegroundColor Cyan
}


####\fc2.ps1
#------------------------------------------------------------------------------------------
# SCRIPT:      filecopy-and-concatenate.ps1
#
# DESCRIPTION: Finds specified file types in a given path and its subdirectories.
#              For each file, it can create a .txt copy and/or concatenate all
#              file contents into a single output file.
#
# FEATURES:
#   - Full parameter support for path, file types, and output name.
#   - Safety features: Supports -WhatIf and -Confirm for all file operations.
#   - Verbose output: Use the -Verbose switch to see detailed progress.
#   - Performance: Uses an efficient single-write operation for the concatenated file.
#   - Robustness: Uses idiomatic PowerShell for path manipulation and error handling.
#   - Compatibility: Works on Windows PowerShell 5.1 and newer.
#   - NEW: Can create individual .txt copies of each source file.
#
# USAGE:
#   # Basic run in the current folder for PowerShell files
#   .\filecopy-and-concatenate.ps1 -Verbose
#
#   # Run on a different project, for C# files, with a different output name
#   .\filecopy-and-concatenate.ps1 -Path "C:\Projects\MyWebApp" -Include "*.cs" -OutputFileName "SourceCode.txt"
#
#   # To also create individual .txt copies of each file:
#   .\filecopy-and-concatenate.ps1 -CreateIndividualCopies -Verbose
#
#   # Perform a "dry run" to see what would happen without making any changes
#   .\filecopy-and-concatenate.ps1 -Path "C:\SomethingImportant" -CreateIndividualCopies -WhatIf
#
#------------------------------------------------------------------------------------------

# Enable support for -WhatIf, -Confirm, and advanced parameter binding
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    # The starting directory to search in. Defaults to the current directory.
    [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "The root path to search for files.")]
    [string]
    $Path = (Get-Location).Path,

    # An array of file patterns to include. Defaults to PowerShell script files.
    [Parameter(Mandatory = $false, HelpMessage = "File patterns to include, e.g., '*.ps1', '*.psm1'.")]
    [string[]]
    $Include = @("*.ps1", "*.psm1"),

    # The name of the final concatenated output file.
    [Parameter(Mandatory = $false, HelpMessage = "Name of the concatenated output file.")]
    [string]
    $OutputFileName = "all.txt",

    # Switch to create a .txt copy of each individual file found.
    [Parameter(Mandatory = $false, HelpMessage = "If specified, creates a .txt copy of each found file.")]
    [switch]
    $CreateIndividualCopies
)

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Resolve-Path returns a PathInfo object. We use it for robustness.
    $resolvedPathObject = Resolve-Path -Path $Path
    $basePathString = $resolvedPathObject.Path # Store the string path for reuse
    $outputFilePath = Join-Path -Path $basePathString -ChildPath $OutputFileName

    Write-Verbose "Starting operations in: $basePathString"
    Write-Verbose "Searching for file types: $($Include -join ', ')"
    Write-Verbose "Output file will be: $outputFilePath"
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Individual .txt copies will be created."
    }

    # --- Step 1: Find all specified files recursively ---
    $filesToProcess = Get-ChildItem -Path $basePathString -Recurse -Include $Include -File

    if ($null -eq $filesToProcess) {
        Write-Warning "No files found matching the specified criteria."
        return # Exit gracefully if no files are found
    }

    Write-Verbose "Found $($filesToProcess.Count) files to process."

    # --- Step 2: Clear the existing output file if it exists ---
    # This is part of the concatenation process, so it's good to do it early.
    if ((Test-Path $outputFilePath) -and $PSCmdlet.ShouldProcess($outputFilePath, "Remove existing output file")) {
        Remove-Item $outputFilePath -Force
    }

    # --- Step 3: Process each file for individual copies (if requested) ---
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Processing files to create individual .txt copies..."
        foreach ($file in $filesToProcess) {
            # Create a new filename by changing the extension to .txt
            $txtCopyPath = [System.IO.Path]::ChangeExtension($file.FullName, ".txt")

            # Use ShouldProcess for -WhatIf and -Confirm support
            if ($PSCmdlet.ShouldProcess($txtCopyPath, "Copy from '$($file.Name)'")) {
                Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force
                Write-Verbose "Created copy: '$txtCopyPath'"
            }
        }
    }

    # --- Step 4: Concatenate all files into the output file (Efficiently) ---
    Write-Verbose "Starting concatenation of all files into '$OutputFileName'..."
    if ($PSCmdlet.ShouldProcess($outputFilePath, "Concatenate $($filesToProcess.Count) files")) {
        # Using a subexpression `$(...)` to gather all output before writing to the file once.
        Set-Content -Path $outputFilePath -Encoding UTF8 -Value $(
            foreach ($file in $filesToProcess) {
                # Calculate the relative path for the header
                $relativePath = $file.FullName.Substring($basePathString.Length)
                # Ensure consistent format like '\subdir\file.ps1'
                $relativePath = '\' + $relativePath.TrimStart('\/')

                # Output the header for this file
                "####$relativePath"

                # Output the file's content
                Get-Content -Path $file.FullName -Raw -Encoding Default

                # Output two blank lines for separation
                ""
                ""
            }
        )
        Write-Host "All operations complete. Concatenated content saved to '$outputFilePath'."
    }
}
catch {
    # A global catch block for any unexpected, terminating errors.
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    Write-Error "Script execution halted at line $($_.InvocationInfo.ScriptLineNumber): $($_.InvocationInfo.Line)"
}


####\fix-inline-conditionals.ps1
#!/usr/bin/env pwsh
# Script to fix inline conditional expressions that PowerShell doesn't support

$ErrorActionPreference = 'Stop'

# Find all PS1 files
$files = Get-ChildItem -Path . -Filter "*.ps1" -Recurse | Where-Object { $_.FullName -notmatch 'fix-inline-conditionals\.ps1' }

$totalFixed = 0

foreach ($file in $files) {
    $content = Get-Content -Path $file.FullName -Raw
    $originalContent = $content
    $fileFixed = 0
    
    # Pattern 1: Variable assignment with inline if
    # $var = value - (if (condition) { x } else { y })
    $pattern1 = '(\$\w+\s*=\s*[^-\n]+)\s*-\s*\(if\s*\(([^)]+)\)\s*\{\s*(\d+)\s*\}\s*else\s*\{\s*(\d+)\s*\}\)'
    $content = [regex]::Replace($content, $pattern1, {
        param($match)
        $prefix = $match.Groups[1].Value
        $condition = $match.Groups[2].Value
        $trueValue = $match.Groups[3].Value
        $falseValue = $match.Groups[4].Value
        $varMatch = [regex]::Match($prefix, '\$(\w+)\s*=')
        $varName = $varMatch.Groups[1].Value
        
        @"
if ($condition) {
            $prefix - $trueValue
        } else {
            $prefix - $falseValue
        }
"@
    })
    
    # Pattern 2: Simple inline if assignments
    # $var = if (condition) { value1 } else { value2 }
    $pattern2 = '(\$\w+)\s*=\s*if\s*\(([^)]+)\)\s*\{\s*([^}]+)\s*\}\s*else\s*\{\s*([^}]+)\s*\}'
    while ($content -match $pattern2) {
        $content = [regex]::Replace($content, $pattern2, {
            param($match)
            $var = $match.Groups[1].Value
            $condition = $match.Groups[2].Value
            $trueValue = $match.Groups[3].Value.Trim()
            $falseValue = $match.Groups[4].Value.Trim()
            
            @"
if ($condition) {
            $var = $trueValue
        } else {
            $var = $falseValue
        }
"@
        }, 1)
        $fileFixed++
    }
    
    # Pattern 3: Inline if in expressions (common in calculations)
    # something + (if (condition) { x } else { y })
    $pattern3 = '([^=\n]+)\s*([+\-*/])\s*\(if\s*\(([^)]+)\)\s*\{\s*(\d+)\s*\}\s*else\s*\{\s*(\d+)\s*\}\)'
    while ($content -match $pattern3) {
        # Extract the full line for context
        $lines = $content -split "`n"
        $newLines = @()
        $modified = $false
        
        foreach ($line in $lines) {
            if ($line -match $pattern3 -and $line -match '^\s*\$(\w+)\s*=') {
                $varName = $matches[1]
                $fullMatch = [regex]::Match($line, $pattern3)
                $prefix = $fullMatch.Groups[1].Value
                $operator = $fullMatch.Groups[2].Value
                $condition = $fullMatch.Groups[3].Value
                $trueValue = $fullMatch.Groups[4].Value
                $falseValue = $fullMatch.Groups[5].Value
                
                $newLines += "        if ($condition) {"
                $newLines += "            `$$varName = $prefix $operator $trueValue"
                $newLines += "        } else {"
                $newLines += "            `$$varName = $prefix $operator $falseValue"
                $newLines += "        }"
                $modified = $true
                $fileFixed++
            } else {
                $newLines += $line
            }
        }
        
        if ($modified) {
            $content = $newLines -join "`n"
        } else {
            break
        }
    }
    
    if ($content -ne $originalContent) {
        Write-Host "Fixing $($file.Name)..." -ForegroundColor Yellow
        Set-Content -Path $file.FullName -Value $content -NoNewline
        $totalFixed += $fileFixed
    }
}

Write-Host "`nFixed $totalFixed inline conditionals!" -ForegroundColor Green


####\run-test.ps1
#!/usr/bin/env pwsh
# Quick test runner

Write-Host @"
BOLT-AXIOM Visual Test
=====================

KEYS TO TEST:
- 'e' = Edit mode (should see YELLOW background)
- 's' = Add subtask (should see "EDITING SUBTASK" in yellow)
- 'd' = Delete (should see RED dialog)
- 'E' = Detail edit (should open new screen)

Starting in 3 seconds...
"@ -ForegroundColor Cyan

Start-Sleep -Seconds 3

. ./bolt.ps1


####\test-colors.ps1
#!/usr/bin/env pwsh
# Test color rendering

. ./Core/vt100.ps1

Write-Host "Testing colors:" -ForegroundColor Cyan

# Test yellow background
$output = [VT]::RGBBG(255, 255, 0) + [VT]::RGB(0, 0, 0) + " This should have yellow background " + [VT]::Reset()
[Console]::Write($output)
Write-Host ""

# Test edit mode style
$output2 = [VT]::RGBBG(255, 255, 0) + [VT]::RGB(0, 0, 0) + " EDIT MODE TEST ▌" + [VT]::Reset()
[Console]::Write($output2)
Write-Host ""

# Test selected style
$output3 = [VT]::Selected() + " > Selected item" + [VT]::Reset()
[Console]::Write($output3)
Write-Host ""

Write-Host "`nIf you see yellow background above, colors are working" -ForegroundColor Green


####\test-edit-mode.ps1
#!/usr/bin/env pwsh
# Test edit mode functionality

# Load the framework
. ./bolt.ps1 -Debug

Write-Host "`nPress 'e' to enter edit mode on a task" -ForegroundColor Yellow
Write-Host "Look for yellow background and cursor block" -ForegroundColor Yellow
Write-Host "Press Ctrl+C to exit`n" -ForegroundColor Gray


####\test-edit-visual.ps1
#!/usr/bin/env pwsh
# Test edit mode visual feedback

Write-Host "Starting BOLT-AXIOM..." -ForegroundColor Cyan
Write-Host "Instructions:" -ForegroundColor Yellow
Write-Host "1. Press 'e' to edit a task - look for YELLOW bar at bottom" -ForegroundColor Gray
Write-Host "2. Press 's' to add subtask - status bar should say 'EDITING SUBTASK'" -ForegroundColor Gray
Write-Host "3. Press 'd' to delete - should see RED confirmation dialog" -ForegroundColor Gray
Write-Host "4. Press 'E' (shift+e) for detail edit screen" -ForegroundColor Gray
Write-Host ""
Write-Host "Press any key to start..." -ForegroundColor Green
[Console]::ReadKey($true) | Out-Null

# Start the app
. ./bolt.ps1


####\test-fixed-keys.ps1
#!/usr/bin/env pwsh
# Test the fixed key handling

Write-Host @"
BOLT-AXIOM Key Test
==================

FIXED BEHAVIORS:
- 'a' = Opens detail screen for new task (not inline)
- 'E' = Opens detail screen for editing (uppercase E)
- 'd' = Shows red delete confirmation dialog
- 'e' = Inline edit (lowercase e) - yellow background

Make sure you're in the TASKS pane (Tab to switch)

"@ -ForegroundColor Cyan

# Load and run
. ./bolt.ps1


####\test-flicker-fix.ps1
#!/usr/bin/env pwsh
# Direct test for flicker issues

Write-Host "Testing flicker fixes..." -ForegroundColor Cyan
Write-Host "Watch for:" -ForegroundColor Yellow
Write-Host "  1. Smooth initial load (no multiple clears)" -ForegroundColor White
Write-Host "  2. Clean transitions when pressing 't' for Tasks" -ForegroundColor White  
Write-Host "  3. No flicker when navigating with arrow keys" -ForegroundColor White
Write-Host ""
Write-Host "Press Enter to start test..." -ForegroundColor Green
Read-Host

# Run with debug to see loading order
& "$PSScriptRoot/bolt.ps1" -Debug


####\test-flicker-fixed.ps1
#!/usr/bin/env pwsh
# Test script to verify flicker fixes

Write-Host "Starting ALCAR with flicker fixes applied..." -ForegroundColor Green
Write-Host "Press Ctrl+Q to quit the application" -ForegroundColor Yellow
Write-Host ""
Start-Sleep -Seconds 2

# Run the application
& "$PSScriptRoot/bolt.ps1"


####\test-flicker.ps1
#!/usr/bin/env pwsh
# Test script to identify source of flickering

Write-Host "Testing flicker source..." -ForegroundColor Yellow

# Test 1: Basic render loop
Write-Host "`nTest 1: Checking basic render loop (press any key to stop)"
$i = 0
while (-not [Console]::KeyAvailable) {
    [Console]::SetCursorPosition(0, 3)
    Write-Host "Render count: $i" -NoNewline
    $i++
    Start-Sleep -Milliseconds 20
}
[Console]::ReadKey($true) | Out-Null

# Test 2: With clear
Write-Host "`n`nTest 2: With clear screen (press any key to stop)"
$i = 0
while (-not [Console]::KeyAvailable) {
    [Console]::Clear()
    Write-Host "Render count: $i"
    $i++
    Start-Sleep -Milliseconds 20
}
[Console]::ReadKey($true) | Out-Null

# Test 3: With escape sequences
Write-Host "`n`nTest 3: With escape sequence clear (press any key to stop)"
$i = 0
while (-not [Console]::KeyAvailable) {
    [Console]::Write("`e[2J`e[H")
    [Console]::Write("Render count: $i")
    $i++
    Start-Sleep -Milliseconds 20
}
[Console]::ReadKey($true) | Out-Null

# Test 4: With home only
Write-Host "`n`nTest 4: With home only (press any key to stop)"
$i = 0
while (-not [Console]::KeyAvailable) {
    [Console]::Write("`e[H")
    [Console]::Write("Render count: $i          ")  # Spaces to overwrite
    $i++
    Start-Sleep -Milliseconds 20
}
[Console]::ReadKey($true) | Out-Null

Write-Host "`n`nDone. Which test flickered?"


####\test-key-handling.ps1
#!/usr/bin/env pwsh
# Test script to verify key handling in TaskScreen

Write-Host "Key Handling Test for TaskScreen" -ForegroundColor Cyan
Write-Host "================================" -ForegroundColor Cyan
Write-Host ""

# Test ConsoleKeyInfo behavior
Write-Host "Testing ConsoleKeyInfo behavior:" -ForegroundColor Yellow

# Test lowercase 'e'
$lowerE = [System.ConsoleKeyInfo]::new('e', [System.ConsoleKey]::E, $false, $false, $false)
Write-Host "Lowercase 'e': KeyChar='$($lowerE.KeyChar)' (ASCII: $([int][char]$lowerE.KeyChar))"

# Test uppercase 'E' 
$upperE = [System.ConsoleKeyInfo]::new('E', [System.ConsoleKey]::E, $true, $false, $false)
Write-Host "Uppercase 'E': KeyChar='$($upperE.KeyChar)' (ASCII: $([int][char]$upperE.KeyChar))"

# Test case-sensitive comparison
Write-Host "`nCase-sensitive comparison test:" -ForegroundColor Yellow
Write-Host "'e' -eq 'e': $('e' -eq 'e')"
Write-Host "'e' -eq 'E': $('e' -eq 'E')"
Write-Host "'E' -eq 'E': $('E' -eq 'E')"

# Simulate menu items
$menuItems = @(
    @{Key='e'; Label='edit'; Action='Edit'},
    @{Key='E'; Label='details'; Action='EditDetails'}
)

Write-Host "`nMenu matching simulation:" -ForegroundColor Yellow

# Test with lowercase e
Write-Host "`nTesting with lowercase 'e':"
foreach ($item in $menuItems) {
    if ($lowerE.KeyChar -eq $item.Key) {
        Write-Host "  MATCH: $($item.Key) -> $($item.Action)" -ForegroundColor Green
    } else {
        Write-Host "  no match: $($item.Key)" -ForegroundColor DarkGray
    }
}

# Test with uppercase E
Write-Host "`nTesting with uppercase 'E':"
foreach ($item in $menuItems) {
    if ($upperE.KeyChar -eq $item.Key) {
        Write-Host "  MATCH: $($item.Key) -> $($item.Action)" -ForegroundColor Green
    } else {
        Write-Host "  no match: $($item.Key)" -ForegroundColor DarkGray
    }
}

Write-Host "`nPress any key to test actual keyboard input..."
Write-Host "Try pressing: e, E (shift+e), d, a" -ForegroundColor Yellow
Write-Host "Press 'q' to quit" -ForegroundColor Yellow
Write-Host ""

# Real keyboard test
while ($true) {
    $key = [Console]::ReadKey($true)
    
    Write-Host "Key pressed: " -NoNewline
    Write-Host "KeyChar='$($key.KeyChar)'" -NoNewline -ForegroundColor Cyan
    Write-Host " ASCII=$([int][char]$key.KeyChar)" -NoNewline -ForegroundColor DarkCyan
    Write-Host " Key=$($key.Key)" -NoNewline -ForegroundColor DarkCyan
    Write-Host " Shift=$($key.Modifiers -band [ConsoleModifiers]::Shift)" -ForegroundColor DarkCyan
    
    # Test against menu items
    foreach ($item in $menuItems) {
        if ($key.KeyChar -eq $item.Key) {
            Write-Host "  -> Would trigger: $($item.Action)" -ForegroundColor Green
        }
    }
    
    if ($key.KeyChar -eq 'q') {
        break
    }
}

Write-Host "`nTest complete!" -ForegroundColor Green


####\test-loading.ps1
#!/usr/bin/env pwsh
# Test script to verify all components load correctly

param(
    [switch]$Verbose
)

$ErrorActionPreference = 'Stop'

try {
    Write-Host "Testing ALCAR loading..." -ForegroundColor Cyan
    
    # Source the bolt.ps1 script but skip the main execution
    $scriptContent = Get-Content -Path "./bolt.ps1" -Raw
    
    # Remove the last part that creates and runs the screen manager
    $scriptContent = $scriptContent -replace '# Create and run screen manager[\s\S]*$', '# Skipped for testing'
    
    # Execute the modified script
    Invoke-Expression $scriptContent
    
    Write-Host "`nAll components loaded successfully!" -ForegroundColor Green
    
    # Test creating instances of screens
    Write-Host "`nTesting screen instantiation..." -ForegroundColor Yellow
    
    $screens = @(
        "MainMenuScreen",
        "TaskScreen", 
        "ProjectsScreen",
        "DashboardScreen",
        "FileBrowserScreen",
        "TextEditorScreen",
        "TextEditorScreenV2",
        "SettingsScreenV2"
    )
    
    foreach ($screenName in $screens) {
        try {
            $screen = Invoke-Expression "[$screenName]::new()"
            Write-Host "✓ $screenName" -ForegroundColor Green
        }
        catch {
            Write-Host "✗ $screenName - $_" -ForegroundColor Red
        }
    }
    
    Write-Host "`nAll tests passed!" -ForegroundColor Green
}
catch {
    Write-Host "`nError: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkGray
    exit 1
}


####\test-menu-alignment.ps1
#!/usr/bin/env pwsh
# Visual test for menu alignment

# Direct test of menu rendering
. "$PSScriptRoot/Core/vt100.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Screens/MainMenuScreen.ps1"

# Create a test screen
$menu = [MainMenuScreen]::new()

# Simulate different window sizes
$sizes = @(
    @{Width=80; Height=25; Name="Standard"},
    @{Width=120; Height=30; Name="Large"},
    @{Width=60; Height=20; Name="Small"}
)

foreach ($size in $sizes) {
    Write-Host "`nTesting $($size.Name) size ($($size.Width)x$($size.Height)):" -ForegroundColor Cyan
    
    # Mock console size
    $originalWidth = [Console]::WindowWidth
    $originalHeight = [Console]::WindowHeight
    
    try {
        # This won't actually resize the console, but will test the calculations
        [Console]::SetWindowSize($size.Width, $size.Height)
        
        # Test render without actually displaying
        $output = $menu.RenderContent()
        
        # Check for proper alignment markers
        $lines = $output -split "`e\["
        $boxCount = ($lines | Where-Object { $_ -match "┌" }).Count
        
        Write-Host "  - Box elements found: $boxCount" -ForegroundColor $(if ($boxCount -gt 0) { "Green" } else { "Red" })
        Write-Host "  - Content length: $($output.Length) chars" -ForegroundColor Gray
        
    } catch {
        Write-Host "  - Error: $_" -ForegroundColor Red
    }
}

Write-Host "`nAlignment test complete." -ForegroundColor Green
Write-Host "Run ./bolt.ps1 to see the actual rendering." -ForegroundColor Yellow


####\test-navigation.ps1
#!/usr/bin/env pwsh
# Test the navigation system

Write-Host @"
BOLT-AXIOM Navigation Test
=========================

You should see a main menu with:
- Task Manager
- Projects  
- Dashboard
- Settings
- Exit

Navigation:
- Use arrow keys to move
- Press Enter to select
- Press 't' for tasks, 'p' for projects, etc.
- Press Esc or Backspace to go back
- Ctrl+Q to quit from anywhere

"@ -ForegroundColor Cyan

Write-Host "Starting in 3 seconds..." -ForegroundColor Yellow
Start-Sleep -Seconds 3

. ./bolt.ps1


####\test-rendering-fix.ps1
#!/usr/bin/env pwsh
# Test the rendering fixes

Write-Host "Testing BOLT-AXIOM rendering fixes..." -ForegroundColor Cyan
Write-Host "This will launch the main menu. Check for:" -ForegroundColor Yellow
Write-Host "  1. No flicker when navigating" -ForegroundColor White
Write-Host "  2. Proper box alignment for selected items" -ForegroundColor White
Write-Host "  3. Description text inside the selection box" -ForegroundColor White
Write-Host "  4. Smooth transitions between screens" -ForegroundColor White
Write-Host ""
Write-Host "Press any key to continue..." -ForegroundColor Green
[Console]::ReadKey($true) | Out-Null

# Launch the application
& "$PSScriptRoot/bolt.ps1"


####\test-screen-switching.ps1
#!/usr/bin/env pwsh
# Test script to verify screen switching works without overlap

Write-Host "Testing screen switching and flicker fixes..." -ForegroundColor Green
Write-Host ""
Write-Host "Navigation:" -ForegroundColor Yellow
Write-Host "  - Use arrow keys to navigate menus"
Write-Host "  - Press 't' for Tasks, 'p' for Projects, 'd' for Dashboard"
Write-Host "  - Press 'q' or Escape to go back"
Write-Host "  - Press Ctrl+Q to quit entirely"
Write-Host ""
Write-Host "Press any key to start..." -ForegroundColor Cyan
[Console]::ReadKey($true) | Out-Null

# Run the application
& "$PSScriptRoot/bolt.ps1"


####\test-simple.ps1
#!/usr/bin/env pwsh
# Simple test to verify bolt.ps1 loads without errors

$ErrorActionPreference = 'Stop'

Write-Host "Testing ALCAR loading..." -ForegroundColor Cyan

# Set a flag to skip the main execution
$global:ALCAR_TEST_MODE = $true

try {
    # Source bolt.ps1
    . ./bolt.ps1
    
    Write-Host "`nFramework loaded successfully!" -ForegroundColor Green
    exit 0
}
catch {
    Write-Host "`nError during loading: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkGray
    exit 1
}


####\test-tree-view.ps1
#!/usr/bin/env pwsh
# Test tree view and edit mode

param(
    [int]$Duration = 10
)

Write-Host "Starting BOLT-AXIOM for $Duration seconds..." -ForegroundColor Cyan
Write-Host "Test:" -ForegroundColor Yellow
Write-Host "- Look for tree view with ▼/▶ indicators" -ForegroundColor Gray
Write-Host "- Press 'e' to enter edit mode (yellow background)" -ForegroundColor Gray
Write-Host "- Press Enter on parent tasks to expand/collapse" -ForegroundColor Gray
Write-Host "- Press 'x' to expand/collapse all" -ForegroundColor Gray
Write-Host ""

# Start bolt.ps1 in background
$process = Start-Process -FilePath "pwsh" -ArgumentList "-File", "./bolt.ps1" -PassThru

# Wait for specified duration
Start-Sleep -Seconds $Duration

# Stop the process
$process | Stop-Process -Force

Write-Host "`nTest completed!" -ForegroundColor Green


