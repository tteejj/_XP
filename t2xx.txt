# Enhanced PowerShell Todoist TUI - Professional Version
# Rich display, smart completions, full feature implementation

# Harden scripting semantics early
Set-StrictMode -Version Latest

# === GLOBAL CONFIGURATION ===
$global:TaskFile = if ($env:PMC_TASK_FILE) { $env:PMC_TASK_FILE } else { Join-Path $PSScriptRoot "tasks.json" }
$global:BackupFile = Join-Path $PSScriptRoot "tasks.bak"
$global:UndoFile = Join-Path $PSScriptRoot "tasks.undo"
$global:ConfigFile = Join-Path $PSScriptRoot "config.json"
$global:DataPath = Join-Path $PSScriptRoot "data"
$global:LastShownTaskMap = @{}
$global:CurrentContext = "inbox"
$global:LastAction = $null
$global:SessionStats = @{
    TasksAdded = 0
    TasksCompleted = 0
    TimeLogged = 0
    CommandsRun = 0
    SessionStart = Get-Date
}

# Ensure application data path exists for templates/backups/etc.
try { if (-not (Test-Path $global:DataPath)) { New-Item -ItemType Directory -Path $global:DataPath -Force | Out-Null } } catch {}

# Debug logging helper (file-only). Enabled when -Debug is used or Behavior.DebugLogging is true.
function Write-DebugLog {
    param([string]$Message)
    try {
        $logEnabled = $false
        try {
            $cfg = [ConfigManager]::Config
            if ($cfg -and $cfg.Behavior -and $cfg.Behavior.DebugLogging) { $logEnabled = $true }
        } catch {}
        # Allow forcing debug logging via environment variable
        try { if ($env:PMC_DEBUG -and ($env:PMC_DEBUG -eq '1' -or $env:PMC_DEBUG -eq 'true')) { $logEnabled = $true } } catch {}
        if ($DebugPreference -and $DebugPreference -ne 'SilentlyContinue') { $logEnabled = $true }
        if (-not $logEnabled) { return }
        $logPath = Join-Path $PSScriptRoot 'debug.log'
        # Simple rotation if > 10MB
        if (Test-Path $logPath) {
            try {
                $len = (Get-Item $logPath).Length
                if ($len -gt 10MB) { Move-Item -Force $logPath ($logPath + '.old') }
            } catch {}
        }
        $ts = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss.fff')
        $msg = $Message
        try {
            # Basic redaction of sensitive tokens
            $msg = ($msg -replace '((?i)(token|secret|password|passwd|apikey|key)\s*[:=]\s*)(\S+)', '$1****')
            # Redact long hex strings that look like secrets
            $msg = ($msg -replace '\b[0-9a-fA-F]{32,}\b', '****')
        } catch {}
        Add-Content -Path $logPath -Value ("[$ts] " + $msg)
    } catch {}
}

# LastShownTaskMap capacity guard
function Ensure-LastShownCapacity {
    param([int]$Max = 1000)
    try {
        if ($global:LastShownTaskMap.Count -gt $Max) {
            $global:LastShownTaskMap.Clear()
            Write-DebugLog "LastShownTaskMap cleared due to capacity"
        }
    } catch {}
}

function Set-LastShownEntry {
    param([int]$LocalId, [int]$TaskId)
    Ensure-LastShownCapacity
    $global:LastShownTaskMap[$LocalId] = $TaskId
}

# === CONFIGURATION MANAGER ===
class ConfigManager {
    static [hashtable] $Config = @{
        Colors = @{
            Overdue = "Red"
            Today = "Yellow"
            Tomorrow = "Cyan"
            Upcoming = "Green"
            Priority1 = "Magenta"
            Priority2 = "Yellow"
            Priority3 = "Blue"
            Project = "DarkCyan"
            Context = "Cyan"
            TimeLog = "Blue"
            Ghost = "Gray"
        }
        Display = @{
            MaxTasksPerSection = 10
            ShowEmptyProjects = $false
            ShowCompletedInReports = $true
            DateFormat = "ddd MM/dd"
            Use24Hour = $false
            CompactMode = $false
            UseAsciiIcons = $false
        }
        Behavior = @{
            AutoArchiveAfterDays = 30
            DefaultDueDateDays = 7
            WarnBeforeDelete = $true
            ShowWelcome = $true
            EnableNotifications = $false
            EnableCsvLedger = $true
            AcceptOnType = $true
            ShowGhostNext = $true
            ShowSyntaxLine = $true
            DebugLogging = $false
            NonInteractive = $false
            SafePathsStrict = $true
            WhatIf = $false
            GhostMinScore = 60
        }
        Shortcuts = @{
            't' = 'today'
            'tm' = 'tomorrow'
            'nd' = 'noduedate'
            'od' = 'overdue'
        }
        Paths = @{
            CsvLedgerPath = 'time_ledger.csv'
            AllowedWriteDirs = @()
        }
        Excel = @{
            SourceFolder = 'C:\\Path\\To\\T2020\\Input'
            DestinationPath = 'C:\\Path\\To\\T2020\\Destination\\Output.xlsm'
            SourceSheet = 'SVI-CAS'
            DestSheet = 'Output'
            ID2FieldName = 'CASNumber'
        }
    }
    
    static [void] Load() {
        if (Test-Path $global:ConfigFile) {
            try {
                # Load as hashtable to avoid PSCustomObject indexing issues
                $saved = Get-Content $global:ConfigFile -Raw | ConvertFrom-Json -AsHashtable
            } catch {
                # Fallback without -AsHashtable; convert PSCustomObject to hashtable
                $tmp = Get-Content $global:ConfigFile -Raw | ConvertFrom-Json
                $saved = Convert-PSObjectToHashtable $tmp
            }
            # Deep merge saved values into defaults, preserving new keys
            foreach ($k in $saved.Keys) {
                if ([ConfigManager]::Config.ContainsKey($k) -and ([ConfigManager]::Config[$k] -is [hashtable]) -and ($saved[$k] -is [hashtable])) {
                    foreach ($k2 in $saved[$k].Keys) { [ConfigManager]::Config[$k][$k2] = $saved[$k][$k2] }
                } else {
                    [ConfigManager]::Config[$k] = $saved[$k]
                }
            }
        }
    }
    
    static [void] Save() {
        [ConfigManager]::Config | ConvertTo-Json -Depth 10 | Set-Content $global:ConfigFile
    }
}

# Minimal VT100 helpers (inlined)
class VT {
    static [string] MoveTo([int]$x, [int]$y) { return "`e[$y;$($x)H" }
    static [string] SavePos() { return "`e[s" }
    static [string] RestorePos() { return "`e[u" }
    static [string] Hide() { return "`e[?25l" }
    static [string] Show() { return "`e[?25h" }
    static [string] ClearLine() { return "`e[2K" }
    static [void] BeginFrame([int]$row) {
        try { Write-DebugLog ("VT: BeginFrame row=" + $row) } catch {}
        Write-Host -NoNewline ([VT]::Hide())
        Write-Host -NoNewline ([VT]::MoveTo(1, $row))
        Write-Host -NoNewline ([VT]::ClearLine())
    }
    static [void] EndFrame([int]$cursorCol, [int]$cursorRow) {
        Write-Host -NoNewline ([VT]::MoveTo($cursorCol, $cursorRow))
        Write-Host -NoNewline ([VT]::Show())
        try { Write-DebugLog ("VT: EndFrame cursorCol=" + $cursorCol + " cursorRow=" + $cursorRow) } catch {}
    }
}

# === INITIALIZE DATA STORAGE ===
    if (-not (Test-Path $global:TaskFile)) {
        @{
            tasks = @()
            lastId = 0
            deleted = @()
            completed = @()
            schema_version = 1
            projects = @( 
            @{ 
                name = 'inbox'
                description = 'Default inbox for uncategorized tasks'
                color = 'Gray'
                icon = 'üì•'
                sortOrder = 0
                isArchived = $false
                settings = @{}
                # === NEW PMC FIELDS ===
                ID1 = 'N/A'
                ID2 = 'INBOX'
                ProjFolder = ''
                AssignedDate = ''
                DueDate = ''
                BFDate = ''
                CAAName = ''
                RequestName = ''
                T2020 = ''
            },
            @{
                name = 'personal'
                description = 'Personal tasks and reminders'
                color = 'Green'
                icon = 'üè†'
                sortOrder = 1
                isArchived = $false
                # === NEW PMC FIELDS ===
                ID1 = ''
                ID2 = 'PERSONAL'
                ProjFolder = ''
                AssignedDate = ''
                DueDate = ''
                BFDate = ''
                CAAName = ''
                RequestName = ''
                T2020 = ''
            },
            @{
                name = 'work'
                description = 'Work-related tasks'
                color = 'Blue'
                icon = 'üíº'
                sortOrder = 2
                isArchived = $false
                # === NEW PMC FIELDS ===
                ID1 = ''
                ID2 = 'WORK'
                ProjFolder = ''
                AssignedDate = ''
                DueDate = ''
                BFDate = ''
                CAAName = ''
                RequestName = ''
                T2020 = ''
            }
        )
        timelogs = @()
        currentContext = 'inbox'
        templates = @{}
        labels = @('urgent', 'waiting', 'someday', 'reference')
        customFields = @{}
        recurringTemplates = @()
        blockedTasks = @()
        dependencies = @()
        notes = @{}
        attachments = @{}
        activityLog = @()
    } | ConvertTo-Json -Depth 10 | Set-Content $global:TaskFile
}

# === ENHANCED DATA FUNCTIONS WITH CACHING, UNDO, AND RECOVERY ===

function Ensure-DataSchema {
    param($data)
    if (-not $data) { return $data }
    try {
        if (-not $data.PSObject.Properties['schema_version']) { $data | Add-Member -NotePropertyName schema_version -NotePropertyValue 1 -Force }
        foreach ($k in @('tasks','deleted','completed','projects','timelogs','activityLog')) {
            if (-not $data.PSObject.Properties[$k] -or -not $data.$k) { $data | Add-Member -NotePropertyName $k -NotePropertyValue @() -Force }
        }
        if (-not $data.PSObject.Properties['preferences'] -or -not $data.preferences) {
            $data | Add-Member -NotePropertyName preferences -NotePropertyValue @{ autoBackup = $true } -Force
        } elseif (-not $data.preferences.PSObject.Properties['autoBackup']) {
            $data.preferences | Add-Member -NotePropertyName autoBackup -NotePropertyValue $true -Force
        }
        if (-not $data.PSObject.Properties['currentContext'] -or -not $data.currentContext) { $data | Add-Member -NotePropertyName currentContext -NotePropertyValue 'inbox' -Force }
    } catch { Write-DebugLog ("Ensure-DataSchema error: " + $_) }
    return $data
}

# Global state for caching, undo, and context
$global:DataCache = $null
$global:CacheTimestamp = 0
$global:UndoStack = @()
$global:RedoStack = @()
$global:MaxUndoLevels = 10
$global:LastShownTaskMap = @{}
$global:CurrentContext = 'inbox'

function Get-TaskData { 
    param([switch]$ForceRefresh)
    
    if (-not (Test-Path $global:TaskFile)) {
        return $null
    }
    
    $currentTimestamp = (Get-Item $global:TaskFile).LastWriteTime.Ticks
    
    if ($ForceRefresh -or -not $global:DataCache -or $global:CacheTimestamp -ne $currentTimestamp) {
        try {
            $global:DataCache = Get-Content $global:TaskFile -Raw | ConvertFrom-Json
            $global:DataCache = Ensure-DataSchema $global:DataCache
            $global:CacheTimestamp = $currentTimestamp
            
            # Ensure all required properties exist
            $requiredProps = @{
                'activityLog' = @()
                'dependencies' = @()
                'projects' = @(@{
                    name = 'inbox'
                    description = 'Default project'
                    aliases = @('i', 'in')
                })
                'timelogs' = @()
                'currentContext' = 'inbox'
                'templates' = @{}
                'preferences' = @{
                    agendaShowOverdue = $true
                    agendaShowToday = $true  
                    agendaShowUpcoming = $true
                    agendaShowTimeToday = $true
                    agendaDaysAhead = 3
                    autoBackup = $true
                    defaultView = 'agenda'
                    generateRecurring = $true
                    maxSearchResults = 50
                }
                'deleted' = @()
                'completed' = @()
                'lastUsedProject' = $null
                'excelImports' = @()
            }
            
            foreach ($prop in $requiredProps.GetEnumerator()) {
                if (-not $global:DataCache.PSObject.Properties[$prop.Key]) {
                    $global:DataCache | Add-Member -MemberType NoteProperty -Name $prop.Key -Value $prop.Value
                }
            }
            # Schema version migration stub
            try {
                $ver = if ($global:DataCache.PSObject.Properties['schema_version']) { [int]$global:DataCache.schema_version } else { 0 }
                if ($ver -lt 1) {
                    $global:DataCache | Add-Member -Force -MemberType NoteProperty -Name schema_version -Value 1
                    Save-TaskData -data $global:DataCache -NoUndo
                }
            } catch { Write-Error "Schema migration error: $_"; throw }
            
            # Set global context from data
            if ($global:DataCache.currentContext) {
                $global:CurrentContext = $global:DataCache.currentContext
            }
            
        } catch {
            Write-Error "Failed to load data: $_"
            # Recovery: prefer .tmp if valid JSON, else backup
            $tmp = "$($global:TaskFile).tmp"
            $recovered = $false
            if (Test-Path $tmp) {
                try {
                    $d = Get-Content $tmp -Raw | ConvertFrom-Json
                    if ($d) {
                        Move-Item -Force $tmp $global:TaskFile
                        $global:DataCache = Ensure-DataSchema $d
                        $recovered = $true
                    }
                } catch {
                    Write-Error "Recovery from tmp file failed: $_"
                }
            }
            if (-not $recovered -and (Test-Path $global:BackupFile)) {
                try {
                    Copy-Item $global:BackupFile $global:TaskFile -Force
                    $global:DataCache = Ensure-DataSchema (Get-Content $global:TaskFile -Raw | ConvertFrom-Json)
                    $recovered = $true
                } catch {
                    Write-Error "Recovery from backup file failed: $_"
                }
            }
            if (-not $recovered) {
                Write-Error "Critical: Could not load task data and no valid recovery available. Aborting to prevent data loss."
                throw "Task data unavailable"
            }
        }
    }
    
    return $global:DataCache
}

function Save-TaskData($data, [switch]$NoUndo) {
    # Honor WhatIf: do not persist changes when enabled
    try { [ConfigManager]::Load() } catch {}
    $cfg = $null; try { $cfg = [ConfigManager]::Config } catch {}
    $whatIf = $false; try { if ($cfg -and $cfg.Behavior -and $cfg.Behavior.WhatIf -ne $null) { $whatIf = [bool]$cfg.Behavior.WhatIf } } catch {}
    if ($whatIf) {
        Write-Host "WhatIf: changes not saved (persistence disabled)" -ForegroundColor DarkYellow
        return
    }
    # Acquire simple file lock to prevent concurrent writers
    $lockPath = $global:TaskFile + '.lock'
    $lock = $null
    try {
        $maxRetries = 20; $delay = 100; $acquired = $false
        for ($i=0; $i -lt $maxRetries; $i++) {
            try {
                $lock = [System.IO.File]::Open($lockPath, [System.IO.FileMode]::OpenOrCreate, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None)
                $acquired = $true; break
            } catch {
                # Stale lock recovery: if lock file older than 2 minutes, remove
                try { $info = Get-Item $lockPath -ErrorAction SilentlyContinue; if ($info -and ((Get-Date) - $info.LastWriteTime).TotalMinutes -gt 2) { Remove-Item $lockPath -Force -ErrorAction SilentlyContinue } } catch { Write-Error "Failed to evaluate/remove stale lock: $_" }
                Start-Sleep -Milliseconds $delay
            }
        }
        if (-not $acquired) { throw "Could not acquire lock for task file" }
    } catch { Write-Error "Save-TaskData lock acquire failed: $_"; throw }

    # Save to undo stack unless explicitly told not to
    if (-not $NoUndo) {
        try {
            # Snapshot the on-disk state (pre-change) to ensure true undo
            if (Test-Path $global:TaskFile) {
                $prev = Get-Content $global:TaskFile -Raw
                if ($prev) { $global:UndoStack += $prev }
            } elseif ($global:DataCache) {
                $global:UndoStack += ($global:DataCache | ConvertTo-Json -Depth 10)
            }
        } catch { Write-DebugLog ("Undo snapshot failed: " + $_) }
        if ($global:UndoStack.Count -gt $global:MaxUndoLevels) {
            $global:UndoStack = $global:UndoStack[-$global:MaxUndoLevels..-1]
        }
        
        # Persist undo stack
        if ($global:UndoStack.Count -gt 0) {
            $global:UndoStack | ConvertTo-Json -Depth 10 | Set-Content $global:UndoFile -Encoding UTF8
        }
    }
    
    # Add activity log entry
    if (-not $data.activityLog) {
        $data | Add-Member -Force -MemberType NoteProperty -Name activityLog -Value @()
    }
    
    $data.activityLog += @{
        timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        action = $global:LastAction
        user = $env:USERNAME
    }
    
    # Keep only last 1000 activity entries
    if ($data.activityLog.Count -gt 1000) {
        $data.activityLog = $data.activityLog[-1000..-1]
    }
    
    $tempFile = "$($global:TaskFile).tmp"
    
    try {
        # Create backup before saving (tolerant of missing preferences)
        $autoBackup = $false
        try {
            if ($data -and $data.PSObject.Properties['preferences'] -and $data.preferences -and $data.preferences.PSObject.Properties['autoBackup']) {
                $autoBackup = [bool]$data.preferences.autoBackup
            }
        } catch {}
        if ($autoBackup -and (Test-Path $global:TaskFile)) {
            Copy-Item $global:TaskFile $global:BackupFile -Force
        }
        
        $data | ConvertTo-Json -Depth 10 | Set-Content -Path $tempFile -Encoding UTF8
        Move-Item -Path $tempFile -Destination $global:TaskFile -Force
        # Remove temp file explicitly here (data loss bug fix)
        if (Test-Path $tempFile) { Remove-Item $tempFile -ErrorAction Stop }
        
        # Update cache
        $global:DataCache = $data
        $global:CacheTimestamp = (Get-Item $global:TaskFile).LastWriteTime.Ticks
    }
    catch {
        Write-Error "Failed to save: $_"
    }
    finally {
        try { if ($lock) { $lock.Close() } } catch {}
        try { if (Test-Path $lockPath) { Remove-Item $lockPath -Force -ErrorAction SilentlyContinue } } catch {}
    }
}

# === CORE UTILITY FUNCTIONS ===

function Get-SafePath {
    param(
        [string]$Path,
        [string]$Base = $PSScriptRoot
    )
    # Returns a path that is safe to write.
    # - Relative paths: anchored under $Base and normalized.
    # - Absolute paths: allowed only if SafePathsStrict=false or under AllowedWriteDirs (or under $Base).
    if ([string]::IsNullOrWhiteSpace($Path)) {
        return (Join-Path $Base 'output.txt')
    }
    try {
        # Load safety config
        $cfg = $null; try { [ConfigManager]::Load(); $cfg = [ConfigManager]::Config } catch {}
        $strict = $true; $allowed = @()
        try {
            if ($cfg -and $cfg.Behavior -and $cfg.Behavior.SafePathsStrict -ne $null) { $strict = [bool]$cfg.Behavior.SafePathsStrict }
            if ($cfg -and $cfg.Paths -and $cfg.Paths.AllowedWriteDirs) { $allowed = @($cfg.Paths.AllowedWriteDirs) }
        } catch {}
        $isAbsolute = [System.IO.Path]::IsPathRooted($Path)
        if (-not $isAbsolute) {
            # Anchor under Base
            $combined = Join-Path $Base $Path
            $full = [System.IO.Path]::GetFullPath($combined)
            $baseFull = [System.IO.Path]::GetFullPath($Base)
            if (-not $full.StartsWith($baseFull, [System.StringComparison]::OrdinalIgnoreCase)) {
                # Prevent traversal outside base
                $full = Join-Path $baseFull ([System.IO.Path]::GetFileName($Path))
            }
            return $full
        }
        else {
            $fullAbs = ([System.IO.Path]::GetFullPath($Path))
            $baseFull = [System.IO.Path]::GetFullPath($Base)
            if ($fullAbs.StartsWith($baseFull, [System.StringComparison]::OrdinalIgnoreCase)) { return $fullAbs }
            if (-not $strict) { return $fullAbs }
            # Check allowlist
            foreach ($dir in $allowed) {
                if (-not [string]::IsNullOrWhiteSpace($dir)) {
                    $dirFull = [System.IO.Path]::GetFullPath((Join-Path $Base $dir))
                    if ($fullAbs.StartsWith($dirFull, [System.StringComparison]::OrdinalIgnoreCase)) { return $fullAbs }
                }
            }
            # Fallback: constrain to Base
            return (Join-Path $baseFull ([System.IO.Path]::GetFileName($Path)))
        }
    } catch {
        # Fallback to base
        return (Join-Path $Base ([System.IO.Path]::GetFileName($Path)))
    }
}

# Unified confirmation helper honoring NonInteractive and WarnBeforeDelete
function Get-UserConfirmation {
    param(
        [Parameter(Mandatory=$true)][string]$Prompt,
        [bool]$DefaultYes = $false
    )
    try { [ConfigManager]::Load() } catch {}
    $cfg = $null; try { $cfg = [ConfigManager]::Config } catch {}
    $nonInteractive = $false; $warn = $true; $whatIf = $false
    try { if ($cfg -and $cfg.Behavior) { $nonInteractive = [bool]$cfg.Behavior.NonInteractive; $warn = [bool]$cfg.Behavior.WarnBeforeDelete; $whatIf = [bool]$cfg.Behavior.WhatIf } } catch {}
    if ($whatIf) { return $false }
    if ($nonInteractive) { return ($DefaultYes -and -not $warn) }
    if (-not $warn) { return $DefaultYes }
    $resp = Read-Host ("$Prompt (y/N)")
    return ($resp -match '^(?i)y(es)?$')
}

# Generate next task id and update data.lastId atomically
function Get-NextTaskId {
    param($data)
    if (-not $data) { $data = Get-TaskData }
    try {
        if ($data.PSObject.Properties['lastId']) {
            $data.lastId = [int]$data.lastId + 1
        } else {
            # Initialize if missing
            $data | Add-Member -MemberType NoteProperty -Name lastId -Value 1 -Force
        }
    } catch {
        # Fallback
        $data.lastId = 1
    }
    return [int]$data.lastId
}

# Generate next time log id
function Get-NextTimeLogId {
    param($data)
    if (-not $data) { $data = Get-TaskData }
    try {
        if (-not $data.timelogs) { return 1 }
        $maxId = ($data.timelogs | ForEach-Object { [int]$_.id } | Measure-Object -Maximum).Maximum
        return $maxId + 1
    } catch {
        return 1
    }
}

function Get-Tasks {
    param(
        [string]$Filter = '',
        [int]$Priority = -1,
        [string]$Project = '',
        [string]$Search = '',
        [string]$Tag = '',
        [string]$ByID2 = '',
        [switch]$Sort
    )
    $data = Get-TaskData
    $tasks = @($data.tasks | Where-Object { $_.status -eq 'pending' })
    $today = (Get-Date).Date
    if ($Project) { $tasks = $tasks | Where-Object { $_.project -eq $Project } }
    if ($Priority -ge 0) { $tasks = $tasks | Where-Object { $_.priority -eq $Priority } }
    if ($Search) { $s = $Search.ToLower(); $tasks = $tasks | Where-Object { $_.text.ToLower().Contains($s) } }
    if ($Tag) { $tasks = $tasks | Where-Object { $_.tags -and ($_.tags -contains $Tag) } }
    if ($ByID2) { $tasks = $tasks | Where-Object { $_.project -and ($data.projects | Where-Object { $_.name -eq $_.project -and $_.ID2 -eq $ByID2 }) }
    }
    switch ($Filter) {
        'today'     { $tasks = $tasks | Where-Object { $_.due -eq $today.ToString('yyyy-MM-dd') } }
        'tomorrow'  { $tasks = $tasks | Where-Object { $_.due -eq $today.AddDays(1).ToString('yyyy-MM-dd') } }
        'overdue'   { $tasks = $tasks | Where-Object { $_.due -and [datetime]$_.due -lt $today } }
        'upcoming'  { $tasks = $tasks | Where-Object { $_.due -and [datetime]$_.due -gt $today -and [datetime]$_.due -le $today.AddDays(7) } }
        'noduedate' { $tasks = $tasks | Where-Object { -not $_.due } }
        'blocked'   { $tasks = $tasks | Where-Object { $_.depends -and $_.depends.Count -gt 0 } }
        default {} 
    }
    if ($Sort) {
        $tasks = $tasks | Sort-Object @(
            @{Expression = { if ($_.priority) { 4 - $_.priority } else { 0 } }; Descending = $false },
            @{Expression = { if ($_.due) { [datetime]$_.due } else { [datetime]::MaxValue } }; Descending = $false }
        )
    }
    return ,$tasks
}

function Undo-LastAction {
    # Initialize in-memory stack once if not already loaded
    if (-not $global:UndoStack -or $global:UndoStack.Count -eq 0) {
        if (Test-Path $global:UndoFile) {
            $global:UndoStack = Get-Content $global:UndoFile -Raw | ConvertFrom-Json
        } else {
            $global:UndoStack = @()
        }
    }
    
    if ($global:UndoStack.Count -eq 0) {
        Write-Host "Nothing to undo" -ForegroundColor Gray
        return
    }
    
    # Push current state to redo stack for Redo-Action support
    if ($global:DataCache) {
        $global:RedoStack += ($global:DataCache | ConvertTo-Json -Depth 10)
    }
    $previousState = $global:UndoStack[-1] | ConvertFrom-Json
    if ($global:UndoStack.Count -gt 1) {
        $global:UndoStack = $global:UndoStack[0..($global:UndoStack.Count - 2)]
    } else {
        $global:UndoStack = @()
    }
    
    # Save without adding to undo stack
    Save-TaskData -data $previousState -NoUndo
    
    # Persist updated stack
    if ($global:UndoStack.Count -gt 0) {
        $global:UndoStack | ConvertTo-Json -Depth 10 | Set-Content $global:UndoFile -Encoding UTF8
    } else {
        Remove-Item $global:UndoFile -ErrorAction SilentlyContinue
    }
    
    Write-Host "Undid last action" -ForegroundColor Green
}

function Set-CurrentContext {
    param([string]$projectName)
    
    $global:CurrentContext = $projectName
    $data = Get-TaskData  # use cached data
    if ($data) {
        $data.currentContext = $projectName
        Save-TaskData $data -NoUndo
    }
}

function Get-ContextPrompt {
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        return "Suite ($global:CurrentContext)> "
    }
    return "Suite> "
}

function Resolve-TaskIds {
    param([string]$inputString)
    
    $globalIds = @()
    $parts = $inputString -split '[,\s]+' | Where-Object { $_ }
    
    foreach ($part in $parts) {
        if ($part -match '^(\d+)-(\d+)$') {
            # Range support
            $start = [int]$matches[1]
            $end = [int]$matches[2]
            
            for ($i = $start; $i -le $end; $i++) {
                if ($global:LastShownTaskMap.ContainsKey($i)) {
                    $globalIds += $global:LastShownTaskMap[$i]
                } else {
                    $globalIds += $i  # Assume global ID
                }
            }
        }
        elseif ($part -match '^\d+$') {
            $localId = [int]$part
            
            # Check if it's a local ID from the last display
            if ($global:LastShownTaskMap.ContainsKey($localId)) {
                $globalIds += $global:LastShownTaskMap[$localId]
            } else {
                $globalIds += $localId  # Treat as global ID
            }
        }
    }
    
    return $globalIds | Select-Object -Unique
}

function Parse-DurationToMinutes {
    param([string]$duration)
    
    if ($duration -match '^(\d+(?:\.\d+)?)([mh])$') {
        $value = [double]$matches[1]
        if ($matches[2] -eq 'h') { 
            return [int]($value * 60) 
        } else { 
            return [int]$value 
        }
    }
    
    return 0
}

function Format-Duration {
    param([int]$minutes)
    
    if ($minutes -le 0) { return "" }
    
    $hours = [Math]::Floor($minutes / 60)
    $mins = $minutes % 60
    
    if ($hours -gt 0 -and $mins -gt 0) {
        return "${hours}h ${mins}m"
    } elseif ($hours -gt 0) {
        return "${hours}h"
    } else {
        return "${mins}m"
    }
}

function Parse-DateRange {
    param([string]$range)
    
    $today = (Get-Date).Date
    $result = @{ Start = $null; End = $null; Display = "" }
    
    switch -Regex ($range.ToLower()) {
        '^today$' {
            $result.Start = $today
            $result.End = $today.AddDays(1)
            $result.Display = "today"
        }
        '^yesterday$' {
            $result.Start = $today.AddDays(-1)
            $result.End = $today
            $result.Display = "yesterday"
        }
        '^this week$|^week$' {
            $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
            $result.Start = $weekStart
            $result.End = $weekStart.AddDays(7)
            $result.Display = "this week"
        }
        '^next week$|^nextweek$' {
            $thisWeekStart = $today.AddDays(-[int]$today.DayOfWeek)
            $nextWeekStart = $thisWeekStart.AddDays(7)
            $result.Start = $nextWeekStart
            $result.End = $nextWeekStart.AddDays(7)
            $result.Display = "next week"
        }
        '^last week$' {
            $lastWeekStart = $today.AddDays(-[int]$today.DayOfWeek - 7)
            $result.Start = $lastWeekStart
            $result.End = $lastWeekStart.AddDays(7)
            $result.Display = "last week"
        }
        '^this month$|^month$' {
            $result.Start = Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0
            $result.End = $result.Start.AddMonths(1)
            $result.Display = "this month"
        }
        '^last month$' {
            $firstOfMonth = Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0
            $result.Start = $firstOfMonth.AddMonths(-1)
            $result.End = $firstOfMonth
            $result.Display = "last month"
        }
        '(\d{4}-\d{2}-\d{2})\s+to\s+(\d{4}-\d{2}-\d{2})' {
            $result.Start = [datetime]$matches[1]
            $result.End = ([datetime]$matches[2]).AddDays(1)
            $result.Display = "$($matches[1]) to $($matches[2])"
        }
        '^\d{4}-\d{2}-\d{2}$' {
            $result.Start = [datetime]$range
            $result.End = $result.Start.AddDays(1)
            $result.Display = $range
        }
        default {
            $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
            $result.Start = $weekStart
            $result.End = $weekStart.AddDays(7)
            $result.Display = "this week (default)"
        }
    }
    
    return $result
}

function Extract-Metadata {
    param([string]$text)
    
    $result = @{
        CleanText = $text
        Project = $null
        Priority = 0
        Due = $null
        Duration = $null
        EstimatedTime = $null
        Tags = @()
        CustomFields = @{}
        Recur = $null
        RecurUntil = $null
        DependsOn = @()
    }
    
    $cleanText = $text
    
    # Extract @project (anywhere in string)
    if ($cleanText -match '@(\S+)') {
        $result.Project = $matches[1]
        $cleanText = $cleanText -replace '@\S+', ''
    }
    
    # Extract priority markers - Fixed for end-of-string matching
    if ($cleanText -match '\s*(p1|!!!)(?=\s|$)') { 
        $result.Priority = 1
        $cleanText = $cleanText -replace '\s*(p1|!!!)(?=\s|$)', ' '
    }
    elseif ($cleanText -match '\s*(p2|!!)(?=\s|$)') { 
        $result.Priority = 2
        $cleanText = $cleanText -replace '\s*(p2|!!)(?=\s|$)', ' '
    }
    elseif ($cleanText -match '\s*(p3|!)(?=\s|$)') { 
        $result.Priority = 3
        $cleanText = $cleanText -replace '\s*(p3|!)(?=\s|$)', ' '
    }
    
    # Extract time duration (for logging) - Fixed for end-of-string matching
    if ($cleanText -match '\s+(for|took):(\d+(?:\.\d+)?[hm])(?=\s|$)') {
        $result.Duration = $matches[2]
        $cleanText = $cleanText -replace '\s+(for|took):\d+(?:\.\d+)?[hm](?=\s|$)', ' '
    }
    
    # est: removed ‚Äî no estimate parsing
    
    # Extract due date - Fixed for end-of-string matching
    if ($cleanText -match '\s+due:(\S+)(?=\s|$)') {
        $result.Due = $matches[1]
        $cleanText = $cleanText -replace '\s+due:\S+(?=\s|$)', ' '
    }
    
    # Extract recurrence - Fixed for end-of-string matching
    if ($cleanText -match '\s+recur:(\S+)(?=\s|$)') {
        $result.Recur = $matches[1]
        $cleanText = $cleanText -replace '\s+recur:\S+(?=\s|$)', ' '
    }
    
    # Extract recurrence end - Fixed for end-of-string matching
    if ($cleanText -match '\s+until:(\S+)(?=\s|$)') {
        $result.RecurUntil = $matches[1]
        $cleanText = $cleanText -replace '\s+until:\S+(?=\s|$)', ' '
    }
    
    # Extract dependencies - Fixed for end-of-string matching
    while ($cleanText -match '\s+depends:(\d+)(?=\s|$)') {
        $result.DependsOn += [int]$matches[1]
        $cleanText = $cleanText -replace '\s+depends:\d+(?=\s|$)', ' '
    }
    
    # Extract custom fields (key:value) - Fixed for end-of-string matching
    while ($cleanText -match '\s+(\w+):([^\s:]+)(?=\s|$)') {
        $key = $matches[1]
        if ($key -notin @('for', 'took', 'est', 'due', 'recur', 'until', 'depends')) {
            $result.CustomFields[$key] = $matches[2]
            $cleanText = $cleanText -replace ("\s+$([regex]::Escape($key)):[^\s:]+(?=\s|$)"), ' '
        }
    }
    
    # Extract hashtags (#tag) and plus-tags (+tag) - Fixed to match at end of string
    while ($cleanText -match '(?:^|\s)([#\+]\w+)(?=\s|$)') {
        $tagWithPrefix = $matches[1]
        $result.Tags += $tagWithPrefix.Substring(1)  # Remove # or + prefix
        $cleanText = $cleanText -replace [regex]::Escape($tagWithPrefix) + '(?=\s|$)', ' '
    }
    # Remove minus-tags from text (they are handled separately for updates)
    while ($cleanText -match '(?:^|\s)(-#?\w+)(?=\s|$)') {
        $minusTag = $matches[1]
        $cleanText = $cleanText -replace [regex]::Escape($minusTag) + '(?=\s|$)', ' '
    }
    
    # Clean up whitespace
    $result.CleanText = $cleanText.Trim() -replace '\s+', ' '
    
    return $result
}

function Format-StyledTable {
    param(
        [string[]]$Headers,
        [object[]]$DataRows,
        [string]$Title = "",
        [string]$BorderColor = "DarkGray",
        [string]$HeaderColor = "Yellow", 
        [string]$TitleColor = "Cyan",
        [string]$DataColor = "White",
        [int]$MaxTextWidth = 50  # Max width for text columns (usually task descriptions)
    )
    
    if ($Title) {
        Write-Host "`n  $Title" -ForegroundColor $TitleColor
        Write-Host "  $('‚îÄ' * $Title.Length)" -ForegroundColor $BorderColor
    }

    if (-not $DataRows -or $DataRows.Count -eq 0) {
        # Contextual empty state based on title or headers
        $emptyMessage = "  üì≠ No data to display"
        if ($Title -match "(?i)(task|todo)") {
            $emptyMessage = "  üìã No tasks found`n  üí° Use 'add <description>' to create your first task"
        } elseif ($Title -match "(?i)project") {
    $emptyMessage = "  üìÅ No projects found`n  üí° Use 'add project <name>' to create your first project"
        } elseif ($Title -match "(?i)(time|report|log)") {
            $emptyMessage = "  ‚è±Ô∏è  No time entries found`n  üí° Use 'log @project date hours [desc]' to log time"
        }
        
        Write-Host $emptyMessage -ForegroundColor Yellow
        Write-Host ""
        return
    }

    # Apply text truncation to data rows for better layout
    $processedRows = @()
    foreach ($row in $DataRows) {
        $processedRow = @()
        for ($i = 0; $i -lt $row.Count; $i++) {
            $cell = if ($row[$i] -ne $null) { $row[$i].ToString() } else { "" }
            
            # Apply truncation to text columns (typically task descriptions in column 2 or 3)
            if ($i -eq 2 -or ($Headers[$i] -match "(?i)(task|text|description|content|note)")) {
                if ($cell.Length -gt $MaxTextWidth) {
                    $cell = $cell.Substring(0, $MaxTextWidth - 3) + "..."
                }
            }
            
            $processedRow += $cell
        }
        $processedRows += ,$processedRow
    }

    # Calculate column widths dynamically using processed data
    $colWidths = for ($i = 0; $i -lt $Headers.Length; $i++) {
        $headerLength = $Headers[$i].Length
        $dataLengths = $processedRows | ForEach-Object { 
            if ($_ -and $_.Count -gt $i -and $_[$i] -ne $null) { 
                $_[$i].ToString().Length 
            } else { 
                0 
            }
        }
        # Add a minimum width to prevent tiny columns and ensure padding
        [Math]::Max(8, [Math]::Max($headerLength, ($dataLengths | Measure-Object -Maximum).Maximum))
    }

    # Reusable scriptblock to build and write a line
    $builder = {
        param($items, $color)
        $line = "  "
        for ($i = 0; $i -lt $Headers.Length; $i++) {
            $value = if ($items -and $items.Count -gt $i -and $items[$i] -ne $null) { 
                $items[$i].ToString() 
            } else { 
                "" 
            }
            $line += $value.PadRight($colWidths[$i]) + "  " # 2 spaces for separation
        }
        Write-Host $line.TrimEnd() -ForegroundColor $color
    }

    # Draw Header
    & $builder $Headers $HeaderColor

    # Draw Separator
    $separatorItems = $colWidths | ForEach-Object { '‚îÄ' * $_ }
    & $builder $separatorItems $BorderColor

    # Draw Data Rows (using processed rows with truncation)
    foreach ($row in $processedRows) {
        & $builder $row $DataColor
    }
    Write-Host ""
}

function Format-ProjectID2Csv {
    param([string]$id2)
    if ([string]::IsNullOrWhiteSpace($id2)) { return "" }
    $core = $id2.Trim()
    $padLen = 12 - (1 + $core.Length + 1)
    if ($padLen -lt 0) { $padLen = 0 }
    return "V" + ("0" * $padLen) + $core + "S"
}

function Get-PriorityIcon {
    param([int]$Priority)
    $useAscii = $false
    try { $useAscii = [ConfigManager]::Config.Display.UseAsciiIcons } catch {}
    if ($useAscii) {
        switch ($Priority) {
            3 { return '^' }
            2 { return '+' }
            1 { return '-' }
            default { return '' }
        }
    } else {
        switch ($Priority) {
            3 { return 'üî∫' }
            2 { return 'üî∏' }
            1 { return 'üîπ' }
            default { return ' ' }
        }
    }
}

function Pause-Screen {
    Write-Host "`nPress any key to continue..." -ForegroundColor DarkGray
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

# Helpers: convert PSCustomObject trees to hashtables for safe indexing/merging
function Convert-PSObjectToHashtable {
    param($Object)
    if ($null -eq $Object) { return $null }
    if ($Object -is [hashtable]) { return $Object }
    if ($Object -is [pscustomobject]) {
        $ht = @{}
        foreach ($p in $Object.PSObject.Properties) { $ht[$p.Name] = Convert-PSObjectToHashtable $p.Value }
        return $ht
    }
    if ($Object -is [System.Collections.IEnumerable] -and -not ($Object -is [string])) {
        return @($Object | ForEach-Object { Convert-PSObjectToHashtable $_ })
    }
    return $Object
}

# === NUMBERED QUICK ACTIONS ===
function Invoke-NumberedAction {
    param([CommandContext]$context)
    
    $input = $context.GetText().Trim()
    Write-DebugLog "Numbered action input: '$input'"
    
    # Parse input like "3", "3 view", "3 tasks"
    if ($input -match '^(\d+)(?:\s+(.+))?$') {
        $number = [int]$matches[1]
        $action = if ($matches[2]) { $matches[2].Trim().ToLower() } else { '' }
        
        Write-DebugLog "Parsed number: $number, action: '$action'"
        
        # Check if we have project context from recent dashboard
        if ($global:LastShownProjectMap -and $global:LastShownProjectMap.ContainsKey($number)) {
            $projectName = $global:LastShownProjectMap[$number]
            Write-DebugLog "Found project: $projectName"
            
            switch ($action) {
                'view' {
                    $ctx = [CommandContext]::new([CompletionState]::new())
                    $ctx.Args = @{ project = $projectName }
                    $ctx.RawText = $projectName
                    Show-ProjectDetails $ctx
                }
                'tasks' {
                    $ctx = [CommandContext]::new([CompletionState]::new())
                    $ctx.Args = @{ project = $projectName }
                    Show-FilteredTasks @{Project=$projectName}
                }
                default {
                    # Default action is to focus on the project
                    Set-CurrentContext $projectName
                    Write-Host "  ‚úÖ Focused on project: $projectName" -ForegroundColor Green
                    Write-Host "  üí° Use 'add <task>' to add tasks to this project" -ForegroundColor DarkCyan
                }
            }
            return
        }
        
        # Check if we have task context from recent task list
        if ($global:LastShownTaskMap -and $global:LastShownTaskMap.ContainsKey($number)) {
            $taskId = $global:LastShownTaskMap[$number]
            Write-DebugLog "Found task ID: $taskId"
            
            switch ($action) {
                'done' {
                    $ctx = [CommandContext]::new([CompletionState]::new())
                    $ctx.RawText = $taskId.ToString()
                    Complete-SmartTasks $ctx
                }
                'view' {
                    $ctx = [CommandContext]::new([CompletionState]::new())
                    $ctx.RawText = $taskId.ToString()
                    Show-TaskDetails $ctx
                }
                'edit' {
                    Edit-TaskInteractive -IdText $taskId.ToString()
                }
                'delete' {
                    $ctx = [CommandContext]::new([CompletionState]::new())
                    $ctx.RawText = $taskId.ToString()
                    Delete-SmartTasks $ctx
                }
                default {
                    # Default action for tasks is to mark done
                    $ctx = [CommandContext]::new([CompletionState]::new())
                    $ctx.RawText = $taskId.ToString()
                    Complete-SmartTasks $ctx
                }
            }
            return
        }
        
        # Check if we have time log context from recent time log list
        if ($global:LastShownTimeLogMap -and $global:LastShownTimeLogMap.ContainsKey($number)) {
            $timeLogId = $global:LastShownTimeLogMap[$number]
            Write-DebugLog "Found time log ID: $timeLogId"
            
            switch ($action) {
                'delete' {
                    $ctx = [CommandContext]::new([CompletionState]::new())
                    $ctx.RawText = $timeLogId.ToString()
                    Delete-TimeLog $ctx
                }
                'copy' {
                    # Get the original time log and create a duplicate
                    $data = Get-TaskData
                    $originalLog = $data.timelogs | Where-Object { $_.id -eq $timeLogId } | Select-Object -First 1
                    if ($originalLog) {
                        $newLog = $originalLog.PSObject.Copy()
                        $newLog.id = Get-NextTimeLogId $data
                        $newLog.date = (Get-Date).ToString("yyyy-MM-dd")
                        $newLog.time = (Get-Date).ToString("HH:mm")
                        $data.timelogs += $newLog
                        Save-TaskData $data
                        Write-Host "  ‚úÖ Copied time entry: $($originalLog.project) ($($originalLog.minutes) min)" -ForegroundColor Green
                        Write-Host "  üí° New entry ID: $($newLog.id)" -ForegroundColor DarkCyan
                    }
                }
                default {
                    # Default action for time logs is to edit
                    $ctx = [CommandContext]::new([CompletionState]::new())
                    $ctx.RawText = $timeLogId.ToString()
                    Edit-TimeLog $ctx
                }
            }
            return
        }
        
        Write-Host "  ‚ùå No numbered items available. Run a list command first." -ForegroundColor Red
        Write-Host "  üí° Available contexts:" -ForegroundColor Gray
        if ($global:LastShownProjectMap -and $global:LastShownProjectMap.Count -gt 0) {
            Write-Host "     Projects: 1-$($global:LastShownProjectMap.Count) (from recent 'projects' command)" -ForegroundColor Gray
        }
        if ($global:LastShownTaskMap -and $global:LastShownTaskMap.Count -gt 0) {
            Write-Host "     Tasks: 1-$($global:LastShownTaskMap.Count) (from recent 'list' command)" -ForegroundColor Gray
        }
        if ($global:LastShownTimeLogMap -and $global:LastShownTimeLogMap.Count -gt 0) {
            Write-Host "     Time Logs: 1-$($global:LastShownTimeLogMap.Count) (from recent 'timelog' command)" -ForegroundColor Gray
        }
    Write-Host "  üí° For config: Use 'edit config' then type numbers inside the editor" -ForegroundColor DarkCyan
    } else {
        Write-Host "  ‚ùå Invalid format. Use: # <number> [action]" -ForegroundColor Red
        Write-Host "  Examples: # 3, # 3 view, # 3 tasks" -ForegroundColor Gray
    }
}

# === CONFIGURATION UI ===
function Show-Config {
    try { [ConfigManager]::Load() } catch {}
    $cfg = [ConfigManager]::Config
    
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor DarkGray
    Write-Host "  ‚ïë                    CONFIGURATION SETTINGS                  ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor DarkGray
    Write-Host ""
    
    $options = Get-ConfigOptions
    $num = 1
    foreach ($option in $options) {
        $value = Get-ConfigOptionValue -option $option -cfg $cfg
        $color = if ($option.Type -eq 'boolean' -and $value -eq $true) { "Green" } 
                elseif ($option.Type -eq 'boolean' -and $value -eq $false) { "Red" } 
                else { "White" }
        
        Write-Host ("  [{0,2}] " -f $num) -NoNewline -ForegroundColor Gray
        Write-Host ("{0,-35}" -f $option.Name) -NoNewline -ForegroundColor Cyan
        Write-Host " $value" -ForegroundColor $color
        $num++
    }
    
    Write-Host "`n  üí° Usage:" -ForegroundColor Yellow
    Write-Host "     edit config          - Interactive config editor" -ForegroundColor Gray
    Write-Host "     # <number>           - Toggle boolean or change value" -ForegroundColor Gray  
    Write-Host "     # <number> <value>   - Set specific value" -ForegroundColor Gray
    Write-Host ""
}

function Convert-ToTypedValue {
    param([string]$Text)
    if ($null -eq $Text) { return $null }
    $t = $Text.Trim()
    if ($t -match '^(?i:true|false)$') { return [bool]::Parse($t) }
    if ($t -match '^-?\d+$') { return [int]$t }
    if ($t -match '^-?\d+\.\d+$') { return [double]$t }
    return $t
}

function Get-ConfigValue {
    param([string] $Path)
    try {
        if (-not $global:Config) { return $null }
        $parts = $Path -split '\.'
        $current = $global:Config
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $null
            }
        }
        return $current
    } catch {
        return $null
    }
}

function Set-ConfigValue {
    param(
        [Parameter(Mandatory=$true)][string]$Path,
        [Parameter(Mandatory=$true)]$Value
    )
    $cfg = [ConfigManager]::Config
    if ($Path -match '^(?<section>\w+)\.(?<key>\w+)$') {
        $section = $matches.section
        $key = $matches.key
        if (-not $cfg.ContainsKey($section)) { Write-Host "Unknown section: $section" -ForegroundColor Yellow; return }
        $typed = if ($Value -is [string]) { Convert-ToTypedValue $Value } else { $Value }
        $cfg.$section[$key] = $typed
        [ConfigManager]::Config = $cfg
    } else {
        Write-Host "Use Section.Key format, e.g., Display.UseAsciiIcons" -ForegroundColor Yellow
    }
}

function Toggle-ConfigValue {
    param([string]$Path)
    if ($Path -match '^(?<section>\w+)\.(?<key>\w+)$') {
        $cfg = [ConfigManager]::Config
        $section = $matches.section; $key = $matches.key
        if ($cfg.$section.ContainsKey($key)) {
            $current = $cfg.$section[$key]
            if ($current -is [bool]) { $cfg.$section[$key] = -not $current } else { Write-Host "Not a boolean: $Path" -ForegroundColor Yellow }
            [ConfigManager]::Config = $cfg
        }
    }
}

function Set-ConfigFromCommand {
    param([CommandContext]$context)
    $text = $context.GetText()
    if ($text -match '^(?<path>\S+)\s+(?<val>.+)$') {
        Set-ConfigValue -Path $matches.path -Value $matches.val
        [ConfigManager]::Save()
        Show-Config
    } else {
    Write-Host "Usage: set config <Section.Key> <value>" -ForegroundColor Yellow
    Write-Host "Example: set config Display.UseAsciiIcons true" -ForegroundColor Gray
    }
}

# Define all config options in a structured way
function Get-ConfigOptions {
    return @(
        @{ Name="Use ASCII Icons (not emoji)"; Path="Display.UseAsciiIcons"; Type="boolean"; Description="Use ASCII characters instead of emoji icons" }
        @{ Name="Compact Display Mode"; Path="Display.CompactMode"; Type="boolean"; Description="Show condensed task lists" }
        @{ Name="Show Empty Projects"; Path="Display.ShowEmptyProjects"; Type="boolean"; Description="Display projects with no tasks" }
        @{ Name="Show Completed in Reports"; Path="Display.ShowCompletedInReports"; Type="boolean"; Description="Include completed tasks in reports" }
        @{ Name="Use 24-Hour Time Format"; Path="Display.Use24Hour"; Type="boolean"; Description="Display time in 24-hour format" }
        @{ Name="Max Tasks Per Section"; Path="Display.MaxTasksPerSection"; Type="number"; Description="Maximum tasks to show in each section" }
        @{ Name="Date Format"; Path="Display.DateFormat"; Type="string"; Description="Date display format (e.g., 'ddd MM/dd')" }
        
        @{ Name="Auto-Archive After Days"; Path="Behavior.AutoArchiveAfterDays"; Type="number"; Description="Days before auto-archiving completed tasks" }
        @{ Name="Default Due Date Days"; Path="Behavior.DefaultDueDateDays"; Type="number"; Description="Default days ahead for new task due dates" }
        @{ Name="Warn Before Delete"; Path="Behavior.WarnBeforeDelete"; Type="boolean"; Description="Show confirmation before deleting tasks" }
        @{ Name="Show Welcome Message"; Path="Behavior.ShowWelcome"; Type="boolean"; Description="Display welcome screen on startup" }
        @{ Name="Enable Notifications"; Path="Behavior.EnableNotifications"; Type="boolean"; Description="Show system notifications" }
        @{ Name="Enable CSV Time Ledger"; Path="Behavior.EnableCsvLedger"; Type="boolean"; Description="Auto-export time logs to CSV" }
        @{ Name="Accept Commands on Type"; Path="Behavior.AcceptOnType"; Type="boolean"; Description="Execute commands without pressing Enter" }
        @{ Name="Show Ghost Next Tasks"; Path="Behavior.ShowGhostNext"; Type="boolean"; Description="Preview next available tasks" }
        @{ Name="Show Syntax Help Line"; Path="Behavior.ShowSyntaxLine"; Type="boolean"; Description="Display syntax hints" }
        @{ Name="User Aliases"; Path="aliases"; Type="object"; Description="Custom command shortcuts" }
        @{ Name="Debug Logging"; Path="Behavior.DebugLogging"; Type="boolean"; Description="Enable debug logging to file" }
        @{ Name="Non-Interactive Mode"; Path="Behavior.NonInteractive"; Type="boolean"; Description="Disable interactive prompts" }
    )
}

function Get-ConfigOptionValue {
    param($option, $cfg)
    $parts = $option.Path -split '\.'
    $section = $cfg.($parts[0])
    return $section.($parts[1])
}

function Set-ConfigOptionValue {
    param($option, $cfg, $value)
    $parts = $option.Path -split '\.'
    $section = $cfg.($parts[0])
    if ($option.Type -eq 'boolean') {
        $section.($parts[1]) = [bool]$value
    } elseif ($option.Type -eq 'number') {
        $section.($parts[1]) = [int]$value
    } else {
        $section.($parts[1]) = [string]$value
    }
}

function Show-ConfigEditor {
    param([CommandContext]$context)
    try { [ConfigManager]::Load() } catch {}
    
    while ($true) {
        Clear-Host
        Show-Config
        
        Write-Host "  Commands:" -ForegroundColor Yellow
        Write-Host "    # <number>          - Toggle boolean or prompt for new value" -ForegroundColor Gray
        Write-Host "    # <number> <value>  - Set specific value" -ForegroundColor Gray  
        Write-Host "    save                - Save changes" -ForegroundColor Gray
        Write-Host "    exit                - Exit editor" -ForegroundColor Gray
        Write-Host ""
        
        $input = Read-Host "  config> "
        if (-not $input) { continue }
        
        if ($input -match '^(?i)(exit|quit|q)$') { break }
        elseif ($input -match '^(?i)save$') { 
            [ConfigManager]::Save()
            Write-Host "  ‚úÖ Configuration saved!" -ForegroundColor Green
            Start-Sleep -Milliseconds 800
        }
        elseif ($input -match '^\s*#?\s*(\d+)(?:\s+(.+))?$') {
            $optionNum = [int]$matches[1]
            $newValue = if ($matches[2]) { $matches[2].Trim() } else { $null }
            
            $options = Get-ConfigOptions
            if ($optionNum -ge 1 -and $optionNum -le $options.Count) {
                $option = $options[$optionNum - 1]
                $cfg = [ConfigManager]::Config
                $currentValue = Get-ConfigOptionValue -option $option -cfg $cfg
                
                if ($newValue) {
                    # Set specific value
                    try {
                        if ($option.Type -eq 'boolean') {
                            $typedValue = $newValue -match '^(?i:true|yes|1|on)$'
                        } elseif ($option.Type -eq 'number') {
                            $typedValue = [int]$newValue
                        } else {
                            $typedValue = $newValue
                        }
                        Set-ConfigOptionValue -option $option -cfg $cfg -value $typedValue
                        [ConfigManager]::Config = $cfg
                        Write-Host "  ‚úÖ $($option.Name) set to: $typedValue" -ForegroundColor Green
                    } catch {
                        Write-Host "  ‚ùå Invalid value for $($option.Name): $newValue" -ForegroundColor Red
                    }
                } else {
                    # Toggle or prompt
                    if ($option.Type -eq 'boolean') {
                        $newVal = -not $currentValue
                        Set-ConfigOptionValue -option $option -cfg $cfg -value $newVal
                        [ConfigManager]::Config = $cfg
                        Write-Host "  ‚úÖ $($option.Name) toggled to: $newVal" -ForegroundColor Green
                    } else {
                        Write-Host "  Current: $currentValue" -ForegroundColor Gray
                        $promptValue = Read-Host "  New value"
                        if ($promptValue) {
                            try {
                                if ($option.Type -eq 'number') {
                                    $typedValue = [int]$promptValue
                                } else {
                                    $typedValue = $promptValue
                                }
                                Set-ConfigOptionValue -option $option -cfg $cfg -value $typedValue
                                [ConfigManager]::Config = $cfg
                                Write-Host "  ‚úÖ $($option.Name) set to: $typedValue" -ForegroundColor Green
                            } catch {
                                Write-Host "  ‚ùå Invalid value: $promptValue" -ForegroundColor Red
                            }
                        }
                    }
                }
                Start-Sleep -Milliseconds 600
            } else {
                Write-Host "  ‚ùå Invalid option number: $optionNum (valid range: 1-$($options.Count))" -ForegroundColor Red
                Start-Sleep -Milliseconds 800
            }
        }
        else { 
            Write-Host "  ‚ùå Invalid command. Use # <number> or # <number> <value>" -ForegroundColor Red
            Start-Sleep -Milliseconds 800
        }
    }
}

# === EXCEL T2020 INTEGRATION ===
function Ensure-ExcelModule {
    $localPath = Join-Path $PSScriptRoot 'ExcelT2020.psm1'
    $parentPath = Join-Path (Split-Path $PSScriptRoot -Parent) 'ExcelT2020.psm1'
    if (-not (Get-Module -Name ExcelT2020 -ListAvailable)) {
        if (Test-Path $localPath) { Import-Module $localPath -Force; return }
        if (Test-Path $parentPath) { Import-Module $parentPath -Force; return }
        throw "ExcelT2020 module not found. Tried: $localPath; $parentPath"
    }
}

function Import-ExcelT2020 {
    try { Ensure-ExcelModule } catch { Write-Host $_ -ForegroundColor Red; return }
    # Apply config to module if available
    try {
        [ConfigManager]::Load()
        $cfg = [ConfigManager]::Config
        if ($cfg.Excel) {
            Set-ExcelT2020Config -SourceFolder $cfg.Excel.SourceFolder -DestinationPath $cfg.Excel.DestinationPath -SourceSheetName $cfg.Excel.SourceSheet -DestSheetName $cfg.Excel.DestSheet
        }
    } catch {}
    $result = Invoke-T2020Batch
    if (-not $result.Success) { Write-Host "Excel import failed" -ForegroundColor Red; return }

    # Persist a summary inside T2 data for viewing
    $data = Get-TaskData
    if (-not $data.excelImports) { $data | Add-Member -NotePropertyName excelImports -NotePropertyValue @() -Force }
    foreach ($rec in $result.Summary) {
        $data.excelImports += [PSCustomObject]@{
            Timestamp = $rec.Timestamp
            Source    = $rec.Source
            Destination = $rec.Destination
            Count     = $rec.Count
            Success   = $rec.Success
            Fields    = $rec.Fields
        }
    }

    # Attempt to bind imports to projects using ID2 = CASNumber
    $id2Field = 'CASNumber'
    try { if ($cfg.Excel -and $cfg.Excel.ID2FieldName) { $id2Field = $cfg.Excel.ID2FieldName } } catch {}
    foreach ($rec in $result.Summary) {
        if (-not $rec.Fields) { continue }
        $id2Val = $null
        foreach ($p in $rec.Fields.PSObject.Properties) { if ($p.Name -ieq $id2Field) { $id2Val = $p.Value; break } }
        if ([string]::IsNullOrWhiteSpace($id2Val)) { continue }
        $proj = $data.projects | Where-Object { $_.ID2 -and $_.ID2 -eq $id2Val } | Select-Object -First 1
        if ($proj) {
            # Store fields on the project for direct viewing
            if (-not $proj.PSObject.Properties['ExcelFields']) { $proj | Add-Member -NotePropertyName ExcelFields -NotePropertyValue @{} -Force }
            $proj.ExcelFields = $rec.Fields
            # Optionally backfill ID1 from TaxID if empty
            if (-not $proj.ID1 -or [string]::IsNullOrWhiteSpace($proj.ID1)) {
                foreach ($p in $rec.Fields.PSObject.Properties) { if ($p.Name -ieq 'TaxID' -and $p.Value) { $proj.ID1 = $p.Value; break } }
            }
        }
    }
$global:LastAction = 'import excel'
    Save-TaskData $data

    # Show quick table summary
    $rows = @()
    foreach ($rec in $result.Summary | Select-Object -Last 10) {
        $rows += , @($rec.Timestamp, (Split-Path $rec.Source -Leaf), $rec.Count, ($rec.Success ? 'OK' : 'ERR'))
    }
    if ($rows.Count -eq 0) { $rows = @(@('(no files)', '', '', '')) }
    Format-StyledTable -Headers @('Time','File','Fields','Status') -DataRows $rows -Title 'Excel T2020 Import Summary'
    Write-Host ("  ‚úÖ Imported {0}/{1} file(s)" -f ($result.Summary | Where-Object { $_.Success }).Count, ($result.Summary).Count) -ForegroundColor Green
}

function Show-ExcelLatest {
    $data = Get-TaskData
    $imports = @($data.excelImports)
    if ($imports.Count -eq 0) { Format-StyledTable -Headers @('Info') -DataRows @(@('No Excel imports yet')) -Title 'Excel Imports'; return }
    $rows = @()
    $last = $imports | Select-Object -Last 10
    $i = [Math]::Max(1, $imports.Count - $last.Count + 1)
    foreach ($rec in $last) {
        $rows += , @($i, $rec.Timestamp, (Split-Path $rec.Source -Leaf), $rec.Count, ($rec.Success ? 'OK' : 'ERR'))
        $i++
    }
    Format-StyledTable -Headers @('#','Time','File','Fields','Status') -DataRows $rows -Title 'Recent Excel Imports'
}

function Show-ExcelImportDetails {
    param($context)
    $data = Get-TaskData
    $imports = @($data.excelImports)
    if ($imports.Count -eq 0) { Format-StyledTable -Headers @('Info') -DataRows @(@('No Excel imports yet')) -Title 'Excel Import Details'; return }
    $arg = if ($context) { $context.GetText() } else { '' }
    $rec = $null
    if ($arg -match '^\d+$') {
        $idx = [int]$arg
        if ($idx -ge 1 -and $idx -le $imports.Count) { $rec = $imports[$idx - 1] }
    } elseif ($arg) {
        $rec = ($imports | Where-Object { $_.Source -like "*${arg}*" } | Select-Object -Last 1)
    } else {
        $rec = $imports[-1]
    }
    if (-not $rec) { Format-StyledTable -Headers @('Info') -DataRows @(@('Import not found')) -Title 'Excel Import Details'; return }
    $rows = @();
    foreach ($k in $rec.Fields.Keys) { $rows += , @($k, ($rec.Fields[$k] -as [string])) }
    if ($rows.Count -eq 0) { $rows = @(@('(no fields)','')) }
    $title = "Fields for: " + (Split-Path $rec.Source -Leaf)
    Format-StyledTable -Headers @('Field','Value') -DataRows $rows -Title $title
}

function Show-ExcelProjectFields {
    param($context)
    $name = if ($context) { $context.GetText() } else { '' }
    if ([string]::IsNullOrWhiteSpace($name)) { Write-Host "Usage: show project-fields <name>" -ForegroundColor Yellow; return }
    $project = Find-Project -query $name -Interactive
    if (-not $project) { return }
    if (-not $project.PSObject.Properties['ExcelFields'] -or -not $project.ExcelFields) {
        Format-StyledTable -Headers @('Info') -DataRows @(@('No Excel fields on this project. Run "import excel".')) -Title ("EXCEL FIELDS - " + $project.name.ToUpper())
        return
    }
    $rows = @(); foreach ($p in $project.ExcelFields.PSObject.Properties) { $rows += , @($p.Name, ($p.Value -as [string])) }
    Format-StyledTable -Headers @('Field','Value') -DataRows $rows -Title ("EXCEL FIELDS - " + $project.name.ToUpper())
}

function Set-ProjectFields {
    param($context)
    $text = $context.GetText()
    if (-not $text) {
        Write-Host "Usage: set project-fields <name> key=value [key=value ...]" -ForegroundColor Yellow
        return
    }
    # Split project name and updates
    $parts = $text -split '\s+', 2
    if ($parts.Count -lt 2) { Write-Host "Usage: set project-fields <name> key=value [key=value ...]" -ForegroundColor Yellow; return }
    $name = $parts[0]
    $updates = $parts[1]
    $data = Get-TaskData
    $project = $data.projects | Where-Object { $_.name -eq $name } | Select-Object -First 1
    if (-not $project) { Write-Host "Project '$name' not found" -ForegroundColor Red; return }

    $allowed = @('ID1','ID2','ProjFolder','AssignedDate','DueDate','BFDate','CAAName','RequestName','T2020')
    $changed = @()
    # Tokenize updates with quoted-value support key="some value"
    $pattern = '(\w+)=(("[^"]+")|[^\s]+)'
    $m = [regex]::Matches($updates, $pattern)
    foreach ($match in $m) {
        $k = $match.Groups[1].Value
        $v = $match.Groups[2].Value.Trim('"')
        if ($k -eq 'x' -and $v -match '^(\w+):(.*)$') {
            # x:FieldName:Value -> set ExcelFields
            $xf = $matches[1]; $xv = $matches[2]
            if (-not $project.PSObject.Properties['ExcelFields']) { $project | Add-Member -NotePropertyName ExcelFields -NotePropertyValue @{} -Force }
            $project.ExcelFields[$xf] = $xv
            $changed += "ExcelFields.$xf=$xv"
            continue
        }
        if ($k -notin $allowed) { Write-Host "Skipping unknown field '$k'" -ForegroundColor Yellow; continue }
        # Basic normalization for dates (store as yyyy-MM-dd if matchable)
        if ($k -match 'Date$') {
            try { $d = [datetime]::Parse($v); $v = $d.ToString('yyyy-MM-dd') } catch {}
        }
        if ($project.PSObject.Properties[$k]) { $project.$k = $v } else { Add-Member -InputObject $project -MemberType NoteProperty -Name $k -Value $v }
        $changed += "$k=$v"
    }
    Save-TaskData $data
    if ($changed.Count -gt 0) { Write-Host ("Updated {0}: {1}" -f $project.name, ($changed -join ', ')) -ForegroundColor Green } else { Write-Host "No valid updates applied." -ForegroundColor Yellow }
}

# === ROBUST COMPLETION SYSTEM ===

# Completion modes - finite state machine
enum CompletionMode {
    Command          # Completing command names (add, done, report)
    Subcommand      # Completing verb-object pairs (start timer, add project)
    SyntaxDiscovery # Showing argument syntax patterns (@, p1, due:)
    PrefixCompletion # Completing within a prefix (@projects, due:dates)
    FreeText        # No completions available
    Help           # Showing help/syntax guidance
}

# Comprehensive completion state
class CompletionState {
    # Current parsing state
    [string] $OriginalBuffer = ""
    [string] $CurrentCommand = ""          # Legacy - use FullCommandName instead
    [array] $CompletedArguments = @()      # Legacy - use ParsedArguments instead
    [string] $CurrentToken = ""
    [bool] $TokenComplete = $false
    [int] $CursorPosition = 0
    
    # Enhanced parsing state (Phase 2)
    [string] $FullCommandName = ""         # Complete resolved command name
    [array] $ArgumentTokens = @()          # Array of ParsedToken objects for arguments
    [ParsedToken] $TokenUnderCursor = $null   # Token at cursor position
    [bool] $IsOnNewWord = $false           # True if cursor is on a new word position
    [hashtable] $ParsedArguments = @{}     # Structured argument parsing
    
    # Completion mode and context
    [CompletionMode] $Mode = [CompletionMode]::Command
    [string] $PrefixBeingCompleted = ""
    [array] $AvailableCompletions = @()
    [hashtable] $ParsedContext = @{}
    
    # State management with deep copy support
    [CompletionState] Clone() {
        $clone = [CompletionState]::new()
        
        # Copy legacy properties
        $clone.OriginalBuffer = $this.OriginalBuffer
        $clone.CurrentCommand = $this.CurrentCommand
        $clone.CompletedArguments = @($this.CompletedArguments)  # New array, same references
        $clone.CurrentToken = $this.CurrentToken
        $clone.TokenComplete = $this.TokenComplete
        $clone.CursorPosition = $this.CursorPosition
        
        # Copy enhanced properties (Phase 2)
        $clone.FullCommandName = $this.FullCommandName
        $clone.ArgumentTokens = @($this.ArgumentTokens)  # New array, same token references
        $clone.TokenUnderCursor = $this.TokenUnderCursor  # Reference copy is fine for immutable tokens
        $clone.IsOnNewWord = $this.IsOnNewWord
        $clone.ParsedArguments = @{}  # Create new hashtable
        if ($this.ParsedArguments) {
            foreach ($key in $this.ParsedArguments.Keys) {
                $clone.ParsedArguments[$key] = $this.ParsedArguments[$key]
            }
        }
        
        # Copy completion context
        $clone.Mode = $this.Mode
        $clone.PrefixBeingCompleted = $this.PrefixBeingCompleted
        $clone.AvailableCompletions = @($this.AvailableCompletions)  # New array
        $clone.ParsedContext = @{}  # Create new hashtable
        if ($this.ParsedContext) {
            foreach ($key in $this.ParsedContext.Keys) {
                $clone.ParsedContext[$key] = $this.ParsedContext[$key]
            }
        }
        
        return $clone
    }
    
    [void] Reset() {
        # Reset legacy properties
        $this.OriginalBuffer = ""
        $this.CurrentCommand = ""
        $this.CompletedArguments = @()
        $this.CurrentToken = ""
        $this.TokenComplete = $false
        $this.CursorPosition = 0
        
        # Reset enhanced properties (Phase 2)
        $this.FullCommandName = ""
        $this.ArgumentTokens = @()
        $this.TokenUnderCursor = $null
        $this.IsOnNewWord = $false
        $this.ParsedArguments = @{}
        
        # Reset completion context
        $this.Mode = [CompletionMode]::Command
        $this.PrefixBeingCompleted = ""
        $this.AvailableCompletions = @()
        $this.ParsedContext = @{}
    }
}

# Token with position information
class ParsedToken {
    [string] $Text = ""
    [int] $StartPos = 0
    [int] $EndPos = 0
    [bool] $IsComplete = $true
    [string] $Type = "Unknown"  # Command, Argument, Prefix, etc.
    
    ParsedToken([string] $text, [int] $start, [int] $end) {
        $this.Text = $text
        $this.StartPos = $start
        $this.EndPos = $end
    }
}

# Completion item with rich metadata
class CompletionItem {
    [string] $Text = ""
    [string] $Description = ""
    [string] $Category = ""
    [string] $Type = ""
    [int] $Score = 0
    [hashtable] $Metadata = @{}
    
    CompletionItem([string] $text, [string] $description, [string] $category, [int] $score) {
        $this.Text = $text
        $this.Description = $description
        $this.Category = $category
        $this.Score = $score
    }
}

# Command execution context - wrapper around CompletionState for command handlers
class CommandContext {
    [string] $CommandName = ""           # The resolved command name (e.g., "add", "add project")
    [hashtable] $Args = @{}              # Structured arguments (e.g., @{project="work"; priority=1})
    [string[]] $FreeText = @()           # Non-argument text tokens
    [string] $RawText = ""               # Clean remaining text after argument extraction
    [CompletionState] $State = $null     # Full parser state for advanced use cases
    [object] $Parser = $null             # Reference to parser for schema access
    
    # Validation properties
    [string[]] $ValidationErrors = @()   # List of validation error messages
    [string[]] $ValidationWarnings = @() # List of validation warnings
    [bool] $IsValid = $true              # True if no validation errors
    
    # Constructor from CompletionState and Parser
    CommandContext([CompletionState] $state, [object] $parser) {
        $this.State = $state
        $this.Parser = $parser
        $this.CommandName = $state.FullCommandName
        $this.ParseArguments()
        $this.ValidateCommand()  # Validate after parsing arguments
    }
    
    # Legacy constructor for backward compatibility
    CommandContext([CompletionState] $state) {
        $this.State = $state
        $this.CommandName = $state.FullCommandName
        $this.ParseArguments()
        $this.ValidateCommand()  # Validate after parsing arguments
    }
    
    # Parse ArgumentTokens into structured Args and FreeText
    [void] ParseArguments() {
        $this.Args = @{}
        $freeTextTokens = @()
        $cmdName = if ($this.CommandName) { $this.CommandName.ToLower() } else { '' }
        $baseVerb = if ($cmdName) { ($cmdName -split ' ')[0] } else { '' }
        $preserveArgsInFreeText = ($baseVerb -in @('update','move','postpone','duplicate','delete','done'))
        
        foreach ($token in $this.State.ArgumentTokens) {
            $text = $token.Text
            
            # Project arguments (@project)
            if ($text -match '^@(.+)$') {
                $projVal = $matches[1]
                if ($projVal.StartsWith('"') -and $projVal.EndsWith('"') -and $projVal.Length -ge 2) {
                    $projVal = $projVal.Substring(1, $projVal.Length-2)
                }
                $this.Args['project'] = $projVal
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Priority arguments (p1, p2, p3, !, !!, !!!)
            elseif ($text -match '^p([123])$') {
                $this.Args['priority'] = [int]$matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            elseif ($text -eq '!') {
                $this.Args['priority'] = 1
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            elseif ($text -eq '!!') {
                $this.Args['priority'] = 2
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            elseif ($text -eq '!!!') {
                $this.Args['priority'] = 3
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Due date arguments (due:date)
            elseif ($text -match '^due:(.+)$') {
                $this.Args['due'] = $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # est: removed ‚Äî do not parse
            # Description argument (desc:text)
            elseif ($text -match '^desc:(.+)$') {
                $this.Args['desc'] = $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Tag arguments (#tag or +tag)
            elseif ($text -match '^#(.+)$') {
                if (-not $this.Args.ContainsKey('tags')) {
                    $this.Args['tags'] = @()
                }
                $this.Args['tags'] += $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            elseif ($text -match '^\+(.+)$') {
                if (-not $this.Args.ContainsKey('tags')) {
                    $this.Args['tags'] = @()
                }
                $this.Args['tags'] += $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Remove tag arguments (-tag or -#tag)
            elseif ($text -match '^-#?(.+)$') {
                if (-not $this.Args.ContainsKey('removeTags')) {
                    $this.Args['removeTags'] = @()
                }
                $this.Args['removeTags'] += $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Recurrence arguments (recur:pattern)
            elseif ($text -match '^recur:(.+)$') {
                $this.Args['recur'] = $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Dependency arguments (dep:id)
            elseif ($text -match '^dep:(.+)$') {
                if (-not $this.Args.ContainsKey('dependencies')) {
                    $this.Args['dependencies'] = @()
                }
                $this.Args['dependencies'] += $matches[1]
                if ($preserveArgsInFreeText) { $freeTextTokens += $text; continue }
            }
            # Everything else is free text
            else {
                $freeTextTokens += $text
            }
        }
        
        $this.FreeText = $freeTextTokens
        $this.RawText = ($freeTextTokens -join ' ').Trim()

        # Command-aware normalization: extract IDs/delta from free text into Args (without removing from text)
        try {
            $cmd = if ($this.CommandName) { $this.CommandName.ToLower() } else { '' }
            $baseVerb2 = if ($cmd) { ($cmd -split ' ')[0] } else { '' }
            $needsId = $baseVerb2 -in @('update','move','postpone','duplicate','delete','done')
            if ($needsId -and $this.FreeText.Count -gt 0) {
                $idToken = $this.FreeText[0]
                if ($idToken -match '^\d+([,-]\d+)*$') { $this.Args['id'] = $idToken }
                if ($cmd -eq 'postpone' -and $this.FreeText.Count -gt 1) { $this.Args['delta'] = $this.FreeText[1] }
            }
        } catch { }
    }
    
    # Helper methods for common operations
    [bool] HasArg([string] $name) {
        return $this.Args.ContainsKey($name)
    }
    
    [object] GetArg([string] $name, [object] $default = $null) {
        if ($this.Args.ContainsKey($name)) {
            return $this.Args[$name]
        }
        return $default
    }
    
    [string] GetProject() {
        return $this.GetArg('project', $global:CurrentContext)
    }
    
    [int] GetPriority() {
        $v = $this.GetArg('priority', 0)
        try {
            if ($v -is [int]) { return $v }
            if ($v -is [string]) {
                $t = $v.Trim().ToLower()
                if ($t -match '^p([1-3])$') { return [int]$matches[1] }
                if ($t -match '^[0-3]$') { return [int]$t }
            }
        } catch {}
        return 0
    }
    
    [string[]] GetTags() {
        return $this.GetArg('tags', @())
    }
    
    [string] GetText() {
        return $this.RawText
    }
    
    # Validation methods
    [void] AddError([string] $message) {
        $this.ValidationErrors += $message
        $this.IsValid = $false
    }
    
    [void] AddWarning([string] $message) {
        $this.ValidationWarnings += $message
    }
    
    [void] ValidateCommand() {
        # Use schema-based validation if available
        if ($this.Parser -and $this.Parser.CommandSchemas -and $this.Parser.CommandSchemas.ContainsKey($this.CommandName)) {
            $this.ValidateWithSchema($this.Parser.CommandSchemas[$this.CommandName])
        } else {
            # Fall back to legacy validation
            $this.ValidateWithoutSchema()
        }
    }
    
    [void] ValidateWithSchema([CommandSchema] $schema) {
        # Validate required arguments
        foreach ($argSchema in $schema.Arguments) {
            if ($argSchema.Required) {
                if ($argSchema.Type -eq "text") {
                    # Text arguments are validated by checking FreeText
                    if ($this.FreeText.Count -eq 0 -or [string]::IsNullOrWhiteSpace($this.GetText())) {
                        $this.AddError("$($argSchema.Description) is required")
                    }
                } elseif (-not $this.HasArg($argSchema.Name)) {
                    # Option B: allow required arg to be satisfied from FreeText when it matches pattern/expectation
                    $satisfied = $false
                    if ($this.FreeText -and $this.FreeText.Count -gt 0) {
                        # Check all free-text tokens for a match (first wins)
                        foreach ($tok in $this.FreeText) {
                            if ($argSchema.Pattern -and ($tok -match $argSchema.Pattern)) { $satisfied = $true; break }
                            elseif (-not $argSchema.Pattern) {
                                # Heuristics for common types
                                if ($argSchema.Name -eq 'id' -and $tok -match '^\d+([,-]\d+)*$') { $satisfied = $true; break }
                                elseif ($argSchema.Name -eq 'delta' -and ($tok -match '^\+\d+d$' -or $tok -match '^\d{4}-\d{2}-\d{2}$' -or $tok -match '^(?i)tomorrow|today$')) { $satisfied = $true; break }
                                elseif ($argSchema.Type -eq 'project' -and $tok -match '^@') { $satisfied = $true; break }
                                elseif ($argSchema.Type -eq 'duration' -and $tok -match '^\d+(?:\.\d+)?[hm]$') { $satisfied = $true; break }
                                elseif ($argSchema.Type -eq 'date' -and ($tok -match '^\d{4}-\d{2}-\d{2}$' -or $tok -match '^(?i)today|tomorrow$')) { $satisfied = $true; break }
                                else { if (-not [string]::IsNullOrWhiteSpace($tok)) { $satisfied = $true; break } }
                            }
                        }
                    }
                    if (-not $satisfied) {
                        $this.AddError("$($argSchema.Description) is required")
                    }
                }
            }
        }
        
        # Validate argument patterns and values
        foreach ($argName in $this.Args.Keys) {
            $argSchema = $schema.GetArgumentSchema($argName)
            if ($argSchema) {
                $value = $this.Args[$argName]
                
                # Pattern validation
                if ($argSchema.Pattern -and $value -notmatch $argSchema.Pattern) {
                    $this.AddError("Invalid format for $($argSchema.Name): '$value'. Expected format: $($argSchema.Example)")
                }
                
                # Valid values validation
                if ($argSchema.ValidValues.Count -gt 0 -and $value -notin $argSchema.ValidValues) {
                    $validStr = $argSchema.ValidValues -join ", "
                    $this.AddError("Invalid value for $($argSchema.Name): '$value'. Valid values: $validStr")
                }
            }
        }
    }
    
    [void] ValidateWithoutSchema() {
        # Legacy validation for backward compatibility
        switch ($this.CommandName) {
            'add' {
                # Add command validation
                if ([string]::IsNullOrWhiteSpace($this.GetText())) {
                    $this.AddError("Task description is required")
                }
                
                # Check for conflicting priority arguments
                if ($this.HasArg('priority')) {
                    $priority = $this.GetArg('priority', 0)
                    if ($priority -lt 0 -or $priority -gt 3) {
                        $this.AddError("Priority must be between 0 and 3 (p1=high, p2=med, p3=low)")
                    }
                }
                
                # Validate due date format if provided
                if ($this.HasArg('due')) {
                    $dueStr = $this.GetArg('due', '')
                    if (-not [string]::IsNullOrEmpty($dueStr)) {
                        # Normalize and validate with both smart and natural parsers
                        $norm = $dueStr.Trim()
                        if ($norm.StartsWith('"') -and $norm.EndsWith('"') -and $norm.Length -ge 2) { $norm = $norm.Substring(1, $norm.Length-2) }
                        if ($norm.StartsWith("'") -and $norm.EndsWith("'") -and $norm.Length -ge 2) { $norm = $norm.Substring(1, $norm.Length-2) }
                        $norm = $norm.Trim().TrimEnd(',', '.', ';', ':')
                        Write-DebugLog ("VALID: due normalized from '" + $dueStr + "' -> '" + $norm + "'")
                        $ok = $false
                        try { $tmp = Parse-SmartDate $norm; if ($tmp) { $ok = $true } } catch {}
                        if (-not $ok) { try { $tmp2 = Parse-NaturalDate -input $norm; if ($tmp2) { $ok = $true } } catch {} }
                        if (-not $ok) {
                            $this.AddError("Invalid due date format: '" + $dueStr + "'. Use formats like 'today', 'tomorrow', '+3d', 'eom', or '2024-12-25'")
                        }
                    }
                }
                
                # est: removed ‚Äî no estimate validation
                
                # Check for empty project name
                if ($this.HasArg('project')) {
                    $proj = $this.GetArg('project', '')
                    if ([string]::IsNullOrWhiteSpace($proj)) {
                        $this.AddError("Project name cannot be empty")
                    }
                }
            }
            
            'add project' {
                # Project creation validation
                if ([string]::IsNullOrWhiteSpace($this.GetText())) {
                    $this.AddError("Project name is required")
                }
            }
            
            'add dep' {
                # Dependency validation - need two task IDs
                $argCount = $this.FreeText.Count
                if ($argCount -lt 2) {
                    $this.AddError("Dependency requires two task IDs: add dep <task> <depends-on>")
                } elseif ($argCount -gt 2) {
                    $this.AddWarning("Extra arguments ignored. Usage: add dep <task> <depends-on>")
                }
            }
        }
    }
    
    [void] ShowValidationErrors() {
        if ($this.ValidationErrors.Count -gt 0) {
            Write-Host "  ‚ùå VALIDATION ERRORS:" -ForegroundColor Red
            foreach ($error in $this.ValidationErrors) {
                Write-Host "     ‚Ä¢ $error" -ForegroundColor Red
            }
            Write-Host ""
        }
        
        if ($this.ValidationWarnings.Count -gt 0) {
            Write-Host "  ‚ö†Ô∏è  WARNINGS:" -ForegroundColor Yellow
            foreach ($warning in $this.ValidationWarnings) {
                Write-Host "     ‚Ä¢ $warning" -ForegroundColor Yellow
            }
            Write-Host ""
        }
    }
}

# Argument schema system for command validation and smart completions
class ArgumentSchema {
    [string] $Name = ""              # Argument name (e.g., "project", "priority", "due")
    [string] $Type = ""              # Argument type (e.g., "project", "priority", "date", "text")
    [string] $Prefix = ""            # Required prefix (e.g., "@", "due:", "#")
    [bool] $Required = $false        # Whether this argument is required
    [string[]] $ValidValues = @()    # Valid values for enum-type arguments
    [string] $Pattern = ""           # Regex pattern for validation
    [string] $Description = ""       # Human-readable description
    [string] $Example = ""           # Example usage
}

class CommandSchema {
    [string] $CommandName = ""       # The command this schema applies to
    [ArgumentSchema[]] $Arguments = @() # Array of argument schemas
    [string] $Description = ""       # Command description
    [string] $Syntax = ""           # Syntax example
    
    # Helper to get schema for a specific argument
    [ArgumentSchema] GetArgumentSchema([string] $argName) {
        return $this.Arguments | Where-Object { $_.Name -eq $argName } | Select-Object -First 1
    }
    
    # Get all argument schemas by type
    [ArgumentSchema[]] GetArgumentsByType([string] $type) {
        return $this.Arguments | Where-Object { $_.Type -eq $type }
    }
}

# === ENHANCED INPUT HANDLER ===
class SmartCommandParser {
    [hashtable] $Commands = @{}
    [hashtable] $Aliases = @{}
    [hashtable] $CommandSchemas = @{}
    [object] $CachedData = $null
    [datetime] $CacheTime = [datetime]::MinValue
    [hashtable] $CommandMap
    [hashtable] $ParameterMap
    [CompletionState] $CurrentState = $null

    SmartCommandParser() {
        $this.CommandMap = @{
            # Core task verbs (verb-object)
            'add' = @{ 'task' = 'Add-SmartTask'; 'project' = 'Add-Project'; 'dep' = 'Add-SmartDependency'; 'alias' = 'Add-UserAlias' }
            'done' = @{ '' = 'Complete-Quick'; 'task' = 'Complete-Quick' }
            'delete' = @{ '' = 'Delete-SmartTasks'; 'task' = 'Delete-SmartTasks'; 'project' = 'Delete-Project'; 'time' = 'Delete-TimeLog' }
            'update' = @{ 'task' = 'Update-SmartTask' }
            'postpone' = @{ 'task' = 'Postpone-Task' }
            'duplicate' = @{ 'task' = 'Duplicate-Task' }
            'move' = @{ 'task' = 'Move-Task' }
            'note' = @{ 'task' = 'Add-TaskNote' }
            'view' = @{ 'task' = 'Show-TaskDetails' }
            'edit' = @{ 'task' = 'Edit-TaskInteractive'; 'time' = 'Edit-TimeLog'; 'config' = 'Show-ConfigEditor' }

            # Project operations
            'rename' = @{ 'project' = 'Rename-Project' }
            'archive' = @{ 'project' = 'Archive-Project' }
            'list' = @{ 'tasks' = 'Show-AllTasks'; 'projects' = 'Show-ProjectDashboard'; 'time' = 'Show-TimeLogList'; 'templates' = 'Show-Templates'; 'recurring' = 'Show-RecurringTasks' }
            'search' = @{ 'tasks' = 'Show-FilteredTasks' }
            'priority' = @{ 'tasks' = 'Show-FilteredTasks' }

            # Time and reports
            'log' = @{ 'time' = 'Log-StructuredEntry' }
            'report' = @{ 'time' = 'Show-TimeReportEnhanced' }

            # Timer controls
            'start' = @{ 'timer' = 'Start-Timer' }
            'stop'  = @{ 'timer' = 'Stop-Timer' }
            'status'= @{ 'timer' = 'Show-TimerStatus' }

            # Dependencies and alias management (verb-object)
            'remove' = @{ 'dep' = 'Remove-SmartDependency'; 'alias' = 'Remove-UserAlias' }
            'show' = @{ 'project' = 'Show-ProjectDetails'; 'dep' = 'Show-Dependencies'; 'dep-graph' = 'Show-DependencyGraph'; 'config' = 'Show-Config'; 'aliases' = 'Show-Aliases'; 'commands' = 'Show-AllCommands'; 'excel' = 'Show-ExcelImportDetails' }

            # Templates/recurring
            'apply' = @{ 'template' = 'Apply-SmartTemplate' }
            'save' = @{ 'template' = 'Save-SmartTemplate' }

            # Excel and import/export
            'import' = @{ 'tasks' = 'Import-Tasks'; 'excel' = 'Import-ExcelT2020' }
            'export' = @{ 'tasks' = 'Export-Tasks' }

            # Config and aliases (verb-object)
            'set' = @{ 'config' = 'Set-ConfigFromCommand'; 'project-fields' = 'Set-ProjectFields' }

            # Misc
            'next' = @{ '' = 'Show-NextActions' }
            'review' = @{ '' = 'Start-WeeklyReview' }
            'stats' = @{ '' = 'Show-ProductivityStats' }
            'burndown' = @{ '' = 'Show-BurndownChart' }
            'velocity' = @{ '' = 'Show-VelocityChart' }
            'undo' = @{ '' = 'Undo-LastAction' }
            'redo' = @{ '' = 'Redo-Action' }
            'backup' = @{ '' = 'Backup-Data' }
            'clean' = @{ '' = 'Clean-CompletedTasks' }
            'help' = @{ '' = 'Show-SmartHelp' }
            'agenda' = @{ '' = 'Show-RichAgenda' }
            'quit' = @{ '' = 'Exit-SmartTUI' }

            '#' = @{ '' = 'Invoke-NumberedAction' }
        }

        $this.ParameterMap = @{
            'Add-SmartTask' = @(
                @{ Name='Project'; Prefix='@'; Type='ProjectName' }
                @{ Name='Priority'; Prefix='p'; Type='Priority'; Pattern='^p[1-3]$' }
                @{ Name='Due'; Prefix='due:'; Type='DateString' }
                @{ Name='Tags'; Prefix='#'; Type='TagName'; AllowsMultiple=$true }
                @{ Name='RemoveTags'; Prefix='-#'; Type='RemoveTagName'; AllowsMultiple=$true }
                @{ Name='Dependencies'; Prefix='dep:'; Type='Dependency'; AllowsMultiple=$true }
                @{ Name='Recur'; Prefix='recur:'; Type='RecurPattern' }
                @{ Name='Desc'; Prefix='desc:'; Type='Description' }
                @{ Name='Text'; Prefix=''; Type='FreeText'; Required=$true }
            )
            'Move-Task' = @(
                @{ Name='Id'; Prefix=''; Type='TaskID'; Required=$true; Pattern='^\d+$' }
                @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true }
            )
            'Postpone-Task' = @(
                @{ Name='Id'; Prefix=''; Type='TaskID'; Required=$true; Pattern='^\d+$' }
                @{ Name='Delta'; Prefix=''; Type='DateOffset'; Required=$true }
            )
            'Update-SmartTask' = @(
                @{ Name='Id'; Prefix=''; Type='TaskID'; Required=$true; Pattern='^\d+$' }
                @{ Name='Project'; Prefix='@'; Type='ProjectName' }
                @{ Name='Priority'; Prefix='p'; Type='Priority'; Pattern='^p[0-3]$' }
                @{ Name='Due'; Prefix='due:'; Type='DateString' }
                @{ Name='Tags'; Prefix='#'; Type='TagName'; AllowsMultiple=$true }
                @{ Name='RemoveTags'; Prefix='-#'; Type='RemoveTagName'; AllowsMultiple=$true }
                @{ Name='Dependencies'; Prefix='dep:'; Type='Dependency'; AllowsMultiple=$true }
                @{ Name='Recur'; Prefix='recur:'; Type='RecurPattern' }
                @{ Name='Desc'; Prefix='desc:'; Type='Description' }
                @{ Name='Text'; Prefix=''; Type='FreeText' }
            )
            'Complete-SmartTasks' = @(
                @{ Name='Id'; Prefix=''; Type='TaskID'; Required=$true; Pattern='^\d+([,-]\d+)*$' }
            )
            'Delete-SmartTasks' = @(
                @{ Name='Id'; Prefix=''; Type='TaskID'; Required=$true; Pattern='^\d+([,-]\d+)*$' }
            )
            'Log-StructuredEntry' = @(
                @{ Name='Project'; Prefix='@'; Type='ProjectName' }
                @{ Name='ID1'; Prefix='#'; Type='ID1Code'; Pattern='^#\w+$' }
                @{ Name='Date'; Prefix=''; Type='DateString' }
                @{ Name='Hours'; Prefix=''; Type='Number' }
                @{ Name='Description'; Prefix=''; Type='FreeText' }
            )
        }

        # Build Commands table from CommandMap for execution layer
        foreach ($verb in $this.CommandMap.Keys) {
            $map = $this.CommandMap[$verb]
            foreach ($obj in $map.Keys) {
                $fn = $map[$obj]
                $key = if ([string]::IsNullOrEmpty($obj)) { $verb } else { "$verb $obj" }
                $handler = [scriptblock]::Create("param(`$context) & $fn `$context")
                $this.Commands[$key] = @{ Handler = $handler; Description = $key; Category = 'Command' }
            }
        }
        $this.InitializeAliases()

        # Optional: enrich descriptions for help
        $desc = @{
            'add task' = @{ D='Add a new task'; C='Task' }
            'done' = @{ D='Complete tasks by id(s)'; C='Task' }
            'delete' = @{ D='Delete tasks by id(s)'; C='Task' }
            'move task' = @{ D='Move task to a project'; C='Task' }
            'postpone task' = @{ D='Postpone task due date'; C='Task' }
            'update task' = @{ D='Update task fields'; C='Task' }
            'list projects' = @{ D='Project dashboard'; C='Project' }
            'add project' = @{ D='Create a new project'; C='Project' }
            'log time' = @{ D='Log time: @project date hours [desc]'; C='Time' }
            'time report' = @{ D='Enhanced time report with CSV'; C='Time' }
            'report time' = @{ D='Enhanced time report with CSV'; C='Time' }
            'show config' = @{ D='Show configuration'; C='Config' }
            'set config' = @{ D='Set a config value'; C='Config' }
            'help show' = @{ D='Show contextual help'; C='Utility' }
            'help all' = @{ D='List all commands'; C='Utility' }
            'agenda' = @{ D='Show agenda'; C='View' }
            'list tasks' = @{ D='List all tasks'; C='View' }
            'search tasks' = @{ D='Search tasks'; C='View' }
            'priority tasks' = @{ D='Filter by priority'; C='View' }
        }

        foreach ($verb in $this.CommandMap.Keys) {
            foreach ($object in $this.CommandMap[$verb].Keys) {
                $fn = $this.CommandMap[$verb][$object]
                $key = if ($object -eq '') { $verb } else { "$verb $object" }
                $d = if ($desc.ContainsKey($key)) { $desc[$key].D } else { "Execute $fn" }
                $c = if ($desc.ContainsKey($key)) { $desc[$key].C } else { "Command" }
                $this.Commands[$key] = @{ Handler = [scriptblock]::Create("param(`$context) & $fn `$context"); Description = $d; Category = $c }
            }
        }
        $this.InitializeAliases()

        # Build lightweight schemas for syntax line and ghost hints
        $this.BuildCommandSchemas()

        # Add aliases to match t2.ps1 'help all' surface
        $this.AddCommandAliases()
    }

    [void] AddCommandAliases() {
        try {
            $aliasMap = @{
                # Simple list/filters and single-word commands
                'list'          = @{ Handler = { Show-AllTasks }; Description='List all tasks'; Category='View' }
                'today'         = @{ Handler = { Show-FilteredTasks @{Filter='today'} }; Description='Tasks due today'; Category='View' }
                'tomorrow'      = @{ Handler = { Show-FilteredTasks @{Filter='tomorrow'} }; Description='Tasks due tomorrow'; Category='View' }
                'overdue'       = @{ Handler = { Show-FilteredTasks @{Filter='overdue'} }; Description='Overdue tasks'; Category='View' }
                'upcoming'      = @{ Handler = { Show-FilteredTasks @{Filter='upcoming'} }; Description='Next 7 days'; Category='View' }
                'noduedate'     = @{ Handler = { Show-FilteredTasks @{Filter='noduedate'} }; Description='Tasks without due dates'; Category='View' }
                'priority'      = @{ Handler = { param($context) Show-FilteredTasks @{Priority=([int]$context.GetText())} }; Description='Filter by priority (1-3)'; Category='View' }
                'search'        = @{ Handler = { param($context) Show-FilteredTasks @{Search=$context.GetText()} }; Description='Search tasks'; Category='View' }
                'blocked'       = @{ Handler = { Show-BlockedTasks }; Description='Tasks with unmet dependencies'; Category='View' }
                'projects'      = @{ Handler = { Show-ProjectDashboard }; Description='Project dashboard with stats'; Category='Project' }

                # Single-word wrappers (task ops)
                'add'           = @{ Handler = { param($context) Add-SmartTask $context }; Description='Add task'; Category='Task' }
                'done'          = @{ Handler = { param($context) Complete-SmartTasks $context }; Description='Complete task(s)'; Category='Task' }
                'delete'        = @{ Handler = { param($context) Delete-SmartTasks $context }; Description='Delete task(s)'; Category='Task' }
                'update'        = @{ Handler = { param($context) Update-SmartTask $context }; Description='Update task'; Category='Task' }
                'postpone'      = @{ Handler = { param($context) Postpone-Task $context }; Description='Postpone task due date'; Category='Task' }
                'duplicate'     = @{ Handler = { param($context) Duplicate-Task $context }; Description='Duplicate task'; Category='Task' }
                'move'          = @{ Handler = { param($context) Move-Task $context }; Description='Move task to project'; Category='Task' }
                'note'          = @{ Handler = { param($context) Add-TaskNote $context }; Description='Add note to task'; Category='Task' }
                'view'          = @{ Handler = { param($context) Show-TaskDetails $context }; Description='View a task'; Category='View' }

                # Week/Month views
                'week'          = @{ Handler = { Show-WeekView }; Description='Week calendar view'; Category='View' }
                'month'         = @{ Handler = { Show-MonthView }; Description='Month calendar view'; Category='View' }
                # Timer synonyms
                'timer start'   = @{ Handler = { param($context) Start-Timer $context }; Description='Start time tracking'; Category='Time' }
                'timer stop'    = @{ Handler = { Stop-Timer }; Description='Stop current timer'; Category='Time' }
                'timer status'  = @{ Handler = { Show-TimerStatus }; Description='Show running timer'; Category='Time' }

                # Time synonyms
                'time list'     = @{ Handler = { param($context) Show-TimeLogList $context }; Description='List time entries'; Category='Time' }
                'time edit'     = @{ Handler = { param($context) Edit-TimeLog $context }; Description='Edit a time entry'; Category='Time' }
                'time delete'   = @{ Handler = { param($context) Delete-TimeLog $context }; Description='Delete a time entry'; Category='Time' }
                'time report'   = @{ Handler = { param($context) Show-TimeReportEnhanced $context }; Description='Enhanced time reports'; Category='Time' }
                'report detailed' = @{ Handler = { param($context) Show-DetailedReport $context }; Description='Detailed time breakdown'; Category='Time' }
                'report'        = @{ Handler = { param($context) Show-TimeReportEnhanced $context }; Description='Enhanced time report'; Category='Time' }
                'log'           = @{ Handler = { param($context) Log-StructuredEntry $context }; Description='Log time (structured)'; Category='Time' }

                # Excel
                'excel latest'  = @{ Handler = { Show-ExcelLatest }; Description='Show latest Excel import summary'; Category='Utility' }
                'excel view'    = @{ Handler = { param($context) Show-ExcelImportDetails $context }; Description='View Excel import details'; Category='Utility' }
                'excel view project' = @{ Handler = { param($context) Show-ExcelProjectFields $context }; Description='View Excel fields for a project'; Category='Utility' }
                'excel import'  = @{ Handler = { Import-ExcelT2020 }; Description='Run Excel T2020 batch'; Category='Utility' }

                # Templates & recurring (verb-first already exist; add reversed aliases)
                'template save' = @{ Handler = { param($context) Save-SmartTemplate $context }; Description='Save template'; Category='Template' }
                'template apply' = @{ Handler = { param($context) Apply-SmartTemplate $context }; Description='Apply template'; Category='Template' }
                'template list' = @{ Handler = { Show-Templates }; Description='List templates'; Category='Template' }
                'recurring add' = @{ Handler = { param($context) Add-RecurringTask $context }; Description='Add recurring task'; Category='Template' }
                'recurring list' = @{ Handler = { Show-RecurringTasks }; Description='Show recurring tasks'; Category='Template' }

                # Alias management (reversed forms)
                'alias'         = @{ Handler = { Show-Aliases }; Description='Show all user-defined aliases'; Category='Utility' }
                'alias add'     = @{ Handler = { param($context) Add-UserAlias $context }; Description='Add alias'; Category='Utility' }
                'alias remove'  = @{ Handler = { param($context) Remove-UserAlias $context }; Description='Remove alias'; Category='Utility' }

                # Project management (extras)
                'new project'   = @{ Handler = { param($context) Add-ProjectGuided ($context.GetText()).Trim() }; Description='Create project (guided)'; Category='Project' }
                'show project'  = @{ Handler = { param($context) Show-ProjectDetails $context }; Description='Show project details'; Category='Project' }
                'proj'          = @{ Handler = { Show-ProjectDashboard }; Description='Project dashboard'; Category='Project' }
                'project'       = @{ Handler = { Show-ProjectDashboard }; Description='Project dashboard'; Category='Project' }
                'proj add'      = @{ Handler = { param($context) Add-Project @{ Name = ($context.GetText()).Trim(); Fields=@{} } }; Description='Create new project'; Category='Project' }
                'project add'   = @{ Handler = { param($context) Add-Project @{ Name = ($context.GetText()).Trim(); Fields=@{} } }; Description='Create new project'; Category='Project' }
                'proj rename'   = @{ Handler = { param($context) Rename-Project $context }; Description='Rename project'; Category='Project' }
                'project rename'= @{ Handler = { param($context) Rename-Project $context }; Description='Rename project'; Category='Project' }
                'proj archive'  = @{ Handler = { param($context) Archive-Project $context }; Description='Archive project'; Category='Project' }
                'project archive'= @{ Handler = { param($context) Archive-Project $context }; Description='Archive project'; Category='Project' }
                'proj delete'   = @{ Handler = { param($context) Delete-Project $context }; Description='Delete project'; Category='Project' }
                'project delete'= @{ Handler = { param($context) Delete-Project $context }; Description='Delete project'; Category='Project' }
                'proj list'     = @{ Handler = { Show-ProjectDashboard }; Description='List projects with stats'; Category='Project' }
                'project list'  = @{ Handler = { Show-ProjectDashboard }; Description='List projects with stats'; Category='Project' }
                'proj stats'    = @{ Handler = { param($context) Show-ProjectStats $context }; Description='Project statistics'; Category='Project' }
                'project stats' = @{ Handler = { param($context) Show-ProjectStats $context }; Description='Project statistics'; Category='Project' }
                'proj fields'   = @{ Handler = { param($context) Show-ExcelProjectFields $context }; Description='Project Excel fields'; Category='Project' }
                'project fields'= @{ Handler = { param($context) Show-ExcelProjectFields $context }; Description='Project Excel fields'; Category='Project' }
                'proj info'     = @{ Handler = { param($context) Show-ProjectDetails $context }; Description='Project details'; Category='Project' }
                'project info'  = @{ Handler = { param($context) Show-ProjectDetails $context }; Description='Project details'; Category='Project' }
                'proj recent'   = @{ Handler = { Show-RecentProjects }; Description='Recent projects'; Category='Project' }
                'project recent'= @{ Handler = { Show-RecentProjects }; Description='Recent projects'; Category='Project' }
                'proj view'     = @{ Handler = { param($context) Show-ProjectDetails $context }; Description='Project details'; Category='Project' }
                'project view'  = @{ Handler = { param($context) Show-ProjectDetails $context }; Description='Project details'; Category='Project' }
                'proj new'      = @{ Handler = { param($context) Add-ProjectGuided ($context.GetText()).Trim() }; Description='Create project (guided)'; Category='Project' }
                'project new'   = @{ Handler = { param($context) Add-ProjectGuided ($context.GetText()).Trim() }; Description='Create project (guided)'; Category='Project' }
                'proj set'      = @{ Handler = { param($context) Set-ProjectFields $context }; Description='Set project fields'; Category='Project' }
                'project set'   = @{ Handler = { param($context) Set-ProjectFields $context }; Description='Set project fields'; Category='Project' }

                # Config & prefs (grouped)
                'config'        = @{ Handler = { Show-Config }; Description='Show current configuration'; Category='Utility' }
                'config edit'   = @{ Handler = { param($context) Show-ConfigEditor $context }; Description='Interactive config editor'; Category='Utility' }
                'config set'    = @{ Handler = { param($context) Set-ConfigFromCommand $context }; Description='Set a config value'; Category='Utility' }
                'config icons ascii' = @{ Handler = { Set-ConfigValue -Path 'Display.UseAsciiIcons' -Value $true; [ConfigManager]::Save(); Show-Config }; Description='Use ASCII icons'; Category='Utility' }
                'config icons emoji' = @{ Handler = { Set-ConfigValue -Path 'Display.UseAsciiIcons' -Value $false; [ConfigManager]::Save(); Show-Config }; Description='Use emoji icons'; Category='Utility' }
                'prefs'         = @{ Handler = { Edit-Configuration }; Description='Edit legacy preferences'; Category='Utility' }
                'help all'      = @{ Handler = { Show-AllCommands }; Description='List all available commands'; Category='Utility' }

                # Context & focus
                'focus'         = @{ Handler = { param($context) Set-SmartFocus $context }; Description='Set project context'; Category='Context' }
                'unfocus'       = @{ Handler = { Clear-Focus }; Description='Clear context'; Category='Context' }
                'context'       = @{ Handler = { Show-ContextInfo }; Description='Show current context'; Category='Context' }

                # Import/Export single-word forms
                'export'        = @{ Handler = { param($context) Export-Tasks $context }; Description='Export tasks'; Category='Utility' }
                'import'        = @{ Handler = { param($context) Import-Tasks $context }; Description='Import tasks'; Category='Utility' }

                # Dependency reversed forms
                'dep add'       = @{ Handler = { param($context) Add-SmartDependency $context }; Description='Add task dependency'; Category='Dependency' }
                'dep remove'    = @{ Handler = { param($context) Remove-SmartDependency $context }; Description='Remove dependency'; Category='Dependency' }
                'dep show'      = @{ Handler = { param($context) Show-Dependencies $context }; Description='Show task dependencies'; Category='Dependency' }
                'dep graph'     = @{ Handler = { Show-DependencyGraph }; Description='Visual dependency graph'; Category='Dependency' }
            }

            foreach ($k in $aliasMap.Keys) {
                if (-not $this.Commands.ContainsKey($k)) { $this.Commands[$k] = $aliasMap[$k] }
            }
        } catch { Write-DebugLog ("AddCommandAliases error: " + $_) }
    }

    [void] InitializeAliases() {
        try {
            if ($global:Config -and $global:Config.aliases -and $global:Config.aliases -is [hashtable]) {
                foreach ($alias in $global:Config.aliases.Keys) {
                    $expansion = $global:Config.aliases[$alias]
                    if ($alias -and $expansion) { $this.Aliases[$alias] = $expansion }
                }
            }
        } catch {}
    }

    [void] BuildCommandSchemas() {
        try {
            foreach ($verb in $this.CommandMap.Keys) {
                foreach ($object in $this.CommandMap[$verb].Keys) {
                    $fn = $this.CommandMap[$verb][$object]
                    $fullKey = if ($object -eq '') { $verb } else { "$verb $object" }
                    if ($this.ParameterMap.ContainsKey($fn)) {
                        $this.EnsureCommandSchema($fullKey, $fn)
                        continue
                    }
                    # Basic templates for common handlers not in ParameterMap
                    $schema = [CommandSchema]::new()
                    $schema.CommandName = $fullKey
                    $schema.Description = $fullKey
                    $args = @()
                    switch ($fn) {
                        'Complete-Quick' {
                            $a = [ArgumentSchema]::new(); $a.Name='Id'; $a.Type='TaskID'; $a.Pattern='^\d+([,-]\d+)*$'; $a.Required=$true; $args += $a
                        }
                        'Add-TaskNote' {
                            $a = [ArgumentSchema]::new(); $a.Name='Id'; $a.Type='TaskID'; $a.Pattern='^\d+$'; $a.Required=$true; $args += $a
                            $b = [ArgumentSchema]::new(); $b.Name='Text'; $b.Type='FreeText'; $b.Required=$true; $args += $b
                        }
                        'Show-TaskDetails' {
                            $a = [ArgumentSchema]::new(); $a.Name='Id'; $a.Type='TaskID'; $a.Pattern='^\d+$'; $a.Required=$true; $args += $a
                        }
                        'Edit-TimeLog' {
                            $a = [ArgumentSchema]::new(); $a.Name='Id'; $a.Type='LogID'; $a.Pattern='^\d+$'; $a.Required=$true; $args += $a
                        }
                        'Delete-TimeLog' {
                            $a = [ArgumentSchema]::new(); $a.Name='Id'; $a.Type='LogID'; $a.Pattern='^\d+$'; $a.Required=$true; $args += $a
                        }
                        'Start-Timer' {
                            $a = [ArgumentSchema]::new(); $a.Name='Project'; $a.Type='ProjectName'; $a.Prefix='@'; $args += $a
                            $b = [ArgumentSchema]::new(); $b.Name='Text'; $b.Type='FreeText'; $args += $b
                        }
                        'Stop-Timer' { }
                        'Show-TimerStatus' { }
                        'Show-Dependencies' {
                            $a = [ArgumentSchema]::new(); $a.Name='Id'; $a.Type='TaskID'; $a.Pattern='^\d+$'; $args += $a
                        }
                        'Show-DependencyGraph' {
                            $a = [ArgumentSchema]::new(); $a.Name='Project'; $a.Type='ProjectName'; $a.Prefix='@'; $args += $a
                        }
                        'Add-SmartDependency' {
                            $a = [ArgumentSchema]::new(); $a.Name='Dependency'; $a.Type='Dependency'; $a.Prefix='dep:'; $a.Required=$true; $args += $a
                        }
                        'Remove-SmartDependency' {
                            $a = [ArgumentSchema]::new(); $a.Name='Dependency'; $a.Type='Dependency'; $a.Prefix='dep:'; $a.Required=$true; $args += $a
                        }
                        'Show-ProjectDashboard' { }
                        'Show-AllTasks' { }
                        'Show-TimeLogList' { }
                        'Show-Templates' { }
                        'Show-RecurringTasks' { }
                        'Show-FilteredTasks' {
                            if ($verb -eq 'search') {
                                $a = [ArgumentSchema]::new(); $a.Name='Query'; $a.Type='FreeText'; $a.Required=$true; $args += $a
                            } elseif ($verb -eq 'priority') {
                                $a = [ArgumentSchema]::new(); $a.Name='Priority'; $a.Type='Priority'; $a.ValidValues=@('p1','p2','p3'); $a.Required=$true; $args += $a
                            }
                        }
                        'Apply-SmartTemplate' {
                            $a = [ArgumentSchema]::new(); $a.Name='Name'; $a.Type='FreeText'; $a.Required=$true; $args += $a
                            $b = [ArgumentSchema]::new(); $b.Name='Project'; $b.Type='ProjectName'; $b.Prefix='@'; $args += $b
                        }
                        'Save-SmartTemplate' {
                            $a = [ArgumentSchema]::new(); $a.Name='Name'; $a.Type='FreeText'; $a.Required=$true; $args += $a
                        }
                        'Import-Tasks' {
                            $a = [ArgumentSchema]::new(); $a.Name='File'; $a.Type='FreeText'; $a.Required=$true; $args += $a
                        }
                        'Import-ExcelT2020' { }
                        'Export-Tasks' {
                            $a = [ArgumentSchema]::new(); $a.Name='Out'; $a.Type='OutPath'; $a.Prefix='out:'; $args += $a
                        }
                        'Set-ConfigFromCommand' {
                            $k = [ArgumentSchema]::new(); $k.Name='Key'; $k.Type='ConfigKey'; $k.Required=$true; $args += $k
                            $v = [ArgumentSchema]::new(); $v.Name='Value'; $v.Type='FreeText'; $args += $v
                        }
                        'Set-ProjectFields' {
                            $p = [ArgumentSchema]::new(); $p.Name='Project'; $p.Type='ProjectName'; $p.Prefix='@'; $p.Required=$true; $args += $p
                            $k = [ArgumentSchema]::new(); $k.Name='KeyValues'; $k.Type='FreeText'; $k.Required=$true; $args += $k
                        }
                        'Show-Config' { }
                        'Show-Aliases' { }
                        'Show-AllCommands' { }
                        'Show-ExcelImportDetails' { }
                        'Show-NextActions' { }
                        'Start-WeeklyReview' { }
                        'Show-ProductivityStats' { }
                        'Show-BurndownChart' { }
                        'Show-VelocityChart' { }
                        'Undo-LastAction' { }
                        'Redo-Action' { }
                        'Backup-Data' { }
                        'Clean-CompletedTasks' { }
                        'Show-SmartHelp' { }
                        'Exit-SmartTUI' { }
                        'Add-Project' {
                            $a = [ArgumentSchema]::new(); $a.Name='Name'; $a.Type='FreeText'; $a.Required=$true; $args += $a
                        }
                        'Rename-Project' {
                            $a = [ArgumentSchema]::new(); $a.Name='Project'; $a.Type='ProjectName'; $a.Prefix='@'; $a.Required=$true; $args += $a
                            $b = [ArgumentSchema]::new(); $b.Name='NewName'; $b.Type='FreeText'; $b.Required=$true; $args += $b
                        }
                        'Archive-Project' {
                            $a = [ArgumentSchema]::new(); $a.Name='Project'; $a.Type='ProjectName'; $a.Prefix='@'; $a.Required=$true; $args += $a
                        }
                        'Delete-Project' {
                            $a = [ArgumentSchema]::new(); $a.Name='Project'; $a.Type='ProjectName'; $a.Prefix='@'; $a.Required=$true; $args += $a
                        }
                        'Show-ProjectDetails' {
                            $a = [ArgumentSchema]::new(); $a.Name='Project'; $a.Type='ProjectName'; $a.Prefix='@'; $args += $a
                        }
                        'Show-TimeReportEnhanced' {
                            $r = [ArgumentSchema]::new(); $r.Name='Range'; $r.Type='Range'; $r.ValidValues=@('today','yesterday','week','next week','last week','month','last month'); $args += $r
                            $f1 = [ArgumentSchema]::new(); $f1.Name='Out'; $f1.Type='OutPath'; $f1.Prefix='out:'; $args += $f1
                            $f2 = [ArgumentSchema]::new(); $f2.Name='ById2'; $f2.Type='Flag'; $f2.Prefix='byid2:'; $args += $f2
                            $f3 = [ArgumentSchema]::new(); $f3.Name='WithIds'; $f3.Type='Flag'; $f3.ValidValues=@('--withids'); $args += $f3
                            $f4 = [ArgumentSchema]::new(); $f4.Name='ExportCsv'; $f4.Type='Flag'; $f4.ValidValues=@('--exportcsv'); $args += $f4
                            $p = [ArgumentSchema]::new(); $p.Name='Project'; $p.Type='ProjectName'; $p.Prefix='@'; $args += $p
                        }
                        'Set-ConfigFromCommand' {
                            $k = [ArgumentSchema]::new(); $k.Name='Key'; $k.Type='ConfigKey'; $k.Required=$true; $args += $k
                            $v = [ArgumentSchema]::new(); $v.Name='Value'; $v.Type='FreeText'; $args += $v
                        }
                        'Add-UserAlias' {
                            $k = [ArgumentSchema]::new(); $k.Name='Shortcut'; $k.Type='FreeText'; $k.Required=$true; $args += $k
                            $v = [ArgumentSchema]::new(); $v.Name='Expansion'; $v.Type='FreeText'; $v.Required=$true; $args += $v
                        }
                        'Remove-UserAlias' {
                            $k = [ArgumentSchema]::new(); $k.Name='Shortcut'; $k.Type='FreeText'; $k.Required=$true; $args += $k
                        }
                        default {
                            # Unknown: skip building to avoid wrong hints
                        }
                    }
                    if ($args.Count -gt 0) {
                        $schema.Arguments = $args
                        $this.CommandSchemas[$fullKey] = $schema
                    }
                }
            }
        } catch { Write-DebugLog ("BuildCommandSchemas error: " + $_) }
    }

    [array] TokenizeInput([string] $input) { if ([string]::IsNullOrWhiteSpace($input)) { return @() }; return $input.Trim() -split '\s+' | Where-Object { $_ } }
    [bool] IsParameter([string] $token) { return $token.StartsWith('@') -or $token.StartsWith('#') -or $token.StartsWith('p') -or $token.StartsWith('due:') }

    [hashtable] ParseParametersForFunction([string] $functionName, [array] $tokens) {
        # Normalize tokens to an array to avoid null/Count issues
        $tokens = @($tokens)
        $params = @{}; $freeText = @(); $posTokens = @()
        if (-not $this.ParameterMap.ContainsKey($functionName)) { if (@($tokens).Count -gt 0) { $params['Text'] = ($tokens -join ' ') }; return $params }
        $schema = $this.ParameterMap[$functionName]
        foreach ($token in $tokens) {
            $matched = $false
            foreach ($paramDef in $schema) {
                $prefix = [string]$paramDef['Prefix']
                if ($prefix -and $token.StartsWith($prefix)) {
                    $value = $token.Substring($prefix.Length)
                    if ($paramDef.ContainsKey('Pattern') -and -not [regex]::IsMatch($token, $paramDef['Pattern'])) { continue }
                    $name = $paramDef['Name']
                    if ($paramDef.ContainsKey('AllowsMultiple') -and $paramDef['AllowsMultiple']) { if (-not $params.ContainsKey($name)) { $params[$name] = @() }; if ($value) { $params[$name] += $value } }
                    else { if ($paramDef['Type'] -eq 'Priority' -and $prefix -eq 'p') { $params[$name] = $token } else { $params[$name] = $value } }
                    $matched = $true; break
                }
            }
            if (-not $matched) {
                $posTokens += $token
            }
        }
        # Assign positional args (defs with empty Prefix, excluding FreeText), in order
        $posDefs = @($schema | Where-Object { -not $_['Prefix'] -or $_['Prefix'] -eq '' } | Where-Object { $_['Type'] -ne 'FreeText' })
        $remaining = @($posTokens)
        foreach ($def in $posDefs) {
            $name = $def['Name']; $pat = $def['Pattern']
            for ($i=0; $i -lt $remaining.Count; $i++) {
                $tok = $remaining[$i]
                if ($pat) {
                    if (-not [regex]::IsMatch($tok, $pat)) { continue }
                }
                # Assign and remove consumed token
                $params[$name] = $tok
                $newRem = @()
                for ($j=0; $j -lt $remaining.Count; $j++) { if ($j -ne $i) { $newRem += $remaining[$j] } }
                $remaining = $newRem
                break
            }
        }
        # Whatever remains becomes free text
        $freeText = @($remaining)
        $freeDef = $null; foreach ($def in $schema) { if ($def['Type'] -eq 'FreeText') { $freeDef = $def; break } }
        if ($freeText.Count -gt 0 -and $freeDef) { $params[$freeDef['Name']] = ($freeText -join ' ') }
        return $params
    }

    [hashtable] TranslateCommand([string] $input) {
        if ([string]::IsNullOrWhiteSpace($input)) { return @{ Success=$false; Error='Empty command' } }
        $tokens = $this.TokenizeInput($input); if ($tokens.Count -eq 0) { return @{ Success=$false; Error='No tokens' } }
        $verb = $tokens[0].ToLower(); $object=''; $consumed=1
        if (-not $this.CommandMap.ContainsKey($verb)) { return @{ Success=$false; Error="Unknown command '$verb'" } }
        $verbMap = $this.CommandMap[$verb]
        if ($tokens.Count -gt 1 -and -not $this.IsParameter($tokens[1])) {
            $cand = $tokens[1].ToLower();
            if ($verbMap.ContainsKey($cand)) { $object=$cand; $consumed=2 }
        }
        # Heuristic: default object for task-centric verbs if second token looks like args
        if (-not $object -and $verbMap.ContainsKey('task') -and ($verb -in @('add','move','postpone','update','delete','duplicate','note','done'))) {
            if ($tokens.Count -gt 1) {
                $tok1 = $tokens[1]
                if ($this.IsParameter($tok1) -or $tok1 -match '^\d+$') { $object='task' }
            } else { $object='task' }
        }
        $fn = if ($verbMap.ContainsKey($object)) { $verbMap[$object] } elseif ($verbMap.ContainsKey('')) { $verbMap[''] } else { $null }
        if (-not $fn) { return @{ Success=$false; Error="Unknown object '$object' for verb '$verb'" } }
        $paramTokens = @($tokens | Select-Object -Skip $consumed)
        $parameters = $this.ParseParametersForFunction($fn, $paramTokens)
        try { Write-DebugLog ("TRANSLATE: input='" + $input + "' verb='" + $verb + "' object='" + $object + "' fn='" + $fn + "'") } catch {}
        return @{ Success=$true; Function=$fn; Parameters=$parameters; Verb=$verb; Object=$object; OriginalInput=$input }
    }

    [void] ExecuteTranslatedCommand([hashtable] $translation) {
        if (-not $translation.Success) { Write-Host "Error: $($translation.Error)" -ForegroundColor Red; return }
        try {
            $fn = $translation.Function
            $state = $this.CreateCompletionState($translation)
            $context = [CommandContext]::new($state)
            try { Write-DebugLog ("EXEC: function='" + $fn + "' verb='" + $translation.Verb + "' object='" + $translation.Object + "'") } catch {}
            # Merge structured parameters from translation into context.Args (lowercase keys)
            try {
                if ($translation.Parameters) {
                    foreach ($k in $translation.Parameters.Keys) {
                        $lk = $k.ToString().ToLower()
                        $context.Args[$lk] = $translation.Parameters[$k]
                    }
                }
            } catch {}
            $funcItem = Get-Item ("Function:" + $fn) -ErrorAction SilentlyContinue
            if ($funcItem) {
                & $funcItem.ScriptBlock $context
            } else {
                $cmd = Get-Command -Name $fn -ErrorAction SilentlyContinue
                if ($cmd -and $cmd.CommandType -eq 'Function') { & $fn $context }
                else { throw "Handler not found: $fn" }
            }
        } catch { Write-Host "Execution error: $_" -ForegroundColor Red }
    }

    [void] ExecuteStructured([string]$commandText) {
        $translation = $this.TranslateCommand($commandText)
        if (-not $translation.Success) { Write-Host "Error: $($translation.Error)" -ForegroundColor Red; return }
        $state = $this.CreateCompletionState($translation)
        $context = [CommandContext]::new($state)
        # Merge structured parameters from translation into context.Args
        try {
            if ($translation.Parameters) {
                foreach ($k in $translation.Parameters.Keys) {
                    $lk = $k.ToString().ToLower()
                    $context.Args[$lk] = $translation.Parameters[$k]
                }
            }
        } catch {}
        # Heuristic: derive id for 'done' when missing
        try {
            if ($translation.Verb -eq 'done') {
                $hasId = $false; try { $hasId = [bool]$context.Args.ContainsKey('id') -and $context.Args['id'] } catch {}
                if (-not $hasId) {
                    $parts = @($commandText.Trim() -split '\s+')
                    if ($parts.Count -ge 2) {
                        $i = 1; if ($parts.Count -ge 3 -and $parts[1].ToLower() -eq 'task') { $i = 2 }
                        $context.Args['id'] = $parts[$i]
                    }
                }
            }
        } catch {}
        # Direct execution path for 'done' when id resolved
        try {
            if ($translation.Verb -eq 'done') {
                $idArg = $null; try { $idArg = $context.Args['id'] } catch {}
                if ($idArg) { Complete-Tasks -idString $idArg; return }
            }
        } catch {}
        # Prefer prebuilt Commands map if available
        $key = if ($translation.Object) { "$($translation.Verb) $($translation.Object)" } else { $translation.Verb }
        if ($this.Commands -and $this.Commands.ContainsKey($key)) {
            $cmd = $this.Commands[$key]
            try { & $cmd.Handler $context } catch { Write-Host "Execution error: $_" -ForegroundColor Red }
            return
        }
        $this.ExecuteTranslatedCommand($translation)
    }

    [array] GetCompletions([string] $buffer, [int] $cursor = -1) {
        try {
            $tokens = $this.TokenizeInput($buffer)
            if ($tokens.Count -eq 0) { return @($this.Commands.Keys | Sort-Object) }
            if ($tokens.Count -eq 1) {
                $p=$tokens[0]
                $strict = @($this.Commands.Keys | Where-Object { $_.StartsWith($p,[System.StringComparison]::OrdinalIgnoreCase) } | Sort-Object)
                if ($strict.Count -ge 1) { return $strict }
                # Fuzzy fallback
                $cands = @($this.Commands.Keys)
                $best = $this.GetTopFuzzyMatches($p, $cands, 60, 8)
                if ($best.Count -gt 0) { return $best }
                return $strict
            }
            $verb = $tokens[0].ToLower()
            $endsWithSpace = $buffer -and $buffer.EndsWith(' ')
            # Subcommand/object completion for verb-object commands (e.g., 'list <obj>')
            if ($this.CommandMap.ContainsKey($verb)) {
                if ($tokens.Count -eq 2 -and -not $this.IsParameter($tokens[1]) -and -not $endsWithSpace) {
                    $p=$tokens[1]
                    $objs = @($this.CommandMap[$verb].Keys | Where-Object { $_ -ne '' })
                    $strict = @($objs | Where-Object { $_.StartsWith($p,[System.StringComparison]::OrdinalIgnoreCase) } | Sort-Object)
                    if ($strict.Count -ge 1) { return $strict }
                    $best = $this.GetTopFuzzyMatches($p, $objs, 60, 8)
                    if ($best.Count -gt 0) { return $best }
                    return $strict
                } elseif ($tokens.Count -eq 1 -and $endsWithSpace) {
                    # First Tab after verb with trailing space -> list objects under verb
                    return @($this.CommandMap[$verb].Keys | Where-Object { $_ -ne '' } | Sort-Object)
                } elseif ($tokens.Count -eq 2 -and -not $this.IsParameter($tokens[1]) -and $endsWithSpace -and [string]::IsNullOrWhiteSpace($tokens[1])) {
                    # Explicit empty second token -> list objects as well
                    return @($this.CommandMap[$verb].Keys | Where-Object { $_ -ne '' } | Sort-Object)
                }
            }
            if ($endsWithSpace) { $tokens = @($tokens + @('')) }
            # Special-case: time report/report time parameter hints
            if ($tokens.Count -ge 2) {
                $v = $tokens[0].ToLower(); $o = $tokens[1].ToLower()
                if ( ($v -eq 'report' -and ($o -eq '' -or $o -eq 'time')) -or ($v -eq 'time' -and ($o -eq '' -or $o -eq 'report')) ) {
                    return @($this.GetTimeReportSuggestions( ($tokens.Count -gt 0) ? $tokens[-1] : '' ))
                }
            }
            # Parameter completions with fuzzy fallback
            $all = @($this.GetParameterCompletions($tokens))
            if ($all.Count -le 0) { return $all }
            $curr = if ($tokens.Count -gt 0) { $tokens[-1] } else { '' }
            if (-not [string]::IsNullOrWhiteSpace($curr)) {
                $strict = @($all | Where-Object { $_.StartsWith($curr,[System.StringComparison]::OrdinalIgnoreCase) })
                if ($strict.Count -ge 1) { return @($strict | Select-Object -Unique) }
                $best = $this.GetTopFuzzyMatches($curr, $all, 60, 12)
                if ($best.Count -gt 0) { return @($best | Select-Object -Unique) }
            }
            return @($all | Select-Object -Unique)
        } catch { return @() }
    }

    [array] GetTopFuzzyMatches([string] $query, [string[]] $candidates, [int] $minScore = 60, [int] $max = 8) {
        $scored = @()
        foreach ($c in $candidates) {
            $s = Get-FuzzyMatchScore -query $query -candidate $c
            if ($s -ge $minScore) { $scored += [pscustomobject]@{ Item=$c; Score=$s } }
        }
        $ordered = $scored | Sort-Object -Property @{Expression='Score';Descending=$true}, @{Expression='Item';Descending=$false}
        $take = @()
        $i=0
        foreach ($o in $ordered) { if ($i -ge $max) { break }; $take += $o.Item; $i++ }
        if ($take.Count -gt 0) { return $take }
        # Very loose fallback: same first letter
        if (-not [string]::IsNullOrEmpty($query)) {
            $first = $query.Substring(0,1)
            $alt = @($candidates | Where-Object { $_ -like ("$first*") }) | Select-Object -First $max
            if ($alt.Count -gt 0) { return $alt }
        }
        return @()
    }

    [array] GetParameterCompletions([array] $tokens) {
        $verb = $tokens[0].ToLower(); $object=''
        if ($tokens.Count -gt 1 -and -not $this.IsParameter($tokens[1])) { $object = $tokens[1].ToLower() }
        if (-not $this.CommandMap.ContainsKey($verb)) { 
            # Heuristic: support 'time report' and 'report time' even if maps change
            if ( ($verb -eq 'report' -and ($object -eq '' -or $object -eq 'time')) -or ($verb -eq 'time' -and ($object -eq '' -or $object -eq 'report')) ) {
                $range = @('today','yesterday','week','next week','last week','month','last month')
                $flags = @('--withids','--exportcsv','out:','byid2:')
                $suggest = @($range + $flags)
                $today = Get-Date; $suggest += @($today.ToString('yyyy-MM-dd'))
                $suggest += (@('due:today','due:tomorrow'))
                try { $suggest += $this.GetProjectCompletions() } catch {}
                $curr = if ($tokens.Count -gt 0) { $tokens[-1] } else { '' }
                if ($curr) { return @($suggest | Select-Object -Unique | Where-Object { $_.StartsWith($curr,[System.StringComparison]::OrdinalIgnoreCase) }) }
                return @($suggest | Select-Object -Unique)
            }
            return @() 
        }
        $verbMap = $this.CommandMap[$verb]; $fn = $null
        if ($verbMap.ContainsKey($object)) { $fn = $verbMap[$object] } elseif ($verbMap.ContainsKey('')) { $fn = $verbMap[''] }
        # Special-case: functions that want free-text ranges or config paths
        if ($fn -eq 'Show-TimeReportEnhanced') {
            $range = @('today','yesterday','week','next week','last week','month','last month')
            $flags = @('--withids','--exportcsv','out:','byid2:')
            $suggest = @($range + $flags)
            $today = Get-Date; $suggest += @($today.ToString('yyyy-MM-dd'))
            # include projects and due for convenience
            $suggest += ($this.GetProjectCompletions() + @('due:today','due:tomorrow'))
            $curr = $tokens[-1]
            if ($curr) { return @($suggest | Select-Object -Unique | Where-Object { $_.StartsWith($curr,[System.StringComparison]::OrdinalIgnoreCase) }) }
            return @($suggest | Select-Object -Unique)
        }
        if ($fn -eq 'Log-StructuredEntry') {
            $suggest = @()
            $suggest += $this.GetProjectCompletions()
            # ID1 code and date/hour helpers
            $suggest += @('#ID1','today','tomorrow','1h','0.5h','30m')
            $today = Get-Date; $suggest += @($today.ToString('yyyy-MM-dd'))
            $curr = $tokens[-1]
            if ($curr) { return @($suggest | Select-Object -Unique | Where-Object { $_.StartsWith($curr,[System.StringComparison]::OrdinalIgnoreCase) }) }
            return @($suggest | Select-Object -Unique)
        }
        if ($fn -eq 'Set-ConfigFromCommand') {
            $opts = @()
            try { $opts = (Get-ConfigOptions) | ForEach-Object { $_.Path } } catch {}
            if (-not $opts -or $opts.Count -eq 0) { $opts = @('Display.UseAsciiIcons','Display.CompactMode','Behavior.ShowGhostNext') }
            if ($tokens[-1]) { return $opts | Where-Object { $_.StartsWith($tokens[-1],[System.StringComparison]::OrdinalIgnoreCase) } }
            return $opts
        }
        if ($fn -eq 'Set-ProjectFields') {
            $curr = if ($tokens.Count -gt 0) { $tokens[-1] } else { '' }
            # If we are at the project position, suggest @projects
            if ($tokens.Count -le 3 -or ($curr -like '@*')) {
                return $this.GetProjectCompletions($curr)
            }
            # Suggest known field keys
            $keys = @('ID1=','ID2=','ProjFolder=','AssignedDate=','DueDate=','BFDate=','CAAName=','RequestName=','T2020=')
            if ($curr) { return @($keys | Where-Object { $_.StartsWith($curr,[System.StringComparison]::OrdinalIgnoreCase) }) }
            return $keys
        }
        if ($fn -in @('Add-UserAlias','Remove-UserAlias')) {
            $curr = if ($tokens.Count -gt 0) { $tokens[-1] } else { '' }
            if ($fn -eq 'Add-UserAlias') {
                $samples = @('aw','ap','rt')
                if ($curr) { return @($samples | Where-Object { $_.StartsWith($curr,[System.StringComparison]::OrdinalIgnoreCase) }) }
                return $samples
            } else {
                try {
                    $listAliases = @()
                    if ($global:Config -and $global:Config.aliases) { $listAliases = $global:Config.aliases.Keys }
                    if ($curr) { return @($listAliases | Where-Object { $_.StartsWith($curr,[System.StringComparison]::OrdinalIgnoreCase) }) }
                    return @($listAliases)
                } catch { return @() }
            }
        }
        if ($fn -in @('Rename-Project','Archive-Project','Delete-Project','Show-ProjectDetails','Set-SmartFocus')) {
            $curr = if ($tokens.Count -gt 0) { $tokens[-1] } else { '' }
            return $this.GetProjectCompletions($curr)
        }
        if ($fn -in @('Add-SmartDependency','Remove-SmartDependency','Show-Dependencies')) {
            $curr = if ($tokens.Count -gt 0) { $tokens[-1] } else { '' }
            $ids = $this.GetIdCompletions($false)
            if ($curr) { $ids = @($ids | Where-Object { $_.StartsWith($curr,[System.StringComparison]::OrdinalIgnoreCase) }) }
            return $ids
        }
        if (-not $fn -or -not $this.ParameterMap.ContainsKey($fn)) { return @() }

        # Determine current token for prefix filtering
        $current = ''
        if ($tokens.Count -gt 0) { $current = $tokens[-1] }

        $schema = $this.ParameterMap[$fn]
        $completions = @()

        foreach ($def in $schema) {
            $pfx = [string]$def['Prefix']
            if ([string]::IsNullOrEmpty($pfx)) { continue }

            switch ($def['Type']) {
                'ProjectName' {
                    if ([string]::IsNullOrEmpty($current) -or $current.StartsWith('@')) {
                        $completions += $this.GetProjectCompletions($current)
                    } else {
                        $completions += '@'
                    }
                }
                'Priority' {
                    $pri = @('p1','p2','p3')
                    if ([string]::IsNullOrEmpty($current) -or $current.StartsWith('p')) { $completions += $pri } else { $completions += 'p1' }
                }
                'DateString' {
                    $dueList = $this.GetDueCompletions()
                    if ([string]::IsNullOrEmpty($current) -or $current.StartsWith('due:')) { $completions += $dueList } else { $completions += 'due:' }
                }
                'TagName' {
                    if ([string]::IsNullOrEmpty($current) -or $current.StartsWith('#')) {
                        $completions += $this.GetTagCompletions($current)
                    } else {
                        $completions += '#'
                    }
                }
                'RemoveTagName' {
                    if ([string]::IsNullOrEmpty($current) -or $current.StartsWith('-#')) {
                        $tags = $this.GetTagCompletions(($current -replace '^-#','' )) | ForEach-Object { if ($_ -like '#*') { '-#' + $_.Substring(1) } else { $_ } }
                        $completions += $tags
                    } else { $completions += '-#' }
                }
                'Dependency' {
                    if ([string]::IsNullOrEmpty($current) -or $current.StartsWith('dep:')) { $completions += $this.GetIdCompletions($true) } else { $completions += 'dep:' }
                }
                'RecurPattern' {
                    $recur = @('recur:daily','recur:weekly','recur:weekdays','recur:monthly','recur:eow','recur:eom')
                    if ([string]::IsNullOrEmpty($current) -or $current.StartsWith('recur:')) { $completions += $recur } else { $completions += 'recur:' }
                }
                'Description' {
                    if ([string]::IsNullOrEmpty($current) -or $current.StartsWith('desc:')) { $completions += 'desc:' } else { $completions += 'desc:' }
                }
                default {
                    if (-not [string]::IsNullOrEmpty($pfx)) { $completions += $pfx }
                }
            }
        }
        # If schema expects an Id token (no prefix), offer numeric id suggestions
        $needsId = $false
        foreach ($def in $schema) { if ($def['Name'] -eq 'Id' -and -not $def['Prefix']) { $needsId = $true; break } }
        if ($needsId) {
            $idList = $this.GetIdCompletions($false)
            if ($current) { $idList = $idList | Where-Object { $_.StartsWith($current, [System.StringComparison]::OrdinalIgnoreCase) } }
            $completions += $idList
        }
        # Ensure basic priority tokens for common tasks
        if ($fn -eq 'Add-SmartTask' -or $fn -eq 'Update-SmartTask') { $completions += @('p1','p2','p3') }
        # Deduplicate and filter by current token
        $list = $completions | Select-Object -Unique
        if ($current) { $list = $list | Where-Object { $_.StartsWith($current, [System.StringComparison]::OrdinalIgnoreCase) } }
        return @($list | Sort-Object)
    }

    [array] GetProjectCompletions([string]$current='') {
        try {
            $data = Get-TaskData
            if ($data -and $data.projects) {
                $all = @($data.projects | Where-Object { -not $_.isArchived } | ForEach-Object { $_.name })
                $ordered = @()
                # Prioritize current context and last used
                if ($global:CurrentContext -and ($all -contains $global:CurrentContext)) { $ordered += $global:CurrentContext }
                if ($data.lastUsedProject -and ($all -contains $data.lastUsedProject) -and ($ordered -notcontains $data.lastUsedProject)) { $ordered += $data.lastUsedProject }
                # Append remaining alphabetical
                $remaining = @($all | Where-Object { $ordered -notcontains $_ } | Sort-Object)
                $ordered += $remaining
                $vals = $ordered | ForEach-Object { "@$_" }
                if ($current) { return @($vals | Where-Object { $_.StartsWith($current, [System.StringComparison]::OrdinalIgnoreCase) }) }
                return @($vals)
            }
        } catch {}
        return @('@work','@personal','@inbox')
    }

    [array] GetDueCompletions() {
        $today = Get-Date
        $iso = $today.ToString('yyyy-MM-dd')
        $next3 = @(
            'due:today',
            'due:tomorrow',
            'due:+1d',
            'due:+3d',
            ("due:{0}" -f $today.AddDays(1).ToString('yyyy-MM-dd')),
            ("due:{0}" -f $today.AddDays(7).ToString('yyyy-MM-dd'))
        )
        return $next3
    }

    [array] GetTagCompletions([string]$current='') {
        $tags = @()
        try {
            $data = Get-TaskData
            if ($data) {
                $freq = @{}
                if ($data.tasks) {
                    foreach ($t in $data.tasks) { if ($t -and $t.tags) { foreach ($tg in $t.tags) { if (-not $freq.ContainsKey($tg)) { $freq[$tg]=0 }; $freq[$tg]++ } } }
                }
                $all = @()
                if ($data.labels) { $all += @($data.labels) }
                $all += @($freq.Keys)
                $all = $all | Select-Object -Unique
                # Sort by frequency desc then name
                $sorted = $all | Sort-Object @{Expression={ if ($freq.ContainsKey($_)) { -$freq[$_] } else { 0 } }}, @{Expression={ $_ }}
                $tags = $sorted | ForEach-Object { "#$_" }
            }
        } catch {}
        if (-not $tags -or $tags.Count -eq 0) { $tags = @('#urgent','#waiting','#someday') }
        if ($current) { $tags = $tags | Where-Object { $_.StartsWith($current, [System.StringComparison]::OrdinalIgnoreCase) } }
        return @($tags)
    }

    [array] GetTimeReportSuggestions([string]$current) {
        $range = @('today','yesterday','week','next week','last week','month','last month')
        $flags = @('--withids','--exportcsv','out:','byid2:')
        $suggest = @($range + $flags)
        $today = Get-Date; $suggest += @($today.ToString('yyyy-MM-dd'))
        $suggest += (@('due:today','due:tomorrow'))
        try { $suggest += $this.GetProjectCompletions() } catch {}
        if ($current) { return @($suggest | Select-Object -Unique | Where-Object { $_.StartsWith($current,[System.StringComparison]::OrdinalIgnoreCase) }) }
        return @($suggest | Select-Object -Unique)
    }

    [array] GetIdCompletions([bool]$AsDependency=$false) {
        try {
            $data = Get-TaskData
            if ($data -and $data.tasks) {
                # Suggest the most recent 10 ids
                $ids = @($data.tasks | Where-Object { $_ } | Sort-Object id -Descending | Select-Object -First 10 | ForEach-Object { [string]$_.id })
                if ($AsDependency) { return $ids | ForEach-Object { 'dep:' + $_ } }
                return $ids
            }
        } catch {}
        if ($AsDependency) { return @('dep:1','dep:2','dep:3') }
        return @('1','2','3')
    }

    [object] CreateCompletionState([hashtable] $translation) {
        $state = [CompletionState]::new()
        $state.OriginalBuffer = $translation.OriginalInput
        $key = if ($translation.Object) { "$($translation.Verb) $($translation.Object)" } else { $translation.Verb }
        $state.FullCommandName = $key
        try {
            $tokens = $this.TokenizeInput($translation.OriginalInput)
            $consumed = if ($translation.Object) { 2 } else { 1 }
            $args = @(); if ($tokens.Count -gt $consumed) { $args = $tokens | Select-Object -Skip $consumed }
            $parsed = @(); foreach ($tok in $args) { $parsed += [ParsedToken]::new($tok, 0, $tok.Length) }
            $state.ArgumentTokens = $parsed
            $state.CompletedArguments = $args
        } catch {}
        return $state
    }

    [array] GetSmartCompletions([string] $buffer) {
        $list = @($this.GetCompletions($buffer, -1))
        if ($buffer -match '^(?i)\s*report\s+time\s*') {
            $list = @('@inbox','@work') + $list | Select-Object -Unique
        }
        $items = @()
        foreach ($cmd in $list) {
            $desc = ''
            $cat = ''
            try {
                if ($this.Commands -and $this.Commands.ContainsKey($cmd)) {
                    $meta = $this.Commands[$cmd]
                    if ($meta -and $meta.ContainsKey('Description')) { $desc = $meta['Description'] }
                    if ($meta -and $meta.ContainsKey('Category')) { $cat = $meta['Category'] }
                }
            } catch {}
            $items += [pscustomobject]@{ Command = $cmd; Description = $desc; Type = 'Command'; Category = $cat }
        }
        return $items
    }
    [array] GetSmartCompletions([string] $buffer, [int] $cursorPosition) {
        $list = @($this.GetCompletions($buffer, $cursorPosition))
        if ($buffer -match '^(?i)\s*report\s+time\s*') {
            $list = @('@inbox','@work') + $list | Select-Object -Unique
        }
        $items = @()
        foreach ($cmd in $list) {
            $desc = ''
            $cat = ''
            try {
                if ($this.Commands -and $this.Commands.ContainsKey($cmd)) {
                    $meta = $this.Commands[$cmd]
                    if ($meta -and $meta.ContainsKey('Description')) { $desc = $meta['Description'] }
                    if ($meta -and $meta.ContainsKey('Category')) { $cat = $meta['Category'] }
                }
            } catch {}
            $items += [pscustomobject]@{ Command = $cmd; Description = $desc; Type = 'Command'; Category = $cat }
        }
        return $items
    }

    [CompletionState] ParseCommandBuffer([string] $buffer, [int] $cursorPosition) { $t = $this.TranslateCommand($buffer); if (-not $t.Success) { return [CompletionState]::new() } else { return $this.CreateCompletionState($t) } }

    # Compatibility shim with hybrid parser API
    [CompletionState] ParseBufferToState([string] $buffer) {
        return $this.ParseBufferToState($buffer, $buffer.Length)
    }

    [CompletionState] ParseBufferToState([string] $buffer, [int] $cursorPosition) {
        # Start from existing translation/state
        $translation = $this.TranslateCommand($buffer)
        $state = if (-not $translation.Success) { [CompletionState]::new() } else { $this.CreateCompletionState($translation) }

        # Populate common fields expected by UI
        $state.OriginalBuffer = $buffer
        $state.CursorPosition = $cursorPosition
        try {
            if ($state.FullCommandName) {
                $state.CurrentCommand = ($state.FullCommandName -split '\s+')[0]
            } else {
                $toks = $this.TokenizeInput($buffer)
                if ($toks.Count -gt 0) { $state.CurrentCommand = $toks[0] }
            }
        } catch {}

        # Determine current token and completion mode
        $before = try {
            if ($cursorPosition -ge 0 -and $cursorPosition -le $buffer.Length) { $buffer.Substring(0, $cursorPosition) } else { $buffer }
        } catch { $buffer }

        $state.TokenComplete = $before.EndsWith(' ')
        $tokens = @()
        try { $tokens = $this.TokenizeInput($before) } catch {}
        $state.CurrentToken = if (-not $state.TokenComplete -and $tokens.Count -gt 0) { $tokens[-1] } else { '' }

        # Prefix-aware mode detection
        $mode = [CompletionMode]::Command
        try {
            if ($before -match '@(\w*)$') {
                $mode = [CompletionMode]::PrefixCompletion
                $state.PrefixBeingCompleted = '@' + $matches[1]
            } elseif ($before -match '(^|\s)p([123]?)$') {
                $mode = [CompletionMode]::PrefixCompletion
                $state.PrefixBeingCompleted = 'p' + $matches[2]
            } elseif ($before -match 'due:(\S*)$') {
                $mode = [CompletionMode]::PrefixCompletion
                $state.PrefixBeingCompleted = 'due:' + $matches[1]
            } elseif ($before -match '[#+](\w*)$') {
                $mode = [CompletionMode]::PrefixCompletion
                $state.PrefixBeingCompleted = $matches[0]
            } else {
                if ($tokens.Count -le 1) { $mode = [CompletionMode]::Command }
                elseif ($tokens.Count -eq 2 -and -not $this.IsParameter($tokens[1]) -and -not $before.EndsWith(' ')) { $mode = [CompletionMode]::Subcommand }
                else { $mode = [CompletionMode]::SyntaxDiscovery }
            }
        } catch {}
        $state.Mode = $mode

        # Cache current state for UI callers that try to read it
        try { $this.CurrentState = $state } catch {}
        return $state
    }

    # Tokenize with positions for cursor-aware features
    [array] TokenizeWithPositions([string] $input) {
        $result = @()
        if ([string]::IsNullOrWhiteSpace($input)) { return $result }
        $i = 0; $len = $input.Length
        while ($i -lt $len) {
            while ($i -lt $len -and [char]::IsWhiteSpace($input[$i])) { $i++ }
            if ($i -ge $len) { break }
            $start = $i
            while ($i -lt $len -and -not [char]::IsWhiteSpace($input[$i])) { $i++ }
            $end = $i
            $text = $input.Substring($start, $end - $start)
            $result += [pscustomobject]@{ Text=$text; StartPos=$start; EndPos=$end }
        }
        return $result
    }

    # Ensure a lightweight schema exists for a command key from ParameterMap
    [void] EnsureCommandSchema([string] $fullKey, [string] $fn) {
        try {
            if ($this.CommandSchemas.ContainsKey($fullKey)) { return }
            $schema = [CommandSchema]::new()
            $schema.CommandName = $fullKey
            $schema.Description = $fullKey
            $schema.Syntax = ''
            $args = @()
            if ($this.ParameterMap.ContainsKey($fn)) {
                foreach ($def in $this.ParameterMap[$fn]) {
                    $a = [ArgumentSchema]::new()
                    $a.Name = [string]$def['Name']
                    $a.Type = [string]$def['Type']
                    $a.Prefix = [string]$def['Prefix']
                    $a.Required = [bool]([bool]$def['Required'])
                    $a.Description = [string]$def['Description']
                    $args += $a
                }
            }
            $schema.Arguments = $args
            $this.CommandSchemas[$fullKey] = $schema
        } catch {}
    }

    [object] GetCommandSchema([string] $fullCommandName) {
        try {
            if ($this.CommandSchemas.ContainsKey($fullCommandName)) { return $this.CommandSchemas[$fullCommandName] }
            # Try to map to function via TranslateCommand
            $t = $this.TranslateCommand($fullCommandName)
            if ($t.Success -and $t.Function) {
                $this.EnsureCommandSchema($fullCommandName, $t.Function)
                if ($this.CommandSchemas.ContainsKey($fullCommandName)) { return $this.CommandSchemas[$fullCommandName] }
            }
        } catch {}
        return $null
    }
}

class SmartInputHandler {
    [SmartCommandParser] $Parser
    [string] $Buffer = ""
    [int] $CursorPos = 0
    [int] $InputRow = -1
    [array] $Completions = @()
    [array] $CompletionDetails = @()
    [int] $CompletionIndex = -1
    [bool] $InCompletion = $false
    [string] $OriginalInput = ""
    # Removed BonkersMode - simplified to basic completion
    # Reserved HUD rows below the input line
    [int] $HudLine1Row = -1   # status/details line (input row + 1)
    [int] $HudLine2Row = -1   # syntax line (input row + 2)
    [bool] $HudReserved = $false
    [object] $LastState = $null
    [array] $History = @()
    [int] $HistoryIndex = -1
    [bool] $ReverseCycle = $false

    [void] ClampCursor() {
        if ($this.CursorPos -lt 0) { $this.CursorPos = 0 }
        $max = if ($this.Buffer) { $this.Buffer.Length } else { 0 }
        if ($this.CursorPos -gt $max) { $this.CursorPos = $max }
    }

    [void] SafeInsert([int]$pos, [string]$text) {
        if (-not $text) { return }
        $len = if ($this.Buffer) { $this.Buffer.Length } else { 0 }
        if ($pos -lt 0) { $pos = 0 }
        if ($pos -gt $len) { $pos = $len }
        $this.Buffer = $this.Buffer.Insert($pos, $text)
    }

    [void] SafeRemove([int]$pos, [int]$count) {
        $len = if ($this.Buffer) { $this.Buffer.Length } else { 0 }
        if ($count -le 0 -or $len -eq 0) { return }
        if ($pos -lt 0) { return }
        if ($pos -ge $len) { return }
        if ($pos + $count -gt $len) { $count = $len - $pos }
        if ($count -le 0) { return }
        $this.Buffer = $this.Buffer.Remove($pos, $count)
    }

    [bool] IsShowGhostNextEnabled() {
        try { [ConfigManager]::Load(); $cfg = [ConfigManager]::Config; if ($cfg -and $cfg.Behavior -and $cfg.Behavior.ShowGhostNext -ne $null) { return [bool]$cfg.Behavior.ShowGhostNext } } catch {}
        return $true
    }

    [bool] IsShowSyntaxLineEnabled() {
        try { [ConfigManager]::Load(); $cfg = [ConfigManager]::Config; if ($cfg -and $cfg.Behavior -and $cfg.Behavior.ShowSyntaxLine -ne $null) { return [bool]$cfg.Behavior.ShowSyntaxLine } } catch {}
        return $true
    }

    [CompletionState] GetAndCacheState() {
        try { $state = $this.Parser.ParseBufferToState($this.Buffer, $this.CursorPos); $this.LastState = $state; return $state } catch { return $null }
    }

    [string] GetNextArgGhost([CompletionState] $state) {
        if (-not $this.IsShowGhostNextEnabled()) { return '' }
        if (-not $state) { $state = $this.GetAndCacheState() }
        if (-not $state) { return '' }
        $cmd = if ($state.FullCommandName) { $state.FullCommandName } else { $state.CurrentCommand }
        if ([string]::IsNullOrWhiteSpace($cmd)) { return '' }
        
        # Universal context-aware ghost text generation
        return $this.GetDynamicGhostText($cmd, $state)
    }
    
    [string] GetDynamicGhostText([string] $cmd, [CompletionState] $state) {
        $ctx = $null
        try { $ctx = [CommandContext]::new($state, $this.Parser) } catch { Write-DebugLog ("GetDynamicGhostText CommandContext error: " + $_) }
        
        # Command-specific smart ghost text
        switch ($cmd) {
            'add' {
                $hasProj = $ctx -and $ctx.HasArg('project')
                $hasPri = $ctx -and $ctx.HasArg('priority') 
                $hasDue = $ctx -and $ctx.HasArg('due')
                $hasTags = $ctx -and $ctx.HasArg('tags') -and $ctx.GetTags().Count -gt 0
                $hasText = $ctx -and -not [string]::IsNullOrWhiteSpace($ctx.GetText())
                
                if (-not $hasProj) { return ' @inbox' }
                if (-not $hasPri) { return ' p1' }
                if (-not $hasDue) { return ' due:today' }
                if (-not $hasTags) { return ' #important' }
                if (-not $hasText) { return ' <description>' }
                return ''
            }
            'log' {
                if ($state.OriginalBuffer -match '\b(\d{2,5})\s*$') { return ' today 1.0 [description]' }
                if ($state.OriginalBuffer -match '@\w+\s*$') { return ' today 1.0 [description]' }
                if ($state.OriginalBuffer -match '#\d+\s*$') { return ' today 1.0 [description]' }
                return ' @project today 1.0  OR  #050 today 1.0'
            }
            'show project' { return ' <project-name>' }
            'add project' { return ' <project-name>' }
            'done' { return ' <task-id>' }
            'delete' { return ' <task-id>' }
            'update' { return ' <task-id> [field:value]' }
            'postpone' { return ' <task-id> [date]' }
            'duplicate' { return ' <task-id>' }
            'move' { return ' <task-id> @project' }
            'note' { return ' <task-id> <note>' }
            'search' { return ' <search-term>' }
            'filter' { return ' [p1|p2|p3|@project]' }
            'start timer' { return ' @project [task-description]' }
            'edit time' { return ' <time-id>' }
            'delete time' { return ' <time-id>' }
            'report time' { return ' [week|month|@project]' }
            'add alias' { return ' <shortcut> "<expansion>"' }
            'remove alias' { return ' <shortcut>' }
            'export' { return ' [format]' }
            'import' { return ' <filename>' }
            default {
                # Fallback to schema syntax if available
                try { 
                    $schema = $this.Parser.CommandSchemas[$cmd]
                    if ($schema -and $schema.Syntax) { return ' ' + $schema.Syntax }
                } catch {}
                return ''
            }
        }
        return ''
    }

    [array] BuildSyntaxSegments([CompletionState] $state) {
        $segments = @()
        if (-not $state) { $state = $this.GetAndCacheState() }
        if (-not $state) { return $segments }
        $full = if ($state.FullCommandName) { $state.FullCommandName } else { $state.CurrentCommand }
        if ([string]::IsNullOrWhiteSpace($full)) { return $segments }
        $parts = $full -split '\s+'
        $base = $parts[0]
        $sub = if ($parts.Count -gt 1) { $parts[1] } else { '' }

        # Always start with the base command as fixed
        $segments += [PSCustomObject]@{ Text = $base; Type = 'fixed'; Done = $true; Required = $true }
        if ($sub) { $segments += [PSCustomObject]@{ Text = ' ' + $sub; Type = 'fixed'; Done = $true; Required = $true } }

        $ctx = $null
        try { $ctx = [CommandContext]::new($state, $this.Parser) } catch {}

        $schema = $null
        try {
            if ($this.Parser.CommandSchemas.ContainsKey($full)) { $schema = $this.Parser.CommandSchemas[$full] }
            elseif ($this.Parser.CommandSchemas.ContainsKey($base)) { $schema = $this.Parser.CommandSchemas[$base] }
        } catch { Write-DebugLog ("BuildSyntaxSegments schema lookup error: " + $_) }
        if ($schema -and $schema.Arguments -and $schema.Arguments.Count -gt 0) {
            foreach ($arg in $schema.Arguments) {
                $name = $arg.Name
                $required = $arg.Required
                $done = $false
                if ($name -eq 'subcommand') { $done = -not [string]::IsNullOrWhiteSpace($sub) }
                elseif ($ctx) { try { $done = $ctx.HasArg($name) } catch { $done = $false } }
                # Build prefix-rich label when possible
                $shape = $name
                if ($arg.Prefix) {
                    switch ($arg.Prefix) {
                        '@'   { $shape = '@project' }
                        'due:'{ $shape = 'due:date' }
                        '#'   { $shape = '#tag' }
                        '+'   { $shape = '+tag' }
                        '-'   { $shape = '-tag' }
                        'p'   {
                            # Show common priority shape
                            $shape = 'p1-3'
                        }
                        default { $shape = $name }
                    }
                } elseif ($arg.ValidValues -and $arg.ValidValues.Count -gt 0 -and $arg.ValidValues.Count -le 4) {
                    $shape = ($arg.ValidValues -join '|')
                }
                $labelCore = $shape
                $label = if ($required) { " <${labelCore}>" } else { " [${labelCore}]" }
                $segments += [PSCustomObject]@{ Text = $label; Type = 'arg'; Done = $done; Required = $required }
            }
        } else {
            # No schema; fall back to NeedsArg flag if present
            try {
                if ($this.Parser.Commands.ContainsKey($full)) {
                    $needs = $this.Parser.Commands[$full].NeedsArg
                    if ($needs) { $segments += [PSCustomObject]@{ Text = ' <args>'; Type = 'arg'; Done = $false; Required = $true } }
                } elseif ($this.Parser.Commands.ContainsKey($base)) {
                    $needs = $this.Parser.Commands[$base].NeedsArg
                    if ($needs) { $segments += [PSCustomObject]@{ Text = ' <args>'; Type = 'arg'; Done = -not [string]::IsNullOrWhiteSpace($sub); Required = $true } }
                }
            } catch {}
        }
        return $segments
    }

    [void] RenderSyntaxLine([CompletionState] $state) {
        if (-not $this.IsShowSyntaxLineEnabled()) { return }
        if (-not $state) { $state = $this.GetAndCacheState() }
        if (-not $state) { return }
        $this.EnsureHud()
        $segments = $this.BuildSyntaxSegments($state)
        if ($segments.Count -eq 0) { return }
        try {
            $syntaxTop = if ($this.HudLine2Row -ge 0) { $this.HudLine2Row } else { $this.InputRow + 2 }
            Write-Host -NoNewline ([VT]::SavePos())
            Write-Host -NoNewline ([VT]::MoveTo(1, $syntaxTop))
            Write-Host -NoNewline ([VT]::ClearLine())
            Write-Host -NoNewline ([VT]::MoveTo(1, $syntaxTop))
            Write-Host -NoNewline "    Syntax: " -ForegroundColor DarkGray
            # Determine next segment (first arg not done)
            $next = $segments | Where-Object { $_.Type -eq 'arg' -and -not $_.Done } | Select-Object -First 1
            foreach ($seg in $segments) {
                if ($seg.Type -eq 'fixed') { Write-Host -NoNewline $seg.Text -ForegroundColor Gray; continue }
                if ($seg.Done) { Write-Host -NoNewline $seg.Text -ForegroundColor DarkGray }
                elseif ($seg.Required) { Write-Host -NoNewline $seg.Text -ForegroundColor White }
                else { Write-Host -NoNewline $seg.Text -ForegroundColor Gray }
            }
            Write-Host -NoNewline ([VT]::RestorePos())
        } finally { }
    }

    [void] TryAutoOpenPrefixCompletion() {
        try {
            # Only auto-open when not already cycling
            if ($this.InCompletion) { return }
            $state = $this.Parser.ParseBufferToState($this.Buffer, $this.CursorPos)
            $this.LastState = $state
            if ($state.Mode -eq [CompletionMode]::PrefixCompletion) {
                Write-DebugLog ("UI: AutoOpenPrefixCompletion for buffer='" + $this.Buffer + "' cursor=" + $this.CursorPos)
                $this.OriginalInput = $this.Buffer
                $smartCompletions = $this.Parser.GetSmartCompletions($this.Buffer, $this.CursorPos)
                $cnt = if ($smartCompletions) { $smartCompletions.Count } else { 0 }
                Write-DebugLog ("UI: AutoOpenPrefixCompletion got {0} items" -f $cnt)
                if ($smartCompletions -and $smartCompletions.Count -gt 0) {
                    $this.Completions = @($smartCompletions | Select-Object -ExpandProperty Command)
                    $this.CompletionDetails = $smartCompletions
                    $this.InCompletion = $true
                    $this.CompletionIndex = 0
                    # Do not auto-apply a value; just show indicators + ghost to avoid greedy completion
                    $this.RedrawLine()
                    $this.ShowCompletionIndicators()
                } else {
                    Write-DebugLog ("UI: AutoOpenPrefixCompletion no items; not entering completion mode")
                }
            }
        } catch { Write-DebugLog ("RenderSyntaxLine error: " + $_) }
    }

    [void] MoveCursorWordLeft() {
        $i = $this.CursorPos
        if ($i -le 0) { return }
        $j = $i - 1
        while ($j -ge 0 -and [char]::IsWhiteSpace($this.Buffer[$j])) { $j-- }
        while ($j -ge 0 -and -not [char]::IsWhiteSpace($this.Buffer[$j]) -and ($this.Buffer[$j] -notin @('@','#','+','-',';','|',':'))) { $j-- }
        $this.CursorPos = [Math]::Max(0, $j + 1)
        [Console]::SetCursorPosition((Get-Prompt).Length + $this.CursorPos, $this.InputRow)
    }

    [void] MoveCursorWordRight() {
        $i = $this.CursorPos
        $n = $this.Buffer.Length
        if ($i -ge $n) { return }
        $j = $i
        while ($j -lt $n -and [char]::IsWhiteSpace($this.Buffer[$j])) { $j++ }
        while ($j -lt $n -and -not [char]::IsWhiteSpace($this.Buffer[$j]) -and ($this.Buffer[$j] -notin @('@','#','+','-',';','|',':'))) { $j++ }
        $this.CursorPos = [Math]::Min($n, $j)
        [Console]::SetCursorPosition((Get-Prompt).Length + $this.CursorPos, $this.InputRow)
    }

    [void] DeletePrevToken() {
        if ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) { $this.AcceptCompletion(); $this.OriginalInput = $this.Buffer }
        $i = $this.CursorPos
        if ($i -le 0) { return }
        $j = $i
        while ($j -gt 0 -and [char]::IsWhiteSpace($this.Buffer[$j-1])) { $j-- }
        while ($j -gt 0 -and -not [char]::IsWhiteSpace($this.Buffer[$j-1])) { $j-- }
        $len = $i - $j
        if ($len -gt 0) {
            if ($j -ge 0 -and $len -gt 0 -and ($j + $len) -le $this.Buffer.Length) {
                $this.SafeRemove($j, $len)
            }
            $this.CursorPos = $j
            $this.RedrawLine()
        }
    }

    # === ENHANCED FIELD NAVIGATION ===
    
    [bool] TryFieldJump() {
        Write-DebugLog ("UI: TryFieldJump - parsing buffer '$($this.Buffer)' at pos $($this.CursorPos)")
        
        try {
            # Parse the current command state
            $state = $this.Parser.ParseCommandBuffer($this.Buffer, $this.CursorPos)
            Write-DebugLog ("UI: TryFieldJump - parsed command: '$($state.FullCommandName)', mode: $($state.Mode)")
            
            # Only jump fields for recognized commands that aren't actively completing something
            if ([string]::IsNullOrEmpty($state.FullCommandName) -or $state.Mode -eq [CompletionMode]::PrefixCompletion) {
                Write-DebugLog ("UI: TryFieldJump - not jumping, no command or in prefix completion")
                return $false
            }
            
            # Get the schema for this command
            $schema = $this.Parser.GetCommandSchema($state.FullCommandName)
            if (-not $schema) {
                Write-DebugLog ("UI: TryFieldJump - no schema found for command '$($state.FullCommandName)'")
                return $false
            }
            
            # Find the next logical field position
            $nextPos = $this.FindNextFieldPosition($state, $schema)
            if ($nextPos -lt 0) {
                Write-DebugLog ("UI: TryFieldJump - no next field position found")
                return $false
            }
            
            # Jump to the field
            $this.CursorPos = $nextPos
            $this.RedrawLine()
            $this.ShowFieldHint($schema, $nextPos)
            
            Write-DebugLog ("UI: TryFieldJump - jumped to position $nextPos")
            return $true
            
        } catch {
            Write-DebugLog ("UI: TryFieldJump error: $_")
            return $false
        }
    }
    
    [int] FindNextFieldPosition([CompletionState]$state, [CommandSchema]$schema) {
        $currentBuffer = $this.Buffer
        $currentCursor = $this.CursorPos
        
        Write-DebugLog ("UI: FindNextFieldPosition - looking for field after pos $currentCursor in '$currentBuffer'")
        
        # Find what arguments we already have
        $parsedArgs = @{}
        if ($state.ParsedArguments) {
            $parsedArgs = $state.ParsedArguments
        }
        
        # Look for common field patterns ahead of cursor
        $remainingBuffer = $currentBuffer.Substring($currentCursor)
        
        # If we're at the end or in whitespace, suggest next field
        if ($currentCursor -ge $currentBuffer.Length -or [char]::IsWhiteSpace($currentBuffer[$currentCursor])) {
            # Move to end and suggest next missing field
            $nextPos = $currentBuffer.Length
            
            # Add space if needed
            if ($nextPos -gt 0 -and -not [char]::IsWhiteSpace($currentBuffer[$nextPos-1])) {
                $this.Buffer = $currentBuffer + " "
                $nextPos++
            }
            
            Write-DebugLog ("UI: FindNextFieldPosition - at end/whitespace, returning $nextPos")
            return $nextPos
        }
        
        # Look for field separators ahead: @, p, due:, #, +
        $fieldPatterns = @('@', 'p[123]', 'due:', '#', '\+')
        foreach ($pattern in $fieldPatterns) {
            if ($remainingBuffer -match $pattern) {
                $matchPos = $currentCursor + $matches.Index
                if ($matchPos -gt $currentCursor) {
                    Write-DebugLog ("UI: FindNextFieldPosition - found field pattern '$pattern' at $matchPos")
                    return $matchPos
                }
            }
        }
        
        # No field found ahead, go to end
        Write-DebugLog ("UI: FindNextFieldPosition - no field found, going to end")
        return $currentBuffer.Length
    }
    
    [void] ShowFieldHint([CommandSchema]$schema, [int]$position) {
        try {
            # Determine what kind of field we're at based on position in buffer
            $currentBuffer = $this.Buffer
            $fieldType = $this.DetermineFieldType($currentBuffer, $position)
            
            # Show appropriate hint below input line
            $hintRow = $this.InputRow + 1
            Write-Host ([VT]::MoveTo(0, $hintRow)) -NoNewline
            Write-Host ([VT]::ClearLine()) -NoNewline
            
            $hint = $this.GetFieldHint($fieldType, $schema)
            if ($hint) {
                Write-Host $hint -ForegroundColor DarkCyan
                Write-DebugLog ("UI: ShowFieldHint - displayed hint for field type '$fieldType'")
            }
            
            # Return cursor to input position
            $promptLen = (Get-Prompt).Length
            Write-Host ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow)) -NoNewline
            
        } catch {
            Write-DebugLog ("UI: ShowFieldHint error: $_")
        }
    }
    
    [string] DetermineFieldType([string]$buffer, [int]$position) {
        if ($position -ge $buffer.Length) {
            return "next"  # At end, show next available field
        }
        
        $char = $buffer[$position]
        switch ($char) {
            '@' { return "project" }
            '#' { return "tag" }
            '+' { return "tag" }
            'p' { return "priority" }
            'd' { 
                if ($buffer.Substring($position).StartsWith("due:")) { 
                    return "due" 
                } else {
                    return "text"
                }
            }
        }
        
        return "text"  # Default to text field
    }
    
    [string] GetFieldHint([string]$fieldType, [CommandSchema]$schema) {
        switch ($fieldType) {
            "project" { return "  Project: [@inbox] [@personal] [@work] ... (Tab completes)" }
            "priority" { return "  Priority: [p1] [p2] [p3] [!] [!!] [!!!]" }
            "due" { return "  Due: [today] [tomorrow] [friday] [+3d] [2024-12-25]" }
            "tag" { return "  Tags: [#urgent] [#waiting] [#someday] [+tag]" }
            "next" { 
                # Show what fields are available for this command
                $missing = $this.GetMissingFields($schema)
                if ($missing.Count -gt 0) {
                    return "  Available: " + ($missing -join " | ")
                }
                return "  Press Enter to execute command"
            }
            default { return "" }
        }
        return ""  # Explicit fallback return
    }
    
    [string[]] GetMissingFields([CommandSchema]$schema) {
        $suggestions = @()
        
        # Check if buffer contains common field patterns
        $hasProject = $this.Buffer -match '@\w+'
        $hasPriority = $this.Buffer -match 'p[123]|!!!?'
        $hasDue = $this.Buffer -match 'due:'
        $hasTags = $this.Buffer -match '[#+]\w+'
        
        if (-not $hasProject) { $suggestions += "@project" }
        if (-not $hasPriority) { $suggestions += "p1/p2/p3" }
        if (-not $hasDue) { $suggestions += "due:date" }
        if (-not $hasTags) { $suggestions += "#tag" }
        
        return $suggestions
    }
    
    # LEVEL 4: Analyze context at cursor position to determine tab behavior
    [object] AnalyzeTabContext() {
        $currentBuffer = $this.Buffer
        $currentCursor = $this.CursorPos
        
        # Check if we're typing a field prefix
        if ($currentCursor -gt 0) {
            # Look for field prefixes before cursor
            $beforeCursor = $currentBuffer.Substring(0, $currentCursor)
            
            # Check for @project prefix
            if ($beforeCursor -match '@(\w*)$') {
                return @{ Type = 'FieldPrefix'; FieldType = 'project'; Prefix = $matches[1] }
            }
            
            # Check for priority prefix
            if ($beforeCursor -match 'p([123]?)$') {
                return @{ Type = 'FieldPrefix'; FieldType = 'priority'; Prefix = $matches[1] }
            }
            
            # Check for due: prefix
            if ($beforeCursor -match 'due:(\w*)$') {
                return @{ Type = 'FieldPrefix'; FieldType = 'due'; Prefix = $matches[1] }
            }
            
            # Check for tag prefix
            if ($beforeCursor -match '[#+](\w*)$') {
                return @{ Type = 'FieldPrefix'; FieldType = 'tag'; Prefix = $matches[1] }
            }
        }
        
        # Check if we should show next field completions
        try {
            $state = $this.Parser.ParseCommandBuffer($currentBuffer, $currentCursor)
            
            # ONLY do field navigation if we have a COMPLETE command + space + arguments
            if (-not [string]::IsNullOrEmpty($state.FullCommandName)) {
                # Check if buffer contains the full command name + space + something after
                $cmdPattern = [regex]::Escape($state.FullCommandName) + '\s+'
                if ($currentBuffer -match $cmdPattern -and $currentCursor -gt ($matches[0].Index + $matches[0].Length)) {
                    # We're after a complete command + space, in the arguments area
                    
                    # Check if we're at the end of buffer or in whitespace after a field
                    if ($currentCursor -ge $currentBuffer.Length -or 
                        ($currentCursor -lt $currentBuffer.Length -and [char]::IsWhiteSpace($currentBuffer[$currentCursor]))) {
                        
                        # Show field template completions rather than navigation
                        return @{ Type = 'FieldTemplate'; Command = $state.FullCommandName }
                    }
                }
            }
        } catch {
            Write-DebugLog ("UI: AnalyzeTabContext parsing error: $_")
        }
        
        # Default to normal command completion
        return @{ Type = 'Normal' }
    }
    
    # Check if cursor is at a field boundary (after @project, p1, due:date, #tag)
    [bool] IsAtFieldBoundary([string]$buffer, [int]$cursor) {
        if ($cursor -eq 0) { return $false }
        
        # Look backwards from cursor to see if we just completed a field
        $beforeCursor = $buffer.Substring(0, $cursor)
        
        # Check if we're right after a complete field pattern
        if ($beforeCursor -match '(@\w+|p[123]|due:\S+|[#+]\w+)\s*$') {
            return $true
        }
        
        return $false
    }
    
    # Get specialized completions for field prefixes
    [array] GetFieldPrefixCompletions([string]$fieldType, [string]$prefix) {
        $results = @()
        
        switch ($fieldType) {
            'project' {
                # Get project names from data
                try {
                    $data = Get-TaskData
                    $projects = $data.tasks | ForEach-Object { $_.project } | Sort-Object -Unique | Where-Object { $_ -and $_ -like "*$prefix*" }
                    $results = $projects | ForEach-Object { "@$_" }
                    if ($results.Count -eq 0) {
                        $results = @('@inbox', '@work', '@personal', '@home')
                    }
                } catch {
                    $results = @('@inbox', '@work', '@personal', '@home')
                }
            }
            'priority' {
                $results = @('p1', 'p2', 'p3')
                if ($prefix) {
                    $results = $results | Where-Object { $_ -like "p$prefix*" }
                }
            }
            'due' {
                $results = @('due:today', 'due:tomorrow', 'due:friday', 'due:+1d', 'due:+1w', 'due:2024-12-25')
                if ($prefix) {
                    $results = $results | Where-Object { $_ -like "due:$prefix*" }
                }
            }
            'tag' {
                # Get existing tags from data
                try {
                    $data = Get-TaskData
                    $tags = $data.tasks | ForEach-Object { $_.tags } | Where-Object { $_ } | ForEach-Object { $_ -split ',' } | 
                           ForEach-Object { $_.Trim() } | Sort-Object -Unique | Where-Object { $_ -like "*$prefix*" }
                    $results = $tags | ForEach-Object { "#$_" }
                    if ($results.Count -eq 0) {
                        $results = @('#urgent', '#waiting', '#someday', '#next', '#review')
                    }
                } catch {
                    $results = @('#urgent', '#waiting', '#someday', '#next', '#review')
                }
            }
        }
        
        return $results
    }
    
    # Simplified field prefix detection for tab completion
    [array] GetFieldPrefixCompletionIfApplicable() {
        $currentBuffer = $this.Buffer
        $cursor = $this.CursorPos
        
        if ($cursor -eq 0) { return @() }
        
        # Look backwards from cursor for field prefixes
        $beforeCursor = $currentBuffer.Substring(0, $cursor)
        
        # Check for @project prefix
        if ($beforeCursor -match '@(\w*)$') {
            return $this.GetFieldPrefixCompletions('project', $matches[1])
        }
        
        # Check for priority prefix  
        if ($beforeCursor -match 'p([123]?)$') {
            return $this.GetFieldPrefixCompletions('priority', $matches[1])
        }
        
        # Check for due: prefix
        if ($beforeCursor -match 'due:(\w*)$') {
            return $this.GetFieldPrefixCompletions('due', $matches[1])
        }
        
        # Check for tag prefix
        if ($beforeCursor -match '[#+](\w*)$') {
            return $this.GetFieldPrefixCompletions('tag', $matches[1])
        }
        
        return @()
    }
    
    # Get template completions for next field after a command (p1, due:, #tag, etc.)
    [array] GetFieldTemplateCompletions([string]$command) {
        $templates = @()
        
        # Analyze what fields are already present in the buffer
        $currentBuffer = $this.Buffer
        $hasProject = $currentBuffer -match '@\w+'
        $hasPriority = $currentBuffer -match 'p[123]'
        $hasDue = $currentBuffer -match 'due:'
        $hasTags = $currentBuffer -match '[#+]\w+'
        
        # Suggest missing field templates based on command
        switch ($command) {
            'add' {
                if (-not $hasPriority) { $templates += @('p1', 'p2', 'p3') }
                if (-not $hasDue) { $templates += @('due:today', 'due:tomorrow', 'due:friday') }
                if (-not $hasTags) { $templates += @('#urgent', '#waiting', '#next') }
                if (-not $hasProject) { $templates += @('@work', '@personal', '@home') }
            }
            'edit' {
                if (-not $hasPriority) { $templates += @('p1', 'p2', 'p3') }
                if (-not $hasDue) { $templates += @('due:today', 'due:tomorrow', 'due:+1d') }
                if (-not $hasTags) { $templates += @('#urgent', '#waiting', '#review') }
            }
            'update' {
                if (-not $hasPriority) { $templates += @('p1','p2','p3') }
                if (-not $hasDue) { $templates += @('due:today','due:tomorrow','due:+1d') }
                if (-not $hasTags) { $templates += @('#urgent','#waiting','#next') }
                if (-not $hasProject) { $templates += @('@inbox','@work') }
            }
            'move' {
                # Suggest project for destination
                if (-not $hasProject) { $templates += @('@inbox','@work','@personal') }
            }
            'postpone' {
                $templates += @('+1d','+2d','+3d','+7d','due:tomorrow','due:nextweek')
            }
            'duplicate' {
                $templates += @('+1d','+7d','#copy')
            }
            default {
                # Generic field templates
                $templates += @('p1', 'p2', 'p3', 'due:today', '#urgent')
            }
        }
        
        return $templates
    }
    
    # LEVEL 5: Bonkers Inline Field Editing - detect and parse fields in buffer
    [array] ParseInlineFields([string]$buffer) {
        $fields = @()
        
        # Find all field patterns in the buffer
        $patterns = @{
            'project' = '@(\w+)'
            'priority' = 'p([123])'
            'due' = 'due:(\S+)'
            'tag' = '[#+](\w+)'
        }
        
        foreach ($type in $patterns.Keys) {
            $pattern = $patterns[$type]
            $matches = [regex]::Matches($buffer, $pattern, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
            
            foreach ($match in $matches) {
                $fields += [PSCustomObject]@{
                    Type = $type
                    Start = $match.Index
                    End = $match.Index + $match.Length
                    Value = $match.Value
                    InnerValue = $match.Groups[1].Value
                }
            }
        }
        
        # Sort by position
        return $fields | Sort-Object Start
    }
    
    # Get the field at a specific cursor position
    [object] GetFieldAtCursor([int]$cursor) {
        $fields = $this.ParseInlineFields($this.Buffer)
        foreach ($field in $fields) {
            if ($cursor -ge $field.Start -and $cursor -le $field.End) {
                return $field
            }
        }
        return $null
    }
    
    # LEVEL 5: Enhanced line rendering with field highlighting
    [void] RedrawLineWithFields() {
        try {
            Write-DebugLog ("UI: RedrawLineWithFields start (BonkersMode=$($this.BonkersMode))")
            
            # If not in bonkers mode, use normal rendering
            if (-not $this.BonkersMode) {
                $this.RedrawLine()
                return
            }
            
            $prompt = Get-Prompt
            $promptLen = $prompt.Length
            $maxWidth = [Math]::Max(80, [Console]::WindowWidth - $promptLen - 2)
            
            # Move to start of input line and clear it
            Write-Host -NoNewline ([VT]::MoveTo(1, $this.InputRow))
            Write-Host -NoNewline ([VT]::ClearLine())
            Write-Host -NoNewline $prompt
            
            # Check if we should use field-aware rendering
            $currentField = $this.GetFieldAtCursor($this.CursorPos)
            $fields = $this.ParseInlineFields($this.Buffer)
            
            if ($fields.Count -gt 0) {
                # Render with field highlighting
                $this.RenderBufferWithFieldHighlighting($fields, $currentField)
            } else {
                # Normal rendering
                Write-Host -NoNewline $this.Buffer
            }
            
            # Position cursor correctly
            $cursorCol = $promptLen + $this.CursorPos + 1
            Write-Host -NoNewline ([VT]::MoveTo($cursorCol, $this.InputRow))
            
            Write-DebugLog ("UI: RedrawLineWithFields complete")
            
        } catch {
            Write-DebugLog ("UI: RedrawLineWithFields error: $_")
            # Fallback to normal rendering
            $this.RedrawLine()
        }
    }
    
    # Render buffer with field highlighting (different colors/backgrounds for each field type)
    [void] RenderBufferWithFieldHighlighting([array]$fields, [object]$activeField) {
        $lastPos = 0
        
        foreach ($field in $fields) {
            # Render text before field normally
            if ($field.Start -gt $lastPos) {
                $beforeText = $this.Buffer.Substring($lastPos, $field.Start - $lastPos)
                Write-Host -NoNewline $beforeText
            }
            
            # Render field with highlighting
            $isActive = $activeField -and $activeField.Start -eq $field.Start
            $this.RenderField($field, $isActive)
            
            $lastPos = $field.End
        }
        
        # Render remaining text after last field
        if ($lastPos -lt $this.Buffer.Length) {
            $afterText = $this.Buffer.Substring($lastPos)
            Write-Host -NoNewline $afterText
        }
    }
    
    # Render individual field with type-specific styling
    [void] RenderField([object]$field, [bool]$isActive) {
        $colors = @{
            'project' = @{ Fg = 'Green'; Bg = if ($isActive) { 'DarkGreen' } else { $null } }
            'priority' = @{ Fg = 'Yellow'; Bg = if ($isActive) { 'DarkYellow' } else { $null } }
            'due' = @{ Fg = 'Cyan'; Bg = if ($isActive) { 'DarkCyan' } else { $null } }
            'tag' = @{ Fg = 'Magenta'; Bg = if ($isActive) { 'DarkMagenta' } else { $null } }
        }
        
        $style = $colors[$field.Type]
        if (-not $style) { $style = @{ Fg = 'White'; Bg = $null } }
        
        # Add visual indicators for active field
        if ($isActive) {
            Write-Host -NoNewline "[" -ForegroundColor DarkGray
            Write-Host -NoNewline $field.Value -ForegroundColor $style.Fg -BackgroundColor $style.Bg
            Write-Host -NoNewline "]" -ForegroundColor DarkGray
        } else {
            Write-Host -NoNewline $field.Value -ForegroundColor $style.Fg
        }
    }
    
    # LEVEL 5: Enhanced field navigation that jumps between detected fields
    [bool] TryInlineFieldJump() {
        $fields = $this.ParseInlineFields($this.Buffer)
        if ($fields.Count -eq 0) { return $false }
        
        # Find next field after current cursor position
        $nextField = $fields | Where-Object { $_.Start -gt $this.CursorPos } | Select-Object -First 1
        
        if ($nextField) {
            # Jump to start of next field
            $this.CursorPos = $nextField.Start
            $this.RedrawLineWithFields()
            Write-DebugLog ("UI: TryInlineFieldJump - jumped to field '$($nextField.Type)' at pos $($nextField.Start)")
            return $true
        } else {
            # No field ahead, jump to end and add new field template
            $this.CursorPos = $this.Buffer.Length
            if ($this.Buffer.Length -gt 0 -and -not [char]::IsWhiteSpace($this.Buffer[$this.Buffer.Length - 1])) {
                $this.Buffer += " "
                $this.CursorPos++
            }
            $this.RedrawLineWithFields()
            Write-DebugLog ("UI: TryInlineFieldJump - jumped to end for new field")
            return $true
        }
    }
    
    SmartInputHandler([SmartCommandParser]$parser) {
        $this.Parser = $parser
        $this.LoadHistory()
        $this.SuppressGhostOnce = $false
    }
    
    [void] LoadHistory() {
        $historyFile = Join-Path $PSScriptRoot "history.txt"
        if (Test-Path $historyFile) {
            $this.History = Get-Content $historyFile
        }
    }
    
    [void] SaveHistory() {
        $historyFile = Join-Path $PSScriptRoot "history.txt"
        try {
            $h = @($this.History)
            if ($h.Count -le 0) { return }
            $slice = if ($h.Count -gt 100) { $h[($h.Count-100)..($h.Count-1)] } else { $h }
            $slice | Set-Content $historyFile
        } catch {}
    }
    
    [bool] IsAcceptOnTypeEnabled() {
        # Disable accept-on-type for command/subcommand/syntax discovery; allow only in prefix-completion mode
        try {
            $mode = $null
            if ($this.LastState) { $mode = $this.LastState.Mode }
            else {
                try { $st = $this.Parser.ParseBufferToState($this.Buffer, $this.CursorPos); if ($st) { $mode = $st.Mode; $this.LastState = $st } } catch {}
            }
            if ($mode -ne $null -and $mode -ne [CompletionMode]::PrefixCompletion) { return $false }
            # In prefix mode, honor config
            $cfg = [ConfigManager]::Config
            if ($cfg -and $cfg.Behavior -and $cfg.Behavior.AcceptOnType -ne $null) {
                return [bool]$cfg.Behavior.AcceptOnType
            }
        } catch {}
        return $false
    }

    [void] NormalizeDueEstBeforeColon() {
        try {
            if ($this.CursorPos -le 0) { return }
            $pos = $this.CursorPos
            $j = $pos - 1
            $hadSpace = $false
            if ($j -ge 0 -and $this.Buffer[$j] -eq ' ') { $hadSpace = $true; $j-- }
            if ($j -lt 0) { return }
            $start = $j
            while ($start -gt 0 -and ($this.Buffer[$start - 1] -match '\\S')) { $start-- }
            $length = $j - $start + 1
            if ($length -le 0) { return }
            $token = $this.Buffer.Substring($start, $length)
            if ($token -match '^(?i)(due)$') {
                if ($hadSpace) {
                    # Remove the space between token and ':'
                    $removeIndex = $start + $token.Length
                    if ($removeIndex -ge 0 -and $removeIndex -lt $this.Buffer.Length) {
                        $this.SafeRemove($removeIndex, 1)
                        if ($this.CursorPos -gt 0) { $this.CursorPos-- }
                        "INPUT: Normalized '${token} :' to '${token}:'" | Write-Debug
                    }
                }
            }
        } catch {}
    }
    
    [string] ReadCommand() {
        $this.Buffer = ""
        $this.CursorPos = 0
        $this.InCompletion = $false
        $this.HistoryIndex = -1
        # Anchor input row (1-based for VT) with bottom clamp for HUD
        $currentRow1 = [Console]::CursorTop + 1
        $windowH = [Console]::WindowHeight
        $targetRow = if ($currentRow1 + 2 -le $windowH) { $currentRow1 } else { [Math]::Max(1, $windowH - 2) }
        $this.InputRow = $targetRow
        $this.EnsureHud()
        $this.RedrawLine()
        
        while ($true) {
            $key = [Console]::ReadKey($true)
            
            switch ($key.Key) {
                'Tab' {
                    # Support Shift+Tab for reverse cycling
                    $reverse = (($key.Modifiers -band [ConsoleModifiers]::Shift) -ne 0)
                    $this.ReverseCycle = $reverse
                    $this.HandleTab()
                }
                'Enter' {
                    if ($this.InCompletion) {
                        $this.AcceptCompletion()
                        # Don't submit, just accept completion and continue editing
                    } else {
                        Write-Host ""
                        
                        # Add to history
                        if (-not [string]::IsNullOrWhiteSpace($this.Buffer)) {
                            $this.History += $this.Buffer
                            $this.SaveHistory()
                        }
                        
                        return $this.Buffer
                    }
                }
                'Escape' {
                    if ($this.InCompletion) {
                        $this.CancelCompletion()
                    } else {
                        $this.Buffer = ""
                        $this.CursorPos = 0
                        $this.RedrawLine()
                    }
                }
                'Backspace' {
                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {
                        $this.DeletePrevToken()
                    } else {
                        if ($this.InCompletion) { $this.CancelCompletion() }
                        if ($this.CursorPos -gt 0) {
                            $this.SafeRemove($this.CursorPos - 1, 1)
                            $this.CursorPos--
                            $this.ClampCursor()
                            $this.RedrawLine()
                        }
                    }
                }
                'UpArrow' {
                    if ($this.History.Count -gt 0) {
                        if ($this.HistoryIndex -eq -1) {
                            $this.HistoryIndex = $this.History.Count - 1
                        } elseif ($this.HistoryIndex -gt 0) {
                            $this.HistoryIndex--
                        }
                        
                        $this.Buffer = $this.History[$this.HistoryIndex]
                        $this.CursorPos = $this.Buffer.Length
                        $this.RedrawLine()
                    }
                }
                'DownArrow' {
                    if ($this.HistoryIndex -ge 0) {
                        if ($this.HistoryIndex -lt $this.History.Count - 1) {
                            $this.HistoryIndex++
                            $this.Buffer = $this.History[$this.HistoryIndex]
                        } else {
                            $this.HistoryIndex = -1
                            $this.Buffer = ""
                        }
                        $this.CursorPos = $this.Buffer.Length
                        $this.RedrawLine()
                    }
                }
                'LeftArrow' {
                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {
                        if ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) { $this.AcceptCompletion(); $this.OriginalInput = $this.Buffer }
                        $this.MoveCursorWordLeft()
                    } else {
                        if ($this.InCompletion -and $this.CursorPos -eq $this.Buffer.Length -and $this.IsAcceptOnTypeEnabled()) {
                            $this.AcceptCompletion(); $this.OriginalInput = $this.Buffer
                        }
                        if ($this.CursorPos -gt 0) {
                            $this.CursorPos--
                            $promptLen = (Get-Prompt).Length
                            Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
                        }
                    }
                }
                'RightArrow' {
                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {
                        if ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) { $this.AcceptCompletion(); $this.OriginalInput = $this.Buffer }
                        $this.MoveCursorWordRight()
                    } else {
                        # If we're at the end and a completion is showing, accept it
                        if ($this.InCompletion -and $this.CursorPos -eq $this.Buffer.Length -and $this.IsAcceptOnTypeEnabled()) {
                            $this.AcceptCompletion(); $this.OriginalInput = $this.Buffer
                        }
                        elseif ($this.CursorPos -lt $this.Buffer.Length) {
                            $this.CursorPos++
                            $promptLen = (Get-Prompt).Length
                            Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
                        }
                    }
                }
                'Home' {
                    if ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) {
                        $this.AcceptCompletion()
                        $this.OriginalInput = $this.Buffer
                    }
                    $this.CursorPos = 0
                    $promptLen = (Get-Prompt).Length
                    Write-Host -NoNewline ([VT]::MoveTo($promptLen + 1, $this.InputRow))
                }
                'End' {
                    # If a completion is showing, accept before moving to end
                    if ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) {
                        $this.AcceptCompletion()
                        $this.OriginalInput = $this.Buffer
                    }
                    $this.CursorPos = $this.Buffer.Length
                    $promptLen = (Get-Prompt).Length
                    Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
                }
                default {
                    "INPUT: Processing key='$($key.KeyChar)' (KeyCode=$($key.Key)), InCompletion=$($this.InCompletion)" | Write-Debug
                    "INPUT: Before - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                    
                    if ($this.InCompletion -and $key.KeyChar -eq ' ') {
                        # Space accepts the current completion
                        "INPUT: Space pressed - accepting completion" | Write-Debug
                        
                        # Check what completion we're accepting to see if it needs immediate input
                        $selectedCompletion = ""
                        if ($this.Completions.Count -gt 0 -and $this.CompletionIndex -ge 0 -and $this.CompletionIndex -lt $this.Completions.Count) {
                            $selectedCompletion = $this.Completions[$this.CompletionIndex]
                        }
                        "INPUT: Selected completion='$selectedCompletion'" | Write-Debug
                        
                        $this.AcceptCompletion()
                        # Update OriginalInput to current buffer so next Tab works correctly
                        $this.OriginalInput = $this.Buffer
                        "INPUT: Updated OriginalInput to '$($this.OriginalInput)'" | Write-Debug
                        
                        # Only add space if:
                        # 1. Buffer doesn't already end with space (prevents double-space)
                        # 2. Completion is not a prefix that needs immediate input (@, #, due:, est:)
                        $needsImmediateInput = ($selectedCompletion -eq '@' -or $selectedCompletion -eq '#' -or 
                                              $selectedCompletion.EndsWith(':'))
                        
                        if (-not $this.Buffer.EndsWith(' ') -and -not $needsImmediateInput) {
                            $this.SafeInsert($this.CursorPos, ' ')
                            $this.CursorPos++
                            "INPUT: Added space - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                        } else {
                            if ($needsImmediateInput) {
                                "INPUT: Prefix needs immediate input, no space added - Buffer='$($this.Buffer)'" | Write-Debug
                            } else {
                                "INPUT: Buffer already ends with space, no space added - Buffer='$($this.Buffer)'" | Write-Debug
                            }
                        }
                        $this.RedrawLine()
                        if ($key.KeyChar -ne ' ') { $this.TryAutoOpenPrefixCompletion() }
                    } elseif ($this.InCompletion -and $this.IsAcceptOnTypeEnabled()) {
                        # Accept-on-type: accept current completion, then insert the typed char
                        "INPUT: Regular printable key while in completion - accepting and continuing" | Write-Debug
                        $selectedCompletion = ""
                        if ($this.Completions.Count -gt 0 -and $this.CompletionIndex -ge 0 -and $this.CompletionIndex -lt $this.Completions.Count) {
                            $selectedCompletion = $this.Completions[$this.CompletionIndex]
                        }
                        "INPUT: Selected completion='$selectedCompletion'" | Write-Debug
                        
                        # If we're completing a prefix value and the user types a letter/number, keep typing instead of accepting
                        $isAlphaNum = ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar))
                        $isPrefixMode = $false
                        try {
                            if ($this.LastState) { $isPrefixMode = ($this.LastState.Mode -eq [CompletionMode]::PrefixCompletion) }
                            else { $isPrefixMode = ($this.Parser.ParseBufferToState($this.OriginalInput).Mode -eq [CompletionMode]::PrefixCompletion) }
                        } catch {}
                        $needsImmediateInput = ($selectedCompletion -eq '@' -or $selectedCompletion -eq '#' -or $selectedCompletion.EndsWith(':'))

                        if ($isPrefixMode -and $isAlphaNum -and -not $needsImmediateInput) {
                            "INPUT: Prefix completion and alphanumeric typed ‚Äî continue typing (do not accept)" | Write-Debug
                            $this.CancelCompletion()
                            if ($key.KeyChar -eq ':') { $this.NormalizeDueEstBeforeColon() }
                            $this.SafeInsert($this.CursorPos, $key.KeyChar)
                            $this.CursorPos++
                            $this.RedrawLine()
                            $this.TryAutoOpenPrefixCompletion()
                        } else {
                            $this.AcceptCompletion()
                            $this.OriginalInput = $this.Buffer

                            # If it's not a prefix and we don't already end with space, insert one
                            if (-not $needsImmediateInput -and -not $this.Buffer.EndsWith(' ')) {
                                $this.SafeInsert($this.CursorPos, ' ')
                                $this.CursorPos++
                                "INPUT: Inserted implied space before typed char" | Write-Debug
                            }

                            # Collision guard: avoid duplicating ':' after a '...:' completion
                            $skipTypedChar = ($selectedCompletion.EndsWith(':') -and $key.KeyChar -eq ':')
                            # Normalize 'due :' -> 'due:' if typing ':'
                            if (-not $skipTypedChar -and $key.KeyChar -eq ':') { $this.NormalizeDueEstBeforeColon() }
                            if (-not $skipTypedChar -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                                $this.SafeInsert($this.CursorPos, $key.KeyChar)
                                $this.CursorPos++
                                "INPUT: Added char after accepting completion - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                            } else {
                                if ($skipTypedChar) { "INPUT: Skipped duplicate ':' after prefix completion" | Write-Debug }
                            }
                            $this.RedrawLine()
                        }
                        
                        if ($key.KeyChar -ne ' ') { $this.TryAutoOpenPrefixCompletion() }
                    } elseif ($this.InCompletion) {
                        # Accept-on-type disabled: keep legacy behavior (cancel then type)
                        "INPUT: Regular key while in completion - cancelling first (accept-on-type disabled)" | Write-Debug
                        $this.CancelCompletion()
                        if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                            if ($key.KeyChar -eq ':') { $this.NormalizeDueEstBeforeColon() }
                            $this.SafeInsert($this.CursorPos, $key.KeyChar)
                            $this.CursorPos++
                            $this.RedrawLine()
                            if ($key.KeyChar -ne ' ') { $this.TryAutoOpenPrefixCompletion() }
                        }
                    } else {
                        "INPUT: Normal key processing (not in completion)" | Write-Debug
                        if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                            if ($key.KeyChar -eq ':') { $this.NormalizeDueEstBeforeColon() }
                            $this.SafeInsert($this.CursorPos, $key.KeyChar)
                            $this.CursorPos++
                            "INPUT: Added char normally - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
                            $this.RedrawLine()
                            if ($key.KeyChar -ne ' ') { $this.TryAutoOpenPrefixCompletion() }
                        }
                    }
                }
            }
        }
        # Fallback return ‚Äì should not be hit in normal flow
        return ""
    }
    
    [void] HandleTab() {
        "=== HANDLETAB START ===" | Write-Debug
        "HANDLETAB: InCompletion=$($this.InCompletion), Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
        "HANDLETAB: OriginalInput='$($this.OriginalInput)'" | Write-Debug
        "HANDLETAB: ReverseCycle=$($this.ReverseCycle)" | Write-Debug
        Write-DebugLog ("UI: HandleTab start InCompletion=" + $this.InCompletion + ", Buffer='" + $this.Buffer + "', CursorPos=" + $this.CursorPos)
        try { Write-DebugLog ("TAB: start inCompletion=" + $this.InCompletion + ", reverseCycle=" + $this.ReverseCycle) } catch {}
        
        if (-not $this.InCompletion) {
            # Check for field prefix completions (@, p, due:, #)
            $prefixCompletion = $this.GetFieldPrefixCompletionIfApplicable()
            if ($prefixCompletion.Count -gt 0) {
                $this.OriginalInput = $this.Buffer
                $this.Completions = $prefixCompletion
                $this.CompletionDetails = $prefixCompletion | ForEach-Object { 
                    [PSCustomObject]@{ Command = $_; Description = ""; Type = "field" }
                }
                $this.InCompletion = $true
                $this.CompletionIndex = 0
                $this.RedrawLine()
                $this.ShowCompletionIndicators()
                Write-DebugLog ("UI: HandleTab entered field prefix completion mode")
                try { Write-DebugLog ("TAB: field-prefix items=" + $this.Completions.Count) } catch {}
                return
            }
            
            # Normal completion logic (for commands or fallback)
            $this.OriginalInput = $this.Buffer
            "HANDLETAB: Set OriginalInput to '$($this.OriginalInput)'" | Write-Debug
            "HANDLETAB: Getting completions for buffer '$($this.Buffer)'" | Write-Debug
            Write-DebugLog ("UI: HandleTab querying completions")
            
            $smartCompletions = $this.Parser.GetSmartCompletions($this.Buffer, $this.CursorPos)
            "HANDLETAB: GetSmartCompletions returned $($smartCompletions.Count) items" | Write-Debug
            $htCnt = if ($smartCompletions) { $smartCompletions.Count } else { 0 }
            Write-DebugLog ("UI: HandleTab completions count={0}" -f $htCnt)
            try { Write-DebugLog ("TAB: items=" + $htCnt) } catch {}
            
            for ($i = 0; $i -lt $smartCompletions.Count; $i++) {
                $comp = $smartCompletions[$i]
                "HANDLETAB: Completion[$i]: Command='$($comp.Command)', Description='$($comp.Description)', Type='$($comp.Type)'" | Write-Debug
                if ($i -lt 3) { Write-DebugLog ("UI: Completion[" + $i + "] '" + $comp.Command + "' ‚Äî '" + ($comp.Description) + "'") }
            }
            
            $this.Completions = @($smartCompletions | Select-Object -ExpandProperty Command)
            $this.CompletionDetails = $smartCompletions
            "HANDLETAB: Set Completions=$($this.Completions.Count), CompletionDetails=$($this.CompletionDetails.Count)" | Write-Debug
            "HANDLETAB: Completions array: $($this.Completions -join ', ')" | Write-Debug
            Write-DebugLog ("UI: Entering completion? Count=" + $this.Completions.Count)
            
            if ($this.Completions.Count -gt 0) {
                "HANDLETAB: Found completions, entering completion mode" | Write-Debug
                $this.InCompletion = $true
                if ($this.ReverseCycle) {
                    $this.CompletionIndex = $this.Completions.Count - 1
                } else {
                    $this.CompletionIndex = 0
                }
                "HANDLETAB: About to call ApplyCompletion()" | Write-Debug
                Write-DebugLog ("UI: ApplyCompletion initial index=" + $this.CompletionIndex)
                $this.ApplyCompletion()
                "HANDLETAB: ApplyCompletion() returned" | Write-Debug
                Write-DebugLog ("UI: ApplyCompletion returned; Buffer='" + $this.Buffer + "' CursorPos=" + $this.CursorPos)
                # Ensure cursor returns to input line
                $promptLen = (Get-Prompt).Length
                Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
            } else {
                "HANDLETAB: No completions found" | Write-Debug
                Write-DebugLog ("UI: No completions found")
            }
        } else {
            # Cycle through
            "HANDLETAB: Cycling through completions, index was $($this.CompletionIndex)" | Write-Debug
            Write-DebugLog ("UI: Cycle completion from index=" + $this.CompletionIndex + "/" + $this.Completions.Count)
            $oldIndex = $this.CompletionIndex
            if ($this.ReverseCycle) {
                $this.CompletionIndex = ($this.CompletionIndex - 1)
                if ($this.CompletionIndex -lt 0) { $this.CompletionIndex = $this.Completions.Count - 1 }
            } else {
                $this.CompletionIndex = ($this.CompletionIndex + 1) % $this.Completions.Count
            }
            "HANDLETAB: Changed index from $oldIndex to $($this.CompletionIndex)" | Write-Debug
            "HANDLETAB: About to call ApplyCompletion() for cycling" | Write-Debug
            Write-DebugLog ("UI: ApplyCompletion (cycle) index=" + $this.CompletionIndex)
            $this.ApplyCompletion()
            "HANDLETAB: ApplyCompletion() for cycling returned" | Write-Debug
            Write-DebugLog ("UI: After cycle ApplyCompletion Buffer='" + $this.Buffer + "' CursorPos=" + $this.CursorPos)
            $promptLen = (Get-Prompt).Length
            Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
        }
        # Reset reverse flag
        $this.ReverseCycle = $false
        "HANDLETAB: COMPLETE - Buffer is now '$($this.Buffer)'" | Write-Debug
        Write-DebugLog ("UI: HandleTab complete Buffer='{0}'" -f $this.Buffer)
        try { $sel = if ($this.CompletionIndex -ge 0 -and $this.CompletionIndex -lt $this.Completions.Count) { $this.Completions[$this.CompletionIndex] } else { '' }; Write-DebugLog ("TAB: end selection='" + $sel + "' index=" + $this.CompletionIndex) } catch {}
    }
    
    [void] ApplyCompletion() {
        "=== APPLYCOMPLETION START ===" | Write-Debug
        "APPLY: Buffer BEFORE='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
        "APPLY: OriginalInput='$($this.OriginalInput)'" | Write-Debug
        "APPLY: Completions.Count=$($this.Completions.Count), CompletionIndex=$($this.CompletionIndex)" | Write-Debug
        Write-DebugLog ("UI: ApplyCompletion start; count={0}, index={1}" -f $this.Completions.Count, $this.CompletionIndex)
        
        if ($this.Completions.Count -gt 0 -and $this.CompletionIndex -ge 0 -and $this.CompletionIndex -lt $this.Completions.Count) {
            $completion = $this.Completions[$this.CompletionIndex]
            "APPLY: Selected completion='$completion'" | Write-Debug
            Write-DebugLog ("UI: Selected completion '" + $completion + "'")
            
            # Use the robust parser's current state - BUT REANALYZE with original input
            "APPLY: About to get parser state for OriginalInput='$($this.OriginalInput)'" | Write-Debug
            # CRITICAL FIX: AnalyzeInput doesn't exist - we need to parse the original input to get the state
            $state = $this.Parser.ParseBufferToState($this.OriginalInput)
            $this.Parser.CurrentState = $state  # Update the parser's state
            $this.LastState = $state
            "APPLY: Parser re-analyzed - Mode=$($state.Mode), CurrentToken='$($state.CurrentToken)', CurrentCommand='$($state.CurrentCommand)'" | Write-Debug
            "APPLY: State details - CompletedArguments.Count=$($state.CompletedArguments.Count), OriginalBuffer='$($state.OriginalBuffer)'" | Write-Debug
            $cmdForLog = if ($state.FullCommandName) { $state.FullCommandName } else { $state.CurrentCommand }
            Write-DebugLog ("UI: State Mode={0}, Token='{1}', Cmd='{2}'" -f $state.Mode, $state.CurrentToken, $cmdForLog)
            
            # Log all completed arguments
            for ($i = 0; $i -lt $state.CompletedArguments.Count; $i++) {
                "APPLY: CompletedArguments[$i]='$($state.CompletedArguments[$i])'" | Write-Debug
            }
            
            # Apply completion based on robust state analysis
            "APPLY: About to call BuildNewBufferWithCompletion" | Write-Debug
            $newBuffer = $this.BuildNewBufferWithCompletion($completion, $state)
            "APPLY: BuildNewBufferWithCompletion returned '$newBuffer'" | Write-Debug
            Write-DebugLog ("UI: BuildNewBufferWithCompletion -> '" + ($newBuffer) + "'")
            
            if ($newBuffer -ne $null -and $newBuffer -ne $this.Buffer) {
                "APPLY: Changing buffer from '$($this.Buffer)' to '$newBuffer'" | Write-Debug
                $oldBuffer = $this.Buffer
                $this.Buffer = $newBuffer
                $this.CursorPos = $this.Buffer.Length
                "APPLY: Updated Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
            $this.RedrawLine()
            "APPLY: RedrawLine() complete" | Write-Debug
            } else {
                "APPLY: Buffer unchanged (newBuffer='$newBuffer', current='$($this.Buffer)')" | Write-Debug
            }
            
            # Show completion indicators
            "APPLY: About to show completion indicators" | Write-Debug
            $this.ShowCompletionIndicators()
            "APPLY: ShowCompletionIndicators() complete" | Write-Debug
            Write-DebugLog ("UI: ShowCompletionIndicators done; index=" + $this.CompletionIndex + "/" + $this.Completions.Count)
        } else {
            "APPLY: Cannot apply - invalid state (Count=$($this.Completions.Count), Index=$($this.CompletionIndex))" | Write-Debug
            Write-DebugLog ("UI: ApplyCompletion invalid state; count=" + $this.Completions.Count + ", index=" + $this.CompletionIndex)
        }
        "APPLY: COMPLETE - Final buffer='$($this.Buffer)'" | Write-Debug
        Write-DebugLog ("UI: ApplyCompletion complete Buffer='" + $this.Buffer + "' CursorPos=" + $this.CursorPos)
    }
    
    [void] ShowCompletionIndicators() {
        if ($this.Completions.Count -le 0 -or $this.CompletionIndex -lt 0) { return }
        $this.EnsureHud()
        try {
            $current = $this.CompletionIndex + 1
            $total = $this.Completions.Count
            Write-DebugLog ("UI: Indicators show current=" + $current + "/" + $total)
            
            if ($this.CompletionDetails.Count -gt 0 -and $this.CompletionIndex -lt $this.CompletionDetails.Count) {
                $detail = $this.CompletionDetails[$this.CompletionIndex]
                if ($detail) {
                    $hudTop = if ($this.HudLine1Row -ge 0) { $this.HudLine1Row } else { $this.InputRow + 1 }
                    Write-Host -NoNewline ([VT]::SavePos())
                    Write-Host -NoNewline ([VT]::MoveTo(1, $hudTop))
                    Write-Host -NoNewline ([VT]::ClearLine())
                    Write-Host -NoNewline ([VT]::MoveTo(1, $hudTop))
                    $mode = ''; $prefix = ''
                    try { if ($this.LastState) { $mode = $this.LastState.Mode.ToString(); if ($this.LastState.PrefixBeingCompleted) { $prefix = " (" + $this.LastState.PrefixBeingCompleted + ")" } } } catch {}
                    $desc = if ($detail.Description) { $detail.Description } else { '' }
                    # Show top 2 suggestions inline for quick preview
                    $topPreview = ''
                    try {
                        $top = @()
                        for ($i = 0; $i -lt [Math]::Min(2, $this.Completions.Count); $i++) { $top += $this.Completions[$i] }
                        if ($top.Count -gt 0) { $topPreview = ' ‚Ä¢ ' + ($top -join '  ') }
                    } catch {}
                    $status = "  $mode$prefix ‚Ä¢ $total suggestions$topPreview"
                    if ($desc) { $status += " ‚Äî $desc" }
                    Write-Host -NoNewline $status -ForegroundColor DarkCyan
                    Write-DebugLog ("UI: Indicator status='" + $status + "'")
                    try { $st2 = if ($this.LastState) { $this.LastState } else { $this.Parser.ParseBufferToState($this.Buffer, $this.CursorPos) }; $this.RenderSyntaxLine($st2) } catch {}
                    Write-Host -NoNewline ([VT]::RestorePos())
                }
            }
        } finally {
            # Ensure cursor returns to input line
            $promptLen = (Get-Prompt).Length
            Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
        }
    }
    
    [string] BuildNewBufferWithCompletion([string] $completion, [CompletionState] $state) {
        "=== BUILDNEWBUFFER START ===" | Write-Debug
        "BUILD: completion='$completion', state.Mode=$($state.Mode), state.OriginalBuffer='$($state.OriginalBuffer)'" | Write-Debug
        try {
            switch ($state.Mode) {
                ([CompletionMode]::Command) { return $completion }
                ([CompletionMode]::Subcommand) {
                    if ($state.CompletedArguments.Count -gt 0) { return ($state.CompletedArguments -join ' ') + ' ' + $completion }
                    return $completion
                }
                ([CompletionMode]::SyntaxDiscovery) {
                    $commandPart = $state.CurrentCommand
                    $base = if ($state.CompletedArguments.Count -gt 0) { "$commandPart $($state.CompletedArguments -join ' ')" } else { $commandPart }
                    if ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#') { return "$base $completion" }
                    return "$base $completion "
                }
                ([CompletionMode]::PrefixCompletion) {
                    $orig = $state.OriginalBuffer
                    $trim = $orig.TrimEnd()
                    $idx = $trim.LastIndexOf(' ')
                    if ($idx -ge 0) {
                        $pre = $trim.Substring(0, $idx + 1)
                        if ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#') { return $pre + $completion }
                        return $pre + $completion + ' '
                    }
                    if ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#') { return $completion }
                    return $completion + ' '
                }
                default {
                    $needsSpace = -not ($completion.EndsWith(':') -or $completion -eq '@' -or $completion -eq '#')
                    if ($state.OriginalBuffer.EndsWith(' ')) {
                        return $state.OriginalBuffer + $completion + ($(if ($needsSpace) { ' ' } else { '' }))
                    }
                    return $state.OriginalBuffer + ' ' + $completion + ($(if ($needsSpace) { ' ' } else { '' }))
                }
            }
        }
        catch {
            "BUILD CATCH: Exception occurred, using fallback" | Write-Debug
            Write-DebugLog ("BuildNewBufferWithCompletion exception: " + $_)
            return $state.OriginalBuffer + ' ' + $completion
        }
        # Final fallback to satisfy static analysis
        return $state.OriginalBuffer
    }
    
    [bool] $SuppressGhostOnce

    [void] AcceptCompletion() {
        $this.InCompletion = $false
        $this.Completions = @()
        $this.CompletionDetails = @()
        $this.CompletionIndex = -1
        $this.SuppressGhostOnce = $true
        
        # Clear HUD status line and restore cursor
        $hud1 = if ($this.HudLine1Row -ge 0) { $this.HudLine1Row } else { $this.InputRow + 1 }
        $promptLen = (Get-Prompt).Length
        Write-Host -NoNewline ([VT]::SavePos())
        Write-Host -NoNewline ([VT]::MoveTo(1, $hud1))
        Write-Host -NoNewline ([VT]::ClearLine())
        Write-Host -NoNewline ([VT]::RestorePos())
        Write-Host -NoNewline ([VT]::MoveTo($promptLen + $this.CursorPos + 1, $this.InputRow))
    }
    
    [void] CancelCompletion() {
        "=== CANCELCOMPLETION START ===" | Write-Debug
        "CANCEL: Before - Buffer='$($this.Buffer)', OriginalInput='$($this.OriginalInput)'" | Write-Debug
        "CANCEL: InCompletion=$($this.InCompletion), CompletionIndex=$($this.CompletionIndex)" | Write-Debug
        
        $this.Buffer = $this.OriginalInput
        $this.CursorPos = $this.Buffer.Length
        $this.InCompletion = $false
        $this.Completions = @()
        $this.CompletionDetails = @()
        $this.CompletionIndex = -1
        
        "CANCEL: After reset - Buffer='$($this.Buffer)', CursorPos=$($this.CursorPos)" | Write-Debug
        "CANCEL: About to redraw line" | Write-Debug
        $this.RedrawLine()
        "CANCEL: COMPLETE" | Write-Debug
    }
    
    [void] RedrawLine() {
        # Redraw anchored input line using VT
        if ($this.InputRow -lt 1) { $this.InputRow = [Console]::CursorTop + 1 }
        $prompt = Get-Prompt
        $promptLen = $prompt.Length
        [VT]::BeginFrame($this.InputRow)
        Write-Host -NoNewline $prompt
        Write-Host -NoNewline $this.Buffer
        
        # Suppress ghost overlay while in completion mode or immediately after accepting a completion
        if (-not $this.InCompletion -and -not $this.SuppressGhostOnce) {
            # Always-on ghost remainder when typing a token
            $state = $this.GetAndCacheState()
            $typedToken = ''
            try {
                if ($state -and -not $state.IsOnNewWord) {
                    if ($state.CurrentToken) { $typedToken = $state.CurrentToken }
                    elseif ($this.Buffer) {
                        $parts = $this.Buffer -split '\\s+'
                        if ($parts.Count -gt 0) { $typedToken = $parts[-1] }
                    }
                }
            } catch {}
            $renderedGhost = $false
            if ($typedToken) {
                try {
                    $cands = @($this.Parser.GetCompletions($this.Buffer, $this.CursorPos))
                    if ($cands.Count -gt 0) {
                        $minScore = 60
                        try { $cfg = [ConfigManager]::Config; if ($cfg -and $cfg.Behavior -and $cfg.Behavior.GhostMinScore) { $minScore = [int]$cfg.Behavior.GhostMinScore } } catch {}
                        $best = Get-BestFuzzyMatch -query $typedToken -candidates $cands -minScore $minScore
                        if ($best) {
                            $ghostColor = 'Gray'
                            try { $cfg = [ConfigManager]::Config; if ($cfg -and $cfg.Colors -and $cfg.Colors.Ghost) { $ghostColor = [string]$cfg.Colors.Ghost } } catch {}
                            if ($best.StartsWith($typedToken)) {
                                $ghost = $best.Substring($typedToken.Length)
                                if ($ghost) { Write-Host -NoNewline $ghost -ForegroundColor $ghostColor; $renderedGhost = $true; Write-DebugLog ("GHOST: remainder token='"+$typedToken+"' best='"+$best+"' scoreMin="+$minScore)
                                }
                            } else {
                                Write-Host -NoNewline " ‚Üí $best" -ForegroundColor $ghostColor; Write-DebugLog ("GHOST: arrow token='"+$typedToken+"' best='"+$best+"' scoreMin="+$minScore)
                                $renderedGhost = $true
                            }
                        }
                    }
                } catch {}
            }
            if (-not $renderedGhost) {
                # Ghost next-token hint when not actively showing remainder
                $hint = $this.GetNextArgGhost($state)
                if ($hint) {
                    $ghostColor = 'Gray'
                    try { $cfg = [ConfigManager]::Config; if ($cfg -and $cfg.Colors -and $cfg.Colors.Ghost) { $ghostColor = [string]$cfg.Colors.Ghost } } catch {}
                    Write-Host -NoNewline $hint -ForegroundColor $ghostColor; Write-DebugLog ("GHOST: hint='"+$hint+"'")
                }
            }
        }
        
        # Position cursor
        [VT]::EndFrame($promptLen + $this.CursorPos + 1, $this.InputRow)
        if ($this.SuppressGhostOnce) { $this.SuppressGhostOnce = $false }
    }

    [void] EnsureHud() {
        try {
            if ($this.HudReserved) { return }
            if ($this.InputRow -lt 1) { $this.InputRow = [Console]::CursorTop + 1 }
            $this.HudLine1Row = $this.InputRow + 1
            $this.HudLine2Row = $this.InputRow + 2
            $this.HudReserved = $true
            Write-DebugLog ("HUD: Reserved at rows " + $this.HudLine1Row + ", " + $this.HudLine2Row)
        } catch { $this.HudReserved = $false }
    }
}

function Get-Prompt {
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        return "todo:$($global:CurrentContext)> "
    }
    return "todo> "
}

function Exit-SmartTUI {
    # Save session stats
    $duration = [Math]::Round(((Get-Date) - $global:SessionStats.SessionStart).TotalMinutes)
    
    Write-Host "`n  üëã SESSION SUMMARY" -ForegroundColor Cyan
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkCyan
    Write-Host "  Duration: ${duration}m" -ForegroundColor White
    Write-Host "  Tasks Added: $($global:SessionStats.TasksAdded)" -ForegroundColor Green
    Write-Host "  Tasks Completed: $($global:SessionStats.TasksCompleted)" -ForegroundColor Green
    Write-Host "  Commands Run: $($global:SessionStats.CommandsRun)" -ForegroundColor Gray
    Write-Host "`n  Goodbye! üöÄ" -ForegroundColor Cyan
    Write-Host ""
    
    exit
}

# === UNIVERSAL PARAMETER EXTRACTION ===
function ConvertFrom-CommandContext {
    param(
        [object]$Context,
        [string]$CommandName
    )
    
    # Handle null context
    if (-not $Context) { return $null }
    
    # Map of ALL commands and their expected parameter types
    $parameterMap = @{
        # Project commands expecting string parameters
        'show project' = 'string'           # expects $projectQuery
        'add project' = 'string'            # expects $projectName
        
        # Filter commands expecting hashtable parameters
        'search' = 'hashtable'              # expects $params hashtable
        'filter' = 'hashtable'              # expects $params hashtable
        
        # Commands expecting no parameters
        'agenda' = 'none'                   # expects no parameters
        'list' = 'none'                     # expects no parameters  
        'today' = 'none'                    # expects no parameters
        
        # Commands expecting context (most commands) - explicitly listed to be complete
        'add' = 'context'
        'done' = 'context'
        'update' = 'context'
        'delete' = 'context'
        'postpone' = 'context'
        'duplicate' = 'context'
        'move' = 'context'
        'note' = 'context'
        'log' = 'context'
        'start timer' = 'context'
        'list time' = 'context'
        'edit time' = 'context'
        'delete time' = 'context'
        'report time' = 'context'
        'add alias' = 'context'
        'remove alias' = 'context'
        'import excel' = 'context'
        'template save' = 'context'
        'template apply' = 'context'
        'recurring add' = 'context'
        'add dep' = 'context'
        'remove dep' = 'context'
        'show dep' = 'context'
        'focus set' = 'context'
        'export' = 'context'
        'import' = 'context'
        'help' = 'context'
        'edit config' = 'context'
        'set config' = 'context'
        'task details' = 'context'
        'task view' = 'context'
        'rename project' = 'context'
        'archive project' = 'context'
        'delete project' = 'context'
        'list projects' = 'context'
        'show project-fields' = 'context'
        'set project-fields' = 'context'
    }
    
    $expectedType = $parameterMap[$CommandName]
    
    switch ($expectedType) {
        'string' {
            # Extract text from context for string parameters
            if ($Context.GetText) {
                return $Context.GetText().Trim()
            } else {
                return ""
            }
        }
        'hashtable' {
            # Create hashtable from context for filter commands
            $params = @{}
            $text = if ($Context.GetText) { $Context.GetText().Trim() } else { "" }
            if ($CommandName -eq 'search' -and $text) {
                $params.Search = $text
            } elseif ($CommandName -eq 'filter' -and $text) {
                # Try to parse as priority filter
                if ($text -match '^p?[0-3]$') {
                    $params.Priority = $text -replace '^p', ''
                } else {
                    $params.Search = $text
                }
            }
            return $params
        }
        'none' {
            # Commands that expect no parameters - return null for splatting
            return @{}
        }
        'context' {
            # Commands that expect the context object directly
            return $Context
        }
        default {
            # Default: return the context object (most commands expect this)
            return $Context
        }
    }
}

# === FUZZY MATCHING UTILITIES ===
function Get-FuzzyMatchScore {
    param(
        [string]$query,
        [string]$candidate
    )
    
    if ([string]::IsNullOrEmpty($query)) { return 0 }
    if ([string]::IsNullOrEmpty($candidate)) { return -1 }
    
    $query = $query.ToLower()
    $candidate = $candidate.ToLower()
    
    # Exact match gets highest score
    if ($candidate -eq $query) { return 100 }
    
    # Starts with gets high score
    if ($candidate.StartsWith($query)) { return 90 }
    
    # Contains gets medium score
    if ($candidate.Contains($query)) { return 70 }
    
    # Character matching for fuzzy search
    $score = 0
    $queryIndex = 0
    $consecutiveBonus = 0
    
    for ($i = 0; $i -lt $candidate.Length -and $queryIndex -lt $query.Length; $i++) {
        if ($candidate[$i] -eq $query[$queryIndex]) {
            $score += 10 + $consecutiveBonus
            $consecutiveBonus += 2  # Bonus for consecutive matches
            $queryIndex++
        } else {
            $consecutiveBonus = 0
        }
    }
    
    # Penalty for unused query characters
    $score -= ($query.Length - $queryIndex) * 5
    
    return $score
}

function Get-BestFuzzyMatch {
    param(
        [string]$query,
        [string[]]$candidates,
        [int]$minScore = 30
    )
    
    $bestMatch = $null
    $bestScore = $minScore
    
    foreach ($candidate in $candidates) {
        $score = Get-FuzzyMatchScore -query $query -candidate $candidate
        if ($score -gt $bestScore) {
            $bestMatch = $candidate
            $bestScore = $score
        }
    }
    
    return $bestMatch
}

# === MAIN ENTRY POINT ===
function Start-TodoistTUI {
    [ConfigManager]::Load()
    
    Clear-Host
    # Header removed per request
    
    # Load context
    $data = Get-TaskData
    $global:CurrentContext = $data.currentContext
    # Generate today's recurring tasks before showing agenda
    try { Generate-RecurringTasks } catch {}
    
    # Show simple agenda
    Show-RichAgenda
    
    # Initialize
    $parser = [SmartCommandParser]::new()
    $inputHandler = [SmartInputHandler]::new($parser)
    $global:smartInputHandler = $inputHandler
    
    # Main loop
    while ($true) {
        try {
            $command = $inputHandler.ReadCommand()
            
            if ($command -eq 'exit' -or $command -eq 'quit' -or $command -eq 'q') {
                Exit-SmartTUI
            }
            
            # NEW: Use structured parsing directly
            $parser.ExecuteStructured($command)
        }
        catch {
            Write-Host "Error: $_" -ForegroundColor Red
            Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
        }
    }
}

# === MISSING FUNCTION IMPLEMENTATIONS ===

function Show-RichAgenda {
    try { Clear-Host } catch {}
    # Ensure recurring tasks are generated
    try { Generate-RecurringTasks } catch {}
    $today = (Get-Date).Date
    $localId = 1
    $global:LastShownTaskMap.Clear(); Ensure-LastShownCapacity

    # Context header with quick stats
    try {
        $ctx = if ($global:CurrentContext) { $global:CurrentContext } else { 'inbox' }
        $allPending = Get-Tasks -Sort
        $pendingCount = ($allPending | Measure-Object).Count
        $overdueCount = (Get-Tasks -Filter 'overdue' -Sort | Measure-Object).Count
        $todayCount = (Get-Tasks -Filter 'today' -Sort | Measure-Object).Count
        Write-Host ("Context: @{0}  ‚Ä¢ Pending: {1}  ‚Ä¢ Overdue: {2}  ‚Ä¢ Today: {3}" -f $ctx, $pendingCount, $overdueCount, $todayCount) -ForegroundColor DarkCyan
        Write-Host "" 
    } catch {}

    # Next actions micro-section (p1/p2 without due)
    try {
        $all = Get-Tasks -Sort
        $nextActions = @($all | Where-Object { (($_.priority -ge 2) -or ($_.priority -eq 0)) -and (-not $_.due) } | Select-Object -First 5)
        if ($nextActions.Count -gt 0) {
            $rows = @()
            foreach ($t in $nextActions) {
                try {
                    Set-LastShownEntry -LocalId $localId -TaskId $t.id
                    $pri = Get-PriorityIcon $t.priority
                    $rows += , @($localId, $pri, $t.text, $t.project)
                    $localId++
                } catch {}
            }
            Format-StyledTable -Headers @('#','Pri','Task','Project') -DataRows $rows -Title '‚úÖ NEXT ACTIONS'
        }
    } catch {}

    # Overdue section
    try {
        $overdue = Get-Tasks -Filter 'overdue' -Sort
        $rows = @()
        foreach ($t in $overdue) {
            try {
                Set-LastShownEntry -LocalId $localId -TaskId $t.id
                $pri = Get-PriorityIcon $t.priority
                $late = ''
                try { if ($t.due) { $late = "{0}d" -f ((($today) - ([datetime]$t.due)).Days) } } catch {}
                $rows += , @($localId, $pri, $t.text, $t.project, $late)
                $localId++
            } catch {}
        }
        Format-StyledTable -Headers @('#','Pri','Task','Project','Late') -DataRows $rows -Title 'üî¥ OVERDUE'
    } catch {}

    # Today section
    try {
        $todayTasks = Get-Tasks -Filter 'today' -Sort
        $rows = @()
        foreach ($t in $todayTasks) {
            try {
                Set-LastShownEntry -LocalId $localId -TaskId $t.id
                $pri = Get-PriorityIcon $t.priority
                $tagDisp = try { if ($t.tags -and $t.tags.Count -gt 0) { $t.tags[0] } else { '' } } catch { '' }
                $rows += , @($localId, $pri, $t.text, $t.project, $tagDisp)
                $localId++
            } catch {}
        }
        Format-StyledTable -Headers @('#','Pri','Task','Project','Tags') -DataRows $rows -Title 'üìÖ TODAY'
    } catch {}

    # Upcoming section (7 days)
    try {
        $upcoming = Get-Tasks -Filter 'upcoming' -Sort
        $rows = @()
        foreach ($t in $upcoming) {
            try {
                Set-LastShownEntry -LocalId $localId -TaskId $t.id
                $pri = Get-PriorityIcon $t.priority
                $dueDisp = try { if ($t.due) { ([datetime]$t.due).ToString('ddd, MMM d') } else { '' } } catch { '' }
                $rows += , @($localId, $pri, $t.text, $t.project, $dueDisp)
                $localId++
            } catch {}
        }
        Format-StyledTable -Headers @('#','Pri','Task','Project','Due') -DataRows $rows -Title 'üìÜ UPCOMING'
    } catch {}
}

function Show-FilteredTasks {
    param([hashtable]$params = @{})
    
    # Normalize filters
    $filter = if ($params.ContainsKey('Filter')) { $params.Filter } else { '' }
    $prio   = if ($params.ContainsKey('Priority')) { [int]$params.Priority } else { -1 }
    $search = if ($params.ContainsKey('Search')) { $params.Search } else { '' }

    $tasks  = Get-Tasks -Filter $filter -Priority $prio -Search $search -Sort

    # Display results using styled table
    Clear-Host
    $title = if ($filter) { "TASKS: $($filter.ToUpper())" } elseif ($prio -ge 0) { "PRIORITY $prio TASKS" } elseif ($search) { "SEARCH: '$search'" } else { "FILTERED TASKS" }

    if ($tasks.Count -eq 0) {
        $rows = @(); $rows += , @('No tasks match the criteria')
        Format-StyledTable -Headers @('Info') -DataRows $rows -Title $title
        return
    }

    $rows = @(); $global:LastShownTaskMap.Clear(); $localId = 1
    foreach ($t in $tasks) {
        Set-LastShownEntry -LocalId $localId -TaskId $t.id
        $pri = Get-PriorityIcon $t.priority
        $due = if ($t.due) { ([datetime]$t.due).ToString('MM/dd') } else { '' }
        $proj = if ($t.project) { $t.project } else { '(none)' }
        $rows += , @($localId, $pri, $t.text, $proj, $due)
        $localId++
    }
    Format-StyledTable -Headers @('#','Pri','Task','Project','Due') -DataRows $rows -Title $title
    Write-Host "  Tip: To log time, type 'log @' and press Tab to cycle projects, or use '#ID1' for codes." -ForegroundColor DarkGray
}

# List all tasks (parity helper)
function Show-AllTasks {
    $params = @{}
    Show-FilteredTasks $params
}

# Summarize all available commands from the parser
function Show-AllCommands {
    $parser = [SmartCommandParser]::new()
    $rows = @()
    foreach ($k in ($parser.Commands.Keys | Sort-Object)) {
        $meta = $parser.Commands[$k]
        $desc = if ($meta -and $meta.ContainsKey('Description')) { $meta.Description } else { '' }
        $rows += , @($k, $desc)
    }
    if ($rows.Count -eq 0) { $rows = @(@('(no commands)','')) }
    Clear-Host
    Format-StyledTable -Headers @('Command','Description') -DataRows $rows -Title 'Available Commands'
}

# Show a small, high-value list of next actions
function Show-NextActions {
    $data = Get-TaskData
    $today = (Get-Date).Date
    $todayStr = $today.ToString('yyyy-MM-dd')
    # Recently completed IDs (last 48h)
    $recentCutoff = (Get-Date).AddDays(-2)
    $recentlyCompleted = @($data.tasks | Where-Object { $_.completed -and [datetime]$_.completed -ge $recentCutoff } | ForEach-Object { $_.id })

    function Get-ActionScore($t) {
        $score = 0
        # Base on priority (p1 highest)
        $p = 0; try { $p = [int]$t.priority } catch {}
        switch ($p) { 1 { $score += 40 } 2 { $score += 20 } 3 { $score += 10 } default { $score += 5 } }
        # Due date proximity
        if ($t.due) {
            try {
                $d=[datetime]$t.due
                $days = ($d - $today).Days
                if ($days -lt 0) { $score += 30 + [Math]::Min(10, -$days) } # overdue boost
                elseif ($days -le 2) { $score += 20 - $days*3 }
                elseif ($days -le 7) { $score += 8 }
            } catch {}
        }
        # Context boost
        if ($t.project -and $t.project -eq $global:CurrentContext) { $score += 10 }
        # Blocked penalty / recently unblocked boost
        $isBlocked = $false
        if ($t.PSObject.Properties['blocked']) { $isBlocked = [bool]$t.blocked }
        if ($isBlocked) { $score -= 25 }
        if ($t.depends -and $t.depends.Count -gt 0) {
            $depAllDone = $true; $depRecent = $false
            foreach ($dep in $t.depends) {
                $depTask = $data.tasks | Where-Object { $_.id -eq $dep } | Select-Object -First 1
                if (-not $depTask -or -not $depTask.done -and $depTask.status -ne 'completed') { $depAllDone = $false }
                if ($recentlyCompleted -contains $dep) { $depRecent = $true }
            }
            if ($depAllDone -and $depRecent) { $score += 20 }
        }
        # Tag signal: #next, #important
        try {
            if ($t.tags) {
                if ($t.tags -contains 'next') { $score += 12 }
                if ($t.tags -contains 'important') { $score += 8 }
            }
        } catch {}
        return $score
    }

    $pending = @($data.tasks | Where-Object { $_.status -eq 'pending' })
    $scored = $pending | ForEach-Object { [PSCustomObject]@{ Task=$_; Score=(Get-ActionScore $_) } }
    $top = @($scored | Sort-Object Score -Descending | Select-Object -First 15)

    $rows = @(); $global:LastShownTaskMap.Clear(); $i=1
    foreach ($s in $top) {
        $t = $s.Task
        Set-LastShownEntry -LocalId $i -TaskId $t.id
        $pri = Get-PriorityIcon $t.priority
        $due = if ($t.due) { try { ([datetime]$t.due).ToString('MM/dd') } catch { '' } } else { '' }
        $proj = if ($t.project) { $t.project } else { '(none)' }
        $rows += , @($i, $pri, $t.text, $proj, $due)
        $i++
    }
    Clear-Host
    Format-StyledTable -Headers @('#','Pri','Task','Project','Due') -DataRows $rows -Title 'NEXT ACTIONS'
}

# Simple productivity snapshot for the current dataset/session
function Show-ProductivityStats {
    $data = Get-TaskData
    $total = @($data.tasks).Count
    $completed = @($data.tasks | Where-Object { $_.status -eq 'completed' }).Count
    $pending = $total - $completed
    $today = (Get-Date).Date.ToString('yyyy-MM-dd')
    $todayDone = @($data.tasks | Where-Object { $_.completed -like "$today*" }).Count
    $timeHrs = 0.0
    foreach ($l in @($data.timelogs)) { try { $timeHrs += ([double]$l.minutes)/60.0 } catch {} }
    Clear-Host
    Write-Host "`n  üìà Productivity Stats" -ForegroundColor Cyan
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkCyan
    Write-Host ("  Tasks: total {0}, pending {1}, completed {2}" -f $total,$pending,$completed) -ForegroundColor White
    Write-Host ("  Completed today: {0}" -f $todayDone) -ForegroundColor Green
    Write-Host ("  Time logged (all): {0:N2} h" -f $timeHrs) -ForegroundColor Yellow
}

# Friendly help overview
function Show-SmartHelp {
    Clear-Host
    Write-Host "`n  Help - Quick Commands" -ForegroundColor Cyan
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkCyan
    Write-Host "  agenda               Show agenda view" -ForegroundColor White
    Write-Host "  add @proj p1 due:‚Ä¶   Add a new task" -ForegroundColor White
    Write-Host "  done <ids>           Complete tasks" -ForegroundColor White
    Write-Host "  list projects        Project dashboard" -ForegroundColor White
    Write-Host "  list tasks           All tasks" -ForegroundColor White
    Write-Host "  list time            Recent time logs" -ForegroundColor White
    Write-Host "  report time ‚Ä¶        Time report" -ForegroundColor White
    Write-Host "  help                 This help" -ForegroundColor White
    Write-Host ""
    Show-AllCommands
}

# Show details for a specific task by id
function Show-TaskDetails {
    param($context)
    $text = $context.GetText()
    if (-not $text) { Write-Host "Usage: view <id>" -ForegroundColor Yellow; return }
    $ids = Resolve-TaskIds -inputString $text
    if ($ids.Count -ne 1) { Write-Host "Please specify a single task id" -ForegroundColor Yellow; return }
    $data = Get-TaskData
    $task = $data.tasks | Where-Object { $_.id -eq $ids[0] } | Select-Object -First 1
    if (-not $task) { Write-Host "Task #$($ids[0]) not found" -ForegroundColor Red; return }
    Clear-Host
    Write-Host ("`n  Task #" + $task.id) -ForegroundColor Cyan
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkCyan
    Write-Host ("  Text:        " + $task.text) -ForegroundColor White
    Write-Host ("  Project:     " + (if($task.project){$task.project}else{'(none)'})) -ForegroundColor White
    Write-Host ("  Priority:    " + (if($task.priority){$task.priority}else{0})) -ForegroundColor White
    Write-Host ("  Due:         " + (if($task.due){$task.due}else{'(none)'})) -ForegroundColor White
    Write-Host ("  Tags:        " + (if($task.tags){$task.tags -join ', '}else{'(none)'})) -ForegroundColor White
    Write-Host ("  Status:      " + (if($task.status){$task.status}else{'pending'})) -ForegroundColor White
    Write-Host ("  Created:     " + (if($task.created){$task.created}else{'(unknown)'})) -ForegroundColor White
    if ($task.completed) { Write-Host ("  Completed:   " + $task.completed) -ForegroundColor Green }
    Write-Host ""
}

# List recent time logs in a simple table
function Show-TimeLogList {
    $data = Get-TaskData
    Clear-Host
    $rows = @()
    if ($data.timelogs) {
        foreach ($log in ($data.timelogs | Sort-Object date, time | Select-Object -Last 50)) {
            $hours = [Math]::Round([double]$log.minutes / 60, 2)
            $rows += , @($log.date, (if($log.time){$log.time}else{''}), $log.project, $hours, (if($log.notes){$log.notes}else{''}))
        }
    }
    Format-StyledTable -Headers @('Date','Time','Project','Hours','Description') -DataRows $rows -Title 'TIME LOGS (recent)'
}

# Project dashboard wrapper (parity shim)
function Show-ProjectDashboard {
    Show-Projects
}

# Edit a time log entry by ID (date/time/project/notes)
function Edit-TimeLog {
    param($context)
    $data = Get-TaskData
    $arg = $context.GetText()
    if (-not $arg -or -not ($arg -match '^\d+$')) { Write-Host "Usage: edit time <id>" -ForegroundColor Yellow; return }
    $id = [int]$arg
    $log = $data.timelogs | Where-Object { $_.id -eq $id } | Select-Object -First 1
    if (-not $log) { Write-Host "Time log #$id not found" -ForegroundColor Red; return }
    Write-Host "Editing time log #$id" -ForegroundColor Cyan
    $newDate = Read-Host ("Date [${($log.date)}]")
    $newTime = Read-Host ("Time [${((if($log.time){$log.time}else{''}))}]")
    $newProj = Read-Host ("Project [${($log.project)}]")
    $newHrs  = Read-Host ("Hours (e.g., 1.5) [${([math]::Round(($log.minutes/60.0),2))}]")
    $newDesc = Read-Host ("Description [${((if($log.notes){$log.notes}else{''}))}]")
    if ($newDate) { $log.date = $newDate }
    if ($newTime) { $log.time = $newTime }
    if ($newProj) { $log.project = $newProj }
    if ($newHrs) {
        try { $mins = [int]([double]$newHrs * 60); $log.minutes = $mins } catch { Write-Host "Invalid hours; keeping current" -ForegroundColor Yellow }
    }
    if ($null -ne $newDesc) { if ($newDesc) { $log.notes = $newDesc } else { $log.PSObject.Properties.Remove('notes') | Out-Null } }
    Save-TaskData $data
    Write-Host "Saved time log #$id" -ForegroundColor Green
}

# Delete a time log entry by ID
function Delete-TimeLog {
    param($context)
    $data = Get-TaskData
    $arg = $context.GetText()
    if (-not $arg -or -not ($arg -match '^\d+$')) { Write-Host "Usage: delete time <id>" -ForegroundColor Yellow; return }
    $id = [int]$arg
    $log = $data.timelogs | Where-Object { $_.id -eq $id } | Select-Object -First 1
    if (-not $log) { Write-Host "Time log #$id not found" -ForegroundColor Red; return }
    $ok = Get-UserConfirmation -Prompt ("Delete time log #$id?") -DefaultYes:$false
    if (-not $ok) { Write-Host "Canceled" -ForegroundColor DarkGray; return }
    $data.timelogs = @($data.timelogs | Where-Object { $_.id -ne $id })
    Save-TaskData $data
    Write-Host "Deleted time log #$id" -ForegroundColor Green
}

function Show-MonthView {
    Clear-Host
    $today = Get-Date
    $year = $today.Year
    $month = $today.Month
    
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Magenta
    $header = (Get-Date -Month $month -Day 1 -Format 'MMMM yyyy').ToUpper()
    Write-Host "  ‚ïë$($header.PadLeft(32 + $header.Length/2).PadRight(60))‚ïë" -ForegroundColor Magenta
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Magenta
    
    # Calendar header
    Write-Host "`n    Sun  Mon  Tue  Wed  Thu  Fri  Sat" -ForegroundColor Cyan
    Write-Host "    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkCyan
    
    # Get first day of month and number of days
    $firstDay = Get-Date -Year $year -Month $month -Day 1
    $daysInMonth = [DateTime]::DaysInMonth($year, $month)
    $startDayOfWeek = [int]$firstDay.DayOfWeek
    
    # Get task data for highlighting days with tasks
    $data = Get-TaskData
    $taskDays = @{}
    foreach ($task in $data.tasks) {
        if ($task.due -and -not $task.completed) {
            try {
                $dueDate = [DateTime]::Parse($task.due)
                if ($dueDate.Year -eq $year -and $dueDate.Month -eq $month) {
                    $taskDays[$dueDate.Day] = $true
                }
            } catch {}
        }
    }
    
    Write-Host "   " -NoNewline
    
    # Add padding for first week
    for ($i = 0; $i -lt $startDayOfWeek; $i++) {
        Write-Host "     " -NoNewline
    }
    
    # Print calendar days
    for ($day = 1; $day -le $daysInMonth; $day++) {
        $dayOfWeek = ($startDayOfWeek + $day - 1) % 7
        
        # Highlight today
        if ($day -eq $today.Day -and $month -eq $today.Month -and $year -eq $today.Year) {
            Write-Host " [$($day.ToString().PadLeft(2))]" -NoNewline -ForegroundColor Yellow
        }
        # Highlight days with tasks
        elseif ($taskDays.ContainsKey($day)) {
            Write-Host "  $($day.ToString().PadLeft(2)) " -NoNewline -ForegroundColor Green
        }
        else {
            Write-Host "  $($day.ToString().PadLeft(2)) " -NoNewline -ForegroundColor White
        }
        
        # New line after Saturday
        if ($dayOfWeek -eq 6) {
            Write-Host ""
            if ($day -lt $daysInMonth) {
                Write-Host "   " -NoNewline
            }
        }
    }
    
    Write-Host "`n"
    Write-Host "  Legend: [Today] " -NoNewline -ForegroundColor Yellow
    Write-Host "Days with tasks " -ForegroundColor Green
    Write-Host ""
    Write-Host "  Tip: To log time, type 'log @' and press Tab to cycle projects, or use '#ID1' for codes." -ForegroundColor DarkGray
}

function Show-WeekView {
    Clear-Host
    $today = (Get-Date).Date
    $start = $today.AddDays(-( [int]$today.DayOfWeek ))
    Write-Host "`n  üìÖ WEEK VIEW" -ForegroundColor Cyan
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkCyan
    Write-Host ("  {0} - {1}" -f $start.ToString('MMM dd'), $start.AddDays(6).ToString('MMM dd')) -ForegroundColor Gray
    Write-Host ""
    $data = Get-TaskData
    for ($d=0; $d -lt 7; $d++) {
        $day = $start.AddDays($d)
        $dateStr = $day.ToString('yyyy-MM-dd')
        $label = $day.ToString('ddd MM/dd')
        $tasks = @($data.tasks | Where-Object { $_.status -eq 'pending' -and $_.due -eq $dateStr })
        Write-Host ("  {0}:" -f $label) -ForegroundColor Yellow
        if ($tasks.Count -eq 0) { Write-Host "    (no tasks)" -ForegroundColor DarkGray; continue }
        $rows = @(); $i=1
        foreach ($t in $tasks | Select-Object -First 10) {
            $rows += , @($i, (Get-PriorityIcon $t.priority), $t.text, (if($t.project){$t.project}else{'(none)'}))
            $i++
        }
        Format-StyledTable -Headers @('#','Pri','Task','Project') -DataRows $rows -Title ''
    }
}

function Show-BlockedTasks {
    $data = Get-TaskData
    $blocked = $data.tasks | Where-Object { 
        $_.dependencies -and $_.dependencies.Count -gt 0 -and -not $_.completed
    }
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Red
    Write-Host "  ‚ïë                      BLOCKED TASKS                         ‚ïë" -ForegroundColor Red
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Red
    
    if ($blocked.Count -eq 0) {
        Write-Host "`n  üéâ No blocked tasks!" -ForegroundColor Green
        return
    }
    
    Write-Host "`n  Found $($blocked.Count) blocked task$(if($blocked.Count -ne 1){'s'}):`n" -ForegroundColor Yellow
    
    foreach ($task in $blocked) {
        Write-Host "  üö´ $($task.text)" -ForegroundColor Red
        Write-Host "     Waiting on: $($task.dependencies -join ', ')" -ForegroundColor DarkRed
        Write-Host ""
    }
}

function Add-Project {
    param($parsed)
    
    $data = Get-TaskData
    
    # Validate name
    if (-not $parsed.Name -or $parsed.Name.Length -eq 0) {
        Write-Host "Project name is required" -ForegroundColor Red
        return
    }
    
    # Check for duplicates
    if ($data.projects | Where-Object { $_.name -eq $parsed.Name }) {
        Write-Host "Project '$($parsed.Name)' already exists." -ForegroundColor Yellow
        return
    }
    
    # Generate smart aliases
    $aliases = Generate-ProjectAliases -name $parsed.Name -existingProjects $data.projects
    
    # Create project
    $newProject = [PSCustomObject]@{
        name = $parsed.Name
        description = if ($parsed.Fields.description) { $parsed.Fields.description } else { "Created $(Get-Date -Format 'yyyy-MM-dd')" }
        aliases = $aliases
        created = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    }
    
    # Add custom fields
    foreach ($key in $parsed.Fields.Keys) {
        if ($key -ne 'description') {
            Add-Member -InputObject $newProject -MemberType NoteProperty -Name $key -Value $parsed.Fields[$key]
        }
    }
    
    $data.projects += $newProject
    Save-TaskData $data
    
    Write-Host "Project '$($parsed.Name)' created." -ForegroundColor Green
    if ($aliases.Count -gt 0) {
        Write-Host "  Shortcuts: $($aliases -join ', ')" -ForegroundColor Gray
    }
}

function Rename-Project {
    param([CommandContext]$context)
    
    $text = $context.GetText()
    $parts = $text -split '\s+', 2
    
    if ($parts.Count -lt 2) {
    Write-Host "‚ùå Usage: rename project <old-name> <new-name>" -ForegroundColor Red
    Write-Host "   Example: rename project work office" -ForegroundColor Gray
        return
    }
    
    $oldName = $parts[0]
    $newName = $parts[1]
    
    $data = Get-TaskData
    $project = $data.projects | Where-Object { $_.name -eq $oldName } | Select-Object -First 1
    
    if (-not $project) {
        Write-Host "‚ùå Project '$oldName' not found" -ForegroundColor Red
        Write-Host "   Available projects: $(@($data.projects | ForEach-Object { $_.name }) -join ', ')" -ForegroundColor Gray
        return
    }
    
    # Check for name conflicts
    if ($data.projects | Where-Object { $_.name -eq $newName -and $_.name -ne $oldName }) {
        Write-Host "‚ùå Project '$newName' already exists" -ForegroundColor Red
        return
    }
    
    # Update project name
    $project.name = $newName
    
    # Update all tasks that reference this project
    $updatedTasks = 0
    foreach ($task in $data.tasks) {
        if ($task.project -eq $oldName) {
            $task.project = $newName
            $updatedTasks++
        }
    }
    
    # Update context if it matches
    if ($global:CurrentContext -eq $oldName) {
        $global:CurrentContext = $newName
        $data.currentContext = $newName
    }
    
    Save-TaskData $data
    Write-Host "‚úÖ Renamed project '$oldName' to '$newName'" -ForegroundColor Green
    if ($updatedTasks -gt 0) {
        Write-Host "   Updated $updatedTasks task$(if($updatedTasks -ne 1){'s'})" -ForegroundColor Gray
    }
}

function Archive-Project {
    param([CommandContext]$context)
    
    $projectName = $context.GetText().Trim()
    
    if ([string]::IsNullOrWhiteSpace($projectName)) {
    Write-Host "‚ùå Usage: archive project <project-name>" -ForegroundColor Red
    Write-Host "   Example: archive project oldwork" -ForegroundColor Gray
        return
    }
    
    $data = Get-TaskData
    $project = $data.projects | Where-Object { $_.name -eq $projectName } | Select-Object -First 1
    
    if (-not $project) {
        Write-Host "‚ùå Project '$projectName' not found" -ForegroundColor Red
        return
    }
    
    if ($project.isArchived) {
        Write-Host "‚ö†Ô∏è  Project '$projectName' is already archived" -ForegroundColor Yellow
        return
    }
    
    # Check for pending tasks
    $pendingTasks = @($data.tasks | Where-Object { $_.project -eq $projectName -and $_.status -eq 'pending' })
    
    if ($pendingTasks.Count -gt 0) {
        Write-Host "‚ö†Ô∏è  Project '$projectName' has $($pendingTasks.Count) pending task$(if($pendingTasks.Count -ne 1){'s'})" -ForegroundColor Yellow
        $confirm = Get-UserConfirmation -Prompt "Archive anyway? This will hide the project but keep tasks" -DefaultYes:$false
        if (-not $confirm) {
            Write-Host "Archive cancelled" -ForegroundColor Gray
            return
        }
    }
    
    # Archive the project
    $project.isArchived = $true
    $project.archivedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    
    # Clear context if it matches
    if ($global:CurrentContext -eq $projectName) {
        $global:CurrentContext = 'inbox'
        $data.currentContext = 'inbox'
    }
    
    Save-TaskData $data
    Write-Host "‚úÖ Archived project '$projectName'" -ForegroundColor Green
    Write-Host "   Use 'list projects --archived' to view archived projects" -ForegroundColor Gray
}

function Delete-Project {
    param([CommandContext]$context)
    
    $projectName = $context.GetText().Trim()
    
    if ([string]::IsNullOrWhiteSpace($projectName)) {
    Write-Host "‚ùå Usage: delete project <project-name>" -ForegroundColor Red
    Write-Host "   Example: delete project tempproject" -ForegroundColor Gray
        return
    }
    
    $data = Get-TaskData
    $project = $data.projects | Where-Object { $_.name -eq $projectName } | Select-Object -First 1
    
    if (-not $project) {
        Write-Host "‚ùå Project '$projectName' not found" -ForegroundColor Red
        return
    }
    
    # Prevent deletion of default projects
    if ($projectName -in @('inbox', 'personal', 'work')) {
        Write-Host "‚ùå Cannot delete default project '$projectName'" -ForegroundColor Red
        return
    }
    
    # Count associated data
    $tasks = @($data.tasks | Where-Object { $_.project -eq $projectName })
    $pendingTasks = @($tasks | Where-Object { $_.status -eq 'pending' })
    $timeLogs = @($data.timelogs | Where-Object { $_.project -eq $projectName })
    
    # Show impact
    Write-Host "‚ö†Ô∏è  Deleting project '$projectName' will:" -ForegroundColor Yellow
    if ($tasks.Count -gt 0) {
        Write-Host "   ‚Ä¢ Delete $($tasks.Count) task$(if($tasks.Count -ne 1){'s'}) ($($pendingTasks.Count) pending)" -ForegroundColor Yellow
    }
    if ($timeLogs.Count -gt 0) {
        Write-Host "   ‚Ä¢ Delete $($timeLogs.Count) time log$(if($timeLogs.Count -ne 1){'s'})" -ForegroundColor Yellow
    }
    
    $confirm = Get-UserConfirmation -Prompt "Are you sure? This cannot be undone" -DefaultYes:$false
    if (-not $confirm) {
        Write-Host "Deletion cancelled" -ForegroundColor Gray
        return
    }
    
    # Delete associated data
    $data.tasks = @($data.tasks | Where-Object { $_.project -ne $projectName })
    $data.timelogs = @($data.timelogs | Where-Object { $_.project -ne $projectName })
    
    # Delete project
    $data.projects = @($data.projects | Where-Object { $_.name -ne $projectName })
    
    # Clear context if it matches
    if ($global:CurrentContext -eq $projectName) {
        $global:CurrentContext = 'inbox'
        $data.currentContext = 'inbox'
    }
    
    Save-TaskData $data
    Write-Host "‚úÖ Deleted project '$projectName' and all associated data" -ForegroundColor Green
}

function Show-ProjectStats {
    param($context)
    $projectName = $context.GetText()
    $data = Get-TaskData
    
    $projectTasks = $data.tasks | Where-Object { $_.project -eq $projectName }
    $completed = $projectTasks | Where-Object { $_.completed }
    $pending = $projectTasks | Where-Object { -not $_.completed }
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Blue
    Write-Host "  ‚ïë                   PROJECT: @$($projectName.ToUpper().PadRight(40))‚ïë" -ForegroundColor Blue
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Blue
    
    Write-Host "`n  üìä STATISTICS" -ForegroundColor Yellow
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkYellow
    Write-Host "  Total tasks:     $($projectTasks.Count)" -ForegroundColor White
    Write-Host "  Completed:       $($completed.Count)" -ForegroundColor Green
    Write-Host "  Pending:         $($pending.Count)" -ForegroundColor Red
    
    if ($projectTasks.Count -gt 0) {
        $percent = [math]::Round(($completed.Count / $projectTasks.Count) * 100, 1)
        Write-Host "  Progress:        $percent%" -ForegroundColor Cyan
    }
    
    Write-Host ""
}

function Update-SmartTask {
    param($context)
    $text = $context.GetText().Trim()
    if (-not $text) {
    Write-Host "Usage: update <id> [@project] [p1|p2|p3] [due:<date>] [#tags] <new text>" -ForegroundColor Yellow
        return
    }
    # Split first token as ID(s), rest as update tokens
    $parts = $text -split '\s+', 2
    if ($parts.Count -lt 1) { Write-Host "Usage: update <id> ..." -ForegroundColor Yellow; return }
    $idPart = $parts[0]
    $rest = if ($parts.Count -gt 1) { $parts[1] } else { '' }
    # Handle project change if provided as arg or in rest
    try {
        $projArg = $context.GetArg('project', $null)
    } catch { $projArg = $null }
    if (-not $projArg -and $rest -match '^@(.+)$') { $projArg = $matches[1] }
    if ($projArg) {
        $projName = $projArg.Trim().TrimStart('@')
        $data = Get-TaskData
        $ids = Resolve-TaskIds -inputString $idPart
        foreach ($tid in $ids) {
            $task = $data.tasks | Where-Object { $_.id -eq $tid } | Select-Object -First 1
            if ($task) { $task.project = $projName }
        }
        Save-TaskData $data
        return
    }
    
    if ([string]::IsNullOrWhiteSpace($rest)) {
        Edit-TaskInteractive -IdText $idPart
        Show-RichAgenda
    } else {
        $parsed = @{ Id = $idPart; Text = $rest }
        Update-Task -parsed $parsed
        Show-RichAgenda
    }
}

function Edit-TaskInteractive {
    param([string]$IdText)
    $data = Get-TaskData
    $ids = Resolve-TaskIds -inputString $IdText
    if ($ids.Count -ne 1) { Write-Host "Interactive edit requires exactly one task ID" -ForegroundColor Yellow; return }
    $task = $data.tasks | Where-Object { $_.id -eq $ids[0] } | Select-Object -First 1
    if (-not $task) { Write-Host "Task not found" -ForegroundColor Red; return }
    
    Write-Host "Editing task #$($task.id)" -ForegroundColor Cyan
    $newText = Read-Host ("Text [{0}]" -f $task.text)
    $newProj = Read-Host ("Project [{0}]" -f (if($task.project){$task.project}else{'(none)'}))
    $newPri  = Read-Host ("Priority (0-3) [{0}]" -f (if($task.priority){$task.priority}else{0}))
    $newDue  = Read-Host ("Due (YYYY-MM-DD/today/yesterday/none) [{0}]" -f (if($task.due){$task.due}else{'(none)'}))
    $newTags = Read-Host ("Tags (comma-separated) [{0}]" -f (if($task.tags){$task.tags -join ', '}else{''}))
    
    if ($newText) { $task.text = $newText }
    if ($newProj) {
        if ($newProj -ne '(none)') {
            $p = Find-Project -query $newProj -Interactive:$false
            if ($p) { $task.project = $p.name } else { Write-Host "Unknown project: $newProj (keeping current)" -ForegroundColor Yellow }
        } else { $task.project = $null }
    }
    if ($newPri -match '^[0-3]$') { $task.priority = [int]$newPri }
    if ($newDue) {
        if ($newDue -match '^(?i)none$') { $task.due = $null }
        else {
            $pd = Parse-NaturalDate -input $newDue
            if ($pd) { $task.due = $pd } else { Write-Host "Invalid due date; keeping current" -ForegroundColor Yellow }
        }
    }
    if ($newTags -ne $null) {
        $trimmed = $newTags.Trim()
        if ($trimmed) { $task.tags = @($trimmed -split '\s*,\s*') } else { $task.tags = @() }
    }
    Save-TaskData $data
    Write-Host "Saved changes for #$($task.id)" -ForegroundColor Green
}

function Add-TaskNote {
    param($context)
    $noteText = $context.GetText()
    
    Write-Host "`n  üìù Note added: '$noteText'" -ForegroundColor Cyan
    Write-Host "  (Note system not fully implemented)" -ForegroundColor Yellow
}

function Postpone-Task {
    param($context)
    $text = $context.GetText()
    if (-not $text) { Write-Host "Usage: postpone <id> <+Nd|tomorrow|YYYY-MM-DD>" -ForegroundColor Yellow; return }
    $parts = $text -split '\s+', 2
    if ($parts.Count -lt 2) { Write-Host "Usage: postpone <id> <+Nd|tomorrow|YYYY-MM-DD>" -ForegroundColor Yellow; return }
    $ids = Resolve-TaskIds -inputString $parts[0]
    try {
        if ($context -and $context.Args -and $context.Args.ContainsKey('id')) {
            $ids = Resolve-TaskIds -inputString $context.Args['id']
        }
    } catch {}
    # Prefer structured args if provided
    try {
        if ($context -and $context.Args -and $context.Args.ContainsKey('id')) {
            $ids = Resolve-TaskIds -inputString $context.Args['id']
        }
    } catch {}
    if ($ids.Count -eq 0) { Write-Host "Invalid task id" -ForegroundColor Red; return }
    $delta = $parts[1]
    try { $argDelta = $context.GetArg('delta', $null); if ($argDelta) { $delta = $argDelta } } catch {}
    $data = Get-TaskData
    foreach ($id in $ids) {
        $task = $data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1
        if (-not $task) { continue }
        $base = if ($task.due) { [datetime]$task.due } else { (Get-Date).Date }
        $newDue = $null
        if ($delta -match '^\+(\d+)d$') { $newDue = $base.AddDays([int]$matches[1]) }
        elseif ($delta -match '^(?i)tomorrow$') { $newDue = (Get-Date).Date.AddDays(1) }
        else { try { $newDue = [datetime]::ParseExact($delta,'yyyy-MM-dd',$null) } catch { $newDue = $null } }
        if ($newDue) { $task.due = $newDue.ToString('yyyy-MM-dd'); Write-Host "Postponed #$id to $($task.due)" -ForegroundColor Yellow }
    }
    Save-TaskData $data
    Show-RichAgenda
}

    function Move-Task {
        param($context)
        # Parse from structured args first
        $idText = $context.GetArg('id', $null)
        $projName = $context.GetArg('project', $null)
    # Fallback to free text tokens
    if (-not $idText -or -not $projName) {
        $free = @($context.FreeText)
        if (-not $idText -and $free.Count -gt 0) { $idText = $free[0] }
        if (-not $projName) {
            $projToken = $free | Where-Object { $_ -match '^@' } | Select-Object -First 1
            if ($projToken) { $projName = ($projToken -replace '^@','') }
        }
    }
        if (-not $idText -or -not $projName) { Write-Host "Usage: move <id> @project" -ForegroundColor Yellow; return }
        $ids = @(Resolve-TaskIds -inputString $idText)
        if (-not $ids -or $ids.Count -eq 0) { Write-Host "Invalid task id" -ForegroundColor Red; return }
    $projName = $projName.Trim().TrimStart('@')
    $proj = Find-Project -query $projName -Interactive:$false
    $destName = if ($proj) { $proj.name } else { $projName }
    $data = Get-TaskData
    foreach ($id in $ids) {
        $task = $data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1
        if ($task) { $task.project = $destName; Write-Host "Moved #$id to @$destName" -ForegroundColor Yellow }
    }
    try { Save-TaskData $data } catch {}
    # Force write to disk as a safety net
    try { $data | ConvertTo-Json -Depth 10 | Set-Content -Path $global:TaskFile -Encoding UTF8 } catch {}
}

function Duplicate-Task {
    param($context)
    $text = $context.GetText()
    if (-not $text) { Write-Host "Usage: duplicate <id> [new text] [+Nd]" -ForegroundColor Yellow; return }
    $parts = $text -split '\s+', 3
    $id = (Resolve-TaskIds -inputString $parts[0]) | Select-Object -First 1
    if (-not $id) { Write-Host "Invalid task id" -ForegroundColor Red; return }
    $data = Get-TaskData
    $orig = $data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1
    if (-not $orig) { Write-Host "Task #$id not found" -ForegroundColor Red; return }
    $newId = Get-NextTaskId $data
    $copy = @{}
    $orig.PSObject.Properties | ForEach-Object { if ($_.Name -ne 'id' -and $_.Name -ne 'completed') { $copy[$_.Name] = $_.Value } }
    $copy.id = $newId
    $copy.status = 'pending'
    $newText = if ($parts.Count -gt 1) { $parts[1] } else { '' }
    $maybeOffset = if ($parts.Count -gt 2) { $parts[2] } else { '' }
    if ($newText) { $copy.text = $newText }
    if ($maybeOffset -match '^\+(\d+)d$') {
        if ($copy.due) { $copy.due = ([datetime]$copy.due).AddDays([int]$matches[1]).ToString('yyyy-MM-dd') }
    }
    $data.tasks += $copy
    Save-TaskData $data
    Write-Host "Duplicated #$id -> #$newId" -ForegroundColor Green
    Show-AllTasks
}

function Start-Timer {
    param($context)
    
    $project = if ($context) { $context.GetArg('project', $global:CurrentContext) } else { $global:CurrentContext }
    if (-not $project) { $project = 'inbox' }
    
    $description = if ($context) { $context.GetArg('desc', '') } else { '' }
    if (-not $description) {
        # Avoid prompt in non-interactive mode
        try { [ConfigManager]::Load() } catch {}
        $cfg = $null; try { $cfg = [ConfigManager]::Config } catch {}
        $nonInteractive = $false
        try { if ($cfg -and $cfg.Behavior) { $nonInteractive = [bool]$cfg.Behavior.NonInteractive } } catch {}
        if (-not $nonInteractive) {
            $description = Read-Host "Timer description (optional)"
        }
    }
    
    $data = Get-TaskData
    if (-not (Get-Variable -Name SessionTimerLogs -Scope Global -ErrorAction SilentlyContinue)) { $global:SessionTimerLogs = @() }
    if (-not ($data.PSObject.Properties['timer'])) { Add-Member -InputObject $data -MemberType NoteProperty -Name timer -Value @{} }
    
    # Stop existing timer if running
    if ($data.timer.active) {
        Stop-Timer -silent
    }
    
    $data.timer = @{
        active = $true
        project = $project
        description = $description
        startTime = Get-Date
        startTimeString = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    }
    
    Save-TaskData $data -NoUndo
    
    Write-Host "‚è±Ô∏è  Timer started for project '$project'" -ForegroundColor Green
    if ($description) {
        Write-Host "   Description: $description" -ForegroundColor Gray
    }
    Write-Host "   Started at: $($data.timer.startTimeString)" -ForegroundColor Gray
}

function Stop-Timer {
    param([switch]$silent)
    
    $data = Get-TaskData
    
    if (-not $data.timer -or -not $data.timer.active) {
        if (-not $silent) {
            Write-Host "No active timer" -ForegroundColor Yellow
        }
        return
    }
    
    $endTime = Get-Date
    $startTime = [DateTime]$data.timer.startTime
    $duration = $endTime - $startTime
    $minutes = [Math]::Round($duration.TotalMinutes, 1)
    
    # Build session-only time record (do not persist to timelogs)
    $timeLog = @{
        project = $data.timer.project
        description = $data.timer.description
        date = $endTime.ToString("yyyy-MM-dd")
        startTime = $data.timer.startTimeString
        endTime = $endTime.ToString("yyyy-MM-dd HH:mm:ss")
        minutes = $minutes
        duration = "$($duration.Hours)h $($duration.Minutes)m"
        id = [System.Guid]::NewGuid().ToString()
    }
    # Track only for this session (not persisted, not included in reports)
    if (-not (Get-Variable -Name SessionTimerLogs -Scope Global -ErrorAction SilentlyContinue)) { $global:SessionTimerLogs = @() }
    $global:SessionTimerLogs += $timeLog
    
    # Clear timer
    $data.timer = @{ active = $false }
    
    # Do not persist session timer entries to timelogs or CSV
    Save-TaskData $data -NoUndo
    
    if (-not $silent) {
        Write-Host "‚è±Ô∏è  Timer stopped" -ForegroundColor Green
        Write-Host "   Project: $($timeLog.project)" -ForegroundColor Gray
        Write-Host "   Duration: $($timeLog.duration) ($minutes minutes)" -ForegroundColor Gray
        Write-Host "   Time logged successfully" -ForegroundColor Green
    }
}

function Show-TimerStatus {
    $data = Get-TaskData
    
    Write-Host "`n‚è±Ô∏è  TIMER STATUS" -ForegroundColor Yellow
    
    if (-not $data.timer -or -not $data.timer.active) {
        Write-Host "  No active timer" -ForegroundColor Gray
        Write-Host "`n  Start timer with: start timer [project] [description]" -ForegroundColor Gray
        return
    }
    
    $startTime = [DateTime]$data.timer.startTime
    $currentTime = Get-Date
    $elapsed = $currentTime - $startTime
    
    Write-Host "  Status: RUNNING" -ForegroundColor Green
    Write-Host "  Project: $($data.timer.project)" -ForegroundColor White
    if ($data.timer.description) {
        Write-Host "  Description: $($data.timer.description)" -ForegroundColor Gray
    }
    Write-Host "  Started: $($data.timer.startTimeString)" -ForegroundColor Gray
    Write-Host "  Elapsed: $($elapsed.Hours)h $($elapsed.Minutes)m $($elapsed.Seconds)s" -ForegroundColor Cyan
    
    Write-Host "`n  Stop timer with: timer stop" -ForegroundColor Gray
}

function Show-ProfessionalReport {
    param($context)
    
    $period = if ($context) { $context.GetArg('period', 'week') } else { 'week' }
    $data = Get-TaskData
    $today = (Get-Date).Date
    
    # Calculate date range
    $startDate = switch ($period.ToLower()) {
        'day' { $today }
        'week' { $today.AddDays(-[int]$today.DayOfWeek) }
        'month' { $today.AddDays(-$today.Day + 1) }
        'quarter' { 
            $quarter = [Math]::Ceiling($today.Month / 3)
            $startMonth = ($quarter - 1) * 3 + 1
            (Get-Date -Year $today.Year -Month $startMonth -Day 1).Date
        }
        default { $today.AddDays(-7) }
    }
    
    $endDate = $today.AddDays(1)
    
    # Task completion statistics
    $completedTasks = @($data.tasks | Where-Object { 
        $_.done -and $_.completed -and 
        [datetime]$_.completed -ge $startDate -and [datetime]$_.completed -lt $endDate
    })
    
    $totalTasks = @($data.tasks | Where-Object { 
        [datetime]$_.created -ge $startDate -and [datetime]$_.created -lt $endDate
    })
    
    # Time tracking
    $timeLogs = @($data.timelogs | Where-Object {
        [datetime]$_.date -ge $startDate -and [datetime]$_.date -lt $endDate
    })
    
    $totalMinutes = ($timeLogs | Measure-Object minutes -Sum).Sum
    $totalHours = [Math]::Round($totalMinutes / 60, 1)
    $avgSession = if ($timeLogs.Count -gt 0) { [Math]::Round($totalMinutes / $timeLogs.Count, 1) } else { 0 }

    # Overview tables
    $periodRows = @(); $periodRows += , @('Start', $startDate.ToString('yyyy-MM-dd')); $periodRows += , @('End', $today.ToString('yyyy-MM-dd'))
    Format-StyledTable -Headers @('Metric','Value') -DataRows $periodRows -Title ("üìà PROFESSIONAL REPORT (" + $period + ")")

    $taskRows = @(); $taskRows += , @('Tasks Created', $totalTasks.Count); $taskRows += , @('Tasks Completed', $completedTasks.Count); $taskRows += , @('Completion Rate', (if ($totalTasks.Count -gt 0) { [Math]::Round(($completedTasks.Count / $totalTasks.Count) * 100, 1) } else { 0 }).ToString() + '%')
    Format-StyledTable -Headers @('Task Metric','Value') -DataRows $taskRows -Title 'TASK COMPLETION'

    $timeRows = @(); $timeRows += , @('Total Hours', $totalHours); $timeRows += , @('Time Entries', $timeLogs.Count); $timeRows += , @('Avg Session (min)', $avgSession)
    Format-StyledTable -Headers @('Time Metric','Value') -DataRows $timeRows -Title 'TIME TRACKING'

    # Project breakdown
    $projectTime = $timeLogs | Group-Object project | ForEach-Object {
        [PSCustomObject]@{
            Project = $_.Name
            Hours = [Math]::Round(($_.Group | Measure-Object minutes -Sum).Sum / 60, 1)
            Sessions = $_.Count
        }
    } | Sort-Object Hours -Descending | Select-Object -First 5
    
    if ($projectTime) {
        $rows = @(); foreach ($p in $projectTime) { $rows += , @($p.Project, $p.Sessions, $p.Hours) }
        Format-StyledTable -Headers @('Project','Entries','Total Hours') -DataRows $rows -Title 'TOP PROJECTS (by time)'
    }
}

function Show-DetailedReport {
    param($context)
    
    $data = Get-TaskData
    $today = (Get-Date).Date
    
    # Overall statistics
    $allTasks = $data.tasks
    $completedTasks = @($allTasks | Where-Object { $_.done })
    $pendingTasks = @($allTasks | Where-Object { -not $_.done })
    $rate = if ($allTasks.Count -gt 0) { [Math]::Round(($completedTasks.Count / $allTasks.Count) * 100, 1) } else { 0 }
    $overall = @();
    $overall += , @('Total Tasks', $allTasks.Count)
    $overall += , @('Completed', $completedTasks.Count)
    $overall += , @('Pending', $pendingTasks.Count)
    $overall += , @('Completion Rate', "$rate%")
    Format-StyledTable -Headers @('Metric','Value') -DataRows $overall -Title 'üìä OVERALL STATISTICS'

    # Priority breakdown
    $priorityStats = $allTasks | Group-Object { if ($_.priority) { "p$($_.priority)" } else { "none" } } | Sort-Object Name
    $priRows = @()
    foreach ($grp in $priorityStats) {
        $c = @($grp.Group | Where-Object { $_.done }).Count
        $t = $grp.Count
        $r = if ($t -gt 0) { [Math]::Round(($c / $t) * 100, 1) } else { 0 }
        $priRows += , @($grp.Name, "$c/$t", "$r%")
    }
    if ($priRows.Count -gt 0) { Format-StyledTable -Headers @('Priority','Completed/Total','Rate') -DataRows $priRows -Title 'üéØ PRIORITY BREAKDOWN' }

    # Project performance
    $projPerf = $allTasks | Where-Object { $_.project } | Group-Object project | ForEach-Object {
        $c = @($_.Group | Where-Object { $_.done }).Count
        $t = $_.Count
        $r = if ($t -gt 0) { [Math]::Round(($c / $t) * 100, 1) } else { 0 }
        [PSCustomObject]@{ Project = $_.Name; Total = $t; Completed = $c; Rate = $r }
    } | Sort-Object Rate -Descending
    if ($projPerf) {
        $rows = @()
        foreach ($p in ($projPerf | Select-Object -First 10)) { $rows += , @($p.Project, $p.Completed, $p.Total, "$($p.Rate)%") }
        Format-StyledTable -Headers @('Project','Completed','Total','Rate') -DataRows $rows -Title 'üìÅ PROJECT PERFORMANCE'
    }

    # Overdue analysis
    $overdueTasks = @($pendingTasks | Where-Object { $_.due -and [datetime]$_.due -lt $today })
    $overRows = @()
    $overRows += , @('Overdue Count', $overdueTasks.Count)
    $oldestOverdue = $null
    if ($overdueTasks.Count -gt 0) {
        $oldestOverdue = $overdueTasks | Sort-Object due | Select-Object -First 1
        if ($oldestOverdue) { $daysPast = ($today - [datetime]$oldestOverdue.due).Days; $overRows += , @('Oldest (days)', $daysPast) }
    }
    Format-StyledTable -Headers @('Metric','Value') -DataRows $overRows -Title '‚è∞ OVERDUE ANALYSIS'

    # Productivity trends (last 30 days)
    $last30Days = $today.AddDays(-30)
    $recentCompletions = @($completedTasks | Where-Object { $_.completed -and [datetime]$_.completed -ge $last30Days })
    $trendRows = @(); $trendRows += , @('Recent Completions', $recentCompletions.Count); $trendRows += , @('Daily Average', [Math]::Round($recentCompletions.Count / 30, 1))
    Format-StyledTable -Headers @('Trend','Value') -DataRows $trendRows -Title 'üìà PRODUCTIVITY TRENDS (30 days)'

    # Time analysis
    $totalTimeMinutes = ($data.timelogs | Measure-Object minutes -Sum).Sum
    $totalTimeHours = [Math]::Round($totalTimeMinutes / 60, 1)
    $timeRows = @();
    $timeRows += , @('Total Logged', "${totalTimeHours} h")
    $timeRows += , @('Time Entries', ($data.timelogs ? $data.timelogs.Count : 0))
    if ($data.timelogs -and $data.timelogs.Count -gt 0) { $avgSession = [Math]::Round($totalTimeMinutes / $data.timelogs.Count, 1); $timeRows += , @('Avg Session', "$avgSession min") }
    Format-StyledTable -Headers @('Time','Value') -DataRows $timeRows -Title '‚è± TIME ANALYSIS'
}

# (Consolidated) Show-Templates implemented later; remove stub

function Add-RecurringTask {
    param($context)
    $txt = ($context.GetText()).Trim()
    if (-not $txt) {
        Write-Host "Usage: recurring add <pattern> <task text> [@project] [p1-3] [#tags]" -ForegroundColor Yellow
        Write-Host "Patterns: daily | weekdays | weekly:<Mon..Sun> | monthly:<1-31>" -ForegroundColor Gray
        return
    }
    $pattern = ''
    if ($txt -match '^(daily|weekdays)\s+(.*)$') { $pattern=$matches[1]; $body=$matches[2] }
    elseif ($txt -match '^(weekly:(\w+))\s+(.*)$') { $pattern=$matches[1]; $body=$matches[3] }
    elseif ($txt -match '^(monthly:(\d{1,2}))\s+(.*)$') { $pattern=$matches[1]; $body=$matches[3] }
    else { Write-Host "Invalid pattern. Use daily|weekdays|weekly:<day>|monthly:<day>" -ForegroundColor Red; return }
    $data = Get-TaskData
    if (-not $data.recurringTemplates) { $data | Add-Member -NotePropertyName recurringTemplates -NotePropertyValue @() -Force }
    $tmpl = [pscustomobject]@{ pattern=$pattern; body=$body; created=(Get-Date).ToString('s'); lastGenerated='' }
    $data.recurringTemplates += $tmpl
    Save-TaskData $data
    Write-Host "Added recurring task: $pattern ‚Üí $body" -ForegroundColor Green
}

function Should-GenerateForToday([string]$pattern) {
    $today = (Get-Date).Date
    if ($pattern -eq 'daily') { return $true }
    if ($pattern -eq 'weekdays') { return ($today.DayOfWeek -ne 'Saturday' -and $today.DayOfWeek -ne 'Sunday') }
    if ($pattern -match '^weekly:(\w+)$') { return ($today.DayOfWeek.ToString().ToLower() -eq $matches[1].ToLower()) }
    if ($pattern -match '^monthly:(\d{1,2})$') { return ($today.Day -eq [int]$matches[1]) }
    return $false
}

function Generate-RecurringTasks {
    $data = Get-TaskData
    if (-not $data.recurringTemplates) { return }
    $today = (Get-Date).Date
    $todayStr = $today.ToString('yyyy-MM-dd')
    foreach ($rt in @($data.recurringTemplates)) {
        try {
            if (-not (Should-GenerateForToday $rt.pattern)) { continue }
            if ($rt.lastGenerated -eq $todayStr) { continue }
            # Parse body using existing Extract-Metadata for fields
            $md = Extract-Metadata -text $rt.body
            $proj = if ($md.Project) { $md.Project } else { $global:CurrentContext }
            $pri = if ($md.Priority) { $md.Priority } else { 0 }
            $task = @{
                id = Get-NextTaskId $data
                text = $md.CleanText
                project = $proj
                priority = $pri
                status = 'pending'
                created = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
                due = $todayStr
            }
            if ($md.Tags -and $md.Tags.Count -gt 0) { $task.tags = $md.Tags }
            $data.tasks += $task
            $rt.lastGenerated = $todayStr
        } catch {}
    }
    Save-TaskData $data
}

function Show-RecurringTasks {
    $data = Get-TaskData
    $list = @($data.recurringTemplates)
    Clear-Host
    if (-not $list -or $list.Count -eq 0) { Write-Host "No recurring tasks configured" -ForegroundColor Yellow; return }
    $rows=@(); $i=1
    foreach ($r in $list) { $rows += , @($i, $r.pattern, $r.body, (if($r.lastGenerated){$r.lastGenerated}else{''})) ; $i++ }
    Format-StyledTable -Headers @('#','Pattern','Body','Last Gen') -DataRows $rows -Title 'RECURRING TASKS'
}

function Add-SmartDependency {
    param($context)
    $text = $context.GetText()
    $ids = $text -split '\s+'
    if ($ids.Count -lt 2) { Write-Host "Usage: add dep <task> <depends-on>" -ForegroundColor Yellow; return }
    $data = Get-TaskData
    $a = (Resolve-TaskIds -inputString $ids[0]) | Select-Object -First 1
    $b = (Resolve-TaskIds -inputString $ids[1]) | Select-Object -First 1
    if (-not $a -or -not $b) { Write-Host "Invalid task IDs" -ForegroundColor Red; return }
    $task = $data.tasks | Where-Object { $_.id -eq $a } | Select-Object -First 1
    if (-not $task) { Write-Host "Task #$a not found" -ForegroundColor Red; return }
    if (-not $task.depends) { $task.depends = @() }
    # Prevent self-dependency and simple cycles
    if ($a -eq $b) { Write-Host "Cannot depend on itself" -ForegroundColor Red; return }
    # Detect cycle: if b (directly or indirectly) depends on a
    function _HasPath($start, $target, $visited) {
        if ($visited -contains $start) { return $false }
        $visited += $start
        $t = $data.tasks | Where-Object { $_.id -eq $start } | Select-Object -First 1
        if (-not $t -or -not $t.depends) { return $false }
        foreach ($n in $t.depends) {
            if ($n -eq $target) { return $true }
            if (_HasPath $n $target $visited) { return $true }
        }
        return $false
    }
    if (_HasPath $b $a @()) { Write-Host "Adding this dependency would create a cycle" -ForegroundColor Red; return }
    $preBlocked = @($data.tasks | Where-Object { $_.blocked })
    if ($task.depends -notcontains $b) { $task.depends += $b }
    Update-BlockedStatus -data $data
    $postBlocked = @($data.tasks | Where-Object { $_.blocked })
    Save-TaskData $data
    $delta = ($postBlocked.Count - $preBlocked.Count)
    Write-Host "Added dependency: #$a depends on #$b" -ForegroundColor Green
    if ($delta -gt 0) { Write-Host "  üîí $delta task(s) became blocked" -ForegroundColor Yellow }
}

function Remove-SmartDependency {
    param($context)
    $text = $context.GetText()
    $ids = $text -split '\s+'
    if ($ids.Count -lt 2) { Write-Host "Usage: remove dep <task> <depends-on>" -ForegroundColor Yellow; return }
    $data = Get-TaskData
    $a = (Resolve-TaskIds -inputString $ids[0]) | Select-Object -First 1
    $b = (Resolve-TaskIds -inputString $ids[1]) | Select-Object -First 1
    if (-not $a -or -not $b) { Write-Host "Invalid task IDs" -ForegroundColor Red; return }
    $task = $data.tasks | Where-Object { $_.id -eq $a } | Select-Object -First 1
    if (-not $task -or -not $task.depends) { Write-Host "No such dependency found" -ForegroundColor Yellow; return }
    $preBlocked = @($data.tasks | Where-Object { $_.blocked })
    $task.depends = @($task.depends | Where-Object { $_ -ne $b })
    Update-BlockedStatus -data $data
    $postBlocked = @($data.tasks | Where-Object { $_.blocked })
    Save-TaskData $data
    Write-Host "Removed dependency: #$a no longer depends on #$b" -ForegroundColor Green
    $delta = ($preBlocked.Count - $postBlocked.Count)
    if ($delta -gt 0) { Write-Host "  üîì $delta task(s) became unblocked" -ForegroundColor Green }
}

function Show-Dependencies {
    param($context)
    $text = if ($context) { $context.GetText() } else { '' }
    if (-not $text) { Write-Host "Usage: show dep <task>" -ForegroundColor Yellow; return }
    $data = Get-TaskData
    $id = (Resolve-TaskIds -inputString $text) | Select-Object -First 1
    if (-not $id) { Write-Host "Invalid task ID" -ForegroundColor Red; return }
    $task = $data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1
    if (-not $task) { Write-Host "Task #$id not found" -ForegroundColor Red; return }
    $rows = @()
    $depends = if ($task.depends) { $task.depends } else { @() }
    foreach ($d in $depends) {
        $t = $data.tasks | Where-Object { $_.id -eq $d } | Select-Object -First 1
        $rows += , @($d, (if($t){$t.text}else{'(missing)'}))
    }
    if ($rows.Count -eq 0) { $rows = @(@('(none)','')) }
    Format-StyledTable -Headers @('Depends On','Text') -DataRows $rows -Title ("DEPENDENCIES FOR #" + $id)
}

function Show-DependencyGraph {
    $data = Get-TaskData
    $rows = @()
    foreach ($t in $data.tasks) {
        if ($t.depends -and $t.depends.Count -gt 0) {
            $rows += , @($t.id, ($t.depends -join ', '), $t.text)
        }
    }
    if ($rows.Count -eq 0) { $rows = @(@('(none)','', '')) }
    Format-StyledTable -Headers @('Task','# Depends','Text') -DataRows $rows -Title 'DEPENDENCY GRAPH (simple)'
}

function Set-SmartFocus {
    param($context)
    $focusText = $context.GetText()
    
    Write-Host "`n  üéØ Focus set: '$focusText'" -ForegroundColor Yellow
    Write-Host "  (Focus system not implemented)" -ForegroundColor Gray
}

# (Consolidated) Detailed Show-ContextInfo is defined later; remove stub

function Show-BurndownChart {
    $data = Get-TaskData
    $today = (Get-Date).Date
    
    Write-Host "`nüìâ BURNDOWN CHART (Last 14 Days)" -ForegroundColor Green
    Write-Host "=" * 50 -ForegroundColor Gray
    
    # Calculate burndown data for last 14 days
    $burndownData = @()
    for ($i = 13; $i -ge 0; $i--) {
        $date = $today.AddDays(-$i)
        $dateStr = $date.ToString("yyyy-MM-dd")
        
        # Tasks remaining at end of day
        $remaining = @($data.tasks | Where-Object { 
            [datetime]$_.created -le $date.AddDays(1) -and
            (-not $_.done -or ($_.completed -and [datetime]$_.completed -gt $date.AddDays(1)))
        }).Count
        
        # Tasks completed on this day
        $completedToday = @($data.tasks | Where-Object {
            $_.done -and $_.completed -and
            [datetime]$_.completed -ge $date -and [datetime]$_.completed -lt $date.AddDays(1)
        }).Count
        
        $burndownData += [PSCustomObject]@{
            Date = $date
            DateStr = $date.ToString("MM-dd")
            Remaining = $remaining
            Completed = $completedToday
        }
    }
    
    # Find max for scaling
    $maxRemaining = ($burndownData | Measure-Object Remaining -Maximum).Maximum
    $maxCompleted = ($burndownData | Measure-Object Completed -Maximum).Maximum
    
    if ($maxRemaining -eq 0) {
        Write-Host "`nNo task data available for burndown chart" -ForegroundColor Yellow
        return
    }
    
    # Combined chart: Remaining + Completions on one line per date
    Write-Host "`nRemaining | Completions" -ForegroundColor Yellow
    foreach ($point in $burndownData) {
        $remLen = if ($maxRemaining -gt 0) { [Math]::Floor(($point.Remaining / $maxRemaining) * 30) } else { 0 }
        $remBar = "‚ñà" * $remLen + "‚ñë" * (30 - $remLen)
        $remColor = if ($point.Remaining -gt 20) { "Red" } elseif ($point.Remaining -gt 10) { "Yellow" } else { "Green" }

        $compLen = if ($maxCompleted -gt 0) { [Math]::Floor(($point.Completed / $maxCompleted) * 10) } else { 0 }
        $compBar = if ($compLen -gt 0) { "‚ñà" * $compLen } else { "" }

        # Print date, remaining bar+count, and completions bar+count inline
        Write-Host ("{0}: " -f $point.DateStr) -NoNewline -ForegroundColor Gray
        Write-Host $remBar -NoNewline -ForegroundColor $remColor
        Write-Host (" {0} | " -f $point.Remaining) -NoNewline -ForegroundColor Gray
        if ($compBar.Length -gt 0) { Write-Host $compBar -NoNewline -ForegroundColor Cyan }
        Write-Host (" {0}" -f $point.Completed) -ForegroundColor Cyan
    }
    
    # Summary stats
    $totalCompleted = ($burndownData | Measure-Object Completed -Sum).Sum
    $avgCompleted = [Math]::Round($totalCompleted / 14, 1)
    $currentRemaining = $burndownData[-1].Remaining
    
    Write-Host "`nSUMMARY:" -ForegroundColor White
    Write-Host "  Current Backlog: $currentRemaining tasks" -ForegroundColor Gray
    Write-Host "  Completed (14 days): $totalCompleted tasks" -ForegroundColor Green
    Write-Host "  Daily Average: $avgCompleted tasks/day" -ForegroundColor Cyan
    
    # Table summary for quick scan
    $summaryRows = @()
    $summaryRows += , @('Current Backlog', $currentRemaining)
    $summaryRows += , @('Completed (14d)', $totalCompleted)
    $summaryRows += , @('Avg/Day', $avgCompleted)
    Format-StyledTable -Headers @('Metric','Value') -DataRows $summaryRows -Title 'üìâ BURNDOWN SUMMARY'
    
    if ($avgCompleted -gt 0 -and $currentRemaining -gt 0) {
        $daysToComplete = [Math]::Ceiling($currentRemaining / $avgCompleted)
        Write-Host "  Est. completion: $daysToComplete days" -ForegroundColor Yellow
    }
    
    Write-Host "`n" + ("=" * 50) -ForegroundColor Gray
}

function Show-VelocityChart {
    $data = Get-TaskData
    $today = (Get-Date).Date
    
    Write-Host "`nüìà VELOCITY CHART (Last 8 Weeks)" -ForegroundColor Blue
    Write-Host "=" * 50 -ForegroundColor Gray
    
    # Calculate velocity data for last 8 weeks
    $velocityData = @()
    for ($i = 7; $i -ge 0; $i--) {
        $weekStart = $today.AddDays(-$i * 7 - [int]$today.DayOfWeek)
        $weekEnd = $weekStart.AddDays(7)
        
        # Tasks completed during this week
        $completed = @($data.tasks | Where-Object {
            $_.done -and $_.completed -and
            [datetime]$_.completed -ge $weekStart -and [datetime]$_.completed -lt $weekEnd
        }).Count
        
        # Tasks created during this week
        $created = @($data.tasks | Where-Object {
            [datetime]$_.created -ge $weekStart -and [datetime]$_.created -lt $weekEnd
        }).Count
        
        # Story points (using priority as proxy)
        $storyPoints = ($data.tasks | Where-Object {
            $_.done -and $_.completed -and $_.priority -and
            [datetime]$_.completed -ge $weekStart -and [datetime]$_.completed -lt $weekEnd
        } | Measure-Object { $_.priority } -Sum).Sum
        
        $velocityData += [PSCustomObject]@{
            WeekStart = $weekStart
            WeekLabel = "W$($weekStart.ToString('MM-dd'))"
            Completed = $completed
            Created = $created
            StoryPoints = if ($storyPoints) { $storyPoints } else { 0 }
            Net = $completed - $created
        }
    }
    
    # Find max for scaling
    $maxCompleted = ($velocityData | Measure-Object Completed -Maximum).Maximum
    $maxCreated = ($velocityData | Measure-Object Created -Maximum).Maximum
    $maxValue = [Math]::Max($maxCompleted, $maxCreated)
    
    if ($maxValue -eq 0) {
        Write-Host "`nNo velocity data available" -ForegroundColor Yellow
        return
    }
    
    # Display velocity chart
    Write-Host "`nWeekly Completion vs Creation:" -ForegroundColor Yellow
    foreach ($week in $velocityData) {
        $completedBar = if ($maxValue -gt 0) { "‚ñà" * [Math]::Floor(($week.Completed / $maxValue) * 20) } else { "" }
        $createdBar = if ($maxValue -gt 0) { "‚ñë" * [Math]::Floor(($week.Created / $maxValue) * 20) } else { "" }
        
        $netColor = if ($week.Net -gt 0) { "Green" } elseif ($week.Net -eq 0) { "Yellow" } else { "Red" }
        $netIndicator = if ($week.Net -gt 0) { "+" } elseif ($week.Net -eq 0) { "=" } else { "" }
        
        Write-Host "$($week.WeekLabel): " -NoNewline -ForegroundColor White
        Write-Host $completedBar -NoNewline -ForegroundColor Green
        Write-Host $createdBar -NoNewline -ForegroundColor Red
        Write-Host " $($week.Completed)‚úì/$($week.Created)+ " -NoNewline -ForegroundColor Gray
        Write-Host "($netIndicator$($week.Net))" -ForegroundColor $netColor
    }
    
    # Velocity metrics
    $avgCompleted = [Math]::Round(($velocityData | Measure-Object Completed -Average).Average, 1)
    $avgCreated = [Math]::Round(($velocityData | Measure-Object Created -Average).Average, 1)
    $totalStoryPoints = ($velocityData | Measure-Object StoryPoints -Sum).Sum
    $avgStoryPoints = [Math]::Round($totalStoryPoints / 8, 1)
    
    Write-Host "`nVELOCITY METRICS:" -ForegroundColor White
    Write-Host "  Avg Completed/week: $avgCompleted tasks" -ForegroundColor Green
    Write-Host "  Avg Created/week: $avgCreated tasks" -ForegroundColor Yellow
    Write-Host "  Net velocity: $([Math]::Round($avgCompleted - $avgCreated, 1)) tasks/week" -ForegroundColor Cyan
    
    if ($totalStoryPoints -gt 0) {
        Write-Host "  Avg Story Points: $avgStoryPoints points/week" -ForegroundColor Blue
    }
    
    # Table summary
    $velRows = @()
    $velRows += , @('Avg Completed/wk', $avgCompleted)
    $velRows += , @('Avg Created/wk', $avgCreated)
    $velRows += , @('Net Velocity', [Math]::Round($avgCompleted - $avgCreated, 1))
    if ($totalStoryPoints -gt 0) { $velRows += , @('Avg Story Points', $avgStoryPoints) }
    Format-StyledTable -Headers @('Metric','Value') -DataRows $velRows -Title 'üìà VELOCITY SUMMARY'
    
    # Trend analysis
    $recent4Weeks = $velocityData | Select-Object -Last 4
    $earlier4Weeks = $velocityData | Select-Object -First 4
    
    $recentAvg = [Math]::Round(($recent4Weeks | Measure-Object Completed -Average).Average, 1)
    $earlierAvg = [Math]::Round(($earlier4Weeks | Measure-Object Completed -Average).Average, 1)
    
    Write-Host "`nTREND ANALYSIS:" -ForegroundColor White
    if ($recentAvg -gt $earlierAvg) {
        Write-Host "  Velocity trending UP ‚ÜóÔ∏è ($earlierAvg ‚Üí $recentAvg)" -ForegroundColor Green
    } elseif ($recentAvg -eq $earlierAvg) {
        Write-Host "  Velocity stable ‚Üí ($recentAvg)" -ForegroundColor Yellow
    } else {
        Write-Host "  Velocity trending down ‚ÜòÔ∏è ($earlierAvg ‚Üí $recentAvg)" -ForegroundColor Red
    }
    
    Write-Host "`n" + ("=" * 50) -ForegroundColor Gray
}

# === ENHANCED PROJECT MANAGEMENT ===

function Find-Project {
    param(
        [string]$query, 
        [switch]$Interactive = $true,
        [switch]$AllowCreate = $false
    )
    
    if ([string]::IsNullOrWhiteSpace($query)) { 
        return $null 
    }
    
    $data = Get-TaskData
    $query_lower = $query.ToLower().Trim()
    
    # Fast exact match
    $exact = $data.projects | Where-Object { $_.name.ToLower() -eq $query_lower }
    if ($exact) { 
        return $exact[0] 
    }
    
    # Check aliases
    $aliasMatch = $data.projects | Where-Object { 
        $_.aliases -and ($_.aliases | Where-Object { $_.ToLower() -eq $query_lower })
    }
    if ($aliasMatch) { 
        return $aliasMatch[0] 
    }
    
    # Single unambiguous matches
    $startsWith = $data.projects | Where-Object { $_.name.ToLower().StartsWith($query_lower) }
    if ($startsWith.Count -eq 1) { 
        return $startsWith[0] 
    }
    
    $contains = $data.projects | Where-Object { $_.name.ToLower() -match "\b$query_lower" }
    if ($contains.Count -eq 1) { 
        return $contains[0] 
    }
    
    # Initials match
    $initials = $data.projects | Where-Object {
        $words = $_.name -split '\s+'
        $init = ($words | ForEach-Object { $_[0] }) -join ''
        $init.ToLower() -eq $query_lower
    }
    if ($initials.Count -eq 1) { 
        return $initials[0] 
    }
    
    # Special shortcuts
    if ($query_lower -eq '-' -or $query_lower -eq 'last') {
        $lastProj = $data.projects | Where-Object { $_.name -eq $data.lastUsedProject }
        if ($lastProj) { 
            return $lastProj[0] 
        }
    }
    
    # Handle multiple matches (smart ranking by recency/activity)
    $allMatches = @()
    $allMatches += $startsWith
    $allMatches += $contains
    $allMatches = $allMatches | Select-Object -Unique | Select-Object -First 8
    # Re-rank by recent activity and context
    try {
        $recentScores = @{}
        try { $recentLogs = @($data.timelogs | Sort-Object date, time | Select-Object -Last 50) } catch { $recentLogs=@() }
        foreach ($l in $recentLogs) { if ($l.project) { if (-not $recentScores.ContainsKey($l.project)) { $recentScores[$l.project]=0 }; $recentScores[$l.project]+=2 } }
        $scored = $allMatches | ForEach-Object {
            $name = $_.name; $s=0
            if ($global:CurrentContext -and $name -eq $global:CurrentContext) { $s+=20 }
            if ($data.lastUsedProject -and $name -eq $data.lastUsedProject) { $s+=30 }
            if ($recentScores.ContainsKey($name)) { $s += [Math]::Min(50, $recentScores[$name]) }
            [pscustomobject]@{ P=$_; S=$s }
        }
        $allMatches = @($scored | Sort-Object S -Descending | ForEach-Object { $_.P })
    } catch {}
    
    if ($allMatches.Count -gt 1 -and $Interactive) {
        Write-Host "`n  üìÅ Multiple projects match '$query':" -ForegroundColor Yellow
        Write-Host "  " + ("‚îÄ" * 50) -ForegroundColor DarkGray
        
        for ($i = 0; $i -lt $allMatches.Count; $i++) {
            $project = $allMatches[$i]
            $taskCount = @($data.tasks | Where-Object { $_.project -eq $project.name -and $_.status -eq 'pending' }).Count
            $taskInfo = if ($taskCount -gt 0) { " ($taskCount task$(if($taskCount -ne 1){'s'}))" } else { " (empty)" }
            
            Write-Host ("  [{0,2}] " -f ($i+1)) -NoNewline -ForegroundColor Cyan
            Write-Host ("{0,-25}" -f $project.name) -NoNewline -ForegroundColor White
            Write-Host $taskInfo -ForegroundColor Gray
        }
        
        Write-Host "  " + ("‚îÄ" * 50) -ForegroundColor DarkGray
        Write-Host "  üí° Enter number to select, or press Enter to cancel" -ForegroundColor DarkCyan
        
        do {
            $choice = Read-Host "  Select"
            
            if ($choice -eq '') { 
                return $null 
            }
            
            if ($choice -match '^#?(\d+)$') {
                $index = [int]$matches[1] - 1
                if ($index -ge 0 -and $index -lt $allMatches.Count) {
                    Write-Host "  ‚úÖ Selected: $($allMatches[$index].name)" -ForegroundColor Green
                    return $allMatches[$index]
                }
            }
            
            Write-Host "  ‚ùå Invalid selection. Enter 1-$($allMatches.Count) or press Enter to cancel." -ForegroundColor Red
        } while ($true)
    }
    elseif ($allMatches.Count -gt 1 -and -not $Interactive) {
        Write-Host "Multiple projects match '$query':" -ForegroundColor Yellow
        foreach ($m in $allMatches) { Write-Host "  - $($m.name)" -ForegroundColor Gray }
        return $null
    }
    
    # Offer to create if allowed
    if ($AllowCreate -and $Interactive) {
        $response = Read-Host "Project '$query' not found. Create it? (Y/n)"
        if ($response -eq '' -or $response.ToLower() -eq 'y') {
            $newProj = @{ 
                Name = $query
                Fields = @{ description = "Auto-created" }
            }
            Add-Project -parsed $newProj
            return $data.projects | Where-Object { $_.name -eq $query }
        }
    }
    
    return $null
}

function Generate-ProjectAliases {
    param([string]$name, [array]$existingProjects)
    
    $aliases = @()
    $words = $name -split '\s+'
    
    # Collect all existing aliases to avoid conflicts
    $existingAliases = $existingProjects | ForEach-Object { 
        @($_.name.ToLower()) + $_.aliases 
    } | Select-Object -Unique
    
    # Generate potential aliases
    $candidates = @()
    
    # First letter of each word (for multi-word projects)
    if ($words.Count -gt 1) {
        $candidates += ($words | ForEach-Object { $_[0] }) -join ''
    }
    
    # First word
    $firstWord = $words[0].ToLower()
    $candidates += $firstWord
    
    # Progressive abbreviations (a, ac, acm, acme)
    for ($i = 1; $i -le [Math]::Min($firstWord.Length, 4); $i++) {
        $candidates += $firstWord.Substring(0, $i)
    }
    
    # Filter out conflicts and the project name itself
    $candidates = $candidates | Where-Object { 
        $_ -notin $existingAliases -and $_ -ne $name.ToLower() 
    } | Select-Object -Unique
    
    return $candidates
}

function Set-ProjectFocus {
    param([string]$projectQuery)
    
    $project = Find-Project -query $projectQuery -Interactive
    if (-not $project) {
        return
    }
    
    Set-CurrentContext -projectName $project.name
    Show-ProjectDetail -projectQuery $project.name
    
    Write-Host "`nContext set: $($project.name)" -ForegroundColor Green
    Write-Host "New tasks and time logs will default to this project" -ForegroundColor Gray
}

function Clear-ProjectFocus {
    Set-CurrentContext -projectName 'inbox'
    Write-Host "Context cleared - returned to inbox" -ForegroundColor Green
}

function Show-Projects {
    $data = Get-TaskData
    
    Write-Host "`n=== ALL PROJECTS ===" -ForegroundColor Cyan
    
    $data.projects | Sort-Object name | ForEach-Object {
        $contextMarker = if ($_.name -eq $global:CurrentContext) { "* " } else { "  " }
        
        Write-Host "$contextMarker$($_.name)" -NoNewline -ForegroundColor White
        
        if ($_.aliases) {
            Write-Host (" [{0}]" -f ($_.aliases -join ', ')) -NoNewline -ForegroundColor DarkGray
        }
        
        Write-Host
        
        # Show custom fields
        $_.PSObject.Properties | Where-Object { 
            $_.Name -notin @('name', 'description', 'aliases') 
        } | ForEach-Object {
            Write-Host ("     {0}: {1}" -f $_.Name, $_.Value) -ForegroundColor Gray
        }
        
        if ($_.description) {
            Write-Host ("     {0}" -f $_.description) -ForegroundColor Gray
        }
        
        # Show statistics
        $taskCount = @($data.tasks | Where-Object { 
            $_.project -eq $_.name -and $_.status -eq 'pending' 
        }).Count
        
        $timeLogged = ($data.timelogs | Where-Object { 
            $_.project -eq $_.name 
        } | Measure-Object minutes -Sum).Sum
        
        if ($taskCount -gt 0) {
            Write-Host "     Tasks: $taskCount pending" -ForegroundColor DarkYellow
        }
        
        if ($timeLogged -gt 0) {
            $hours = [Math]::Round($timeLogged / 60, 1)
            Write-Host "     Time: $hours hours total" -ForegroundColor DarkGreen
        }
        
        Write-Host
    }
}

function Show-ProjectDetail {
    param([string]$projectQuery)
    
    $project = Find-Project -query $projectQuery -Interactive
    if (-not $project) {
        return
    }
    
    $global:LastShownTaskMap.Clear()
    $localIdCounter = 1
    $data = Get-TaskData
    
    Write-Host "`n=== PROJECT: $($project.name) ===" -ForegroundColor Cyan
    
    # Project metadata
    $project.PSObject.Properties | Where-Object { $_.Name -ne 'name' } | ForEach-Object {
        Write-Host ("  {0}: {1}" -f $_.Name, $_.Value) -ForegroundColor Gray
    }
    
    # Active tasks
    $tasks = $data.tasks | Where-Object { 
        $_.project -eq $project.name -and $_.status -eq 'pending' 
    }
    
    if ($tasks) {
        Write-Host "`n  ACTIVE TASKS:" -ForegroundColor Yellow
        
        foreach ($task in ($tasks | Sort-Object priority, created)) {
            $pri = @("", "!", "!!", "!!!")[$task.priority]
            $priColor = @("White", "Red", "Yellow", "Cyan")[$task.priority]
            
            Write-Host ("    [{0,2}] (#{1}) " -f $localIdCounter, $task.id) -NoNewline -ForegroundColor Gray
            Write-Host "$pri " -NoNewline -ForegroundColor $priColor
            Write-Host $task.text -NoNewline
            
            if ($task.due) {
                $dueDate = [datetime]$task.due
                $days = ($dueDate - (Get-Date).Date).Days
                $dueText = if ($days -lt 0) { "OVERDUE" }
                          elseif ($days -eq 0) { "TODAY" }
                          elseif ($days -eq 1) { "Tomorrow" }
                          else { $dueDate.ToString("MMM d") }
                
                $dueColor = if ($days -lt 0) { "Red" }
                           elseif ($days -le 1) { "Yellow" }
                           else { "Gray" }
                
                Write-Host " [$dueText]" -NoNewline -ForegroundColor $dueColor
            }
            
            if ($task.estimatedMinutes) {
                $est = if ($task.estimatedMinutes -lt 60) { 
                    "$($task.estimatedMinutes)m" 
                } else { 
                    "$([Math]::Round($task.estimatedMinutes/60,1))h" 
                }
                Write-Host " ~$est" -NoNewline -ForegroundColor DarkGray
            }
            
            Write-Host
            Set-LastShownEntry -LocalId $localIdCounter -TaskId $task.id
            $localIdCounter++
        }
    }
    
    # Recent time logs
    $logs = $data.timelogs | Where-Object { 
        $_.project -eq $project.name 
    } | Sort-Object date, time | Select-Object -Last 5
    
    if ($logs) {
        Write-Host "`n  RECENT TIME:" -ForegroundColor Yellow
        foreach ($log in $logs) {
            $hours = [Math]::Round($log.minutes / 60, 1)
            Write-Host "    $($log.date) $($log.time): ${hours}h" -NoNewline -ForegroundColor Gray
            if ($log.notes) { 
                Write-Host " - $($log.notes)" -ForegroundColor DarkGray 
            } else { 
                Write-Host 
            }
        }
    }
    
    # Project statistics
    $totalTasks = @($tasks).Count
    $totalMinutes = ($data.timelogs | Where-Object { 
        $_.project -eq $project.name 
    } | Measure-Object minutes -Sum).Sum
    $totalHours = [Math]::Round($totalMinutes / 60, 1)
    
    $weekStart = (Get-Date).Date.AddDays(-[int](Get-Date).DayOfWeek)
    $weekMinutes = ($data.timelogs | Where-Object { 
        $_.project -eq $project.name -and [datetime]$_.date -ge $weekStart 
    } | Measure-Object minutes -Sum).Sum
    $weekHours = [Math]::Round($weekMinutes / 60, 1)
    
    Write-Host "`n  PROJECT SUMMARY:" -ForegroundColor Yellow
    Write-Host "    Active Tasks: $totalTasks" -ForegroundColor Gray
    Write-Host "    This Week: $weekHours hours" -ForegroundColor Gray
    Write-Host "    Total Time: $totalHours hours" -ForegroundColor Gray
}

function Add-ProjectGuided {
    param(
        [string]$projectName = ""
    )
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor DarkGray
    Write-Host "  ‚ïë                    NEW PROJECT WIZARD                      ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor DarkGray
    Write-Host ""
    
    # Gather project information with prompts and validation
    if ([string]::IsNullOrWhiteSpace($projectName)) {
        Write-Host "  üìù Project Name: " -NoNewline -ForegroundColor Cyan
        $projectName = Read-Host
        if ([string]::IsNullOrWhiteSpace($projectName)) {
            Write-Host "  ‚ùå Project name cannot be empty" -ForegroundColor Red
            Pause-Screen
            return
        }
    }
    
    # Check if project already exists
    $data = Get-TaskData
    if ($data.projects | Where-Object { $_.name -eq $projectName }) {
        Write-Host "  ‚ö†Ô∏è  Project '$projectName' already exists" -ForegroundColor Yellow
        Pause-Screen
        return
    }
    
    Write-Host "  üìÑ Description (optional): " -NoNewline -ForegroundColor Cyan
    $description = Read-Host
    
    Write-Host "  üéØ Icon/Emoji (optional): " -NoNewline -ForegroundColor Cyan
    $icon = Read-Host
    if ([string]::IsNullOrWhiteSpace($icon)) { $icon = "üìÅ" }
    
    # PMC Fields
    Write-Host "`n  === PMC INTEGRATION FIELDS ===" -ForegroundColor Yellow
    
    Write-Host "  üè∑Ô∏è  ID1 (Primary ID): " -NoNewline -ForegroundColor Cyan
    $id1 = Read-Host
    
    Write-Host "  üè∑Ô∏è  ID2 (Secondary ID): " -NoNewline -ForegroundColor Cyan
    $id2 = Read-Host
    
    Write-Host "  üìÅ Project Folder Path: " -NoNewline -ForegroundColor Cyan
    $projFolder = Read-Host
    
    Write-Host "  üìÖ Assigned Date (YYYY-MM-DD): " -NoNewline -ForegroundColor Cyan
    $assignedDate = Read-Host
    
    Write-Host "  ‚è∞ Due Date (YYYY-MM-DD): " -NoNewline -ForegroundColor Cyan
    $dueDate = Read-Host
    
    Write-Host "  üìä BF Date (YYYY-MM-DD): " -NoNewline -ForegroundColor Cyan
    $bfDate = Read-Host
    
    Write-Host "  üë§ CAA Name: " -NoNewline -ForegroundColor Cyan
    $caaName = Read-Host
    
    Write-Host "  üìã Request Name: " -NoNewline -ForegroundColor Cyan
    $requestName = Read-Host
    
    Write-Host "  üéØ T2020 Reference: " -NoNewline -ForegroundColor Cyan
    $t2020 = Read-Host
    
    # Create new project with full PMC integration
    $newProject = @{
        name = $projectName
        description = $description
        icon = $icon
        created = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        isArchived = $false
        sortOrder = ($data.projects.Count + 1)
        # PMC Fields
        ID1 = if ([string]::IsNullOrWhiteSpace($id1)) { '' } else { $id1 }
        ID2 = if ([string]::IsNullOrWhiteSpace($id2)) { '' } else { $id2 }
        ProjFolder = if ([string]::IsNullOrWhiteSpace($projFolder)) { '' } else { $projFolder }
        AssignedDate = if ([string]::IsNullOrWhiteSpace($assignedDate)) { '' } else { $assignedDate }
        DueDate = if ([string]::IsNullOrWhiteSpace($dueDate)) { '' } else { $dueDate }
        BFDate = if ([string]::IsNullOrWhiteSpace($bfDate)) { '' } else { $bfDate }
        CAAName = if ([string]::IsNullOrWhiteSpace($caaName)) { '' } else { $caaName }
        RequestName = if ([string]::IsNullOrWhiteSpace($requestName)) { '' } else { $requestName }
        T2020 = if ([string]::IsNullOrWhiteSpace($t2020)) { '' } else { $t2020 }
    }
    
    # Add to projects list
    $data.projects += $newProject
    
    # Save data
    Save-TaskData $data
    
    Write-Host "`n  ‚úÖ Project '$projectName' created successfully!" -ForegroundColor Green
    Write-Host "  üí° Use 'focus @$projectName' to switch to this project" -ForegroundColor DarkCyan
    Write-Host "  üí° Use 'show project $projectName' to view details" -ForegroundColor DarkCyan
    
    Pause-Screen
}

function Show-ProjectDetails {
    param([string]$projectQuery = "")
    
    if ([string]::IsNullOrWhiteSpace($projectQuery)) {
        Write-Host "Usage: show project <name>" -ForegroundColor Yellow
        return
    }
    
    $project = Find-Project -query $projectQuery -Interactive
    if (-not $project) {
        Write-Host "Project not found: $projectQuery" -ForegroundColor Red
        return
    }
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor DarkGray
    Write-Host "  ‚ïë                    PROJECT DETAILS                         ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor DarkGray
    Write-Host ""
    
    # Enhanced project information display using Format-StyledTable
    $projectInfo = @()
    
    # Basic Info
    $projectInfo += [PSCustomObject]@{
        Field = "Name"
        Value = $project.name
        Category = "Basic"
    }
    $projectInfo += [PSCustomObject]@{
        Field = "Description"
        Value = if ($project.description) { $project.description } else { "(none)" }
        Category = "Basic"
    }
    $projectInfo += [PSCustomObject]@{
        Field = "Icon"
        Value = if ($project.icon) { $project.icon } else { "üìÅ" }
        Category = "Basic"
    }
    $projectInfo += [PSCustomObject]@{
        Field = "Created"
        Value = if ($project.created) { $project.created } else { "(unknown)" }
        Category = "Basic"
    }
    
    # PMC Fields
    if ($project.ID1 -or $project.ID2) {
        $projectInfo += [PSCustomObject]@{
            Field = "ID1 (Primary)"
            Value = if ($project.ID1) { $project.ID1 } else { "(not set)" }
            Category = "PMC"
        }
        $projectInfo += [PSCustomObject]@{
            Field = "ID2 (Secondary)"
            Value = if ($project.ID2) { $project.ID2 } else { "(not set)" }
            Category = "PMC"
        }
    }
    
    if ($project.ProjFolder) {
        $projectInfo += [PSCustomObject]@{
            Field = "Project Folder"
            Value = $project.ProjFolder
            Category = "PMC"
        }
    }
    
    if ($project.AssignedDate -or $project.DueDate -or $project.BFDate) {
        if ($project.AssignedDate) {
            $projectInfo += [PSCustomObject]@{
                Field = "Assigned Date"
                Value = $project.AssignedDate
                Category = "PMC Dates"
            }
        }
        if ($project.DueDate) {
            $projectInfo += [PSCustomObject]@{
                Field = "Due Date"
                Value = $project.DueDate
                Category = "PMC Dates"
            }
        }
        if ($project.BFDate) {
            $projectInfo += [PSCustomObject]@{
                Field = "BF Date"
                Value = $project.BFDate
                Category = "PMC Dates"
            }
        }
    }
    
    if ($project.CAAName -or $project.RequestName -or $project.T2020) {
        if ($project.CAAName) {
            $projectInfo += [PSCustomObject]@{
                Field = "CAA Name"
                Value = $project.CAAName
                Category = "PMC Personnel"
            }
        }
        if ($project.RequestName) {
            $projectInfo += [PSCustomObject]@{
                Field = "Request Name"
                Value = $project.RequestName
                Category = "PMC Personnel"
            }
        }
        if ($project.T2020) {
            $projectInfo += [PSCustomObject]@{
                Field = "T2020 Reference"
                Value = $project.T2020
                Category = "PMC Reference"
            }
        }
    }
    
    # Display project info using our new styled table
    Format-StyledTable -Headers @("Field", "Value") -DataRows ($projectInfo | ForEach-Object { @($_.Field, $_.Value) }) -Title "PROJECT INFORMATION"
    
    # Task Summary
    $data = Get-TaskData
    $allTasks = $data.tasks | Where-Object { $_.project -eq $project.name }
    $pendingTasks = $allTasks | Where-Object { $_.status -eq 'pending' }
    $completedTasks = $allTasks | Where-Object { $_.status -eq 'completed' }
    $overdueToday = $pendingTasks | Where-Object { $_.due -and $_.due -lt (Get-Date).ToString("yyyy-MM-dd") }
    
    # Time summary
    $totalMinutes = 0
    $weekMinutes = 0
    if ($data.timelogs) {
        $projectLogs = $data.timelogs | Where-Object { $_.project -eq $project.name }
        $totalMinutes = ($projectLogs | Measure-Object minutes -Sum).Sum
        
        $weekStart = (Get-Date).Date.AddDays(-[int](Get-Date).DayOfWeek)
        $thisWeekLogs = $projectLogs | Where-Object { [datetime]$_.date -ge $weekStart }
        $weekMinutes = ($thisWeekLogs | Measure-Object minutes -Sum).Sum
    }
    
    # Summary table
    $summaryData = @()
    $summaryData += @("Pending Tasks", $pendingTasks.Count)
    $summaryData += @("Completed Tasks", $completedTasks.Count)
    if ($overdueToday.Count -gt 0) {
        $summaryData += @("‚ö†Ô∏è OVERDUE Tasks", $overdueToday.Count)
    }
    $summaryData += @("Total Time Logged", "$([Math]::Round($totalMinutes / 60, 1))h")
    $summaryData += @("This Week", "$([Math]::Round($weekMinutes / 60, 1))h")
    
    Write-Host ""
    Format-StyledTable -Headers @("Metric", "Value") -DataRows $summaryData -Title "PROJECT SUMMARY"

    # Excel T2020 fields for this project (preferred), else fallback to latest import
    $excelRows = @()
    if ($project.PSObject.Properties['ExcelFields'] -and $project.ExcelFields) {
        foreach ($p in $project.ExcelFields.PSObject.Properties) { $excelRows += , @($p.Name, ($p.Value -as [string])) }
        if ($excelRows.Count -gt 0) {
            Format-StyledTable -Headers @("Field", "Value") -DataRows $excelRows -Title "EXCEL T2020 (project)"
        }
    } else {
        $imports = @($data.excelImports)
        if ($imports.Count -gt 0) {
            $latest = $imports[-1]
            foreach ($k in $latest.Fields.Keys) { $excelRows += , @($k, ($latest.Fields[$k] -as [string])) }
            if ($excelRows.Count -gt 0) {
                Format-StyledTable -Headers @("Field", "Value") -DataRows $excelRows -Title "EXCEL T2020 (latest import)"
            }
        } else {
        Format-StyledTable -Headers @('Info') -DataRows @(@('No Excel fields found for this project. Run "import excel" or configure Excel settings.')) -Title 'EXCEL T2020'
        }
    }
    
    # Show recent tasks if any
    if ($pendingTasks.Count -gt 0) {
        Write-Host ""
        $recentTasks = $pendingTasks | Sort-Object created -Descending | Select-Object -First 5
        $taskRows = @()
        foreach ($task in $recentTasks) {
            $priority = @("", "!", "!!", "!!!")[$task.priority]
            $dueText = if ($task.due) { $task.due } else { "" }
        $taskRows += , @($task.id, $priority, $task.text, $dueText)
        }
        
        Format-StyledTable -Headers @("ID", "Pri", "Task", "Due") -DataRows $taskRows -Title "RECENT PENDING TASKS"
    }
    
    Write-Host "`n  üí° Use 'list $($project.name)' to see all tasks" -ForegroundColor DarkCyan
    Write-Host "  üí° Use 'add @$($project.name) <task>' to add a task" -ForegroundColor DarkCyan
    Write-Host ""
    
    Pause-Screen
}

function Show-RecentProjects {
    $data = Get-TaskData
    
    # Get recent projects from time logs (last 20 entries)
    $recentFromLogs = @()
    if ($data.timelogs) {
        $recentLogs = $data.timelogs | Sort-Object timestamp -Descending | Select-Object -First 20
        foreach ($log in $recentLogs) {
            if ($log.project -and $log.project -notin $recentFromLogs) {
                $recentFromLogs += $log.project
            }
        }
    }
    
    # Get recent projects from current context and last used
    $contextProj = if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') { @($global:CurrentContext) } else { @() }
    $lastUsed = if ($data.lastUsedProject) { @($data.lastUsedProject) } else { @() }
    
    # Combine and deduplicate
    $allRecent = @($contextProj + $lastUsed + $recentFromLogs) | Select-Object -Unique | Select-Object -First 8
    
    Clear-Host
    Write-Host "`n  üìÇ RECENT PROJECTS" -ForegroundColor Cyan
    Write-Host "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" -ForegroundColor DarkCyan
    Write-Host ""
    
    if ($allRecent.Count -eq 0) {
        Write-Host "  üì≠ No recent projects found" -ForegroundColor Yellow
        Write-Host "  üí° Projects will appear here after you log time or work with tasks" -ForegroundColor Gray
    } else {
        for ($i = 0; $i -lt $allRecent.Count; $i++) {
            $projName = $allRecent[$i]
            $project = $data.projects | Where-Object { $_.name -eq $projName } | Select-Object -First 1
            
            if ($project) {
                $current = if ($projName -eq $global:CurrentContext) { " (current)" } else { "" }
                $taskCount = @($data.tasks | Where-Object { $_.project -eq $projName -and $_.status -eq 'pending' }).Count
                $taskText = if ($taskCount -gt 0) { " ($taskCount tasks)" } else { " (no tasks)" }
                
                Write-Host "    [$($i+1)] @$projName$current$taskText" -ForegroundColor White
            }
        }
        
        Write-Host ""
        Write-Host "  üí° Use 'focus @<project>' to switch context" -ForegroundColor Gray
        Write-Host "  üí° Use 'show project <project>' for details" -ForegroundColor Gray
    }
    
    Write-Host ""
}

# === ENHANCED TASK MANAGEMENT ===

function Complete-Tasks {
    param([string]$idString)
    
    $data = Get-TaskData
    $ids = Resolve-TaskIds -inputString $idString
    
    if ($ids.Count -eq 0) {
        Write-Host "‚ùå No valid task IDs found for: '$idString'" -ForegroundColor Red
        Write-Host "   Make sure the task IDs exist and are pending" -ForegroundColor Yellow
        Show-RecentTasks
        return
    }
    
    $completedCount = 0
    foreach ($id in $ids) {
        $task = $data.tasks | Where-Object { $_.id -eq $id -and $_.status -eq 'pending' } | Select-Object -First 1
        if ($task) {
            $task.status = 'completed'
            $completedVal = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            if ($task.PSObject.Properties['completed']) { $task.completed = $completedVal }
            else { Add-Member -InputObject $task -MemberType NoteProperty -Name completed -Value $completedVal }
            Write-Host "‚úÖ [done] #$($task.id) $($task.text)" -ForegroundColor Green
            $completedCount++
        }
    }
    
    if ($completedCount -gt 0) {
        # Update blocked status for dependent tasks
        Update-BlockedStatus -data $data
        Save-TaskData $data
        Write-Host "‚úÖ Completed $completedCount task$(if($completedCount -ne 1){'s'})" -ForegroundColor Green
    } else {
        Write-Host "‚ùå No tasks were completed. Check that the IDs are correct and tasks are pending." -ForegroundColor Yellow
    }
}

function Complete-SmartTasks {
    param([CommandContext]$context)
    
    $idString = $context.GetText()
    if ([string]::IsNullOrWhiteSpace($idString)) {
        try { $idString = $context.GetArg('id', $null) } catch { $idString = $null }
        if ([string]::IsNullOrWhiteSpace($idString)) {
            try {
                $tok = @($context.State.ArgumentTokens | ForEach-Object { $_.Text })
                if ($tok -and $tok.Count -gt 0) { $idString = ($tok -join ' ') }
            } catch {}
            if ([string]::IsNullOrWhiteSpace($idString)) {
                try {
                    $buf = ''
                    try { $buf = $context.State.OriginalBuffer } catch {}
                    if ($buf) {
                        $parts = @($buf.Trim() -split '\s+')
                        if ($parts.Count -ge 2) {
                            # Skip optional 'task' keyword
                            if ($parts[1].ToLower() -eq 'task' -and $parts.Count -ge 3) { $idString = $parts[2] } else { $idString = $parts[1] }
                        }
                    }
                } catch {}
            }
        }
    }
    if ([string]::IsNullOrWhiteSpace($idString)) {
        Write-Host "‚ùå Please specify task ID(s) to complete" -ForegroundColor Red
        Write-Host "   Usage: done <id> or done <id1,id2> or done <id1-id5>" -ForegroundColor Yellow
        Write-Host "   Example: done 3 or done 1,2,5 or done 1-5" -ForegroundColor Gray
        Show-RecentTasks
        return
    }
    
    Complete-Tasks -idString $idString
}

function Complete-Quick {
    param([CommandContext]$context)
    $idString = $null
    try { $idString = $context.GetArg('id', $null) } catch {}
    if ([string]::IsNullOrWhiteSpace($idString)) {
        try {
            $buf = ''
            try { $buf = $context.State.OriginalBuffer } catch {}
            if ($buf -match '(?i)^\s*done\s+(?:task\s+)?(?<ids>[0-9,\- ]+)') { $idString = $matches.ids.Trim() }
        } catch {}
    }
    if ([string]::IsNullOrWhiteSpace($idString)) { Write-Host "‚ùå Please specify task ID(s) to complete" -ForegroundColor Red; return }
    # Direct complete (robust)
    $data = Get-TaskData
    $ids = Resolve-TaskIds -inputString $idString
    $count = 0
    foreach ($id in $ids) {
        $task = $data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1
        if ($task) {
            $task.status = 'completed'
            $task | Add-Member -Force -MemberType NoteProperty -Name completed -Value ((Get-Date).ToString('yyyy-MM-dd HH:mm:ss'))
            $count++
        }
    }
    if ($count -gt 0) { Save-TaskData $data; Write-Host "‚úÖ Completed $count" -ForegroundColor Green } else { Write-Host "No matching tasks to complete" -ForegroundColor Yellow }
}

function Delete-Tasks {
    param([string]$idString)
    
    # Support --yes/-y flags in id string
    $yesFlag = $false
    if ($idString) {
        $clean = @()
        foreach ($tok in ($idString -split '[,\s]+' | Where-Object { $_ })) {
            if ($tok -eq '--yes' -or $tok -eq '-y') { $yesFlag = $true }
            else { $clean += $tok }
        }
        $idString = ($clean -join ' ')
    }

    $data = Get-TaskData
    $ids = Resolve-TaskIds -inputString $idString
    
    $tasksToDelete = $data.tasks | Where-Object { 
        $_.id -in $ids -and $_.status -eq 'pending' 
    }
    
    if ($tasksToDelete.Count -eq 0) {
        Write-Host "No pending tasks found for the given IDs." -ForegroundColor Yellow
        Show-RecentTasks
        return
    }
    
    # Show what will be deleted
    Write-Host "Tasks to delete:" -ForegroundColor Yellow
    $tasksToDelete | ForEach-Object {
        Write-Host "  [-] #$($_.id) $($_.text)" -ForegroundColor Gray
    }
    
    # Confirmation (honor config for non-interactive or warn bypass)
    try { [ConfigManager]::Load() } catch {}
    $cfg = $null; try { $cfg = [ConfigManager]::Config } catch {}
    $nonInteractive = $false; $warn = $true
    try { if ($cfg -and $cfg.Behavior) { $nonInteractive = [bool]$cfg.Behavior.NonInteractive; $warn = [bool]$cfg.Behavior.WarnBeforeDelete } } catch {}
    if ($yesFlag -or $nonInteractive -or -not $warn) {
        Write-Host "Auto-confirm delete ($($tasksToDelete.Count) item(s)) due to configuration." -ForegroundColor DarkGray
    } else {
        $confirm = Get-UserConfirmation -Prompt ("Delete {0} task{1}?" -f $tasksToDelete.Count, ($(if($tasksToDelete.Count -ne 1){'s'} else {''}))) -DefaultYes:$false
        if (-not $confirm) {
            Write-Host "Deletion cancelled." -ForegroundColor Gray
            return
        }
    }
    
    # Perform deletion
    foreach ($task in $tasksToDelete) {
        $data.deleted += $task
        $data.tasks = $data.tasks | Where-Object { $_.id -ne $task.id }
        Write-Host "[-] #$($task.id) $($task.text)" -ForegroundColor Red
    }
    
    Save-TaskData $data
}

function Delete-SmartTasks {
    param([CommandContext]$context)
    
    $idString = $context.GetText()
    if ([string]::IsNullOrWhiteSpace($idString)) {
        Write-Host "‚ùå Please specify task ID(s) to delete" -ForegroundColor Red
        Write-Host "   Usage: delete <id> [--yes] or delete <id1,id2> [--yes]" -ForegroundColor Yellow
        Write-Host "   Example: delete 3 --yes or delete 1,2,5" -ForegroundColor Gray
        Show-RecentTasks
        return
    }
    
    Delete-Tasks -idString $idString
}

function Update-Task {
    param($parsed)
    
    $data = Get-TaskData
    $ids = Resolve-TaskIds -inputString $parsed.Id
    if ($ids.Count -eq 0) { Write-Host "No valid task ID(s) found" -ForegroundColor Red; return }

    $text = if ($parsed.Text) { $parsed.Text } else { '' }
    $metadata = Extract-Metadata -text $text
    
    # Special directives within the free text
    $clearDue = $text -match '(?i)\bdue:none\b'
    $clearEst = $text -match '(?i)\best:none\b'
    $clearPri = $text -match '(?i)\bp0\b|\bpri:none\b'
    $removeTags = @()
    foreach ($tok in ($text -split '\s+')) {
        if ($tok -match '^-#?(.+)$') { $removeTags += $matches[1] }
    }
    # Include structured remove tags if provided
    $ctxRemove = $context.GetArg('removeTags', @())
    if ($ctxRemove -and $ctxRemove.Count -gt 0) {
        $removeTags = @($removeTags + $ctxRemove)
    }

    foreach ($taskId in $ids) {
        $task = $data.tasks | Where-Object { $_.id -eq $taskId } | Select-Object -First 1
        if (-not $task) { continue }
        
        if ($metadata.CleanText) { $task.text = $metadata.CleanText }
        
        if ($metadata.Project) {
            $newProject = Find-Project -query $metadata.Project -Interactive:$false
            if ($newProject) { $task.project = $newProject.name }
        }
        
        if ($clearPri) { $task.priority = 0 }
        elseif ($metadata.Priority) { $task.priority = $metadata.Priority }
        
        if ($clearDue) { $task.due = $null }
        elseif ($metadata.Due) { $task.due = Parse-NaturalDate -input $metadata.Due }
        
        if ($clearEst) { $task.estimatedMinutes = $null }
        elseif ($metadata.EstimatedTime) { $task.estimatedMinutes = Parse-DurationToMinutes $metadata.EstimatedTime }
        
        # Update custom fields
        foreach ($key in $metadata.CustomFields.Keys) {
            if ($task.PSObject.Properties[$key]) { $task.$key = $metadata.CustomFields[$key] }
            else { Add-Member -InputObject $task -MemberType NoteProperty -Name $key -Value $metadata.CustomFields[$key] }
        }
        
        # Update tags (add/remove)
        if (-not $task.tags) { $task.tags = @() }
        if ($metadata.Tags.Count -gt 0) {
            $task.tags = @($task.tags + $metadata.Tags | Select-Object -Unique)
        }
        if ($removeTags.Count -gt 0) {
            $task.tags = @($task.tags | Where-Object { $_ -notin $removeTags })
        }
        Write-Host "[updated] #$($task.id) $($task.text)" -ForegroundColor Yellow
    }
    Save-TaskData $data
}

function Show-RecentTasks {
    Write-Host "Recently shown task IDs:" -ForegroundColor Gray
    $global:LastShownTaskMap.GetEnumerator() | Sort-Object Key | ForEach-Object {
        Write-Host "  [$($_.Key)] -> #$($_.Value)" -ForegroundColor DarkGray
    }
}

function Complete-AllOverdue {
    $data = Get-TaskData
    $todayStr = (Get-Date).ToString("yyyy-MM-dd")
    
    $overdue = $data.tasks | Where-Object { 
        $_.status -eq 'pending' -and $_.due -and $_.due -lt $todayStr 
    }
    
    if (-not $overdue) {
        Write-Host "No overdue tasks found." -ForegroundColor Green
        return
    }
    
    Write-Host "Found $($overdue.Count) overdue task$(if($overdue.Count -ne 1){'s'}):" -ForegroundColor Yellow
    $overdue | ForEach-Object {
        Write-Host "  #$($_.id) $($_.text)" -ForegroundColor Gray
    }
    
    # Confirmation (honor NonInteractive / WarnBeforeDelete)
    try { [ConfigManager]::Load() } catch {}
    $cfg = $null; try { $cfg = [ConfigManager]::Config } catch {}
    $nonInteractive = $false; $warn = $true
    try { if ($cfg -and $cfg.Behavior) { $nonInteractive = [bool]$cfg.Behavior.NonInteractive; $warn = [bool]$cfg.Behavior.WarnBeforeDelete } } catch {}
    $proceed = $false
    if ($nonInteractive -or -not $warn) { $proceed = $true }
    else {
        if (Get-UserConfirmation -Prompt "Mark all as complete?" -DefaultYes:$false) { $proceed = $true }
    }
    if ($proceed) {
        $overdue | ForEach-Object {
            $_.status = 'completed'
            $_.completed = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            Write-Host "[done] #$($_.id) $($_.text)" -ForegroundColor Green
        }
        Update-BlockedStatus -data $data
        Save-TaskData $data
        Write-Host "Completed $($overdue.Count) overdue task$(if($overdue.Count -ne 1){'s'})" -ForegroundColor Green
    }
}

function Show-NextTask {
    $data = Get-TaskData
    $today = (Get-Date).Date
    $todayStr = $today.ToString("yyyy-MM-dd")
    
    # Priority order: overdue, due today, high priority, then rest
    $candidates = $data.tasks | Where-Object { $_.status -eq 'pending' }
    
    $nextTask = $candidates | Where-Object { $_.due -and $_.due -lt $todayStr } | 
                Sort-Object due, priority | Select-Object -First 1
    
    if (-not $nextTask) {
        $nextTask = $candidates | Where-Object { $_.due -eq $todayStr } |
                    Sort-Object priority | Select-Object -First 1
    }
    
    if (-not $nextTask) {
        $nextTask = $candidates | Where-Object { $_.priority -eq 1 } |
                    Sort-Object created | Select-Object -First 1
    }
    
    if (-not $nextTask) {
        $nextTask = $candidates | Sort-Object priority, due, created | Select-Object -First 1
    }
    
    if ($nextTask) {
        Write-Host "`n=== NEXT RECOMMENDED TASK ===" -ForegroundColor Cyan
        $global:LastShownTaskMap.Clear()
        Set-LastShownEntry -LocalId 1 -TaskId $nextTask.id
        
        $pri = @(" ", "!", "!!", "!!!")[$nextTask.priority]
        $priColor = @("Gray", "Red", "Yellow", "Cyan")[$nextTask.priority]
        
        Write-Host ("  [1] (#{0}) " -f $nextTask.id) -NoNewline -ForegroundColor Gray
        Write-Host "$pri " -NoNewline -ForegroundColor $priColor
        Write-Host $nextTask.text -NoNewline
        
        if ($nextTask.project -ne 'inbox') {
            Write-Host " @$($nextTask.project)" -NoNewline -ForegroundColor Cyan
        }
        
        if ($nextTask.due) {
            $dueDate = [datetime]$nextTask.due
            $days = ($dueDate - $today).Days
            $dueText = if ($days -lt 0) { "OVERDUE" }
                      elseif ($days -eq 0) { "TODAY" }
                      elseif ($days -eq 1) { "Tomorrow" }
                      else { $dueDate.ToString("MMM d") }
            
            $dueColor = if ($days -le 0) { "Red" }
                       elseif ($days -eq 1) { "Yellow" }
                       else { "Gray" }
            
            Write-Host " [$dueText]" -NoNewline -ForegroundColor $dueColor
        }
        
        Write-Host
        Write-Host "`nQuick complete: done 1" -ForegroundColor DarkGray
    } else {
        Write-Host "No pending tasks found." -ForegroundColor Gray
    }
}

# === DEPENDENCIES & BLOCKING ===

function Add-Dependency {
    param([int]$taskId, [int]$dependsOnId)
    
    if ($taskId -eq $dependsOnId) {
        Write-Host "Task cannot depend on itself" -ForegroundColor Red
        return
    }
    
    $data = Get-TaskData
    $task = $data.tasks | Where-Object { $_.id -eq $taskId }
    $dependency = $data.tasks | Where-Object { $_.id -eq $dependsOnId }
    
    if (-not $task) {
        Write-Host "Task #$taskId not found" -ForegroundColor Red
        return
    }
    
    if (-not $dependency) {
        Write-Host "Task #$dependsOnId not found" -ForegroundColor Red
        return
    }
    
    # Check for circular dependencies
    if (Test-CircularDependency -data $data -taskId $taskId -checkId $dependsOnId) {
        Write-Host "Cannot add dependency: would create circular reference" -ForegroundColor Red
        return
    }
    
    if (-not $task.depends) { $task.depends = @() }
    
    if ($dependsOnId -notin $task.depends) {
        $task.depends += $dependsOnId
        Update-BlockedStatus -data $data
        Save-TaskData $data
        Write-Host "Task #$taskId now depends on #$dependsOnId" -ForegroundColor Yellow
        Write-Host "  #$taskId`: $($task.text)" -ForegroundColor Gray
        Write-Host "  depends on -> #$dependsOnId`: $($dependency.text)" -ForegroundColor Gray
    } else {
        Write-Host "Dependency already exists" -ForegroundColor Gray
    }
}

function Remove-Dependency {
    param([int]$taskId, [int]$dependsOnId)
    
    $data = Get-TaskData
    $task = $data.tasks | Where-Object { $_.id -eq $taskId }
    
    if ($task -and $task.depends) {
        $task.depends = $task.depends | Where-Object { $_ -ne $dependsOnId }
        if ($task.depends.Count -eq 0) {
            $task.PSObject.Properties.Remove('depends')
        }
        Update-BlockedStatus -data $data
        Save-TaskData $data
        Write-Host "Removed dependency #$taskId ‚Üí #$dependsOnId" -ForegroundColor Green
    }
}

function Test-CircularDependency {
    param($data, [int]$taskId, [int]$checkId, [array]$visited = @(), [int]$depth = 0)
    
    if ($checkId -in $visited) { return $true }
    if ($checkId -eq $taskId) { return $true }
    
    if ($depth -gt 100) { Write-Warning "Dependency chain too deep (>$depth), possible cycle"; return $true }
    $visited += $checkId
    $checkTask = $data.tasks | Where-Object { $_.id -eq $checkId }
    
    if ($checkTask -and $checkTask.depends) {
        foreach ($depId in $checkTask.depends) {
            if (Test-CircularDependency -data $data -taskId $taskId -checkId $depId -visited $visited -depth ($depth+1)) {
                return $true
            }
        }
    }
    
    return $false
}

function Update-BlockedStatus {
    param($data = (Get-TaskData))
    
    foreach ($task in $data.tasks | Where-Object { $_.depends }) {
        $blockers = $data.tasks | Where-Object { 
            $_.id -in $task.depends -and $_.status -eq 'pending' 
        }
        $isBlocked = ($blockers.Count -gt 0)
        if ($task.PSObject.Properties['blocked']) { $task.blocked = $isBlocked }
        else { Add-Member -InputObject $task -MemberType NoteProperty -Name blocked -Value $isBlocked }
    }
    
    # Clear blocked status for tasks without dependencies
    foreach ($task in $data.tasks | Where-Object { -not $_.depends }) {
        if ($task.PSObject.Properties['blocked']) {
            $task.PSObject.Properties.Remove('blocked')
        }
    }
}

# === TEMPLATES ===

function Save-Template {
    param([string]$name, [string]$template)
    
    if ([string]::IsNullOrWhiteSpace($name)) {
        Write-Host "Template name cannot be empty" -ForegroundColor Red
        return $false
    }
    
    $templatePath = Join-Path $global:DataPath "templates.json"
    $templates = @{}
    
    if (Test-Path $templatePath) {
        try {
            $content = Get-Content $templatePath -Raw -ErrorAction SilentlyContinue
            if ($content) {
                $templates = $content | ConvertFrom-Json -AsHashtable -ErrorAction SilentlyContinue
                if (-not $templates) { $templates = @{} }
            }
        } catch {
            Write-Host "Error reading templates: $_" -ForegroundColor Yellow
            $templates = @{}
        }
    }
    
    $templates[$name] = @{
        Template = $template
        Created = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        UsageCount = if ($templates[$name]) { $templates[$name].UsageCount } else { 0 }
    }
    
    try {
        $templates | ConvertTo-Json -Depth 3 | Out-File $templatePath -Encoding UTF8
        Write-Host "Template '$name' saved successfully" -ForegroundColor Green
        return $true
    } catch {
        Write-Host "Error saving template: $_" -ForegroundColor Red
        return $false
    }
}

function Get-Templates {
    $templatePath = Join-Path $global:DataPath "templates.json"
    if (-not (Test-Path $templatePath)) {
        return @{}
    }
    
    try {
        $content = Get-Content $templatePath -Raw -ErrorAction SilentlyContinue
        if ($content) {
            $templates = $content | ConvertFrom-Json -AsHashtable -ErrorAction SilentlyContinue
            return if ($templates) { $templates } else { @{} }
        }
        return @{}
    } catch {
        Write-Host "Error reading templates: $_" -ForegroundColor Yellow
        return @{}
    }
}

function Use-Template {
    param([string]$name, [string]$project = $null)
    
    $templates = Get-Templates
    if (-not $templates[$name]) {
        Write-Host "Template '$name' not found" -ForegroundColor Red
        $availableTemplates = $templates.Keys | Sort-Object
        if ($availableTemplates.Count -gt 0) {
            Write-Host "Available templates: $($availableTemplates -join ', ')" -ForegroundColor Gray
        }
        return
    }
    
    $template = $templates[$name]
    $tasks = $template.Template -split ';' | Where-Object { $_.Trim() }
    
    if ($tasks.Count -eq 0) {
        Write-Host "Template '$name' is empty" -ForegroundColor Yellow
        return
    }
    
    Write-Host "Using template '$name' (creating $($tasks.Count) tasks)..." -ForegroundColor Cyan
    
    $data = Get-TaskData
    $addedTasks = @()
    
    foreach ($taskText in $tasks) {
        $taskText = $taskText.Trim()
        if (-not $taskText) { continue }
        
        if ($project -and $taskText -notmatch '@\w+') {
            $taskText = "$taskText @$project"
        }
        
        $metadata = Extract-Metadata $taskText
        $newTask = @{
            id = Get-NextTaskId $data
            text = $metadata.CleanText
            created = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            done = $false
        }
        
        if ($metadata.Project) { $newTask.project = $metadata.Project }
        if ($metadata.Priority -gt 0) { $newTask.priority = $metadata.Priority }
        if ($metadata.Due) { $newTask.due = $metadata.Due }
        if ($metadata.EstimatedTime) { $newTask.estimated = $metadata.EstimatedTime }
        if ($metadata.Tags.Count -gt 0) { $newTask.tags = $metadata.Tags }
        
        $data.tasks += $newTask
        $addedTasks += $newTask
        Write-Host "  + $($newTask.text)" -ForegroundColor Green
    }
    
    Save-TaskData $data
    
    $template.UsageCount++
    $templates[$name] = $template
    $templatePath = Join-Path $global:DataPath "templates.json"
    try {
        $templates | ConvertTo-Json -Depth 3 | Out-File $templatePath -Encoding UTF8
    } catch {
        Write-Host "Note: Could not update template usage count" -ForegroundColor Yellow
    }
    
    Write-Host "`nCreated $($addedTasks.Count) tasks from template '$name'" -ForegroundColor Green
}

function Remove-Template {
    param([string]$name)
    
    if ([string]::IsNullOrWhiteSpace($name)) {
        Write-Host "Template name cannot be empty" -ForegroundColor Red
        return $false
    }
    
    $templates = Get-Templates
    if (-not $templates[$name]) {
        Write-Host "Template '$name' not found" -ForegroundColor Red
        return $false
    }
    
    $templates.Remove($name)
    $templatePath = Join-Path $global:DataPath "templates.json"
    
    try {
        if ($templates.Count -eq 0) {
            if (Test-Path $templatePath) {
                Remove-Item $templatePath
            }
        } else {
            $templates | ConvertTo-Json -Depth 3 | Out-File $templatePath -Encoding UTF8
        }
        Write-Host "Template '$name' removed successfully" -ForegroundColor Green
        return $true
    } catch {
        Write-Host "Error removing template: $_" -ForegroundColor Red
        return $false
    }
}

function Show-Templates {
    $templates = Get-Templates
    
    if ($templates.Count -eq 0) {
        Write-Host "No templates found" -ForegroundColor Gray
        Write-Host "`nCreate templates with: template save <name> <tasks>" -ForegroundColor Yellow
        return
    }
    
    Write-Host "=== TEMPLATES ===" -ForegroundColor Cyan
    foreach ($templateName in ($templates.Keys | Sort-Object)) {
        $template = $templates[$templateName]
        $tasks = $template.Template -split ';' | Where-Object { $_.Trim() }
        
        Write-Host "`n$templateName" -ForegroundColor Yellow
        Write-Host "  Created: $($template.Created)" -ForegroundColor Gray
        Write-Host "  Usage: $($template.UsageCount) times" -ForegroundColor Gray
        Write-Host "  Tasks ($($tasks.Count)):" -ForegroundColor Gray
        
        foreach ($task in $tasks) {
            $task = $task.Trim()
            if ($task) {
                Write-Host "    - $task" -ForegroundColor White
            }
        }
    }
}

function Invoke-TemplateCommand {
    param([string[]]$args)
    
    if ($args.Count -eq 0) {
        Show-Templates
        return
    }
    
    $action = $args[0].ToLower()
    
    switch ($action) {
        'save' {
            if ($args.Count -lt 3) {
                Write-Host "Usage: template save <name> <tasks>" -ForegroundColor Yellow
                Write-Host "  Tasks separated by semicolons" -ForegroundColor Gray
                Write-Host "  Example: template save 'daily' 'Check emails; Review calendar; Plan day'" -ForegroundColor Gray
                return
            }
            $name = $args[1]
            $template = $args[2..($args.Count-1)] -join ' '
            Save-Template $name $template
        }
        
        'use' {
            if ($args.Count -lt 2) {
                Write-Host "Usage: template use <name> [project]" -ForegroundColor Yellow
                return
            }
            $name = $args[1]
            $project = if ($args.Count -gt 2) { $args[2] } else { $null }
            Use-Template $name $project
        }
        
        'remove' {
            if ($args.Count -lt 2) {
                Write-Host "Usage: template remove <name>" -ForegroundColor Yellow
                return
            }
            Remove-Template $args[1]
        }
        
        'delete' {
            if ($args.Count -lt 2) {
                Write-Host "Usage: template delete <name>" -ForegroundColor Yellow
                return
            }
            Remove-Template $args[1]
        }
        
        'list' {
            Show-Templates
        }
        
        'show' {
            Show-Templates
        }
        
        default {
            Write-Host "Unknown template command: $action" -ForegroundColor Red
            Write-Host "Available commands: save, use, remove, list" -ForegroundColor Yellow
        }
    }
}


# === TIME TRACKING ===

function Log-StructuredEntry {
    param($context)
    # Prefer structured args from CommandContext
    $text = if ($context) { $context.GetText() } else { '' }
    $text = ($text -replace "\s+", ' ').Trim()
    if (-not $text -and -not ($context -and ($context.HasArg('project') -or $context.HasArg('id1')))) {
        Write-Host "Usage:" -ForegroundColor Yellow
        Write-Host "  log @project YYYY-MM-DD <hours> [description]" -ForegroundColor White
        Write-Host "  log #<ID1>   YYYY-MM-DD <hours> [description]" -ForegroundColor White
        Write-Host "Hints:" -ForegroundColor Yellow
        Write-Host "  ‚Ä¢ @project supports Tab completion (existing projects only)" -ForegroundColor Gray
        Write-Host "  ‚Ä¢ #ID1 is a 2‚Äì5 digit numeric code when no project applies" -ForegroundColor Gray
        Write-Host "  ‚Ä¢ Date may be 'today' or 'yesterday' as shortcuts" -ForegroundColor Gray
        Write-Host "  ‚Ä¢ Hours are decimal: .25, 1.25, 2" -ForegroundColor Gray
        return
    }
    $projName = $null; $id1 = $null; $dateStr = $null; $hoursStr = $null; $desc = ''
    if ($context) {
        if ($context.HasArg('project')) { $projName = $context.GetArg('project', '') }
        if ($context.HasArg('id1')) { $id1 = ($context.GetArg('id1','') -replace '^#','') }
    }
    
    # Handle numeric ID pattern: 'log 050 today 1' -> treat 050 as #050
    if (-not $projName -and -not $id1 -and $text -match '^(\d{2,5})\s+(.+)$') {
        $id1 = $matches[1]
        $text = $matches[2]
        Write-DebugLog ("LOG: Detected numeric ID pattern: '$id1' with remaining text: '$text'")
    }
    
    # Heal multi-word project if only first word captured and remaining text begins with tail words
    if ($projName -and $text) {
        $tokens = $text -split '\s+'
        $bestIndex = -1; $bestExact = $false; $bestName = ''
        for ($i = 0; $i -lt $tokens.Count; $i++) {
            $candidate = ($projName + ' ' + (($tokens[0..$i]) -join ' ')).Trim()
            $p = Find-Project -query $candidate -Interactive:$false
            if ($p) {
                $bestIndex = $i; $bestName = $candidate
                if ($p.name -and ($p.name.ToLower() -eq $candidate.ToLower())) { $bestExact = $true; break }
            }
        }
        if ($bestIndex -ge 0) {
            $projName = $bestName
            if ($bestIndex -lt ($tokens.Count - 1)) { $text = ($tokens[($bestIndex+1)..($tokens.Count-1)] -join ' ') } else { $text = '' }
        }
    }
    # Parse remaining text as: <date> <hours> [desc]
    if ($text) {
        $parts = $text -split '\s+', 3
        if ($parts.Count -ge 2) {
            $dateStr = $parts[0]
            $hoursStr = $parts[1]
            if ($parts.Count -ge 3) { $desc = $parts[2] }
        }
    }
    if (-not $projName -and -not $id1) {
        Write-Host "Invalid format." -ForegroundColor Red
        Write-Host "Use: log @project YYYY-MM-DD <hours> [desc] OR log #1234 YYYY-MM-DD <hours> [desc]" -ForegroundColor Gray
        Write-Host "Example: log @work today 1.25 Weekly sync" -ForegroundColor Gray
        return
    }

    # Validate date (supports 'today'/'yesterday')
    if ($dateStr -match '^(?i)today|yesterday$') {
        $today = (Get-Date).Date
        $date = if ($dateStr.ToLower() -eq 'today') { $today } else { $today.AddDays(-1) }
    } else {
        try { $date = [datetime]::ParseExact($dateStr, 'yyyy-MM-dd', $null) } catch { Write-Host "Invalid date: $dateStr" -ForegroundColor Red; return }
    }
    # Validate hours
    if (-not [double]::TryParse($hoursStr, [ref]([double]$null))) { Write-Host "Invalid hours: $hoursStr" -ForegroundColor Red; return }
    $hours = [double]$hoursStr
    if ($hours -lt 0.25) { Write-Host "Minimum 0.25 hours" -ForegroundColor Yellow; return }
    $minutes = [int][Math]::Round($hours * 60)

    $data = Get-TaskData
    $project = $null
    if ($projName) {
        $project = Find-Project -query $projName -Interactive:$false
        if (-not $project) {
            Write-Host "Unknown project: $projName" -ForegroundColor Red
            Write-Host "Tip: Use @ and press Tab to cycle through existing projects" -ForegroundColor Gray
            return
        }
    }

    # Build JSON log
    $jsonLog = @{
        project = $(if ($project) { $project.name } else { "(none)" })
        minutes = $minutes
        date = $date.ToString('yyyy-MM-dd')
        time = (Get-Date).ToString('HH:mm')
        notes = $desc
        id = [System.Guid]::NewGuid().ToString()
    }
    if ($id1) { $jsonLog.id1 = $id1 }
    $data.timelogs += $jsonLog
    Save-TaskData $data

    # Prepare project data for CSV
    $projData = $null
    if ($project) {
        $projData = @{
            ID1    = ($(if ($project.PSObject.Properties.Name -contains 'ID1') { $project.ID1 } else { '' }))
            ID2    = ($(if ($project.PSObject.Properties.Name -contains 'ID2') { $project.ID2 } else { '' }))
            CAAName= ($(if ($project.PSObject.Properties.Name -contains 'CAAName') { $project.CAAName } else { '' }))
            T2020  = ($(if ($project.PSObject.Properties.Name -contains 'T2020') { $project.T2020 } else { '' }))
        }
    } else {
        $projData = @{ ID1 = $id1; ID2 = ''; CAAName = ''; T2020 = '' }
    }
    Export-TimeToCsv -LogEntry $jsonLog -ProjectData $projData
    
    Write-Host ("‚úÖ Logged {0}h {1}" -f $hours, $(if ($project) {"to '" + $project.name + "'"} else {"with ID1 #$id1"})) -ForegroundColor Green
}

function Add-TimeLog {
    param($parsed)
    
    # Determine target project
    $projectQuery = $parsed.ProjectQuery
    if (-not $projectQuery -and $global:CurrentContext) {
        $projectQuery = $global:CurrentContext
    }
    
    $project = Find-Project -query $projectQuery -Interactive -AllowCreate
    if (-not $project) {
        Write-Host "Cannot determine project for time log." -ForegroundColor Red
        return
    }
    
    $data = Get-TaskData
    $minutes = Parse-DurationToMinutes $parsed.Duration
    
    if ($minutes -le 0) {
        Write-Host "Invalid duration: $($parsed.Duration)" -ForegroundColor Red
        Write-Host "Use format: 1.5h, 90m, 2h, 30m" -ForegroundColor Gray
        return
    }
    
    # Create time log entry
    $log = @{
        project = $project.name
        minutes = $minutes
        date = (Get-Date).ToString("yyyy-MM-dd")
        time = (Get-Date).ToString("HH:mm")
        notes = $parsed.Notes
    }
    
    $data.timelogs += $log
    $data.lastUsedProject = $project.name
    Save-TaskData $data
    
    # Display confirmation
    $hours = [Math]::Round($minutes / 60, 2)
    Write-Host "Logged $hours hours to '$($project.name)'" -ForegroundColor Green
    
    if ($parsed.Notes) {
        Write-Host "  Note: $($parsed.Notes)" -ForegroundColor Gray
    }
    
    # Show daily total for context
    $todayStr = (Get-Date).ToString("yyyy-MM-dd")
    $todayTotal = ($data.timelogs | Where-Object { 
        $_.date -eq $todayStr -and $_.project -eq $project.name 
    } | Measure-Object minutes -Sum).Sum
    
    if ($todayTotal -gt $minutes) {
        $totalHours = [Math]::Round($todayTotal / 60, 2)
        Write-Host "  Today's total for $($project.name): $totalHours hours" -ForegroundColor DarkGreen
    }
}

function Show-TimeReport {
    param($parsed)
    
    $data = Get-TaskData
    $dateRange = Parse-DateRange -range $parsed.DateRange
    
    # Get logs for date range
    $logs = $data.timelogs | Where-Object { 
        [datetime]$_.date -ge $dateRange.Start -and [datetime]$_.date -lt $dateRange.End 
    }
    
    # Filter by project if specified
    if ($parsed.ProjectFilter) {
        $project = Find-Project -query $parsed.ProjectFilter -Interactive
        if ($project) {
            $logs = $logs | Where-Object { $_.project -eq $project.name }
            $projDisplay = " for $($project.name)"
        } else {
            return
        }
    } else {
        $projDisplay = ""
    }
    
    if (-not $logs) {
        Write-Host "No time logged for $($dateRange.Display)$projDisplay" -ForegroundColor Gray
        return
    }
    
    Write-Host "`n=== TIME REPORT: $($dateRange.Display)$projDisplay ===" -ForegroundColor Cyan
    
    # Group by project and calculate totals
    $grouped = $logs | Group-Object project | Sort-Object Name
    $totalMinutes = 0
    
    foreach ($group in $grouped) {
        $projMinutes = ($group.Group | Measure-Object minutes -Sum).Sum
        $totalMinutes += $projMinutes
        $projHours = [Math]::Round($projMinutes / 60, 2)
        
        $contextMarker = if ($group.Name -eq $global:CurrentContext) { "* " } else { "  " }
        Write-Host ("$contextMarker{0,-25} {1,8} hours" -f $group.Name, $projHours)
        
        # Show daily breakdown for short periods
        if (($dateRange.End - $dateRange.Start).Days -le 7) {
            $daily = $group.Group | Group-Object date | Sort-Object Name
            
            foreach ($day in $daily) {
                $dayMinutes = ($day.Group | Measure-Object minutes -Sum).Sum
                $dayHours = [Math]::Round($dayMinutes / 60, 2)
                $dayDate = [datetime]$day.Name
                
                Write-Host ("    {0,-15} {1,6}h" -f $dayDate.ToString("ddd MM/dd"), $dayHours) -ForegroundColor Gray
                
                # Show individual entries for very detailed view
                if ($day.Group.Count -le 3) {
                    $day.Group | ForEach-Object {
                        if ($_.notes) {
                            $entryHours = [Math]::Round($_.minutes / 60, 2)
                            Write-Host ("      {0} {1}h - {2}" -f $_.time, $entryHours, $_.notes) -ForegroundColor DarkGray
                        }
                    }
                }
            }
        }
    }
    
    $totalHours = [Math]::Round($totalMinutes / 60, 2)
    Write-Host ("  {0}" -f ("-" * 40)) -ForegroundColor DarkGray
    Write-Host ("  {0,-25} {1,8} hours" -f "TOTAL", $totalHours) -ForegroundColor Yellow
}

function Log-Time {
    param(
        [string]$ProjectName = "",
        [string]$Duration = "",
        [string]$Description = "",
        [switch]$Interactive
    )
    
    # Interactive mode or missing parameters
    if ($Interactive -or [string]::IsNullOrWhiteSpace($ProjectName) -or [string]::IsNullOrWhiteSpace($Duration)) {
        Clear-Host
        Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor DarkGray
        Write-Host "  ‚ïë                    TIME LOGGING ENTRY                      ‚ïë" -ForegroundColor Cyan
        Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor DarkGray
        Write-Host ""
        
        if ([string]::IsNullOrWhiteSpace($ProjectName)) {
            Write-Host "  üìÅ Project: " -NoNewline -ForegroundColor Cyan
            $ProjectName = Read-Host
            if ([string]::IsNullOrWhiteSpace($ProjectName)) {
                Write-Host "  ‚ùå Project name required" -ForegroundColor Red
                Pause-Screen
                return
            }
        }
        
        if ([string]::IsNullOrWhiteSpace($Duration)) {
            Write-Host "  ‚è±Ô∏è  Duration (e.g., 2h, 90m, 1.5h): " -NoNewline -ForegroundColor Cyan
            $Duration = Read-Host
            if ([string]::IsNullOrWhiteSpace($Duration)) {
                Write-Host "  ‚ùå Duration required" -ForegroundColor Red
                Pause-Screen
                return
            }
        }
        
        if ([string]::IsNullOrWhiteSpace($Description)) {
            Write-Host "  üìù Description (optional): " -NoNewline -ForegroundColor Cyan
            $Description = Read-Host
        }
        
        # Optional date override
        Write-Host "  üìÖ Date (YYYY-MM-DD, blank for today): " -NoNewline -ForegroundColor Cyan
        $dateOverride = Read-Host
    }
    
    # Find or create project
    $project = Find-Project -query $ProjectName -Interactive -AllowCreate
    if (-not $project) {
        Write-Host "Cannot determine project for time log." -ForegroundColor Red
        return
    }
    
    # Parse duration
    $minutes = Parse-DurationToMinutes $Duration
    if ($minutes -le 0) {
        Write-Host "Invalid duration: $Duration" -ForegroundColor Red
        Write-Host "Use format: 1.5h, 90m, 2h, 30m" -ForegroundColor Gray
        Pause-Screen
        return
    }
    
    # Determine date
    $logDate = if ([string]::IsNullOrWhiteSpace($dateOverride)) { 
        Get-Date 
    } else { 
        try { 
            [datetime]::Parse($dateOverride) 
        } catch { 
            Write-Host "Invalid date format: $dateOverride" -ForegroundColor Red
            Pause-Screen
            return
        }
    }
    
    # Create log entry (both JSON and CSV)
    $data = Get-TaskData
    
    # Add to JSON structure (existing system)
    $log = @{
        project = $project.name
        minutes = $minutes
        date = $logDate.ToString("yyyy-MM-dd")
        time = $logDate.ToString("HH:mm")
        notes = $Description
        id = [System.Guid]::NewGuid().ToString()
    }
    
    $data.timelogs += $log
    Save-TaskData $data
    
    # Add to CSV ledger (new enhancement)
    Export-TimeToCsv -LogEntry $log -ProjectData $project
    
    # Display confirmation
    $hours = [Math]::Round($minutes / 60, 2)
    Write-Host "`n  ‚úÖ Logged $hours hours to '$($project.name)'" -ForegroundColor Green
    if ($Description) {
        Write-Host "  üìù $Description" -ForegroundColor Gray
    }
    Write-Host "  üìÖ Date: $($log.date) at $($log.time)" -ForegroundColor Gray
    
    if ($Interactive) {
        Pause-Screen
    }
}

function Export-TimeToCsv {
    param(
        [hashtable]$LogEntry,
        [hashtable]$ProjectData
    )
    
    
    # Determine CSV file path from Config
    try { [ConfigManager]::Load() } catch {}
    # Honor WhatIf: skip CSV export when enabled
    $cfg0 = $null; try { $cfg0 = [ConfigManager]::Config } catch {}
    try { if ($cfg0 -and $cfg0.Behavior -and $cfg0.Behavior.WhatIf) { return } } catch {}
    $csvPath = $null
    try { $cfg = [ConfigManager]::Config } catch {}
    $enabled = if ($cfg -and $cfg.Behavior -and $cfg.Behavior.EnableCsvLedger -ne $null) { [bool]$cfg.Behavior.EnableCsvLedger } else { $true }
    if (-not $enabled) { return }
    $pathSetting = if ($cfg -and $cfg.Paths) { $cfg.Paths.CsvLedgerPath } else { 'time_ledger.csv' }
    if ([string]::IsNullOrWhiteSpace($pathSetting)) { $pathSetting = 'time_ledger.csv' }
    $csvPath = Get-SafePath -Path $pathSetting -Base $PSScriptRoot
    # Enforce .csv extension for safety
    try { if (-not $csvPath.ToLower().EndsWith('.csv')) { $csvPath = "$csvPath.csv" } } catch {}
    Write-DebugLog ("Export-TimeToCsv resolved path: " + $csvPath)
    
    # Ensure directory exists
    $csvDir = Split-Path -Parent $csvPath
    if (-not (Test-Path $csvDir)) { New-Item -ItemType Directory -Path $csvDir -Force | Out-Null }

    # Create CSV headers if file doesn't exist
    if (-not (Test-Path $csvPath)) {
        $headers = @(
            "Date", "Time", "Project", "ProjectID1", "ProjectID2", 
            "Duration_Minutes", "Duration_Hours", "Description", 
            "CAAName", "T2020", "LogID"
        )
        try {
            $headers -join "," | Out-File -FilePath $csvPath -Encoding UTF8
            Write-DebugLog ("Export-TimeToCsv created CSV with headers at: " + $csvPath)
        } catch {
            Write-DebugLog ("Export-TimeToCsv header write failed: " + $_)
        }
    }
    
    # Create CSV row
    $hours = [Math]::Round($LogEntry.minutes / 60, 2)
    $desc = if ($LogEntry.ContainsKey('notes') -and $LogEntry.notes) { $LogEntry.notes } elseif ($LogEntry.ContainsKey('description') -and $LogEntry.description) { $LogEntry.description } else { "" }
    $id2Formatted = if ($ProjectData.ID2) { (Format-ProjectID2Csv $ProjectData.ID2) } else { "" }
    $csvRow = @(
        $LogEntry.date,
        $LogEntry.time,
        $LogEntry.project,
        $(if ($ProjectData.ID1) { $ProjectData.ID1 } else { "" }),
        $id2Formatted,
        $LogEntry.minutes,
        $hours,
        $(if ($desc) { "`"$($desc -replace '"', '""')`"" } else { "" }),
        $(if ($ProjectData.CAAName) { $ProjectData.CAAName } else { "" }),
        $(if ($ProjectData.T2020) { $ProjectData.T2020 } else { "" }),
        $LogEntry.id
    )
    
    try {
        $csvRow -join "," | Out-File -FilePath $csvPath -Append -Encoding UTF8
        Write-DebugLog ("Export-TimeToCsv appended row for date=" + $LogEntry.date + ", project=" + $LogEntry.project)
    } catch {
        Write-DebugLog ("Export-TimeToCsv append failed: " + $_)
    }
}

function Show-TimeReportEnhanced {
    param(
        [string]$DateRange = "week",
        [string]$ProjectFilter = "",
        [switch]$ExportCsv,
        [string]$OutputPath = "",
        [switch]$WithIDs,
        [string]$ByID2 = ""
    )
    
    $data = Get-TaskData
    $rangeInfo = Parse-DateRange -range $DateRange
    Write-DebugLog (("REPORT: Range='{0}' -> Start={1}, End={2}" -f $DateRange, $rangeInfo.Start, $rangeInfo.End))
    
    # Get logs for date range (array) and ignore zero-minute timer entries
    $logs = @($data.timelogs | Where-Object { 
        ([datetime]$_.date -ge $rangeInfo.Start) -and ([datetime]$_.date -lt $rangeInfo.End) -and ([double]$_.minutes -gt 0)
    })
    Write-DebugLog (("REPORT: Found logs in range: {0}" -f ($logs.Count)))
    
    # Filter by project if specified
    if ($ProjectFilter) {
        $project = Find-Project -query $ProjectFilter -Interactive
        if ($project) {
            $logs = $logs | Where-Object { $_.project -eq $project.name }
            $projDisplay = " for $($project.name)"
        } else {
            return
        }
    } else {
        $projDisplay = ""
    }

    # Filter by raw ID2 if specified
    if ($ByID2) {
        $raw = $ByID2.ToString().Trim()
        $logs = $logs | Where-Object {
            $p = ($data.projects | Where-Object { $_.name -eq $_.project } | Select-Object -First 1)
            $p -and $p.ID2 -and ($p.ID2 -eq $raw)
        }
        if (-not $logs) { Write-Host "No time logged for $($rangeInfo.Display) matching ID2=$raw" -ForegroundColor Gray; return }
        $projDisplay += " (ID2=$raw)"
    }
    
    if (-not $logs -or $logs.Count -eq 0) {
        Write-Host "No time logged for $($rangeInfo.Display)$projDisplay" -ForegroundColor Gray
        return
    }
    
    Clear-Host
    Write-Host "`n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor DarkGray
    Write-Host "  ‚ïë                    ENHANCED TIME REPORT                    ‚ïë" -ForegroundColor Cyan
    Write-Host "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor DarkGray
    Write-Host ""
    
    # Create detailed report data
    $reportData = @()
    $totalMinutes = 0
    
    foreach ($log in ($logs | Sort-Object date, time)) {
        $project = $data.projects | Where-Object { $_.name -eq $log.project } | Select-Object -First 1
        $hours = [Math]::Round([double]$log.minutes / 60, 2)
        $totalMinutes += $log.minutes
        
        $reportData += [PSCustomObject]@{
            Date = $log.date
            Time = $(if ($log.PSObject.Properties['time'] -and $log.time) { $log.time } elseif ($log.PSObject.Properties['endTime'] -and $log.endTime) { (Get-Date $log.endTime).ToString('HH:mm') } else { '' })
            Project = $log.project
            Hours = $hours
            Description = if ($log.notes) { $log.notes } else { "(no description)" }
            ID1 = if ($project.ID1) { $project.ID1 } else { "" }
            ID2 = if ($project.ID2) { (Format-ProjectID2Csv $project.ID2) } else { "" }
            CAA = if ($project.CAAName) { $project.CAAName } else { "" }
        }
    }
    
    # Display report using Format-StyledTable
    $displayRows = @()
        if ($WithIDs) {
        foreach ($item in $reportData) { $displayRows += , @($item.Date, $item.Time, $item.Project, $item.ID1, $item.ID2, $item.Hours, $item.Description) }
        Format-StyledTable -Headers @("Date", "Time", "Project", "ID1", "ID2", "Hours", "Description") -DataRows $displayRows -Title "TIME LOG DETAILS - $($rangeInfo.Display)$projDisplay"
    } else {
        foreach ($item in $reportData) { $displayRows += , @($item.Date, $item.Time, $item.Project, $item.Hours, $item.Description) }
        Format-StyledTable -Headers @("Date", "Time", "Project", "Hours", "Description") -DataRows $displayRows -Title "TIME LOG DETAILS - $($rangeInfo.Display)$projDisplay"
    }
    
    # Summary by project
    Write-Host ""
    $grouped = $reportData | Group-Object Project
    $summaryRows = @()
    foreach ($group in $grouped) {
        $groupTotal = ($group.Group | Measure-Object Hours -Sum).Sum
        $summaryRows += , @($group.Name, $group.Count, [Math]::Round($groupTotal, 2))
    }
    
    Format-StyledTable -Headers @("Project", "Entries", "Total Hours") -DataRows $summaryRows -Title "PROJECT SUMMARY"
    
    # Grand total
    $totalHours = [Math]::Round([double]$totalMinutes / 60, 2)
    Write-Host "`n  üìä GRAND TOTAL: $totalHours hours across $($logs.Count) entries" -ForegroundColor Yellow
    
    # CSV Export option
    if ($ExportCsv) {
        if ([string]::IsNullOrWhiteSpace($OutputPath)) {
            $OutputPath = "time_report_$(Get-Date -Format 'yyyyMMdd_HHmm').csv"
        }
        $safeOut = Get-SafePath -Path $OutputPath -Base $PSScriptRoot
        try {
            $dir = [System.IO.Path]::GetDirectoryName($safeOut)
            if ($dir -and -not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null }
            $reportData | Export-Csv -Path $safeOut -NoTypeInformation -Encoding UTF8
            Write-Host "  üìÑ Report exported to: $safeOut" -ForegroundColor Green
        } catch {
            Write-Host "  ‚ùå Failed to export report: $_" -ForegroundColor Red
        }
    }
    
    Write-Host "`n  üí° Use 'log time' to add more time entries" -ForegroundColor DarkCyan
    Write-Host "  üí° Add -ExportCsv to export this report to CSV" -ForegroundColor DarkCyan
    Write-Host ""
    
    Pause-Screen
}

# === NATURAL DATE PARSING ===

function GetNextWeekday {
    param([datetime]$from, [DayOfWeek]$targetDay)
    
    $daysUntilTarget = ([int]$targetDay - [int]$from.DayOfWeek + 7) % 7
    if ($daysUntilTarget -eq 0) { $daysUntilTarget = 7 }
    return $from.Date.AddDays($daysUntilTarget)
}

function Parse-NaturalDate {
    param([Alias('input')][string]$text)
    
    if (-not $text) { return $null }
    
    $today = (Get-Date).Date
    $patterns = @{
        '^(\d+)d$' = { param($m) $today.AddDays([int]$m[1]) }
        '^(\d+)w$' = { param($m) $today.AddDays([int]$m[1] * 7) }
        '^(\d+)m$' = { param($m) $today.AddMonths([int]$m[1]) }
        '^(\d+)y$' = { param($m) $today.AddYears([int]$m[1]) }
        '^next (\w+)$' = { param($m) 
            try {
                $targetDay = [Enum]::Parse([DayOfWeek], $m[1], $true)
                $daysUntil = ($targetDay - $today.DayOfWeek + 7) % 7
                if ($daysUntil -eq 0) { $daysUntil = 7 }
                $today.AddDays($daysUntil)
            } catch { $null }
        }
        '^(eow|endofweek)$' = { 
            # End of week (Sunday)
            $daysUntilSunday = (7 - [int]$today.DayOfWeek) % 7
            if ($daysUntilSunday -eq 0) { $daysUntilSunday = 7 }
            $today.AddDays($daysUntilSunday)
        }
        '^(sow|startofweek)$' = { 
            # Start of week (Monday)
            $daysSinceMonday = ([int]$today.DayOfWeek + 6) % 7
            $today.AddDays(-$daysSinceMonday)
        }
        '^(eom|endofmonth)$' = { 
            # End of month
            $today.AddMonths(1).AddDays(-$today.AddMonths(1).Day) 
        }
        '^(som|startofmonth)$' = { 
            # Start of month
            $today.AddDays(-$today.Day + 1)
        }
        '^(eoy|endofyear)$' = {
            # End of year
            Get-Date -Month 12 -Day 31 -Year $today.Year
        }
        '^(soy|startofyear)$' = {
            # Start of year
            Get-Date -Month 1 -Day 1 -Year $today.Year
        }
        '^(mon|monday)$' = { GetNextWeekday $today ([DayOfWeek]::Monday) }
        '^(tue|tuesday)$' = { GetNextWeekday $today ([DayOfWeek]::Tuesday) }
        '^(wed|wednesday)$' = { GetNextWeekday $today ([DayOfWeek]::Wednesday) }
        '^(thu|thursday)$' = { GetNextWeekday $today ([DayOfWeek]::Thursday) }
        '^(fri|friday)$' = { GetNextWeekday $today ([DayOfWeek]::Friday) }
        '^(sat|saturday)$' = { GetNextWeekday $today ([DayOfWeek]::Saturday) }
        '^(sun|sunday)$' = { GetNextWeekday $today ([DayOfWeek]::Sunday) }
        '^(\d+)(?:st|nd|rd|th)$' = { param($m)
            $day = [int]$m[1]
            if ($day -ge 1 -and $day -le 31) {
                try {
                    $targetDate = Get-Date -Day $day
                    if ($targetDate -le $today) { 
                        $targetDate = $targetDate.AddMonths(1) 
                    }
                    $targetDate
                } catch { $null }
            }
        }
        '^(\w+) (\d+)$' = { param($m)
            # Month day format (Jan 15)
            try {
                $month = [datetime]::ParseExact($m[1], "MMM", $null).Month
                $day = [int]$m[2]
                $targetDate = Get-Date -Month $month -Day $day
                if ($targetDate -le $today) {
                    $targetDate = $targetDate.AddYears(1)
                }
                $targetDate
            } catch { $null }
        }
        '^today$' = { $today }
        '^tomorrow$' = { $today.AddDays(1) }
        '^yesterday$' = { $today.AddDays(-1) }
    }
    
    $lowerInput = $text.ToLower()
    
    foreach ($pattern in $patterns.GetEnumerator()) {
        if ($lowerInput -match $pattern.Key) {
            $result = & $pattern.Value $matches
            if ($result) {
                return $result.ToString("yyyy-MM-dd")
            }
        }
    }
    
    # Try parsing as standard date
    try {
        $date = [datetime]::Parse($text)
        return $date.ToString("yyyy-MM-dd")
    } catch {
        return $null
    }
}

# === ENHANCED AGENDA DISPLAY ===

function Show-EnhancedAgenda {
    $global:LastShownTaskMap.Clear()
    $localIdCounter = 1
    $data = Get-TaskData
    $prefs = $data.preferences
    $today = (Get-Date).Date
    $todayStr = $today.ToString("yyyy-MM-dd")
    
    Write-Host "`n=== DAILY AGENDA ===" -ForegroundColor Cyan
    
    # Show current context
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        Write-Host "Current focus: $global:CurrentContext" -ForegroundColor Yellow
    }
    
    Write-Host
    
    # Time logged today
    if ($prefs.agendaShowTimeToday) {
        $todayLogs = $data.timelogs | Where-Object { $_.date -eq $todayStr }
        $todayMinutes = ($todayLogs | Measure-Object minutes -Sum).Sum
        
        if ($todayMinutes -gt 0) {
            $todayHours = [Math]::Round($todayMinutes / 60, 2)
            Write-Host "Time logged today: $todayHours hours" -ForegroundColor Green
            Write-Host
        }
    }
    
    $foundUrgent = $false
    
    # Overdue tasks (highest priority)
    if ($prefs.agendaShowOverdue) {
        $overdue = $data.tasks | Where-Object { 
            $_.status -eq 'pending' -and $_.due -and $_.due -lt $todayStr 
        } | Sort-Object due, priority
        
        if ($overdue) {
            Write-Host "OVERDUE TASKS:" -ForegroundColor Red
            foreach ($task in $overdue) {
                $days = ([datetime]$todayStr - [datetime]$task.due).Days
                $pri = @("", "!", "!!", "!!!")[$task.priority]
                $priColor = @("Gray", "Red", "Yellow", "Cyan")[$task.priority]
                
                Write-Host ("  [{0,2}] (#{1}) " -f $localIdCounter, $task.id) -NoNewline -ForegroundColor DarkGray
                Write-Host "$pri " -NoNewline -ForegroundColor $priColor
                Write-Host $task.text -NoNewline
                Write-Host " ($days day$(if($days -ne 1){'s'}) late)" -ForegroundColor Red
                
                Set-LastShownEntry -LocalId $localIdCounter -TaskId $task.id
                $localIdCounter++
            }
            Write-Host
            $foundUrgent = $true
        }
    }
    
    # Today's tasks
    if ($prefs.agendaShowToday) {
        $todayTasks = $data.tasks | Where-Object { 
            $_.status -eq 'pending' -and $_.due -eq $todayStr 
        } | Sort-Object priority
        
        if ($todayTasks) {
            Write-Host "TODAY'S TASKS:" -ForegroundColor Yellow
            foreach ($task in $todayTasks) {
                $pri = @("", "!", "!!", "!!!")[$task.priority]
                $priColor = @("Gray", "Red", "Yellow", "Cyan")[$task.priority]
                
                Write-Host ("  [{0,2}] (#{1}) " -f $localIdCounter, $task.id) -NoNewline -ForegroundColor Gray
                Write-Host "$pri " -NoNewline -ForegroundColor $priColor
                Write-Host $task.text
                
                Set-LastShownEntry -LocalId $localIdCounter -TaskId $task.id
                $localIdCounter++
            }
            Write-Host
            $foundUrgent = $true
        }
    }
    
    # High priority tasks (if no urgent items)
    if (-not $foundUrgent) {
        $highPri = $data.tasks | Where-Object { 
            $_.status -eq 'pending' -and $_.priority -eq 1 
        } | Select-Object -First 3
        
        if ($highPri) {
            Write-Host "HIGH PRIORITY TASKS:" -ForegroundColor Red
            foreach ($task in $highPri) {
                Write-Host ("  [{0,2}] (#{1}) !!! {2}" -f $localIdCounter, $task.id, $task.text) -ForegroundColor Red
                Set-LastShownEntry -LocalId $localIdCounter -TaskId $task.id
                $localIdCounter++
            }
            Write-Host
        }
    }
    
    # Upcoming tasks
    if ($prefs.agendaShowUpcoming) {
        $upcoming = $data.tasks | Where-Object { 
            $_.status -eq 'pending' -and $_.due -and 
            $_.due -gt $todayStr -and 
            $_.due -le $today.AddDays($prefs.agendaDaysAhead).ToString("yyyy-MM-dd")
        } | Sort-Object due, priority
        
        if ($upcoming) {
            Write-Host "UPCOMING ($($prefs.agendaDaysAhead) days):" -ForegroundColor Cyan
            foreach ($task in $upcoming) {
                $dueDate = [datetime]$task.due
                $days = ($dueDate - $today).Days
                $dayText = if ($days -eq 1) { "Tomorrow" } else { $dueDate.ToString("ddd MMM d") }
                
                Write-Host ("  [{0,2}] (#{1}) {2} ({3})" -f $localIdCounter, $task.id, $task.text, $dayText) -ForegroundColor Gray
                Set-LastShownEntry -LocalId $localIdCounter -TaskId $task.id
                $localIdCounter++
            }
            Write-Host
        }
    }
    
    # Current context summary
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        $contextTasks = @($data.tasks | Where-Object { 
            $_.project -eq $global:CurrentContext -and $_.status -eq 'pending' 
        })
        
        if ($contextTasks.Count -gt 0) {
            Write-Host "FOCUSED PROJECT ($($global:CurrentContext)): $($contextTasks.Count) task$(if($contextTasks.Count -ne 1){'s'})" -ForegroundColor Cyan
        }
    }
    
    # Quick action suggestions
    if ($localIdCounter -gt 1) {
        Write-Host "Quick actions: done 1-3 (complete), rm 2 (delete), next (show next task)" -ForegroundColor DarkGray
    }
}

# === CONFIGURATION MENU ===

# Removed duplicate Show-ConfigMenu - use the improved config system instead

# === STATISTICS ===

function Show-Statistics {
    $data = Get-TaskData
    $today = (Get-Date).Date
    
    Write-Host "`n=== PRODUCTIVITY STATISTICS ===" -ForegroundColor Cyan
    
    # Task counts
    $pendingCount = @($data.tasks | Where-Object { $_.status -eq 'pending' }).Count
    $completedCount = @($data.completed).Count + @($data.tasks | Where-Object { $_.status -eq 'completed' }).Count
    $totalTasks = $pendingCount + $completedCount
    
    Write-Host "`nTASKS:" -ForegroundColor Yellow
    Write-Host "  Pending: $pendingCount" -ForegroundColor Gray
    Write-Host "  Completed: $completedCount" -ForegroundColor Green
    Write-Host "  Total: $totalTasks" -ForegroundColor White
    
    if ($totalTasks -gt 0) {
        $completionRate = [Math]::Round(($completedCount / $totalTasks) * 100, 1)
        Write-Host "  Completion Rate: $completionRate%" -ForegroundColor Cyan
    }
    
    # Time statistics
    $totalMinutes = ($data.timelogs | Measure-Object minutes -Sum).Sum
    $totalHours = [Math]::Round($totalMinutes / 60, 1)
    
    Write-Host "`nTIME TRACKING:" -ForegroundColor Yellow
    Write-Host "  Total Logged: $totalHours hours" -ForegroundColor Gray
    
    # This week
    $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
    $weekMinutes = ($data.timelogs | Where-Object { 
        [datetime]$_.date -ge $weekStart 
    } | Measure-Object minutes -Sum).Sum
    $weekHours = [Math]::Round($weekMinutes / 60, 1)
    
    Write-Host "  This Week: $weekHours hours" -ForegroundColor Gray
    
    # Project statistics
    $projectCount = @($data.projects).Count
    $activeProjects = @($data.projects | Where-Object {
        $data.tasks | Where-Object { $_.project -eq $_.name -and $_.status -eq 'pending' }
    }).Count
    
    Write-Host "`nPROJECTS:" -ForegroundColor Yellow
    Write-Host "  Total: $projectCount" -ForegroundColor Gray
    Write-Host "  With Active Tasks: $activeProjects" -ForegroundColor Gray
    
    # Most productive project
    $projectTime = $data.timelogs | Group-Object project | 
                   ForEach-Object { 
                       [PSCustomObject]@{ 
                           Project = $_.Name
                           Hours = [Math]::Round(($_.Group | Measure-Object minutes -Sum).Sum / 60, 1)
                       }
                   } | Sort-Object Hours -Descending | Select-Object -First 1
    
    if ($projectTime) {
        Write-Host "  Most Time: $($projectTime.Project) ($($projectTime.Hours)h)" -ForegroundColor Green
    }
}

# === QUICK ENTRY MODE ===

function Start-QuickEntry {
    Write-Host "`n=== QUICK ENTRY MODE ===" -ForegroundColor Cyan
    Write-Host "Enter tasks quickly. Empty line to finish." -ForegroundColor Gray
    Write-Host "Format: task text @project #tag due:tomorrow p1" -ForegroundColor Gray
    Write-Host
    
    $tasks = @()
    $count = 0
    
    do {
        Write-Host "‚ûú " -NoNewline -ForegroundColor Green
        $input = Read-Host
        
        if ($input) {
            $metadata = Extract-Metadata -text $input
            $finalProject = if ($metadata.Project) { $metadata.Project } elseif ($global:CurrentContext) { $global:CurrentContext } else { 'inbox' }
            
            $parsed = @{
                Text = $metadata.CleanText
                Project = $finalProject
                Priority = $metadata.Priority
                Due = $metadata.Due
                EstimatedTime = $metadata.EstimatedTime
                Tags = $metadata.Tags
                CustomFields = $metadata.CustomFields
            }
            
            Add-SmartTask -parsed $parsed
            $tasks += $input
            $count++
            Write-Host "  ‚úì Added" -ForegroundColor DarkGreen
        }
    } while ($input)
    
    if ($count -gt 0) {
        Write-Host "`nAdded $count task$(if($count -ne 1){'s'})" -ForegroundColor Green
        Show-RichAgenda
    }
}

# === MISSING COMMAND IMPLEMENTATIONS ===

function Edit-Configuration {
    Show-ConfigEditor
}

function Clear-Focus {
    Set-CurrentContext -projectName 'inbox'
    Write-Host "Project focus cleared. Back to inbox." -ForegroundColor Green
}

function Show-ContextInfo {
    Write-Host "`n‚ÑπÔ∏è  CURRENT CONTEXT" -ForegroundColor Cyan
    
    if ($global:CurrentContext -and $global:CurrentContext -ne 'inbox') {
        Write-Host "  Active Focus: $global:CurrentContext" -ForegroundColor Yellow
        
        $data = Get-TaskData
        $contextTasks = @($data.tasks | Where-Object { 
            $_.project -eq $global:CurrentContext -and -not $_.done 
        })
        
        Write-Host "  Pending Tasks: $($contextTasks.Count)" -ForegroundColor Gray
        
        if ($contextTasks.Count -gt 0) {
            $overdue = @($contextTasks | Where-Object { 
                $_.due -and [datetime]$_.due -lt (Get-Date).Date 
            }).Count
            $today = @($contextTasks | Where-Object { 
                $_.due -and [datetime]$_.due -eq (Get-Date).Date 
            }).Count
            
            if ($overdue -gt 0) {
                Write-Host "  Overdue: $overdue" -ForegroundColor Red
            }
            if ($today -gt 0) {
                Write-Host "  Due Today: $today" -ForegroundColor Yellow
            }
        }
    } else {
        Write-Host "  No active focus (showing all projects)" -ForegroundColor Gray
    }
    
    Write-Host "`n  Switch focus with: focus <project>" -ForegroundColor DarkGray
    Write-Host "  Clear focus with: focus clear" -ForegroundColor DarkGray
}

function Start-WeeklyReview {
    $data = Get-TaskData
    $today = (Get-Date).Date
    $weekStart = $today.AddDays(-[int]$today.DayOfWeek)
    
    Write-Host "`nüìÖ WEEKLY REVIEW" -ForegroundColor Cyan
    Write-Host "Week of $($weekStart.ToString('yyyy-MM-dd'))" -ForegroundColor Gray
    Write-Host "=" * 50 -ForegroundColor Gray
    
    # This week's accomplishments
    $completedThisWeek = @($data.tasks | Where-Object {
        $_.done -and $_.completed -and
        [datetime]$_.completed -ge $weekStart -and [datetime]$_.completed -lt $weekStart.AddDays(7)
    })
    
    Write-Host "`n‚úÖ ACCOMPLISHMENTS ($($completedThisWeek.Count)):" -ForegroundColor Green
    if ($completedThisWeek.Count -gt 0) {
        $completedThisWeek | ForEach-Object {
            $projectLabel = if ($_.project) { "[$($_.project)]" } else { "[inbox]" }
            Write-Host "  ‚Ä¢ $($_.text) $projectLabel" -ForegroundColor Gray
        }
    } else {
        Write-Host "  No tasks completed this week" -ForegroundColor Yellow
    }
    
    # Incomplete tasks
    $incompleteTasks = @($data.tasks | Where-Object { -not $_.done })
    $overdueTasks = @($incompleteTasks | Where-Object { 
        $_.due -and [datetime]$_.due -lt $today 
    })
    
    Write-Host "`n‚è≥ REVIEW NEEDED:" -ForegroundColor Yellow
    if ($overdueTasks.Count -gt 0) {
        Write-Host "  Overdue Tasks: $($overdueTasks.Count)" -ForegroundColor Red
        $overdueTasks | Select-Object -First 5 | ForEach-Object {
            $daysOverdue = ($today - [datetime]$_.due).Days
            Write-Host "    ‚Ä¢ $($_.text) ($daysOverdue days overdue)" -ForegroundColor Red
        }
    }
    
    # Next week planning
    $nextWeekStart = $weekStart.AddDays(7)
    $nextWeekTasks = @($incompleteTasks | Where-Object {
        $_.due -and [datetime]$_.due -ge $nextWeekStart -and [datetime]$_.due -lt $nextWeekStart.AddDays(7)
    })
    
    Write-Host "`nüéØ NEXT WEEK PLANNING:" -ForegroundColor Blue
    Write-Host "  Scheduled Tasks: $($nextWeekTasks.Count)" -ForegroundColor Gray
    if ($nextWeekTasks.Count -gt 0) {
        $nextWeekTasks | Select-Object -First 5 | ForEach-Object {
            Write-Host "    ‚Ä¢ $($_.text) (due: $($_.due))" -ForegroundColor Gray
        }
    }
    
    # Time tracking summary
    $weekLogs = @($data.timelogs | Where-Object {
        [datetime]$_.date -ge $weekStart -and [datetime]$_.date -lt $weekStart.AddDays(7)
    })
    
    if ($weekLogs.Count -gt 0) {
        $totalHours = [Math]::Round(($weekLogs | Measure-Object minutes -Sum).Sum / 60, 1)
        Write-Host "`n‚è±Ô∏è  TIME SUMMARY:" -ForegroundColor Magenta
        Write-Host "  Total Logged: $totalHours hours" -ForegroundColor Gray
        Write-Host "  Sessions: $($weekLogs.Count)" -ForegroundColor Gray
    }
    
    Write-Host "`n" + ("=" * 50) -ForegroundColor Gray
    Write-Host "Review complete. Plan your next week!" -ForegroundColor Green
}

function Backup-Data {
    $data = Get-TaskData
    $timestamp = (Get-Date).ToString("yyyyMMdd-HHmmss")
    $backupPath = Join-Path $global:DataPath "backup-$timestamp.json"
    
    try {
        $data | ConvertTo-Json -Depth 10 | Out-File $backupPath -Encoding UTF8
        Write-Host "‚úÖ Data backed up to: $backupPath" -ForegroundColor Green
        
        # Keep only last 5 backups
        $backupFiles = Get-ChildItem (Join-Path $global:DataPath "backup-*.json") | 
                       Sort-Object LastWriteTime -Descending | 
                       Select-Object -Skip 5
        
        if ($backupFiles) {
            $backupFiles | Remove-Item
            Write-Host "   Cleaned up $($backupFiles.Count) old backup(s)" -ForegroundColor Gray
        }
    } catch {
        Write-Host "‚ùå Backup failed: $_" -ForegroundColor Red
    }
}

function Clean-CompletedTasks {
    $data = Get-TaskData
    $completedTasks = @($data.tasks | Where-Object { $_.done })
    
    if ($completedTasks.Count -eq 0) {
        Write-Host "No completed tasks to clean" -ForegroundColor Yellow
        return
    }
    
    Write-Host "Found $($completedTasks.Count) completed task(s)" -ForegroundColor Yellow
    Write-Host "Archive completed tasks? (y/N): " -NoNewline -ForegroundColor Red
    $confirm = Read-Host
    
    if ($confirm -eq 'y' -or $confirm -eq 'Y') {
        # Move completed tasks to archive
        if (-not $data.archive) { $data.archive = @() }
        
        $archived = 0
        $data.tasks = @($data.tasks | Where-Object { 
            if ($_.done) {
                $data.archive += $_
                $archived++
                $false
            } else {
                $true
            }
        })
        
        Save-TaskData $data
        Write-Host "‚úÖ Archived $archived completed task(s)" -ForegroundColor Green
        Write-Host "   Tasks moved to archive (use 'show archive' to view)" -ForegroundColor Gray
    } else {
        Write-Host "Cleanup cancelled" -ForegroundColor Yellow
    }
}

function Export-Tasks {
    param($context)
    
    $format = if ($context) { $context.GetArg('format', 'json') } else { 'json' }
    $data = Get-TaskData
    $timestamp = (Get-Date).ToString("yyyyMMdd-HHmmss")
    
    switch ($format.ToLower()) {
        'json' {
            $exportPath = Join-Path $global:DataPath "export-$timestamp.json"
            try {
                $data | ConvertTo-Json -Depth 10 | Out-File $exportPath -Encoding UTF8
                Write-Host "‚úÖ Tasks exported to: $exportPath" -ForegroundColor Green
            } catch {
                Write-Host "‚ùå Export failed: $_" -ForegroundColor Red
            }
        }
        
        'csv' {
            $exportPath = Join-Path $global:DataPath "export-$timestamp.csv"
            try {
                $exportData = $data.tasks | ForEach-Object {
                    [PSCustomObject]@{
                        ID = $_.id
                        Text = $_.text
                        Project = $_.project
                        Priority = $_.priority
                        Due = $_.due
                        Created = $_.created
                        Completed = $_.completed
                        Done = $_.done
                        Tags = ($_.tags -join ';')
                    }
                }
                $exportData | Export-Csv $exportPath -NoTypeInformation -Encoding UTF8
                Write-Host "‚úÖ Tasks exported to: $exportPath" -ForegroundColor Green
            } catch {
                Write-Host "‚ùå CSV export failed: $_" -ForegroundColor Red
            }
        }
        
        default {
            Write-Host "‚ùå Unknown format: $format" -ForegroundColor Red
            Write-Host "Available formats: json, csv" -ForegroundColor Gray
        }
    }
}

function Import-Tasks {
    param($context)
    
    $filePath = if ($context) { $context.GetArg('file', '') } else { '' }
    if (-not $filePath) {
        $filePath = Read-Host "Import file path"
    }
    
    if (-not (Test-Path $filePath)) {
        Write-Host "‚ùå File not found: $filePath" -ForegroundColor Red
        return
    }
    
    try {
        $importData = Get-Content $filePath -Raw | ConvertFrom-Json
        $data = Get-TaskData
        
        if ($importData.tasks) {
            $imported = 0
            $nextId = Get-NextTaskId $data
            
            foreach ($task in $importData.tasks) {
                if (-not $task.id) { $task.id = $nextId++ }
                $data.tasks += $task
                $imported++
            }
            
            Save-TaskData $data
            Write-Host "‚úÖ Imported $imported task(s)" -ForegroundColor Green
        } else {
            Write-Host "‚ùå No tasks found in import file" -ForegroundColor Red
        }
    } catch {
        Write-Host "‚ùå Import failed: $_" -ForegroundColor Red
    }
}

function Redo-Action {
    if (-not $global:RedoStack -or $global:RedoStack.Count -eq 0) {
        Write-Host "Nothing to redo" -ForegroundColor Gray
        return
    }
    $nextState = $global:RedoStack[-1] | ConvertFrom-Json
    if ($global:RedoStack.Count -gt 1) {
        $global:RedoStack = $global:RedoStack[0..($global:RedoStack.Count - 2)]
    } else {
        $global:RedoStack = @()
    }
    # Push current to undo stack then restore
    if ($global:DataCache) {
        $global:UndoStack += ($global:DataCache | ConvertTo-Json -Depth 10)
        $global:UndoStack | ConvertTo-Json -Depth 10 | Set-Content $global:UndoFile -Encoding UTF8
    }
    Save-TaskData -data $nextState -NoUndo
    Write-Host "Redid last action" -ForegroundColor Green
}

function Save-SmartTemplate {
    param($context)
    
    $name = if ($context) { $context.GetArg('name', '') } else { '' }
    $tasks = if ($context) { $context.GetText() } else { '' }
    
    if (-not $name) {
        $name = Read-Host "Template name"
    }
    if (-not $tasks) {
        $tasks = Read-Host "Task definitions (separate with semicolons)"
    }
    
    Save-Template $name $tasks
}

function Apply-SmartTemplate {
    param($context)
    
    $name = if ($context) { $context.GetArg('name', '') } else { '' }
    $project = if ($context) { $context.GetArg('project', $global:CurrentContext) } else { $global:CurrentContext }
    
    if (-not $name) {
        $templates = Get-Templates
        if ($templates.Count -gt 0) {
            Write-Host "Available templates:" -ForegroundColor Yellow
            $templates.Keys | Sort-Object | ForEach-Object {
                Write-Host "  - $_" -ForegroundColor Gray
            }
        }
        $name = Read-Host "Template name"
    }
    
    Use-Template $name $project
}

function Log-ProfessionalTime {
    param($context)
    
    $project = if ($context) { $context.GetArg('project', $global:CurrentContext) } else { $global:CurrentContext }
    $description = if ($context) { $context.GetArg('desc', '') } else { '' }
    $duration = if ($context) { $context.GetArg('duration', '') } else { '' }
    
    if (-not $project) { $project = 'inbox' }
    
    if (-not $description) {
        $description = Read-Host "Work description"
    }
    
    if (-not $duration) {
        $duration = Read-Host "Duration (e.g., 2h, 90m, 1.5h)"
    }
    
    $minutes = Parse-DurationToMinutes $duration
    if ($minutes -le 0) {
        Write-Host "‚ùå Invalid duration format" -ForegroundColor Red
        return
    }
    
    $data = Get-TaskData
    if (-not $data.timelogs) { $data.timelogs = @() }
    
    $timeLog = @{
        project = $project
        description = $description
        date = (Get-Date).ToString("yyyy-MM-dd")
        startTime = (Get-Date).AddMinutes(-$minutes).ToString("yyyy-MM-dd HH:mm:ss")
        endTime = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        minutes = $minutes
        duration = "$([Math]::Floor($minutes / 60))h $($minutes % 60)m"
    }
    
    $data.timelogs += $timeLog
    Save-TaskData $data -NoUndo
    
    Write-Host "‚è±Ô∏è  Time logged successfully" -ForegroundColor Green
    Write-Host "   Project: $project" -ForegroundColor Gray
    Write-Host "   Duration: $($timeLog.duration)" -ForegroundColor Gray
    Write-Host "   Description: $description" -ForegroundColor Gray
}

# Alias management functions
function Show-Aliases {
    if (-not $global:Config -or -not $global:Config.aliases -or $global:Config.aliases.Count -eq 0) {
        Write-Host "No aliases configured." -ForegroundColor Yellow
        return
    }
    
    Write-Host "Configured Aliases:" -ForegroundColor Cyan
    foreach ($alias in $global:Config.aliases.Keys | Sort-Object) {
        $expansion = $global:Config.aliases[$alias]
        Write-Host "  $alias ‚Üí $expansion" -ForegroundColor Gray
    }
}

function Add-UserAlias {
    param($context)
    
    if (-not $context -or $context.Trim() -eq "") {
        Write-Host "Usage: add alias <alias> <expansion>" -ForegroundColor Red
        Write-Host "Example: add alias aw 'add @work p1'" -ForegroundColor Gray
        return
    }
    
    $parts = $context.Trim() -split '\s+', 2
    if ($parts.Count -lt 2) {
        Write-Host "Usage: add alias <alias> <expansion>" -ForegroundColor Red
        Write-Host "Example: add alias aw 'add @work p1'" -ForegroundColor Gray
        return
    }
    
    $alias = $parts[0]
    $expansion = $parts[1].Trim('"').Trim("'")
    
    # Get existing aliases from config
    if (-not $global:Config) { $global:Config = @{} }
    if (-not $global:Config.ContainsKey('aliases')) {
        $global:Config.aliases = @{}
    }
    
    # Add or update alias
    $global:Config.aliases[$alias] = $expansion
    
    Write-Host "‚úì Alias '$alias' ‚Üí '$expansion' added successfully" -ForegroundColor Green
    
    # Reload aliases in current session if handler exists
    if ($global:smartInputHandler) {
        $global:smartInputHandler.InitializeAliases()
    }
}

function Remove-UserAlias {
    param($context)
    
    if (-not $context -or $context.Trim() -eq "") {
        Write-Host "Usage: remove alias <alias>" -ForegroundColor Red
        return
    }
    
    $alias = $context.Trim()
    
    # Check if alias exists
    if (-not $global:Config -or -not $global:Config.aliases -or -not $global:Config.aliases.ContainsKey($alias)) {
        Write-Host "Alias '$alias' not found." -ForegroundColor Yellow
        return
    }
    
    # Remove alias
    $global:Config.aliases.Remove($alias)
    
    Write-Host "‚úì Alias '$alias' removed successfully" -ForegroundColor Green
    
    # Reload aliases in current session if handler exists
    if ($global:smartInputHandler) {
        $global:smartInputHandler.InitializeAliases()
    }
}

# Auto-start
if ($MyInvocation.InvocationName -ne '.') {
    Start-TodoistTUI
} else {
    Write-Host "Enhanced Todoist TUI loaded. Run 'Start-TodoistTUI' to begin." -ForegroundColor Cyan
}

# Safety override: ensure Add-SmartTask handler exists (minimal implementation)
if (-not (Get-Command -Name Add-SmartTask -ErrorAction SilentlyContinue)) {
    function Add-SmartTask {
        param([CommandContext]$context)
        $data = Get-TaskData
        if (-not $data.PSObject.Properties['lastId']) { $data | Add-Member -NotePropertyName lastId -NotePropertyValue 0 -Force }
        $text = $context.GetText()
        if ([string]::IsNullOrWhiteSpace($text)) { Write-Host "Usage: add [@project] [p1-3] [due:date] [#tags] <description>" -ForegroundColor Yellow; return }
        $id = Get-NextTaskId $data
        $proj = $context.GetProject(); if ([string]::IsNullOrWhiteSpace($proj)) { $proj = $global:CurrentContext }
        $pri = $context.GetPriority()
        # Due date (optional)
        $due = $null
        try { $dueArg = $context.GetArg('due', $null); if ($dueArg) { $parsedDue = Parse-NaturalDate -input $dueArg; if ($parsedDue) { $due = $parsedDue } } } catch {}
        $task = @{ id=$id; text=$text; project=$proj; priority=$pri; status='pending'; created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss'); due=$due }
        $data.tasks += $task
        Save-TaskData $data
        Write-Host "  ‚úÖ Task #$id created" -ForegroundColor Green
    }
}
