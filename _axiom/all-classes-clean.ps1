# ==============================================================================
# All Classes - Auto-generated by fixed-extractor.ps1
# Generated: 07/05/2025 16:51:13
# Total Classes/Enums: 42
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation
using namespace System.Threading.Tasks
using namespace System.Collections.Concurrent
#region Classes from modules\models\models.psm1

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

enum BillingType {
    Billable
    NonBillable
}

class ValidationBase {
    # Validates that a string value is not null, empty, or whitespace.
    # Throws an ArgumentException if the validation fails.
    static [void] ValidateNotEmpty(
        [string]$value, # FIX: Removed [Parameter(Mandatory)] and [ValidateNotNullOrEmpty()] attributes. They are not valid on method parameters.
        [string]$parameterName
    ) {
        try {
            if ([string]::IsNullOrWhiteSpace($value)) {
                $errorMessage = "Parameter '$($parameterName)' cannot be null or empty."
                # Write-Error is not appropriate here, as this is a library class. Throwing is correct.
                throw [System.ArgumentException]::new($errorMessage, $parameterName)
            }
            # Write-Verbose is for cmdlets, not ideal for class methods. The throw is sufficient.
        }
        catch {
            # Re-throw to ensure calling context handles the exception
            throw
        }
    }
}

#endregion

#region Classes from components\tui-primitives\tui-primitives.psm1

class TuiAnsiHelper {
    hidden static [System.Collections.Concurrent.ConcurrentDictionary[string, string]] $_fgCache = [System.Collections.Concurrent.ConcurrentDictionary[string, string]]::new()
    hidden static [System.Collections.Concurrent.ConcurrentDictionary[string, string]] $_bgCache = [System.Collections.Concurrent.ConcurrentDictionary[string, string]]::new()

    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int[]] ParseHexColor([string]$hexColor) {
        if ([string]::IsNullOrWhiteSpace($hexColor) -or -not $hexColor.StartsWith("#")) { return $null }
        $hex = $hexColor.Substring(1)
        if ($hex.Length -eq 3) { $hex = "$($hex[0])$($hex[0])$($hex[1])$($hex[1])$($hex[2])$($hex[2])" }
        if ($hex.Length -ne 6) { return $null }
        try {
            $r = [System.Convert]::ToInt32($hex.Substring(0, 2), 16)
            $g = [System.Convert]::ToInt32($hex.Substring(2, 2), 16)
            $b = [System.Convert]::ToInt32($hex.Substring(4, 2), 16)
            return @($r, $g, $b)
        } catch { return $null }
    }

    static [string] GetForegroundCode($color) {
        if ($color -is [ConsoleColor]) {
            return "`e[$([TuiAnsiHelper]::ColorMap[$color.ToString()] ?? 37)m"
        } elseif ($color -is [string] -and $color.StartsWith("#")) {
            return [TuiAnsiHelper]::GetForegroundSequence($color)
        } else {
            return "`e[37m" 
        }
    }

    static [string] GetBackgroundCode($color) {
        if ($color -is [ConsoleColor]) {
            $code = ([TuiAnsiHelper]::ColorMap[$color.ToString()] ?? 30) + 10
            return "`e[${code}m"
        } elseif ($color -is [string] -and $color.StartsWith("#")) {
            return [TuiAnsiHelper]::GetBackgroundSequence($color)
        } else {
            return "`e[40m" 
        }
    }

    static [string] GetForegroundSequence([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor)) { return "" }
        if ([TuiAnsiHelper]::_fgCache.ContainsKey($hexColor)) { 
            return [TuiAnsiHelper]::_fgCache[$hexColor] 
        }
        $rgb = [TuiAnsiHelper]::ParseHexColor($hexColor)
        if (-not $rgb) { return "" }
        $sequence = "`e[38;2;$($rgb[0]);$($rgb[1]);$($rgb[2])m"
        [TuiAnsiHelper]::_fgCache[$hexColor] = $sequence
        return $sequence
    }
    
    static [string] GetBackgroundSequence([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor)) { return "" }
        if ([TuiAnsiHelper]::_bgCache.ContainsKey($hexColor)) { 
            return [TuiAnsiHelper]::_bgCache[$hexColor] 
        }
        $rgb = [TuiAnsiHelper]::ParseHexColor($hexColor)
        if (-not $rgb) { return "" }
        $sequence = "`e[48;2;$($rgb[0]);$($rgb[1]);$($rgb[2])m"
        [TuiAnsiHelper]::_bgCache[$hexColor] = $sequence
        return $sequence
    }
    
    static [string] Reset() { return "`e[0m" }
    static [string] Bold() { return "`e[1m" }
    static [string] Underline() { return "`e[4m" }
    static [string] Italic() { return "`e[3m" }
}

class TuiCell {
    [char] $Char = ' '
    $ForegroundColor = [ConsoleColor]::White
    $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = "" 
    [int] $ZIndex = 0        
    [object] $Metadata = $null 

    TuiCell() { }
    TuiCell([char]$char) { $this.Char = $char }
    TuiCell([char]$char, $fg, $bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }
    TuiCell([char]$char, $fg, $bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }
    # FIX: Removed the [TuiCell] type hint from the $other parameter to prevent cross-module type conversion errors.
    TuiCell([object]$other) {
        $this.Char = $other.Char
        $this.ForegroundColor = $other.ForegroundColor
        $this.BackgroundColor = $other.BackgroundColor
        $this.Bold = $other.Bold
        $this.Underline = $other.Underline
        $this.Italic = $other.Italic
        $this.StyleFlags = $other.StyleFlags
        $this.ZIndex = $other.ZIndex
        $this.Metadata = $other.Metadata
    }

    [TuiCell] WithStyle($fg, $bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    # FIX: Removed the [TuiCell] type hint from the $other parameter to prevent cross-module type conversion errors.
    [TuiCell] BlendWith([object]$other) {
        if ($null -eq $other) { return $this }
        
        # Always replace with source cell if it has a higher z-index
        if ($other.ZIndex -gt $this.ZIndex) { 
            return [TuiCell]::new($other)  # Return a copy to prevent reference issues
        }
        
        # For equal z-index, blend based on content
        if ($other.ZIndex -eq $this.ZIndex) {
            # If other cell has actual content (non-space) or styling, use it
            if ($other.Char -ne ' ' -or $other.Bold -or $other.Underline -or $other.Italic) {
                return [TuiCell]::new($other)
            }
            # If other cell has different background color, use it (for filled backgrounds)
            if ($other.BackgroundColor -ne $this.BackgroundColor) {
                return [TuiCell]::new($other)
            }
        }
        
        return $this
    }

    # FIX: Removed the [TuiCell] type hint from the $other parameter to prevent cross-module type conversion errors.
    [bool] DiffersFrom([object]$other) {
        if ($null -eq $other) { return $true }
        
        # Check all properties for differences
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic -or
                $this.ZIndex -ne $other.ZIndex)  # Also check z-index for overlay changes
    }

    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append($fgCode).Append($bgCode)
        if ($this.Bold) { [void]$sb.Append([TuiAnsiHelper]::Bold()) }
        if ($this.Underline) { [void]$sb.Append([TuiAnsiHelper]::Underline()) }
        if ($this.Italic) { [void]$sb.Append([TuiAnsiHelper]::Italic()) }
        [void]$sb.Append($this.Char)
        return $sb.ToString()
    }

    [hashtable] ToLegacyFormat() {
        return @{ Char = $this.Char; FG = $this.ForegroundColor; BG = $this.BackgroundColor }
    }
    [string] ToString() {
        return "TuiCell(Char='$($this.Char)', FG='$($this.ForegroundColor)', BG='$($this.BackgroundColor)', Bold=$($this.Bold), Underline=$($this.Underline), Italic=$($this.Italic), ZIndex=$($this.ZIndex))"
    }
}

class TuiBuffer {
    [TuiCell[,]] $Cells       
    [int] $Width             
    [int] $Height            
    [string] $Name            
    [bool] $IsDirty = $true  

    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
        Write-Verbose "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
    }

    [void] Clear() { $this.Clear([TuiCell]::new()) }

    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell) 
            }
        }
        $this.IsDirty = $true
        Write-Verbose "TuiBuffer '$($this.Name)' cleared with specified cell."
    }

    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) { return [TuiCell]::new() }
        return $this.Cells[$y, $x]
    }

    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        } else {
            Write-Warning "Attempted to set cell out of bounds in TuiBuffer '$($this.Name)': ($x, $y) is outside 0..$($this.Width-1), 0..$($this.Height-1). Cell: '$($cell.Char)'."
        }
    }

    [void] WriteString([int]$x, [int]$y, [string]$text, $fg, $bg) {
        if ($y -lt 0 -or $y -ge $this.Height) {
            Write-Warning "Skipping WriteString: Y coordinate ($y) out of bounds for buffer '$($this.Name)' (0..$($this.Height-1)). Text: '$text'."
            return
        }
        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break } 
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
        $this.IsDirty = $true
        Write-Verbose "WriteString: Wrote '$text' to buffer '$($this.Name)' at ($x, $y)."
    }

    # FIX: Removed the [TuiBuffer] type hint from the $other parameter to prevent cross-module type conversion errors.
    [void] BlendBuffer([object]$other, [int]$offsetX, [int]$offsetY) {
        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
        $this.IsDirty = $true
        Write-Verbose "BlendBuffer: Blended buffer '$($other.Name)' onto '$($this.Name)' at ($offsetX, $offsetY)."
    }

    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        Write-Verbose "GetSubBuffer: Created sub-buffer '$($subBuffer.Name)' from '$($this.Name)' at ($x, $y) with dimensions $($width)x$($height)."
        return $subBuffer
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height
        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)
        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }
        $this.IsDirty = $true
        Write-Verbose "TuiBuffer '$($this.Name)' resized from $($oldWidth)x$($oldHeight) to $($newWidth)x$($newHeight)."
    }

    [string] ToString() {
        return "TuiBuffer(Name='$($this.Name)', Width=$($this.Width), Height=$($this.Height), IsDirty=$($this.IsDirty))"
    }
}

class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString() # Unique identifier for the task
    [string]$Title                            # Short descriptive title
    [string]$Description                      # Detailed description
    [TaskStatus]$Status = [TaskStatus]::Pending # Current status of the task
    [TaskPriority]$Priority = [TaskPriority]::Medium # Importance level
    [string]$ProjectKey = "General"           # Associated project (key)
    [string]$Category                         # Alias for ProjectKey, for broader use
    [datetime]$CreatedAt = [datetime]::Now   # Timestamp of creation
    [datetime]$UpdatedAt = [datetime]::Now   # Last update timestamp
    [Nullable[datetime]]$DueDate             # Optional due date
    [string[]]$Tags = @()                     # Array of tags
    [int]$Progress = 0                        # Progress percentage (0-100)
    [bool]$Completed = $false                 # Convenience flag for completed status

    # Default constructor: Initializes a new task with default values.
    PmcTask() {}
    
    # Constructor: Initializes a new task with a title.
    PmcTask([string]$title) { # FIX: Removed [Parameter(Mandatory)] and [ValidateNotNullOrEmpty()] attributes from the constructor parameter.
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title
    }
    
    # Constructor: Initializes a new task with common detailed properties.
    PmcTask(
        [string]$title, # FIX: Removed all cmdlet-style attributes from the constructor parameters.
        [string]$description,
        [TaskPriority]$priority,
        [string]$projectKey
    ) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")

        $this.Title = $title
        $this.Description = $description
        $this.Priority = $priority
        $this.ProjectKey = $projectKey
        $this.Category = $projectKey # Category is often an alias for ProjectKey
    }

    # Complete: Marks the task as completed, setting progress to 100% and updating timestamp.
    [void] Complete() {
        $this.Status = [TaskStatus]::Completed
        $this.Completed = $true
        $this.Progress = 100
        $this.UpdatedAt = [datetime]::Now
    }

    # UpdateProgress: Updates the task's progress and adjusts status accordingly.
    # Throws an ArgumentOutOfRangeException if newProgress is outside 0-100.
    [void] UpdateProgress([int]$newProgress) { # FIX: Removed [Parameter(Mandatory)] and [ValidateRange(0,100)]. The validation is done manually inside.
        if ($newProgress -lt 0 -or $newProgress -gt 100) {
            throw [System.ArgumentOutOfRangeException]::new("newProgress", $newProgress, "Progress must be between 0 and 100.")
        }

        $this.Progress = $newProgress
        # Update status based on progress: Completed (100), InProgress (>0), Pending (0)
        $this.Status = switch ($newProgress) {
            100 { [TaskStatus]::Completed }
            { $_ -gt 0 } { [TaskStatus]::InProgress }
            default { [TaskStatus]::Pending }
        }
        $this.Completed = ($this.Status -eq [TaskStatus]::Completed)
        $this.UpdatedAt = [datetime]::Now
    }

    # GetDueDateString: Returns the due date as a formatted string, or "N/A" if null.
    [string] GetDueDateString() {
        return $this.DueDate ? $this.DueDate.Value.ToString("yyyy-MM-dd") : "N/A"
    }

    # ToLegacyFormat: Converts the PmcTask object to a hashtable compatible with older data structures.
    [hashtable] ToLegacyFormat() {
        return @{
            id = $this.Id
            title = $this.Title
            description = $this.Description
            completed = $this.Completed
            priority = $this.Priority.ToString().ToLower() # Convert enum to lowercase string
            project = $this.ProjectKey
            due_date = $this.DueDate ? $this.GetDueDateString() : $null
            created_at = $this.CreatedAt.ToString("o") # ISO 8601 format
            updated_at = $this.UpdatedAt.ToString("o")
        }
    }

    # FromLegacyFormat: Static method to create a PmcTask object from a legacy hashtable format.
    static [PmcTask] FromLegacyFormat([hashtable]$legacyData) { # FIX: Removed [Parameter(Mandatory)] and [ValidateNotNull()] attributes.
        $task = [PmcTask]::new() # Start with a default PmcTask instance
        
        # Populate properties, using null-coalescing where appropriate
        $task.Id = $legacyData.id ?? $task.Id
        $task.Title = $legacyData.title ?? "" # Ensure title is not null
        $task.Description = $legacyData.description ?? ""

        # Handle priority conversion with error handling
        if ($legacyData.priority) {
            try {
                $task.Priority = [TaskPriority]::$($legacyData.priority)
            } catch {
                # Silently fallback to default, logging should be handled by a higher-level system if needed
                $task.Priority = [TaskPriority]::Medium
            }
        }
        
        $task.ProjectKey = $legacyData.project ?? $legacyData.Category ?? "General"
        $task.Category = $task.ProjectKey
        
        if ($legacyData.created_at) {
            try { $task.CreatedAt = [datetime]::Parse($legacyData.created_at) }
            catch { $task.CreatedAt = [datetime]::Now }
        }
        
        if ($legacyData.updated_at) {
            try { $task.UpdatedAt = [datetime]::Parse($legacyData.updated_at) }
            catch { $task.UpdatedAt = $task.CreatedAt }
        }
        
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") {
            try { $task.DueDate = [datetime]::Parse($legacyData.due_date) }
            catch { $task.DueDate = $null }
        }
        
        if ($legacyData.completed -is [bool] -and $legacyData.completed) {
            $task.Complete()
        } else {
            $task.UpdateProgress($task.Progress)
        }
        return $task
    }

    # ToString: Provides a human-readable string representation of the PmcTask object.
    [string] ToString() {
        return "PmcTask(ID: $($this.Id.Substring(0, 8)), Title: '$($this.Title)', Status: $($this.Status), Priority: $($this.Priority))"
    }
}

class PmcProject : ValidationBase {
    [string]$Key = ([Guid]::NewGuid().ToString().Split('-')[0]).ToUpper() # Unique short key (e.g., "ABCD123")
    [string]$Name                                                    # Full project name
    [string]$Client                                                  # Client associated with the project
    [BillingType]$BillingType = [BillingType]::NonBillable           # Billing status
    [double]$Rate = 0.0                                             # Billing rate per hour/unit
    [double]$Budget = 0.0                                           # Project budget
    [bool]$Active = $true                                           # Is the project currently active?
    [datetime]$CreatedAt = [datetime]::Now                         # Timestamp of creation
    [datetime]$UpdatedAt = [datetime]::Now                         # Last update timestamp

    # Default constructor: Initializes a new project with default values.
    PmcProject() {}
    
    # Constructor: Initializes a new project with a key and name.
    PmcProject(
        [string]$key, # FIX: Removed [Parameter(Mandatory)] and [ValidateNotNullOrEmpty()] attributes.
        [string]$name
    ) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key.ToUpper() # Ensure key is always uppercase
        $this.Name = $name
    }

    # ToLegacyFormat: Converts the PmcProject object to a hashtable compatible with older data structures.
    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key
            Name = $this.Name
            Client = $this.Client
            BillingType = $this.BillingType.ToString() # Convert enum to string
            Rate = $this.Rate
            Budget = $this.Budget
            Active = $this.Active
            CreatedAt = $this.CreatedAt.ToString("o") # ISO 8601 format
            UpdatedAt = $this.UpdatedAt.ToString("o") # Include UpdatedAt for consistency
        }
    }

    # FromLegacyFormat: Static method to create a PmcProject object from a legacy hashtable format.
    static [PmcProject] FromLegacyFormat([hashtable]$legacyData) { # FIX: Removed [Parameter(Mandatory)] and [ValidateNotNull()] attributes.
        $project = [PmcProject]::new() # Start with a default PmcProject instance
        
        $project.Key = ($legacyData.Key ?? $project.Key).ToUpper()
        $project.Name = $legacyData.Name ?? ""
        $project.Client = $legacyData.Client ?? ""
        
        if ($legacyData.Rate) {
            try { $project.Rate = [double]$legacyData.Rate } catch {}
        }
        
        if ($legacyData.Budget) {
            try { $project.Budget = [double]$legacyData.Budget } catch {}
        }
        
        if ($legacyData.Active -is [bool]) {
            $project.Active = $legacyData.Active
        }
        
        if ($legacyData.BillingType) {
            try { $project.BillingType = [BillingType]::$($legacyData.BillingType) }
            catch { $project.BillingType = [BillingType]::NonBillable }
        }
        
        if ($legacyData.CreatedAt) {
            try { $project.CreatedAt = [datetime]::Parse($legacyData.CreatedAt) }
            catch { $project.CreatedAt = [datetime]::Now }
        }
        
        if ($legacyData.UpdatedAt) {
             try { $project.UpdatedAt = [datetime]::Parse($legacyData.UpdatedAt) }
             catch { $project.UpdatedAt = $project.CreatedAt }
        } else {
            $project.UpdatedAt = $project.CreatedAt
        }
        
        return $project
    }

    # ToString: Provides a human-readable string representation of the PmcProject object.
    [string] ToString() {
        return "PmcProject(Key: $($this.Key), Name: '$($this.Name)', Active: $($this.Active))"
    }
}

#endregion

#region Classes from components\ui-classes\ui-classes.psm1

class UIElement {
    [string] $Name = "UIElement" 
    [int] $X = 0               
    [int] $Y = 0               
    [int] $Width = 10          
    [int] $Height = 3          
    [bool] $Visible = $true    
    [bool] $Enabled = $true    
    [bool] $IsFocusable = $false 
    [bool] $IsFocused = $false  
    [int] $TabIndex = 0        
    [int] $ZIndex = 0          
    [UIElement] $Parent = $null 
    [System.Collections.Generic.List[UIElement]] $Children 
    
    hidden [object] $_private_buffer = $null
    hidden [bool] $_needs_redraw = $true
    
    [hashtable] $Metadata = @{} 

    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = New-TuiBuffer -Width $this.Width -Height $this.Height -Name "$($this.Name).Buffer"
        Write-Verbose "UIElement 'Unnamed' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([string]$name) {
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = New-TuiBuffer -Width $this.Width -Height $this.Height -Name "$($this.Name).Buffer"
        Write-Verbose "UIElement '$($this.Name)' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = New-TuiBuffer -Width $width -Height $height -Name "Unnamed.Buffer"
        Write-Verbose "UIElement 'Unnamed' created at ($x, $y) with dimensions $($width)x$($height)."
    }

    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        return @{ X = $absX; Y = $absY }
    }

    # FIX: Removed the [UIElement] type hint from the $child parameter to prevent cross-module type conversion errors.
    [void] AddChild([object]$child) {
        try {
            if ($child -eq $this) { throw [System.ArgumentException]::new("Cannot add an element as its own child.") }
            if ($this.Children.Contains($child)) {
                Write-Warning "Child '$($child.Name)' is already a child of '$($this.Name)'. Skipping addition."
                return
            }
            if ($child.Parent -ne $null) {
                Write-Warning "Child '$($child.Name)' already has a parent ('$($child.Parent.Name)'). Consider removing it from its current parent first."
            }
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
            Write-Verbose "Added child '$($child.Name)' to parent '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add child '$($child.Name)' to '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    # FIX: Removed the [UIElement] type hint from the $child parameter to prevent cross-module type conversion errors.
    [void] RemoveChild([object]$child) {
        try {
            if ($this.Children.Remove($child)) {
                $child.Parent = $null
                $this.RequestRedraw()
                Write-Verbose "Removed child '$($child.Name)' from parent '$($this.Name)'."
            } else {
                Write-Warning "Child '$($child.Name)' not found in parent '$($this.Name)' for removal. No action taken."
            }
        }
        catch {
            Write-Error "Failed to remove child '$($child.Name)' from '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
        Write-Verbose "Redraw requested for '$($this.Name)'."
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        try {
            if ($this.Width -eq $newWidth -and $this.Height -eq $newHeight) {
                Write-Verbose "Resize: Component '$($this.Name)' already has target dimensions ($($newWidth)x$($newHeight)). No change."
                return
            }
            $this.Width = $newWidth
            $this.Height = $newHeight
            if ($null -ne $this._private_buffer) {
                $this._private_buffer.Resize($newWidth, $newHeight)
            } else {
                $this._private_buffer = New-TuiBuffer -Width $newWidth -Height $newHeight -Name "$($this.Name).Buffer"
                Write-Verbose "Re-initialized buffer for '$($this.Name)' due to null buffer."
            }
            $this.RequestRedraw()
            $this.OnResize($newWidth, $newHeight)
            Write-Verbose "Component '$($this.Name)' resized to $($newWidth)x$($newHeight)."
        }
        catch {
            Write-Error "Failed to resize component '$($this.Name)' to $($newWidth)x$($newHeight): $($_.Exception.Message)"
            throw
        }
    }

    [void] Move([int]$newX, [int]$newY) {
        if ($this.X -eq $newX -and $this.Y -eq $newY) {
            Write-Verbose "Move: Component '$($this.Name)' already at target position ($($newX), $($newY)). No change."
            return
        }
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
        Write-Verbose "Component '$($this.Name)' moved to ($newX, $newY)."
    }

    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height)
    }

    # FIX: Removed the [UIElement] return type hint to prevent cross-module type conversion errors.
    [object] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $child.X, $y - $child.Y)) {
                return $child
            }
        }
        return $null
    }

    [void] OnRender() {
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
        Write-Verbose "OnRender called for '$($this.Name)': Default buffer clear."
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        Write-Verbose "OnResize called for '$($this.Name)': No custom resize logic."
    }

    [void] OnMove([int]$newX, [int]$newY) {
        Write-Verbose "OnMove called for '$($this.Name)': No custom move logic."
    }

    [void] OnFocus() { Write-Verbose "OnFocus called for '$($this.Name)'." }
    [void] OnBlur() { Write-Verbose "OnBlur called for '$($this.Name)'." }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Write-Verbose "HandleInput called for '$($this.Name)': Key: $($keyInfo.Key)."
        return $false
    }

    [void] Render() {
        if (-not $this.Visible) { 
            Write-Verbose "Skipping Render for '$($this.Name)': Not visible."
            return 
        }
        $this._RenderContent() 
    }

    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
                $bufferWidth = [Math]::Max(1, $this.Width)
                $bufferHeight = [Math]::Max(1, $this.Height)
                $this._private_buffer = New-TuiBuffer -Width $bufferWidth -Height $bufferHeight -Name "$($this.Name).Buffer"
                Write-Verbose "Re-initialized buffer for '$($this.Name)' due to null or dimension mismatch ($($bufferWidth)x$($bufferHeight))."
            }
            $this.OnRender()
            $this._needs_redraw = $false
            Write-Verbose "Rendered own content for '$($this.Name)'."
        }
        foreach ($child in $this.Children | Sort-Object ZIndex) { 
            if ($child.Visible) {
                $child.Render()
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                    Write-Verbose "Blended child '$($child.Name)' onto '$($this.Name)' at ($($child.X), $($child.Y))."
                }
            }
        }
    }

    [object] GetBuffer() { return $this._private_buffer }
    
    [string] ToString() {
        return "$($this.GetType().Name)(Name='$($this.Name)', X=$($this.X), Y=$($this.Y), Width=$($this.Width), Height=$($this.Height), Visible=$($this.Visible))"
    }
}

#endregion

#region Classes from layout\panels-class\panels-class.psm1

class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [ConsoleColor] $BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"

    Panel() : base() {
        $this.Name = "Panel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
        Write-Verbose "Panel: Default constructor called for '$($this.Name)'."
    }

    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) { # FIX: Removed invalid attributes
        $this.Name = "Panel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
        Write-Verbose "Panel: Constructor with dimensions called for '$($this.Name)' at ($x, $y) with $($width)x$($height)."
    }

    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) { # FIX: Removed invalid attributes
        $this.Name = "Panel_$(Get-Random -Maximum 1000)"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
        Write-Verbose "Panel: Constructor with title called for '$($this.Name)' ('$title') at ($x, $y) with $($width)x$($height)."
    }

    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
        Write-Verbose "Panel '$($this.Name)': Content bounds updated to ($($this.ContentX), $($this.ContentY)) - $($this.ContentWidth)x$($this.ContentHeight) (HasBorder: $($this.HasBorder))."
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) { # FIX: Removed invalid attributes
        ([UIElement]$this).OnResize($newWidth, $newHeight) 
        $this.UpdateContentBounds()
        $this.PerformLayout()
        Write-Verbose "Panel '$($this.Name)': OnResize triggered, new content bounds calculated and layout performed."
    }

    [void] PerformLayout() {
        try {
            if ($this.Children.Count -eq 0) {
                Write-Verbose "Panel '$($this.Name)': No children to lay out."
                return
            }
            switch ($this.LayoutType) {
                "Vertical" { $this.LayoutVertical() }
                "Horizontal" { $this.LayoutHorizontal() }
                "Grid" { $this.LayoutGrid() }
                "Manual" { Write-Verbose "Panel '$($this.Name)': LayoutType is Manual, skipping auto-layout." }
                default { Write-Warning "Panel '$($this.Name)': Unknown LayoutType '$($this.LayoutType)'. Skipping auto-layout." }
            }
            Write-Verbose "Panel '$($this.Name)': Layout performed for type '$($this.LayoutType)'."
        }
        catch {
            Write-Error "Panel '$($this.Name)': Error during PerformLayout for type '$($this.LayoutType)': $($_.Exception.Message)"
            throw
        }
    }

    hidden [void] LayoutVertical() {
        if ($this.Children.Count -eq 0) { return }
        if ($this.ContentHeight -eq 0) { Write-Warning "Panel '$($this.Name)': ContentHeight is 0 for vertical layout. Children will have 0 height." }
        $currentY = $this.ContentY
        $childWidth = $this.ContentWidth
        $availableHeight = $this.ContentHeight
        $childHeight = [Math]::Max(1, [Math]::Floor($availableHeight / $this.Children.Count)) 
        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $this.ContentX
            $child.Y = $currentY
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingHeight = $this.ContentY + $this.ContentHeight - $currentY
                $child.Resize($childWidth, [Math]::Max(1, $remainingHeight))
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            $currentY += $child.Height
        }
        Write-Verbose "Panel '$($this.Name)': Performed Vertical Layout for $($this.Children.Count) children."
    }

    hidden [void] LayoutHorizontal() {
        if ($this.Children.Count -eq 0) { return }
        if ($this.ContentWidth -eq 0) { Write-Warning "Panel '$($this.Name)': ContentWidth is 0 for horizontal layout. Children will have 0 width." }
        $currentX = $this.ContentX
        $childHeight = $this.ContentHeight
        $availableWidth = $this.ContentWidth
        $childWidth = [Math]::Max(1, [Math]::Floor($availableWidth / $this.Children.Count))
        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $child.X = $currentX
            $child.Y = $this.ContentY
            if ($i -eq ($this.Children.Count - 1)) {
                $remainingWidth = $this.ContentX + $this.ContentWidth - $currentX
                $child.Resize([Math]::Max(1, $remainingWidth), $childHeight)
            } else {
                $child.Resize($childWidth, $childHeight)
            }
            $currentX += $child.Width
        }
        Write-Verbose "Panel '$($this.Name)': Performed Horizontal Layout for $($this.Children.Count) children."
    }

    hidden [void] LayoutGrid() {
        if ($this.Children.Count -eq 0) { return }
        if ($this.ContentWidth -eq 0 -or $this.ContentHeight -eq 0) { Write-Warning "Panel '$($this.Name)': Content dimensions are zero for grid layout. Children will have 0 dimensions." }
        $childCount = $this.Children.Count
        $cols = [Math]::Ceiling([Math]::Sqrt($childCount))
        $rows = [Math]::Ceiling($childCount / $cols)
        $cellWidth = [Math]::Max(1, [Math]::Floor($this.ContentWidth / $cols))
        $cellHeight = [Math]::Max(1, [Math]::Floor($this.ContentHeight / $rows))
        for ($i = 0; $i -lt $this.Children.Count; $i++) {
            $child = $this.Children[$i]
            $row = [Math]::Floor($i / $cols)
            $col = $i % $cols
            $x = $this.ContentX + ($col * $cellWidth)
            $y = $this.ContentY + ($row * $cellHeight)
            $width = if ($col -eq ($cols - 1)) { $this.ContentX + $this.ContentWidth - $x } else { $cellWidth }
            $height = if ($row -eq ($rows - 1)) { $this.ContentY + $this.ContentHeight - $y } else { $cellHeight }
            $child.Move($x, $y)
            $child.Resize([Math]::Max(1, $width), [Math]::Max(1, $height))
        }
        Write-Verbose "Panel '$($this.Name)': Performed Grid Layout for $($this.Children.Count) children ($rows x $cols grid)."
    }

    [void] SetBorderStyle([string]$style, [ConsoleColor]$color) { # FIX: Removed invalid attributes
        $this.BorderStyle = $style
        $this.BorderColor = $color
        $this.RequestRedraw()
        Write-Verbose "Panel '$($this.Name)': Border style set to '$style' with color '$color'."
    }

    [void] SetBorder([bool]$hasBorder) { # FIX: Removed invalid attributes
        if ($this.HasBorder -eq $hasBorder) {
            Write-Verbose "Panel '$($this.Name)': Border status already $($hasBorder). No change."
            return
        }
        $this.HasBorder = $hasBorder
        $this.UpdateContentBounds()
        $this.PerformLayout()
        $this.RequestRedraw()
        Write-Verbose "Panel '$($this.Name)': Border set to '$hasBorder'. Content bounds updated and layout performed."
    }

    [void] SetTitle([string]$title) { # FIX: Removed invalid attributes
        if ($this.Title -eq $title) {
            Write-Verbose "Panel '$($this.Name)': Title already set to '$title'. No change."
            return
        }
        $this.Title = $title
        $this.RequestRedraw()
        Write-Verbose "Panel '$($this.Name)': Title set to '$title'."
    }

    [bool] ContainsContentPoint([int]$x, [int]$y) { # FIX: Removed invalid attributes
        return ($x -ge $this.ContentX -and $x -lt ($this.ContentX + $this.ContentWidth) -and 
                $y -ge $this.ContentY -and $y -lt ($this.ContentY + $this.ContentHeight))
    }

    [hashtable] GetContentBounds() { return @{ X = $this.ContentX; Y = $this.ContentY; Width = $this.ContentWidth; Height = $this.ContentHeight } }
    [hashtable] GetContentArea() { return $this.GetContentBounds() }
    
    [void] WriteToBuffer([int]$x, [int]$y, [string]$text, [ConsoleColor]$fg, [ConsoleColor]$bg) { # FIX: Removed invalid attributes
        if ($null -eq $this._private_buffer) { 
            Write-Warning "Panel '$($this.Name)': Internal buffer is null, cannot write text. (Call OnRender first)."
            return 
        }
        Write-TuiText -Buffer $this._private_buffer -X $x -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
        Write-Verbose "Panel '$($this.Name)': Wrote text to buffer at ($x, $y)."
    }
    
    [void] DrawBoxToBuffer([int]$x, [int]$y, [int]$width, [int]$height, [ConsoleColor]$borderColor, [ConsoleColor]$bgColor) { # FIX: Removed invalid attributes
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        if ($null -eq $this._private_buffer) { 
            Write-Warning "Panel '$($this.Name)': Internal buffer is null, cannot draw box. (Call OnRender first)."
            return 
        }
        Write-TuiBox -Buffer $this._private_buffer -X $x -Y $y -Width $width -Height $height -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
        Write-Verbose "Panel '$($this.Name)': Drew sub-box on buffer at ($x, $y) with $($width)x$($height)."
    }

    [void] ClearContent() {
        if ($null -eq $this._private_buffer) { return }
        $clearCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, $clearCell)
            }
        }
        $this.RequestRedraw()
        Write-Verbose "Panel '$($this.Name)': Content area cleared."
    }

    [void] OnRender() {
        if ($null -eq $this._private_buffer) { 
            Write-Warning "Panel '$($this.Name)': OnRender called but internal buffer is null. Skipping render."
            return 
        }
        $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
        $this._private_buffer.Clear($bgCell)
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -BorderStyle $this.BorderStyle -BorderColor $this.BorderColor -BackgroundColor $this.BackgroundColor -Title $this.Title
        }
        Write-Verbose "Panel '$($this.Name)': OnRender completed (background and border)."
    }

    [void] OnFocus() {
        ([UIElement]$this).OnFocus()
        if ($this.CanFocus) {
            $this.BorderColor = Get-ThemeColor 'Accent'
            $this.RequestRedraw()
            Write-Verbose "Panel '$($this.Name)': Gained focus, border color set to theme accent."
        }
    }

    [void] OnBlur() {
        ([UIElement]$this).OnBlur()
        if ($this.CanFocus) {
            $this.BorderColor = Get-ThemeColor 'Border'
            $this.RequestRedraw()
            Write-Verbose "Panel '$($this.Name)': Lost focus, border color set to theme border."
        }
    }

    [object] GetFirstFocusableChild() {
        foreach ($child in $this.Children | Sort-Object TabIndex) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                Write-Verbose "Panel '$($this.Name)': Found first focusable child '$($child.Name)'."
                return $child
            }
            if ($child.PSObject.TypeNames -contains 'Panel') {
                $nestedChild = $child.GetFirstFocusableChild()
                if ($null -ne $nestedChild) {
                    Write-Verbose "Panel '$($this.Name)': Found nested focusable child '$($nestedChild.Name)'."
                    return $nestedChild
                }
            }
        }
        Write-Verbose "Panel '$($this.Name)': No focusable children found."
        return $null
    }

    [System.Collections.Generic.List[object]] GetFocusableChildren() {
        $focusable = [System.Collections.Generic.List[object]]::new()
        foreach ($child in $this.Children | Sort-Object TabIndex) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                [void]$focusable.Add($child)
            }
            if ($child -is [Panel]) {
                $nestedFocusable = $child.GetFocusableChildren()
                $focusable.AddRange($nestedFocusable)
            }
        }
        Write-Verbose "Panel '$($this.Name)': Collected $($focusable.Count) focusable children."
        return $focusable
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) { # FIX: Removed invalid attributes
        try {
            ([UIElement]$this).HandleInput($keyInfo)
            if ($this.CanFocus -and $this.IsFocused) {
                switch ($keyInfo.Key) {
                    ([ConsoleKey]::Tab) {
                        $firstChild = $this.GetFirstFocusableChild()
                        if ($null -ne $firstChild) {
                            $this.IsFocused = $false
                            Write-Verbose "Panel '$($this.Name)': Redirecting focus to first child '$($firstChild.Name)' on Tab press."
                            return $true
                        }
                    }
                    ([ConsoleKey]::Enter) {
                        $firstChild = $this.GetFirstFocusableChild()
                        if ($null -ne $firstChild) {
                            $this.IsFocused = $false
                            Write-Verbose "Panel '$($this.Name)': Redirecting focus to first child '$($firstChild.Name)' on Enter press."
                            return $true
                        }
                    }
                }
            }
            foreach ($child in $this.Children | Sort-Object TabIndex) {
                if ($child.Visible -and $child.Enabled) {
                    if ($child.HandleInput($keyInfo)) {
                        Write-Verbose "Panel '$($this.Name)': Child '$($child.Name)' handled input."
                        return $true
                    }
                }
            }
            Write-Verbose "Panel '$($this.Name)': Did not handle input. Key: $($keyInfo.Key)."
        }
        catch {
            Write-Error "Panel '$($this.Name)': Error handling input (Key: $($keyInfo.Key)): $($_.Exception.Message)"
            throw
        }
        return $false
    }

    [string] ToString() {
        return "Panel(Name='$($this.Name)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height), HasBorder=$($this.HasBorder), Children=$($this.Children.Count))"
    }
}

#endregion

#region Classes from services\service-container\service-container.psm1

class ServiceContainer {
    #region Private State
    hidden [hashtable] $_services = @{}
    hidden [hashtable] $_serviceFactories = @{}
    #endregion

    #region Constructor
    ServiceContainer() {
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer created."
        }
        Write-Verbose "ServiceContainer: Instance constructed."
    }
    #endregion

    #region Public Methods
    # Registers an already created service instance (eager loading).
    [void] Register(
        [string]$name, # FIX: Removed [Parameter] and [Validate] attributes which are invalid on class method parameters.
        [object]$serviceInstance
    ) {
        Invoke-WithErrorHandling -Component "ServiceContainer" -Context "Register" -AdditionalData @{ ServiceName = $name } -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") } # FIX: Added manual validation to replace the removed attributes.
            if ($null -eq $serviceInstance) { throw [System.ArgumentNullException]::new("serviceInstance") }

            if ($this.$_services.ContainsKey($name) -or $this.$_serviceFactories.ContainsKey($name)) {
                throw [System.InvalidOperationException]::new("A service or factory with the name '$name' is already registered.")
            }

            $this.$_services[$name] = $serviceInstance
            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Registered eager service instance: '$name'."
            }
            Write-Verbose "ServiceContainer: Registered eager instance for '$name' of type '$($serviceInstance.GetType().Name)'."
        }
    }

    # Registers a factory scriptblock used to create the service on-demand (lazy loading).
    [void] RegisterFactory(
        [string]$name, # FIX: Removed [Parameter] and [Validate] attributes.
        [scriptblock]$factory,
        [bool]$isSingleton = $true
    ) {
        Invoke-WithErrorHandling -Component "ServiceContainer" -Context "RegisterFactory" -AdditionalData @{ ServiceName = $name } -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") } # FIX: Added manual validation.
            if ($null -eq $factory) { throw [System.ArgumentNullException]::new("factory") }

            if ($this.$_services.ContainsKey($name) -or $this.$_serviceFactories.ContainsKey($name)) {
                throw [System.InvalidOperationException]::new("A service or factory with the name '$name' is already registered.")
            }
            
            $this.$_serviceFactories[$name] = @{
                Factory = $factory
                IsSingleton = $isSingleton
                Instance = $null # To hold the singleton instance once created
            }
            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Registered service factory: '$name' (Singleton: $isSingleton)."
            }
            Write-Verbose "ServiceContainer: Registered factory for '$name' (Singleton: $isSingleton)."
        }
    }

    # Retrieves a service by its name.
    [object] GetService(
        [string]$name # FIX: Removed [Parameter] and [Validate] attributes.
    ) {
        return Invoke-WithErrorHandling -Component "ServiceContainer" -Context "GetService" -AdditionalData @{ ServiceName = $name } -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") } # FIX: Added manual validation.

            # 1. Return from eager-loaded services
            if ($this.$_services.ContainsKey($name)) {
                Write-Verbose "ServiceContainer: Returning eager-loaded instance of '$name'."
                return $this.$_services[$name]
            }

            # 2. Check for a factory
            if ($this.$_serviceFactories.ContainsKey($name)) {
                return $this._InitializeServiceFromFactory($name, [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase))
            }

            # 3. If not found, throw a detailed error
            $available = $this.GetAllRegisteredServices() | Select-Object -ExpandProperty Name
            throw [System.InvalidOperationException]::new("Service '$name' not found. Available services: $($available -join ', ')")
        }
    }
    
    # Retrieves a list of all registered services and their status.
    [object[]] GetAllRegisteredServices() {
        $list = [System.Collections.Generic.List[object]]::new()
        
        foreach ($key in $this.$_services.Keys) {
            $list.Add([pscustomobject]@{
                Name = $key
                Type = 'Instance'
                Initialized = $true
                Lifestyle = 'Singleton' # Eager instances are always singletons
            })
        }
        
        foreach ($key in $this.$_serviceFactories.Keys) {
            $factoryInfo = $this.$_serviceFactories[$key]
            $list.Add([pscustomobject]@{
                Name = $key
                Type = 'Factory'
                Initialized = ($null -ne $factoryInfo.Instance)
                Lifestyle = if ($factoryInfo.IsSingleton) { 'Singleton' } else { 'Transient' }
            })
        }
        
        return $list.ToArray() | Sort-Object Name
    }

    # Cleans up all managed singleton services that implement IDisposable.
    [void] Cleanup() {
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer cleanup initiated."
        }
        Write-Verbose "ServiceContainer: Initiating cleanup of disposable singleton services."
        
        # Collect all singleton instances
        $instancesToClean = [System.Collections.Generic.List[object]]::new()
        $this.$_services.Values | ForEach-Object { $instancesToClean.Add($_) }
        $this.$_serviceFactories.Values | Where-Object { $_.IsSingleton -and $_.Instance } | ForEach-Object { $instancesToClean.Add($_.Instance) }

        foreach ($service in $instancesToClean) {
            if ($service -is [System.IDisposable]) {
                try {
                    Write-Verbose "ServiceContainer: Disposing service of type '$($service.GetType().FullName)'."
                    $service.Dispose()
                } catch {
                    if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                        Write-Log -Level Error -Message "Error disposing service of type '$($service.GetType().FullName)': $($_.Exception.Message)"
                    }
                }
            }
        }
        
        $this.$_services.Clear()
        $this.$_serviceFactories.Clear()
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer cleanup complete."
        }
        Write-Verbose "ServiceContainer: Cleanup complete. All service registries cleared."
    }
    #endregion

    #region Private Methods
    # The core logic for instantiating a service from its factory.
    hidden [object] _InitializeServiceFromFactory([string]$name, [System.Collections.Generic.HashSet[string]]$resolutionChain) {
        $factoryInfo = $this.$_serviceFactories[$name]
        
        # For singletons, if an instance already exists, return it immediately.
        if ($factoryInfo.IsSingleton -and $null -ne $factoryInfo.Instance) {
            Write-Verbose "ServiceContainer: Returning cached singleton instance of '$name'."
            return $factoryInfo.Instance
        }

        # Circular dependency detection
        if ($resolutionChain.Contains($name)) {
            $chain = ($resolutionChain -join ' -> ') + " -> $name"
            throw [System.InvalidOperationException]::new("Circular dependency detected while resolving service '$name'. Chain: $chain")
        }
        [void]$resolutionChain.Add($name)
        
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Instantiating service '$name' from factory."
        }
        Write-Verbose "ServiceContainer: Invoking factory to create instance of '$name'."
        
        # Invoke the factory, passing the container itself as an argument.
        $serviceInstance = & $factoryInfo.Factory $this

        # If it's a singleton, cache the new instance.
        if ($factoryInfo.IsSingleton) {
            $factoryInfo.Instance = $serviceInstance
            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Cached singleton instance of service '$name'."
            }
            Write-Verbose "ServiceContainer: Cached new singleton instance of '$name'."
        }

        # Unwind the resolution chain
        [void]$resolutionChain.Remove($name)
        
        return $serviceInstance
    }
    #endregion
}

#endregion

#region Classes from services\action-service\action-service.psm1

class ActionService {
    # Stores action definitions, mapping action names (string) to action details (hashtable).
    [hashtable] $ActionRegistry = @{}
    
    # Manages internal event subscriptions made by ActionService itself for cleanup purposes.
    # Maps event names (string) to handler IDs (string).
    [hashtable] $EventSubscriptions = @{} 

    # Constructor: Called when a new instance of ActionService is created.
    ActionService() {
        Write-Verbose "ActionService: Constructor called."
        # Register default application-level actions.
        # These actions typically publish events for other services to handle.
        $this.RegisterAction(
            "app.exit", 
            "Exits the PMC Terminal application.", 
            {
                # This script block will be executed when 'app.exit' action is called.
                # It expects the global 'Publish-Event' function to be available.
                Publish-Event -EventName "Application.Exit" -Data @{ Source = "ActionService"; Action = "AppExit" }
            }, 
            "Application", 
            $true # Force overwrite if called multiple times in tests
        )

        $this.RegisterAction(
            "app.help", 
            "Displays application help.", 
            {
                Publish-Event -EventName "App.HelpRequested" -Data @{ Source = "ActionService"; Action = "Help" }
            }, 
            "Application", 
            $true # Force overwrite
        )

        Write-Log -Level Info -Message "ActionService initialized with default actions."
        Write-Verbose "ActionService: Default actions registered."
    }

    # RegisterAction: Registers a new action with the service.
    # Actions are identified by a unique name and associated with a script block to execute.
    [void] RegisterAction(
        [string]$name, 
        [string]$description, 
        [scriptblock]$scriptBlock, 
        [string]$category = "General", 
        [switch]$Force 
    ) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }
        if ([string]::IsNullOrWhiteSpace($description)) { throw [System.ArgumentException]::new("Parameter 'description' cannot be null or empty.") }
        if ($null -eq $scriptBlock) { throw [System.ArgumentNullException]::new("scriptBlock") }

        if ($this.ActionRegistry.ContainsKey($name)) {
            if (-not $Force) {
                Write-Log -Level Warning -Message "Action '$name' already registered. Use -Force to overwrite."
                Write-Verbose "ActionService: Skipping registration of '$name' as it already exists (no -Force)."
                return # Do not overwrite if not forced
            } else {
                Write-Log -Level Info -Message "Action '$name' already registered. Overwriting due to -Force."
                Write-Verbose "ActionService: Overwriting action '$name'."
            }
        }

        # Store action details in the registry.
        $this.ActionRegistry[$name] = @{
            Name = $name;
            Description = $description;
            ScriptBlock = $scriptBlock;
            Category = $category;
            RegisteredAt = (Get-Date);
        }
        Write-Log -Level Debug -Message "Action '$name' registered."
        Write-Verbose "ActionService: Action '$name' successfully registered."
    }

    # UnregisterAction: Removes an action from the service.
    [void] UnregisterAction([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }

        if ($this.ActionRegistry.ContainsKey($name)) {
            $this.ActionRegistry.Remove($name)
            Write-Log -Level Debug -Message "Action '$name' unregistered."
            Write-Verbose "ActionService: Action '$name' successfully unregistered."
        } else {
            Write-Log -Level Warning -Message "Action '$name' not found, cannot unregister."
            Write-Verbose "ActionService: Action '$name' not found for unregistration."
        }
    }

    # ExecuteAction: Executes a registered action.
    # The parameters hashtable is passed to the action's script block as $ActionParameters.
    [void] ExecuteAction(
        [string]$name, 
        [hashtable]$parameters = @{}
    ) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }

        if (-not $this.ActionRegistry.ContainsKey($name)) {
            $errorMessage = "Attempted to execute unknown action: $name"
            Write-Log -Level Error -Message $errorMessage -Data @{ ActionName = $name; Parameters = $parameters }
            Write-Verbose "ActionService: Failed to execute action '$name' - not found."
            throw [System.ArgumentException]::new($errorMessage, "name")
        }

        $action = $this.ActionRegistry[$name]
        Write-Log -Level Info -Message "Executing action: $name" -Data @{ ActionName = $name; Parameters = $parameters }
        Write-Verbose "ActionService: Preparing to execute action '$name'."

        try {
            # Pass parameters to the action's script block via a named parameter ($ActionParameters).
            # This ensures a consistent contract for all action script blocks.
            & $action.ScriptBlock -ActionParameters $parameters
            Write-Verbose "ActionService: Action '$name' executed successfully."
        } catch {
            $errorMessage = "Action '$name' failed: $($_.Exception.Message)"
            Write-Log -Level Error -Message $errorMessage -Data @{ ActionName = $name; ActionParameters = $parameters; ErrorDetails = $_.Exception.Message; FullError = $_ }
            Write-Verbose "ActionService: Action '$name' execution failed: $($_.Exception.Message)."
            throw # Re-throw to propagate the error, allowing Invoke-WithErrorHandling to catch it.
        }
    }

    # GetAction: Retrieves the definition of a specific action.
    [hashtable] GetAction([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }
        
        Write-Verbose "ActionService: Retrieving action '$name'."
        return $this.ActionRegistry[$name]
    }

    # GetAllActions: Retrieves a list of all registered action definitions.
    # Returns a list of hashtables, each representing an action.
    [System.Collections.Generic.List[hashtable]] GetAllActions() {
        Write-Verbose "ActionService: Retrieving all registered actions."
        # Filter out any null values (shouldn't happen with proper registration) and sort by name.
        return @($this.ActionRegistry.Values | Where-Object { $_ -ne $null } | Sort-Object Name)
    }

    # AddEventSubscription: Internal method to track event subscriptions made by ActionService.
    # This allows for proper cleanup in the Cleanup method.
    hidden [void] AddEventSubscription([string]$eventName, [string]$handlerId) {
        if ([string]::IsNullOrWhiteSpace($eventName)) { throw [System.ArgumentException]::new("Parameter 'eventName' cannot be null or empty.") }
        if ([string]::IsNullOrWhiteSpace($handlerId)) { throw [System.ArgumentException]::new("Parameter 'handlerId' cannot be null or empty.") }

        $this.EventSubscriptions[$eventName] = $handlerId
        Write-Log -Level Debug -Message "ActionService: Tracking event subscription for '$eventName' (HandlerId: $handlerId)."
        Write-Verbose "ActionService: Added event subscription tracking for '$eventName'."
    }

    # Cleanup: Performs necessary cleanup operations when the ActionService is no longer needed.
    # This includes unsubscribing from any events it subscribed to and clearing its action registry.
    [void] Cleanup() {
        # Unsubscribe from any events ActionService itself subscribed to.
        # Assumes 'Unsubscribe-Event' from EventSystem module is globally available.
        Write-Verbose "ActionService: Starting cleanup process."
        foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value
                Write-Log -Level Debug -Message "ActionService: Unsubscribed from event '$($kvp.Key)' (HandlerId: $($kvp.Value))."
                Write-Verbose "ActionService: Unsubscribed from event '$($kvp.Key)'."
            } catch {
                Write-Log -Level Warning -Message "ActionService: Failed to unsubscribe from event '$($kvp.Key)' (HandlerId: $($kvp.Value)): $($_.Exception.Message)"
                Write-Verbose "ActionService: Failed to unsubscribe from event '$($kvp.Key)'. Error: $($_.Exception.Message)."
            }
        }
        $this.EventSubscriptions.Clear() # Clear tracking after attempting unsubscriptions.
        
        # Clear the action registry.
        $this.ActionRegistry.Clear()
        Write-Log -Level Info -Message "ActionService cleaned up."
        Write-Verbose "ActionService: ActionRegistry cleared. Cleanup complete."
    }
}

#endregion

#region Classes from services\navigation-service-class\navigation-service-class.psm1

class ScreenFactory {

    hidden [hashtable] $Services
    hidden [hashtable] $ScreenTypes = @{}

    ScreenFactory([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        Write-Log -Level Debug -Message "ScreenFactory initialized"
    }

    [void] RegisterScreen([string]$name, [type]$screenType) {
        # Debug information
        Write-Log -Level Debug -Message "RegisterScreen: $name with type $($screenType.Name)"
        Write-Log -Level Debug -Message "BaseType: $($screenType.BaseType?.Name)"
        Write-Log -Level Debug -Message "BaseType.BaseType: $($screenType.BaseType?.BaseType?.Name)"

        # More flexible inheritance check
        $isScreenType = $screenType.Name -eq 'Screen' -or 
                       $screenType.BaseType.Name -eq 'Screen' -or 
                       ($screenType.BaseType -and $screenType.BaseType.BaseType -and $screenType.BaseType.BaseType.Name -eq 'Screen')

        if (-not $isScreenType) {
            throw "Screen type '$($screenType.Name)' must inherit from the Screen class."
        }

        $this.ScreenTypes[$name] = $screenType
        Write-Log -Level Info -Message "Registered screen factory: $name -> $($screenType.Name)"
    }

    # FIX: Removed the [Screen] return type constraint.
    # This prevents the fatal type conversion error across module scopes.
    [object] CreateScreen([string]$screenName, [hashtable]$parameters) {
        $screenType = $this.ScreenTypes[$screenName]
        if (-not $screenType) {
            throw "Unknown screen type: '$screenName'. Available screens: $($this.ScreenTypes.Keys -join ', ')"
        }

        try {
            $serviceContainer = $this.Services['ServiceContainer']
            if (-not $serviceContainer) {
                Write-Log -Level Warning -Message "ServiceContainer not found in Services, passing Services hashtable instead"
                $screen = $screenType::new($this.Services)
            } else {
                # Pass the ServiceContainer object, not the Services hashtable
                $screen = $screenType::new($serviceContainer)
            }
            
            if ($parameters) {
                foreach ($key in $parameters.Keys) {
                    $screen.State[$key] = $parameters[$key]
                }
            }
            Write-Log -Level Info -Message "Created screen: $screenName"
            return $screen
        } catch {
            Write-Log -Level Error -Message "Failed to create screen '$screenName': $($_.Exception.Message)"
            throw
        }
    }

    [string[]] GetRegisteredScreens() {
        return @($this.ScreenTypes.Keys)
    }
}

#endregion

#region Classes from modules\tui-framework\tui-framework.psm1

class TuiFrameworkService {
    hidden [System.Collections.Concurrent.ConcurrentDictionary[guid, object]] $_asyncJobs
    
    TuiFrameworkService() {
        $this._asyncJobs = [System.Collections.Concurrent.ConcurrentDictionary[guid, object]]::new()
        Write-Log -Level Info "TuiFrameworkService initialized."
    }
    
    # Executes a script block asynchronously using a lightweight thread job.
    # Ideal for I/O-bound operations like network requests or file access.
    [System.Management.Automation.Job] StartAsync(
        [scriptblock]$ScriptBlock,
        [hashtable]$ArgumentList = @{}
    ) {
        return Invoke-WithErrorHandling -Component "TuiFramework.StartAsync" -Context "Starting async thread job" -ScriptBlock {
            $job = Start-ThreadJob -ScriptBlock $ScriptBlock -ArgumentList @($ArgumentList)
            $this._asyncJobs[$job.InstanceId] = $job
            Write-Log -Level Debug -Message "Started async thread job: $($job.Name)" -Data @{ JobId = $job.InstanceId }
            return $job
        }
    }

    # Checks for completed async jobs and returns their results, cleaning them up by default.
    [object[]] GetAsyncResults([switch]$RemoveCompleted = $true) {
        return Invoke-WithErrorHandling -Component "TuiFramework.GetAsyncResults" -Context "Checking async job results" -ScriptBlock {
            $results = @()
            $completedJobs = $this._asyncJobs.Values | Where-Object { $_.State -in @('Completed', 'Failed', 'Stopped') }
            
            foreach ($job in $completedJobs) {
                $jobResult = [pscustomobject]@{
                    JobId = $job.InstanceId
                    Name = $job.Name
                    State = $job.State
                    Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job -Keep } else { $null }
                    Error = if ($job.State -eq 'Failed') { $job.Error | Select-Object -First 1 } else { $null }
                }
                $results += $jobResult
                
                if ($RemoveCompleted) {
                    $this._asyncJobs.TryRemove($job.InstanceId, [ref]$null) | Out-Null
                    Remove-Job -Job $job -Force
                }
            }
            return $results
        }
    }

    # Stops all tracked asynchronous jobs. Should be called during application cleanup.
    [void] StopAllAsyncJobs() {
        Invoke-WithErrorHandling -Component "TuiFramework.StopAllAsync" -Context "Stopping all tracked async jobs" -ScriptBlock {
            foreach ($job in $this._asyncJobs.Values) {
                try {
                    Stop-Job -Job $job -Force
                    Remove-Job -Job $job -Force
                } catch {
                    Write-Log -Level Warning -Message "Failed to stop or remove job $($job.Name): $($_.Exception.Message)"
                }
            }
            $this._asyncJobs.Clear()
            Write-Log -Level Info -Message "All tracked TUI async jobs stopped."
        }
    }
    
    # Returns the global TUI state object for debugging or advanced scenarios.
    [hashtable] GetState() {
        return $global:TuiState
    }

    # Tests if the TUI is in a valid, running state.
    [bool] IsRunning() {
        return $global:TuiState -and $global:TuiState.Running -and $global:TuiState.CurrentScreen
    }
}

#endregion

#region Classes from components\navigation-class\navigation-class.psm1

class NavigationItem {
    [string]$Key
    [string]$Label
    [scriptblock]$Action
    [bool]$Enabled = $true
    [bool]$Visible = $true
    [string]$Description = ""

    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key)) {
            throw [System.ArgumentException]::new("Navigation key cannot be null or empty")
        }
        if ([string]::IsNullOrWhiteSpace($label)) {
            throw [System.ArgumentException]::new("Navigation label cannot be null or empty")
        }
        if (-not $action) {
            throw [System.ArgumentNullException]::new("action", "Navigation action cannot be null")
        }

        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
        
        Write-Verbose "NavigationItem: Created item '$($this.Key)' - '$($this.Label)'"
    }

    [void] Execute() {
        try {
            if (-not $this.Enabled) {
                Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)"
                return
            }
            
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key)"
            Invoke-WithErrorHandling -Component "NavigationItem" -Context "Execute '$($this.Key)'" -ScriptBlock $this.Action
        }
        catch {
            Write-Error "NavigationItem '$($this.Key)': Error during execution: $($_.Exception.Message)"
        }
    }

    [string] ToString() {
        return "NavigationItem(Key='$($this.Key)', Label='$($this.Label)', Enabled=$($this.Enabled))"
    }
}

#endregion

#region Classes from components\advanced-data-components\advanced-data-components.psm1

class TableColumn {
    [string]$Key
    [string]$Header
    [object]$Width # Can be [int] or the string 'Auto'
    [string]$Alignment = "Left"

    TableColumn([string]$key, [string]$header, [object]$width) {
        if ([string]::IsNullOrWhiteSpace($key)) { throw [System.ArgumentException]::new("Parameter 'key' cannot be null or empty.") }
        if ([string]::IsNullOrWhiteSpace($header)) { throw [System.ArgumentException]::new("Parameter 'header' cannot be null or empty.") }
        if ($null -eq $width) { throw [System.ArgumentNullException]::new("width") }

        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }

    [string] ToString() {
        return "TableColumn(Key='$($this.Key)', Header='$($this.Header)', Width=$($this.Width))"
    }
}

class NavigationService {

    [System.Collections.Generic.Stack[Screen]] $ScreenStack
    [ScreenFactory] $ScreenFactory
    [Screen] $CurrentScreen
    [hashtable] $Services
    [hashtable] $RouteMap = @{}

    NavigationService([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        $this.ScreenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.ScreenFactory = [ScreenFactory]::new($services)
        $this.InitializeRoutes()
        Write-Log -Level Info -Message "NavigationService initialized"
    }

    hidden [void] InitializeRoutes() {
        $this.RouteMap = @{
            "/" = "DashboardScreen"
            "/dashboard" = "DashboardScreen"
            "/tasks" = "TaskListScreen"
        }
        Write-Log -Level Debug -Message "Routes initialized: $($this.RouteMap.Keys -join ', ')"
    }

    [void] RegisterScreenClass([string]$name, [type]$screenType) {
        $this.ScreenFactory.RegisterScreen($name, $screenType)
    }

    [void] GoTo([string]$path, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "GoTo:$path" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be empty.")
            }
            if ($path -eq "/exit") {
                $this.RequestExit()
                return
            }

            $screenName = $this.RouteMap[$path]
            if (-not $screenName) {
                $availableRoutes = $this.RouteMap.Keys -join ', '
                throw "Unknown route: '$path'. Available routes: $availableRoutes"
            }

            Write-Log -Level Info -Message "Navigating to: $path -> $screenName"
            $this.PushScreen($screenName, $parameters)
        }
    }

    [void] PushScreen([string]$screenName, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "PushScreen:$screenName" -ScriptBlock {
            Write-Log -Level Info -Message "Pushing screen: $screenName"

            if ($this.CurrentScreen) {
                Write-Log -Level Debug -Message "Exiting current screen: $($this.CurrentScreen.Name)"
                $this.CurrentScreen.OnExit()
                [void]$this.ScreenStack.Push($this.CurrentScreen)
            }

            Write-Log -Level Debug -Message "Creating new screen: $screenName"
            $newScreen = $this.ScreenFactory.CreateScreen($screenName, $parameters)
            $this.CurrentScreen = $newScreen

            Write-Log -Level Debug -Message "Initializing screen: $screenName"
            if($newScreen.PSObject.Methods['Initialize']) {
                $newScreen.Initialize()
            }
            if($newScreen.PSObject.Methods['OnEnter']) {
                $newScreen.OnEnter()
            }

            if (Get-Command "Push-Screen" -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Pushing screen to TUI engine"
                Push-Screen -Screen $newScreen
            } else {
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $newScreen
                    Request-TuiRefresh
                }
            }

            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{ Screen = $screenName; Action = "Push" }
            Write-Log -Level Info -Message "Successfully pushed screen: $screenName"
        }
    }

    [bool] PopScreen() {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "PopScreen" -ScriptBlock {
            if ($this.ScreenStack.Count -eq 0) {
                Write-Log -Level Warning -Message "Cannot pop screen: stack is empty"
                return $false
            }

            Write-Log -Level Info -Message "Popping screen"
            $this.CurrentScreen?.OnExit()
            $this.CurrentScreen = $this.ScreenStack.Pop()
            $this.CurrentScreen?.OnResume()

            if (Get-Command "Pop-Screen" -ErrorAction SilentlyContinue) {
                Pop-Screen
            } else {
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $this.CurrentScreen
                    Request-TuiRefresh
                }
            }

            Publish-Event -EventName "Navigation.ScreenPopped" -Data @{ Screen = $this.CurrentScreen.Name }
            return $true
        }
    }

    [void] RequestExit() {
        Write-Log -Level Info -Message "Exit requested"
        while ($this.PopScreen()) {} # Pop all screens
        $this.CurrentScreen?.OnExit()
        if (Get-Command "Stop-TuiEngine" -ErrorAction SilentlyContinue) {
            Stop-TuiEngine
        }
        Publish-Event -EventName "Application.Exit"
    }

    [Screen] GetCurrentScreen() { return $this.CurrentScreen }
    [bool] IsValidRoute([string]$path) { return $this.RouteMap.ContainsKey($path) }

    [void] ListRegisteredScreens() {
        $screens = $this.ScreenFactory.GetRegisteredScreens()
        Write-Log -Level Info -Message "Registered screens: $($screens -join ', ')"
        Write-Host "Registered screens: $($screens -join ', ')" -ForegroundColor Green
    }

    [void] ListAvailableRoutes() {
        $routes = $this.RouteMap.Keys
        Write-Log -Level Info -Message "Available routes: $($routes -join ', ')"
        Write-Host "Available routes: $($routes -join ', ')" -ForegroundColor Green
    }
}

#endregion

#region Classes from services\keybinding-service-class\keybinding-service-class.psm1

class KeybindingService {
    [hashtable] $KeyMap = @{}
    [hashtable] $GlobalHandlers = @{}
    [System.Collections.Generic.List[string]] $ContextStack
    [bool] $EnableChords = $false

    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.InitializeDefaultBindings()
        Write-Log -Level Info -Message "KeybindingService initialized"
    }

    KeybindingService([bool]$enableChords) {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.EnableChords = $enableChords
        $this.InitializeDefaultBindings()
        Write-Log -Level Info -Message "KeybindingService initialized with chords: $enableChords"
    }

    hidden [void] InitializeDefaultBindings() {
        $this.KeyMap = @{
            "app.exit" = @{ Key = [System.ConsoleKey]::Q; Modifiers = @("Ctrl") }
            "app.help" = @{ Key = [System.ConsoleKey]::F1; Modifiers = @() }
            "nav.back" = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }
            "nav.up" = @{ Key = [System.ConsoleKey]::UpArrow; Modifiers = @() }
            "nav.down" = @{ Key = [System.ConsoleKey]::DownArrow; Modifiers = @() }
            "nav.left" = @{ Key = [System.ConsoleKey]::LeftArrow; Modifiers = @() }
            "nav.right" = @{ Key = [System.ConsoleKey]::RightArrow; Modifiers = @() }
            "nav.select" = @{ Key = [System.ConsoleKey]::Enter; Modifiers = @() }
            "nav.pageup" = @{ Key = [System.ConsoleKey]::PageUp; Modifiers = @() }
            "nav.pagedown" = @{ Key = [System.ConsoleKey]::PageDown; Modifiers = @() }
            "nav.home" = @{ Key = [System.ConsoleKey]::Home; Modifiers = @() }
            "nav.end" = @{ Key = [System.ConsoleKey]::End; Modifiers = @() }
            "nav.tab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @() }
            "nav.shifttab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @("Shift") }
            "edit.delete" = @{ Key = [System.ConsoleKey]::Delete; Modifiers = @() }
            "edit.backspace" = @{ Key = [System.ConsoleKey]::Backspace; Modifiers = @() }
            "edit.new" = @{ Key = [System.ConsoleKey]::N; Modifiers = @() }
            "edit.save" = @{ Key = [System.ConsoleKey]::S; Modifiers = @("Ctrl") }
            "app.refresh" = @{ Key = [System.ConsoleKey]::F5; Modifiers = @() }
        }
    }

    # FIX: Consolidated SetBinding into a single method to remove ambiguity.
    [void] SetBinding([string]$actionName, [object]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            if ($null -eq $key) {
                throw [System.ArgumentNullException]::new("key", "Key cannot be null")
            }

            $binding = @{
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }

            # Intelligently handle the key type.
            if ($key -is [System.ConsoleKey]) {
                $binding.Key = $key
            } elseif ($key -is [char]) {
                $binding.KeyChar = $key
            } else {
                # Attempt to parse as ConsoleKey if it's a string.
                try {
                    $binding.Key = [System.ConsoleKey]::$key
                } catch {
                    throw [System.ArgumentException]::new("The provided key '$key' is not a valid [System.ConsoleKey] or [char].")
                }
            }

            $this.KeyMap[$actionName.ToLower()] = $binding
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $($this.GetBindingDescription($actionName))"
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
        }

        $modifiers = @()
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) { $modifiers += "Ctrl" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) { $modifiers += "Alt" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) { $modifiers += "Shift" }

        $this.KeyMap[$actionName.ToLower()] = @{
            Key = $keyInfo.Key
            KeyChar = $keyInfo.KeyChar
            Modifiers = $modifiers
        }
        Write-Log -Level Debug -Message "Set keybinding for '$actionName': $($this.GetBindingDescription($actionName))"
    }

    [void] RemoveBinding([string]$actionName) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RemoveBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return
            }

            $normalizedName = $actionName.ToLower()
            if ($this.KeyMap.ContainsKey($normalizedName)) {
                $this.KeyMap.Remove($normalizedName)
                Write-Log -Level Debug -Message "Removed keybinding: $actionName"
            }
        }
    }

    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        return $this.IsAction($actionName, $keyInfo, $null)
    }

    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "IsAction:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return $false
            }

            $normalizedName = $actionName.ToLower()
            if (-not $this.KeyMap.ContainsKey($normalizedName)) {
                return $false
            }

            $binding = $this.KeyMap[$normalizedName]

            # FIX: Unified key matching logic
            $keyMatches = $false
            if ($binding.ContainsKey('KeyChar')) {
                # KeyChar binding is more specific.
                # KeyChar matching should be case-sensitive.
                if ($keyInfo.KeyChar -eq $binding.KeyChar) {
                    $keyMatches = $true
                }
            }
            if (-not $keyMatches -and $binding.ContainsKey('Key')) {
                 # Fallback to ConsoleKey if KeyChar doesn't match or isn't present
                if ($keyInfo.Key -eq $binding.Key) {
                    $keyMatches = $true
                }
            }
            
            if (-not $keyMatches) {
                return $false
            }

            # Check modifiers
            $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
            $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
            $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0

            $expectedCtrl = $binding.Modifiers -contains "Ctrl"
            $expectedAlt = $binding.Modifiers -contains "Alt"
            $expectedShift = $binding.Modifiers -contains "Shift"

            return ($hasCtrl -eq $expectedCtrl) -and ($hasAlt -eq $expectedAlt) -and ($hasShift -eq $expectedShift)
        }
    }

    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "GetAction" -ScriptBlock {
            foreach ($actionName in $this.KeyMap.Keys) {
                if ($this.IsAction($actionName, $keyInfo)) {
                    return $actionName
                }
            }
            return $null
        }
    }

    [void] RegisterGlobalHandler([string]$actionName, [scriptblock]$handler) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RegisterGlobalHandler:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            if ($null -eq $handler) {
                throw [System.ArgumentNullException]::new("handler", "Handler cannot be null")
            }

            $this.GlobalHandlers[$actionName.ToLower()] = $handler
            Write-Log -Level Debug -Message "Registered global handler: $actionName"
        }
    }

    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo) {
        return $this.HandleKey($keyInfo, $null)
    }

    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "HandleKey" -ScriptBlock {
            foreach ($action in $this.KeyMap.Keys) {
                if ($this.IsAction($action, $keyInfo, $context)) {
                    if ($this.GlobalHandlers.ContainsKey($action)) {
                        Write-Log -Level Debug -Message "Executing global handler: $action"
                        try {
                            return & $this.GlobalHandlers[$action] -KeyInfo $keyInfo -Context $context
                        }
                        catch {
                            Write-Log -Level Error -Message "Global handler failed for '$action': $_"
                            return $null
                        }
                    }
                    return $action
                }
            }
            return $null
        }
    }

    [void] PushContext([string]$context) {
        if (-not [string]::IsNullOrWhiteSpace($context)) {
            $this.ContextStack.Add($context)
            Write-Log -Level Debug -Message "Pushed keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
        }
    }

    [string] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $context = $this.ContextStack[-1]
            $this.ContextStack.RemoveAt($this.ContextStack.Count - 1)
            Write-Log -Level Debug -Message "Popped keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
            return $context
        }
        return $null
    }

    [string] GetCurrentContext() {
        if ($this.ContextStack.Count -gt 0) {
            return $this.ContextStack[-1]
        }
        return "global"
    }

    [string] GetBindingDescription([string]$actionName) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            return $null
        }

        $normalizedName = $actionName.ToLower()
        if (-not $this.KeyMap.ContainsKey($normalizedName)) {
            return "Unbound"
        }

        $binding = $this.KeyMap[$normalizedName]
        $keyStr = ""
        if ($binding.ContainsKey('KeyChar')) {
            $keyStr = $binding.KeyChar.ToString().ToUpper()
        } elseif ($binding.ContainsKey('Key')) {
            $keyStr = $binding.Key.ToString()
        }

        if ($binding.Modifiers.Count -gt 0) {
            return "$($binding.Modifiers -join '+') + $keyStr"
        }

        return $keyStr
    }

    [hashtable] GetAllBindings() {
        return $this.GetAllBindings($false)
    }

    [hashtable] GetAllBindings([bool]$groupByCategory) {
        if (-not $groupByCategory) {
            return $this.KeyMap.Clone()
        }
        
        $grouped = @{}
        foreach ($action in $this.KeyMap.Keys) {
            $parts = $action.Split('.')
            $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
            if (-not $grouped.ContainsKey($category)) {
                $grouped[$category] = @{}
            }
            $grouped[$category][$action] = $this.KeyMap[$action]
        }
        return $grouped
    }

    [void] ExportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ExportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            $this.KeyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $path -Encoding UTF8
            Write-Log -Level Info -Message "Exported keybindings to: $path"
        }
    }

    [void] ImportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ImportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            if (-not (Test-Path $path)) {
                Write-Log -Level Warning -Message "Keybindings file not found: $path"
                return
            }
            try {
                $imported = Get-Content $path -Raw | ConvertFrom-Json
                foreach ($prop in $imported.PSObject.Properties) {
                    $bindingData = @{
                        Modifiers = $prop.Value.Modifiers
                    }
                    if ($prop.Value.PSObject.Properties.Name -contains 'KeyChar') {
                        $bindingData['KeyChar'] = $prop.Value.KeyChar
                    }
                    if ($prop.Value.PSObject.Properties.Name -contains 'Key') {
                        $bindingData['Key'] = $prop.Value.Key
                    }
                    $this.KeyMap[$prop.Name] = $bindingData
                }
                Write-Log -Level Info -Message "Imported keybindings from: $path"
            }
            catch {
                Write-Log -Level Error -Message "Failed to import keybindings from '$path': $_"
                throw
            }
        }
    }
}

#endregion

#region Classes from modules\data-manager\data-manager.psm1

class DataManager : IDisposable {
    #region Private State
    hidden [hashtable] $_dataStore
    hidden [string] $_dataFilePath
    hidden [string] $_backupPath
    hidden [datetime] $_lastSaveTime
    hidden [bool] $_dataModified = $false
    
    # High-performance indexes for fast lookups
    hidden [System.Collections.Generic.Dictionary[string, object]] $_taskIndex
    hidden [System.Collections.Generic.Dictionary[string, object]] $_projectIndex
    
    # For transactional updates
    hidden [int] $_updateTransactionCount = 0
    #endregion

    #region Constructor and Initialization
    DataManager() {
        $this.$_dataStore = @{
            Projects = [System.Collections.ArrayList]::new()
            Tasks = [System.Collections.ArrayList]::new()
            Settings = @{ 
                AutoSave = $true
                BackupCount = 5
                LastModified = [datetime]::MinValue
            }
        }
        $this.$_taskIndex = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.$_projectIndex = [System.Collections.Generic.Dictionary[string, object]]::new()
        
        # Set up file paths
        $baseDir = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal"
        $this.$_dataFilePath = Join-Path $baseDir "pmc-data.json"
        $this.$_backupPath = Join-Path $baseDir "backups"

        # Ensure directories exist
        if (-not (Test-Path $baseDir)) {
            New-Item -ItemType Directory -Path $baseDir -Force | Out-Null
        }
        if (-not (Test-Path $this.$_backupPath)) {
            New-Item -ItemType Directory -Path $this.$_backupPath -Force | Out-Null
        }

        $this.LoadData()
        $this.InitializeEventHandlers()
        
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "DataManager initialized successfully." -Data @{
                DataPath = $this.$_dataFilePath
                BackupPath = $this.$_backupPath
                TaskCount = $this.$_dataStore.Tasks.Count
                ProjectCount = $this.$_dataStore.Projects.Count
            }
        }
        Write-Verbose "DataManager: Initialization complete."
    }

    hidden [void] LoadData() {
        try {
            if (Test-Path $this.$_dataFilePath) {
                $jsonData = Get-Content $this.$_dataFilePath -Raw | ConvertFrom-Json -AsHashtable
                
                # Validate and load data structure
                if ($jsonData.ContainsKey('Tasks')) {
                    $this.$_dataStore.Tasks.Clear()
                    foreach ($taskData in $jsonData.Tasks) {
                        # FIX: Use the correct FromLegacyFormat static method for deserialization.
                        $task = [PmcTask]::FromLegacyFormat($taskData)
                        [void]$this.$_dataStore.Tasks.Add($task)
                    }
                }
                
                if ($jsonData.ContainsKey('Projects')) {
                    $this.$_dataStore.Projects.Clear()
                    foreach ($projectData in $jsonData.Projects) {
                        # FIX: Use the correct FromLegacyFormat static method for deserialization.
                        $project = [PmcProject]::FromLegacyFormat($projectData)
                        [void]$this.$_dataStore.Projects.Add($project)
                    }
                }
                
                if ($jsonData.ContainsKey('Settings')) {
                    foreach ($key in $jsonData.Settings.Keys) {
                        $this.$_dataStore.Settings[$key] = $jsonData.Settings[$key]
                    }
                }
                
                $this.$_lastSaveTime = [datetime]::Now
                Write-Verbose "DataManager: Loaded data from '$($this.$_dataFilePath)'."
            } else {
                Write-Verbose "DataManager: No existing data file found. Starting with empty data store."
            }
        } catch {
            Write-Warning "DataManager: Failed to load data from '$($this.$_dataFilePath)': $($_.Exception.Message). Starting with empty data store."
            $this.$_dataStore.Tasks.Clear()
            $this.$_dataStore.Projects.Clear()
        }
        
        # Rebuild indexes after loading
        $this._RebuildIndexes()
    }
    
    hidden [void] _RebuildIndexes() {
        $this.$_taskIndex.Clear()
        $this.$_projectIndex.Clear()
        
        foreach ($task in $this.$_dataStore.Tasks) {
            if ($task.Id) {
                $this.$_taskIndex[$task.Id] = $task
            }
        }
        
        foreach ($project in $this.$_dataStore.Projects) {
            if ($project.Key) {
                $this.$_projectIndex[$project.Key] = $project
            }
        }
        
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Rebuilt data indexes." -Data @{
                TaskIndexCount = $this.$_taskIndex.Count
                ProjectIndexCount = $this.$_projectIndex.Count
            }
        }
        Write-Verbose "DataManager: Rebuilt data indexes for $($this.$_taskIndex.Count) tasks and $($this.$_projectIndex.Count) projects."
    }
    
    hidden [void] SaveData() {
        if ($this.$_updateTransactionCount -gt 0) {
            Write-Verbose "DataManager: SaveData deferred - inside update transaction (level $($this.$_updateTransactionCount))."
            return
        }
        
        try {
            $this.CreateBackup()
            
            $saveData = @{
                Tasks = @()
                Projects = @()
                Settings = $this.$_dataStore.Settings.Clone()
                SavedAt = [datetime]::Now
            }
            
            foreach ($task in $this.$_dataStore.Tasks) {
                $saveData.Tasks += $task.ToLegacyFormat()
            }
            
            foreach ($project in $this.$_dataStore.Projects) {
                $saveData.Projects += $project.ToLegacyFormat()
            }
            
            $saveData | ConvertTo-Json -Depth 10 | Set-Content -Path $this.$_dataFilePath -Encoding UTF8 -Force
            $this.$_lastSaveTime = [datetime]::Now
            $this.$_dataModified = $false
            
            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Data saved successfully." -Data @{
                    FilePath = $this.$_dataFilePath
                    TaskCount = $saveData.Tasks.Count
                    ProjectCount = $saveData.Projects.Count
                }
            }
            Write-Verbose "DataManager: Data saved to '$($this.$_dataFilePath)'."
        } catch {
            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Failed to save data: $($_.Exception.Message)"
            }
            throw
        }
    }
    
    hidden [void] CreateBackup() {
        try {
            if (Test-Path $this.$_dataFilePath) {
                $timestamp = (Get-Date).ToString("yyyyMMdd-HHmmss")
                $backupFileName = "pmc-data-$timestamp.json"
                $backupFilePath = Join-Path $this.$_backupPath $backupFileName
                
                Copy-Item -Path $this.$_dataFilePath -Destination $backupFilePath -Force
                
                $backupLimit = $this.$_dataStore.Settings.BackupCount
                if ($backupLimit -is [int] -and $backupLimit -gt 0) {
                    $backups = Get-ChildItem -Path $this.$_backupPath -Filter "pmc-data-*.json" | Sort-Object LastWriteTime -Descending
                    if ($backups.Count -gt $backupLimit) {
                        $backupsToDelete = $backups | Select-Object -Skip $backupLimit
                        foreach ($backup in $backupsToDelete) {
                            Remove-Item -Path $backup.FullName -Force
                            Write-Verbose "DataManager: Removed old backup '$($backup.Name)'."
                        }
                    }
                }
                
                Write-Verbose "DataManager: Created backup '$backupFileName'."
            }
        } catch {
            Write-Warning "DataManager: Failed to create backup: $($_.Exception.Message)"
        }
    }
    
    hidden [void] InitializeEventHandlers() {
        Write-Verbose "DataManager: Event handlers initialized."
    }
    #endregion
    
    #region Lifecycle Management
    [void] Dispose() {
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "DataManager disposing. Checking for unsaved data."
        }
        Write-Verbose "DataManager: Disposing - checking for unsaved data."
        
        if ($this.$_dataModified) {
            $originalTransactionCount = $this.$_updateTransactionCount
            $this.$_updateTransactionCount = 0
            try {
                $this.SaveData()
                if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                    Write-Log -Level Info -Message "Performed final save of modified data during dispose."
                }
                Write-Verbose "DataManager: Performed final save during dispose."
            } catch {
                Write-Warning "DataManager: Failed to save data during dispose: $($_.Exception.Message)"
            } finally {
                $this.$_updateTransactionCount = $originalTransactionCount
            }
        }
    }
    #endregion

    #region Transactional Updates
    [void] BeginUpdate() {
        $this.$_updateTransactionCount++
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Began data update transaction." -Data @{ Depth = $this.$_updateTransactionCount }
        }
        Write-Verbose "DataManager: Began update transaction. Depth: $($this.$_updateTransactionCount)."
    }

    [void] EndUpdate() {
        $this.EndUpdate($false)
    }
    
    [void] EndUpdate([bool]$forceSave) {
        if ($this.$_updateTransactionCount -gt 0) {
            $this.$_updateTransactionCount--
        }
        
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Ended data update transaction." -Data @{ Depth = $this.$_updateTransactionCount }
        }
        Write-Verbose "DataManager: Ended update transaction. Depth: $($this.$_updateTransactionCount)."
        
        if ($this.$_updateTransactionCount -eq 0 -and ($this.$_dataModified -or $forceSave)) {
            if ($this.$_dataStore.Settings.AutoSave -or $forceSave) {
                $this.SaveData()
            }
        }
    }
    #endregion

    #region Task Management Methods
    [PmcTask] AddTask([PmcTask]$newTask) {
        return Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task" -AdditionalData @{ TaskId = $newTask.Id; TaskTitle = $newTask.Title } -ScriptBlock {
            if ([string]::IsNullOrEmpty($newTask.Id)) {
                $newTask.Id = [guid]::NewGuid().ToString()
            }
            if ($newTask.CreatedAt -eq [datetime]::MinValue) {
                $newTask.CreatedAt = [datetime]::Now
            }
            
            if ($this.$_taskIndex.ContainsKey($newTask.Id)) {
                throw [System.InvalidOperationException]::new("Task with ID '$($newTask.Id)' already exists.")
            }
            
            [void]$this.$_dataStore.Tasks.Add($newTask)
            $this.$_taskIndex[$newTask.Id] = $newTask
            $this.$_dataModified = $true
            
            if ($this.$_dataStore.Settings.AutoSave -and $this.$_updateTransactionCount -eq 0) {
                $this.SaveData()
            }
            
            if (Get-Command 'Publish-Event' -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Created"; Task = $newTask }
            }
            
            Write-Verbose "DataManager: Added task '$($newTask.Title)' with ID '$($newTask.Id)'."
            return $newTask
        }
    }

    [PmcTask] UpdateTask([PmcTask]$taskWithUpdates) {
        return Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating task" -AdditionalData @{ TaskId = $taskWithUpdates.Id } -ScriptBlock {
            if (-not $this.$_taskIndex.ContainsKey($taskWithUpdates.Id)) {
                throw [System.InvalidOperationException]::new("Task with ID '$($taskWithUpdates.Id)' not found for update.")
            }
            
            $managedTask = $this.$_taskIndex[$taskWithUpdates.Id]
            
            $propertiesToUpdate = @('Title', 'Description', 'Status', 'Priority', 'ProjectKey', 'Tags', 'DueDate', 'CompletedAt')
            foreach ($propName in $propertiesToUpdate) {
                if ($taskWithUpdates.PSObject.Properties[$propName]) {
                    $managedTask.$propName = $taskWithUpdates.$propName
                }
            }
            $managedTask.UpdatedAt = [datetime]::Now
            
            $this.$_dataModified = $true
            
            if ($this.$_dataStore.Settings.AutoSave -and $this.$_updateTransactionCount -eq 0) {
                $this.SaveData()
            }
            
            if (Get-Command 'Publish-Event' -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Updated"; Task = $managedTask }
            }
            
            Write-Verbose "DataManager: Updated task '$($managedTask.Title)' with ID '$($managedTask.Id)'."
            return $managedTask
        }
    }

    [bool] RemoveTask([string]$taskId) {
        return Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task" -AdditionalData @{ TaskId = $taskId } -ScriptBlock {
            if (-not $this.$_taskIndex.ContainsKey($taskId)) {
                if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                    Write-Log -Level Warning -Message "Task not found for removal: '$taskId'"
                }
                Write-Verbose "DataManager: Task '$taskId' not found for removal."
                return $false
            }
            
            $taskToRemove = $this.$_taskIndex[$taskId]
            [void]$this.$_dataStore.Tasks.Remove($taskToRemove)
            [void]$this.$_taskIndex.Remove($taskId)
            $this.$_dataModified = $true
            
            if ($this.$_dataStore.Settings.AutoSave -and $this.$_updateTransactionCount -eq 0) {
                $this.SaveData()
            }
            
            if (Get-Command 'Publish-Event' -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Deleted"; TaskId = $taskId }
            }
            
            Write-Verbose "DataManager: Removed task with ID '$taskId'."
            return $true
        }
    }
    
    [PmcTask] GetTask([string]$taskId) {
        if ($this.$_taskIndex.ContainsKey($taskId)) {
            return $this.$_taskIndex[$taskId]
        }
        return $null
    }
    
    [PmcTask[]] GetTasks() {
        return $this.$_dataStore.Tasks.ToArray()
    }
    #endregion
    
    #region Project Management Methods
    [PmcProject] AddProject([PmcProject]$newProject) {
        return Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding new project" -AdditionalData @{ ProjectKey = $newProject.Key; ProjectName = $newProject.Name } -ScriptBlock {
            if ([string]::IsNullOrEmpty($newProject.Key)) {
                throw [System.ArgumentException]::new("Project Key is required.")
            }
            if ($newProject.CreatedAt -eq [datetime]::MinValue) {
                $newProject.CreatedAt = [datetime]::Now
            }
            
            if ($this.$_projectIndex.ContainsKey($newProject.Key)) {
                throw [System.InvalidOperationException]::new("Project with Key '$($newProject.Key)' already exists.")
            }
            
            [void]$this.$_dataStore.Projects.Add($newProject)
            $this.$_projectIndex[$newProject.Key] = $newProject
            $this.$_dataModified = $true
            
            if ($this.$_dataStore.Settings.AutoSave -and $this.$_updateTransactionCount -eq 0) {
                $this.SaveData()
            }
            
            if (Get-Command 'Publish-Event' -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Created"; Project = $newProject }
            }
            
            Write-Verbose "DataManager: Added project '$($newProject.Name)' with Key '$($newProject.Key)'."
            return $newProject
        }
    }
    
    [PmcProject] UpdateProject([PmcProject]$projectWithUpdates) {
        return Invoke-WithErrorHandling -Component "DataManager.UpdateProject" -Context "Updating project" -AdditionalData @{ ProjectKey = $projectWithUpdates.Key } -ScriptBlock {
            if (-not $this.$_projectIndex.ContainsKey($projectWithUpdates.Key)) {
                throw [System.InvalidOperationException]::new("Project with Key '$($projectWithUpdates.Key)' not found for update.")
            }
            
            $managedProject = $this.$_projectIndex[$projectWithUpdates.Key]
            
            $propertiesToUpdate = @('Name', 'Description', 'Status', 'CompletedAt')
            foreach ($propName in $propertiesToUpdate) {
                if ($projectWithUpdates.PSObject.Properties[$propName]) {
                    $managedProject.$propName = $projectWithUpdates.$propName
                }
            }
            $managedProject.UpdatedAt = [datetime]::Now
            
            $this.$_dataModified = $true
            
            if ($this.$_dataStore.Settings.AutoSave -and $this.$_updateTransactionCount -eq 0) {
                $this.SaveData()
            }
            
            if (Get-Command 'Publish-Event' -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Updated"; Project = $managedProject }
            }
            
            Write-Verbose "DataManager: Updated project '$($managedProject.Name)' with Key '$($managedProject.Key)'."
            return $managedProject
        }
    }
    
    [bool] RemoveProject([string]$projectKey) {
        return Invoke-WithErrorHandling -Component "DataManager.RemoveProject" -Context "Removing project" -AdditionalData @{ ProjectKey = $projectKey } -ScriptBlock {
            if (-not $this.$_projectIndex.ContainsKey($projectKey)) {
                if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                    Write-Log -Level Warning -Message "Project not found for removal: '$projectKey'"
                }
                Write-Verbose "DataManager: Project '$projectKey' not found for removal."
                return $false
            }
            
            $projectToRemove = $this.$_projectIndex[$projectKey]
            [void]$this.$_dataStore.Projects.Remove($projectToRemove)
            [void]$this.$_projectIndex.Remove($projectKey)
            $this.$_dataModified = $true
            
            if ($this.$_dataStore.Settings.AutoSave -and $this.$_updateTransactionCount -eq 0) {
                $this.SaveData()
            }
            
            if (Get-Command 'Publish-Event' -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Deleted"; ProjectKey = $projectKey }
            }
            
            Write-Verbose "DataManager: Removed project with Key '$projectKey'."
            return $true
        }
    }
    
    [PmcProject] GetProject([string]$projectKey) {
        if ($this.$_projectIndex.ContainsKey($projectKey)) {
            return $this.$_projectIndex[$projectKey]
        }
        return $null
    }
    
    [PmcProject[]] GetProjects() {
        return $this.$_dataStore.Projects.ToArray()
    }
    #endregion
    
    #region Settings and Utility Methods
    [bool] IsAutoSaveEnabled() {
        return $this.$_dataStore.Settings.AutoSave
    }
    
    [void] SetAutoSave([bool]$enabled) {
        $this.$_dataStore.Settings.AutoSave = $enabled
        $this.$_dataModified = $true
        Write-Verbose "DataManager: AutoSave set to '$enabled'."
    }
    
    [datetime] GetLastSaveTime() {
        return $this.$_lastSaveTime
    }
    
    [void] ForceSave() {
        $this.SaveData()
    }
    #endregion
}

class Table : UIElement {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    [scriptblock]$OnSelectionChanged
    hidden [int]$_scrollOffset = 0 # The index of the first visible row

    Table([string]$name) : base($name) {
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        $this.IsFocusable = $true
        $this.Width = 60
        $this.Height = 15
        Write-Verbose "Table: Constructor called for '$($this.Name)'"
    }

    [void] SetColumns([TableColumn[]]$columns) {
        try {
            if ($null -eq $columns) { throw [System.ArgumentNullException]::new("columns") }
            $this.Columns.Clear()
            foreach ($col in $columns) {
                $this.Columns.Add($col)
            }
            $this.RequestRedraw()
            Write-Verbose "Table '$($this.Name)': Set $($columns.Count) columns"
        }
        catch {
            Write-Error "Table '$($this.Name)': Error setting columns: $($_.Exception.Message)"
            throw
        }
    }

    [void] SetData([object[]]$data) {
        try {
            if ($null -eq $data) { throw [System.ArgumentNullException]::new("data") }
            $this.Data = @($data) # Consistently cast to an array
            if ($this.SelectedIndex -ge $this.Data.Count) {
                $this.SelectedIndex = [Math]::Max(0, $this.Data.Count - 1)
            }
            $this._scrollOffset = 0 # Reset scroll on new data
            $this.RequestRedraw()
            Write-Verbose "Table '$($this.Name)': Set data with $($this.Data.Count) items"
        }
        catch {
            Write-Error "Table '$($this.Name)': Error setting data: $($_.Exception.Message)"
            throw
        }
    }

    [void] SelectNext() {
        if ($this.SelectedIndex -lt ($this.Data.Count - 1)) {
            $this.SelectedIndex++
            $this._EnsureVisible()
            $this.RequestRedraw()
            Write-Verbose "Table '$($this.Name)': Selected next item (index $($this.SelectedIndex))"
        }
    }

    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
            $this._EnsureVisible()
            $this.RequestRedraw()
            Write-Verbose "Table '$($this.Name)': Selected previous item (index $($this.SelectedIndex))"
        }
    }

    [object] GetSelectedItem() {
        if ($this.Data.Count -gt 0 -and $this.SelectedIndex -in (0..($this.Data.Count - 1))) {
            return $this.Data[$this.SelectedIndex]
        }
        return $null
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer with theme-aware colors
            $bgColor = Get-ThemeColor 'Background'
            $fgColor = Get-ThemeColor 'Foreground'
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            # Draw border if enabled
            if ($this.ShowBorder) {
                $borderColor = Get-ThemeColor 'Border'
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
            }

            $contentWidth = if ($this.ShowBorder) { $this.Width - 2 } else { $this.Width }
            $contentHeight = $this._GetContentHeight()
            $renderX = if ($this.ShowBorder) { 1 } else { 0 }
            $currentY = if ($this.ShowBorder) { 1 } else { 0 }
            
            # Resolve auto-sized column widths
            $resolvedColumns = $this._ResolveColumnWidths($contentWidth)
            
            # Header
            if ($this.ShowHeader -and $resolvedColumns.Count -gt 0) {
                $headerColor = Get-ThemeColor 'Header'
                $xOffset = 0
                foreach ($col in $resolvedColumns) {
                    $headerText = $this._FormatCell($col.Header, $col.ResolvedWidth, $col.Alignment)
                    Write-TuiText -Buffer $this._private_buffer -X ($renderX + $xOffset) -Y $currentY -Text $headerText -ForegroundColor $headerColor -BackgroundColor $bgColor
                    $xOffset += $col.ResolvedWidth
                }
                $currentY++
            }
            
            # Data rows (respecting scroll offset)
            for ($i = 0; $i -lt $contentHeight; $i++) {
                $dataIndex = $i + $this._scrollOffset
                if ($dataIndex -ge $this.Data.Count) { break }
                $row = $this.Data[$dataIndex]
                if (-not $row) { continue }

                $isSelected = ($dataIndex -eq $this.SelectedIndex)
                $bg = if ($isSelected -and $this.IsFocused) { Get-ThemeColor 'Selection' } else { $bgColor }
                $fg = if ($isSelected -and $this.IsFocused) { Get-ThemeColor 'Background' } else { $fgColor }

                $xOffset = 0
                foreach ($col in $resolvedColumns) {
                    $propValue = $row | Select-Object -ExpandProperty $col.Key -ErrorAction SilentlyContinue
                    $cellValue = if ($propValue) { $propValue.ToString() } else { "" }
                    $cellText = $this._FormatCell($cellValue, $col.ResolvedWidth, $col.Alignment)
                    Write-TuiText -Buffer $this._private_buffer -X ($renderX + $xOffset) -Y $currentY -Text $cellText -ForegroundColor $fg -BackgroundColor $bg
                    $xOffset += $col.ResolvedWidth
                }
                $currentY++
            }

            # Show message if no data
            if ($this.Data.Count -eq 0) {
                $subtleColor = Get-ThemeColor 'Subtle'
                Write-TuiText -Buffer $this._private_buffer -X $renderX -Y $currentY -Text " (No data to display) " -ForegroundColor $subtleColor -BackgroundColor $bgColor
            }
        }
        catch {
            Write-Error "Table '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($null -eq $keyInfo) { return $false }
        try {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { 
                    $this.SelectPrevious()
                    return $true
                }
                ([ConsoleKey]::DownArrow) { 
                    $this.SelectNext()
                    return $true
                }
                ([ConsoleKey]::PageUp) { 
                    0..($this._GetContentHeight() - 1) | ForEach-Object { $this.SelectPrevious() }
                    return $true
                }
                ([ConsoleKey]::PageDown) { 
                    0..($this._GetContentHeight() - 1) | ForEach-Object { $this.SelectNext() }
                    return $true
                }
                ([ConsoleKey]::Home) { 
                    $this.SelectedIndex = 0
                    $this._EnsureVisible()
                    $this.RequestRedraw()
                    return $true
                }
                ([ConsoleKey]::End) { 
                    $this.SelectedIndex = $this.Data.Count - 1
                    $this._EnsureVisible()
                    $this.RequestRedraw()
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($this.OnSelectionChanged) {
                        $item = $this.GetSelectedItem()
                        if ($item) {
                            Invoke-WithErrorHandling -Component "$($this.Name).OnSelectionChanged" -ScriptBlock {
                                & $this.OnSelectionChanged -SelectedItem $item
                            }
                        }
                    }
                    return $true
                }
            }
        }
        catch {
            Write-Error "Table '$($this.Name)': Error handling input: $($_.Exception.Message)"
        }
        return $false
    }
    
    # Ensure the selected item is visible in the viewport
    hidden [void] _EnsureVisible() {
        $contentHeight = $this._GetContentHeight()
        
        # Scroll down if selected item is below visible area
        if ($this.SelectedIndex -ge ($this._scrollOffset + $contentHeight)) {
            $this._scrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        # Scroll up if selected item is above visible area
        if ($this.SelectedIndex -lt $this._scrollOffset) {
            $this._scrollOffset = $this.SelectedIndex
        }
        
        # Ensure scroll offset is within bounds
        $this._scrollOffset = [Math]::Max(0, $this._scrollOffset)
    }
    
    # Calculate available height for content (excluding border and header)
    hidden [int] _GetContentHeight() {
        $h = $this.Height
        if ($this.ShowBorder) { $h -= 2 }
        if ($this.ShowHeader) { $h -= 1 }
        return [Math]::Max(0, $h)
    }

    # Format cell content with proper alignment and overflow handling
    hidden [string] _FormatCell([string]$text, [int]$width, [string]$alignment) {
        if ([string]::IsNullOrEmpty($text)) { return ' ' * $width }
        
        # Handle overflow with ellipsis
        if ($text.Length -gt $width) { 
            $text = $text.Substring(0, $width - 1) + '' 
        }
        
        # Apply alignment
        $result = switch ($alignment.ToLower()) {
            'right' { $text.PadLeft($width) }
            'center' { 
                $pad = [Math]::Max(0, ($width - $text.Length) / 2)
                $padded = (' ' * $pad) + $text
                $padded.PadRight($width)
            }
            default { $text.PadRight($width) }
        }
        return $result
    }
    
    # Resolve column widths, handling 'Auto' sizing
    hidden [object[]] _ResolveColumnWidths([int]$totalWidth) {
        $fixedWidth = 0
        $autoCols = @()
        $resolved = @()

        # First pass: calculate fixed widths and identify auto columns
        foreach ($col in $this.Columns) {
            if ($col.Width -is [int]) {
                $fixedWidth += $col.Width
                $resolved += [pscustomobject]@{ 
                    Original = $col
                    ResolvedWidth = $col.Width
                    Key = $col.Key
                    Header = $col.Header
                    Alignment = $col.Alignment
                }
            } else {
                $autoCols += $col
            }
        }

        # Second pass: distribute remaining width among auto columns
        if ($autoCols.Count -gt 0) {
            $remainingWidth = $totalWidth - $fixedWidth
            $autoWidth = [Math]::Max(1, [Math]::Floor($remainingWidth / $autoCols.Count))
            
            foreach ($col in $autoCols) {
                $resolved += [pscustomobject]@{ 
                    Original = $col
                    ResolvedWidth = $autoWidth
                    Key = $col.Key
                    Header = $col.Header
                    Alignment = $col.Alignment
                }
            }
        }

        # Return in original column order
        $orderedResolved = @()
        foreach ($originalCol in $this.Columns) {
            $matchedCol = $resolved | Where-Object { $_.Original -eq $originalCol } | Select-Object -First 1
            if ($matchedCol) {
                $orderedResolved += $matchedCol
            }
        }
        
        return $orderedResolved
    }

    [string] ToString() {
        return "Table(Name='$($this.Name)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height), Data=$($this.Data.Count) items, Selected=$($this.SelectedIndex))"
    }
}

#endregion

#region Classes from components\tui-components\tui-components.psm1

class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange

    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
        Write-Verbose "RadioButtonComponent: Constructor called for '$($this.Name)'"
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = if ($this.IsFocused) { Get-ThemeColor 'Accent' } else { Get-ThemeColor 'Foreground' }
            $bg = Get-ThemeColor 'Background'
            
            $radio = if ($this.Selected) { "()" } else { "( )" }
            $displayText = "$radio $($this.Text)"
            
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $displayText -ForegroundColor $fg -BackgroundColor $bg
            Write-Verbose "RadioButtonComponent '$($this.Name)': Rendered (Selected: $($this.Selected))"
        }
        catch {
            Write-Error "RadioButtonComponent '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            try {
                if (-not $this.Selected) {
                    $this.Selected = $true
                    
                    # Unselect other radio buttons in the same group
                    if ($this.Parent -and $this.GroupName) {
                        $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        } | ForEach-Object {
                            $_.Selected = $false
                            $_.RequestRedraw()
                        }
                    }
                    
                    if ($this.OnChange) {
                        try {
                            & $this.OnChange -NewValue $this.Selected
                        } catch {
                            Write-Error "RadioButtonComponent '$($this.Name)': Error in OnChange handler: $($_.Exception.Message)"
                        }
                    }
                    
                    $this.RequestRedraw()
                    Write-Verbose "RadioButtonComponent '$($this.Name)': Selected in group '$($this.GroupName)'"
                }
                return $true
            }
            catch {
                Write-Error "RadioButtonComponent '$($this.Name)': Error handling selection: $($_.Exception.Message)"
            }
        }
        return $false
    }

    [string] ToString() {
        return "RadioButtonComponent(Name='$($this.Name)', Text='$($this.Text)', Selected=$($this.Selected), Group='$($this.GroupName)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

class Screen : UIElement {
    [hashtable]$Services
    [object]$ServiceContainer 
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[UIElement]] $Panels
    
    # FIX: Removed the [UIElement] type hint to prevent cross-module conversion errors.
    $LastFocusedComponent
    
    hidden [System.Collections.Generic.Dictionary[string, string]] $EventSubscriptions 

    Screen([string]$name, [hashtable]$services) : base($name) {
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        $this.ServiceContainer = $null
        Write-Verbose "Screen '$($this.Name)' created with hashtable services."
    }

    Screen([string]$name, [object]$serviceContainer) : base($name) {
        $this.ServiceContainer = $serviceContainer
        $this.Services = [hashtable]::new()
        if ($this.ServiceContainer.PSObject.Methods['GetAllRegisteredServices'] -and $this.ServiceContainer.PSObject.Methods['GetService']) { 
            try {
                $registeredServices = $this.ServiceContainer.GetAllRegisteredServices()
                foreach ($service in $registeredServices) {
                    try {
                        $this.Services[$service.Name] = $this.ServiceContainer.GetService($service.Name)
                    } catch {
                        Write-Warning "Screen '$($this.Name)': Failed to resolve service '$($service.Name)' from container: $($_.Exception.Message)"
                    }
                }
                Write-Verbose "Screen '$($this.Name)' populated Services hashtable from ServiceContainer."
            } catch {
                Write-Warning "Screen '$($this.Name)': Failed to enumerate services from container: $($_.Exception.Message)"
            }
        } else {
            Write-Warning "Screen '$($this.Name)' received a non-ServiceContainer object for DI. Services hashtable might be incomplete or inaccurate."
        }
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        Write-Verbose "Screen '$($this.Name)' created with ServiceContainer."
    }

    [void] Initialize() { Write-Verbose "Initialize called for Screen '$($this.Name)': Default (no-op)." }
    [void] OnEnter() { Write-Verbose "OnEnter called for Screen '$($this.Name)': Default (no-op)." }
    [void] OnExit() { Write-Verbose "OnExit called for Screen '$($this.Name)': Default (no-op)." }
    [void] OnResume() { Write-Verbose "OnResume called for Screen '$($this.Name)': Default (no-op)." }

    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Write-Verbose "HandleInput called for Screen '$($this.Name)': Key: $($keyInfo.Key). Default (no-op)."
    }

    [void] Cleanup() {
        try {
            Write-Verbose "Cleanup called for Screen '$($this.Name)'."
            foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
                try {
                    if (Get-Command 'Unsubscribe-Event' -ErrorAction SilentlyContinue) {
                        Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value
                        Write-Verbose "Unsubscribed event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)'."
                    }
                }
                catch {
                    Write-Warning "Failed to unsubscribe event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)': $($_.Exception.Message)"
                }
            }
            $this.EventSubscriptions.Clear()
            foreach ($child in $this.Children) {
                if ($child.PSObject.Methods['Cleanup']) {
                    try { $child.Cleanup() } catch { Write-Warning "Failed to cleanup child '$($child.Name)': $($_.Exception.Message)" }
                }
            }
            $this.Panels.Clear()
            $this.Children.Clear()
            Write-Verbose "Cleaned up resources for screen: $($this.Name)."
        }
        catch {
            Write-Error "Error during Cleanup for screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    # FIX: Removed the [UIElement] type hint from the $panel parameter to prevent cross-module type conversion errors.
    [void] AddPanel([object]$panel) {
        try {
            $this.Panels.Add($panel)
            $this.AddChild($panel) 
            Write-Verbose "Added panel '$($panel.Name)' to screen '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add panel '$($panel.Name)' to screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        try {
            if (Get-Command 'Subscribe-Event' -ErrorAction SilentlyContinue) {
                $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
                $this.EventSubscriptions[$eventName] = $subscriptionId
                Write-Verbose "Screen '$($this.Name)' subscribed to event '$eventName' with HandlerId: $subscriptionId."
            } else {
                Write-Warning "Subscribe-Event function not available. Event subscription for '$eventName' failed."
            }
        }
        catch {
            Write-Error "Failed for screen '$($this.Name)' to subscribe to event '$eventName': $($_.Exception.Message)"
            throw
        }
    }
    
    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent()
        Write-Verbose "_RenderContent called for Screen '$($this.Name)' (rendering UIElement children, including panels)."
    }

    [string] ToString() {
        return "Screen(Name='$($this.Name)', Panels=$($this.Panels.Count), Visible=$($this.Visible))"
    }
}

#endregion

#region Classes from components\advanced-input-components\advanced-input-components.psm1

class MultilineTextBoxComponent : UIElement {
    [string[]]$Lines = @("")
    [string]$Placeholder = "Enter text..."
    [ValidateRange(1, 100)][int]$MaxLines = 10
    [ValidateRange(1, 1000)][int]$MaxLineLength = 100
    [int]$CurrentLine = 0
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    hidden [int]$_scrollOffsetY = 0
    hidden [int]$_scrollOffsetX = 0

    MultilineTextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 40
        $this.Height = 8
        Write-Verbose "MultilineTextBoxComponent: Constructor called for '$($this.Name)'"
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = Get-ThemeColor 'input.background' -Default (Get-ThemeColor 'Background')
            $borderColor = if ($this.IsFocused) { 
                Get-ThemeColor 'input.border.focus' -Default (Get-ThemeColor 'Accent') 
            } else { 
                Get-ThemeColor 'input.border.normal' -Default (Get-ThemeColor 'Border') 
            }
            $fgColor = Get-ThemeColor 'input.foreground' -Default (Get-ThemeColor 'Foreground')
            $placeholderColor = Get-ThemeColor 'input.placeholder' -Default (Get-ThemeColor 'Subtle')
            $cursorColor = Get-ThemeColor 'input.cursor' -Default (Get-ThemeColor 'Accent')
            
            # Clear buffer and draw border
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor

            $textAreaHeight = $this.Height - 2
            $textAreaWidth = $this.Width - 2
            
            # Render visible lines
            for ($i = 0; $i -lt $textAreaHeight; $i++) {
                $lineIndex = $i + $this._scrollOffsetY
                if ($lineIndex -ge $this.Lines.Count) { break }
                
                $lineText = $this.Lines[$lineIndex]
                $displayLine = ""
                
                if ($lineText.Length -gt $this._scrollOffsetX) {
                    $displayLine = $lineText.Substring($this._scrollOffsetX, [Math]::Min($textAreaWidth, $lineText.Length - $this._scrollOffsetX))
                }
                
                if (-not [string]::IsNullOrEmpty($displayLine)) {
                    Write-TuiText -Buffer $this._private_buffer -X 1 -Y ($i + 1) -Text $displayLine -ForegroundColor $fgColor -BackgroundColor $bgColor
                }
            }

            # Show placeholder if empty and not focused
            if ($this.Lines.Count -eq 1 -and [string]::IsNullOrEmpty($this.Lines[0]) -and -not $this.IsFocused) {
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $this.Placeholder -ForegroundColor $placeholderColor -BackgroundColor $bgColor
            }

            # Render cursor
            if ($this.IsFocused) {
                $cursorLineY = $this.CurrentLine - $this._scrollOffsetY
                if ($cursorLineY -ge 0 -and $cursorLineY -lt $textAreaHeight) {
                    $cursorX = 1 + ($this.CursorPosition - $this._scrollOffsetX)
                    if ($cursorX -ge 1 -and $cursorX -le $textAreaWidth) {
                        $cell = $this._private_buffer.GetCell($cursorX, $cursorLineY + 1)
                        if ($null -ne $cell) {
                            $cell.BackgroundColor = $cursorColor
                            $cell.ForegroundColor = $bgColor
                            $this._private_buffer.SetCell($cursorX, $cursorLineY + 1, $cell)
                        }
                    }
                }
            }
            
            Write-Verbose "MultilineTextBoxComponent '$($this.Name)': Rendered successfully"
        }
        catch {
            Write-Error "MultilineTextBoxComponent '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        try {
            $handled = $true
            $currentLineText = $this.Lines[$this.CurrentLine]
            $originalText = $this.Lines -join "`n"
            
            switch ($key.Key) {
                ([ConsoleKey]::Enter) {
                    if ($this.Lines.Count -lt $this.MaxLines) {
                        $beforeCursor = $currentLineText.Substring(0, $this.CursorPosition)
                        $afterCursor = $currentLineText.Substring($this.CursorPosition)
                        
                        $this.Lines[$this.CurrentLine] = $beforeCursor
                        $this.Lines = $this.Lines[0..$this.CurrentLine] + @($afterCursor) + $this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)]
                        
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                    elseif ($this.CurrentLine -gt 0) {
                        $this.CursorPosition = $this.Lines[$this.CurrentLine - 1].Length
                        $this.Lines[$this.CurrentLine - 1] += $currentLineText
                        $this.Lines = $this.Lines[0..($this.CurrentLine - 1)] + $this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)]
                        $this.CurrentLine--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition, 1)
                    }
                    elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.Lines[$this.CurrentLine] += $this.Lines[$this.CurrentLine + 1]
                        $this.Lines = $this.Lines[0..$this.CurrentLine] + $this.Lines[($this.CurrentLine + 2)..($this.Lines.Count - 1)]
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    }
                    elseif ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = $this.Lines[$this.CurrentLine].Length
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.CursorPosition++
                    }
                    elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    if ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                    }
                }
                ([ConsoleKey]::Home) {
                    $this.CursorPosition = 0
                }
                ([ConsoleKey]::End) {
                    $this.CursorPosition = $currentLineText.Length
                }
                ([ConsoleKey]::PageUp) {
                    $this.CurrentLine = [Math]::Max(0, $this.CurrentLine - ($this.Height - 2))
                    $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                }
                ([ConsoleKey]::PageDown) {
                    $this.CurrentLine = [Math]::Min($this.Lines.Count - 1, $this.CurrentLine + ($this.Height - 2))
                    $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                        $newLine = $currentLineText.Insert($this.CursorPosition, $key.KeyChar)
                        if ($newLine.Length -le $this.MaxLineLength) {
                            $this.Lines[$this.CurrentLine] = $newLine
                            $this.CursorPosition++
                        }
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                $this._UpdateScrolling()
                
                # Fire change event if text changed
                $newText = $this.Lines -join "`n"
                if ($newText -ne $originalText -and $this.OnChange) {
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewValue $newText
                    }
                }
                
                $this.RequestRedraw()
            }
            
            return $handled
        }
        catch {
            Write-Error "MultilineTextBoxComponent '$($this.Name)': Error handling input: $($_.Exception.Message)"
            return $false
        }
    }

    hidden [void] _UpdateScrolling() {
        $textAreaHeight = $this.Height - 2
        $textAreaWidth = $this.Width - 2
        
        # Vertical scrolling
        if ($this.CurrentLine -lt $this._scrollOffsetY) {
            $this._scrollOffsetY = $this.CurrentLine
        }
        elseif ($this.CurrentLine -ge ($this._scrollOffsetY + $textAreaHeight)) {
            $this._scrollOffsetY = $this.CurrentLine - $textAreaHeight + 1
        }
        
        # Horizontal scrolling
        if ($this.CursorPosition -lt $this._scrollOffsetX) {
            $this._scrollOffsetX = $this.CursorPosition
        }
        elseif ($this.CursorPosition -ge ($this._scrollOffsetX + $textAreaWidth)) {
            $this._scrollOffsetX = $this.CursorPosition - $textAreaWidth + 1
        }
        
        # Ensure scroll offsets are within bounds
        $this._scrollOffsetY = [Math]::Max(0, $this._scrollOffsetY)
        $this._scrollOffsetX = [Math]::Max(0, $this._scrollOffsetX)
    }

    [string] GetText() {
        return $this.Lines -join "`n"
    }

    [void] SetText([string]$text) {
        if ([string]::IsNullOrEmpty($text)) {
            $this.Lines = @("")
        } else {
            $this.Lines = $text -split "`n"
        }
        $this.CurrentLine = 0
        $this.CursorPosition = 0
        $this._scrollOffsetY = 0
        $this._scrollOffsetX = 0
        $this.RequestRedraw()
    }

    [string] ToString() {
        return "MultilineTextBoxComponent(Name='$($this.Name)', Lines=$($this.Lines.Count), Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$MinValue = [double]::MinValue
    [double]$MaxValue = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [string]$Suffix = ""
    [string]$TextValue = "0"
    [int]$CursorPosition = 0
    [scriptblock]$OnChange

    NumericInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.TextValue = $this.Value.ToString()
        Write-Verbose "NumericInputComponent: Constructor called for '$($this.Name)'"
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = Get-ThemeColor 'input.background' -Fallback (Get-ThemeColor 'Background')
            $borderColor = if ($this.IsFocused) { 
                Get-ThemeColor 'input.border.focus' -Fallback (Get-ThemeColor 'Accent') 
            } else { 
                Get-ThemeColor 'input.border.normal' -Fallback (Get-ThemeColor 'Border') 
            }
            $fgColor = Get-ThemeColor 'input.foreground' -Fallback (Get-ThemeColor 'Foreground')
            $suffixColor = Get-ThemeColor 'input.suffix' -Fallback (Get-ThemeColor 'Subtle')
            $cursorColor = Get-ThemeColor 'input.cursor' -Fallback (Get-ThemeColor 'Accent')
            
            # Clear buffer and draw border
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
            
            # Draw main value
            $displayText = $this.TextValue
            if (-not [string]::IsNullOrEmpty($this.Suffix)) {
                $displayText += $this.Suffix
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayText -ForegroundColor $fgColor -BackgroundColor $bgColor
            
            # Draw spinner arrows
            $spinnerColor = if ($this.IsFocused) { $borderColor } else { (Get-ThemeColor 'Subtle') }
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 0 -Text "" -ForegroundColor $spinnerColor -BackgroundColor $bgColor
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 2 -Text "" -ForegroundColor $spinnerColor -BackgroundColor $bgColor
            
            # Draw cursor
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt ($this.Width - 4)) {
                    $cell = $this._private_buffer.GetCell($cursorX, 1)
                    if ($null -ne $cell) {
                        $cell.BackgroundColor = $cursorColor
                        $cell.ForegroundColor = $bgColor
                        $this._private_buffer.SetCell($cursorX, 1, $cell)
                    }
                }
            }
            
            Write-Verbose "NumericInputComponent '$($this.Name)': Rendered successfully"
        }
        catch {
            Write-Error "NumericInputComponent '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        try {
            $handled = $true
            $originalValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this.Value = [Math]::Min($this.MaxValue, $this.Value + $this.Step)
                    $this._UpdateTextValue()
                }
                ([ConsoleKey]::DownArrow) {
                    $this.Value = [Math]::Max($this.MinValue, $this.Value - $this.Step)
                    $this._UpdateTextValue()
                }
                ([ConsoleKey]::Enter) {
                    if ($this._ValidateAndSetValue($this.TextValue)) {
                        # Value was valid and set
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.CursorPosition++
                    }
                }
                ([ConsoleKey]::Home) {
                    $this.CursorPosition = 0
                }
                ([ConsoleKey]::End) {
                    $this.CursorPosition = $this.TextValue.Length
                }
                default {
                    if ($key.KeyChar -and $this._IsValidNumericChar($key.KeyChar)) {
                        $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                # Fire change event if value changed
                if ($this.Value -ne $originalValue -and $this.OnChange) {
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewValue $this.Value
                    }
                }
                
                $this.RequestRedraw()
            }
            
            return $handled
        }
        catch {
            Write-Error "NumericInputComponent '$($this.Name)': Error handling input: $($_.Exception.Message)"
            return $false
        }
    }

    hidden [bool] _IsValidNumericChar([char]$char) {
        return [char]::IsDigit($char) -or $char -eq '.' -or $char -eq '-'
    }

    hidden [bool] _ValidateAndSetValue([string]$text) {
        try {
            $parsedValue = [double]::Parse($text)
            if ($parsedValue -ge $this.MinValue -and $parsedValue -le $this.MaxValue) {
                $this.Value = $parsedValue
                $this._UpdateTextValue()
                return $true
            }
        }
        catch {
            # Invalid format, revert to current value
            $this._UpdateTextValue()
        }
        return $false
    }

    hidden [void] _UpdateTextValue() {
        $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.TextValue.Length)
    }

    [string] ToString() {
        return "NumericInputComponent(Name='$($this.Name)', Value=$($this.Value), Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

#endregion

#region Classes from modules\dialog-system-class\dialog-system-class.psm1

class ConfirmDialog : Dialog {
    hidden [int] $_selectedButton = 0

    ConfirmDialog([string]$title, [string]$message) : base("ConfirmDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 8
        $this.Width = [Math]::Min(70, [Math]::Max(50, $message.Length + 10))
        Write-Verbose "ConfirmDialog: Created with title '$title'"
    }

    [void] RenderDialogContent() {
        try {
            # Get theme colors
            $normalFg = Get-ThemeColor 'dialog.button.normal.foreground' -Default (Get-ThemeColor 'Foreground')
            $normalBg = Get-ThemeColor 'dialog.button.normal.background' -Default (Get-ThemeColor 'Background')
            $focusFg = Get-ThemeColor 'dialog.button.focus.foreground' -Default (Get-ThemeColor 'Background')
            $focusBg = Get-ThemeColor 'dialog.button.focus.background' -Default (Get-ThemeColor 'Accent')
            
            $buttonY = $this.Height - 3
            $buttons = @("  Yes  ", "  No   ")
            $startX = [Math]::Floor(($this.Width - 24) / 2)
            
            for ($i = 0; $i -lt $buttons.Count; $i++) {
                $isFocused = ($i -eq $this._selectedButton)
                $label = if ($isFocused) { "[ $($buttons[$i].Trim()) ]" } else { $buttons[$i] }
                $fg = if ($isFocused) { $focusFg } else { $normalFg }
                $bg = if ($isFocused) { $focusBg } else { $normalBg }
                
                Write-TuiText -Buffer $this._private_buffer -X ($startX + ($i * 14)) -Y $buttonY -Text $label -ForegroundColor $fg -BackgroundColor $bg
            }
        }
        catch {
            Write-Error "ConfirmDialog '$($this.Name)': Error rendering content: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            { $_ -in @([ConsoleKey]::LeftArrow, [ConsoleKey]::RightArrow, [ConsoleKey]::Tab) } {
                $this._selectedButton = ($this._selectedButton + 1) % 2
                $this.RequestRedraw()
                return $true
            }
            ([ConsoleKey]::Enter) {
                $result = ($this._selectedButton -eq 0) # True for Yes, False for No
                $this.Close($result)
                return $true
            }
        }
        return ([Dialog]$this).HandleInput($key)
    }
}

class GroupPanel : Panel {
    [bool] $IsCollapsed = $false
    [int] $ExpandedHeight = 0
    [int] $HeaderHeight = 1
    [ConsoleColor] $HeaderColor = [ConsoleColor]::DarkBlue
    [string] $CollapseChar = ""
    [string] $ExpandChar = ""

    GroupPanel() : base() {
        $this.Name = "GroupPanel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $this.Height
        Write-Verbose "GroupPanel: Default constructor called for '$($this.Name)'."
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) { # FIX: Removed invalid attributes
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.Name = "GroupPanel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        $this.ExpandedHeight = $height
        Write-Verbose "GroupPanel: Constructor with dimensions and title called for '$($this.Name)' ('$title')."
    }

    [void] ToggleCollapsed() {
        try {
            $this.IsCollapsed = -not $this.IsCollapsed
            if ($this.IsCollapsed) {
                $this.ExpandedHeight = $this.Height
                $this.Resize($this.Width, [Math]::Max(1, $this.HeaderHeight + 2))
                Write-Verbose "GroupPanel '$($this.Name)': Collapsed. Resized to $($this.Width)x$($this.Height)."
            } else {
                $this.Resize($this.Width, [Math]::Max(1, $this.ExpandedHeight))
                Write-Verbose "GroupPanel '$($this.Name)': Expanded. Resized to $($this.Width)x$($this.Height)."
            }
            foreach ($child in $this.Children) {
                $child.Visible = -not $this.IsCollapsed
            }
            $this.RequestRedraw()
            Write-Verbose "GroupPanel '$($this.Name)': Toggled collapsed state to $($this.IsCollapsed). Children visibility updated."
        }
        catch {
            Write-Error "GroupPanel '$($this.Name)': Error toggling collapsed state: $($_.Exception.Message)"
            throw
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) { # FIX: Removed invalid attributes
        try {
            ([Panel]$this).HandleInput($keyInfo)
            if ($this.IsFocused) {
                switch ($keyInfo.Key) {
                    ([ConsoleKey]::Enter) { $this.ToggleCollapsed(); return $true }
                    ([ConsoleKey]::Spacebar) { $this.ToggleCollapsed(); return $true }
                }
            }
            if (-not $this.IsCollapsed) {
                Write-Verbose "GroupPanel '$($this.Name)': Not collapsed, delegating input to children."
                return ([Panel]$this).HandleInput($keyInfo)
            }
            Write-Verbose "GroupPanel '$($this.Name)': Did not handle input. Key: $($keyInfo.Key)."
        }
        catch {
            Write-Error "GroupPanel '$($this.Name)': Error handling input (Key: $($keyInfo.Key)): $($_.Exception.Message)"
            throw
        }
        return $false
    }

    [void] OnRender() {
        ([Panel]$this).OnRender()
        Write-Verbose "GroupPanel '$($this.Name)': Base Panel OnRender completed."
        if ($this.HasBorder -and -not [string]::IsNullOrEmpty($this.Title)) {
            $indicator = if ($this.IsCollapsed) { $this.ExpandChar } else { $this.CollapseChar }
            $indicatorCell = [TuiCell]::new($indicator, $this.TitleColor, $this.BackgroundColor)
            if (3 -lt ($this.Width - 1)) {
                $this._private_buffer.SetCell(2, 0, $indicatorCell)
                Write-Verbose "GroupPanel '$($this.Name)': Indicator '$indicator' drawn."
            }
        }
    }

    [string] ToString() {
        return "GroupPanel(Name='$($this.Name)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height), Collapsed=$($this.IsCollapsed))"
    }
}

class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange

    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
        Write-Verbose "CheckBoxComponent: Constructor called for '$($this.Name)'"
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = if ($this.IsFocused) { Get-ThemeColor 'Accent' } else { Get-ThemeColor 'Foreground' }
            $bg = Get-ThemeColor 'Background'
            
            $checkbox = if ($this.Checked) { "[X]" } else { "[ ]" }
            $displayText = "$checkbox $($this.Text)"
            
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $displayText -ForegroundColor $fg -BackgroundColor $bg
            Write-Verbose "CheckBoxComponent '$($this.Name)': Rendered (Checked: $($this.Checked))"
        }
        catch {
            Write-Error "CheckBoxComponent '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            try {
                $this.Checked = -not $this.Checked
                
                if ($this.OnChange) {
                    try {
                        & $this.OnChange -NewValue $this.Checked
                    } catch {
                        Write-Error "CheckBoxComponent '$($this.Name)': Error in OnChange handler: $($_.Exception.Message)"
                    }
                }
                
                $this.RequestRedraw()
                Write-Verbose "CheckBoxComponent '$($this.Name)': State changed to $($this.Checked)"
                return $true
            }
            catch {
                Write-Error "CheckBoxComponent '$($this.Name)': Error handling toggle: $($_.Exception.Message)"
            }
        }
        return $false
    }

    [string] ToString() {
        return "CheckBoxComponent(Name='$($this.Name)', Text='$($this.Text)', Checked=$($this.Checked), Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    hidden [TaskCompletionSource[object]] $_tcs # For promise-based async result

    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 50
        $this.Height = 10
        $this._tcs = [TaskCompletionSource[object]]::new()
        Write-Verbose "Dialog: Constructor called for '$($this.Name)'"
    }

    [Task[object]] Show() {
        try {
            # Center the dialog on screen
            $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
            $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 4)
            
            # Show as overlay and set focus
            Show-TuiOverlay -Element $this
            Set-ComponentFocus -Component $this
            
            Write-Verbose "Dialog '$($this.Name)': Shown at ($($this.X), $($this.Y))"
            return $this._tcs.Task
        }
        catch {
            Write-Error "Dialog '$($this.Name)': Error showing dialog: $($_.Exception.Message)"
            $this._tcs.TrySetException($_.Exception)
            return $this._tcs.Task
        }
    }

    [void] Close([object]$result, [bool]$wasCancelled = $false) {
        try {
            if ($wasCancelled) {
                $this._tcs.TrySetCanceled()
                Write-Verbose "Dialog '$($this.Name)': Closed with cancellation"
            } else {
                $this._tcs.TrySetResult($result)
                Write-Verbose "Dialog '$($this.Name)': Closed with result: $result"
            }
            
            # The engine will call Cleanup() on this dialog automatically
            Close-TopTuiOverlay
        }
        catch {
            Write-Error "Dialog '$($this.Name)': Error closing dialog: $($_.Exception.Message)"
            $this._tcs.TrySetException($_.Exception)
        }
    }

    [void] OnRender() {
        if (-not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = Get-ThemeColor 'dialog.background' -Default (Get-ThemeColor 'Background')
            $borderColor = Get-ThemeColor 'dialog.border' -Default (Get-ThemeColor 'Border')
            $titleColor = Get-ThemeColor 'dialog.title' -Default (Get-ThemeColor 'Accent')
            
            # Clear buffer with higher z-index for proper overlay rendering
            $clearCell = [TuiCell]::new(' ', $titleColor, $bgColor)
            $clearCell.ZIndex = 100  # Ensure dialog is above background content
            $this._private_buffer.Clear($clearCell)
            
            # Draw dialog box
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -Title " $($this.Title) " -BorderStyle "Double" -BorderColor $borderColor -BackgroundColor $bgColor

            # Render message if present
            if (-not [string]::IsNullOrWhiteSpace($this.Message)) {
                $this._RenderMessage()
            }
            
            # Allow subclasses to render their specific content
            $this.RenderDialogContent()
            
            Write-Verbose "Dialog '$($this.Name)': Rendered"
        }
        catch {
            Write-Error "Dialog '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    hidden [void] _RenderMessage() {
        try {
            $messageColor = Get-ThemeColor 'dialog.message' -Default (Get-ThemeColor 'Foreground')
            $bgColor = Get-ThemeColor 'dialog.background' -Default (Get-ThemeColor 'Background')
            
            $messageY = 2
            $messageX = 2
            $maxWidth = $this.Width - 4
            
            $wrappedLines = Get-WordWrappedLines -Text $this.Message -MaxWidth $maxWidth
            foreach ($line in $wrappedLines) {
                if ($messageY -ge ($this.Height - 3)) { break }
                Write-TuiText -Buffer $this._private_buffer -X $messageX -Y $messageY -Text $line -ForegroundColor $messageColor -BackgroundColor $bgColor
                $messageY++
            }
        }
        catch {
            Write-Error "Dialog '$($this.Name)': Error rendering message: $($_.Exception.Message)"
        }
    }

    # Virtual method for subclasses to render their specific content
    [void] RenderDialogContent() { 
        # Override in subclasses
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Close($null, $true)
            return $true
        }
        return $false
    }

    [string] ToString() {
        return "Dialog(Name='$($this.Name)', Title='$($this.Title)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

class Component : UIElement {
    Component([string]$name) : base($name) {
        $this.Name = $name
        Write-Verbose "Component '$($this.Name)' created."
    }

    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent()
        Write-Verbose "_RenderContent called for Component '$($this.Name)' (delegating to base UIElement)."
    }

    [string] ToString() {
        return "Component(Name='$($this.Name)', Children=$($this.Children.Count))"
    }
}

class AlertDialog : Dialog {
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 8
        $this.Width = [Math]::Min(70, [Math]::Max(40, $message.Length + 10))
        Write-Verbose "AlertDialog: Created with title '$title'"
    }

    [void] RenderDialogContent() {
        try {
            # Get theme colors for button
            $buttonFg = Get-ThemeColor 'dialog.button.focus.foreground' -Default (Get-ThemeColor 'Background')
            $buttonBg = Get-ThemeColor 'dialog.button.focus.background' -Default (Get-ThemeColor 'Accent')
            
            $buttonY = $this.Height - 2
            $buttonLabel = " [ OK ] "
            $buttonX = [Math]::Floor(($this.Width - $buttonLabel.Length) / 2)
            
            Write-TuiText -Buffer $this._private_buffer -X $buttonX -Y $buttonY -Text $buttonLabel -ForegroundColor $buttonFg -BackgroundColor $buttonBg
        }
        catch {
            Write-Error "AlertDialog '$($this.Name)': Error rendering content: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            $this.Close($true)
            return $true
        }
        return ([Dialog]$this).HandleInput($key)
    }
}

class ScrollablePanel : Panel {
    [int] $ScrollX = 0 
    [int] $ScrollY = 0 
    [int] $VirtualWidth = 0 
    [int] $VirtualHeight = 0 
    [bool] $ShowScrollbars = $true 
    hidden [TuiBuffer] $_virtual_buffer = $null

    ScrollablePanel() : base() {
        $this.Name = "ScrollablePanel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        Write-Verbose "ScrollablePanel: Default constructor called for '$($this.Name)'."
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) { # FIX: Removed invalid attributes
        $this.Name = "ScrollablePanel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $true
        $this.CanFocus = $true
        Write-Verbose "ScrollablePanel: Constructor with dimensions called for '$($this.Name)'."
    }

    [void] SetVirtualSize([int]$width, [int]$height) { # FIX: Removed invalid attributes
        if ($width -lt 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width cannot be negative.") }
        if ($height -lt 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height cannot be negative.") }
        try {
            if ($this.VirtualWidth -eq $width -and $this.VirtualHeight -eq $height) {
                Write-Verbose "ScrollablePanel '$($this.Name)': Virtual size already set to $($width)x$($height). No change."
                return
            }
            $this.VirtualWidth = $width
            $this.VirtualHeight = $height
            if ($width -gt 0 -and $height -gt 0) {
                if ($null -ne $this._virtual_buffer -and $this._virtual_buffer.Width -eq $width -and $this._virtual_buffer.Height -eq $height) {
                    Write-Verbose "ScrollablePanel '$($this.Name)': Virtual buffer already correct size."
                } else {
                    $this._virtual_buffer = [TuiBuffer]::new($width, $height, "$($this.Name).Virtual")
                    Write-Verbose "ScrollablePanel '$($this.Name)': Virtual buffer re-initialized to $($width)x$($height)."
                }
            } else {
                $this._virtual_buffer = $null
                Write-Verbose "ScrollablePanel '$($this.Name)': Virtual size set to 0, clearing virtual buffer."
            }
            $this.ScrollTo($this.ScrollX, $this.ScrollY)
            $this.RequestRedraw()
            Write-Verbose "ScrollablePanel '$($this.Name)': Virtual size set to $($width)x$($height)."
        }
        catch {
            Write-Error "ScrollablePanel '$($this.Name)': Error setting virtual size to $($width)x$($height): $($_.Exception.Message)"
            throw
        }
    }

    [void] ScrollTo([int]$x, [int]$y) { # FIX: Removed invalid attributes
        $maxScrollX = [Math]::Max(0, $this.VirtualWidth - $this.ContentWidth)
        $maxScrollY = [Math]::Max(0, $this.VirtualHeight - $this.ContentHeight)
        $newScrollX = [Math]::Max(0, [Math]::Min($x, $maxScrollX))
        $newScrollY = [Math]::Max(0, [Math]::Min($y, $maxScrollY))
        if ($this.ScrollX -eq $newScrollX -and $this.ScrollY -eq $newScrollY) {
            Write-Verbose "ScrollablePanel '$($this.Name)': Scroll position already at ($newScrollX, $newScrollY). No change."
            return
        }
        $this.ScrollX = $newScrollX
        $this.ScrollY = $newScrollY
        $this.RequestRedraw()
        Write-Verbose "ScrollablePanel '$($this.Name)': Scrolled to ($($this.ScrollX), $($this.ScrollY))."
    }

    [void] ScrollBy([int]$deltaX, [int]$deltaY) { # FIX: Removed invalid attributes
        $this.ScrollTo($this.ScrollX + $deltaX, $this.ScrollY + $deltaY)
        Write-Verbose "ScrollablePanel '$($this.Name)': Scrolled by ($deltaX, $deltaY)."
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) { # FIX: Removed invalid attributes
        try {
            ([Panel]$this).HandleInput($keyInfo)
            if ($this.IsFocused) {
                switch ($keyInfo.Key) {
                    ([ConsoleKey]::UpArrow) { $this.ScrollBy(0, -1); return $true }
                    ([ConsoleKey]::DownArrow) { $this.ScrollBy(0, 1); return $true }
                    ([ConsoleKey]::LeftArrow) { $this.ScrollBy(-1, 0); return $true }
                    ([ConsoleKey]::RightArrow) { $this.ScrollBy(1, 0); return $true }
                    ([ConsoleKey]::PageUp) { $this.ScrollBy(0, -$this.ContentHeight); return $true }
                    ([ConsoleKey]::PageDown) { $this.ScrollBy(0, $this.ContentHeight); return $true }
                    ([ConsoleKey]::Home) { $this.ScrollTo(0, 0); return $true }
                    ([ConsoleKey]::End) { $this.ScrollTo(0, $this.VirtualHeight); return $true }
                }
            }
            Write-Verbose "ScrollablePanel '$($this.Name)': Did not handle input. Key: $($keyInfo.Key)."
        }
        catch {
            Write-Error "ScrollablePanel '$($this.Name)': Error handling input (Key: $($keyInfo.Key)): $($_.Exception.Message)"
            throw
        }
        return $false
    }

    [void] OnRender() {
        ([Panel]$this).OnRender()
        Write-Verbose "ScrollablePanel '$($this.Name)': Base Panel OnRender completed."
        if ($null -ne $this._virtual_buffer -and $this.ContentWidth -gt 0 -and $this.ContentHeight -gt 0) {
            $visibleBuffer = $this._virtual_buffer.GetSubBuffer($this.ScrollX, $this.ScrollY, $this.ContentWidth, $this.ContentHeight)
            $this._private_buffer.BlendBuffer($visibleBuffer, $this.ContentX, $this.ContentY)
            Write-Verbose "ScrollablePanel '$($this.Name)': Blended virtual content."
        } else {
            Write-Verbose "ScrollablePanel '$($this.Name)': No virtual content to blend or content area is zero."
        }
        if ($this.ShowScrollbars -and $this.HasBorder) {
            $this.DrawScrollbars()
            Write-Verbose "ScrollablePanel '$($this.Name)': Scrollbars drawn."
        }
    }

    hidden [void] DrawScrollbars() {
        if ($null -eq $this._private_buffer) { return }
        if ($this.VirtualHeight -gt $this.ContentHeight -and $this.Width -gt 1) {
            $scrollbarX = $this.Width - 1
            $scrollbarTrackHeight = $this.Height - 2
            $scrollRatioY = ($this.ScrollY / [Math]::Max(1, $this.VirtualHeight - $this.ContentHeight))
            $thumbPositionInTrack = [Math]::Floor($scrollRatioY * ($scrollbarTrackHeight - 1))
            for ($y = 1; $y -lt ($this.Height - 1); $y++) {
                $char = if ($y -eq ($thumbPositionInTrack + 1)) { '' } else { '' }
                $cell = [TuiCell]::new($char, (Get-ThemeColor 'Subtle'), $this.BackgroundColor)
                $this._private_buffer.SetCell($scrollbarX, $y, $cell)
            }
            Write-Verbose "ScrollablePanel '$($this.Name)': Vertical scrollbar drawn."
        }
        if ($this.VirtualWidth -gt $this.ContentWidth -and $this.Height -gt 1) {
            $scrollbarY = $this.Height - 1
            $scrollbarTrackWidth = $this.Width - 2
            $scrollRatioX = ($this.ScrollX / [Math]::Max(1, $this.VirtualWidth - $this.ContentWidth))
            $thumbPositionInTrack = [Math]::Floor($scrollRatioX * ($scrollbarTrackWidth - 1))
            for ($x = 1; $x -lt ($this.Width - 1); $x++) {
                $char = if ($x -eq ($thumbPositionInTrack + 1)) { '' } else { '' }
                $cell = [TuiCell]::new($char, (Get-ThemeColor 'Subtle'), $this.BackgroundColor)
                $this._private_buffer.SetCell($x, $scrollbarY, $cell)
            }
            Write-Verbose "ScrollablePanel '$($this.Name)': Horizontal scrollbar drawn."
        }
    }

    [object] GetVirtualBuffer() { return $this._virtual_buffer }

    [string] ToString() {
        return "ScrollablePanel(Name='$($this.Name)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height), VirtualSize=$($this.VirtualWidth)x$($this.VirtualHeight), Scroll=($($this.ScrollX),$($this.ScrollY)))"
    }
}

class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick

    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
        Write-Verbose "ButtonComponent: Constructor called for '$($this.Name)'"
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Determine state for theme colors
            $state = if ($this.IsPressed) { "pressed" } elseif ($this.IsFocused) { "focus" } else { "normal" }
            
            # Get theme colors based on state
            $bgColor = Get-ThemeColor "button.$state.background"
            $borderColor = Get-ThemeColor "button.$state.border"
            $fgColor = Get-ThemeColor "button.$state.foreground"
            
            # Fallback to basic theme colors if specific button colors not available
            if (-not $bgColor) {
                $bgColor = if ($this.IsPressed) { Get-ThemeColor 'Accent' } else { Get-ThemeColor 'Background' }
            }
            if (-not $borderColor) {
                $borderColor = if ($this.IsFocused) { Get-ThemeColor 'Accent' } else { Get-ThemeColor 'Border' }
            }
            if (-not $fgColor) {
                $fgColor = if ($this.IsPressed) { Get-ThemeColor 'Background' } else { Get-ThemeColor 'Foreground' }
            }

            # Clear buffer and draw button
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
            
            # Center text
            $textX = [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = [Math]::Floor(($this.Height - 1) / 2)
            Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -ForegroundColor $fgColor -BackgroundColor $bgColor
            
            Write-Verbose "ButtonComponent '$($this.Name)': Rendered in state '$state'"
        }
        catch {
            Write-Error "ButtonComponent '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            try {
                $this.IsPressed = $true
                $this.RequestRedraw()
                
                if ($this.OnClick) {
                    try {
                        & $this.OnClick
                    } catch {
                        Write-Error "ButtonComponent '$($this.Name)': Error in OnClick handler: $($_.Exception.Message)"
                    }
                }
                
                # Brief visual feedback
                Start-Sleep -Milliseconds 50
                $this.IsPressed = $false
                $this.RequestRedraw()
                
                Write-Verbose "ButtonComponent '$($this.Name)': Click event handled"
                return $true
            }
            catch {
                Write-Error "ButtonComponent '$($this.Name)': Error handling click: $($_.Exception.Message)"
                $this.IsPressed = $false
                $this.RequestRedraw()
            }
        }
        return $false
    }

    [string] ToString() {
        return "ButtonComponent(Name='$($this.Name)', Text='$($this.Text)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [ValidateRange(1, [int]::MaxValue)][int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    hidden [int]$_scrollOffset = 0 # Tracks the start of the visible text window

    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        Write-Verbose "TextBoxComponent: Constructor called for '$($this.Name)'"
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = Get-ThemeColor 'Background'
            $borderColor = if ($this.IsFocused) { Get-ThemeColor 'Accent' } else { Get-ThemeColor 'Border' }
            $textColor = Get-ThemeColor 'Foreground'
            $placeholderColor = Get-ThemeColor 'Subtle'
            
            # Clear buffer and draw border
            $this._private_buffer.Clear([TuiCell]::new(' ', $textColor, $bgColor))
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor

            $textAreaWidth = $this.Width - 2
            $displayText = $this.Text ?? ""
            $currentTextColor = $textColor

            # Show placeholder if empty and not focused
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) {
                $displayText = $this.Placeholder ?? ""
                $currentTextColor = $placeholderColor
            }

            # Apply viewport scrolling
            if ($displayText.Length -gt $textAreaWidth) {
                $displayText = $displayText.Substring($this._scrollOffset, [Math]::Min($textAreaWidth, $displayText.Length - $this._scrollOffset))
            }

            # Draw text
            if (-not [string]::IsNullOrEmpty($displayText)) {
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayText -ForegroundColor $currentTextColor -BackgroundColor $bgColor
            }

            # Render non-destructive block cursor
            if ($this.IsFocused) {
                $cursorX = 1 + ($this.CursorPosition - $this._scrollOffset)
                if ($cursorX -ge 1 -and $cursorX -lt ($this.Width - 1)) {
                    $cell = $this._private_buffer.GetCell($cursorX, 1)
                    if ($null -ne $cell) {
                        $cell.BackgroundColor = Get-ThemeColor 'Accent'
                        $cell.ForegroundColor = Get-ThemeColor 'Background'
                        $this._private_buffer.SetCell($cursorX, 1, $cell)
                    }
                }
            }
            
            Write-Verbose "TextBoxComponent '$($this.Name)': Rendered text (length: $($this.Text.Length), cursor: $($this.CursorPosition))"
        }
        catch {
            Write-Error "TextBoxComponent '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition
            $originalText = $currentText
            $handled = $true

            switch ($key.Key) {
                ([ConsoleKey]::Backspace) {
                    if ($cursorPos -gt 0) {
                        $this.Text = $currentText.Remove($cursorPos - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($cursorPos -lt $currentText.Length) {
                        $this.Text = $currentText.Remove($cursorPos, 1)
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($cursorPos -gt 0) {
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($cursorPos -lt $this.Text.Length) {
                        $this.CursorPosition++
                    }
                }
                ([ConsoleKey]::Home) {
                    $this.CursorPosition = 0
                }
                ([ConsoleKey]::End) {
                    $this.CursorPosition = $this.Text.Length
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) {
                        $this.Text = $currentText.Insert($cursorPos, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }

            if ($handled) {
                $this._UpdateScrollOffset()
                
                # Trigger change event if text changed
                if ($this.Text -ne $originalText -and $this.OnChange) {
                    try {
                        & $this.OnChange -NewValue $this.Text
                    } catch {
                        Write-Error "TextBoxComponent '$($this.Name)': Error in OnChange handler: $($_.Exception.Message)"
                    }
                }
                
                $this.RequestRedraw()
                Write-Verbose "TextBoxComponent '$($this.Name)': Input handled, new text: '$($this.Text)'"
            }
            
            return $handled
        }
        catch {
            Write-Error "TextBoxComponent '$($this.Name)': Error handling input: $($_.Exception.Message)"
            return $false
        }
    }

    # Update scroll offset to keep cursor visible
    hidden [void] _UpdateScrollOffset() {
        $textAreaWidth = $this.Width - 2
        
        # Scroll right if cursor is beyond visible area
        if ($this.CursorPosition -gt ($this._scrollOffset + $textAreaWidth - 1)) {
            $this._scrollOffset = $this.CursorPosition - $textAreaWidth + 1
        }
        
        # Scroll left if cursor is before visible area
        if ($this.CursorPosition -lt $this._scrollOffset) {
            $this._scrollOffset = $this.CursorPosition
        }
        
        # Ensure scroll offset is within bounds
        $maxScroll = [Math]::Max(0, $this.Text.Length - $textAreaWidth)
        $this._scrollOffset = [Math]::Min($this._scrollOffset, $maxScroll)
        $this._scrollOffset = [Math]::Max(0, $this._scrollOffset)
    }

    [string] ToString() {
        return "TextBoxComponent(Name='$($this.Name)', Text='$($this.Text)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor

    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
        Write-Verbose "LabelComponent: Constructor called for '$($this.Name)'"
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = $this.ForegroundColor ?? (Get-ThemeColor 'Foreground')
            $bg = Get-ThemeColor 'Background'
            Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $this.Text -ForegroundColor $fg -BackgroundColor $bg
            Write-Verbose "LabelComponent '$($this.Name)': Rendered text '$($this.Text)'"
        }
        catch {
            Write-Error "LabelComponent '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false # Labels don't handle input
    }

    [string] ToString() {
        return "LabelComponent(Name='$($this.Name)', Text='$($this.Text)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

class InputDialog : Dialog {
    hidden [TextBoxComponent] $_textBox
    
    InputDialog([string]$title, [string]$message, [string]$defaultValue = "") : base("InputDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 10
        $this.Width = [Math]::Min(70, [Math]::Max(50, $message.Length + 20))
        # Store default value in metadata for use during initialization
        $this.Metadata.DefaultValue = $defaultValue
        Write-Verbose "InputDialog: Created with title '$title'"
    }

    # Create child components during the Initialize lifecycle hook
    [void] OnInitialize() {
        try {
            $this._textBox = New-TuiTextBox -Props @{ 
                Name = 'DialogInput'
                Text = $this.Metadata.DefaultValue
                Width = $this.Width - 4
                Height = 3
                X = 2
                Y = 4
            }
            $this.AddChild($this._textBox)
            Write-Verbose "InputDialog '$($this.Name)': TextBox component initialized"
        }
        catch {
            Write-Error "InputDialog '$($this.Name)': Error initializing: $($_.Exception.Message)"
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        if ($this._textBox) {
            $this._textBox.Move(2, 4)
            $this._textBox.Resize($newWidth - 4, 3)
        }
    }

    [void] RenderDialogContent() {
        try {
            # The textbox is a child, so the base UIElement.Render() will handle it.
            # We just need to render the buttons.
            $normalFg = Get-ThemeColor 'dialog.button.normal.foreground' -Default (Get-ThemeColor 'Foreground')
            $focusFg = Get-ThemeColor 'dialog.button.focus.foreground' -Default (Get-ThemeColor 'Accent')
            $bgColor = Get-ThemeColor 'dialog.background' -Default (Get-ThemeColor 'Background')
            
            $buttonY = $this.Height - 2
            $okLabel = "[ OK ]"
            $cancelLabel = "[ Cancel ]"
            $startX = $this.Width - $okLabel.Length - $cancelLabel.Length - 6
            
            Write-TuiText -Buffer $this._private_buffer -X $startX -Y $buttonY -Text $okLabel -ForegroundColor $focusFg -BackgroundColor $bgColor
            Write-TuiText -Buffer $this._private_buffer -X ($startX + $okLabel.Length + 2) -Y $buttonY -Text $cancelLabel -ForegroundColor $normalFg -BackgroundColor $bgColor
        }
        catch {
            Write-Error "InputDialog '$($this.Name)': Error rendering content: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Enter) {
            $result = $this._textBox ? $this._textBox.Text : ""
            $this.Close($result)
            return $true
        }
        
        # Let the textbox handle all other input
        if ($this._textBox -and $this._textBox.HandleInput($key)) {
            return $true
        }
        
        return ([Dialog]$this).HandleInput($key)
    }
}

#endregion

#region Classes from components\command-palette\command-palette.psm1

class CommandPalette : UIElement {
    hidden [object] $_actionService
    hidden [TextBoxComponent] $_searchBox
    hidden [object[]] $_filteredActions
    hidden [object[]] $_allActions
    hidden [int] $_selectedIndex
    hidden [int] $_scrollOffset
    hidden [string] $_lastQuery

    CommandPalette([object]$actionService) : base("CommandPalette") {
        if (-not $actionService) {
            throw [System.ArgumentNullException]::new('actionService')
        }
        
        $this._actionService = $actionService
        $this._filteredActions = @()
        $this._allActions = @()
        $this._selectedIndex = 0
        $this._scrollOffset = 0
        $this._lastQuery = ""
        
        $this.IsFocusable = $true
        $this.Enabled = $true
        $this.Visible = $false
        $this.ZIndex = 1000
        
        Write-Verbose "CommandPalette: Constructor called"
    }

    [void] Initialize() {
        Write-Verbose "CommandPalette: Initialize called"
        
        $this._searchBox = New-TuiTextBox -Props @{
            Name = 'CommandPaletteSearch'
            Placeholder = "Type to search actions..."
            Width = 70
            Height = 3
        }
        
        $paletteInstance = $this
        $this._searchBox.OnChange = {
            param($NewValue)
            $paletteInstance._UpdateFilter($NewValue)
        }.GetNewClosure()
        
        $this.AddChild($this._searchBox)
        
        Subscribe-Event -EventName "CommandPalette.Open" -Handler {
            [void]$paletteInstance.Show()
        }.GetNewClosure() -Source "CommandPalette"
        
        Write-Verbose "CommandPalette: Initialization complete"
    }

    [void] Show() {
        try {
            Write-Log -Level Debug -Message "Opening Command Palette"
            
            $screenWidth = $global:TuiState.BufferWidth
            $screenHeight = $global:TuiState.BufferHeight
            
            $this.Width = [Math]::Min(80, ($screenWidth - 10))
            $this.Height = [Math]::Min(20, ($screenHeight - 6))
            $this.X = [Math]::Floor(($screenWidth - $this.Width) / 2)
            $this.Y = [Math]::Floor(($screenHeight - $this.Height) / 4)
            
            if ($null -eq $this._private_buffer -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
                $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
            }

            $this._searchBox.Move(2, 2)
            $this._searchBox.Resize(($this.Width - 4), 3)

            $this.Visible = $true
            $this._selectedIndex = 0
            $this._scrollOffset = 0
            $this._searchBox.Text = ""
            $this._lastQuery = ""

            $this._allActions = $this._actionService.GetAllActions()
            $this._filteredActions = $this._allActions
            
            Show-TuiOverlay -Element $this
            Set-ComponentFocus -Component $this._searchBox
            Request-TuiRefresh
            
            Write-Verbose "CommandPalette: Shown successfully"
        }
        catch {
            Write-Error "CommandPalette: Error showing palette: $($_.Exception.Message)"
        }
    }

    [void] Hide() {
        try {
            Write-Log -Level Debug -Message "Closing Command Palette"
            $this.Visible = $false
            Close-TopTuiOverlay
            if ($global:TuiState.FocusedComponent -eq $this._searchBox) { Set-ComponentFocus -Component $null }
            Request-TuiRefresh
            Write-Verbose "CommandPalette: Hidden successfully"
        }
        catch { Write-Error "CommandPalette: Error hiding palette: $($_.Exception.Message)" }
    }

    hidden [void] _UpdateFilter([string]$query) {
        try {
            $this._lastQuery = $query
            $this._selectedIndex = 0
            $this._scrollOffset = 0
            if ([string]::IsNullOrWhiteSpace($query)) {
                $this._filteredActions = $this._allActions
            } else {
                $this._filteredActions = $this._allActions | Where-Object { $_.Name -like "*$query*" -or $_.Description -like "*$query*" }
            }
            $this.RequestRedraw()
            Write-Verbose "CommandPalette: Filter updated, $($this._filteredActions.Count) results"
        }
        catch { Write-Error "CommandPalette: Error updating filter: $($_.Exception.Message)" }
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor 'Background'
            $borderColor = Get-ThemeColor 'Accent'
            $fgColor = Get-ThemeColor 'Foreground'
            $selectionBg = Get-ThemeColor 'Selection'
            $selectionFg = Get-ThemeColor 'Background'
            $subtleColor = Get-ThemeColor 'Subtle'
            
            # Clear buffer with higher z-index for proper overlay rendering
            $clearCell = [TuiCell]::new(' ', $fgColor, $bgColor)
            $clearCell.ZIndex = 100  # Ensure palette is above background content
            $this._private_buffer.Clear($clearCell)
            
            $title = " Command Palette ($($this._filteredActions.Count)) "
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -Title $title -BorderStyle "Double" -BorderColor $borderColor -BackgroundColor $bgColor

            $helpText = " [] Navigate | [Enter] Execute | [Esc] Close "
            if ($helpText.Length -lt ($this.Width - 2)) {
                $helpX = $this.Width - $helpText.Length - 1
                Write-TuiText -Buffer $this._private_buffer -X $helpX -Y ($this.Height - 1) -Text $helpText -ForegroundColor $subtleColor -BackgroundColor $bgColor
            }

            $listY = 5
            $listHeight = $this.Height - 6
            
            for ($i = 0; $i -lt $listHeight; $i++) {
                $dataIndex = $i + $this._scrollOffset
                if ($dataIndex -ge $this._filteredActions.Count) { break }
                $action = $this._filteredActions[$dataIndex]
                $yPos = $listY + $i
                $isSelected = ($dataIndex -eq $this._selectedIndex)
                $itemBg = if ($isSelected) { $selectionBg } else { $bgColor }
                $itemFg = if ($isSelected) { $selectionFg } else { $fgColor }
                
                $highlightText = ' ' * ($this.Width - 2)
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y $yPos -Text $highlightText -ForegroundColor $itemFg -BackgroundColor $itemBg

                $displayText = " $($action.Name)"
                if ($action.Description) { $displayText += ": $($action.Description)" }
                
                $maxWidth = $this.Width - 4
                if ($displayText.Length -gt $maxWidth) { $displayText = $displayText.Substring(0, $maxWidth - 3) + "..." }
                
                Write-TuiText -Buffer $this._private_buffer -X 2 -Y $yPos -Text $displayText -ForegroundColor $itemFg -BackgroundColor $itemBg
            }

            if ($this._filteredActions.Count -eq 0 -and -not [string]::IsNullOrWhiteSpace($this._lastQuery)) {
                $noResultsText = "No actions match '$($this._lastQuery)'"
                $centerX = [Math]::Floor(($this.Width - $noResultsText.Length) / 2)
                $centerY = [Math]::Floor($this.Height / 2)
                Write-TuiText -Buffer $this._private_buffer -X $centerX -Y $centerY -Text $noResultsText -ForegroundColor $subtleColor -BackgroundColor $bgColor
            }
            Write-Verbose "CommandPalette: Rendered successfully"
        }
        catch { Write-Error "CommandPalette: Error during render: $($_.Exception.Message)" }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if (-not $this.Visible) { return $false }
        if ($null -eq $keyInfo) { return $false }
        
        try {
            if ($this._searchBox.IsFocused) {
                # This switch intercepts navigation keys, passing everything else to the text box.
                switch ($keyInfo.Key) {
                    { $_ -in @(
                        [ConsoleKey]::UpArrow, [ConsoleKey]::DownArrow, [ConsoleKey]::PageUp,
                        [ConsoleKey]::PageDown, [ConsoleKey]::Home, [ConsoleKey]::End,
                        [ConsoleKey]::Enter, [ConsoleKey]::Escape
                      ) } {
                        # Do nothing, effectively "swallowing" the key press so it's not typed.
                      }
                    default {
                        if ($this._searchBox.HandleInput($keyInfo)) {
                            return $true
                        }
                    }
                }
            }
            
            # This switch handles navigation for the palette itself.
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Escape) { $this.Hide(); return $true }
                ([ConsoleKey]::Enter) {
                    if ($this._filteredActions.Count -gt 0 -and $this._selectedIndex -lt $this._filteredActions.Count) {
                        $action = $this._filteredActions[$this._selectedIndex]
                        $this.Hide()
                        try {
                            $this._actionService.ExecuteAction($action.Name)
                            Write-Log -Level Info -Message "Executed action: $($action.Name)"
                        }
                        catch {
                            Write-Error "Failed to execute action '$($action.Name)': $($_.Exception.Message)"
                            if (Get-Command Show-AlertDialog -ErrorAction SilentlyContinue) { Show-AlertDialog -Title "Action Failed" -Message "Failed to execute action: $($_.Exception.Message)" }
                        }
                    }
                    return $true
                }
                ([ConsoleKey]::UpArrow) {
                    if ($this._selectedIndex -gt 0) {
                        $this._selectedIndex--
                        $this._EnsureSelectedVisible()
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this._selectedIndex -lt ($this._filteredActions.Count - 1)) {
                        $this._selectedIndex++
                        $this._EnsureSelectedVisible()
                        $this.RequestRedraw()
                    }
                    return $true
                }
                ([ConsoleKey]::PageUp) {
                    $pageSize = $this.Height - 6
                    $this._selectedIndex = [Math]::Max(0, ($this._selectedIndex - $pageSize))
                    $this._EnsureSelectedVisible()
                    $this.RequestRedraw()
                    return $true
                }
                ([ConsoleKey]::PageDown) {
                    $pageSize = $this.Height - 6
                    $this._selectedIndex = [Math]::Min(($this._filteredActions.Count - 1), ($this._selectedIndex + $pageSize))
                    $this._EnsureSelectedVisible()
                    $this.RequestRedraw()
                    return $true
                }
                ([ConsoleKey]::Home) {
                    $this._selectedIndex = 0
                    $this._EnsureSelectedVisible()
                    $this.RequestRedraw()
                    return $true
                }
                ([ConsoleKey]::End) {
                    $this._selectedIndex = $this._filteredActions.Count - 1
                    $this._EnsureSelectedVisible()
                    $this.RequestRedraw()
                    return $true
                }
            }
            return $false
        }
        catch {
            Write-Error "CommandPalette: Error handling input: $($_.Exception.Message)"
            return $false
        }
    }
    
    hidden [void] _EnsureSelectedVisible() {
        $listHeight = $this.Height - 6
        if ($this._selectedIndex -lt $this._scrollOffset) { $this._scrollOffset = $this._selectedIndex }
        elseif ($this._selectedIndex -ge ($this._scrollOffset + $listHeight)) { $this._scrollOffset = $this._selectedIndex - $listHeight + 1 }
        $this._scrollOffset = [Math]::Max(0, $this._scrollOffset)
    }

    [string] ToString() {
        return "CommandPalette(Name='$($this.Name)', Actions=$($this._allActions.Count), Filtered=$($this._filteredActions.Count), Selected=$($this._selectedIndex))"
    }
}

#endregion

#region Classes from screens\dashboard-screen\dashboard-screen.psm1

class DashboardScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [Panel] $_summaryPanel
    hidden [Panel] $_statusPanel
    hidden [Panel] $_helpPanel
    #endregion

    #region State
    hidden [int] $_totalTasks = 0
    hidden [int] $_completedTasks = 0
    hidden [int] $_pendingTasks = 0
    #endregion

    DashboardScreen([object]$serviceContainer) : base("DashboardScreen", $serviceContainer) {}

    [void] Initialize() {
        if (-not $this.ServiceContainer) {
            Write-Warning "DashboardScreen.Initialize: ServiceContainer is null"
            return
        }
        
        $this._mainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "Axiom-Phoenix Dashboard")
        $this.AddChild($this._mainPanel)

        $summaryWidth = [Math]::Floor($this.Width * 0.5)
        $this._summaryPanel = [Panel]::new(1, 1, $summaryWidth, 12, "Task Summary")
        $this._mainPanel.AddChild($this._summaryPanel)

        $helpX = $summaryWidth + 2
        $helpWidth = $this.Width - $helpX - 1
        $this._helpPanel = [Panel]::new($helpX, 1, $helpWidth, 12, "Quick Start")
        $this._mainPanel.AddChild($this._helpPanel)

        $this._statusPanel = [Panel]::new(1, 14, $this.Width - 2, $this.Height - 15, "System Status")
        $this._mainPanel.AddChild($this._statusPanel)
        
        if ($this.PSObject.Methods['SubscribeToEvent']) {
            $this.SubscribeToEvent("Tasks.Changed", {
                param($EventData)
                if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                    Write-Log -Level Debug "DashboardScreen detected Tasks.Changed event. Refreshing data."
                }
                if ($this.ServiceContainer) {
                    $this._RefreshData($this.ServiceContainer.GetService("DataManager"))
                }
            })
        }
    }

    [void] OnEnter() {
        Write-Verbose "DashboardScreen: OnEnter called"
        
        # Force a complete redraw of all panels
        if ($this._summaryPanel) { $this._summaryPanel.RequestRedraw() }
        if ($this._helpPanel) { $this._helpPanel.RequestRedraw() }
        if ($this._statusPanel) { $this._statusPanel.RequestRedraw() }
        if ($this._mainPanel) { $this._mainPanel.RequestRedraw() }
        
        if ($this.ServiceContainer) {
            $this._RefreshData($this.ServiceContainer.GetService("DataManager"))
        } else {
            Write-Warning "DashboardScreen.OnEnter: ServiceContainer is null, using defaults"
            $this._RefreshData($null)
        }
        
        # Force another redraw after data refresh
        $this.RequestRedraw()
        
        if ($this._mainPanel -and (Get-Command Set-ComponentFocus -ErrorAction SilentlyContinue)) {
            Set-ComponentFocus -Component $this._mainPanel
        }
    }

    hidden [void] _RefreshData([object]$dataManager) {
        if(-not $dataManager) {
            Write-Warning "DashboardScreen: DataManager service not found."
            $this._totalTasks = 0
            $this._completedTasks = 0
            $this._pendingTasks = 0
        } else {
            $allTasks = $dataManager.GetTasks()
            $this._totalTasks = $allTasks.Count
            $this._completedTasks = ($allTasks | Where-Object { $_.Completed }).Count
            $this._pendingTasks = $this._totalTasks - $this._completedTasks
        }
        $this._UpdateDisplay()
    }
    
    hidden [void] _UpdateDisplay() {
        $this._UpdateSummaryPanel()
        $this._UpdateHelpPanel()
        $this._UpdateStatusPanel()
        $this.RequestRedraw()
    }
    
    hidden [void] _UpdateSummaryPanel() {
        $panel = $this._summaryPanel
        if (-not $panel) { return }
        
        Write-Verbose "DashboardScreen: Updating summary panel"
        
        # Clear the panel content completely
        $panel.ClearContent()
        
        # Force the panel to render its background
        $panel.OnRender()

        $headerColor = Get-ThemeColor 'Header'
        $subtleColor = Get-ThemeColor 'Subtle'
        $defaultColor = Get-ThemeColor 'Foreground'
        $highlightColor = Get-ThemeColor 'Highlight'
        $bgColor = Get-ThemeColor 'Background'
        
        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY

        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY) -Text "Task Overview" -ForegroundColor $headerColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 1) -Text ('' * ($panel.ContentWidth - 2)) -ForegroundColor $subtleColor -BackgroundColor $bgColor
        
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 3) -Text "Total Tasks:    $($this._totalTasks)" -ForegroundColor $defaultColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 4) -Text "Completed:      $($this._completedTasks)" -ForegroundColor $defaultColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 5) -Text "Pending:        $($this._pendingTasks)" -ForegroundColor $defaultColor -BackgroundColor $bgColor
        
        $progress = $this._GetProgressBar()
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 7) -Text "Overall Progress:" -ForegroundColor $defaultColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 8) -Text $progress -ForegroundColor $highlightColor -BackgroundColor $bgColor
        
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateHelpPanel() {
        $panel = $this._helpPanel
        if (-not $panel) { return }
        
        Write-Verbose "DashboardScreen: Updating help panel"
        
        # Clear the panel content completely
        $panel.ClearContent()
        
        # Force the panel to render its background
        $panel.OnRender()
        
        $paletteHotkey = "Ctrl+P"
        
        $headerColor = Get-ThemeColor 'Header'
        $subtleColor = Get-ThemeColor 'Subtle'
        $defaultColor = Get-ThemeColor 'Foreground'
        $accentColor = Get-ThemeColor 'Accent'
        $bgColor = Get-ThemeColor 'Background'

        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY
        
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 0) -Text "Welcome to Axiom-Phoenix!" -ForegroundColor $headerColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 1) -Text ('' * ($panel.ContentWidth - 2)) -ForegroundColor $subtleColor -BackgroundColor $bgColor
        
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 3) -Text "Press " -ForegroundColor $defaultColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 7) -Y ($contentY + 3) -Text $paletteHotkey -ForegroundColor $accentColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 7 + $paletteHotkey.Length) -Y ($contentY + 3) -Text " to open the" -ForegroundColor $defaultColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 4) -Text "Command Palette." -ForegroundColor $defaultColor -BackgroundColor $bgColor

        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 6) -Text "All navigation and actions are" -ForegroundColor $subtleColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 7) -Text "now available from there." -ForegroundColor $subtleColor -BackgroundColor $bgColor
        
        $panel.RequestRedraw()
    }
    
    hidden [void] _UpdateStatusPanel() {
        $panel = $this._statusPanel
        if (-not $panel) { return }
        
        Write-Verbose "DashboardScreen: Updating status panel"
        
        # Clear the panel content completely
        $panel.ClearContent()
        
        # Force the panel to render its background
        $panel.OnRender()

        $memoryMB = try { [Math]::Round((Get-Process -Id $global:PID).WorkingSet64 / 1MB, 2) } catch { 0 } # FIX: Changed $PID to $global:PID to access the global automatic variable from within a class method.

        $headerColor = Get-ThemeColor 'Header'
        $subtleColor = Get-ThemeColor 'Subtle'
        $defaultColor = Get-ThemeColor 'Foreground'
        $bgColor = Get-ThemeColor 'Background'
        
        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY

        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 0) -Text "System Information" -ForegroundColor $headerColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 1) -Text ('' * ($panel.ContentWidth - 2)) -ForegroundColor $subtleColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 3) -Text "PowerShell Version: $($global:PSVersionTable.PSVersion)" -ForegroundColor $defaultColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 4) -Text "Platform:           $($global:PSVersionTable.Platform)" -ForegroundColor $defaultColor -BackgroundColor $bgColor
        Write-TuiText -Buffer $buffer -X ($contentX + 1) -Y ($contentY + 5) -Text "Memory Usage:       $($memoryMB) MB" -ForegroundColor $defaultColor -BackgroundColor $bgColor
        
        $panel.RequestRedraw()
    }

    hidden [string] _GetProgressBar() {
        if ($this._totalTasks -eq 0) { return "No tasks defined." }
        $percentage = [Math]::Round(($this._completedTasks / $this._totalTasks) * 100)
        $barLength = $this._summaryPanel.ContentWidth - 6
        if($barLength -lt 1) { $barLength = 1 }
        $filledLength = [Math]::Floor(($percentage / 100) * $barLength)
        $bar = '' * $filledLength + '' * ($barLength - $filledLength)
        return "[$bar] $percentage%"
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($keyInfo.Key -eq [ConsoleKey]::F5) {
            $this._RefreshData($this.ServiceContainer.GetService("DataManager"))
            return $true
        }
        return $false
    }
}

#endregion

#region Classes from screens\task-list-screen\task-list-screen.psm1

class TaskListScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [Panel] $_headerPanel
    hidden [Panel] $_tablePanel
    hidden [Panel] $_footerPanel
    hidden [Table] $_taskTable
    #endregion

    #region State
    hidden [string] $_filterStatus = "All"
    hidden [PmcTask] $_selectedTask
    #endregion

    # Constructor is minimal, only calling its base.
    TaskListScreen([object]$serviceContainer) : base("TaskListScreen", $serviceContainer) {}

    # OnInitialize creates the UI, registers context-specific actions, and subscribes to events.
    [void] OnInitialize() {
        # --- UI Construction ---
        $this._mainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "Task Management")
        $this.AddChild($this._mainPanel)

        $this._headerPanel = [Panel]::new(1, 1, $this.Width - 2, 1)
        $this._headerPanel.HasBorder = $false
        $this._mainPanel.AddChild($this._headerPanel)

        # The main panel for the table, which gives it a border.
        $this._tablePanel = [Panel]::new(1, 2, $this.Width - 2, $this.Height - 4)
        $this._mainPanel.AddChild($this._tablePanel)
        
        $this._footerPanel = [Panel]::new(1, $this.Height - 2, $this.Width - 2, 1)
        $this._footerPanel.HasBorder = $false
        $this._mainPanel.AddChild($this._footerPanel)

        # --- Table Setup ---
        $this._taskTable = [Table]::new("TaskTable")
        $this._taskTable.Move(0,0)
        $this._taskTable.Resize($this._tablePanel.ContentWidth, $this._tablePanel.ContentHeight)
        $this._taskTable.ShowBorder = $false
        $this._taskTable.SetColumns(@(
            [TableColumn]::new('Title', 'Task Title', 'Auto'),
            [TableColumn]::new('Status', 'Status', 15),
            [TableColumn]::new('Priority', 'Priority', 12)
        ))
        # When the table selection changes, update our local state.
        $this._taskTable.OnSelectionChanged = { param($SelectedItem) $this._selectedTask = $SelectedItem }.GetNewClosure()
        $this._tablePanel.AddChild($this._taskTable)

        # --- Register Actions & Keybindings for THIS screen's context ---
        $this._RegisterActions()
        
        # --- Subscribe to global events ---
        $this.SubscribeToEvent("Tasks.Changed", { $this._RefreshData() })
    }

    # OnEnter/OnExit manage the keybinding context for this screen.
    [void] OnEnter() {
        $keybindingService = $this.ServiceContainer.GetService('KeybindingService')
        $keybindingService.PushContext('tasklist')
        $this._RefreshData()
        Set-ComponentFocus -Component $this._taskTable
    }

    [void] OnExit() {
        $keybindingService = $this.ServiceContainer.GetService('KeybindingService')
        $keybindingService.PopContext()
    }

    # Registers all actions and keybindings specific to this screen.
    hidden [void] _RegisterActions() {
        $actionService = $this.ServiceContainer.GetService('ActionService')
        $keybindingService = $this.ServiceContainer.GetService('KeybindingService')
        $context = 'tasklist' # Define the context for these actions/bindings

        # A helper closure to ensure an action isn't run if no task is selected.
        $withSelectedTask = {
            param($scriptblock)
            if ($this._selectedTask) { . $scriptblock $this._selectedTask }
            else { Show-AlertDialog -Title 'No Task Selected' -Message 'Please select a task first.' | Out-Null }
        }

        # New Task
        $actionService.RegisterAction("task.new", "Create a new task", { $this._ShowNewTaskDialog() }, "Tasks")
        $keybindingService.SetBinding("task.new", 'N', $context)

        # Edit Task
        $actionService.RegisterAction("task.edit", "Edit selected task", { . $withSelectedTask { param($task) $this._ShowEditTaskDialog($task) } }, "Tasks")
        $keybindingService.SetBinding("task.edit", 'E', $context)
        
        # Delete Task
        $actionService.RegisterAction("task.delete", "Delete selected task", { . $withSelectedTask { param($task) $this._ShowDeleteConfirmDialog($task) } }, "Tasks")
        $keybindingService.SetBinding("task.delete", 'Delete', $context)

        # Toggle Task Status
        $actionService.RegisterAction("task.toggleStatus", "Toggle task status", { . $withSelectedTask { param($task) $this._ToggleTaskStatus($task) } }, "Tasks")
        $keybindingService.SetBinding("task.toggleStatus", 'Spacebar', $context)

        # Cycle Filter
        $actionService.RegisterAction("task.cycleFilter", "Cycle task filter", { $this._CycleFilter() }, "Tasks")
        $keybindingService.SetBinding("task.cycleFilter", 'F', $context)

        # Navigate Back
        $actionService.RegisterAction("task.back", "Return to dashboard", { $this.ServiceContainer.GetService('NavigationService').PopScreen() }, "Navigation")
        $keybindingService.SetBinding("task.back", 'Escape', $context)
    }

    # Fetches tasks, applies filters, and updates the table and display.
    hidden [void] _RefreshData() {
        $dataManager = $this.ServiceContainer.GetService('DataManager')
        $allTasks = $dataManager.GetTasks()
        $filteredTasks = switch ($this._filterStatus) {
            "Active"    { $allTasks | Where-Object { -not $_.Completed } }
            "Completed" { $allTasks | Where-Object { $_.Completed } }
            default     { $allTasks }
        }
        $this._taskTable.SetData($filteredTasks)
        $this._UpdateDisplay()
    }
    
    # Redraws the static parts of the screen like headers and footers.
    hidden [void] _UpdateDisplay() {
        $theme = $this.ServiceContainer.GetService('ThemeManager')
        # Header
        $this._headerPanel.ClearContent()
        $headerText = " Filter: $($this._filterStatus) "
        $this._headerPanel.WriteToBuffer(0, 0, $headerText, $theme.GetColor('header.foreground'), $theme.GetColor('header.background'))
        
        # Footer (Dynamic Help Text based on current keybindings)
        $this._footerPanel.ClearContent()
        $keybindingService = $this.ServiceContainer.GetService('KeybindingService')
        $bindings = @(
            "($($keybindingService.GetBindingDescription('task.toggleStatus')))-Toggle"
            "($($keybindingService.GetBindingDescription('task.new')))-New"
            "($($keybindingService.GetBindingDescription('task.edit')))-Edit"
            "($($keybindingService.GetBindingDescription('task.cycleFilter')))-Filter"
            "($($keybindingService.GetBindingDescription('task.back')))-Back"
        )
        $this._footerPanel.WriteToBuffer(0, 0, ($bindings -join ' | '), $theme.GetColor('statusbar.foreground'), $theme.GetColor('statusbar.background'))
        
        $this.RequestRedraw()
    }
    
    # The screen's input handler delegates all input to the focused child (the table).
    # The table will then translate keystrokes into actions via the KeybindingService.
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        return $this._taskTable.HandleInput($keyInfo)
    }

    #region Task Action Implementations
    hidden [void] _ToggleTaskStatus([PmcTask]$task) {
        # The logic is simple: update the task and let the DataManager notify everyone.
        $task.UpdateProgress($task.Completed ? 0 : 100)
        $this.ServiceContainer.GetService('DataManager').UpdateTask($task)
    }

    hidden [void] _CycleFilter() {
        $this._filterStatus = switch ($this._filterStatus) {
            "All"       { "Active" }
            "Active"    { "Completed" }
            default     { "All" }
        }
        # Refresh data, which will re-filter and trigger a display update.
        $this._RefreshData() 
    }
    
    hidden [void] _ShowNewTaskDialog() {
        # Using the async/await dialog API for cleaner code.
        $title = await Show-InputDialog -Title "New Task" -Message "Enter task title:"
        if ($title) { # A non-null/non-empty result means the user pressed OK
            $newTask = [PmcTask]::new($title)
            $this.ServiceContainer.GetService('DataManager').AddTask($newTask)
        }
    }
    
    hidden [void] _ShowEditTaskDialog([PmcTask]$task) {
        $newTitle = await Show-InputDialog -Title "Edit Task" -Message "New title:" -DefaultValue $task.Title
        if ($newTitle) {
            $task.Title = $newTitle
            $this.ServiceContainer.GetService('DataManager').UpdateTask($task)
        }
    }
    
    hidden [void] _ShowDeleteConfirmDialog([PmcTask]$task) {
        $confirmed = await Show-ConfirmDialog -Title "Delete Task" -Message "Delete task `"$($task.Title)`"?"
        if ($confirmed) {
            $this.ServiceContainer.GetService('DataManager').RemoveTask($task.Id)
        }
    }
    #endregion
}

class ComboBoxComponent : UIElement {
    [string[]]$Items = @()
    [int]$SelectedIndex = -1
    [string]$SelectedItem = ""
    [string]$DisplayText = ""
    [string]$SearchText = ""
    [bool]$IsDropDownOpen = $false
    [bool]$AllowSearch = $true
    [ValidateRange(3, 20)][int]$MaxDropDownHeight = 8
    [int]$ScrollOffset = 0
    [scriptblock]$OnSelectionChanged
    
    hidden [TuiBuffer]$_dropdownBuffer = $null
    hidden [string[]]$_filteredItems = @()

    ComboBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 30
        $this.Height = 3
        $this._filteredItems = $this.Items
        Write-Verbose "ComboBoxComponent: Constructor called for '$($this.Name)'"
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = Get-ThemeColor 'input.background' -Fallback (Get-ThemeColor 'Background')
            $borderColor = if ($this.IsFocused) { 
                Get-ThemeColor 'input.border.focus' -Fallback (Get-ThemeColor 'Accent') 
            } else { 
                Get-ThemeColor 'input.border.normal' -Fallback (Get-ThemeColor 'Border') 
            }
            $fgColor = Get-ThemeColor 'input.foreground' -Fallback (Get-ThemeColor 'Foreground')
            
            # Clear buffer and draw border
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
            
            # Draw current value or search text
            $displayValue = if ($this.IsDropDownOpen -and $this.AllowSearch) { $this.SearchText } else { $this.DisplayText }
            if (-not [string]::IsNullOrEmpty($displayValue)) {
                $maxTextWidth = $this.Width - 6
                if ($displayValue.Length -gt $maxTextWidth) {
                    $displayValue = $displayValue.Substring(0, $maxTextWidth - 3) + "..."
                }
                Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $displayValue -ForegroundColor $fgColor -BackgroundColor $bgColor
            }
            
            # Draw dropdown arrow
            $arrow = if ($this.IsDropDownOpen) { "" } else { "" }
            $arrowColor = if ($this.IsFocused) { $borderColor } else { (Get-ThemeColor 'Subtle') }
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text $arrow -ForegroundColor $arrowColor -BackgroundColor $bgColor
            
            # Render dropdown overlay if open
            if ($this.IsDropDownOpen) {
                $this._RenderDropdownOverlay()
            }
            
            Write-Verbose "ComboBoxComponent '$($this.Name)': Rendered successfully"
        }
        catch {
            Write-Error "ComboBoxComponent '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    hidden [void] _RenderDropdownOverlay() {
        try {
            # Get theme colors
            $bgColor = Get-ThemeColor 'input.background' -Fallback (Get-ThemeColor 'Background')
            $borderColor = Get-ThemeColor 'input.border.focus' -Fallback (Get-ThemeColor 'Accent')
            $fgColor = Get-ThemeColor 'input.foreground' -Fallback (Get-ThemeColor 'Foreground')
            $selectionBg = Get-ThemeColor 'input.selection' -Fallback (Get-ThemeColor 'Selection')
            $selectionFg = Get-ThemeColor 'input.selection.foreground' -Fallback (Get-ThemeColor 'Background')
            
            $dropdownHeight = [Math]::Min($this.MaxDropDownHeight, ($this._filteredItems.Count + 2))
            
            # Create or resize dropdown buffer
            if (-not $this._dropdownBuffer -or $this._dropdownBuffer.Height -ne $dropdownHeight -or $this._dropdownBuffer.Width -ne $this.Width) {
                $this._dropdownBuffer = [TuiBuffer]::new($this.Width, $dropdownHeight, "$($this.Name).Dropdown")
            }
            
            # Clear and draw dropdown
            $this._dropdownBuffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            Write-TuiBox -Buffer $this._dropdownBuffer -X 0 -Y 0 -Width $this.Width -Height $dropdownHeight -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
            
            # Draw items
            $visibleItems = [Math]::Min($this.MaxDropDownHeight - 2, $this._filteredItems.Count)
            for ($i = 0; $i -lt $visibleItems; $i++) {
                $itemIndex = $i + $this.ScrollOffset
                if ($itemIndex -ge $this._filteredItems.Count) { break }
                
                $item = $this._filteredItems[$itemIndex]
                $isSelected = ($itemIndex -eq $this.SelectedIndex)
                
                $itemBg = if ($isSelected) { $selectionBg } else { $bgColor }
                $itemFg = if ($isSelected) { $selectionFg } else { $fgColor }
                
                # Draw selection background
                $highlightText = ' ' * ($this.Width - 2)
                Write-TuiText -Buffer $this._dropdownBuffer -X 1 -Y ($i + 1) -Text $highlightText -ForegroundColor $itemFg -BackgroundColor $itemBg
                
                # Draw item text
                $itemText = " $item"
                $maxItemWidth = $this.Width - 4
                if ($itemText.Length -gt $maxItemWidth) {
                    $itemText = $itemText.Substring(0, $maxItemWidth - 3) + "..."
                }
                Write-TuiText -Buffer $this._dropdownBuffer -X 2 -Y ($i + 1) -Text $itemText -ForegroundColor $itemFg -BackgroundColor $itemBg
            }
            
            # Add dropdown to overlay stack for rendering
            # Note: This would need integration with the TUI engine's overlay system
            # For now, we'll blend it directly onto the current screen
            
            Write-Verbose "ComboBoxComponent '$($this.Name)': Dropdown overlay rendered"
        }
        catch {
            Write-Error "ComboBoxComponent '$($this.Name)': Error rendering dropdown: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        try {
            $handled = $true
            $originalSelection = $this.SelectedItem
            
            if ($this.IsDropDownOpen) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) {
                        $this.IsDropDownOpen = $false
                        $this.SearchText = ""
                        $this._UpdateFilteredItems()
                    }
                    ([ConsoleKey]::Enter) {
                        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._filteredItems.Count) {
                            $this.SelectedItem = $this._filteredItems[$this.SelectedIndex]
                            $this.DisplayText = $this.SelectedItem
                            $this.IsDropDownOpen = $false
                            $this.SearchText = ""
                            $this._UpdateFilteredItems()
                        }
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($this.SelectedIndex -gt 0) {
                            $this.SelectedIndex--
                            $this._EnsureSelectedVisible()
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($this.SelectedIndex -lt ($this._filteredItems.Count - 1)) {
                            $this.SelectedIndex++
                            $this._EnsureSelectedVisible()
                        }
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($this.AllowSearch -and $this.SearchText.Length -gt 0) {
                            $this.SearchText = $this.SearchText.Substring(0, $this.SearchText.Length - 1)
                            $this._UpdateFilteredItems()
                        }
                    }
                    default {
                        if ($this.AllowSearch -and $key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                            $this.SearchText += $key.KeyChar
                            $this._UpdateFilteredItems()
                        } else {
                            $handled = $false
                        }
                    }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::Enter) {
                        $this.IsDropDownOpen = $true
                        $this.SelectedIndex = 0
                        $this._UpdateFilteredItems()
                    }
                    ([ConsoleKey]::Spacebar) {
                        $this.IsDropDownOpen = $true
                        $this.SelectedIndex = 0
                        $this._UpdateFilteredItems()
                    }
                    ([ConsoleKey]::DownArrow) {
                        $this.IsDropDownOpen = $true
                        $this.SelectedIndex = 0
                        $this._UpdateFilteredItems()
                    }
                    default {
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                # Fire selection changed event
                if ($this.SelectedItem -ne $originalSelection -and $this.OnSelectionChanged) {
                    Invoke-WithErrorHandling -Component "$($this.Name).OnSelectionChanged" -ScriptBlock {
                        & $this.OnSelectionChanged -SelectedItem $this.SelectedItem
                    }
                }
                
                $this.RequestRedraw()
            }
            
            return $handled
        }
        catch {
            Write-Error "ComboBoxComponent '$($this.Name)': Error handling input: $($_.Exception.Message)"
            return $false
        }
    }

    hidden [void] _UpdateFilteredItems() {
        if ([string]::IsNullOrWhiteSpace($this.SearchText)) {
            $this._filteredItems = $this.Items
        } else {
            $this._filteredItems = $this.Items | Where-Object { $_ -like "*$($this.SearchText)*" }
        }
        
        # Reset selection if current selection is no longer valid
        if ($this.SelectedIndex -ge $this._filteredItems.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
        }
        
        $this.ScrollOffset = 0
    }

    hidden [void] _EnsureSelectedVisible() {
        $visibleItems = $this.MaxDropDownHeight - 2
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        }
        elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $visibleItems)) {
            $this.ScrollOffset = $this.SelectedIndex - $visibleItems + 1
        }
    }

    [void] SetItems([string[]]$items) {
        $this.Items = $items
        $this._filteredItems = $items
        $this.SelectedIndex = -1
        $this.SelectedItem = ""
        $this.DisplayText = ""
        $this.RequestRedraw()
    }

    [string] ToString() {
        return "ComboBoxComponent(Name='$($this.Name)', Items=$($this.Items.Count), Selected='$($this.SelectedItem)', Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

class DateInputComponent : UIElement {
    [DateTime]$Value = (Get-Date)
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [string]$DateFormat = "yyyy-MM-dd"
    [string]$TextValue = ""
    [int]$CursorPosition = 0
    [bool]$ShowCalendar = $false
    [scriptblock]$OnChange

    DateInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.TextValue = $this.Value.ToString($this.DateFormat)
        Write-Verbose "DateInputComponent: Constructor called for '$($this.Name)'"
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = Get-ThemeColor 'input.background' -Fallback (Get-ThemeColor 'Background')
            $borderColor = if ($this.IsFocused) { 
                Get-ThemeColor 'input.border.focus' -Fallback (Get-ThemeColor 'Accent') 
            } else { 
                Get-ThemeColor 'input.border.normal' -Fallback (Get-ThemeColor 'Border') 
            }
            $fgColor = Get-ThemeColor 'input.foreground' -Fallback (Get-ThemeColor 'Foreground')
            $cursorColor = Get-ThemeColor 'input.cursor' -Fallback (Get-ThemeColor 'Accent')
            
            # Clear buffer and draw border
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -BorderStyle "Single" -BorderColor $borderColor -BackgroundColor $bgColor
            
            # Draw date value
            Write-TuiText -Buffer $this._private_buffer -X 2 -Y 1 -Text $this.TextValue -ForegroundColor $fgColor -BackgroundColor $bgColor
            
            # Draw calendar icon
            $iconColor = if ($this.IsFocused) { $borderColor } else { (Get-ThemeColor 'Subtle') }
            Write-TuiText -Buffer $this._private_buffer -X ($this.Width - 3) -Y 1 -Text "" -ForegroundColor $iconColor -BackgroundColor $bgColor
            
            # Draw cursor
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt ($this.Width - 4)) {
                    $cell = $this._private_buffer.GetCell($cursorX, 1)
                    if ($null -ne $cell) {
                        $cell.BackgroundColor = $cursorColor
                        $cell.ForegroundColor = $bgColor
                        $this._private_buffer.SetCell($cursorX, 1, $cell)
                    }
                }
            }
            
            Write-Verbose "DateInputComponent '$($this.Name)': Rendered successfully"
        }
        catch {
            Write-Error "DateInputComponent '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        try {
            $handled = $true
            $originalValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::Enter) {
                    if ($this._ValidateAndSetDate($this.TextValue)) {
                        # Date was valid and set
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.CursorPosition++
                    }
                }
                ([ConsoleKey]::Home) {
                    $this.CursorPosition = 0
                }
                ([ConsoleKey]::End) {
                    $this.CursorPosition = $this.TextValue.Length
                }
                default {
                    if ($key.KeyChar -and $this._IsValidDateChar($key.KeyChar)) {
                        $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                # Fire change event if value changed
                if ($this.Value -ne $originalValue -and $this.OnChange) {
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewValue $this.Value
                    }
                }
                
                $this.RequestRedraw()
            }
            
            return $handled
        }
        catch {
            Write-Error "DateInputComponent '$($this.Name)': Error handling input: $($_.Exception.Message)"
            return $false
        }
    }

    hidden [bool] _IsValidDateChar([char]$char) {
        return [char]::IsDigit($char) -or $char -eq '-' -or $char -eq '/' -or $char -eq '.'
    }

    hidden [bool] _ValidateAndSetDate([string]$text) {
        try {
            $date = [DateTime]::ParseExact($text, $this.DateFormat, $null)
            if ($date -ge $this.MinDate -and $date -le $this.MaxDate) {
                $this.Value = $date
                $this._UpdateTextValue()
                return $true
            }
        }
        catch {
            # Invalid format, revert to current value
            $this._UpdateTextValue()
        }
        return $false
    }

    hidden [void] _UpdateTextValue() {
        $this.TextValue = $this.Value.ToString($this.DateFormat)
        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.TextValue.Length)
    }

    [string] ToString() {
        return "DateInputComponent(Name='$($this.Name)', Value=$($this.Value), Pos=($($this.X),$($this.Y)), Size=$($this.Width)x$($this.Height))"
    }
}

class NavigationMenu : UIElement {
    [System.Collections.Generic.List[NavigationItem]]$Items
    [ValidateSet("Vertical", "Horizontal")][string]$Orientation = "Vertical"
    [string]$Separator = " | "
    [int]$SelectedIndex = 0

    NavigationMenu([string]$name) : base($name) {
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 10
        Write-Verbose "NavigationMenu: Constructor called for '$($this.Name)'"
    }

    [void] AddItem([NavigationItem]$item) {
        try {
            if (-not $item) {
                throw [System.ArgumentNullException]::new("item")
            }
            
            # Check for duplicate keys
            $existingItem = $this.Items | Where-Object { $_.Key -eq $item.Key }
            if ($existingItem) {
                throw [System.InvalidOperationException]::new("Item with key '$($item.Key)' already exists")
            }
            
            $this.Items.Add($item)
            $this.RequestRedraw()
            Write-Verbose "NavigationMenu '$($this.Name)': Added item '$($item.Key)'"
        }
        catch {
            Write-Error "NavigationMenu '$($this.Name)': Error adding item: $($_.Exception.Message)"
            throw
        }
    }

    [void] AddSeparator() {
        try {
            $separatorItem = [NavigationItem]::new("-", "---", {})
            $separatorItem.Enabled = $false
            $this.Items.Add($separatorItem)
            $this.RequestRedraw()
            Write-Verbose "NavigationMenu '$($this.Name)': Added separator"
        }
        catch {
            Write-Error "NavigationMenu '$($this.Name)': Error adding separator: $($_.Exception.Message)"
        }
    }

    [void] RemoveItem([string]$key) {
        try {
            if ([string]::IsNullOrWhiteSpace($key)) { return }
            $item = $this.Items | Where-Object { $_.Key -eq $key.ToUpper() }
            if ($item) {
                $this.Items.Remove($item)
                
                # Adjust selected index if needed
                if ($this.SelectedIndex -ge $this.Items.Count) {
                    $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
                }
                
                $this.RequestRedraw()
                Write-Verbose "NavigationMenu '$($this.Name)': Removed item '$key'"
            }
        }
        catch {
            Write-Error "NavigationMenu '$($this.Name)': Error removing item '$key': $($_.Exception.Message)"
        }
    }

    [NavigationItem] GetItem([string]$key) {
        if ([string]::IsNullOrWhiteSpace($key)) { return $null }
        return $this.Items | Where-Object { $_.Key -eq $key.ToUpper() } | Select-Object -First 1
    }

    [void] ExecuteSelectedItem() {
        try {
            $visibleItems = @($this.Items | Where-Object { $_.Visible })
            if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $visibleItems.Count) {
                $selectedItem = $visibleItems[$this.SelectedIndex]
                if ($selectedItem.Enabled -and $selectedItem.Key -ne "-") {
                    $selectedItem.Execute()
                }
            }
        }
        catch {
            Write-Error "NavigationMenu '$($this.Name)': Error executing selected item: $($_.Exception.Message)"
        }
    }

    [void] ExecuteByKey([string]$key) {
        try {
            if ([string]::IsNullOrWhiteSpace($key)) { return }
            $item = $this.GetItem($key)
            if ($item -and $item.Enabled -and $item.Visible) {
                $item.Execute()
            }
        }
        catch {
            Write-Error "NavigationMenu '$($this.Name)': Error executing item by key '$key': $($_.Exception.Message)"
        }
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = Get-ThemeColor 'Background'
            $fgColor = Get-ThemeColor 'Foreground'
            
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            $visibleItems = @($this.Items | Where-Object { $_.Visible })
            if ($visibleItems.Count -eq 0) {
                Write-Verbose "NavigationMenu '$($this.Name)': No visible items to render"
                return
            }

            # Ensure selected index is valid
            if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $visibleItems.Count) {
                $this.SelectedIndex = 0
            }

            if ($this.Orientation -eq "Horizontal") {
                $this._RenderHorizontal($visibleItems)
            } else {
                $this._RenderVertical($visibleItems)
            }
            
            Write-Verbose "NavigationMenu '$($this.Name)': Rendered $($visibleItems.Count) items"
        }
        catch {
            Write-Error "NavigationMenu '$($this.Name)': Error during render: $($_.Exception.Message)"
        }
    }

    hidden [void] _RenderHorizontal([NavigationItem[]]$items) {
        try {
            $currentX = 0
            $maxY = 0
            
            for ($i = 0; $i -lt $items.Count; $i++) {
                if ($currentX -ge $this.Width) { break }
                
                $item = $items[$i]
                $isSelected = ($i -eq $this.SelectedIndex)
                $isFocused = ($isSelected -and $this.IsFocused)
                
                # Get colors based on state
                $itemFg = if (-not $item.Enabled) {
                    Get-ThemeColor 'menu.item.disabled' -Fallback (Get-ThemeColor 'Subtle')
                } elseif ($isFocused) {
                    Get-ThemeColor 'menu.item.foreground.focus' -Fallback (Get-ThemeColor 'Background')
                } else {
                    Get-ThemeColor 'menu.item.foreground.normal' -Fallback (Get-ThemeColor 'Foreground')
                }
                
                $itemBg = if ($isFocused) {
                    Get-ThemeColor 'menu.item.background.focus' -Fallback (Get-ThemeColor 'Accent')
                } else {
                    Get-ThemeColor 'Background'
                }
                
                # Format item text
                $text = if ($item.Key -eq "-") {
                    "---"
                } else {
                    "[$($item.Key)] $($item.Label)"
                }
                
                # Draw item
                $textLength = [Math]::Min($text.Length, $this.Width - $currentX)
                $displayText = $text.Substring(0, $textLength)
                
                Write-TuiText -Buffer $this._private_buffer -X $currentX -Y 0 -Text $displayText -ForegroundColor $itemFg -BackgroundColor $itemBg
                $currentX += $textLength
                
                # Add separator if not last item and space available
                if ($i -lt ($items.Count - 1) -and ($currentX + $this.Separator.Length) -lt $this.Width) {
                    $separatorColor = Get-ThemeColor 'menu.item.separator' -Fallback (Get-ThemeColor 'Subtle')
                    Write-TuiText -Buffer $this._private_buffer -X $currentX -Y 0 -Text $this.Separator -ForegroundColor $separatorColor -BackgroundColor (Get-ThemeColor 'Background')
                    $currentX += $this.Separator.Length
                }
            }
        }
        catch {
            Write-Error "NavigationMenu '$($this.Name)': Error rendering horizontal layout: $($_.Exception.Message)"
        }
    }

    hidden [void] _RenderVertical([NavigationItem[]]$items) {
        try {
            $maxItems = [Math]::Min($items.Count, $this.Height)
            
            for ($i = 0; $i -lt $maxItems; $i++) {
                $item = $items[$i]
                $isSelected = ($i -eq $this.SelectedIndex)
                $isFocused = ($isSelected -and $this.IsFocused)
                
                # Handle separators
                if ($item.Key -eq "-") {
                    $separatorColor = Get-ThemeColor 'menu.item.separator' -Fallback (Get-ThemeColor 'Subtle')
                    $line = '' * $this.Width
                    Write-TuiText -Buffer $this._private_buffer -X 0 -Y $i -Text $line -ForegroundColor $separatorColor -BackgroundColor (Get-ThemeColor 'Background')
                    continue
                }
                
                # Get colors based on state
                $itemBg = if ($isFocused) {
                    Get-ThemeColor 'menu.item.background.focus' -Fallback (Get-ThemeColor 'Accent')
                } else {
                    Get-ThemeColor 'Background'
                }
                
                $prefixFg = if ($isFocused) {
                    Get-ThemeColor 'menu.item.prefix.focus' -Fallback (Get-ThemeColor 'Background')
                } else {
                    Get-ThemeColor 'menu.item.prefix.normal' -Fallback (Get-ThemeColor 'Accent')
                }
                
                $keyFg = if (-not $item.Enabled) {
                    Get-ThemeColor 'menu.item.disabled' -Fallback (Get-ThemeColor 'Subtle')
                } elseif ($isFocused) {
                    Get-ThemeColor 'menu.item.hotkey.focus' -Fallback (Get-ThemeColor 'Background')
                } else {
                    Get-ThemeColor 'menu.item.hotkey.normal' -Fallback (Get-ThemeColor 'Accent')
                }
                
                $labelFg = if (-not $item.Enabled) {
                    Get-ThemeColor 'menu.item.disabled' -Fallback (Get-ThemeColor 'Subtle')
                } elseif ($isFocused) {
                    Get-ThemeColor 'menu.item.foreground.focus' -Fallback (Get-ThemeColor 'Background')
                } else {
                    Get-ThemeColor 'menu.item.foreground.normal' -Fallback (Get-ThemeColor 'Foreground')
                }
                
                # Draw selection highlight background
                $highlightText = ' ' * $this.Width
                Write-TuiText -Buffer $this._private_buffer -X 0 -Y $i -Text $highlightText -ForegroundColor $labelFg -BackgroundColor $itemBg
                
                # Draw selection prefix
                $prefix = if ($isSelected) { "> " } else { "  " }
                Write-TuiText -Buffer $this._private_buffer -X 0 -Y $i -Text $prefix -ForegroundColor $prefixFg -BackgroundColor $itemBg
                
                # Draw hotkey
                $keyText = "[$($item.Key)]"
                Write-TuiText -Buffer $this._private_buffer -X 2 -Y $i -Text $keyText -ForegroundColor $keyFg -BackgroundColor $itemBg
                
                # Draw label
                $labelX = 2 + $keyText.Length + 1
                $maxLabelWidth = $this.Width - $labelX
                $labelText = $item.Label
                if ($labelText.Length -gt $maxLabelWidth) {
                    $labelText = $labelText.Substring(0, $maxLabelWidth - 3) + "..."
                }
                Write-TuiText -Buffer $this._private_buffer -X $labelX -Y $i -Text $labelText -ForegroundColor $labelFg -BackgroundColor $itemBg
            }
        }
        catch {
            Write-Error "NavigationMenu '$($this.Name)': Error rendering vertical layout: $($_.Exception.Message)"
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($null -eq $keyInfo) { return $false }
        try {
            $visibleItems = @($this.Items | Where-Object { $_.Visible })
            if ($visibleItems.Count -eq 0) {
                return $false
            }
            
            # Handle direct hotkey access
            $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
            $hotkeyItem = $visibleItems | Where-Object { $_.Key -eq $keyChar -and $_.Enabled }
            if ($hotkeyItem) {
                $hotkeyItem.Execute()
                return $true
            }
            
            # Handle navigation keys
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) {
                    $this.ExecuteSelectedItem()
                    return $true
                }
                ([ConsoleKey]::UpArrow) {
                    if ($this.Orientation -eq "Vertical") {
                        $this._MovePrevious($visibleItems)
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.Orientation -eq "Vertical") {
                        $this._MoveNext($visibleItems)
                        return $true
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.Orientation -eq "Horizontal") {
                        $this._MovePrevious($visibleItems)
                        return $true
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.Orientation -eq "Horizontal") {
                        $this._MoveNext($visibleItems)
                        return $true
                    }
                }
                ([ConsoleKey]::Home) {
                    $this.SelectedIndex = 0
                    $this.RequestRedraw()
                    return $true
                }
                ([ConsoleKey]::End) {
                    $this.SelectedIndex = $visibleItems.Count - 1
                    $this.RequestRedraw()
                    return $true
                }
            }
            
            return $false
        }
        catch {
            Write-Error "NavigationMenu '$($this.Name)': Error handling input: $($_.Exception.Message)"
            return $false
        }
    }

    hidden [void] _MovePrevious([NavigationItem[]]$items) {
        do {
            $this.SelectedIndex = if ($this.SelectedIndex -le 0) { $items.Count - 1 } else { $this.SelectedIndex - 1 }
        } while ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $items.Count -and (-not $items[$this.SelectedIndex].Enabled -or $items[$this.SelectedIndex].Key -eq "-"))
        
        $this.RequestRedraw()
    }

    hidden [void] _MoveNext([NavigationItem[]]$items) {
        do {
            $this.SelectedIndex = if ($this.SelectedIndex -ge ($items.Count - 1)) { 0 } else { $this.SelectedIndex + 1 }
        } while ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $items.Count -and (-not $items[$this.SelectedIndex].Enabled -or $items[$this.SelectedIndex].Key -eq "-"))
        
        $this.RequestRedraw()
    }

    [void] OnFocus() {
        ([UIElement]$this).OnFocus()
        $this.RequestRedraw()
        Write-Verbose "NavigationMenu '$($this.Name)': Gained focus"
    }

    [void] OnBlur() {
        ([UIElement]$this).OnBlur()
        $this.RequestRedraw()
        Write-Verbose "NavigationMenu '$($this.Name)': Lost focus"
    }

    [string] ToString() {
        return "NavigationMenu(Name='$($this.Name)', Items=$($this.Items.Count), Selected=$($this.SelectedIndex), Orientation='$($this.Orientation)')"
    }
}

#endregion


