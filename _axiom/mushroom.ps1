# mushroom.ps1 - The Monolith Decomposer & Recomposer Toolkit (v6.5 - Robust Block Removal)

[CmdletBinding()]
param(
    [Parameter(Position = 0)]
    [string]$Command = 'recompose',
    
    [Parameter(Position = 1)]
    [string]$Path,
    
    [Parameter(Position = 2)]
    [string]$Output = "AxiomPhoenix.ps1"
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

#==============================================================================
# FUNCTION DEFINITIONS
#==============================================================================

function Write-Status {
    param($Message, $Color = 'Cyan')
    Write-Host "ðŸ„ $Message" -ForegroundColor $Color
}

function Invoke-Recompose {
    param($SourceDir, $OutputPath)
    Write-Status "Recomposing project from '$SourceDir' into '$OutputPath'..."
    
    $SourceFileOrder = @(
        'modules\exceptions\exceptions.psm1',
        'modules\logger\logger.psm1',
        'modules\event-system\event-system.psm1',
        'modules\models\models.psm1',
        'components\tui-primitives\tui-primitives.psm1',
        'modules\theme-manager\theme-manager.psm1',
        'components\ui-classes\ui-classes.psm1',
        'layout\panels-class\panels-class.psm1',
        'services\service-container\service-container.psm1',
        'services\action-service\action-service.psm1',
        'services\keybinding-service-class\keybinding-service-class.psm1',
        'services\navigation-service-class\navigation-service-class.psm1',
        'components\tui-components\tui-components.psm1',
        'components\advanced-data-components\advanced-data-components.psm1',
        'components\advanced-input-components\advanced-input-components.psm1',
        'modules\dialog-system-class\dialog-system-class.psm1',
        'modules\panic-handler\panic-handler.psm1',
        'services\keybinding-service\keybinding-service.psm1',
        'services\navigation-service\navigation-service.psm1',
        'modules\tui-framework\tui-framework.psm1',
        'components\command-palette\command-palette.psm1',
        'modules\data-manager\data-manager.psm1',
        'screens\dashboard-screen\dashboard-screen.psm1',
        'screens\task-list-screen\task-list-screen.psm1',
        'modules\tui-engine\tui-engine.psm1'
    )
    
    $mainLogicSource = Join-Path $SourceDir 'run.ps1'
    if (-not (Test-Path $mainLogicSource)) { throw "'run.ps1' not found in source directory."}
    
    $runnerContent = Get-Content -Path $mainLogicSource -Raw
    $paramBlock = if ($runnerContent -match '(?msi)(^param\s*\(.*?\))') { $matches[0] } else { '' }
    $mainLogic = if ($runnerContent -match '(?msi)(# --- MAIN EXECUTION LOGIC ---.*)') { $matches[0] } else { $runnerContent }

    Write-Status "Scanning modules for using statements and content..."
    $allUsingStatements = [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase)
    $allCleanedContent = [System.Text.StringBuilder]::new()

    foreach ($path in $SourceFileOrder) {
        $fullPath = Join-Path $SourceDir $path
        if (-not (Test-Path $fullPath)) { Write-Warning "Source file '$fullPath' is missing. Skipping."; continue }
        
        if ($fullPath -eq $MyInvocation.MyCommand.Definition) {
            Write-Warning "Skipping '$path' because it is the build script itself."
            continue
        }
        
        Write-Status "  -> Processing: $path" 'Gray'
        $fileContent = Get-Content -Path $fullPath -Raw
        
        $usingMatches = [regex]::Matches($fileContent, '(?im)^using\s+namespace\s+.*')
        foreach ($match in $usingMatches) {
            [void]$allUsingStatements.Add($match.Value.Trim())
        }
        
        # **THE FIX**: This regex handles single-line and multi-line Export-ModuleMember commands.
        # (?s) is the "single line" flag, which makes '.' match newlines.
        # It finds 'Export-ModuleMember' and matches everything until it finds a line that does NOT end with a backtick (`).
        $exportBlockRegex = '(?is)Export-ModuleMember.*?(?<!`)(\r?\n)'
        
        $cleaned = $fileContent -replace '(?im)^using\s+(module|namespace)\s+.*' -replace $exportBlockRegex

        [void]$allCleanedContent.AppendLine("####$path")
        [void]$allCleanedContent.AppendLine($cleaned.Trim())
        [void]$allCleanedContent.AppendLine()
    }
    
    Write-Status "Assembling the monolith..."
    $finalScript = [System.Text.StringBuilder]::new()

    [void]$finalScript.AppendLine("# ==============================================================================")
    [void]$finalScript.AppendLine("# Axiom-Phoenix v5.0 - MONOLITH SCRIPT")
    [void]$finalScript.AppendLine("# Auto-generated by mushroom.ps1 on $(Get-Date)")
    [void]$finalScript.AppendLine("# ==============================================================================")
    [void]$finalScript.AppendLine()
    
    [void]$finalScript.AppendLine("# --- Global Using Statements ---")
    foreach ($statement in $allUsingStatements | Sort-Object) {
        [void]$finalScript.AppendLine($statement)
    }
    [void]$finalScript.AppendLine("# --- End Using Statements ---")
    [void]$finalScript.AppendLine()
    
    [void]$finalScript.AppendLine($paramBlock)
    [void]$finalScript.AppendLine()
    
    [void]$finalScript.Append($allCleanedContent.ToString())
    
    [void]$finalScript.AppendLine($mainLogic.Trim())

    Set-Content -Path $OutputPath -Value $finalScript.ToString() -Encoding UTF8
    Write-Status "Recomposition complete! New monolith is at '$OutputPath'" "Green"
}

function Show-Help {
    Write-Host @"
Mushroom - The Monolith Decomposer & Recomposer Toolkit (v6.5)
(Help message...)
"@
}

#==============================================================================
# MAIN EXECUTION BLOCK
#==============================================================================
try {
    switch ($Command.ToLower()) {
        'recompose' {
            $sourceDir = if ($Path) { (Resolve-Path $Path).Path } else { $PSScriptRoot }
            Invoke-Recompose -SourceDir $sourceDir -OutputPath $Output
        }
        default { Show-Help }
    }
} catch {
    Write-Host "`nðŸ„ ERROR: $($_.Exception.Message)" -ForegroundColor Red
    if ($_.ScriptStackTrace) {
        Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
    }
    exit 1
}