####\allbaseclasses.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#region TuiAnsiHelper - ANSI Code Generation with Truecolor Support
class TuiAnsiHelper {
    hidden static [System.Collections.Concurrent.ConcurrentDictionary[string, string]] $_fgCache = [System.Collections.Concurrent.ConcurrentDictionary[string, string]]::new()
    hidden static [System.Collections.Concurrent.ConcurrentDictionary[string, string]] $_bgCache = [System.Collections.Concurrent.ConcurrentDictionary[string, string]]::new()

    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int[]] ParseHexColor([string]$hexColor) {
        if ([string]::IsNullOrWhiteSpace($hexColor) -or -not $hexColor.StartsWith("#")) { return $null }
        $hex = $hexColor.Substring(1)
        if ($hex.Length -eq 3) { $hex = "$($hex[0])$($hex[0])$($hex[1])$($hex[1])$($hex[2])$($hex[2])" }
        if ($hex.Length -ne 6) { return $null }
        try {
            $r = [System.Convert]::ToInt32($hex.Substring(0, 2), 16)
            $g = [System.Convert]::ToInt32($hex.Substring(2, 2), 16)
            $b = [System.Convert]::ToInt32($hex.Substring(4, 2), 16)
            return @($r, $g, $b)
        } catch { return $null }
    }

    static [string] GetForegroundCode($color) {
        if ($color -is [ConsoleColor]) {
            return "`e[$([TuiAnsiHelper]::ColorMap[$color.ToString()] ?? 37)m"
        } elseif ($color -is [string] -and $color.StartsWith("#")) {
            return [TuiAnsiHelper]::GetForegroundSequence($color)
        } else {
            return "`e[37m" 
        }
    }

    static [string] GetBackgroundCode($color) {
        if ($color -is [ConsoleColor]) {
            $code = ([TuiAnsiHelper]::ColorMap[$color.ToString()] ?? 30) + 10
            return "`e[${code}m"
        } elseif ($color -is [string] -and $color.StartsWith("#")) {
            return [TuiAnsiHelper]::GetBackgroundSequence($color)
        } else {
            return "`e[40m" 
        }
    }

    static [string] GetForegroundSequence([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor)) { return "" }
        if ([TuiAnsiHelper]::_fgCache.ContainsKey($hexColor)) { 
            return [TuiAnsiHelper]::_fgCache[$hexColor] 
        }
        $rgb = [TuiAnsiHelper]::ParseHexColor($hexColor)
        if (-not $rgb) { return "" }
        $sequence = "`e[38;2;$($rgb[0]);$($rgb[1]);$($rgb[2])m"
        [TuiAnsiHelper]::_fgCache[$hexColor] = $sequence
        return $sequence
    }
    
    static [string] GetBackgroundSequence([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor)) { return "" }
        if ([TuiAnsiHelper]::_bgCache.ContainsKey($hexColor)) { 
            return [TuiAnsiHelper]::_bgCache[$hexColor] 
        }
        $rgb = [TuiAnsiHelper]::ParseHexColor($hexColor)
        if (-not $rgb) { return "" }
        $sequence = "`e[48;2;$($rgb[0]);$($rgb[1]);$($rgb[2])m"
        [TuiAnsiHelper]::_bgCache[$hexColor] = $sequence
        return $sequence
    }
    
    static [string] Reset() { return "`e[0m" }
    static [string] Bold() { return "`e[1m" }
    static [string] Underline() { return "`e[4m" }
    static [string] Italic() { return "`e[3m" }
}
#endregion

#region TuiCell Class - Core Compositor Unit with Truecolor Support
class TuiCell {
    [char] $Char = ' '
    $ForegroundColor = [ConsoleColor]::White
    $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = "" 
    [int] $ZIndex = 0        
    [object] $Metadata = $null 

    TuiCell() { }
    TuiCell([char]$char) { $this.Char = $char }
    TuiCell([char]$char, $fg, $bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }
    TuiCell([char]$char, $fg, $bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }
    TuiCell([object]$other) {
        $this.Char = $other.Char
        $this.ForegroundColor = $other.ForegroundColor
        $this.BackgroundColor = $other.BackgroundColor
        $this.Bold = $other.Bold
        $this.Underline = $other.Underline
        $this.Italic = $other.Italic
        $this.StyleFlags = $other.StyleFlags
        $this.ZIndex = $other.ZIndex
        $this.Metadata = $other.Metadata
    }

    [TuiCell] WithStyle($fg, $bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    [TuiCell] BlendWith([object]$other) {
        if ($null -eq $other) { return $this }
        
        if ($other.ZIndex -gt $this.ZIndex) { 
            return [TuiCell]::new($other)
        }
        
        if ($other.ZIndex -eq $this.ZIndex) {
            if ($other.Char -ne ' ' -or $other.Bold -or $other.Underline -or $other.Italic) {
                return [TuiCell]::new($other)
            }
            if ($other.BackgroundColor -ne $this.BackgroundColor) {
                return [TuiCell]::new($other)
            }
        }
        
        return $this
    }

    [bool] DiffersFrom([object]$other) {
        if ($null -eq $other) { return $true }
        
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic -or
                $this.ZIndex -ne $other.ZIndex)
    }

    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append($fgCode).Append($bgCode)
        if ($this.Bold) { [void]$sb.Append([TuiAnsiHelper]::Bold()) }
        if ($this.Underline) { [void]$sb.Append([TuiAnsiHelper]::Underline()) }
        if ($this.Italic) { [void]$sb.Append([TuiAnsiHelper]::Italic()) }
        [void]$sb.Append($this.Char)
        return $sb.ToString()
    }

    [hashtable] ToLegacyFormat() {
        return @{ Char = $this.Char; FG = $this.ForegroundColor; BG = $this.BackgroundColor }
    }
    
    [string] ToString() {
        return "TuiCell(Char='$($this.Char)', FG='$($this.ForegroundColor)', BG='$($this.BackgroundColor)', Bold=$($this.Bold), Underline=$($this.Underline), Italic=$($this.Italic), ZIndex=$($this.ZIndex))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    [TuiCell[,]] $Cells       
    [int] $Width             
    [int] $Height            
    [string] $Name            
    [bool] $IsDirty = $true  

    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.Cells = New-Object 'TuiCell[,]' $height, $width
        $this.Clear()
        # Write-Verbose "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
    }

    [void] Clear() { $this.Clear([TuiCell]::new()) }

    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell) 
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "TuiBuffer '$($this.Name)' cleared with specified cell."
    }

    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) { return [TuiCell]::new() }
        return $this.Cells[$y, $x]
    }

    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        } else {
            # Write-Warning "Attempted to set cell out of bounds in TuiBuffer '$($this.Name)': ($x, $y) is outside 0..$($this.Width-1), 0..$($this.Height-1). Cell: '$($cell.Char)'."
        }
    }

    [void] WriteString([int]$x, [int]$y, [string]$text, $fg, $bg) {
        if ($y -lt 0 -or $y -ge $this.Height) {
            # Write-Warning "Skipping WriteString: Y coordinate ($y) out of bounds for buffer '$($this.Name)' (0..$($this.Height-1)). Text: '$text'."
            return
        }
        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break } 
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
        $this.IsDirty = $true
        # Write-Verbose "WriteString: Wrote '$text' to buffer '$($this.Name)' at ($x, $y)."
    }

    [void] BlendBuffer([object]$other, [int]$offsetX, [int]$offsetY) {
        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "BlendBuffer: Blended buffer '$($other.Name)' onto '$($this.Name)' at ($offsetX, $offsetY)."
    }

    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        # Write-Verbose "GetSubBuffer: Created sub-buffer '$($subBuffer.Name)' from '$($this.Name)' at ($x, $y) with dimensions $($width)x$($height)."
        return $subBuffer
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height
        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.Cells = New-Object 'TuiCell[,]' $newHeight, $newWidth
        $this.Clear()
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)
        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "TuiBuffer '$($this.Name)' resized from $($oldWidth)x$($oldHeight) to $($newWidth)x$($newHeight)."
    }

    [string] ToString() {
        return "TuiBuffer(Name='$($this.Name)', Width=$($this.Width), Height=$($this.Height), IsDirty=$($this.IsDirty))"
    }

    # Additional helper methods needed by rendering pipeline
    [void] DrawText([int]$x, [int]$y, [string]$text, $fg, $bg) {
        $this.WriteString($x, $y, $text, $fg, $bg)
    }
    
    [void] DrawBox([int]$x, [int]$y, [int]$width, [int]$height, $fg, $bg, [bool]$doubleLine = $false) {
        if ($doubleLine) {
            $topLeft = '╔'; $topRight = '╗'; $bottomLeft = '╚'; $bottomRight = '╝'
            $horizontal = '═'; $vertical = '║'
        } else {
            $topLeft = '┌'; $topRight = '┐'; $bottomLeft = '└'; $bottomRight = '┘'
            $horizontal = '─'; $vertical = '│'
        }
        
        # Top line
        $this.SetCell($x, $y, [TuiCell]::new($topLeft, $fg, $bg))
        for ($i = 1; $i -lt $width - 1; $i++) {
            $this.SetCell($x + $i, $y, [TuiCell]::new($horizontal, $fg, $bg))
        }
        $this.SetCell($x + $width - 1, $y, [TuiCell]::new($topRight, $fg, $bg))
        
        # Vertical lines
        for ($i = 1; $i -lt $height - 1; $i++) {
            $this.SetCell($x, $y + $i, [TuiCell]::new($vertical, $fg, $bg))
            $this.SetCell($x + $width - 1, $y + $i, [TuiCell]::new($vertical, $fg, $bg))
        }
        
        # Bottom line
        $this.SetCell($x, $y + $height - 1, [TuiCell]::new($bottomLeft, $fg, $bg))
        for ($i = 1; $i -lt $width - 1; $i++) {
            $this.SetCell($x + $i, $y + $height - 1, [TuiCell]::new($horizontal, $fg, $bg))
        }
        $this.SetCell($x + $width - 1, $y + $height - 1, [TuiCell]::new($bottomRight, $fg, $bg))
    }
    
    [void] FillRect([int]$x, [int]$y, [int]$width, [int]$height, [char]$char, $fg, $bg) {
        for ($py = $y; $py -lt $y + $height; $py++) {
            for ($px = $x; $px -lt $x + $width; $px++) {
                $this.SetCell($px, $py, [TuiCell]::new($char, $fg, $bg))
            }
        }
    }
    
    [TuiBuffer] Clone() {
        $clone = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name)_Clone")
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $clone.Cells[$y, $x] = [TuiCell]::new($this.Cells[$y, $x])
            }
        }
        return $clone
    }
}
#endregion

#region UIElement - Base Class for all UI Components
class UIElement {
    [string] $Name = "UIElement" 
    [int] $X = 0               
    [int] $Y = 0               
    [int] $Width = 10          
    [int] $Height = 3          
    [bool] $Visible = $true    
    [bool] $Enabled = $true    
    [bool] $IsFocusable = $false 
    [bool] $IsFocused = $false  
    [int] $TabIndex = 0        
    [int] $ZIndex = 0          
    [UIElement] $Parent = $null 
    [System.Collections.Generic.List[UIElement]] $Children 
    
    hidden [object] $_private_buffer = $null
    hidden [bool] $_needs_redraw = $true
    
    [hashtable] $Metadata = @{} 

    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        # Write-Verbose "UIElement 'Unnamed' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([string]$name) {
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        # Write-Verbose "UIElement '$($this.Name)' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "Unnamed.Buffer")
        # Write-Verbose "UIElement 'Unnamed' created at ($x, $y) with dimensions $($width)x$($height)."
    }

    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        return @{ X = $absX; Y = $absY }
    }

    [void] AddChild([object]$child) {
        try {
            if ($child -eq $this) { throw [System.ArgumentException]::new("Cannot add an element as its own child.") }
            if ($this.Children.Contains($child)) {
                Write-Warning "Child '$($child.Name)' is already a child of '$($this.Name)'. Skipping addition."
                return
            }
            if ($child.Parent -ne $null) {
                Write-Warning "Child '$($child.Name)' already has a parent ('$($child.Parent.Name)'). Consider removing it from its current parent first."
            }
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
            # Write-Verbose "Added child '$($child.Name)' to parent '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add child '$($child.Name)' to '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] RemoveChild([object]$child) {
        try {
            if ($this.Children.Remove($child)) {
                $child.Parent = $null
                $this.RequestRedraw()
                # Write-Verbose "Removed child '$($child.Name)' from parent '$($this.Name)'."
            } else {
                Write-Warning "Child '$($child.Name)' not found in parent '$($this.Name)' for removal. No action taken."
            }
        }
        catch {
            Write-Error "Failed to remove child '$($child.Name)' from '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
        # Write-Verbose "Redraw requested for '$($this.Name)'."
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        try {
            if ($this.Width -eq $newWidth -and $this.Height -eq $newHeight) {
                Write-Verbose "Resize: Component '$($this.Name)' already has target dimensions ($($newWidth)x$($newHeight)). No change."
                return
            }
            $this.Width = $newWidth
            $this.Height = $newHeight
            if ($null -ne $this._private_buffer) {
                $this._private_buffer.Resize($newWidth, $newHeight)
            } else {
                $this._private_buffer = [TuiBuffer]::new($newWidth, $newHeight, "$($this.Name).Buffer")
                # Write-Verbose "Re-initialized buffer for '$($this.Name)' due to null buffer."
            }
            $this.RequestRedraw()
            $this.OnResize($newWidth, $newHeight)
            # Write-Verbose "Component '$($this.Name)' resized to $($newWidth)x$($newHeight)."
        }
        catch {
            Write-Error "Failed to resize component '$($this.Name)' to $($newWidth)x$($newHeight): $($_.Exception.Message)"
            throw
        }
    }

    [void] Move([int]$newX, [int]$newY) {
        if ($this.X -eq $newX -and $this.Y -eq $newY) {
            # Write-Verbose "Move: Component '$($this.Name)' already at target position ($($newX), $($newY)). No change."
            return
        }
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
        # Write-Verbose "Component '$($this.Name)' moved to ($newX, $newY)."
    }

    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height)
    }

    [object] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $child.X, $y - $child.Y)) {
                return $child
            }
        }
        return $null
    }

    [void] OnRender() 
    {
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
        # Write-Verbose "OnRender called for '$($this.Name)': Default buffer clear."
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) 
    {
        # Write-Verbose "OnResize called for '$($this.Name)': No custom resize logic."
    }

    [void] OnMove([int]$newX, [int]$newY) 
    {
        # Write-Verbose "OnMove called for '$($this.Name)': No custom move logic."
    }

    [void] OnFocus() 
    { 
        # Write-Verbose "OnFocus called for '$($this.Name)'." 
    }
    
    [void] OnBlur() 
    { 
        # Write-Verbose "OnBlur called for '$($this.Name)'." 
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) 
    {
        # Write-Verbose "HandleInput called for '$($this.Name)': Key: $($keyInfo.Key)."
        return $false
    }

    [void] Render() 
    {
        if (-not $this.Visible) { 
            # Write-Verbose "Skipping Render for '$($this.Name)': Not visible."
            return 
        }
        $this._RenderContent() 
    }

    hidden [void] _RenderContent() 
    {
        if (-not $this.Visible) { return }
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
                $bufferWidth = [Math]::Max(1, $this.Width)
                $bufferHeight = [Math]::Max(1, $this.Height)
                $this._private_buffer = [TuiBuffer]::new($bufferWidth, $bufferHeight, "$($this.Name).Buffer")
                # Write-Verbose "Re-initialized buffer for '$($this.Name)' due to null or dimension mismatch ($($bufferWidth)x$($bufferHeight))."
            }
            $this.OnRender()
            $this._needs_redraw = $false
            # Write-Verbose "Rendered own content for '$($this.Name)'."
        }
        foreach ($child in $this.Children | Sort-Object ZIndex) { 
            if ($child.Visible) {
                $child.Render()
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                    # Write-Verbose "Blended child '$($child.Name)' onto '$($this.Name)' at ($($child.X), $($child.Y))."
                }
            }
        }
    }

    [object] GetBuffer() 
    { 
        return $this._private_buffer 
    }
    
    [string] ToString() 
    {
        return "$($this.GetType().Name)(Name='$($this.Name)', X=$($this.X), Y=$($this.Y), Width=$($this.Width), Height=$($this.Height), Visible=$($this.Visible))"
    }
}
#endregion

#region Component - A generic container component
class Component : UIElement {
    Component([string]$name) : base($name) {
        $this.Name = $name
        # Write-Verbose "Component '$($this.Name)' created."
    }

    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent()
        # Write-Verbose "_RenderContent called for Component '$($this.Name)' (delegating to base UIElement)."
    }

    [string] ToString() {
        return "Component(Name='$($this.Name)', Children=$($this.Children.Count))"
    }
}
#endregion

#region Screen - Top-level Container for Application Views
class Screen : UIElement {
    [hashtable]$Services
    [object]$ServiceContainer 
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[UIElement]] $Panels
    
    $LastFocusedComponent
    
    hidden [System.Collections.Generic.Dictionary[string, string]] $EventSubscriptions 

    Screen([string]$name, [hashtable]$services) : base($name) {
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        $this.ServiceContainer = $null
        # Write-Verbose "Screen '$($this.Name)' created with hashtable services."
    }

    Screen([string]$name, [object]$serviceContainer) : base($name) {
        $this.ServiceContainer = $serviceContainer
        $this.Services = [hashtable]::new()
        if ($this.ServiceContainer.PSObject.Methods['GetAllRegisteredServices'] -and $this.ServiceContainer.PSObject.Methods['GetService']) { 
            try {
                $registeredServices = $this.ServiceContainer.GetAllRegisteredServices()
                foreach ($service in $registeredServices) {
                    try {
                        $this.Services[$service.Name] = $this.ServiceContainer.GetService($service.Name)
                    } catch {
                        Write-Warning "Screen '$($this.Name)': Failed to resolve service '$($service.Name)' from container: $($_.Exception.Message)"
                    }
                }
                # Write-Verbose "Screen '$($this.Name)' populated Services hashtable from ServiceContainer."
            } catch {
                Write-Warning "Screen '$($this.Name)': Failed to enumerate services from container: $($_.Exception.Message)"
            }
        } else {
            Write-Warning "Screen '$($this.Name)' received a non-ServiceContainer object for DI. Services hashtable might be incomplete or inaccurate."
        }
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        # Write-Verbose "Screen '$($this.Name)' created with ServiceContainer."
    }

    [void] Initialize() { 
        # Write-Verbose "Initialize called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnEnter() { 
        # Write-Verbose "OnEnter called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnExit() { 
        # Write-Verbose "OnExit called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnResume() { 
        # Write-Verbose "OnResume called for Screen '$($this.Name)': Default (no-op)." 
    }

    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Write-Verbose "HandleInput called for Screen '$($this.Name)': Key: $($keyInfo.Key). Default (no-op)."
    }

    [void] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo) {
        $this.HandleInput($keyInfo)
    }

    [void] HandleResize([int]$newWidth, [int]$newHeight) {
        $this.Resize($newWidth, $newHeight)
    }

    [void] Cleanup() {
        try {
            # Write-Verbose "Cleanup called for Screen '$($this.Name)'."
            foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
                try {
                    if (Get-Command 'Unsubscribe-Event' -ErrorAction SilentlyContinue) {
                        Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value
                        Write-Verbose "Unsubscribed event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)'."
                    }
                }
                catch {
                    Write-Warning "Failed to unsubscribe event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)': $($_.Exception.Message)"
                }
            }
            $this.EventSubscriptions.Clear()
            foreach ($child in $this.Children) {
                if ($child.PSObject.Methods['Cleanup']) {
                    try { $child.Cleanup() } catch { Write-Warning "Failed to cleanup child '$($child.Name)': $($_.Exception.Message)" }
                }
            }
            $this.Panels.Clear()
            $this.Children.Clear()
            Write-Verbose "Cleaned up resources for screen: $($this.Name)."
        }
        catch {
            Write-Error "Error during Cleanup for screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] AddPanel([object]$panel) {
        try {
            $this.Panels.Add($panel)
            $this.AddChild($panel) 
            Write-Verbose "Added panel '$($panel.Name)' to screen '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add panel '$($panel.Name)' to screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        try {
            if (Get-Command 'Subscribe-Event' -ErrorAction SilentlyContinue) {
                $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
                $this.EventSubscriptions[$eventName] = $subscriptionId
                Write-Verbose "Screen '$($this.Name)' subscribed to event '$eventName' with HandlerId: $subscriptionId."
            } else {
                Write-Warning "Subscribe-Event function not available. Event subscription for '$eventName' failed."
            }
        }
        catch {
            Write-Error "Failed for screen '$($this.Name)' to subscribe to event '$eventName': $($_.Exception.Message)"
            throw
        }
    }
    
    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent()
        Write-Verbose "_RenderContent called for Screen '$($this.Name)' (rendering UIElement children, including panels)."
    }

    [string] ToString() {
        return "Screen(Name='$($this.Name)', Panels=$($this.Panels.Count), Visible=$($this.Visible))"
    }

    [void] Render([TuiBuffer]$buffer) {
        # First render self
        $this._RenderContent()
        
        # Then blend our buffer onto the target
        if ($null -ne $this._private_buffer) {
            $buffer.BlendBuffer($this._private_buffer, 0, 0)
        }
    }
}
#endregion

#region ServiceContainer Class
class ServiceContainer {
    hidden [hashtable] $_services = @{}
    hidden [hashtable] $_serviceFactories = @{}

    ServiceContainer() {
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer created."
        }
        Write-Verbose "ServiceContainer: Instance constructed."
    }

    [void] Register([string]$name, [object]$serviceInstance) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }
        if ($null -eq $serviceInstance) { throw [System.ArgumentNullException]::new("serviceInstance") }

        if ($this._services.ContainsKey($name) -or $this._serviceFactories.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("A service or factory with the name '$name' is already registered.")
        }

        $this._services[$name] = $serviceInstance
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Registered eager service instance: '$name'."
        }
        Write-Verbose "ServiceContainer: Registered eager instance for '$name' of type '$($serviceInstance.GetType().Name)'."
    }

    [void] RegisterFactory([string]$name, [scriptblock]$factory, [bool]$isSingleton = $true) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }
        if ($null -eq $factory) { throw [System.ArgumentNullException]::new("factory") }

        if ($this._services.ContainsKey($name) -or $this._serviceFactories.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("A service or factory with the name '$name' is already registered.")
        }
        
        $this._serviceFactories[$name] = @{
            Factory = $factory
            IsSingleton = $isSingleton
            Instance = $null
        }
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Registered service factory: '$name' (Singleton: $isSingleton)."
        }
        Write-Verbose "ServiceContainer: Registered factory for '$name' (Singleton: $isSingleton)."
    }

    [object] GetService([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }

        if ($this._services.ContainsKey($name)) {
            Write-Verbose "ServiceContainer: Returning eager-loaded instance of '$name'."
            return $this._services[$name]
        }

        if ($this._serviceFactories.ContainsKey($name)) {
            return $this._InitializeServiceFromFactory($name, [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase))
        }

        $available = $this.GetAllRegisteredServices() | Select-Object -ExpandProperty Name
        throw [System.InvalidOperationException]::new("Service '$name' not found. Available services: $($available -join ', ')")
    }
    
    [object[]] GetAllRegisteredServices() {
        $list = [System.Collections.Generic.List[object]]::new()
        
        foreach ($key in $this._services.Keys) {
            $list.Add([pscustomobject]@{
                Name = $key
                Type = 'Instance'
                Initialized = $true
                Lifestyle = 'Singleton'
            })
        }
        
        foreach ($key in $this._serviceFactories.Keys) {
            $factoryInfo = $this._serviceFactories[$key]
            $list.Add([pscustomobject]@{
                Name = $key
                Type = 'Factory'
                Initialized = ($null -ne $factoryInfo.Instance)
                Lifestyle = if ($factoryInfo.IsSingleton) { 'Singleton' } else { 'Transient' }
            })
        }
        
        return $list.ToArray() | Sort-Object Name
    }

    [void] Cleanup() {
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer cleanup initiated."
        }
        Write-Verbose "ServiceContainer: Initiating cleanup of disposable singleton services."
        
        $instancesToClean = [System.Collections.Generic.List[object]]::new()
        $this._services.Values | ForEach-Object { $instancesToClean.Add($_) }
        $this._serviceFactories.Values | Where-Object { $_.IsSingleton -and $_.Instance } | ForEach-Object { $instancesToClean.Add($_.Instance) }

        foreach ($service in $instancesToClean) {
            if ($service -is [System.IDisposable]) {
                try {
                    Write-Verbose "ServiceContainer: Disposing service of type '$($service.GetType().FullName)'."
                    $service.Dispose()
                } catch {
                    if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                        Write-Log -Level Error -Message "Error disposing service of type '$($service.GetType().FullName)': $($_.Exception.Message)"
                    }
                }
            }
        }
        
        $this._services.Clear()
        $this._serviceFactories.Clear()
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer cleanup complete."
        }
        Write-Verbose "ServiceContainer: Cleanup complete. All service registries cleared."
    }

    hidden [object] _InitializeServiceFromFactory([string]$name, [System.Collections.Generic.HashSet[string]]$resolutionChain) {
        $factoryInfo = $this._serviceFactories[$name]
        
        if ($factoryInfo.IsSingleton -and $null -ne $factoryInfo.Instance) {
            Write-Verbose "ServiceContainer: Returning cached singleton instance of '$name'."
            return $factoryInfo.Instance
        }

        if ($resolutionChain.Contains($name)) {
            $chain = ($resolutionChain -join ' -> ') + " -> $name"
            throw [System.InvalidOperationException]::new("Circular dependency detected while resolving service '$name'. Chain: $chain")
        }
        [void]$resolutionChain.Add($name)
        
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Instantiating service '$name' from factory."
        }
        Write-Verbose "ServiceContainer: Invoking factory to create instance of '$name'."
        
        $serviceInstance = & $factoryInfo.Factory $this

        if ($factoryInfo.IsSingleton) {
            $factoryInfo.Instance = $serviceInstance
            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Cached singleton instance of service '$name'."
            }
            Write-Verbose "ServiceContainer: Cached new singleton instance of '$name'."
        }

        [void]$resolutionChain.Remove($name)
        
        return $serviceInstance
    }
}
#endregion

####\AllComponents.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components CLEAN (No Verbose)
# UI components that extend UIElement - NO VERBOSE OUTPUT
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#region Core UI Components

class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor

    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            $bg = [ConsoleColor]::Black
            $this._private_buffer.WriteString(0, 0, $this.Text, $fg, $bg)
        }
        catch {
            # Silently handle errors in render
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}

class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick

    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = if ($this.IsPressed) { [ConsoleColor]::DarkGray } else { [ConsoleColor]::Black }
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            $fgColor = if ($this.IsPressed) { [ConsoleColor]::Black } else { [ConsoleColor]::White }

            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this._private_buffer.SetCell($x, 0, [TuiCell]::new('-', $borderColor, $bgColor))
                $this._private_buffer.SetCell($x, $this.Height - 1, [TuiCell]::new('-', $borderColor, $bgColor))
            }
            for ($y = 0; $y -lt $this.Height; $y++) {
                $this._private_buffer.SetCell(0, $y, [TuiCell]::new('|', $borderColor, $bgColor))
                $this._private_buffer.SetCell($this.Width - 1, $y, [TuiCell]::new('|', $borderColor, $bgColor))
            }
            
            $this._private_buffer.SetCell(0, 0, [TuiCell]::new('+', $borderColor, $bgColor))
            $this._private_buffer.SetCell($this.Width - 1, 0, [TuiCell]::new('+', $borderColor, $bgColor))
            $this._private_buffer.SetCell(0, $this.Height - 1, [TuiCell]::new('+', $borderColor, $bgColor))
            $this._private_buffer.SetCell($this.Width - 1, $this.Height - 1, [TuiCell]::new('+', $borderColor, $bgColor))
            
            $textX = [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = [Math]::Floor(($this.Height - 1) / 2)
            $this._private_buffer.WriteString($textX, $textY, $this.Text, $fgColor, $bgColor)
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            try {
                $this.IsPressed = $true
                $this.RequestRedraw()
                
                if ($this.OnClick) {
                    & $this.OnClick
                }
                
                Start-Sleep -Milliseconds 50
                $this.IsPressed = $false
                $this.RequestRedraw()
                
                return $true
            }
            catch {
                $this.IsPressed = $false
                $this.RequestRedraw()
            }
        }
        return $false
    }
}

class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [ValidateRange(1, [int]::MaxValue)][int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    hidden [int]$_scrollOffset = 0

    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = [ConsoleColor]::Black
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            $textColor = [ConsoleColor]::White
            $placeholderColor = [ConsoleColor]::DarkGray
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $textColor, $bgColor))
            
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this._private_buffer.SetCell($x, 0, [TuiCell]::new('-', $borderColor, $bgColor))
                $this._private_buffer.SetCell($x, $this.Height - 1, [TuiCell]::new('-', $borderColor, $bgColor))
            }
            for ($y = 0; $y -lt $this.Height; $y++) {
                $this._private_buffer.SetCell(0, $y, [TuiCell]::new('|', $borderColor, $bgColor))
                $this._private_buffer.SetCell($this.Width - 1, $y, [TuiCell]::new('|', $borderColor, $bgColor))
            }
            
            $this._private_buffer.SetCell(0, 0, [TuiCell]::new('+', $borderColor, $bgColor))
            $this._private_buffer.SetCell($this.Width - 1, 0, [TuiCell]::new('+', $borderColor, $bgColor))
            $this._private_buffer.SetCell(0, $this.Height - 1, [TuiCell]::new('+', $borderColor, $bgColor))
            $this._private_buffer.SetCell($this.Width - 1, $this.Height - 1, [TuiCell]::new('+', $borderColor, $bgColor))

            $textAreaWidth = $this.Width - 2
            $displayText = $this.Text ?? ""
            $currentTextColor = $textColor

            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) {
                $displayText = $this.Placeholder ?? ""
                $currentTextColor = $placeholderColor
            }

            if ($displayText.Length -gt $textAreaWidth) {
                $displayText = $displayText.Substring($this._scrollOffset, [Math]::Min($textAreaWidth, $displayText.Length - $this._scrollOffset))
            }

            if (-not [string]::IsNullOrEmpty($displayText)) {
                $this._private_buffer.WriteString(1, 1, $displayText, $currentTextColor, $bgColor)
            }

            if ($this.IsFocused) {
                $cursorX = 1 + ($this.CursorPosition - $this._scrollOffset)
                if ($cursorX -ge 1 -and $cursorX -lt ($this.Width - 1)) {
                    $cell = $this._private_buffer.GetCell($cursorX, 1)
                    if ($null -ne $cell) {
                        $cell.BackgroundColor = [ConsoleColor]::Cyan
                        $cell.ForegroundColor = [ConsoleColor]::Black
                        $this._private_buffer.SetCell($cursorX, 1, $cell)
                    }
                }
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        try {
            $currentText = $this.Text ?? ""
            $cursorPos = $this.CursorPosition
            $originalText = $currentText
            $handled = $true

            switch ($key.Key) {
                ([ConsoleKey]::Backspace) {
                    if ($cursorPos -gt 0) {
                        $this.Text = $currentText.Remove($cursorPos - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($cursorPos -lt $currentText.Length) {
                        $this.Text = $currentText.Remove($cursorPos, 1)
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($cursorPos -gt 0) {
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($cursorPos -lt $this.Text.Length) {
                        $this.CursorPosition++
                    }
                }
                ([ConsoleKey]::Home) {
                    $this.CursorPosition = 0
                }
                ([ConsoleKey]::End) {
                    $this.CursorPosition = $this.Text.Length
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar) -and $currentText.Length -lt $this.MaxLength) {
                        $this.Text = $currentText.Insert($cursorPos, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }

            if ($handled) {
                $this._UpdateScrollOffset()
                
                if ($this.Text -ne $originalText -and $this.OnChange) {
                    & $this.OnChange -NewValue $this.Text
                }
                
                $this.RequestRedraw()
            }
            
            return $handled
        }
        catch {
            return $false
        }
    }

    hidden [void] _UpdateScrollOffset() {
        $textAreaWidth = $this.Width - 2
        
        if ($this.CursorPosition -gt ($this._scrollOffset + $textAreaWidth - 1)) {
            $this._scrollOffset = $this.CursorPosition - $textAreaWidth + 1
        }
        
        if ($this.CursorPosition -lt $this._scrollOffset) {
            $this._scrollOffset = $this.CursorPosition
        }
        
        $maxScroll = [Math]::Max(0, $this.Text.Length - $textAreaWidth)
        $this._scrollOffset = [Math]::Min($this._scrollOffset, $maxScroll)
        $this._scrollOffset = [Math]::Max(0, $this._scrollOffset)
    }
}

class CheckBoxComponent : UIElement {
    [string]$Text = "Checkbox"
    [bool]$Checked = $false
    [scriptblock]$OnChange

    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::White }
            $bg = [ConsoleColor]::Black
            
            $checkbox = if ($this.Checked) { "[X]" } else { "[ ]" }
            $displayText = "$checkbox $($this.Text)"
            
            $this._private_buffer.WriteString(0, 0, $displayText, $fg, $bg)
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            try {
                $this.Checked = -not $this.Checked
                
                if ($this.OnChange) {
                    & $this.OnChange -NewValue $this.Checked
                }
                
                $this.RequestRedraw()
                return $true
            }
            catch {}
        }
        return $false
    }
}

class RadioButtonComponent : UIElement {
    [string]$Text = "Option"
    [bool]$Selected = $false
    [string]$GroupName = ""
    [scriptblock]$OnChange

    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::White }
            $bg = [ConsoleColor]::Black
            
            $radio = if ($this.Selected) { "(●)" } else { "( )" }
            $displayText = "$radio $($this.Text)"
            
            $this._private_buffer.WriteString(0, 0, $displayText, $fg, $bg)
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            try {
                if (-not $this.Selected) {
                    $this.Selected = $true
                    
                    if ($this.Parent -and $this.GroupName) {
                        $this.Parent.Children | Where-Object { 
                            $_ -is [RadioButtonComponent] -and $_.GroupName -eq $this.GroupName -and $_ -ne $this 
                        } | ForEach-Object {
                            $_.Selected = $false
                            $_.RequestRedraw()
                        }
                    }
                    
                    if ($this.OnChange) {
                        & $this.OnChange -NewValue $this.Selected
                    }
                    
                    $this.RequestRedraw()
                }
                return $true
            }
            catch {}
        }
        return $false
    }
}

#endregion

#region Advanced Input Components

# ===== CLASS: MultilineTextBoxComponent =====
# Module: advanced-input-components (from axiom)
# Dependencies: UIElement, theme colors
# Purpose: Full text editor with viewport scrolling
class MultilineTextBoxComponent : UIElement {
    [string[]]$Lines = @("")
    [string]$Placeholder = "Enter text..."
    [ValidateRange(1, 100)][int]$MaxLines = 10
    [ValidateRange(1, 1000)][int]$MaxLineLength = 100
    [int]$CurrentLine = 0
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    
    hidden [int]$_scrollOffsetY = 0
    hidden [int]$_scrollOffsetX = 0

    MultilineTextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 40
        $this.Height = 8
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            # Get theme colors (fallback to default if no theme)
            $bgColor = [ConsoleColor]::Black
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            $fgColor = [ConsoleColor]::White
            $placeholderColor = [ConsoleColor]::DarkGray
            $cursorColor = [ConsoleColor]::Cyan
            
            # Clear buffer and draw border
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            $this._private_buffer.DrawBox(0, 0, $this.Width, $this.Height, $borderColor, $bgColor, $false)

            $textAreaHeight = $this.Height - 2
            $textAreaWidth = $this.Width - 2
            
            # Render visible lines
            for ($i = 0; $i -lt $textAreaHeight; $i++) {
                $lineIndex = $i + $this._scrollOffsetY
                if ($lineIndex -ge $this.Lines.Count) { break }
                
                $lineText = $this.Lines[$lineIndex]
                $displayLine = ""
                
                if ($lineText.Length -gt $this._scrollOffsetX) {
                    $displayLine = $lineText.Substring($this._scrollOffsetX, [Math]::Min($textAreaWidth, $lineText.Length - $this._scrollOffsetX))
                }
                
                if (-not [string]::IsNullOrEmpty($displayLine)) {
                    $this._private_buffer.WriteString(1, $i + 1, $displayLine, $fgColor, $bgColor)
                }
            }

            # Show placeholder if empty and not focused
            if ($this.Lines.Count -eq 1 -and [string]::IsNullOrEmpty($this.Lines[0]) -and -not $this.IsFocused) {
                $this._private_buffer.WriteString(1, 1, $this.Placeholder, $placeholderColor, $bgColor)
            }

            # Render cursor
            if ($this.IsFocused) {
                $cursorLineY = $this.CurrentLine - $this._scrollOffsetY
                if ($cursorLineY -ge 0 -and $cursorLineY -lt $textAreaHeight) {
                    $cursorX = 1 + ($this.CursorPosition - $this._scrollOffsetX)
                    if ($cursorX -ge 1 -and $cursorX -le $textAreaWidth) {
                        $cell = $this._private_buffer.GetCell($cursorX, $cursorLineY + 1)
                        if ($null -ne $cell) {
                            $cell.BackgroundColor = $cursorColor
                            $cell.ForegroundColor = $bgColor
                            $this._private_buffer.SetCell($cursorX, $cursorLineY + 1, $cell)
                        }
                    }
                }
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        try {
            $handled = $true
            $currentLineText = $this.Lines[$this.CurrentLine]
            $originalText = $this.Lines -join "`n"
            
            switch ($key.Key) {
                ([ConsoleKey]::Enter) {
                    if ($this.Lines.Count -lt $this.MaxLines) {
                        $beforeCursor = $currentLineText.Substring(0, $this.CursorPosition)
                        $afterCursor = $currentLineText.Substring($this.CursorPosition)
                        
                        $this.Lines[$this.CurrentLine] = $beforeCursor
                        $this.Lines = $this.Lines[0..$this.CurrentLine] + @($afterCursor) + $this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)]
                        
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                    elseif ($this.CurrentLine -gt 0) {
                        $this.CursorPosition = $this.Lines[$this.CurrentLine - 1].Length
                        $this.Lines[$this.CurrentLine - 1] += $currentLineText
                        $this.Lines = $this.Lines[0..($this.CurrentLine - 1)] + $this.Lines[($this.CurrentLine + 1)..($this.Lines.Count - 1)]
                        $this.CurrentLine--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.Lines[$this.CurrentLine] = $currentLineText.Remove($this.CursorPosition, 1)
                    }
                    elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.Lines[$this.CurrentLine] += $this.Lines[$this.CurrentLine + 1]
                        $this.Lines = $this.Lines[0..$this.CurrentLine] + $this.Lines[($this.CurrentLine + 2)..($this.Lines.Count - 1)]
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    }
                    elseif ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = $this.Lines[$this.CurrentLine].Length
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $currentLineText.Length) {
                        $this.CursorPosition++
                    }
                    elseif ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = 0
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    if ($this.CurrentLine -gt 0) {
                        $this.CurrentLine--
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.CurrentLine -lt ($this.Lines.Count - 1)) {
                        $this.CurrentLine++
                        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                    }
                }
                ([ConsoleKey]::Home) {
                    $this.CursorPosition = 0
                }
                ([ConsoleKey]::End) {
                    $this.CursorPosition = $currentLineText.Length
                }
                ([ConsoleKey]::PageUp) {
                    $this.CurrentLine = [Math]::Max(0, $this.CurrentLine - ($this.Height - 2))
                    $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                }
                ([ConsoleKey]::PageDown) {
                    $this.CurrentLine = [Math]::Min($this.Lines.Count - 1, $this.CurrentLine + ($this.Height - 2))
                    $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.Lines[$this.CurrentLine].Length)
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                        $newLine = $currentLineText.Insert($this.CursorPosition, $key.KeyChar)
                        if ($newLine.Length -le $this.MaxLineLength) {
                            $this.Lines[$this.CurrentLine] = $newLine
                            $this.CursorPosition++
                        }
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                $this._UpdateScrolling()
                
                # Fire change event if text changed
                $newText = $this.Lines -join "`n"
                if ($newText -ne $originalText -and $this.OnChange) {
                    & $this.OnChange -NewValue $newText
                }
                
                $this.RequestRedraw()
            }
            
            return $handled
        }
        catch {
            return $false
        }
    }

    hidden [void] _UpdateScrolling() {
        $textAreaHeight = $this.Height - 2
        $textAreaWidth = $this.Width - 2
        
        # Vertical scrolling
        if ($this.CurrentLine -lt $this._scrollOffsetY) {
            $this._scrollOffsetY = $this.CurrentLine
        }
        elseif ($this.CurrentLine -ge ($this._scrollOffsetY + $textAreaHeight)) {
            $this._scrollOffsetY = $this.CurrentLine - $textAreaHeight + 1
        }
        
        # Horizontal scrolling
        if ($this.CursorPosition -lt $this._scrollOffsetX) {
            $this._scrollOffsetX = $this.CursorPosition
        }
        elseif ($this.CursorPosition -ge ($this._scrollOffsetX + $textAreaWidth)) {
            $this._scrollOffsetX = $this.CursorPosition - $textAreaWidth + 1
        }
        
        # Ensure scroll offsets are within bounds
        $this._scrollOffsetY = [Math]::Max(0, $this._scrollOffsetY)
        $this._scrollOffsetX = [Math]::Max(0, $this._scrollOffsetX)
    }

    [string] GetText() {
        return $this.Lines -join "`n"
    }

    [void] SetText([string]$text) {
        if ([string]::IsNullOrEmpty($text)) {
            $this.Lines = @("")
        } else {
            $this.Lines = $text -split "`n"
        }
        $this.CurrentLine = 0
        $this.CursorPosition = 0
        $this._scrollOffsetY = 0
        $this._scrollOffsetX = 0
        $this.RequestRedraw()
    }
}

# ===== CLASS: NumericInputComponent =====
# Module: advanced-input-components (from axiom)
# Dependencies: UIElement
# Purpose: Numeric input with spinners and validation
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$MinValue = [double]::MinValue
    [double]$MaxValue = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [string]$Suffix = ""
    [string]$TextValue = "0"
    [int]$CursorPosition = 0
    [scriptblock]$OnChange

    NumericInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
        $this.TextValue = $this.Value.ToString()
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = [ConsoleColor]::Black
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            $fgColor = [ConsoleColor]::White
            $suffixColor = [ConsoleColor]::DarkGray
            $cursorColor = [ConsoleColor]::Cyan
            
            # Clear buffer and draw border
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            $this._private_buffer.DrawBox(0, 0, $this.Width, $this.Height, $borderColor, $bgColor, $false)
            
            # Draw main value
            $displayText = $this.TextValue
            if (-not [string]::IsNullOrEmpty($this.Suffix)) {
                $displayText += $this.Suffix
            }
            
            $this._private_buffer.WriteString(2, 1, $displayText, $fgColor, $bgColor)
            
            # Draw spinner arrows
            $spinnerColor = if ($this.IsFocused) { $borderColor } else { [ConsoleColor]::DarkGray }
            $this._private_buffer.WriteString($this.Width - 3, 0, "▲", $spinnerColor, $bgColor)
            $this._private_buffer.WriteString($this.Width - 3, 2, "▼", $spinnerColor, $bgColor)
            
            # Draw cursor
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt ($this.Width - 4)) {
                    $cell = $this._private_buffer.GetCell($cursorX, 1)
                    if ($null -ne $cell) {
                        $cell.BackgroundColor = $cursorColor
                        $cell.ForegroundColor = $bgColor
                        $this._private_buffer.SetCell($cursorX, 1, $cell)
                    }
                }
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        try {
            $handled = $true
            $originalValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $this.Value = [Math]::Min($this.MaxValue, $this.Value + $this.Step)
                    $this._UpdateTextValue()
                }
                ([ConsoleKey]::DownArrow) {
                    $this.Value = [Math]::Max($this.MinValue, $this.Value - $this.Step)
                    $this._UpdateTextValue()
                }
                ([ConsoleKey]::Enter) {
                    if ($this._ValidateAndSetValue($this.TextValue)) {
                        # Value was valid and set
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.CursorPosition++
                    }
                }
                ([ConsoleKey]::Home) {
                    $this.CursorPosition = 0
                }
                ([ConsoleKey]::End) {
                    $this.CursorPosition = $this.TextValue.Length
                }
                default {
                    if ($key.KeyChar -and $this._IsValidNumericChar($key.KeyChar)) {
                        $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                # Fire change event if value changed
                if ($this.Value -ne $originalValue -and $this.OnChange) {
                    & $this.OnChange -NewValue $this.Value
                }
                
                $this.RequestRedraw()
            }
            
            return $handled
        }
        catch {
            return $false
        }
    }

    hidden [bool] _IsValidNumericChar([char]$char) {
        return [char]::IsDigit($char) -or $char -eq '.' -or $char -eq '-'
    }

    hidden [bool] _ValidateAndSetValue([string]$text) {
        try {
            $parsedValue = [double]::Parse($text)
            if ($parsedValue -ge $this.MinValue -and $parsedValue -le $this.MaxValue) {
                $this.Value = $parsedValue
                $this._UpdateTextValue()
                return $true
            }
        }
        catch {
            # Invalid format, revert to current value
            $this._UpdateTextValue()
        }
        return $false
    }

    hidden [void] _UpdateTextValue() {
        $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.TextValue.Length)
    }
}

# ===== CLASS: DateInputComponent =====
# Module: advanced-input-components (from axiom)
# Dependencies: UIElement
# Purpose: Date picker with validation
class DateInputComponent : UIElement {
    [DateTime]$Value = (Get-Date)
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [string]$DateFormat = "yyyy-MM-dd"
    [string]$TextValue = ""
    [int]$CursorPosition = 0
    [bool]$ShowCalendar = $false
    [scriptblock]$OnChange

    DateInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.TextValue = $this.Value.ToString($this.DateFormat)
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = [ConsoleColor]::Black
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            $fgColor = [ConsoleColor]::White
            $cursorColor = [ConsoleColor]::Cyan
            
            # Clear buffer and draw border
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            $this._private_buffer.DrawBox(0, 0, $this.Width, $this.Height, $borderColor, $bgColor, $false)
            
            # Draw date value
            $this._private_buffer.WriteString(2, 1, $this.TextValue, $fgColor, $bgColor)
            
            # Draw calendar icon
            $iconColor = if ($this.IsFocused) { $borderColor } else { [ConsoleColor]::DarkGray }
            $this._private_buffer.WriteString($this.Width - 3, 1, "📅", $iconColor, $bgColor)
            
            # Draw cursor
            if ($this.IsFocused -and $this.CursorPosition -le $this.TextValue.Length) {
                $cursorX = 2 + $this.CursorPosition
                if ($cursorX -lt ($this.Width - 4)) {
                    $cell = $this._private_buffer.GetCell($cursorX, 1)
                    if ($null -ne $cell) {
                        $cell.BackgroundColor = $cursorColor
                        $cell.ForegroundColor = $bgColor
                        $this._private_buffer.SetCell($cursorX, 1, $cell)
                    }
                }
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        try {
            $handled = $true
            $originalValue = $this.Value
            
            switch ($key.Key) {
                ([ConsoleKey]::Enter) {
                    if ($this._ValidateAndSetDate($this.TextValue)) {
                        # Date was valid and set
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.CursorPosition -gt 0) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition - 1, 1)
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.TextValue = $this.TextValue.Remove($this.CursorPosition, 1)
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.CursorPosition -gt 0) {
                        $this.CursorPosition--
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.CursorPosition -lt $this.TextValue.Length) {
                        $this.CursorPosition++
                    }
                }
                ([ConsoleKey]::Home) {
                    $this.CursorPosition = 0
                }
                ([ConsoleKey]::End) {
                    $this.CursorPosition = $this.TextValue.Length
                }
                default {
                    if ($key.KeyChar -and $this._IsValidDateChar($key.KeyChar)) {
                        $this.TextValue = $this.TextValue.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    } else {
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                # Fire change event if value changed
                if ($this.Value -ne $originalValue -and $this.OnChange) {
                    & $this.OnChange -NewValue $this.Value
                }
                
                $this.RequestRedraw()
            }
            
            return $handled
        }
        catch {
            return $false
        }
    }

    hidden [bool] _IsValidDateChar([char]$char) {
        return [char]::IsDigit($char) -or $char -eq '-' -or $char -eq '/' -or $char -eq '.'
    }

    hidden [bool] _ValidateAndSetDate([string]$text) {
        try {
            $date = [DateTime]::ParseExact($text, $this.DateFormat, $null)
            if ($date -ge $this.MinDate -and $date -le $this.MaxDate) {
                $this.Value = $date
                $this._UpdateTextValue()
                return $true
            }
        }
        catch {
            # Invalid format, revert to current value
            $this._UpdateTextValue()
        }
        return $false
    }

    hidden [void] _UpdateTextValue() {
        $this.TextValue = $this.Value.ToString($this.DateFormat)
        $this.CursorPosition = [Math]::Min($this.CursorPosition, $this.TextValue.Length)
    }
}

# ===== CLASS: ComboBoxComponent =====
# Module: advanced-input-components (from axiom)
# Dependencies: UIElement
# Purpose: Dropdown with search and overlay rendering
class ComboBoxComponent : UIElement {
    [string[]]$Items = @()
    [int]$SelectedIndex = -1
    [string]$SelectedItem = ""
    [string]$DisplayText = ""
    [string]$SearchText = ""
    [bool]$IsDropDownOpen = $false
    [bool]$AllowSearch = $true
    [ValidateRange(3, 20)][int]$MaxDropDownHeight = 8
    [int]$ScrollOffset = 0
    [scriptblock]$OnSelectionChanged
    
    hidden [TuiBuffer]$_dropdownBuffer = $null
    hidden [string[]]$_filteredItems = @()

    ComboBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 30
        $this.Height = 3
        $this._filteredItems = $this.Items
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = [ConsoleColor]::Black
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            $fgColor = [ConsoleColor]::White
            
            # Clear buffer and draw border
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            $this._private_buffer.DrawBox(0, 0, $this.Width, $this.Height, $borderColor, $bgColor, $false)
            
            # Draw current value or search text
            $displayValue = if ($this.IsDropDownOpen -and $this.AllowSearch) { $this.SearchText } else { $this.DisplayText }
            if (-not [string]::IsNullOrEmpty($displayValue)) {
                $maxTextWidth = $this.Width - 6
                if ($displayValue.Length -gt $maxTextWidth) {
                    $displayValue = $displayValue.Substring(0, $maxTextWidth - 3) + "..."
                }
                $this._private_buffer.WriteString(2, 1, $displayValue, $fgColor, $bgColor)
            }
            
            # Draw dropdown arrow
            $arrow = if ($this.IsDropDownOpen) { "▲" } else { "▼" }
            $arrowColor = if ($this.IsFocused) { $borderColor } else { [ConsoleColor]::DarkGray }
            $this._private_buffer.WriteString($this.Width - 3, 1, $arrow, $arrowColor, $bgColor)
            
            # Render dropdown overlay if open
            if ($this.IsDropDownOpen) {
                $this._RenderDropdownOverlay()
            }
        }
        catch {}
    }

    hidden [void] _RenderDropdownOverlay() {
        try {
            # Get theme colors
            $bgColor = [ConsoleColor]::Black
            $borderColor = [ConsoleColor]::Cyan
            $fgColor = [ConsoleColor]::White
            $selectionBg = [ConsoleColor]::Blue
            $selectionFg = [ConsoleColor]::White
            
            $dropdownHeight = [Math]::Min($this.MaxDropDownHeight, ($this._filteredItems.Count + 2))
            
            # Create or resize dropdown buffer
            if (-not $this._dropdownBuffer -or $this._dropdownBuffer.Height -ne $dropdownHeight -or $this._dropdownBuffer.Width -ne $this.Width) {
                $this._dropdownBuffer = [TuiBuffer]::new($this.Width, $dropdownHeight, "$($this.Name).Dropdown")
            }
            
            # Clear and draw dropdown
            $this._dropdownBuffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            $this._dropdownBuffer.DrawBox(0, 0, $this.Width, $dropdownHeight, $borderColor, $bgColor, $false)
            
            # Draw items
            $visibleItems = [Math]::Min($this.MaxDropDownHeight - 2, $this._filteredItems.Count)
            for ($i = 0; $i -lt $visibleItems; $i++) {
                $itemIndex = $i + $this.ScrollOffset
                if ($itemIndex -ge $this._filteredItems.Count) { break }
                
                $item = $this._filteredItems[$itemIndex]
                $isSelected = ($itemIndex -eq $this.SelectedIndex)
                
                $itemBg = if ($isSelected) { $selectionBg } else { $bgColor }
                $itemFg = if ($isSelected) { $selectionFg } else { $fgColor }
                
                # Draw selection background
                $highlightText = ' ' * ($this.Width - 2)
                $this._dropdownBuffer.WriteString(1, $i + 1, $highlightText, $itemFg, $itemBg)
                
                # Draw item text
                $itemText = " $item"
                $maxItemWidth = $this.Width - 4
                if ($itemText.Length -gt $maxItemWidth) {
                    $itemText = $itemText.Substring(0, $maxItemWidth - 3) + "..."
                }
                $this._dropdownBuffer.WriteString(2, $i + 1, $itemText, $itemFg, $itemBg)
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        try {
            $handled = $true
            $originalSelection = $this.SelectedItem
            
            if ($this.IsDropDownOpen) {
                switch ($key.Key) {
                    ([ConsoleKey]::Escape) {
                        $this.IsDropDownOpen = $false
                        $this.SearchText = ""
                        $this._UpdateFilteredItems()
                    }
                    ([ConsoleKey]::Enter) {
                        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._filteredItems.Count) {
                            $this.SelectedItem = $this._filteredItems[$this.SelectedIndex]
                            $this.DisplayText = $this.SelectedItem
                            $this.IsDropDownOpen = $false
                            $this.SearchText = ""
                            $this._UpdateFilteredItems()
                        }
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($this.SelectedIndex -gt 0) {
                            $this.SelectedIndex--
                            $this._EnsureSelectedVisible()
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($this.SelectedIndex -lt ($this._filteredItems.Count - 1)) {
                            $this.SelectedIndex++
                            $this._EnsureSelectedVisible()
                        }
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($this.AllowSearch -and $this.SearchText.Length -gt 0) {
                            $this.SearchText = $this.SearchText.Substring(0, $this.SearchText.Length - 1)
                            $this._UpdateFilteredItems()
                        }
                    }
                    default {
                        if ($this.AllowSearch -and $key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                            $this.SearchText += $key.KeyChar
                            $this._UpdateFilteredItems()
                        } else {
                            $handled = $false
                        }
                    }
                }
            } else {
                switch ($key.Key) {
                    ([ConsoleKey]::Enter) {
                        $this.IsDropDownOpen = $true
                        $this.SelectedIndex = 0
                        $this._UpdateFilteredItems()
                    }
                    ([ConsoleKey]::Spacebar) {
                        $this.IsDropDownOpen = $true
                        $this.SelectedIndex = 0
                        $this._UpdateFilteredItems()
                    }
                    ([ConsoleKey]::DownArrow) {
                        $this.IsDropDownOpen = $true
                        $this.SelectedIndex = 0
                        $this._UpdateFilteredItems()
                    }
                    default {
                        $handled = $false
                    }
                }
            }
            
            if ($handled) {
                # Fire selection changed event
                if ($this.SelectedItem -ne $originalSelection -and $this.OnSelectionChanged) {
                    & $this.OnSelectionChanged -SelectedItem $this.SelectedItem
                }
                
                $this.RequestRedraw()
            }
            
            return $handled
        }
        catch {
            return $false
        }
    }

    hidden [void] _UpdateFilteredItems() {
        if ([string]::IsNullOrWhiteSpace($this.SearchText)) {
            $this._filteredItems = $this.Items
        } else {
            $this._filteredItems = $this.Items | Where-Object { $_ -like "*$($this.SearchText)*" }
        }
        
        # Reset selection if current selection is no longer valid
        if ($this.SelectedIndex -ge $this._filteredItems.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
        }
        
        $this.ScrollOffset = 0
    }

    hidden [void] _EnsureSelectedVisible() {
        $visibleItems = $this.MaxDropDownHeight - 2
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        }
        elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $visibleItems)) {
            $this.ScrollOffset = $this.SelectedIndex - $visibleItems + 1
        }
    }

    [void] SetItems([string[]]$items) {
        $this.Items = $items
        $this._filteredItems = $items
        $this.SelectedIndex = -1
        $this.SelectedItem = ""
        $this.DisplayText = ""
        $this.RequestRedraw()
    }
}

#endregion

#region Data Components

# ===== CLASS: TableColumn =====
# Module: advanced-data-components (from axiom)
# Dependencies: None
# Purpose: Defines a column for the Table component
class TableColumn {
    [string]$Key
    [string]$Header
    [object]$Width # Can be [int] or the string 'Auto'
    [string]$Alignment = "Left"

    TableColumn([string]$key, [string]$header, [object]$width) {
        if ([string]::IsNullOrWhiteSpace($key)) { throw [System.ArgumentException]::new("Parameter 'key' cannot be null or empty.") }
        if ([string]::IsNullOrWhiteSpace($header)) { throw [System.ArgumentException]::new("Parameter 'header' cannot be null or empty.") }
        if ($null -eq $width) { throw [System.ArgumentNullException]::new("width") }

        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }

    [string] ToString() {
        return "TableColumn(Key='$($this.Key)', Header='$($this.Header)', Width=$($this.Width))"
    }
}

# ===== CLASS: Table =====
# Module: advanced-data-components (from axiom)
# Dependencies: UIElement, TableColumn
# Purpose: High-performance data grid with virtual scrolling
class Table : UIElement {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    [scriptblock]$OnSelectionChanged
    hidden [int]$_scrollOffset = 0 # The index of the first visible row

    Table([string]$name) : base($name) {
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
        $this.IsFocusable = $true
        $this.Width = 60
        $this.Height = 15
    }

    [void] SetColumns([TableColumn[]]$columns) {
        try {
            if ($null -eq $columns) { throw [System.ArgumentNullException]::new("columns") }
            $this.Columns.Clear()
            foreach ($col in $columns) {
                $this.Columns.Add($col)
            }
            $this.RequestRedraw()
        }
        catch {
            throw
        }
    }

    [void] SetData([object[]]$data) {
        try {
            if ($null -eq $data) { throw [System.ArgumentNullException]::new("data") }
            $this.Data = @($data) # Consistently cast to an array
            if ($this.SelectedIndex -ge $this.Data.Count) {
                $this.SelectedIndex = [Math]::Max(0, $this.Data.Count - 1)
            }
            $this._scrollOffset = 0 # Reset scroll on new data
            $this.RequestRedraw()
        }
        catch {
            throw
        }
    }

    [void] SelectNext() {
        if ($this.SelectedIndex -lt ($this.Data.Count - 1)) {
            $this.SelectedIndex++
            $this._EnsureVisible()
            $this.RequestRedraw()
        }
    }

    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
            $this._EnsureVisible()
            $this.RequestRedraw()
        }
    }

    [object] GetSelectedItem() {
        if ($this.Data.Count -gt 0 -and $this.SelectedIndex -in (0..($this.Data.Count - 1))) {
            return $this.Data[$this.SelectedIndex]
        }
        return $null
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            # Clear buffer with theme-aware colors
            $bgColor = [ConsoleColor]::Black
            $fgColor = [ConsoleColor]::White
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            # Draw border if enabled
            if ($this.ShowBorder) {
                $borderColor = [ConsoleColor]::Gray
                $this._private_buffer.DrawBox(0, 0, $this.Width, $this.Height, $borderColor, $bgColor, $false)
            }

            $contentWidth = if ($this.ShowBorder) { $this.Width - 2 } else { $this.Width }
            $contentHeight = $this._GetContentHeight()
            $renderX = if ($this.ShowBorder) { 1 } else { 0 }
            $currentY = if ($this.ShowBorder) { 1 } else { 0 }
            
            # Resolve auto-sized column widths
            $resolvedColumns = $this._ResolveColumnWidths($contentWidth)
            
            # Header
            if ($this.ShowHeader -and $resolvedColumns.Count -gt 0) {
                $headerColor = [ConsoleColor]::Cyan
                $xOffset = 0
                foreach ($col in $resolvedColumns) {
                    $headerText = $this._FormatCell($col.Header, $col.ResolvedWidth, $col.Alignment)
                    $this._private_buffer.WriteString($renderX + $xOffset, $currentY, $headerText, $headerColor, $bgColor)
                    $xOffset += $col.ResolvedWidth
                }
                $currentY++
            }
            
            # Data rows (respecting scroll offset)
            for ($i = 0; $i -lt $contentHeight; $i++) {
                $dataIndex = $i + $this._scrollOffset
                if ($dataIndex -ge $this.Data.Count) { break }
                $row = $this.Data[$dataIndex]
                if (-not $row) { continue }

                $isSelected = ($dataIndex -eq $this.SelectedIndex)
                $bg = if ($isSelected -and $this.IsFocused) { [ConsoleColor]::Blue } else { $bgColor }
                $fg = if ($isSelected -and $this.IsFocused) { [ConsoleColor]::White } else { $fgColor }

                $xOffset = 0
                foreach ($col in $resolvedColumns) {
                    $propValue = $row | Select-Object -ExpandProperty $col.Key -ErrorAction SilentlyContinue
                    $cellValue = if ($propValue) { $propValue.ToString() } else { "" }
                    $cellText = $this._FormatCell($cellValue, $col.ResolvedWidth, $col.Alignment)
                    $this._private_buffer.WriteString($renderX + $xOffset, $currentY, $cellText, $fg, $bg)
                    $xOffset += $col.ResolvedWidth
                }
                $currentY++
            }

            # Show message if no data
            if ($this.Data.Count -eq 0) {
                $subtleColor = [ConsoleColor]::DarkGray
                $this._private_buffer.WriteString($renderX, $currentY, " (No data to display) ", $subtleColor, $bgColor)
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($null -eq $keyInfo) { return $false }
        try {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::UpArrow) { 
                    $this.SelectPrevious()
                    return $true
                }
                ([ConsoleKey]::DownArrow) { 
                    $this.SelectNext()
                    return $true
                }
                ([ConsoleKey]::PageUp) { 
                    0..($this._GetContentHeight() - 1) | ForEach-Object { $this.SelectPrevious() }
                    return $true
                }
                ([ConsoleKey]::PageDown) { 
                    0..($this._GetContentHeight() - 1) | ForEach-Object { $this.SelectNext() }
                    return $true
                }
                ([ConsoleKey]::Home) { 
                    $this.SelectedIndex = 0
                    $this._EnsureVisible()
                    $this.RequestRedraw()
                    return $true
                }
                ([ConsoleKey]::End) { 
                    $this.SelectedIndex = $this.Data.Count - 1
                    $this._EnsureVisible()
                    $this.RequestRedraw()
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($this.OnSelectionChanged) {
                        $item = $this.GetSelectedItem()
                        if ($item) {
                            & $this.OnSelectionChanged -SelectedItem $item
                        }
                    }
                    return $true
                }
            }
        }
        catch {}
        return $false
    }
    
    # Ensure the selected item is visible in the viewport
    hidden [void] _EnsureVisible() {
        $contentHeight = $this._GetContentHeight()
        
        # Scroll down if selected item is below visible area
        if ($this.SelectedIndex -ge ($this._scrollOffset + $contentHeight)) {
            $this._scrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        # Scroll up if selected item is above visible area
        if ($this.SelectedIndex -lt $this._scrollOffset) {
            $this._scrollOffset = $this.SelectedIndex
        }
        
        # Ensure scroll offset is within bounds
        $this._scrollOffset = [Math]::Max(0, $this._scrollOffset)
    }
    
    # Calculate available height for content (excluding border and header)
    hidden [int] _GetContentHeight() {
        $h = $this.Height
        if ($this.ShowBorder) { $h -= 2 }
        if ($this.ShowHeader) { $h -= 1 }
        return [Math]::Max(0, $h)
    }

    # Format cell content with proper alignment and overflow handling
    hidden [string] _FormatCell([string]$text, [int]$width, [string]$alignment) {
        if ([string]::IsNullOrEmpty($text)) { return ' ' * $width }
        
        # Handle overflow with ellipsis
        if ($text.Length -gt $width) { 
            $text = $text.Substring(0, $width - 1) + '…' 
        }
        
        # Apply alignment
        $result = switch ($alignment.ToLower()) {
            'right' { $text.PadLeft($width) }
            'center' { 
                $pad = [Math]::Max(0, ($width - $text.Length) / 2)
                $padded = (' ' * $pad) + $text
                $padded.PadRight($width)
            }
            default { $text.PadRight($width) }
        }
        return $result
    }
    
    # Resolve column widths, handling 'Auto' sizing
    hidden [object[]] _ResolveColumnWidths([int]$totalWidth) {
        $fixedWidth = 0
        $autoCols = @()
        $resolved = @()

        # First pass: calculate fixed widths and identify auto columns
        foreach ($col in $this.Columns) {
            if ($col.Width -is [int]) {
                $fixedWidth += $col.Width
                $resolved += [pscustomobject]@{ 
                    Original = $col
                    ResolvedWidth = $col.Width
                    Key = $col.Key
                    Header = $col.Header
                    Alignment = $col.Alignment
                }
            } else {
                $autoCols += $col
            }
        }

        # Second pass: distribute remaining width among auto columns
        if ($autoCols.Count -gt 0) {
            $remainingWidth = $totalWidth - $fixedWidth
            $autoWidth = [Math]::Max(1, [Math]::Floor($remainingWidth / $autoCols.Count))
            
            foreach ($col in $autoCols) {
                $resolved += [pscustomobject]@{ 
                    Original = $col
                    ResolvedWidth = $autoWidth
                    Key = $col.Key
                    Header = $col.Header
                    Alignment = $col.Alignment
                }
            }
        }

        # Return in original column order
        $orderedResolved = @()
        foreach ($originalCol in $this.Columns) {
            $matchedCol = $resolved | Where-Object { $_.Original -eq $originalCol } | Select-Object -First 1
            if ($matchedCol) {
                $orderedResolved += $matchedCol
            }
        }
        
        return $orderedResolved
    }
}

#endregion

#region Dialog System

# ===== CLASS: Dialog =====
# Module: dialog-system-class (from axiom)
# Dependencies: UIElement
# Purpose: Base dialog class with promise-based API
class Dialog : UIElement {
    [string] $Title = "Dialog"
    [string] $Message = ""
    hidden [object] $_result = $null
    hidden [bool] $_isClosed = $false

    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 50
        $this.Height = 10
    }

    [void] Show() {
        try {
            # Center the dialog on screen
            $this.X = [Math]::Floor(($global:TuiState.BufferWidth - $this.Width) / 2)
            $this.Y = [Math]::Floor(($global:TuiState.BufferHeight - $this.Height) / 4)
            
            # Show as overlay
            if (Get-Command 'Show-TuiOverlay' -ErrorAction SilentlyContinue) {
                Show-TuiOverlay -Element $this
            }
            if (Get-Command 'Set-ComponentFocus' -ErrorAction SilentlyContinue) {
                Set-ComponentFocus -Component $this
            }
        }
        catch {}
    }

    [void] Close([object]$result, [bool]$wasCancelled = $false) {
        try {
            $this._result = $result
            $this._isClosed = $true
            
            if (Get-Command 'Close-TopTuiOverlay' -ErrorAction SilentlyContinue) {
                Close-TopTuiOverlay
            }
        }
        catch {}
    }

    [void] OnRender() {
        if (-not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = [ConsoleColor]::Black
            $borderColor = [ConsoleColor]::Gray
            $titleColor = [ConsoleColor]::Cyan
            
            # Clear buffer with higher z-index for proper overlay rendering
            $clearCell = [TuiCell]::new(' ', $titleColor, $bgColor)
            $clearCell.ZIndex = 100  # Ensure dialog is above background content
            $this._private_buffer.Clear($clearCell)
            
            # Draw dialog box
            $this._private_buffer.DrawBox(0, 0, $this.Width, $this.Height, $borderColor, $bgColor, $true)
            
            # Draw title
            if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
                $titleText = " $($this.Title) "
                $titleX = [Math]::Floor(($this.Width - $titleText.Length) / 2)
                $this._private_buffer.WriteString($titleX, 0, $titleText, $titleColor, $bgColor)
            }
            
            # Render message if present
            if (-not [string]::IsNullOrWhiteSpace($this.Message)) {
                $this._RenderMessage()
            }
            
            # Allow subclasses to render their specific content
            $this.RenderDialogContent()
        }
        catch {}
    }

    hidden [void] _RenderMessage() {
        try {
            $messageColor = [ConsoleColor]::White
            $bgColor = [ConsoleColor]::Black
            
            $messageY = 2
            $messageX = 2
            $maxWidth = $this.Width - 4
            
            # Simple word wrap
            $words = $this.Message -split ' '
            $lines = @()
            $currentLine = ""
            
            foreach ($word in $words) {
                $testLine = if ($currentLine) { "$currentLine $word" } else { $word }
                if ($testLine.Length -le $maxWidth) {
                    $currentLine = $testLine
                } else {
                    if ($currentLine) { $lines += $currentLine }
                    $currentLine = $word
                }
            }
            if ($currentLine) { $lines += $currentLine }
            
            foreach ($line in $lines) {
                if ($messageY -ge ($this.Height - 3)) { break }
                $this._private_buffer.WriteString($messageX, $messageY, $line, $messageColor, $bgColor)
                $messageY++
            }
        }
        catch {}
    }

    # Virtual method for subclasses to render their specific content
    [void] RenderDialogContent() { 
        # Override in subclasses
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Close($null, $true)
            return $true
        }
        return $false
    }
}

# ===== CLASS: AlertDialog =====
# Module: dialog-system-class (from axiom)
# Dependencies: Dialog
# Purpose: Simple message dialog with OK button
class AlertDialog : Dialog {
    AlertDialog([string]$title, [string]$message) : base("AlertDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 8
        $this.Width = [Math]::Min(70, [Math]::Max(40, $message.Length + 10))
    }

    [void] RenderDialogContent() {
        try {
            # Get theme colors for button
            $buttonFg = [ConsoleColor]::Black
            $buttonBg = [ConsoleColor]::Cyan
            
            $buttonY = $this.Height - 2
            $buttonLabel = " [ OK ] "
            $buttonX = [Math]::Floor(($this.Width - $buttonLabel.Length) / 2)
            
            $this._private_buffer.WriteString($buttonX, $buttonY, $buttonLabel, $buttonFg, $buttonBg)
        }
        catch {}
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            $this.Close($true)
            return $true
        }
        return ([Dialog]$this).HandleInput($key)
    }
}

# ===== CLASS: ConfirmDialog =====
# Module: dialog-system-class (from axiom)
# Dependencies: Dialog
# Purpose: Confirmation dialog with Yes/No buttons
class ConfirmDialog : Dialog {
    hidden [int] $_selectedButton = 0

    ConfirmDialog([string]$title, [string]$message) : base("ConfirmDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 8
        $this.Width = [Math]::Min(70, [Math]::Max(50, $message.Length + 10))
    }

    [void] RenderDialogContent() {
        try {
            # Get theme colors
            $normalFg = [ConsoleColor]::White
            $normalBg = [ConsoleColor]::Black
            $focusFg = [ConsoleColor]::Black
            $focusBg = [ConsoleColor]::Cyan
            
            $buttonY = $this.Height - 3
            $buttons = @("  Yes  ", "  No   ")
            $startX = [Math]::Floor(($this.Width - 24) / 2)
            
            for ($i = 0; $i -lt $buttons.Count; $i++) {
                $isFocused = ($i -eq $this._selectedButton)
                $label = if ($isFocused) { "[ $($buttons[$i].Trim()) ]" } else { $buttons[$i] }
                $fg = if ($isFocused) { $focusFg } else { $normalFg }
                $bg = if ($isFocused) { $focusBg } else { $normalBg }
                
                $this._private_buffer.WriteString($startX + ($i * 14), $buttonY, $label, $fg, $bg)
            }
        }
        catch {}
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            { $_ -in @([ConsoleKey]::LeftArrow, [ConsoleKey]::RightArrow, [ConsoleKey]::Tab) } {
                $this._selectedButton = ($this._selectedButton + 1) % 2
                $this.RequestRedraw()
                return $true
            }
            ([ConsoleKey]::Enter) {
                $result = ($this._selectedButton -eq 0) # True for Yes, False for No
                $this.Close($result)
                return $true
            }
        }
        return ([Dialog]$this).HandleInput($key)
    }
}

# ===== CLASS: InputDialog =====
# Module: dialog-system-class (from axiom)
# Dependencies: Dialog, TextBoxComponent
# Purpose: Text input dialog
class InputDialog : Dialog {
    hidden [TextBoxComponent] $_textBox
    
    InputDialog([string]$title, [string]$message, [string]$defaultValue = "") : base("InputDialog") {
        $this.Title = $title
        $this.Message = $message
        $this.Height = 10
        $this.Width = [Math]::Min(70, [Math]::Max(50, $message.Length + 20))
        # Store default value in metadata for use during initialization
        $this.Metadata.DefaultValue = $defaultValue
    }

    # Create child components during the Initialize lifecycle hook
    [void] OnInitialize() {
        try {
            $this._textBox = [TextBoxComponent]::new('DialogInput')
            $this._textBox.Text = $this.Metadata.DefaultValue
            $this._textBox.Width = $this.Width - 4
            $this._textBox.Height = 3
            $this._textBox.X = 2
            $this._textBox.Y = 4
            $this.AddChild($this._textBox)
        }
        catch {}
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        if ($this._textBox) {
            $this._textBox.Move(2, 4)
            $this._textBox.Resize($newWidth - 4, 3)
        }
    }

    [void] RenderDialogContent() {
        try {
            # The textbox is a child, so the base UIElement.Render() will handle it.
            # We just need to render the buttons.
            $normalFg = [ConsoleColor]::White
            $focusFg = [ConsoleColor]::Cyan
            $bgColor = [ConsoleColor]::Black
            
            $buttonY = $this.Height - 2
            $okLabel = "[ OK ]"
            $cancelLabel = "[ Cancel ]"
            $startX = $this.Width - $okLabel.Length - $cancelLabel.Length - 6
            
            $this._private_buffer.WriteString($startX, $buttonY, $okLabel, $focusFg, $bgColor)
            $this._private_buffer.WriteString($startX + $okLabel.Length + 2, $buttonY, $cancelLabel, $normalFg, $bgColor)
        }
        catch {}
    }

    [bool] HandleInput([ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Enter) {
            $result = if ($this._textBox) { $this._textBox.Text } else { "" }
            $this.Close($result)
            return $true
        }
        
        # Let the textbox handle all other input
        if ($this._textBox -and $this._textBox.HandleInput($key)) {
            return $true
        }
        
        return ([Dialog]$this).HandleInput($key)
    }
}

#endregion

#region Navigation Menu

# ===== CLASS: NavigationMenu =====
# Module: navigation-class (from axiom)
# Dependencies: UIElement, NavigationItem (from AllModels.ps1)
# Purpose: Contextual navigation menu component
class NavigationMenu : UIElement {
    [System.Collections.Generic.List[NavigationItem]]$Items
    [ValidateSet("Vertical", "Horizontal")][string]$Orientation = "Vertical"
    [string]$Separator = " | "
    [int]$SelectedIndex = 0

    NavigationMenu([string]$name) : base($name) {
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 10
    }

    [void] AddItem([NavigationItem]$item) {
        try {
            if (-not $item) {
                throw [System.ArgumentNullException]::new("item")
            }
            
            # Check for duplicate keys
            $existingItem = $this.Items | Where-Object { $_.Key -eq $item.Key }
            if ($existingItem) {
                throw [System.InvalidOperationException]::new("Item with key '$($item.Key)' already exists")
            }
            
            $this.Items.Add($item)
            $this.RequestRedraw()
        }
        catch {
            throw
        }
    }

    [void] AddSeparator() {
        try {
            $separatorItem = [NavigationItem]::new("-", "---", {})
            $separatorItem.Enabled = $false
            $this.Items.Add($separatorItem)
            $this.RequestRedraw()
        }
        catch {}
    }

    [void] RemoveItem([string]$key) {
        try {
            if ([string]::IsNullOrWhiteSpace($key)) { return }
            $item = $this.Items | Where-Object { $_.Key -eq $key.ToUpper() }
            if ($item) {
                $this.Items.Remove($item)
                
                # Adjust selected index if needed
                if ($this.SelectedIndex -ge $this.Items.Count) {
                    $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
                }
                
                $this.RequestRedraw()
            }
        }
        catch {}
    }

    [NavigationItem] GetItem([string]$key) {
        if ([string]::IsNullOrWhiteSpace($key)) { return $null }
        return $this.Items | Where-Object { $_.Key -eq $key.ToUpper() } | Select-Object -First 1
    }

    [void] ExecuteSelectedItem() {
        try {
            $visibleItems = @($this.Items | Where-Object { $_.Visible })
            if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $visibleItems.Count) {
                $selectedItem = $visibleItems[$this.SelectedIndex]
                if ($selectedItem.Enabled -and $selectedItem.Key -ne "-") {
                    $selectedItem.Execute()
                }
            }
        }
        catch {}
    }

    [void] ExecuteByKey([string]$key) {
        try {
            if ([string]::IsNullOrWhiteSpace($key)) { return }
            $item = $this.GetItem($key)
            if ($item -and $item.Enabled -and $item.Visible) {
                $item.Execute()
            }
        }
        catch {}
    }

    [void] OnRender() {
        if (-not $this.Visible -or -not $this._private_buffer) { return }
        
        try {
            # Get theme colors
            $bgColor = [ConsoleColor]::Black
            $fgColor = [ConsoleColor]::White
            
            # Clear buffer
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            $visibleItems = @($this.Items | Where-Object { $_.Visible })
            if ($visibleItems.Count -eq 0) {
                return
            }

            # Ensure selected index is valid
            if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $visibleItems.Count) {
                $this.SelectedIndex = 0
            }

            if ($this.Orientation -eq "Horizontal") {
                $this._RenderHorizontal($visibleItems)
            } else {
                $this._RenderVertical($visibleItems)
            }
        }
        catch {}
    }

    hidden [void] _RenderHorizontal([NavigationItem[]]$items) {
        try {
            $currentX = 0
            $maxY = 0
            
            for ($i = 0; $i -lt $items.Count; $i++) {
                if ($currentX -ge $this.Width) { break }
                
                $item = $items[$i]
                $isSelected = ($i -eq $this.SelectedIndex)
                $isFocused = ($isSelected -and $this.IsFocused)
                
                # Get colors based on state
                $itemFg = if (-not $item.Enabled) {
                    [ConsoleColor]::DarkGray
                } elseif ($isFocused) {
                    [ConsoleColor]::Black
                } else {
                    [ConsoleColor]::White
                }
                
                $itemBg = if ($isFocused) {
                    [ConsoleColor]::Cyan
                } else {
                    [ConsoleColor]::Black
                }
                
                # Format item text
                $text = if ($item.Key -eq "-") {
                    "---"
                } else {
                    "[$($item.Key)] $($item.Label)"
                }
                
                # Draw item
                $textLength = [Math]::Min($text.Length, $this.Width - $currentX)
                $displayText = $text.Substring(0, $textLength)
                
                $this._private_buffer.WriteString($currentX, 0, $displayText, $itemFg, $itemBg)
                $currentX += $textLength
                
                # Add separator if not last item and space available
                if ($i -lt ($items.Count - 1) -and ($currentX + $this.Separator.Length) -lt $this.Width) {
                    $separatorColor = [ConsoleColor]::DarkGray
                    $this._private_buffer.WriteString($currentX, 0, $this.Separator, $separatorColor, [ConsoleColor]::Black)
                    $currentX += $this.Separator.Length
                }
            }
        }
        catch {}
    }

    hidden [void] _RenderVertical([NavigationItem[]]$items) {
        try {
            $maxItems = [Math]::Min($items.Count, $this.Height)
            
            for ($i = 0; $i -lt $maxItems; $i++) {
                $item = $items[$i]
                $isSelected = ($i -eq $this.SelectedIndex)
                $isFocused = ($isSelected -and $this.IsFocused)
                
                # Handle separators
                if ($item.Key -eq "-") {
                    $separatorColor = [ConsoleColor]::DarkGray
                    $line = '─' * $this.Width
                    $this._private_buffer.WriteString(0, $i, $line, $separatorColor, [ConsoleColor]::Black)
                    continue
                }
                
                # Get colors based on state
                $itemBg = if ($isFocused) {
                    [ConsoleColor]::Cyan
                } else {
                    [ConsoleColor]::Black
                }
                
                $prefixFg = if ($isFocused) {
                    [ConsoleColor]::Black
                } else {
                    [ConsoleColor]::Cyan
                }
                
                $keyFg = if (-not $item.Enabled) {
                    [ConsoleColor]::DarkGray
                } elseif ($isFocused) {
                    [ConsoleColor]::Black
                } else {
                    [ConsoleColor]::Cyan
                }
                
                $labelFg = if (-not $item.Enabled) {
                    [ConsoleColor]::DarkGray
                } elseif ($isFocused) {
                    [ConsoleColor]::Black
                } else {
                    [ConsoleColor]::White
                }
                
                # Draw selection highlight background
                $highlightText = ' ' * $this.Width
                $this._private_buffer.WriteString(0, $i, $highlightText, $labelFg, $itemBg)
                
                # Draw selection prefix
                $prefix = if ($isSelected) { "> " } else { "  " }
                $this._private_buffer.WriteString(0, $i, $prefix, $prefixFg, $itemBg)
                
                # Draw hotkey
                $keyText = "[$($item.Key)]"
                $this._private_buffer.WriteString(2, $i, $keyText, $keyFg, $itemBg)
                
                # Draw label
                $labelX = 2 + $keyText.Length + 1
                $maxLabelWidth = $this.Width - $labelX
                $labelText = $item.Label
                if ($labelText.Length -gt $maxLabelWidth) {
                    $labelText = $labelText.Substring(0, $maxLabelWidth - 3) + "..."
                }
                $this._private_buffer.WriteString($labelX, $i, $labelText, $labelFg, $itemBg)
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($null -eq $keyInfo) { return $false }
        try {
            $visibleItems = @($this.Items | Where-Object { $_.Visible })
            if ($visibleItems.Count -eq 0) {
                return $false
            }
            
            # Handle direct hotkey access
            $keyChar = $keyInfo.KeyChar.ToString().ToUpper()
            $hotkeyItem = $visibleItems | Where-Object { $_.Key -eq $keyChar -and $_.Enabled }
            if ($hotkeyItem) {
                $hotkeyItem.Execute()
                return $true
            }
            
            # Handle navigation keys
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Enter) {
                    $this.ExecuteSelectedItem()
                    return $true
                }
                ([ConsoleKey]::UpArrow) {
                    if ($this.Orientation -eq "Vertical") {
                        $this._MovePrevious($visibleItems)
                        return $true
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.Orientation -eq "Vertical") {
                        $this._MoveNext($visibleItems)
                        return $true
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($this.Orientation -eq "Horizontal") {
                        $this._MovePrevious($visibleItems)
                        return $true
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.Orientation -eq "Horizontal") {
                        $this._MoveNext($visibleItems)
                        return $true
                    }
                }
                ([ConsoleKey]::Home) {
                    $this.SelectedIndex = 0
                    $this.RequestRedraw()
                    return $true
                }
                ([ConsoleKey]::End) {
                    $this.SelectedIndex = $visibleItems.Count - 1
                    $this.RequestRedraw()
                    return $true
                }
            }
            
            return $false
        }
        catch {
            return $false
        }
    }

    hidden [void] _MovePrevious([NavigationItem[]]$items) {
        do {
            $this.SelectedIndex = if ($this.SelectedIndex -le 0) { $items.Count - 1 } else { $this.SelectedIndex - 1 }
        } while ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $items.Count -and (-not $items[$this.SelectedIndex].Enabled -or $items[$this.SelectedIndex].Key -eq "-"))
        
        $this.RequestRedraw()
    }

    hidden [void] _MoveNext([NavigationItem[]]$items) {
        do {
            $this.SelectedIndex = if ($this.SelectedIndex -ge ($items.Count - 1)) { 0 } else { $this.SelectedIndex + 1 }
        } while ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $items.Count -and (-not $items[$this.SelectedIndex].Enabled -or $items[$this.SelectedIndex].Key -eq "-"))
        
        $this.RequestRedraw()
    }

    [void] OnFocus() {
        ([UIElement]$this).OnFocus()
        $this.RequestRedraw()
    }

    [void] OnBlur() {
        ([UIElement]$this).OnBlur()
        $this.RequestRedraw()
    }
}

#endregion

#region ListBox Component

class ListBox : UIElement {
    [System.Collections.Generic.List[string]] $Items
    [int] $SelectedIndex = -1
    $BackgroundColor = [ConsoleColor]::Black
    $ForegroundColor = [ConsoleColor]::White
    $SelectedBackgroundColor = [ConsoleColor]::Blue
    $SelectedForegroundColor = [ConsoleColor]::White
    [int] $ScrollOffset = 0
    
    ListBox([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Items = [System.Collections.Generic.List[string]]::new()
        $this.IsFocusable = $true
    }
    
    [void] AddItem([string]$item) {
        $this.Items.Add($item)
        if ($this.SelectedIndex -eq -1 -and $this.Items.Count -eq 1) {
            $this.SelectedIndex = 0
        }
        $this.RequestRedraw()
    }
    
    [void] ClearItems() {
        $this.Items.Clear()
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.RequestRedraw()
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $this._private_buffer.Clear([TuiCell]::new(' ', $this.ForegroundColor, $this.BackgroundColor))
        
        $visibleItems = [Math]::Min($this.Height, $this.Items.Count - $this.ScrollOffset)
        
        for ($i = 0; $i -lt $visibleItems; $i++) {
            $itemIndex = $i + $this.ScrollOffset
            $item = $this.Items[$itemIndex]
            
            $isSelected = ($itemIndex -eq $this.SelectedIndex)
            $fg = if ($isSelected) { $this.SelectedForegroundColor } else { $this.ForegroundColor }
            $bg = if ($isSelected) { $this.SelectedBackgroundColor } else { $this.BackgroundColor }
            
            # Fill the entire line with background color
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this._private_buffer.SetCell($x, $i, [TuiCell]::new(' ', $fg, $bg))
            }
            
            # Draw the text
            $displayText = if ($item.Length -gt $this.Width) { 
                $item.Substring(0, $this.Width - 3) + "..."
            } else { 
                $item 
            }
            $this._private_buffer.WriteString(0, $i, $displayText, $fg, $bg)
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.Items.Count -eq 0) { return $false }
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $this.EnsureVisible()
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    $this.EnsureVisible()
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.ScrollOffset = 0
                $this.RequestRedraw()
                return $true
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.EnsureVisible()
                $this.RequestRedraw()
                return $true
            }
        }
        return $false
    }
    
    hidden [void] EnsureVisible() {
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        }
        elseif ($this.SelectedIndex -ge $this.ScrollOffset + $this.Height) {
            $this.ScrollOffset = $this.SelectedIndex - $this.Height + 1
        }
    }
}

#endregion

#region TextBox Component

class TextBox : TextBoxComponent {
    # Wrapper class to match CommandPalette's expectations
    
    TextBox([int]$x, [int]$y, [int]$width, [string]$placeholder) : base("TextBox") {
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = 3
        $this.Placeholder = $placeholder
    }
    
    [void] Clear() {
        $this.Text = ""
        $this.CursorPosition = 0
        $this.RequestRedraw()
    }
    
    [void] Focus() {
        $this.IsFocused = $true
        $global:TuiState.FocusedComponent = $this
        $this.RequestRedraw()
    }
}

#endregion

#region CommandPalette Component

class CommandPalette : UIElement {
    hidden [ListBox] $_listBox
    hidden [TextBox] $_searchBox
    hidden [Panel] $_panel
    hidden [object] $_actionService  # ActionService - type not available at parse time
    hidden [System.Collections.Generic.List[hashtable]] $_filteredActions
    hidden [bool] $_isVisible = $false
    
    CommandPalette([object]$actionService) : base("CommandPalette") {
        $this._actionService = $actionService
        $this.IsFocusable = $true
        $this.ZIndex = 1000  # Always on top
        
        # Size and position (centered overlay)
        $this.Width = 60
        $this.Height = 20
        
        # Create panel
        $this._panel = [Panel]::new(0, 0, $this.Width, $this.Height, "Command Palette")
        $this._panel.BorderStyle = "Double"
        $this._panel.BorderColor = "#00FF00"  # Truecolor green
        $this._panel.BackgroundColor = "#1a1a1a"  # Dark background
        $this._panel.TitleColor = "#FFFF00"  # Yellow title
        $this.AddChild($this._panel)
        
        # Create search box
        $this._searchBox = [TextBox]::new(2, 2, $this.Width - 4, "Search commands...")
        $this._searchBox.BackgroundColor = "#2a2a2a"
        $this._searchBox.ForegroundColor = "#FFFFFF"
        $this._panel.AddChild($this._searchBox)
        
        # Create list box
        $this._listBox = [ListBox]::new(2, 4, $this.Width - 4, $this.Height - 5)
        $this._listBox.BackgroundColor = "#1a1a1a"
        $this._listBox.ForegroundColor = "#CCCCCC"
        $this._listBox.SelectedBackgroundColor = "#0066CC"
        $this._listBox.SelectedForegroundColor = "#FFFFFF"
        $this._panel.AddChild($this._listBox)
        
        $this.RefreshActions()
    }
    
    [void] Show() {
        # Center on screen
        $screenWidth = $global:TuiState.BufferWidth
        $screenHeight = $global:TuiState.BufferHeight
        $this.X = [Math]::Max(0, ($screenWidth - $this.Width) / 2)
        $this.Y = [Math]::Max(0, ($screenHeight - $this.Height) / 2)
        
        $this._isVisible = $true
        $this.Visible = $true
        $this._searchBox.Clear()
        $this._searchBox.Focus()
        $this.RefreshActions()
        $this.RequestRedraw()
        
        # Request immediate redraw
        $global:TuiState.IsDirty = $true
    }
    
    [void] Hide() {
        $this._isVisible = $false
        $this.Visible = $false
        $this.RequestRedraw()
        $global:TuiState.IsDirty = $true
    }
    
    [void] RefreshActions([string]$filter = "") {
        $allActions = $this._actionService.GetAllActions()
        
        if ([string]::IsNullOrWhiteSpace($filter)) {
            $this._filteredActions = $allActions
        } else {
            $this._filteredActions = $allActions | Where-Object {
                $_.Name -like "*$filter*" -or $_.Description -like "*$filter*"
            }
        }
        
        $this._listBox.ClearItems()
        foreach ($action in $this._filteredActions) {
            $this._listBox.AddItem("$($action.Name) - $($action.Description)")
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if (-not $this._isVisible) { return $false }
        
        switch ($keyInfo.Key) {
            'Escape' {
                $this.Hide()
                return $true
            }
            'Enter' {
                if ($this._listBox.SelectedIndex -ge 0 -and $this._listBox.SelectedIndex -lt $this._filteredActions.Count) {
                    $selectedAction = $this._filteredActions[$this._listBox.SelectedIndex]
                    $this.Hide()
                    $this._actionService.ExecuteAction($selectedAction.Name)
                }
                return $true
            }
            'UpArrow' {
                $this._listBox.HandleInput($keyInfo)
                return $true
            }
            'DownArrow' {
                $this._listBox.HandleInput($keyInfo)
                return $true
            }
            default {
                # Pass to search box
                $oldText = $this._searchBox.Text
                $this._searchBox.HandleInput($keyInfo)
                if ($this._searchBox.Text -ne $oldText) {
                    $this.RefreshActions($this._searchBox.Text)
                }
                return $true
            }
        }
        return $false  # Fallback return value
    }
}

#endregion

#region Panel Classes

class Panel : UIElement {
    [string] $Title = ""
    [string] $BorderStyle = "Single"
    $BorderColor = [ConsoleColor]::Gray  # Supports ConsoleColor or hex string
    $BackgroundColor = [ConsoleColor]::Black  # Supports ConsoleColor or hex string
    $TitleColor = [ConsoleColor]::White  # Supports ConsoleColor or hex string
    [bool] $HasBorder = $true
    [bool] $CanFocus = $false
    [int] $ContentX = 0
    [int] $ContentY = 0
    [int] $ContentWidth = 0
    [int] $ContentHeight = 0
    [string] $LayoutType = "Manual"

    Panel() : base() {
        $this.Name = "Panel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    Panel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.Name = "Panel_$(Get-Random -Maximum 1000)"
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    Panel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height) {
        $this.Name = "Panel_$(Get-Random -Maximum 1000)"
        $this.Title = $title
        $this.IsFocusable = $false
        $this.UpdateContentBounds()
    }

    [void] UpdateContentBounds() {
        if ($this.HasBorder) {
            $this.ContentX = 1
            $this.ContentY = 1
            $this.ContentWidth = [Math]::Max(0, $this.Width - 2)
            $this.ContentHeight = [Math]::Max(0, $this.Height - 2)
        } else {
            $this.ContentX = 0
            $this.ContentY = 0
            $this.ContentWidth = $this.Width
            $this.ContentHeight = $this.Height
        }
    }
    
    [void] ClearContent() {
        if (-not $this._private_buffer) { return }
        
        for ($y = $this.ContentY; $y -lt ($this.ContentY + $this.ContentHeight); $y++) {
            for ($x = $this.ContentX; $x -lt ($this.ContentX + $this.ContentWidth); $x++) {
                $this._private_buffer.SetCell($x, $y, [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor))
            }
        }
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        ([UIElement]$this).OnResize($newWidth, $newHeight) 
        $this.UpdateContentBounds()
        $this.PerformLayout()
    }

    [void] PerformLayout() {
        try {
            if ($this.Children.Count -eq 0) { return }
            switch ($this.LayoutType) {
                "Vertical" { $this.LayoutVertical() }
                "Horizontal" { $this.LayoutHorizontal() }
                "Grid" { $this.LayoutGrid() }
                "Manual" { }
                default { }
            }
        }
        catch {}
    }

    hidden [void] LayoutVertical() {
        if ($this.Children.Count -eq 0) { return }
        
        $y = $this.ContentY
        $spacing = 1
        
        foreach ($child in $this.Children | Where-Object { $_.Visible }) {
            $child.X = $this.ContentX
            $child.Y = $y
            $child.Width = $this.ContentWidth
            $y += $child.Height + $spacing
        }
    }

    hidden [void] LayoutHorizontal() {
        if ($this.Children.Count -eq 0) { return }
        
        $x = $this.ContentX
        $spacing = 1
        
        foreach ($child in $this.Children | Where-Object { $_.Visible }) {
            $child.X = $x
            $child.Y = $this.ContentY
            $x += $child.Width + $spacing
        }
    }

    hidden [void] LayoutGrid() {
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor))
            
            if ($this.HasBorder) {
                for ($x = 0; $x -lt $this.Width; $x++) {
                    $this._private_buffer.SetCell($x, 0, [TuiCell]::new('-', $this.BorderColor, $this.BackgroundColor))
                    $this._private_buffer.SetCell($x, $this.Height - 1, [TuiCell]::new('-', $this.BorderColor, $this.BackgroundColor))
                }
                for ($y = 0; $y -lt $this.Height; $y++) {
                    $this._private_buffer.SetCell(0, $y, [TuiCell]::new('|', $this.BorderColor, $this.BackgroundColor))
                    $this._private_buffer.SetCell($this.Width - 1, $y, [TuiCell]::new('|', $this.BorderColor, $this.BackgroundColor))
                }
                
                $this._private_buffer.SetCell(0, 0, [TuiCell]::new('+', $this.BorderColor, $this.BackgroundColor))
                $this._private_buffer.SetCell($this.Width - 1, 0, [TuiCell]::new('+', $this.BorderColor, $this.BackgroundColor))
                $this._private_buffer.SetCell(0, $this.Height - 1, [TuiCell]::new('+', $this.BorderColor, $this.BackgroundColor))
                $this._private_buffer.SetCell($this.Width - 1, $this.Height - 1, [TuiCell]::new('+', $this.BorderColor, $this.BackgroundColor))
                
                if (-not [string]::IsNullOrEmpty($this.Title)) {
                    $titleText = " $($this.Title) "
                    $titleX = [Math]::Floor(($this.Width - $titleText.Length) / 2)
                    if ($titleX -lt 1) { $titleX = 1 }
                    $this._private_buffer.WriteString($titleX, 0, $titleText, $this.TitleColor, $this.BackgroundColor)
                }
            }
        }
        catch {}
    }
}

class ScrollablePanel : Panel {
    [int] $ScrollOffsetY = 0
    [int] $MaxScrollY = 0
    [int] $ScrollbarWidth = 1
    [bool] $ShowScrollbar = $true
    [ConsoleColor] $ScrollbarColor = [ConsoleColor]::DarkGray
    [ConsoleColor] $ScrollbarThumbColor = [ConsoleColor]::Gray

    ScrollablePanel() : base() {
        $this.IsFocusable = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height) : base($x, $y, $width, $height) {
        $this.IsFocusable = $true
    }

    ScrollablePanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.IsFocusable = $true
    }

    [void] UpdateContentBounds() {
        ([Panel]$this).UpdateContentBounds()
        if ($this.ShowScrollbar -and $this.ContentWidth -gt 0) {
            $this.ContentWidth -= $this.ScrollbarWidth
        }
    }

    [void] UpdateMaxScroll() {
        $totalContentHeight = 0
        foreach ($child in $this.Children | Where-Object { $_.Visible }) {
            $childBottom = $child.Y + $child.Height
            if ($childBottom -gt $totalContentHeight) {
                $totalContentHeight = $childBottom
            }
        }
        $this.MaxScrollY = [Math]::Max(0, $totalContentHeight - $this.ContentHeight)
    }

    [void] ScrollUp([int]$lines = 1) {
        $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY - $lines)
        $this.RequestRedraw()
    }

    [void] ScrollDown([int]$lines = 1) {
        $this.UpdateMaxScroll()
        $this.ScrollOffsetY = [Math]::Min($this.MaxScrollY, $this.ScrollOffsetY + $lines)
        $this.RequestRedraw()
    }

    [void] ScrollToTop() {
        $this.ScrollOffsetY = 0
        $this.RequestRedraw()
    }

    [void] ScrollToBottom() {
        $this.UpdateMaxScroll()
        $this.ScrollOffsetY = $this.MaxScrollY
        $this.RequestRedraw()
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.ScrollUp()
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                $this.ScrollDown()
                return $true
            }
            ([ConsoleKey]::PageUp) {
                $this.ScrollUp($this.ContentHeight)
                return $true
            }
            ([ConsoleKey]::PageDown) {
                $this.ScrollDown($this.ContentHeight)
                return $true
            }
            ([ConsoleKey]::Home) {
                $this.ScrollToTop()
                return $true
            }
            ([ConsoleKey]::End) {
                $this.ScrollToBottom()
                return $true
            }
        }
        
        return $false
    }

    [void] OnRender() {
        ([Panel]$this).OnRender()
        
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this.UpdateMaxScroll()
            
            if ($this.ShowScrollbar -and $this.MaxScrollY -gt 0) {
                $scrollbarX = $this.Width - $this.ScrollbarWidth
                if ($this.HasBorder) { $scrollbarX-- }
                
                $scrollbarStartY = if ($this.HasBorder) { 1 } else { 0 }
                $scrollbarHeight = if ($this.HasBorder) { $this.Height - 2 } else { $this.Height }
                
                for ($y = $scrollbarStartY; $y -lt $scrollbarStartY + $scrollbarHeight; $y++) {
                    $this._private_buffer.SetCell($scrollbarX, $y, [TuiCell]::new('│', $this.ScrollbarColor, $this.BackgroundColor))
                }
                
                $thumbHeight = [Math]::Max(1, [Math]::Floor($scrollbarHeight * ($this.ContentHeight / ($this.MaxScrollY + $this.ContentHeight))))
                $thumbPosition = [Math]::Floor($scrollbarHeight * ($this.ScrollOffsetY / ($this.MaxScrollY + $this.ContentHeight)))
                
                for ($y = 0; $y -lt $thumbHeight; $y++) {
                    $thumbY = $scrollbarStartY + $thumbPosition + $y
                    if ($thumbY -lt $scrollbarStartY + $scrollbarHeight) {
                        $this._private_buffer.SetCell($scrollbarX, $thumbY, [TuiCell]::new('█', $this.ScrollbarThumbColor, $this.BackgroundColor))
                    }
                }
            }
        }
        catch {}
    }

    hidden [void] _RenderContent() {
        $originalPositions = @{}
        
        foreach ($child in $this.Children) {
            $originalPositions[$child] = @{ Y = $child.Y }
            $child.Y -= $this.ScrollOffsetY
        }
        
        try {
            ([UIElement]$this)._RenderContent()
        }
        finally {
            foreach ($kvp in $originalPositions.GetEnumerator()) {
                $kvp.Key.Y = $kvp.Value.Y
            }
        }
    }
}

class GroupPanel : Panel {
    [hashtable] $GroupStyle = @{
        BorderColor = [ConsoleColor]::DarkGray
        TitleColor = [ConsoleColor]::Cyan
        BorderStyle = "Single"
    }

    GroupPanel() : base() {
        $this.ApplyGroupStyle()
    }

    GroupPanel([int]$x, [int]$y, [int]$width, [int]$height, [string]$title) : base($x, $y, $width, $height, $title) {
        $this.ApplyGroupStyle()
    }

    [void] ApplyGroupStyle() {
        $this.BorderColor = $this.GroupStyle.BorderColor
        $this.TitleColor = $this.GroupStyle.TitleColor
        $this.BorderStyle = $this.GroupStyle.BorderStyle
        $this.HasBorder = $true
    }
}

#endregion


####\AllFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================

#region TUI Drawing Functions

function Write-TuiText {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][string]$Text,
        [object]$ForegroundColor = [ConsoleColor]::White,
        [object]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false,
        [bool]$Italic = $false,
        [int]$ZIndex = 0
    )
    
    try {
        if ($Y -lt 0 -or $Y -ge $Buffer.Height) {
            Write-Warning "Write-TuiText: Y coordinate ($Y) is out of bounds for buffer '$($Buffer.Name)' (0..$($Buffer.Height-1)). Text: '$Text'."
            return
        }
        
        $currentX = $X
        foreach ($char in $Text.ToCharArray()) {
            if ($currentX -ge $Buffer.Width) { break }
            if ($currentX -ge 0) {
                $cell = [TuiCell]::new($char, $ForegroundColor, $BackgroundColor, $Bold, $Underline)
                $cell.Italic = $Italic
                $cell.ZIndex = $ZIndex
                $Buffer.SetCell($currentX, $Y, $cell)
            }
            $currentX++
        }
        
        Write-Verbose "Write-TuiText: Wrote '$Text' to buffer '$($Buffer.Name)' at ($X, $Y)."
    }
    catch {
        Write-Error "Failed to write text to buffer '$($Buffer.Name)' at ($X, $Y): $($_.Exception.Message)"
        throw
    }
}

function Write-TuiBox {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [ValidateSet("Single", "Double", "Rounded", "Thick")][string]$BorderStyle = "Single",
        [object]$BorderColor = [ConsoleColor]::White,
        [object]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    try {
        if ($Width -le 0 -or $Height -le 0) {
            Write-Warning "Write-TuiBox: Invalid dimensions ($($Width)x$($Height)). Dimensions must be positive."
            return
        }
        
        $borders = Get-TuiBorderChars -Style $BorderStyle
        
        # Calculate effective drawing area
        $drawStartX = [Math]::Max(0, $X)
        $drawStartY = [Math]::Max(0, $Y)
        $drawEndX = [Math]::Min($Buffer.Width, $X + $Width)
        $drawEndY = [Math]::Min($Buffer.Height, $Y + $Height)
        
        if ($drawEndX -le $drawStartX -or $drawEndY -le $drawStartY) {
            Write-Verbose "Write-TuiBox: Effective drawing area is invalid after clipping. Skipping."
            return
        }
        
        # Fill background
        $fillCell = [TuiCell]::new(' ', $BorderColor, $BackgroundColor)
        for ($currentY = $drawStartY; $currentY -lt $drawEndY; $currentY++) {
            for ($currentX = $drawStartX; $currentX -lt $drawEndX; $currentX++) {
                $Buffer.SetCell($currentX, $currentY, [TuiCell]::new($fillCell))
            }
        }
        
        # Draw corners
        if ($X -ge 0 -and $Y -ge 0) { 
            $Buffer.SetCell($X, $Y, [TuiCell]::new($borders.TopLeft, $BorderColor, $BackgroundColor))
        }
        if (($X + $Width - 1) -lt $Buffer.Width -and $Y -ge 0) { 
            $Buffer.SetCell($X + $Width - 1, $Y, [TuiCell]::new($borders.TopRight, $BorderColor, $BackgroundColor))
        }
        if ($X -ge 0 -and ($Y + $Height - 1) -lt $Buffer.Height) { 
            $Buffer.SetCell($X, $Y + $Height - 1, [TuiCell]::new($borders.BottomLeft, $BorderColor, $BackgroundColor))
        }
        if (($X + $Width - 1) -lt $Buffer.Width -and ($Y + $Height - 1) -lt $Buffer.Height) { 
            $Buffer.SetCell($X + $Width - 1, $Y + $Height - 1, [TuiCell]::new($borders.BottomRight, $BorderColor, $BackgroundColor))
        }
        
        # Draw horizontal borders
        for ($cx = 1; $cx -lt ($Width - 1); $cx++) {
            if (($X + $cx) -ge 0 -and ($X + $cx) -lt $Buffer.Width) {
                if ($Y -ge 0 -and $Y -lt $Buffer.Height) { 
                    $Buffer.SetCell($X + $cx, $Y, [TuiCell]::new($borders.Horizontal, $BorderColor, $BackgroundColor))
                }
                if ($Height -gt 1 -and ($Y + $Height - 1) -ge 0 -and ($Y + $Height - 1) -lt $Buffer.Height) { 
                    $Buffer.SetCell($X + $cx, $Y + $Height - 1, [TuiCell]::new($borders.Horizontal, $BorderColor, $BackgroundColor))
                }
            }
        }
        
        # Draw vertical borders
        for ($cy = 1; $cy -lt ($Height - 1); $cy++) {
            if (($Y + $cy) -ge 0 -and ($Y + $cy) -lt $Buffer.Height) {
                if ($X -ge 0 -and $X -lt $Buffer.Width) { 
                    $Buffer.SetCell($X, $Y + $cy, [TuiCell]::new($borders.Vertical, $BorderColor, $BackgroundColor))
                }
                if ($Width -gt 1 -and ($X + $Width - 1) -ge 0 -and ($X + $Width - 1) -lt $Buffer.Width) { 
                    $Buffer.SetCell($X + $Width - 1, $Y + $cy, [TuiCell]::new($borders.Vertical, $BorderColor, $BackgroundColor))
                }
            }
        }
        
        # Draw title if provided
        if (-not [string]::IsNullOrEmpty($Title) -and $Y -ge 0 -and $Y -lt $Buffer.Height) {
            $titleText = " $Title "
            if ($titleText.Length -le ($Width - 2)) { 
                $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
                Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
            }
        }
        
        Write-Verbose "Write-TuiBox: Drew '$BorderStyle' box on buffer '$($Buffer.Name)' at ($X, $Y) with dimensions $($Width)x$($Height)."
    }
    catch {
        Write-Error "Failed to draw TUI box on buffer '$($Buffer.Name)' at ($X, $Y), $($Width)x$($Height): $($_.Exception.Message)"
        throw
    }
}

function Get-TuiBorderChars {
    [CmdletBinding()]
    param(
        [ValidateSet("Single", "Double", "Rounded", "Thick")][string]$Style = "Single"
    )
    
    try {
        $styles = @{
            Single = @{ 
                TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'; 
                Horizontal = '─'; Vertical = '│' 
            }
            Double = @{ 
                TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'; 
                Horizontal = '═'; Vertical = '║' 
            }
            Rounded = @{ 
                TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'; 
                Horizontal = '─'; Vertical = '│' 
            }
            Thick = @{ 
                TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'; 
                Horizontal = '━'; Vertical = '┃' 
            }
        }
        
        $selectedStyle = $styles[$Style]
        if ($null -eq $selectedStyle) {
            Write-Warning "Get-TuiBorderChars: Border style '$Style' not found. Returning 'Single' style."
            return $styles.Single
        }
        
        Write-Verbose "Get-TuiBorderChars: Retrieved TUI border characters for style: $Style."
        return $selectedStyle
    }
    catch {
        Write-Error "Failed to get TUI border characters for style '$Style': $($_.Exception.Message)"
        throw
    }
}

#endregion

#region Factory Functions

function New-TuiBuffer {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [string]$Name = "Unnamed"
    )
    return [TuiBuffer]::new($Width, $Height, $Name)
}

function New-TuiLabel {
    [CmdletBinding()]
    param([hashtable]$Props = @{})
    
    try {
        $labelName = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        $label = [LabelComponent]::new($labelName)
        
        $Props.GetEnumerator() | ForEach-Object {
            if ($label.PSObject.Properties.Match($_.Name)) {
                $label.($_.Name) = $_.Value
            }
        }
        
        Write-Verbose "Created label '$labelName' with $($Props.Count) properties"
        return $label
    }
    catch {
        Write-Error "Failed to create label: $($_.Exception.Message)"
        throw
    }
}

function New-TuiButton {
    [CmdletBinding()]
    param([hashtable]$Props = @{})
    
    try {
        $buttonName = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        $button = [ButtonComponent]::new($buttonName)
        
        $Props.GetEnumerator() | ForEach-Object {
            if ($button.PSObject.Properties.Match($_.Name)) {
                $button.($_.Name) = $_.Value
            }
        }
        
        Write-Verbose "Created button '$buttonName' with $($Props.Count) properties"
        return $button
    }
    catch {
        Write-Error "Failed to create button: $($_.Exception.Message)"
        throw
    }
}

function New-TuiTextBox {
    [CmdletBinding()]
    param([hashtable]$Props = @{})
    
    try {
        $textBoxName = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        $textBox = [TextBoxComponent]::new($textBoxName)
        
        $Props.GetEnumerator() | ForEach-Object {
            if ($textBox.PSObject.Properties.Match($_.Name)) {
                $textBox.($_.Name) = $_.Value
            }
        }
        
        Write-Verbose "Created textbox '$textBoxName' with $($Props.Count) properties"
        return $textBox
    }
    catch {
        Write-Error "Failed to create textbox: $($_.Exception.Message)"
        throw
    }
}

function New-TuiCheckBox {
    [CmdletBinding()]
    param([hashtable]$Props = @{})
    
    try {
        $checkBoxName = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        $checkBox = [CheckBoxComponent]::new($checkBoxName)
        
        $Props.GetEnumerator() | ForEach-Object {
            if ($checkBox.PSObject.Properties.Match($_.Name)) {
                $checkBox.($_.Name) = $_.Value
            }
        }
        
        Write-Verbose "Created checkbox '$checkBoxName' with $($Props.Count) properties"
        return $checkBox
    }
    catch {
        Write-Error "Failed to create checkbox: $($_.Exception.Message)"
        throw
    }
}

function New-TuiRadioButton {
    [CmdletBinding()]
    param([hashtable]$Props = @{})
    
    try {
        $radioButtonName = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        $radioButton = [RadioButtonComponent]::new($radioButtonName)
        
        $Props.GetEnumerator() | ForEach-Object {
            if ($radioButton.PSObject.Properties.Match($_.Name)) {
                $radioButton.($_.Name) = $_.Value
            }
        }
        
        Write-Verbose "Created radio button '$radioButtonName' with $($Props.Count) properties"
        return $radioButton
    }
    catch {
        Write-Error "Failed to create radio button: $($_.Exception.Message)"
        throw
    }
}

#endregion

#region Theme Functions

function Get-ThemeColor {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$ColorName
    )
    
    if ($global:TuiState.Services.ThemeManager) {
        return $global:TuiState.Services.ThemeManager.GetColor($ColorName)
    }
    
    # Fallback if theme manager not available
    $defaultTheme = @{
        'Foreground' = [ConsoleColor]::White
        'Background' = [ConsoleColor]::Black
        'Accent' = [ConsoleColor]::Cyan
        'Header' = [ConsoleColor]::Cyan
        'Subtle' = [ConsoleColor]::DarkGray
        'Highlight' = [ConsoleColor]::Yellow
        'Border' = [ConsoleColor]::Gray
        'Selection' = [ConsoleColor]::DarkBlue
        'button.normal.background' = [ConsoleColor]::Black
        'button.normal.foreground' = [ConsoleColor]::White
        'button.normal.border' = [ConsoleColor]::Gray
        'button.focus.background' = [ConsoleColor]::Black
        'button.focus.foreground' = [ConsoleColor]::White
        'button.focus.border' = [ConsoleColor]::Cyan
        'button.pressed.background' = [ConsoleColor]::DarkGray
        'button.pressed.foreground' = [ConsoleColor]::Black
        'button.pressed.border' = [ConsoleColor]::Cyan
    }
    
    return $defaultTheme[$ColorName] ?? [ConsoleColor]::White
}

#endregion

#region Utility Functions

function Set-ComponentFocus {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][UIElement]$Component
    )
    
    # Find parent screen/container and clear other focus
    $parent = $Component.Parent
    while ($parent -and -not ($parent -is [Screen])) {
        $parent = $parent.Parent
    }
    
    if ($parent) {
        # Clear focus from all other focusable components
        $parent.Children | ForEach-Object {
            if ($_.IsFocusable -and $_.IsFocused -and $_ -ne $Component) {
                $_.IsFocused = $false
                $_.OnBlur()
                $_.RequestRedraw()
            }
        }
    }
    
    # Set focus on target component
    if ($Component.IsFocusable) {
        $Component.IsFocused = $true
        $Component.OnFocus()
        $Component.RequestRedraw()
        Write-Verbose "Set focus to component: $($Component.Name)"
    } else {
        Write-Warning "Component '$($Component.Name)' is not focusable"
    }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Message,
        [ValidateSet('Info', 'Warning', 'Error', 'Debug')]
        [string]$Level = 'Info'
    )
    
    # Simplified logging - in full app this would use Logger service
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    $logMessage = "[$timestamp] [$Level] $Message"
    
    switch ($Level) {
        'Error' { Write-Error $logMessage }
        'Warning' { Write-Warning $logMessage }
        'Debug' { Write-Debug $logMessage }
        default { Write-Verbose $logMessage }
    }
}

#endregion

#region Event System

function Subscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [Parameter(Mandatory)][scriptblock]$Handler,
        [string]$Source = ""
    )
    
    if ($global:TuiState.Services.EventManager) {
        return $global:TuiState.Services.EventManager.Subscribe($EventName, $Handler)
    }
    
    # Fallback
    $subscriptionId = [Guid]::NewGuid().ToString()
    Write-Verbose "Subscribed to event '$EventName' with handler ID: $subscriptionId"
    return $subscriptionId
}

function Unsubscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [Parameter(Mandatory)][string]$HandlerId
    )
    
    if ($global:TuiState.Services.EventManager) {
        $global:TuiState.Services.EventManager.Unsubscribe($EventName, $HandlerId)
    }
    Write-Verbose "Unsubscribed from event '$EventName' (Handler ID: $HandlerId)"
}

function Publish-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [hashtable]$EventData = @{}
    )
    
    if ($global:TuiState.Services.EventManager) {
        $global:TuiState.Services.EventManager.Publish($EventName, $EventData)
    }
    Write-Verbose "Published event '$EventName' with data: $($EventData | ConvertTo-Json -Compress)"
}

#endregion


####\AllModels.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Models (No UI Dependencies)
# Data models, enums, and validation classes
# ==============================================================================

#region Enums

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

enum BillingType {
    Billable
    NonBillable
}

#endregion

#region Base Validation Class

# ===== CLASS: ValidationBase =====
# Module: models (from axiom)
# Dependencies: None
# Purpose: Provides common validation methods used across model classes
class ValidationBase {
    # Validates that a string value is not null, empty, or whitespace.
    # Throws an ArgumentException if the validation fails.
    static [void] ValidateNotEmpty(
        [string]$value,
        [string]$parameterName
    ) {
        try {
            if ([string]::IsNullOrWhiteSpace($value)) {
                $errorMessage = "Parameter '$($parameterName)' cannot be null or empty."
                throw [System.ArgumentException]::new($errorMessage, $parameterName)
            }
        }
        catch {
            # Re-throw to ensure calling context handles the exception
            throw
        }
    }
}

#endregion

#region Core Model Classes

# ===== CLASS: PmcTask =====
# Module: models (from axiom)
# Dependencies: ValidationBase, TaskStatus, TaskPriority enums
# Purpose: Represents a single task with lifecycle methods
class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString() # Unique identifier for the task
    [string]$Title                            # Short descriptive title
    [string]$Description                      # Detailed description
    [TaskStatus]$Status = [TaskStatus]::Pending # Current status of the task
    [TaskPriority]$Priority = [TaskPriority]::Medium # Importance level
    [string]$ProjectKey = "General"           # Associated project (key)
    [string]$Category                         # Alias for ProjectKey, for broader use
    [datetime]$CreatedAt = [datetime]::Now   # Timestamp of creation
    [datetime]$UpdatedAt = [datetime]::Now   # Last update timestamp
    [Nullable[datetime]]$DueDate             # Optional due date
    [string[]]$Tags = @()                     # Array of tags
    [int]$Progress = 0                        # Progress percentage (0-100)
    [bool]$Completed = $false                 # Convenience flag for completed status

    # Default constructor: Initializes a new task with default values.
    PmcTask() {}
    
    # Constructor: Initializes a new task with a title.
    PmcTask([string]$title) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title
    }
    
    # Constructor: Initializes a new task with common detailed properties.
    PmcTask(
        [string]$title,
        [string]$description,
        [TaskPriority]$priority,
        [string]$projectKey
    ) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")

        $this.Title = $title
        $this.Description = $description
        $this.Priority = $priority
        $this.ProjectKey = $projectKey
        $this.Category = $projectKey # Category is often an alias for ProjectKey
    }

    # Complete: Marks the task as completed, setting progress to 100% and updating timestamp.
    [void] Complete() {
        $this.Status = [TaskStatus]::Completed
        $this.Progress = 100
        $this.Completed = $true
        $this.UpdatedAt = [datetime]::Now
    }
    
    # Cancel: Marks the task as cancelled and updates timestamp.
    [void] Cancel() {
        $this.Status = [TaskStatus]::Cancelled
        $this.UpdatedAt = [datetime]::Now
    }
    
    # SetProgress: Updates the progress percentage and adjusts status accordingly.
    [void] SetProgress([int]$progress) {
        if ($progress -lt 0 -or $progress -gt 100) {
            throw [System.ArgumentOutOfRangeException]::new("progress", "Progress must be between 0 and 100.")
        }
        
        $this.Progress = $progress
        
        # Auto-update status based on progress
        if ($progress -eq 0 -and $this.Status -eq [TaskStatus]::InProgress) {
            $this.Status = [TaskStatus]::Pending
        }
        elseif ($progress -gt 0 -and $progress -lt 100) {
            $this.Status = [TaskStatus]::InProgress
        }
        elseif ($progress -eq 100) {
            $this.Complete()
        }
        
        $this.UpdatedAt = [datetime]::Now
    }
    
    # AddTag: Adds a tag to the task if not already present.
    [void] AddTag([string]$tag) {
        [ValidationBase]::ValidateNotEmpty($tag, "Tag")
        if ($this.Tags -notcontains $tag) {
            $this.Tags += $tag
            $this.UpdatedAt = [datetime]::Now
        }
    }
    
    # RemoveTag: Removes a tag from the task.
    [void] RemoveTag([string]$tag) {
        $this.Tags = $this.Tags | Where-Object { $_ -ne $tag }
        $this.UpdatedAt = [datetime]::Now
    }
    
    # GetAge: Returns the age of the task as a TimeSpan.
    [TimeSpan] GetAge() {
        return [datetime]::Now - $this.CreatedAt
    }
    
    # IsOverdue: Checks if the task is overdue based on DueDate.
    [bool] IsOverdue() {
        if ($null -eq $this.DueDate) { return $false }
        if ($this.Status -in @([TaskStatus]::Completed, [TaskStatus]::Cancelled)) { return $false }
        return [datetime]::Now -gt $this.DueDate
    }
    
    # Clone: Creates a deep copy of the task with a new ID.
    [PmcTask] Clone() {
        $clone = [PmcTask]::new()
        $clone.Title = $this.Title
        $clone.Description = $this.Description
        $clone.Status = $this.Status
        $clone.Priority = $this.Priority
        $clone.ProjectKey = $this.ProjectKey
        $clone.Category = $this.Category
        $clone.DueDate = $this.DueDate
        $clone.Tags = $this.Tags.Clone()
        $clone.Progress = $this.Progress
        $clone.Completed = $this.Completed
        # New task gets new timestamps and ID
        $clone.CreatedAt = [datetime]::Now
        $clone.UpdatedAt = [datetime]::Now
        return $clone
    }
    
    # ToString: Returns a string representation of the task.
    [string] ToString() {
        $statusSymbol = switch ($this.Status) {
            ([TaskStatus]::Pending) { "○" }
            ([TaskStatus]::InProgress) { "◐" }
            ([TaskStatus]::Completed) { "●" }
            ([TaskStatus]::Cancelled) { "✕" }
            default { "?" }
        }
        
        $prioritySymbol = switch ($this.Priority) {
            ([TaskPriority]::Low) { "↓" }
            ([TaskPriority]::Medium) { "→" }
            ([TaskPriority]::High) { "↑" }
            default { "-" }
        }
        
        $overdueFlag = if ($this.IsOverdue()) { " [OVERDUE]" } else { "" }
        
        return "$statusSymbol $prioritySymbol $($this.Title) ($($this.Progress)%)$overdueFlag"
    }
}

# ===== CLASS: PmcProject =====
# Module: models (from axiom)
# Dependencies: ValidationBase
# Purpose: Represents a project that contains multiple tasks
class PmcProject : ValidationBase {
    [string]$Key                              # Unique project key (e.g., "PROJ-001")
    [string]$Name                             # Project name
    [string]$Description                      # Project description
    [DateTime]$CreatedAt = [DateTime]::Now  # Creation timestamp
    [DateTime]$UpdatedAt = [DateTime]::Now  # Last update timestamp
    [string]$Owner                           # Project owner
    [string[]]$Tags = @()                    # Project tags
    [hashtable]$Metadata = @{}               # Additional project metadata
    [bool]$IsActive = $true                  # Whether project is active

    # Default constructor
    PmcProject() {}

    # Constructor with key and name
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key
        $this.Name = $name
    }

    # Constructor with full details
    PmcProject([string]$key, [string]$name, [string]$description, [string]$owner) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        [ValidationBase]::ValidateNotEmpty($owner, "Owner")
        
        $this.Key = $key
        $this.Name = $name
        $this.Description = $description
        $this.Owner = $owner
    }

    # Archive: Marks the project as inactive
    [void] Archive() {
        $this.IsActive = $false
        $this.UpdatedAt = [DateTime]::Now
    }

    # Activate: Marks the project as active
    [void] Activate() {
        $this.IsActive = $true
        $this.UpdatedAt = [DateTime]::Now
    }

    # AddTag: Adds a tag to the project if not already present
    [void] AddTag([string]$tag) {
        [ValidationBase]::ValidateNotEmpty($tag, "Tag")
        if ($this.Tags -notcontains $tag) {
            $this.Tags += $tag
            $this.UpdatedAt = [DateTime]::Now
        }
    }

    # RemoveTag: Removes a tag from the project
    [void] RemoveTag([string]$tag) {
        $this.Tags = $this.Tags | Where-Object { $_ -ne $tag }
        $this.UpdatedAt = [DateTime]::Now
    }

    # SetMetadata: Sets a metadata key-value pair
    [void] SetMetadata([string]$key, $value) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        $this.Metadata[$key] = $value
        $this.UpdatedAt = [DateTime]::Now
    }

    # GetMetadata: Gets a metadata value by key
    [object] GetMetadata([string]$key) {
        return $this.Metadata[$key]
    }

    # ToString: Returns a string representation of the project
    [string] ToString() {
        $status = if ($this.IsActive) { "Active" } else { "Archived" }
        return "[$($this.Key)] $($this.Name) - $status"
    }
}

# ===== CLASS: TimeEntry =====
# Module: models (from axiom)
# Dependencies: ValidationBase, BillingType enum
# Purpose: Represents a time entry for a task
class TimeEntry : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()  # Unique identifier
    [string]$TaskId                              # Associated task ID
    [string]$ProjectKey                          # Associated project key
    [DateTime]$StartTime                         # When work started
    [Nullable[DateTime]]$EndTime                 # When work ended (null if ongoing)
    [string]$Description                         # What was done
    [BillingType]$BillingType = [BillingType]::Billable # Billing classification
    [string]$UserId                              # Who logged the time
    [decimal]$HourlyRate = 0                    # Rate per hour (if applicable)
    [hashtable]$Metadata = @{}                   # Additional metadata

    # Default constructor
    TimeEntry() {}

    # Constructor with basic details
    TimeEntry([string]$taskId, [string]$projectKey, [DateTime]$startTime) {
        [ValidationBase]::ValidateNotEmpty($taskId, "TaskId")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")
        
        $this.TaskId = $taskId
        $this.ProjectKey = $projectKey
        $this.StartTime = $startTime
    }

    # GetDuration: Returns the duration of the time entry
    [TimeSpan] GetDuration() {
        if ($null -eq $this.EndTime) {
            return [DateTime]::Now - $this.StartTime
        }
        return $this.EndTime - $this.StartTime
    }

    # GetHours: Returns the duration in decimal hours
    [decimal] GetHours() {
        return [decimal]($this.GetDuration().TotalHours)
    }

    # GetTotalValue: Returns the monetary value of the time entry
    [decimal] GetTotalValue() {
        if ($this.BillingType -eq [BillingType]::NonBillable) {
            return 0
        }
        return $this.GetHours() * $this.HourlyRate
    }

    # Stop: Stops the timer on this entry
    [void] Stop() {
        if ($null -eq $this.EndTime) {
            $this.EndTime = [DateTime]::Now
        }
    }

    # IsRunning: Checks if the time entry is still running
    [bool] IsRunning() {
        return $null -eq $this.EndTime
    }

    # ToString: Returns a string representation of the time entry
    [string] ToString() {
        $duration = $this.GetDuration()
        $status = if ($this.IsRunning()) { "Running" } else { "Completed" }
        return "$($this.ProjectKey) - $($duration.ToString('hh\:mm\:ss')) [$status]"
    }
}

#endregion

#region Exception Classes

# ===== CLASS: HeliosException =====
# Module: exceptions (from axiom)
# Dependencies: None (inherits from System.Exception)
# Purpose: Base exception for all framework exceptions
class HeliosException : System.Exception {
    [string]$ErrorCode
    [hashtable]$Context = @{}
    [string]$Component
    [DateTime]$Timestamp
    
    HeliosException([string]$message) : base($message) {
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component) : base($message) {
        $this.Component = $component
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component, [hashtable]$context) : base($message) {
        $this.Component = $component
        $this.Context = $context
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $innerException) {
        $this.Component = $component
        $this.Context = $context
        $this.Timestamp = [DateTime]::Now
    }
}

# ===== CLASS: NavigationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for navigation-related errors
class NavigationException : HeliosException {
    NavigationException([string]$message) : base($message) {}
    NavigationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: ServiceInitializationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for service initialization failures
class ServiceInitializationException : HeliosException {
    ServiceInitializationException([string]$message) : base($message) {}
    ServiceInitializationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: ComponentRenderException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for component rendering failures
class ComponentRenderException : HeliosException {
    ComponentRenderException([string]$message) : base($message) {}
    ComponentRenderException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: StateMutationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for state mutation errors
class StateMutationException : HeliosException {
    StateMutationException([string]$message) : base($message) {}
    StateMutationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: InputHandlingException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for input handling errors
class InputHandlingException : HeliosException {
    InputHandlingException([string]$message) : base($message) {}
    InputHandlingException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: DataLoadException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for data loading errors
class DataLoadException : HeliosException {
    DataLoadException([string]$message) : base($message) {}
    DataLoadException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

#endregion

#region Navigation Classes

# ===== CLASS: NavigationItem =====
# Module: navigation-class (from axiom)
# Dependencies: None
# Purpose: Represents a menu item for local/contextual navigation
class NavigationItem {
    [string]$Key
    [string]$Label
    [scriptblock]$Action
    [bool]$Enabled = $true
    [bool]$Visible = $true
    [string]$Description = ""

    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key)) {
            throw [System.ArgumentException]::new("Navigation key cannot be null or empty")
        }
        if ([string]::IsNullOrWhiteSpace($label)) {
            throw [System.ArgumentException]::new("Navigation label cannot be null or empty")
        }
        if (-not $action) {
            throw [System.ArgumentNullException]::new("action", "Navigation action cannot be null")
        }

        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }

    [void] Execute() {
        try {
            if (-not $this.Enabled) {
                return
            }
            
            & $this.Action
        }
        catch {
            throw
        }
    }

    [string] ToString() {
        return "NavigationItem(Key='$($this.Key)', Label='$($this.Label)', Enabled=$($this.Enabled))"
    }
}

#endregion


####\AllRuntime.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Runtime (Load Last)
# TUI engine, screen management, and main application loop
# ==============================================================================

#region Global State

# Initialize global TUI state
$global:TuiState = @{
    Running = $false
    BufferWidth = 0
    BufferHeight = 0
    CompositorBuffer = $null
    PreviousCompositorBuffer = $null
    ScreenStack = [System.Collections.Stack]::new()
    CurrentScreen = $null
    IsDirty = $true
    FocusedComponent = $null
    CommandPalette = $null
    Services = @{}
    LastRenderTime = [datetime]::Now
    FrameCount = 0
    InputQueue = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
}

#endregion

#region Engine Management

function Initialize-TuiEngine {
    [CmdletBinding()]
    param()
    
    try {
        Write-Verbose "Initializing TUI Engine..."
        
        # Hide cursor
        [Console]::CursorVisible = $false
        
        # Clear screen
        [Console]::Clear()
        
        # Get initial console size
        $global:TuiState.BufferWidth = [Console]::WindowWidth
        $global:TuiState.BufferHeight = [Console]::WindowHeight
        
        # Create compositor buffers
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new(
            $global:TuiState.BufferWidth,
            $global:TuiState.BufferHeight,
            "Compositor"
        )
        
        $global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new(
            $global:TuiState.BufferWidth,
            $global:TuiState.BufferHeight,
            "PreviousCompositor"
        )
        
        Write-Verbose "TUI Engine initialized with buffer size: $($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight)"
    }
    catch {
        Write-Error "Failed to initialize TUI engine: $_"
        throw
    }
}

function Start-TuiEngine {
    [CmdletBinding()]
    param()
    
    try {
        Write-Verbose "Starting TUI Engine main loop..."
        
        $global:TuiState.Running = $true
        $frameTimer = [System.Diagnostics.Stopwatch]::new()
        
        while ($global:TuiState.Running) {
            $frameTimer.Restart()
            
            # Check for resize
            if ([Console]::WindowWidth -ne $global:TuiState.BufferWidth -or 
                [Console]::WindowHeight -ne $global:TuiState.BufferHeight) {
                Update-TuiEngineSize
            }
            
            # Process input
            Process-TuiInput
            
            # Render if dirty
            if ($global:TuiState.IsDirty) {
                Invoke-TuiRender
                $global:TuiState.IsDirty = $false
            }
            
            # Frame timing (target 60 FPS)
            $frameTimer.Stop()
            $frameTime = $frameTimer.ElapsedMilliseconds
            if ($frameTime -lt 16) {
                Start-Sleep -Milliseconds (16 - $frameTime)
            }
            
            $global:TuiState.FrameCount++
        }
        
        Write-Verbose "TUI Engine stopped after $($global:TuiState.FrameCount) frames"
    }
    catch {
        Write-Error "TUI Engine error: $_"
        Invoke-PanicHandler $_
    }
    finally {
        Stop-TuiEngine
    }
}

function Stop-TuiEngine {
    [CmdletBinding()]
    param()
    
    try {
        Write-Verbose "Stopping TUI Engine..."
        
        $global:TuiState.Running = $false
        
        # Cleanup current screen
        if ($global:TuiState.CurrentScreen) {
            try {
                $global:TuiState.CurrentScreen.OnExit()
                $global:TuiState.CurrentScreen.Cleanup()
            }
            catch {
                Write-Warning "Error cleaning up current screen: $_"
            }
        }
        
        # Cleanup services
        foreach ($service in $global:TuiState.Services.Values) {
            if ($service -and $service.PSObject.Methods.Match('Cleanup')) {
                try {
                    $service.Cleanup()
                }
                catch {
                    Write-Warning "Error cleaning up service: $_"
                }
            }
        }
        
        # Restore console
        [Console]::CursorVisible = $true
        [Console]::Clear()
        [Console]::SetCursorPosition(0, 0)
        
        Write-Verbose "TUI Engine stopped and cleaned up"
    }
    catch {
        Write-Error "Error stopping TUI engine: $_"
    }
}

function Update-TuiEngineSize {
    [CmdletBinding()]
    param()
    
    try {
        $newWidth = [Console]::WindowWidth
        $newHeight = [Console]::WindowHeight
        
        Write-Verbose "Console resized from $($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight) to ${newWidth}x${newHeight}"
        
        # Update state
        $global:TuiState.BufferWidth = $newWidth
        $global:TuiState.BufferHeight = $newHeight
        
        # Resize compositor buffers
        $global:TuiState.CompositorBuffer.Resize($newWidth, $newHeight)
        $global:TuiState.PreviousCompositorBuffer.Resize($newWidth, $newHeight)
        
        # Resize current screen
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.Resize($newWidth, $newHeight)
        }
        
        # Force full redraw
        $global:TuiState.IsDirty = $true
        [Console]::Clear()
    }
    catch {
        Write-Error "Failed to update engine size: $_"
    }
}

#endregion

#region Rendering System

function Invoke-TuiRender {
    [CmdletBinding()]
    param()
    
    try {
        $renderTimer = [System.Diagnostics.Stopwatch]::StartNew()
        
        # Clear compositor buffer
        $global:TuiState.CompositorBuffer.Clear()
        
        # Render current screen
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.OnRender($global:TuiState.CompositorBuffer)
            
            # Render command palette if visible
            if ($global:TuiState.CommandPalette -and $global:TuiState.CommandPalette.Visible) {
                $global:TuiState.CommandPalette.OnRender($global:TuiState.CompositorBuffer)
            }
        }
        
        # Differential rendering
        Render-DifferentialBuffer
        
        # Swap buffers
        $temp = $global:TuiState.PreviousCompositorBuffer
        $global:TuiState.PreviousCompositorBuffer = $global:TuiState.CompositorBuffer
        $global:TuiState.CompositorBuffer = $temp
        
        $renderTimer.Stop()
        
        if ($renderTimer.ElapsedMilliseconds -gt 16) {
            Write-Verbose "Slow frame: $($renderTimer.ElapsedMilliseconds)ms"
        }
    }
    catch {
        Write-Error "Render error: $_"
        throw
    }
}

function Render-DifferentialBuffer {
    [CmdletBinding()]
    param()
    
    try {
        $current = $global:TuiState.CompositorBuffer
        $previous = $global:TuiState.PreviousCompositorBuffer
        
        $ansiBuilder = [System.Text.StringBuilder]::new()
        $lastBgColor = $null
        $lastFgColor = $null
        $lastBold = $false
        $lastUnderline = $false
        $currentX = -1
        $currentY = -1
        
        for ($y = 0; $y -lt $current.Height; $y++) {
            for ($x = 0; $x -lt $current.Width; $x++) {
                $currentCell = $current.GetCell($x, $y)
                $previousCell = $previous.GetCell($x, $y)
                
                if ($currentCell.DiffersFrom($previousCell)) {
                    # Move cursor if needed
                    if ($currentX -ne $x -or $currentY -ne $y) {
                        [void]$ansiBuilder.Append("`e[$($y + 1);$($x + 1)H")
                        $currentX = $x
                        $currentY = $y
                    }
                    
                    # Apply styling if changed
                    if ($currentCell.BackgroundColor -ne $lastBgColor) {
                        [void]$ansiBuilder.Append([TuiAnsiHelper]::GetBackgroundCode($currentCell.BackgroundColor))
                        $lastBgColor = $currentCell.BackgroundColor
                    }
                    
                    if ($currentCell.ForegroundColor -ne $lastFgColor) {
                        [void]$ansiBuilder.Append([TuiAnsiHelper]::GetForegroundCode($currentCell.ForegroundColor))
                        $lastFgColor = $currentCell.ForegroundColor
                    }
                    
                    if ($currentCell.Bold -ne $lastBold) {
                        [void]$ansiBuilder.Append($(if ($currentCell.Bold) { "`e[1m" } else { "`e[22m" }))
                        $lastBold = $currentCell.Bold
                    }
                    
                    if ($currentCell.Underline -ne $lastUnderline) {
                        [void]$ansiBuilder.Append($(if ($currentCell.Underline) { "`e[4m" } else { "`e[24m" }))
                        $lastUnderline = $currentCell.Underline
                    }
                    
                    # Write character
                    [void]$ansiBuilder.Append($currentCell.Char)
                    $currentX++
                    
                    # Copy to previous buffer
                    $previous.SetCell($x, $y, [TuiCell]::new($currentCell))
                }
            }
        }
        
        # Reset styling at end
        if ($ansiBuilder.Length -gt 0) {
            [void]$ansiBuilder.Append("`e[0m")
            [Console]::Write($ansiBuilder.ToString())
        }
    }
    catch {
        Write-Error "Differential rendering error: $_"
        throw
    }
}

#endregion

#region Input Processing

function Process-TuiInput {
    [CmdletBinding()]
    param()
    
    try {
        if ([Console]::KeyAvailable) {
            $keyInfo = [Console]::ReadKey($true)
            
            # Check command palette first
            if ($global:TuiState.CommandPalette -and $global:TuiState.CommandPalette.Visible) {
                $handled = $global:TuiState.CommandPalette.HandleInput($keyInfo)
                if ($handled) {
                    $global:TuiState.IsDirty = $true
                    return
                }
            }
            
            # Check global hotkeys
            if ($global:TuiState.Services.KeybindingService) {
                $action = $global:TuiState.Services.KeybindingService.GetAction($keyInfo)
                
                if ($action) {
                    Write-Verbose "Processing global action: $action"
                    
                    switch ($action) {
                        "app.exit" {
                            $global:TuiState.Running = $false
                            return
                        }
                        "app.commandPalette" {
                            if ($global:TuiState.CommandPalette) {
                                $global:TuiState.CommandPalette.Show()
                                $global:TuiState.IsDirty = $true
                            }
                            return
                        }
                    }
                    
                    # Try to execute via ActionService
                    if ($global:TuiState.Services.ActionService) {
                        try {
                            $global:TuiState.Services.ActionService.ExecuteAction($action)
                            $global:TuiState.IsDirty = $true
                            return
                        }
                        catch {
                            Write-Verbose "Action execution failed: $_"
                        }
                    }
                }
            }
            
            # Pass to current screen
            if ($global:TuiState.CurrentScreen) {
                $global:TuiState.CurrentScreen.HandleInput($keyInfo)
                $global:TuiState.IsDirty = $true
            }
        }
    }
    catch {
        Write-Error "Input processing error: $_"
    }
}

#endregion

#region Screen Management

function Push-Screen {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [Screen]$Screen
    )
    
    try {
        Write-Verbose "Pushing screen: $($Screen.Name)"
        
        # Exit current screen
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.OnExit()
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        
        # Initialize and enter new screen
        $global:TuiState.CurrentScreen = $Screen
        
        if (-not $Screen._isInitialized) {
            $Screen.Initialize()
            $Screen._isInitialized = $true
        }
        
        $Screen.OnEnter()
        $global:TuiState.IsDirty = $true
    }
    catch {
        Write-Error "Failed to push screen: $_"
        throw
    }
}

function Pop-Screen {
    [CmdletBinding()]
    param()
    
    try {
        if ($global:TuiState.ScreenStack.Count -eq 0) {
            Write-Warning "No screens to pop"
            return
        }
        
        Write-Verbose "Popping screen"
        
        # Exit current screen
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.OnExit()
        }
        
        # Resume previous screen
        $previousScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.CurrentScreen = $previousScreen
        $previousScreen.OnResume()
        
        $global:TuiState.IsDirty = $true
    }
    catch {
        Write-Error "Failed to pop screen: $_"
        throw
    }
}

function Switch-Screen {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [Screen]$Screen
    )
    
    try {
        Write-Verbose "Switching to screen: $($Screen.Name)"
        
        # Exit current screen without pushing to stack
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.OnExit()
        }
        
        # Initialize and enter new screen
        $global:TuiState.CurrentScreen = $Screen
        
        if (-not $Screen._isInitialized) {
            $Screen.Initialize()
            $Screen._isInitialized = $true
        }
        
        $Screen.OnEnter()
        $global:TuiState.IsDirty = $true
    }
    catch {
        Write-Error "Failed to switch screen: $_"
        throw
    }
}

#endregion

#region Error Handling

function Invoke-PanicHandler {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [object]$Error
    )
    
    try {
        Write-Host "`n`n=== AXIOM-PHOENIX PANIC HANDLER ===" -ForegroundColor Red
        Write-Host "A critical error has occurred!" -ForegroundColor Red
        Write-Host ""
        
        # Error details
        Write-Host "Error Message:" -ForegroundColor Yellow
        Write-Host "  $($Error.Exception.Message)" -ForegroundColor White
        Write-Host ""
        
        Write-Host "Error Type:" -ForegroundColor Yellow
        Write-Host "  $($Error.Exception.GetType().FullName)" -ForegroundColor White
        Write-Host ""
        
        Write-Host "Stack Trace:" -ForegroundColor Yellow
        $Error.ScriptStackTrace -split "`n" | ForEach-Object {
            Write-Host "  $_" -ForegroundColor Gray
        }
        Write-Host ""
        
        # System info
        Write-Host "System Information:" -ForegroundColor Yellow
        Write-Host "  PowerShell: $($PSVersionTable.PSVersion)" -ForegroundColor Gray
        Write-Host "  OS: $([System.Environment]::OSVersion.VersionString)" -ForegroundColor Gray
        Write-Host "  Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" -ForegroundColor Gray
        Write-Host ""
        
        # Crash report location
        $crashReportPath = Join-Path $env:TEMP "axiom-phoenix-crash-$(Get-Date -Format 'yyyyMMdd-HHmmss').txt"
        
        $crashReport = @"
AXIOM-PHOENIX CRASH REPORT
Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')

ERROR DETAILS:
$($Error | Out-String)

SYSTEM INFORMATION:
PowerShell Version: $($PSVersionTable.PSVersion)
OS Version: $([System.Environment]::OSVersion.VersionString)
CLR Version: $($PSVersionTable.CLRVersion)
Host: $($Host.Name)

GLOBAL STATE:
$($global:TuiState | ConvertTo-Json -Depth 3)
"@
        
        $crashReport | Out-File -FilePath $crashReportPath -Force
        
        Write-Host "Crash report saved to:" -ForegroundColor Yellow
        Write-Host "  $crashReportPath" -ForegroundColor Cyan
        Write-Host ""
        
        Write-Host "Press any key to exit..." -ForegroundColor White
        [Console]::ReadKey($true) | Out-Null
    }
    catch {
        Write-Host "FATAL: Panic handler failed!" -ForegroundColor Magenta
        Write-Host $_.Exception.Message -ForegroundColor Red
    }
    finally {
        # Try to restore console
        try {
            [Console]::CursorVisible = $true
            [Console]::Clear()
        }
        catch {}
        
        # Exit
        exit 1
    }
}

#endregion

#region Application Entry

function Start-AxiomPhoenix {
    [CmdletBinding()]
    param(
        [ServiceContainer]$ServiceContainer,
        [Screen]$InitialScreen
    )
    
    try {
        Write-Verbose "Starting Axiom-Phoenix application..."
        
        # Store services
        $global:TuiState.Services = @{
            ServiceContainer = $ServiceContainer
        }
        
        # Extract key services for quick access
        $serviceNames = @(
            'ActionService', 'KeybindingService', 'NavigationService', 
            'DataManager', 'ThemeManager', 'EventManager', 'Logger'
        )
        
        foreach ($serviceName in $serviceNames) {
            try {
                $service = $ServiceContainer.GetService($serviceName)
                if ($service) {
                    $global:TuiState.Services[$serviceName] = $service
                }
            }
            catch {
                Write-Warning "Failed to get service '$serviceName': $_"
            }
        }
        
        # Create command palette if available
        if ($ServiceContainer.GetService("ActionService")) {
            $global:TuiState.CommandPalette = [CommandPalette]::new()
            $global:TuiState.CommandPalette.ActionService = $ServiceContainer.GetService("ActionService")
            $global:TuiState.CommandPalette.RefreshActions()
        }
        
        # Initialize engine
        Initialize-TuiEngine
        
        # Set initial screen
        if ($InitialScreen) {
            Push-Screen -Screen $InitialScreen
        }
        else {
            Write-Warning "No initial screen provided"
        }
        
        # Start main loop
        Start-TuiEngine
    }
    catch {
        Write-Error "Application startup failed: $_"
        Invoke-PanicHandler $_
    }
    finally {
        Stop-TuiEngine
    }
}

#endregion


####\AllScreens.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Screens (Load After Components)
# Application screens that extend Screen base class
# ==============================================================================

using namespace System.Collections.Generic

#region Screen Classes

class DashboardScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [Panel] $_summaryPanel
    hidden [Panel] $_statusPanel
    hidden [Panel] $_helpPanel
    #endregion

    #region State
    hidden [int] $_totalTasks = 0
    hidden [int] $_completedTasks = 0
    hidden [int] $_pendingTasks = 0
    #endregion

    DashboardScreen([object]$serviceContainer) : base("DashboardScreen", $serviceContainer) {}

    [void] Initialize() {
        if (-not $this.ServiceContainer) {
            Write-Warning "DashboardScreen.Initialize: ServiceContainer is null"
            return
        }
        
        $this._mainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "Axiom-Phoenix Dashboard")
        $this.AddChild($this._mainPanel)

        $summaryWidth = [Math]::Floor($this.Width * 0.5)
        $this._summaryPanel = [Panel]::new(1, 1, $summaryWidth, 12, "Task Summary")
        $this._mainPanel.AddChild($this._summaryPanel)

        $helpX = $summaryWidth + 2
        $helpWidth = $this.Width - $helpX - 1
        $this._helpPanel = [Panel]::new($helpX, 1, $helpWidth, 12, "Quick Start")
        $this._mainPanel.AddChild($this._helpPanel)

        $this._statusPanel = [Panel]::new(1, 14, $this.Width - 2, $this.Height - 15, "System Status")
        $this._mainPanel.AddChild($this._statusPanel)
    }

    [void] OnEnter() {
        # Force a complete redraw of all panels
        if ($this._summaryPanel) { $this._summaryPanel.RequestRedraw() }
        if ($this._helpPanel) { $this._helpPanel.RequestRedraw() }
        if ($this._statusPanel) { $this._statusPanel.RequestRedraw() }
        if ($this._mainPanel) { $this._mainPanel.RequestRedraw() }
        
        if ($this.ServiceContainer) {
            $this._RefreshData($this.ServiceContainer.GetService("DataManager"))
        } else {
            Write-Warning "DashboardScreen.OnEnter: ServiceContainer is null, using defaults"
            $this._RefreshData($null)
        }
        
        # Force another redraw after data refresh
        $this.RequestRedraw()
    }

    hidden [void] _RefreshData([object]$dataManager) {
        if(-not $dataManager) {
            Write-Warning "DashboardScreen: DataManager service not found."
            $this._totalTasks = 0
            $this._completedTasks = 0
            $this._pendingTasks = 0
        } else {
            $allTasks = $dataManager.GetTasks()
            $this._totalTasks = $allTasks.Count
            $this._completedTasks = ($allTasks | Where-Object { $_.Completed }).Count
            $this._pendingTasks = $this._totalTasks - $this._completedTasks
        }
        $this._UpdateDisplay()
    }
    
    hidden [void] _UpdateDisplay() {
        $this._UpdateSummaryPanel()
        $this._UpdateHelpPanel()
        $this._UpdateStatusPanel()
        $this.RequestRedraw()
    }
    
    hidden [void] _UpdateSummaryPanel() {
        $panel = $this._summaryPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()

        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY

        # Simple text rendering using buffer
        $buffer.WriteString($contentX + 1, $contentY, "Task Overview", [ConsoleColor]::Cyan, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 1, ('─' * ($panel.ContentWidth - 2)), [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
        
        $buffer.WriteString($contentX + 1, $contentY + 3, "Total Tasks:    $($this._totalTasks)", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 4, "Completed:      $($this._completedTasks)", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 5, "Pending:        $($this._pendingTasks)", [ConsoleColor]::White, [ConsoleColor]::Black)
        
        $progress = $this._GetProgressBar()
        $buffer.WriteString($contentX + 1, $contentY + 7, "Overall Progress:", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 8, $progress, [ConsoleColor]::Yellow, [ConsoleColor]::Black)
        
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateHelpPanel() {
        $panel = $this._helpPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        $paletteHotkey = "Ctrl+P"
        
        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY
        
        $buffer.WriteString($contentX + 1, $contentY + 0, "Welcome to Axiom-Phoenix!", [ConsoleColor]::Cyan, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 1, ('─' * ($panel.ContentWidth - 2)), [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
        
        $buffer.WriteString($contentX + 1, $contentY + 3, "Press ", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 7, $contentY + 3, $paletteHotkey, [ConsoleColor]::Yellow, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 7 + $paletteHotkey.Length, $contentY + 3, " to open the", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 4, "Command Palette.", [ConsoleColor]::White, [ConsoleColor]::Black)

        $buffer.WriteString($contentX + 1, $contentY + 6, "All navigation and actions are", [ConsoleColor]::Gray, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 7, "now available from there.", [ConsoleColor]::Gray, [ConsoleColor]::Black)
        
        $panel.RequestRedraw()
    }
    
    hidden [void] _UpdateStatusPanel() {
        $panel = $this._statusPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()

        $memoryMB = try { [Math]::Round((Get-Process -Id $global:PID).WorkingSet64 / 1MB, 2) } catch { 0 }

        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY
        
        $buffer.WriteString($contentX + 1, $contentY, "Environment", [ConsoleColor]::Cyan, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 1, ('─' * ($panel.ContentWidth - 2)), [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
        
        $buffer.WriteString($contentX + 1, $contentY + 3, "PowerShell Version: $($global:PSVersionTable.PSVersion)", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 4, "Memory Usage: ${memoryMB} MB", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 5, "Host: $($global:Host.Name)", [ConsoleColor]::White, [ConsoleColor]::Black)
        
        $panel.RequestRedraw()
    }
    
    hidden [string] _GetProgressBar() {
        if ($this._totalTasks -eq 0) { return "[No Tasks]" }
        $percentage = [Math]::Round(($this._completedTasks / $this._totalTasks) * 100)
        $barWidth = 20
        $filled = [Math]::Floor($barWidth * ($percentage / 100))
        $empty = $barWidth - $filled
        return "[" + ('█' * $filled) + ('░' * $empty) + "] $percentage%"
    }

    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Dashboard doesn't handle specific input - all navigation via command palette
        # Input not handled
    }
}

class TaskListScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [ScrollablePanel] $_taskListPanel
    hidden [Panel] $_detailPanel
    hidden [Panel] $_statusBar
    #endregion

    #region State
    hidden [System.Collections.Generic.List[PmcTask]] $_tasks
    hidden [int] $_selectedIndex = 0
    hidden [PmcTask] $_selectedTask
    hidden [string] $_filterText = ""
    hidden [TaskStatus] $_filterStatus = $null
    hidden [TaskPriority] $_filterPriority = $null
    #endregion

    TaskListScreen([object]$serviceContainer) : base("TaskListScreen", $serviceContainer) {}

    [void] Initialize() {
        if (-not $this.ServiceContainer) {
            Write-Warning "TaskListScreen.Initialize: ServiceContainer is null"
            return
        }
        
        $this._mainPanel = [Panel]::new(0, 0, $this.Width, $this.Height, "Task List")
        $this.AddChild($this._mainPanel)

        # Task list panel (left side)
        $listWidth = [Math]::Floor($this.Width * 0.6)
        $this._taskListPanel = [ScrollablePanel]::new(1, 1, $listWidth, $this.Height - 4, "Tasks")
        $this._mainPanel.AddChild($this._taskListPanel)

        # Detail panel (right side)
        $detailX = $listWidth + 2
        $detailWidth = $this.Width - $detailX - 1
        $this._detailPanel = [Panel]::new($detailX, 1, $detailWidth, $this.Height - 4, "Task Details")
        $this._mainPanel.AddChild($this._detailPanel)

        # Status bar
        $this._statusBar = [Panel]::new(1, $this.Height - 2, $this.Width - 2, 1)
        $this._statusBar.HasBorder = $false
        $this._mainPanel.AddChild($this._statusBar)
        
        $this._tasks = [System.Collections.Generic.List[PmcTask]]::new()
    }

    [void] OnEnter() {
        if ($this.ServiceContainer) {
            $this._RefreshTasks()
        }
        
        $this.RequestRedraw()
    }

    hidden [void] _RefreshTasks() {
        $dataManager = $this.ServiceContainer.GetService("DataManager")
        if (-not $dataManager) {
            Write-Warning "TaskListScreen: DataManager service not found"
            return
        }
        
        $allTasks = $dataManager.GetTasks()
        $this._tasks.Clear()
        $this._tasks.AddRange($allTasks)
        
        # Apply filters if any
        if (-not [string]::IsNullOrEmpty($this._filterText)) {
            $this._tasks = $this._tasks | Where-Object { 
                $_.Title -like "*$($this._filterText)*" -or 
                $_.Description -like "*$($this._filterText)*" 
            }
        }
        
        if ($null -ne $this._filterStatus) {
            $this._tasks = $this._tasks | Where-Object { $_.Status -eq $this._filterStatus }
        }
        
        if ($null -ne $this._filterPriority) {
            $this._tasks = $this._tasks | Where-Object { $_.Priority -eq $this._filterPriority }
        }
        
        # Update selection
        if ($this._selectedIndex -ge $this._tasks.Count) {
            $this._selectedIndex = [Math]::Max(0, $this._tasks.Count - 1)
        }
        
        if ($this._tasks.Count -gt 0) {
            $this._selectedTask = $this._tasks[$this._selectedIndex]
        } else {
            $this._selectedTask = $null
        }
        
        $this._UpdateDisplay()
    }

    hidden [void] _UpdateDisplay() {
        $this._UpdateTaskList()
        $this._UpdateDetailPanel()
        $this._UpdateStatusBar()
        $this.RequestRedraw()
    }

    hidden [void] _UpdateTaskList() {
        $panel = $this._taskListPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY
        $contentHeight = $panel.ContentHeight
        
        if ($this._tasks.Count -eq 0) {
            $buffer.WriteString($contentX + 2, $contentY + 2, "No tasks found.", [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
            return
        }
        
        # Render tasks
        $startIndex = $panel.ScrollOffsetY
        $endIndex = [Math]::Min($startIndex + $contentHeight, $this._tasks.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $task = $this._tasks[$i]
            $y = $contentY + ($i - $startIndex)
            
            # Highlight selected task
            $bgColor = if ($i -eq $this._selectedIndex) { [ConsoleColor]::DarkGray } else { [ConsoleColor]::Black }
            $fgColor = if ($i -eq $this._selectedIndex) { [ConsoleColor]::White } else { [ConsoleColor]::Gray }
            
            # Status indicator
            $statusChar = switch ($task.Status) {
                ([TaskStatus]::Pending) { "○" }
                ([TaskStatus]::InProgress) { "◐" }
                ([TaskStatus]::Completed) { "●" }
                ([TaskStatus]::Cancelled) { "✕" }
                default { "?" }
            }
            
            # Priority indicator
            $priorityChar = switch ($task.Priority) {
                ([TaskPriority]::Low) { "↓" }
                ([TaskPriority]::Medium) { "→" }
                ([TaskPriority]::High) { "↑" }
                default { "-" }
            }
            
            # Truncate title if needed
            $maxTitleLength = $panel.ContentWidth - 10
            $title = if ($task.Title.Length -gt $maxTitleLength) {
                $task.Title.Substring(0, $maxTitleLength - 3) + "..."
            } else {
                $task.Title
            }
            
            $taskLine = "$statusChar $priorityChar $title"
            
            # Fill entire line with background color
            for ($x = 0; $x -lt $panel.ContentWidth; $x++) {
                $buffer.SetCell($contentX + $x, $y, [TuiCell]::new(' ', $fgColor, $bgColor))
            }
            
            $buffer.WriteString($contentX + 1, $y, $taskLine, $fgColor, $bgColor)
        }
        
        # Update scrollbar
        $panel.UpdateMaxScroll()
    }

    hidden [void] _UpdateDetailPanel() {
        $panel = $this._detailPanel
        if (-not $panel -or -not $this._selectedTask) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        $task = $this._selectedTask
        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY
        
        # Task details
        $y = $contentY
        $buffer.WriteString($contentX + 1, $y++, "Title: $($task.Title)", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $y++, "Status: $($task.Status)", [ConsoleColor]::Cyan, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $y++, "Priority: $($task.Priority)", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $y++, "Progress: $($task.Progress)%", [ConsoleColor]::Green, [ConsoleColor]::Black)
        
        $y++
        $buffer.WriteString($contentX + 1, $y++, "Description:", [ConsoleColor]::Gray, [ConsoleColor]::Black)
        
        if (-not [string]::IsNullOrEmpty($task.Description)) {
            # Word wrap description
            $words = $task.Description -split '\s+'
            $line = ""
            $maxLineLength = $panel.ContentWidth - 2
            
            foreach ($word in $words) {
                if (($line + " " + $word).Length -gt $maxLineLength) {
                    if ($line) {
                        $buffer.WriteString($contentX + 1, $y++, $line, [ConsoleColor]::White, [ConsoleColor]::Black)
                    }
                    $line = $word
                } else {
                    $line = if ($line) { "$line $word" } else { $word }
                }
            }
            
            if ($line) {
                $buffer.WriteString($contentX + 1, $y++, $line, [ConsoleColor]::White, [ConsoleColor]::Black)
            }
        } else {
            $buffer.WriteString($contentX + 1, $y++, "(No description)", [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
        }
        
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateStatusBar() {
        $panel = $this._statusBar
        if (-not $panel) { return }
        
        $buffer = $panel.GetBuffer()
        
        $statusText = "Tasks: $($this._tasks.Count) | Selected: $($this._selectedIndex + 1)"
        if ($this._filterText) {
            $statusText += " | Filter: '$($this._filterText)'"
        }
        
        $buffer.WriteString(0, 0, $statusText, [ConsoleColor]::White, [ConsoleColor]::Black)
        
        # Keyboard hints
        $hints = "↑↓: Navigate | Enter: Edit | D: Delete | N: New"
        $hintsX = $this.Width - $hints.Length - 3
        if ($hintsX -gt $statusText.Length + 2) {
            $buffer.WriteString($hintsX, 0, $hints, [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
        }
        
        $panel.RequestRedraw()
    }

    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this._selectedIndex -gt 0) {
                    $this._selectedIndex--
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                    
                    # Adjust scroll if needed
                    if ($this._selectedIndex -lt $this._taskListPanel.ScrollOffsetY) {
                        $this._taskListPanel.ScrollUp()
                    }
                    
                    $this._UpdateDisplay()
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this._selectedIndex -lt $this._tasks.Count - 1) {
                    $this._selectedIndex++
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                    
                    # Adjust scroll if needed
                    $visibleEnd = $this._taskListPanel.ScrollOffsetY + $this._taskListPanel.ContentHeight - 1
                    if ($this._selectedIndex -gt $visibleEnd) {
                        $this._taskListPanel.ScrollDown()
                    }
                    
                    $this._UpdateDisplay()
                }
            }
            ([ConsoleKey]::PageUp) {
                $this._taskListPanel.ScrollUp($this._taskListPanel.ContentHeight)
                $this._selectedIndex = [Math]::Max(0, $this._selectedIndex - $this._taskListPanel.ContentHeight)
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::PageDown) {
                $this._taskListPanel.ScrollDown($this._taskListPanel.ContentHeight)
                $this._selectedIndex = [Math]::Min($this._tasks.Count - 1, $this._selectedIndex + $this._taskListPanel.ContentHeight)
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::Home) {
                $this._taskListPanel.ScrollToTop()
                $this._selectedIndex = 0
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::End) {
                $this._taskListPanel.ScrollToBottom()
                $this._selectedIndex = $this._tasks.Count - 1
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::Enter) {
                # Edit task - would trigger command palette or dialog
                Write-Verbose "TaskListScreen: Edit task requested for: $($this._selectedTask.Title)"
            }
            ([ConsoleKey]::D) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    # Delete task
                    Write-Verbose "TaskListScreen: Delete task requested for: $($this._selectedTask.Title)"
                }
            }
            ([ConsoleKey]::N) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    # New task
                    Write-Verbose "TaskListScreen: New task requested"
                }
            }
            default {
                # Unhandled key
            }
        }
    }
}

#endregion


####\AllServices.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================

#region Service Classes

# ===== CLASS: ActionService =====
# Module: action-service (from axiom)
# Dependencies: EventManager (optional)
# Purpose: Central command registry and execution service
class ActionService {
    [hashtable]$ActionRegistry = @{}
    [hashtable]$EventSubscriptions = @{}
    [object]$EventManager = $null
    
    ActionService() {
        Write-Verbose "ActionService: Initialized with empty registry"
    }
    
    ActionService([object]$eventManager) {
        $this.EventManager = $eventManager
        Write-Verbose "ActionService: Initialized with EventManager integration"
    }
    
    [void] RegisterAction([string]$actionName, [scriptblock]$action, [hashtable]$metadata = @{}) {
        try {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw "Action name cannot be null or empty"
            }
            if (-not $action) {
                throw "Action scriptblock cannot be null"
            }
            
            $actionData = @{
                Name = $actionName
                Action = $action
                Category = $metadata.Category ?? "General"
                Description = $metadata.Description ?? ""
                Hotkey = $metadata.Hotkey ?? ""
                RegisteredAt = [datetime]::Now
                ExecutionCount = 0
                LastExecuted = $null
                Metadata = $metadata
            }
            
            $this.ActionRegistry[$actionName] = $actionData
            
            # Publish event if EventManager available
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Registered", @{
                    ActionName = $actionName
                    Category = $actionData.Category
                })
            }
            
            Write-Verbose "ActionService: Registered action '$actionName' in category '$($actionData.Category)'"
        }
        catch {
            Write-Error "Failed to register action '$actionName': $_"
            throw
        }
    }
    
    [void] UnregisterAction([string]$actionName) {
        if ($this.ActionRegistry.ContainsKey($actionName)) {
            $this.ActionRegistry.Remove($actionName)
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Unregistered", @{
                    ActionName = $actionName
                })
            }
            
            Write-Verbose "ActionService: Unregistered action '$actionName'"
        }
    }
    
    [object] ExecuteAction([string]$actionName, [hashtable]$parameters = @{}) {
        try {
            if (-not $this.ActionRegistry.ContainsKey($actionName)) {
                throw "Action '$actionName' not found in registry"
            }
            
            $actionData = $this.ActionRegistry[$actionName]
            
            # Update execution metadata
            $actionData.ExecutionCount++
            $actionData.LastExecuted = [datetime]::Now
            
            Write-Verbose "ActionService: Executing action '$actionName' with $($parameters.Count) parameters"
            
            # Execute the action
            $result = & $actionData.Action @parameters
            
            # Publish execution event
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Executed", @{
                    ActionName = $actionName
                    Parameters = $parameters
                    Success = $true
                })
            }
            
            return $result
        }
        catch {
            Write-Error "Failed to execute action '$actionName': $_"
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Executed", @{
                    ActionName = $actionName
                    Parameters = $parameters
                    Success = $false
                    Error = $_.ToString()
                })
            }
            
            throw
        }
    }
    
    [hashtable] GetAction([string]$actionName) {
        return $this.ActionRegistry[$actionName]
    }
    
    [hashtable[]] GetAllActions() {
        return $this.ActionRegistry.Values | ForEach-Object { $_ }
    }
    
    [hashtable[]] GetActionsByCategory([string]$category) {
        return $this.ActionRegistry.Values | Where-Object { $_.Category -eq $category }
    }
    
    [void] RegisterDefaultActions() {
        # Register built-in actions
        $this.RegisterAction("app.exit", {
            Write-Verbose "Executing app.exit action"
            $global:TuiState.Running = $false
        }, @{
            Category = "Application"
            Description = "Exit the application"
            Hotkey = "Ctrl+Q"
        })
        
        $this.RegisterAction("app.help", {
            Write-Verbose "Executing app.help action"
            # Would show help screen
        }, @{
            Category = "Application"
            Description = "Show help"
            Hotkey = "F1"
        })
        
        Write-Verbose "ActionService: Registered default actions"
    }
}

# ===== CLASS: KeybindingService =====
# Module: keybinding-service (from axiom)
# Dependencies: ActionService (optional)
# Purpose: Global keyboard shortcut management
class KeybindingService {
    [hashtable]$KeyMap = @{}
    [hashtable]$GlobalHandlers = @{}
    [System.Collections.Generic.Stack[hashtable]]$ContextStack
    [ActionService]$ActionService
    [bool]$EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.Stack[hashtable]]::new()
        $this._InitializeDefaultBindings()
    }
    
    KeybindingService([ActionService]$actionService) {
        $this.ActionService = $actionService
        $this.ContextStack = [System.Collections.Generic.Stack[hashtable]]::new()
        $this._InitializeDefaultBindings()
    }
    
    hidden [void] _InitializeDefaultBindings() {
        # Default global bindings
        $this.SetBinding("Ctrl+Q", "app.exit", "Global")
        $this.SetBinding("F1", "app.help", "Global")
        $this.SetBinding("Ctrl+P", "app.commandPalette", "Global")
        
        # Navigation bindings
        $this.SetBinding("Tab", "navigation.nextComponent", "Global")
        $this.SetBinding("Shift+Tab", "navigation.previousComponent", "Global")
        
        # Arrow keys
        $this.SetBinding("UpArrow", "navigation.up", "Global")
        $this.SetBinding("DownArrow", "navigation.down", "Global")
        $this.SetBinding("LeftArrow", "navigation.left", "Global")
        $this.SetBinding("RightArrow", "navigation.right", "Global")
        
        Write-Verbose "KeybindingService: Initialized default keybindings"
    }
    
    [void] SetBinding([string]$keyPattern, [string]$actionName, [string]$context = "Global") {
        if (-not $this.KeyMap.ContainsKey($context)) {
            $this.KeyMap[$context] = @{}
        }
        
        $this.KeyMap[$context][$keyPattern] = $actionName
        Write-Verbose "KeybindingService: Bound '$keyPattern' to '$actionName' in context '$context'"
    }
    
    [void] RemoveBinding([string]$keyPattern, [string]$context = "Global") {
        if ($this.KeyMap.ContainsKey($context)) {
            $this.KeyMap[$context].Remove($keyPattern)
            Write-Verbose "KeybindingService: Removed binding for '$keyPattern' in context '$context'"
        }
    }
    
    [bool] IsAction([System.ConsoleKeyInfo]$keyInfo, [string]$actionName) {
        $keyPattern = $this._GetKeyPattern($keyInfo)
        
        # Check current context stack
        foreach ($context in $this.ContextStack) {
            if ($context.ContainsKey($keyPattern) -and $context[$keyPattern] -eq $actionName) {
                return $true
            }
        }
        
        # Check global context
        if ($this.KeyMap.ContainsKey("Global") -and 
            $this.KeyMap["Global"].ContainsKey($keyPattern) -and
            $this.KeyMap["Global"][$keyPattern] -eq $actionName) {
            return $true
        }
        
        return $false
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        $keyPattern = $this._GetKeyPattern($keyInfo)
        
        # Check current context stack (most recent first)
        foreach ($context in $this.ContextStack) {
            if ($context.ContainsKey($keyPattern)) {
                return $context[$keyPattern]
            }
        }
        
        # Check global context
        if ($this.KeyMap.ContainsKey("Global") -and $this.KeyMap["Global"].ContainsKey($keyPattern)) {
            return $this.KeyMap["Global"][$keyPattern]
        }
        
        return $null
    }
    
    [string] GetBindingDescription([System.ConsoleKeyInfo]$keyInfo) {
        $action = $this.GetAction($keyInfo)
        if ($action -and $this.ActionService) {
            $actionData = $this.ActionService.GetAction($action)
            if ($actionData) {
                return $actionData.Description
            }
        }
        return $null
    }
    
    hidden [string] _GetKeyPattern([System.ConsoleKeyInfo]$keyInfo) {
        $parts = @()
        
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) {
            $parts += "Ctrl"
        }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) {
            $parts += "Alt"
        }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) {
            $parts += "Shift"
        }
        
        $parts += $keyInfo.Key.ToString()
        
        return $parts -join "+"
    }
    
    [void] PushContext([hashtable]$contextBindings) {
        $this.ContextStack.Push($contextBindings)
        Write-Verbose "KeybindingService: Pushed new context with $($contextBindings.Count) bindings"
    }
    
    [void] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $removed = $this.ContextStack.Pop()
            Write-Verbose "KeybindingService: Popped context with $($removed.Count) bindings"
        }
    }
    
    [void] RegisterGlobalHandler([string]$handlerId, [scriptblock]$handler) {
        $this.GlobalHandlers[$handlerId] = $handler
        Write-Verbose "KeybindingService: Registered global handler '$handlerId'"
    }
    
    [void] UnregisterGlobalHandler([string]$handlerId) {
        $this.GlobalHandlers.Remove($handlerId)
        Write-Verbose "KeybindingService: Unregistered global handler '$handlerId'"
    }
}

# ===== CLASS: DataManager =====
# Module: data-manager (from axiom)
# Dependencies: EventManager (optional), PmcTask, PmcProject
# Purpose: High-performance data management with transactions
class DataManager {
    [hashtable]$Tasks = @{}
    [hashtable]$Projects = @{}
    [hashtable]$TasksByProject = @{}
    [string]$DataPath
    [EventManager]$EventManager
    [bool]$IsDirty = $false
    [bool]$AutoSave = $true
    [int]$BatchUpdateCount = 0
    [datetime]$LastSave = [datetime]::Now
    [hashtable]$Metadata = @{}
    [int]$MaxBackups = 5
    
    DataManager() {
        $this.DataPath = Join-Path $env:APPDATA "AxiomPhoenix\data.json"
        $this._Initialize()
    }
    
    DataManager([string]$dataPath) {
        $this.DataPath = $dataPath
        $this._Initialize()
    }
    
    DataManager([string]$dataPath, [EventManager]$eventManager) {
        $this.DataPath = $dataPath
        $this.EventManager = $eventManager
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $dataDir = Split-Path -Parent $this.DataPath
        if (-not (Test-Path $dataDir)) {
            New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
        }
        
        Write-Verbose "DataManager: Initialized with data path: $($this.DataPath)"
    }
    
    [void] LoadData() {
        try {
            if (Test-Path $this.DataPath) {
                $jsonContent = Get-Content -Path $this.DataPath -Raw
                $data = $jsonContent | ConvertFrom-Json -AsHashtable
                
                # Load tasks
                $this.Tasks.Clear()
                $this.TasksByProject.Clear()
                
                if ($data.ContainsKey('Tasks')) {
                    foreach ($taskData in $data.Tasks) {
                        $task = [PmcTask]::new()
                        # Map properties
                        $taskData.GetEnumerator() | ForEach-Object {
                            if ($task.PSObject.Properties.Match($_.Name)) {
                                $task.($_.Name) = $_.Value
                            }
                        }
                        
                        $this.Tasks[$task.Id] = $task
                        
                        # Update project index
                        if (-not $this.TasksByProject.ContainsKey($task.ProjectKey)) {
                            $this.TasksByProject[$task.ProjectKey] = @()
                        }
                        $this.TasksByProject[$task.ProjectKey] += $task.Id
                    }
                }
                
                # Load projects
                $this.Projects.Clear()
                if ($data.ContainsKey('Projects')) {
                    foreach ($projectData in $data.Projects) {
                        $project = [PmcProject]::new()
                        # Map properties
                        $projectData.GetEnumerator() | ForEach-Object {
                            if ($project.PSObject.Properties.Match($_.Name)) {
                                $project.($_.Name) = $_.Value
                            }
                        }
                        
                        $this.Projects[$project.Key] = $project
                    }
                }
                
                # Load metadata
                if ($data.ContainsKey('Metadata')) {
                    $this.Metadata = $data.Metadata
                }
                
                $this.IsDirty = $false
                Write-Verbose "DataManager: Loaded $($this.Tasks.Count) tasks and $($this.Projects.Count) projects"
                
                if ($this.EventManager) {
                    $this.EventManager.Publish("Data.Loaded", @{
                        TaskCount = $this.Tasks.Count
                        ProjectCount = $this.Projects.Count
                    })
                }
            }
            else {
                Write-Verbose "DataManager: No data file found at $($this.DataPath)"
            }
        }
        catch {
            Write-Error "Failed to load data: $_"
            throw [DataLoadException]::new("Failed to load data from $($this.DataPath)", "DataManager", @{}, $_)
        }
    }
    
    [void] SaveData() {
        try {
            if ($this.BatchUpdateCount -gt 0) {
                Write-Verbose "DataManager: Save deferred - batch update in progress"
                return
            }
            
            # Create backup if file exists
            if (Test-Path $this.DataPath) {
                $this._CreateBackup()
            }
            
            $data = @{
                Tasks = $this.Tasks.Values | ForEach-Object {
                    @{
                        Id = $_.Id
                        Title = $_.Title
                        Description = $_.Description
                        Status = $_.Status.ToString()
                        Priority = $_.Priority.ToString()
                        ProjectKey = $_.ProjectKey
                        Category = $_.Category
                        CreatedAt = $_.CreatedAt
                        UpdatedAt = $_.UpdatedAt
                        DueDate = $_.DueDate
                        Tags = $_.Tags
                        Progress = $_.Progress
                        Completed = $_.Completed
                    }
                }
                Projects = $this.Projects.Values | ForEach-Object {
                    @{
                        Key = $_.Key
                        Name = $_.Name
                        Description = $_.Description
                        CreatedAt = $_.CreatedAt
                        UpdatedAt = $_.UpdatedAt
                        Owner = $_.Owner
                        Tags = $_.Tags
                        Metadata = $_.Metadata
                        IsActive = $_.IsActive
                    }
                }
                Metadata = $this.Metadata
                SavedAt = [datetime]::Now
            }
            
            $jsonContent = $data | ConvertTo-Json -Depth 10
            Set-Content -Path $this.DataPath -Value $jsonContent -Force
            
            $this.IsDirty = $false
            $this.LastSave = [datetime]::Now
            
            Write-Verbose "DataManager: Saved $($this.Tasks.Count) tasks and $($this.Projects.Count) projects"
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Data.Saved", @{
                    TaskCount = $this.Tasks.Count
                    ProjectCount = $this.Projects.Count
                })
            }
        }
        catch {
            Write-Error "Failed to save data: $_"
            throw
        }
    }
    
    hidden [void] _CreateBackup() {
        try {
            $backupDir = Join-Path (Split-Path -Parent $this.DataPath) "backups"
            if (-not (Test-Path $backupDir)) {
                New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
            }
            
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $backupPath = Join-Path $backupDir "data_$timestamp.json"
            
            Copy-Item -Path $this.DataPath -Destination $backupPath -Force
            
            # Clean old backups
            $backups = Get-ChildItem -Path $backupDir -Filter "data_*.json" | 
                       Sort-Object -Property LastWriteTime -Descending
            
            if ($backups.Count -gt $this.MaxBackups) {
                $backups | Select-Object -Skip $this.MaxBackups | Remove-Item -Force
            }
            
            Write-Verbose "DataManager: Created backup at $backupPath"
        }
        catch {
            Write-Warning "Failed to create backup: $_"
        }
    }
    
    # Task operations
    [PmcTask[]] GetTasks() {
        return $this.Tasks.Values | ForEach-Object { $_ }
    }
    
    [PmcTask] GetTask([string]$id) {
        return $this.Tasks[$id]
    }
    
    [PmcTask[]] GetTasksByProject([string]$projectKey) {
        if ($this.TasksByProject.ContainsKey($projectKey)) {
            return $this.TasksByProject[$projectKey] | ForEach-Object { $this.Tasks[$_] } | Where-Object { $_ }
        }
        return @()
    }
    
    [void] AddTask([PmcTask]$task) {
        if (-not $task) {
            throw [ArgumentNullException]::new("task")
        }
        
        $this.Tasks[$task.Id] = $task
        
        # Update project index
        if (-not $this.TasksByProject.ContainsKey($task.ProjectKey)) {
            $this.TasksByProject[$task.ProjectKey] = @()
        }
        $this.TasksByProject[$task.ProjectKey] += $task.Id
        
        $this.IsDirty = $true
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Data.TaskAdded", @{ Task = $task })
        }
        
        if ($this.AutoSave -and $this.BatchUpdateCount -eq 0) {
            $this.SaveData()
        }
        
        Write-Verbose "DataManager: Added task '$($task.Title)' with ID: $($task.Id)"
    }
    
    [void] UpdateTask([PmcTask]$task) {
        if (-not $task) {
            throw [ArgumentNullException]::new("task")
        }
        
        if (-not $this.Tasks.ContainsKey($task.Id)) {
            throw "Task with ID '$($task.Id)' not found"
        }
        
        $oldTask = $this.Tasks[$task.Id]
        
        # Update project index if project changed
        if ($oldTask.ProjectKey -ne $task.ProjectKey) {
            # Remove from old project
            if ($this.TasksByProject.ContainsKey($oldTask.ProjectKey)) {
                $this.TasksByProject[$oldTask.ProjectKey] = 
                    $this.TasksByProject[$oldTask.ProjectKey] | Where-Object { $_ -ne $task.Id }
            }
            
            # Add to new project
            if (-not $this.TasksByProject.ContainsKey($task.ProjectKey)) {
                $this.TasksByProject[$task.ProjectKey] = @()
            }
            $this.TasksByProject[$task.ProjectKey] += $task.Id
        }
        
        $this.Tasks[$task.Id] = $task
        $this.IsDirty = $true
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Data.TaskUpdated", @{ 
                Task = $task
                OldTask = $oldTask
            })
        }
        
        if ($this.AutoSave -and $this.BatchUpdateCount -eq 0) {
            $this.SaveData()
        }
        
        Write-Verbose "DataManager: Updated task '$($task.Title)'"
    }
    
    [void] RemoveTask([string]$id) {
        if ($this.Tasks.ContainsKey($id)) {
            $task = $this.Tasks[$id]
            
            # Remove from project index
            if ($this.TasksByProject.ContainsKey($task.ProjectKey)) {
                $this.TasksByProject[$task.ProjectKey] = 
                    $this.TasksByProject[$task.ProjectKey] | Where-Object { $_ -ne $id }
            }
            
            $this.Tasks.Remove($id)
            $this.IsDirty = $true
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Data.TaskRemoved", @{ TaskId = $id })
            }
            
            if ($this.AutoSave -and $this.BatchUpdateCount -eq 0) {
                $this.SaveData()
            }
            
            Write-Verbose "DataManager: Removed task with ID: $id"
        }
    }
    
    # Project operations
    [PmcProject[]] GetProjects() {
        return $this.Projects.Values | ForEach-Object { $_ }
    }
    
    [PmcProject] GetProject([string]$key) {
        return $this.Projects[$key]
    }
    
    [void] AddProject([PmcProject]$project) {
        if (-not $project) {
            throw [ArgumentNullException]::new("project")
        }
        
        $this.Projects[$project.Key] = $project
        $this.IsDirty = $true
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Data.ProjectAdded", @{ Project = $project })
        }
        
        if ($this.AutoSave -and $this.BatchUpdateCount -eq 0) {
            $this.SaveData()
        }
        
        Write-Verbose "DataManager: Added project '$($project.Name)' with key: $($project.Key)"
    }
    
    [void] UpdateProject([PmcProject]$project) {
        if (-not $project) {
            throw [ArgumentNullException]::new("project")
        }
        
        if (-not $this.Projects.ContainsKey($project.Key)) {
            throw "Project with key '$($project.Key)' not found"
        }
        
        $oldProject = $this.Projects[$project.Key]
        $this.Projects[$project.Key] = $project
        $this.IsDirty = $true
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Data.ProjectUpdated", @{ 
                Project = $project
                OldProject = $oldProject
            })
        }
        
        if ($this.AutoSave -and $this.BatchUpdateCount -eq 0) {
            $this.SaveData()
        }
        
        Write-Verbose "DataManager: Updated project '$($project.Name)'"
    }
    
    # Transaction support
    [void] BeginUpdate() {
        $this.BatchUpdateCount++
        Write-Verbose "DataManager: Began batch update (level: $($this.BatchUpdateCount))"
    }
    
    [void] EndUpdate() {
        $this.BatchUpdateCount--
        if ($this.BatchUpdateCount -eq 0 -and $this.IsDirty -and $this.AutoSave) {
            $this.SaveData()
        }
        Write-Verbose "DataManager: Ended batch update (level: $($this.BatchUpdateCount))"
    }
}

# ===== CLASS: NavigationService =====
# Module: navigation-service (from axiom)
# Dependencies: EventManager (optional)
# Purpose: Screen navigation and history management
class NavigationService {
    [System.Collections.Generic.Stack[Screen]]$NavigationStack
    [Screen]$CurrentScreen
    [EventManager]$EventManager
    [hashtable]$ScreenRegistry = @{}
    [int]$MaxStackSize = 10
    
    NavigationService() {
        $this.NavigationStack = [System.Collections.Generic.Stack[Screen]]::new()
    }
    
    NavigationService([EventManager]$eventManager) {
        $this.NavigationStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.EventManager = $eventManager
    }
    
    [void] RegisterScreen([string]$name, [Screen]$screen) {
        $this.ScreenRegistry[$name] = $screen
        Write-Verbose "NavigationService: Registered screen '$name'"
    }
    
    [void] NavigateTo([Screen]$screen) {
        if (-not $screen) {
            throw [ArgumentNullException]::new("screen")
        }
        
        try {
            # Exit current screen
            if ($this.CurrentScreen) {
                Write-Verbose "NavigationService: Exiting screen '$($this.CurrentScreen.Name)'"
                $this.CurrentScreen.OnExit()
                $this.NavigationStack.Push($this.CurrentScreen)
                
                # Limit stack size
                if ($this.NavigationStack.Count -gt $this.MaxStackSize) {
                    $tempStack = [System.Collections.Generic.Stack[Screen]]::new()
                    for ($i = 0; $i -lt $this.MaxStackSize - 1; $i++) {
                        $tempStack.Push($this.NavigationStack.Pop())
                    }
                    $this.NavigationStack.Clear()
                    while ($tempStack.Count -gt 0) {
                        $this.NavigationStack.Push($tempStack.Pop())
                    }
                }
            }
            
            # Enter new screen
            $this.CurrentScreen = $screen
            Write-Verbose "NavigationService: Entering screen '$($screen.Name)'"
            
            if (-not $screen._isInitialized) {
                $screen.Initialize()
                $screen._isInitialized = $true
            }
            
            $screen.OnEnter()
            
            # Publish navigation event
            if ($this.EventManager) {
                $this.EventManager.Publish("Navigation.ScreenChanged", @{
                    Screen = $screen
                    ScreenName = $screen.Name
                    StackDepth = $this.NavigationStack.Count
                })
            }
            
            # Update global state
            $global:TuiState.CurrentScreen = $screen
            $global:TuiState.IsDirty = $true
        }
        catch {
            Write-Error "NavigationService: Failed to navigate to screen '$($screen.Name)': $_"
            throw [NavigationException]::new(
                "Failed to navigate to screen '$($screen.Name)'",
                "NavigationService",
                @{ ScreenName = $screen.Name },
                $_
            )
        }
    }
    
    [void] NavigateToByName([string]$screenName) {
        if (-not $this.ScreenRegistry.ContainsKey($screenName)) {
            throw "Screen '$screenName' not found in registry"
        }
        
        $this.NavigateTo($this.ScreenRegistry[$screenName])
    }
    
    [bool] CanGoBack() {
        return $this.NavigationStack.Count -gt 0
    }
    
    [void] GoBack() {
        if (-not $this.CanGoBack()) {
            Write-Warning "NavigationService: Cannot go back - navigation stack is empty"
            return
        }
        
        try {
            # Exit current screen
            if ($this.CurrentScreen) {
                Write-Verbose "NavigationService: Exiting screen '$($this.CurrentScreen.Name)' (going back)"
                $this.CurrentScreen.OnExit()
            }
            
            # Pop and resume previous screen
            $previousScreen = $this.NavigationStack.Pop()
            $this.CurrentScreen = $previousScreen
            
            Write-Verbose "NavigationService: Resuming screen '$($previousScreen.Name)'"
            $previousScreen.OnResume()
            
            # Publish navigation event
            if ($this.EventManager) {
                $this.EventManager.Publish("Navigation.BackNavigation", @{
                    Screen = $previousScreen
                    ScreenName = $previousScreen.Name
                    StackDepth = $this.NavigationStack.Count
                })
            }
            
            # Update global state
            $global:TuiState.CurrentScreen = $previousScreen
            $global:TuiState.IsDirty = $true
        }
        catch {
            Write-Error "NavigationService: Failed to go back: $_"
            throw [NavigationException]::new(
                "Failed to navigate back",
                "NavigationService",
                @{ StackDepth = $this.NavigationStack.Count },
                $_
            )
        }
    }
    
    [void] Reset() {
        # Clean up all screens in stack
        while ($this.NavigationStack.Count -gt 0) {
            $screen = $this.NavigationStack.Pop()
            try {
                $screen.Cleanup()
            }
            catch {
                Write-Warning "NavigationService: Error cleaning up screen '$($screen.Name)': $_"
            }
        }
        
        # Clean up current screen
        if ($this.CurrentScreen) {
            try {
                $this.CurrentScreen.OnExit()
                $this.CurrentScreen.Cleanup()
            }
            catch {
                Write-Warning "NavigationService: Error cleaning up current screen: $_"
            }
            $this.CurrentScreen = $null
        }
        
        Write-Verbose "NavigationService: Reset complete"
    }
}

# ===== CLASS: ThemeManager =====
# Module: theme-manager (from axiom)
# Dependencies: None
# Purpose: Visual theming system with hot-swapping
class ThemeManager {
    [hashtable]$CurrentTheme = @{}
    [string]$ThemeName = "Default"
    [hashtable]$ThemeRegistry = @{}
    [string]$ThemePath
    
    ThemeManager() {
        $this.ThemePath = Join-Path $env:APPDATA "AxiomPhoenix\themes"
        $this._Initialize()
    }
    
    ThemeManager([string]$themePath) {
        $this.ThemePath = $themePath
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        if (-not (Test-Path $this.ThemePath)) {
            New-Item -ItemType Directory -Path $this.ThemePath -Force | Out-Null
        }
        
        $this.LoadDefaultTheme()
        Write-Verbose "ThemeManager: Initialized with theme path: $($this.ThemePath)"
    }
    
    [void] LoadDefaultTheme() {
        $this.CurrentTheme = @{
            # Base colors
            'Foreground' = [ConsoleColor]::White
            'Background' = [ConsoleColor]::Black
            'Accent' = [ConsoleColor]::Cyan
            'Header' = [ConsoleColor]::Cyan
            'Subtle' = [ConsoleColor]::DarkGray
            'Highlight' = [ConsoleColor]::Yellow
            'Border' = [ConsoleColor]::Gray
            'Selection' = [ConsoleColor]::DarkBlue
            'Error' = [ConsoleColor]::Red
            'Warning' = [ConsoleColor]::Yellow
            'Success' = [ConsoleColor]::Green
            'Info' = [ConsoleColor]::Cyan
            
            # Component-specific colors
            'button.normal.background' = [ConsoleColor]::Black
            'button.normal.foreground' = [ConsoleColor]::White
            'button.normal.border' = [ConsoleColor]::Gray
            'button.focus.background' = [ConsoleColor]::Black
            'button.focus.foreground' = [ConsoleColor]::White
            'button.focus.border' = [ConsoleColor]::Cyan
            'button.pressed.background' = [ConsoleColor]::DarkGray
            'button.pressed.foreground' = [ConsoleColor]::Black
            'button.pressed.border' = [ConsoleColor]::Cyan
            
            'textbox.normal.background' = [ConsoleColor]::Black
            'textbox.normal.foreground' = [ConsoleColor]::White
            'textbox.normal.border' = [ConsoleColor]::Gray
            'textbox.focus.background' = [ConsoleColor]::Black
            'textbox.focus.foreground' = [ConsoleColor]::White
            'textbox.focus.border' = [ConsoleColor]::Cyan
            'textbox.placeholder' = [ConsoleColor]::DarkGray
            
            'checkbox.normal.foreground' = [ConsoleColor]::White
            'checkbox.checked.foreground' = [ConsoleColor]::Green
            'checkbox.focus.foreground' = [ConsoleColor]::Cyan
            
            'panel.background' = [ConsoleColor]::Black
            'panel.foreground' = [ConsoleColor]::White
            'panel.border' = [ConsoleColor]::Gray
            'panel.title' = [ConsoleColor]::Cyan
            
            'list.item.normal' = [ConsoleColor]::White
            'list.item.selected' = [ConsoleColor]::Black
            'list.item.selected.background' = [ConsoleColor]::Cyan
            'list.scrollbar' = [ConsoleColor]::DarkGray
            
            'dialog.background' = [ConsoleColor]::Black
            'dialog.foreground' = [ConsoleColor]::White
            'dialog.border' = [ConsoleColor]::Yellow
            'dialog.title' = [ConsoleColor]::Yellow
            'dialog.shadow' = [ConsoleColor]::DarkGray
        }
        
        $this.ThemeName = "Default"
        Write-Verbose "ThemeManager: Loaded default theme"
    }
    
    [object] GetColor([string]$colorName) {
        if ($this.CurrentTheme.ContainsKey($colorName)) {
            return $this.CurrentTheme[$colorName]
        }
        
        # Fallback to base color
        if ($colorName -match '\.') {
            $baseColor = $colorName.Split('.')[0]
            if ($this.CurrentTheme.ContainsKey($baseColor)) {
                return $this.CurrentTheme[$baseColor]
            }
        }
        
        Write-Warning "ThemeManager: Color '$colorName' not found in theme, using White"
        return [ConsoleColor]::White
    }
    
    [void] SetColor([string]$colorName, [object]$color) {
        $this.CurrentTheme[$colorName] = $color
        Write-Verbose "ThemeManager: Set color '$colorName' to '$color'"
    }
    
    [void] LoadTheme([string]$themeName) {
        $themePath = Join-Path $this.ThemePath "$themeName.json"
        
        if (-not (Test-Path $themePath)) {
            throw "Theme file not found: $themePath"
        }
        
        try {
            $themeData = Get-Content -Path $themePath -Raw | ConvertFrom-Json -AsHashtable
            
            # Convert color values
            $this.CurrentTheme.Clear()
            foreach ($key in $themeData.Keys) {
                $value = $themeData[$key]
                
                # Handle ConsoleColor enum values
                if ($value -is [string] -and [Enum]::TryParse([ConsoleColor], $value, [ref]$null)) {
                    $this.CurrentTheme[$key] = [Enum]::Parse([ConsoleColor], $value)
                }
                # Handle hex colors
                elseif ($value -is [string] -and $value -match '^#[0-9A-Fa-f]{6}$') {
                    $this.CurrentTheme[$key] = $value
                }
                else {
                    $this.CurrentTheme[$key] = $value
                }
            }
            
            $this.ThemeName = $themeName
            Write-Verbose "ThemeManager: Loaded theme '$themeName' from file"
        }
        catch {
            Write-Error "Failed to load theme '$themeName': $_"
            throw
        }
    }
    
    [void] SaveTheme([string]$themeName) {
        $themePath = Join-Path $this.ThemePath "$themeName.json"
        
        try {
            # Convert ConsoleColor enums to strings for JSON
            $themeData = @{}
            foreach ($key in $this.CurrentTheme.Keys) {
                $value = $this.CurrentTheme[$key]
                if ($value -is [ConsoleColor]) {
                    $themeData[$key] = $value.ToString()
                }
                else {
                    $themeData[$key] = $value
                }
            }
            
            $jsonContent = $themeData | ConvertTo-Json -Depth 10
            Set-Content -Path $themePath -Value $jsonContent -Force
            
            Write-Verbose "ThemeManager: Saved theme '$themeName' to file"
        }
        catch {
            Write-Error "Failed to save theme '$themeName': $_"
            throw
        }
    }
    
    [hashtable] CreateTheme([string]$themeName, [hashtable]$baseTheme = @{}) {
        $newTheme = if ($baseTheme.Count -gt 0) { 
            $baseTheme.Clone() 
        } else { 
            $this.CurrentTheme.Clone() 
        }
        
        $this.ThemeRegistry[$themeName] = $newTheme
        Write-Verbose "ThemeManager: Created theme '$themeName'"
        
        return $newTheme
    }
    
    [void] ApplyTheme([string]$themeName) {
        if ($this.ThemeRegistry.ContainsKey($themeName)) {
            $this.CurrentTheme = $this.ThemeRegistry[$themeName].Clone()
            $this.ThemeName = $themeName
            Write-Verbose "ThemeManager: Applied theme '$themeName' from registry"
        }
        else {
            $this.LoadTheme($themeName)
        }
    }
}

# ===== CLASS: Logger =====
# Module: logger (from axiom)
# Dependencies: None
# Purpose: Application-wide logging with multiple outputs
class Logger {
    [string]$LogPath
    [System.Collections.Queue]$LogQueue
    [int]$MaxQueueSize = 1000
    [bool]$EnableFileLogging = $true
    [bool]$EnableConsoleLogging = $false
    [string]$MinimumLevel = "Info"
    [hashtable]$LevelPriority = @{
        'Trace' = 0
        'Debug' = 1
        'Info' = 2
        'Warning' = 3
        'Error' = 4
        'Fatal' = 5
    }
    
    Logger() {
        $this.LogPath = Join-Path $env:APPDATA "AxiomPhoenix\app.log"
        $this._Initialize()
    }
    
    Logger([string]$logPath) {
        $this.LogPath = $logPath
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $this.LogQueue = [System.Collections.Queue]::new()
        
        $logDir = Split-Path -Parent $this.LogPath
        if (-not (Test-Path $logDir)) {
            New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        }
        
        Write-Verbose "Logger: Initialized with log path: $($this.LogPath)"
    }
    
    [void] Log([string]$message, [string]$level = "Info") {
        # Check if we should log this level
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) {
            return
        }
        
        $logEntry = @{
            Timestamp = [DateTime]::Now
            Level = $level
            Message = $message
            ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        }
        
        # Add to queue
        $this.LogQueue.Enqueue($logEntry)
        
        # Flush if queue is getting large
        if ($this.LogQueue.Count -ge $this.MaxQueueSize) {
            $this.Flush()
        }
        
        # Console logging if enabled
        if ($this.EnableConsoleLogging) {
            $this._WriteToConsole($logEntry)
        }
    }
    
    [void] LogException([Exception]$exception, [string]$message = "") {
        $exceptionDetails = @{
            Message = if ($message) { $message } else { "Exception occurred" }
            ExceptionType = $exception.GetType().FullName
            ExceptionMessage = $exception.Message
            StackTrace = $exception.StackTrace
            InnerException = if ($exception.InnerException) { 
                $exception.InnerException.Message 
            } else { 
                $null 
            }
        }
        
        $detailsJson = $exceptionDetails | ConvertTo-Json -Compress
        $this.Log($detailsJson, "Error")
    }
    
    [void] Flush() {
        if ($this.LogQueue.Count -eq 0 -or -not $this.EnableFileLogging) {
            return
        }
        
        try {
            $logContent = [System.Text.StringBuilder]::new()
            
            while ($this.LogQueue.Count -gt 0) {
                $entry = $this.LogQueue.Dequeue()
                $logLine = "$($entry.Timestamp.ToString('yyyy-MM-dd HH:mm:ss.fff')) [$($entry.Level.ToUpper().PadRight(7))] [Thread:$($entry.ThreadId)] $($entry.Message)"
                [void]$logContent.AppendLine($logLine)
            }
            
            if ($logContent.Length -gt 0) {
                Add-Content -Path $this.LogPath -Value $logContent.ToString() -NoNewline
            }
        }
        catch {
            Write-Warning "Logger: Failed to flush logs: $_"
        }
    }
    
    hidden [void] _WriteToConsole([hashtable]$logEntry) {
        $color = switch ($logEntry.Level) {
            'Trace' { [ConsoleColor]::DarkGray }
            'Debug' { [ConsoleColor]::Gray }
            'Info' { [ConsoleColor]::White }
            'Warning' { [ConsoleColor]::Yellow }
            'Error' { [ConsoleColor]::Red }
            'Fatal' { [ConsoleColor]::Magenta }
            default { [ConsoleColor]::White }
        }
        
        $timestamp = $logEntry.Timestamp.ToString('HH:mm:ss')
        $prefix = "[$timestamp] [$($logEntry.Level.ToUpper())]"
        
        Write-Host $prefix -ForegroundColor $color -NoNewline
        Write-Host " $($logEntry.Message)" -ForegroundColor White
    }
    
    [void] Cleanup() {
        $this.Flush()
        Write-Verbose "Logger: Cleanup complete"
    }
}

# ===== CLASS: EventManager =====
# Module: event-system (from axiom)
# Dependencies: None
# Purpose: Pub/sub event system for decoupled communication
class EventManager {
    [hashtable]$EventHandlers = @{}
    [int]$NextHandlerId = 1
    [System.Collections.Generic.List[hashtable]]$EventHistory
    [int]$MaxHistorySize = 100
    [bool]$EnableHistory = $true
    
    EventManager() {
        $this.EventHistory = [System.Collections.Generic.List[hashtable]]::new()
        Write-Verbose "EventManager: Initialized"
    }
    
    [string] Subscribe([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) {
            throw [ArgumentException]::new("Event name cannot be null or empty")
        }
        if (-not $handler) {
            throw [ArgumentNullException]::new("handler")
        }
        
        if (-not $this.EventHandlers.ContainsKey($eventName)) {
            $this.EventHandlers[$eventName] = @{}
        }
        
        $handlerId = "handler_$($this.NextHandlerId)"
        $this.NextHandlerId++
        
        $this.EventHandlers[$eventName][$handlerId] = @{
            Handler = $handler
            SubscribedAt = [DateTime]::Now
            ExecutionCount = 0
        }
        
        Write-Verbose "EventManager: Subscribed handler '$handlerId' to event '$eventName'"
        return $handlerId
    }
    
    [void] Unsubscribe([string]$eventName, [string]$handlerId) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            if ($this.EventHandlers[$eventName].ContainsKey($handlerId)) {
                $this.EventHandlers[$eventName].Remove($handlerId)
                Write-Verbose "EventManager: Unsubscribed handler '$handlerId' from event '$eventName'"
                
                # Clean up empty event entries
                if ($this.EventHandlers[$eventName].Count -eq 0) {
                    $this.EventHandlers.Remove($eventName)
                }
            }
        }
    }
    
    [void] UnsubscribeAll([string]$eventName) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlerCount = $this.EventHandlers[$eventName].Count
            $this.EventHandlers.Remove($eventName)
            Write-Verbose "EventManager: Unsubscribed all $handlerCount handlers from event '$eventName'"
        }
    }
    
    [void] Publish([string]$eventName, [hashtable]$eventData = @{}) {
        Write-Verbose "EventManager: Publishing event '$eventName'"
        
        # Add to history if enabled
        if ($this.EnableHistory) {
            $historyEntry = @{
                EventName = $eventName
                EventData = $eventData.Clone()
                Timestamp = [DateTime]::Now
                HandlerCount = 0
            }
            
            $this.EventHistory.Add($historyEntry)
            
            # Trim history if needed
            if ($this.EventHistory.Count -gt $this.MaxHistorySize) {
                $this.EventHistory.RemoveAt(0)
            }
        }
        
        # Execute handlers
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlers = @($this.EventHandlers[$eventName].GetEnumerator())
            $handlerCount = $handlers.Count
            
            if ($this.EnableHistory) {
                $this.EventHistory[-1].HandlerCount = $handlerCount
            }
            
            foreach ($entry in $handlers) {
                try {
                    $handlerData = $entry.Value
                    $handlerData.ExecutionCount++
                    
                    Write-Verbose "EventManager: Executing handler '$($entry.Key)' for event '$eventName'"
                    & $handlerData.Handler $eventData
                }
                catch {
                    Write-Error "EventManager: Error in handler '$($entry.Key)' for event '$eventName': $_"
                }
            }
            
            Write-Verbose "EventManager: Published event '$eventName' to $handlerCount handlers"
        }
        else {
            Write-Verbose "EventManager: No handlers registered for event '$eventName'"
        }
    }
    
    [hashtable[]] GetEventHistory([string]$eventName = $null) {
        if ($eventName) {
            return $this.EventHistory | Where-Object { $_.EventName -eq $eventName }
        }
        return $this.EventHistory | ForEach-Object { $_ }
    }
    
    [void] ClearHistory() {
        $this.EventHistory.Clear()
        Write-Verbose "EventManager: Cleared event history"
    }
    
    [hashtable] GetEventInfo() {
        $info = @{
            RegisteredEvents = @{}
            TotalHandlers = 0
        }
        
        foreach ($eventName in $this.EventHandlers.Keys) {
            $handlers = $this.EventHandlers[$eventName]
            $info.RegisteredEvents[$eventName] = @{
                HandlerCount = $handlers.Count
                Handlers = $handlers.Keys | ForEach-Object { $_ }
            }
            $info.TotalHandlers += $handlers.Count
        }
        
        return $info
    }
}

# ===== CLASS: TuiFrameworkService =====
# Module: tui-framework (from axiom)
# Dependencies: None
# Purpose: Framework utilities and async operations
class TuiFrameworkService {
    [hashtable]$AsyncJobs = @{}
    [int]$NextJobId = 1
    [bool]$IsRunning = $false
    
    TuiFrameworkService() {
        Write-Verbose "TuiFrameworkService: Initialized"
    }
    
    [hashtable] StartAsync([scriptblock]$work, [string]$name = "") {
        try {
            $jobId = $this.NextJobId++
            $jobName = if ($name) { $name } else { "AsyncJob_$jobId" }
            
            # Use ThreadJob for lightweight async operations
            $job = Start-ThreadJob -ScriptBlock $work -Name $jobName
            
            $jobInfo = @{
                Id = $jobId
                Name = $jobName
                Job = $job
                StartedAt = [DateTime]::Now
                Status = "Running"
            }
            
            $this.AsyncJobs[$jobId] = $jobInfo
            
            Write-Verbose "TuiFrameworkService: Started async job '$jobName' with ID $jobId"
            return $jobInfo
        }
        catch {
            Write-Error "Failed to start async job: $_"
            throw
        }
    }
    
    [object] GetAsyncResults([int]$jobId, [bool]$wait = $false) {
        if (-not $this.AsyncJobs.ContainsKey($jobId)) {
            throw "Async job with ID $jobId not found"
        }
        
        $jobInfo = $this.AsyncJobs[$jobId]
        $job = $jobInfo.Job
        
        if ($wait) {
            Write-Verbose "TuiFrameworkService: Waiting for job $jobId to complete"
            Wait-Job -Job $job | Out-Null
        }
        
        if ($job.State -eq "Completed") {
            $result = Receive-Job -Job $job -Keep
            $jobInfo.Status = "Completed"
            return $result
        }
        elseif ($job.State -eq "Failed") {
            $jobInfo.Status = "Failed"
            $error = Receive-Job -Job $job -Keep
            throw "Async job $jobId failed: $error"
        }
        else {
            return $null
        }
    }
    
    [void] StopAllAsyncJobs() {
        Write-Verbose "TuiFrameworkService: Stopping all async jobs"
        
        foreach ($jobInfo in $this.AsyncJobs.Values) {
            try {
                if ($jobInfo.Job.State -eq "Running") {
                    Stop-Job -Job $jobInfo.Job
                    Remove-Job -Job $jobInfo.Job -Force
                }
            }
            catch {
                Write-Warning "Failed to stop job $($jobInfo.Id): $_"
            }
        }
        
        $this.AsyncJobs.Clear()
    }
    
    [hashtable] GetState() {
        return @{
            IsRunning = $this.IsRunning
            AsyncJobCount = $this.AsyncJobs.Count
            ActiveJobs = $this.AsyncJobs.Values | Where-Object { $_.Status -eq "Running" } | Measure-Object | Select-Object -ExpandProperty Count
        }
    }
    
    [bool] IsRunning() {
        return $this.IsRunning
    }
    
    [void] Start() {
        $this.IsRunning = $true
        Write-Verbose "TuiFrameworkService: Started"
    }
    
    [void] Stop() {
        $this.StopAllAsyncJobs()
        $this.IsRunning = $false
        Write-Verbose "TuiFrameworkService: Stopped"
    }
    
    [void] Cleanup() {
        $this.Stop()
    }
}

#endregion


####\filecopy.ps1
#------------------------------------------------------------------------------------------
# SCRIPT:      filecopy-and-concatenate.ps1
#
# DESCRIPTION: Finds specified file types in a given path and its subdirectories.
#              For each file, it can create a .txt copy and/or concatenate all
#              file contents into a single output file.
#
# FEATURES:
#   - Full parameter support for path, file types, and output name.
#   - Safety features: Supports -WhatIf and -Confirm for all file operations.
#   - Verbose output: Use the -Verbose switch to see detailed progress.
#   - Performance: Uses an efficient single-write operation for the concatenated file.
#   - Robustness: Uses idiomatic PowerShell for path manipulation and error handling.
#   - Compatibility: Works on Windows PowerShell 5.1 and newer.
#
# USAGE:
#   # Basic run in the current folder for PowerShell files
#   .\filecopy-and-concatenate.ps1 -Verbose
#
#   # Run on a different project, for C# files, with a different output name
#   .\filecopy-and-concatenate.ps1 -Path "C:\Projects\MyWebApp" -Include "*.cs" -OutputFileName "SourceCode.txt"
#
#   # Perform a "dry run" to see what would happen without making any changes
#   .\filecopy-and-concatenate.ps1 -Path "C:\SomethingImportant" -WhatIf
#
#   # To also create individual .txt copies of each file:
#   .\filecopy-and-concatenate.ps1 -CreateIndividualCopies -Verbose
#
#------------------------------------------------------------------------------------------

# Enable support for -WhatIf, -Confirm, and advanced parameter binding
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    # The starting directory to search in. Defaults to the current directory.
    [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "The root path to search for files.")]
    [string]
    $Path = (Get-Location).Path,

    # An array of file patterns to include. Defaults to PowerShell script files.
    [Parameter(Mandatory = $false, HelpMessage = "File patterns to include, e.g., '*.ps1', '*.psm1'.")]
    [string[]]
    $Include = @("*.ps1", "*.psm1"),

    # The name of the final concatenated output file.
    [Parameter(Mandatory = $false, HelpMessage = "Name of the concatenated output file.")]
    [string]
    $OutputFileName = "all.txt",
    
    # Switch to create a .txt copy of each individual file found.
    [Parameter(Mandatory = $false, HelpMessage = "If specified, creates a .txt copy of each found file.")]
    [switch]
    $CreateIndividualCopies
)

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Resolve-Path returns a PathInfo object. We use it for robustness.
    $resolvedPathObject = Resolve-Path -Path $Path
    $outputFilePath = Join-Path -Path $resolvedPathObject.Path -ChildPath $OutputFileName

    Write-Verbose "Starting operations in: $($resolvedPathObject.Path)"
    Write-Verbose "Searching for file types: $($Include -join ', ')"
    Write-Verbose "Output file will be: $outputFilePath"

    # --- Step 1: Find all specified files recursively ---
    $filesToProcess = Get-ChildItem -Path $resolvedPathObject.Path -Recurse -Include $Include -File

    if ($null -eq $filesToProcess) {
        Write-Warning "No files found matching the specified criteria."
        return # Exit gracefully if no files are found
    }

    Write-Verbose "Found $($filesToProcess.Count) files to process."

    # --- Step 2: Clear the existing output file if it exists ---
    if ((Test-Path $outputFilePath) -and $PSCmdlet.ShouldProcess($outputFilePath, "Remove existing output file")) {
        Remove-Item $outputFilePath -Force
    }

    # --- Step 3: Process each file for individual copies (if requested) ---
    if ($CreateIndividualCopies.IsPresent) {
        foreach ($file in $filesToProcess) {
            $txtCopyPath = [System.IO.Path]::ChangeExtension($file.FullName, ".txt")
            if ($PSCmdlet.ShouldProcess($txtCopyPath, "Copy from $($file.Name)")) {
                Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force
                Write-Verbose "Copied '$($file.Name)' to '$($txtCopyPath)'"
            }
        }
    }

    # --- Step 4: Concatenate all files into the output file (Efficiently) ---
    Write-Verbose "Starting concatenation of all files into '$OutputFileName'..."
    if ($PSCmdlet.ShouldProcess($outputFilePath, "Concatenate $($filesToProcess.Count) files")) {
        Set-Content -Path $outputFilePath -Encoding UTF8 -Value $(
            foreach ($file in $filesToProcess) {
                # CORRECTED LINE: Get the length from the .Path property of the PathInfo object.
                $basePathString = $resolvedPathObject.Path
                $relativePath = $file.FullName.Substring($basePathString.Length)
                $relativePath = '\' + $relativePath.TrimStart('\/') # Ensure consistent format like '\subdir\file.ps1'
                
                # Output the header for this file
                "####$relativePath"
                
                # Output the file's content
                Get-Content -Path $file.FullName -Raw -Encoding UTF8
                
                # Output a blank line for separation
                ""
            }
        )
        Write-Host "All operations complete. Concatenated content saved to '$outputFilePath'."
    }

}
catch {
    # A global catch block for any unexpected, terminating errors.
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    Write-Error "Script execution halted at line $($_.InvocationInfo.ScriptLineNumber): $($_.InvocationInfo.Line)"
}

####\Start.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Application Entry Point
# Loads all framework files and starts the application
# ==============================================================================

#region Script Configuration

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
$VerbosePreference = 'SilentlyContinue'  # Change to 'Continue' for debug output

#endregion

#region Load Framework Files

try {
    Write-Host "Loading Axiom-Phoenix v4.0..." -ForegroundColor Cyan
    
    $scriptRoot = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent
    
    # Define files in dependency order (CRITICAL: Do not change order!)
    $filesToLoad = @(
        'AllBaseClasses.ps1'   # Foundation types with zero dependencies
        'AllModels.ps1'        # Data models, depends on base classes
        'AllComponents.ps1'    # UI components, depends on base + models
        'AllScreens.ps1'       # Screens, depends on all above
        'AllFunctions.ps1'     # Helper functions, can reference all classes
        'AllServices.ps1'      # Services, can use everything
        'AllRuntime.ps1'       # Engine and runtime, orchestrates everything
    )
    
    # Load each file
    foreach ($file in $filesToLoad) {
        $filePath = Join-Path $scriptRoot $file
        
        if (-not (Test-Path $filePath)) {
            throw "Required file not found: $filePath"
        }
        
        Write-Verbose "Loading: $file"
        . $filePath
    }
    
    Write-Host "Framework loaded successfully!" -ForegroundColor Green
}
catch {
    Write-Host "Failed to load framework files!" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    exit 1
}

#endregion

#region Initialize Services

try {
    Write-Host "Initializing services..." -ForegroundColor Cyan
    
    # Create service container
    $container = [ServiceContainer]::new()
    
    # Register core services
    $container.Register("Logger", [Logger]::new())
    $container.Register("EventManager", [EventManager]::new())
    $container.Register("ThemeManager", [ThemeManager]::new())
    
    # Register services that depend on EventManager
    $eventManager = $container.GetService("EventManager")
    $container.Register("ActionService", [ActionService]::new($eventManager))
    $container.Register("DataManager", [DataManager]::new((Join-Path $env:APPDATA "AxiomPhoenix\data.json"), $eventManager))
    $container.Register("NavigationService", [NavigationService]::new($eventManager))
    
    # Register services that depend on ActionService
    $actionService = $container.GetService("ActionService")
    $container.Register("KeybindingService", [KeybindingService]::new($actionService))
    
    # Register framework service
    $container.Register("TuiFrameworkService", [TuiFrameworkService]::new())
    
    # Initialize default actions
    $actionService.RegisterDefaultActions()
    
    # Register navigation actions
    $navService = $container.GetService("NavigationService")
    
    $actionService.RegisterAction("navigation.dashboard", {
        $dashboard = [DashboardScreen]::new($container)
        $navService.NavigateTo($dashboard)
    }, @{
        Category = "Navigation"
        Description = "Go to Dashboard"
    })
    
    $actionService.RegisterAction("navigation.taskList", {
        $taskList = [TaskListScreen]::new($container)
        $navService.NavigateTo($taskList)
    }, @{
        Category = "Navigation"
        Description = "Go to Task List"
    })
    
    Write-Host "Services initialized successfully!" -ForegroundColor Green
}
catch {
    Write-Host "Failed to initialize services!" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    exit 1
}

#endregion

#region Load Sample Data

try {
    Write-Host "Loading sample data..." -ForegroundColor Cyan
    
    $dataManager = $container.GetService("DataManager")
    
    # Try to load existing data first
    try {
        $dataManager.LoadData()
        
        if ($dataManager.Tasks.Count -eq 0) {
            throw "No existing data found"
        }
        
        Write-Host "Loaded $($dataManager.Tasks.Count) tasks from storage" -ForegroundColor Green
    }
    catch {
        Write-Host "Creating sample data..." -ForegroundColor Yellow
        
        # Create sample project
        $project = [PmcProject]::new("DEMO", "Demo Project", "Sample project for demonstration", "Admin")
        $dataManager.AddProject($project)
        
        # Create sample tasks
        $sampleTasks = @(
            @{
                Title = "Complete TUI Framework Migration"
                Description = "Migrate all axiom components to mono structure"
                Priority = [TaskPriority]::High
                Status = [TaskStatus]::InProgress
                Progress = 75
            },
            @{
                Title = "Write Documentation"
                Description = "Create comprehensive documentation for the framework"
                Priority = [TaskPriority]::Medium
                Status = [TaskStatus]::Pending
                Progress = 0
            },
            @{
                Title = "Add Unit Tests"
                Description = "Implement unit tests for core components"
                Priority = [TaskPriority]::Medium
                Status = [TaskStatus]::Pending
                Progress = 0
            },
            @{
                Title = "Optimize Rendering Performance"
                Description = "Profile and optimize the differential rendering system"
                Priority = [TaskPriority]::Low
                Status = [TaskStatus]::InProgress
                Progress = 30
            },
            @{
                Title = "Create Theme Editor"
                Description = "Build a visual theme editor screen"
                Priority = [TaskPriority]::Low
                Status = [TaskStatus]::Pending
                Progress = 0
            }
        )
        
        foreach ($taskData in $sampleTasks) {
            $task = [PmcTask]::new($taskData.Title, $taskData.Description, $taskData.Priority, "DEMO")
            $task.Status = $taskData.Status
            $task.Progress = $taskData.Progress
            
            if ($taskData.Progress -eq 100) {
                $task.Complete()
            }
            
            $dataManager.AddTask($task)
        }
        
        Write-Host "Created $($sampleTasks.Count) sample tasks" -ForegroundColor Green
    }
}
catch {
    Write-Warning "Failed to load sample data: $($_.Exception.Message)"
    # Continue anyway - app can run without data
}

#endregion

#region Start Application

try {
    Write-Host "`nStarting Axiom-Phoenix..." -ForegroundColor Cyan
    Write-Host "Press Ctrl+P to open the Command Palette" -ForegroundColor Yellow
    Write-Host "Press Ctrl+Q to exit`n" -ForegroundColor Yellow
    
    Start-Sleep -Seconds 2
    
    # Create initial screen
    $dashboardScreen = [DashboardScreen]::new($container)
    
    # Start the application
    Start-AxiomPhoenix -ServiceContainer $container -InitialScreen $dashboardScreen
}
catch {
    Write-Host "`nApplication error!" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    
    Write-Host "`nPress any key to exit..." -ForegroundColor White
    [Console]::ReadKey($true) | Out-Null
    exit 1
}
finally {
    # Ensure console is restored
    try {
        [Console]::CursorVisible = $true
        [Console]::Clear()
    }
    catch {}
}

#endregion


####\test.ps1
# Test if classes and functions load
cd "C:\Users\jhnhe\Documents\GitHub\_XP\_mono"
.\Start.ps1 -LoadOnly

# Check if critical components exist
Write-Host "`nChecking critical components:" -ForegroundColor Cyan
Write-Host "TuiBuffer class: $([TuiBuffer] -ne $null)" -ForegroundColor Yellow
Write-Host "TuiCell class: $([TuiCell] -ne $null)" -ForegroundColor Yellow
Write-Host "ServiceContainer class: $([ServiceContainer] -ne $null)" -ForegroundColor Yellow
Write-Host "Start-TuiEngine function: $(Get-Command Start-TuiEngine -ErrorAction SilentlyContinue)" -ForegroundColor Yellow
Write-Host "Initialize-TuiEngine function: $(Get-Command Initialize-TuiEngine -ErrorAction SilentlyContinue)" -ForegroundColor Yellow


