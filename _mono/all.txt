####\allbaseclasses.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#region TuiAnsiHelper - ANSI Code Generation with Truecolor Support
class TuiAnsiHelper {
    hidden static [System.Collections.Concurrent.ConcurrentDictionary[string, string]] $_fgCache = [System.Collections.Concurrent.ConcurrentDictionary[string, string]]::new()
    hidden static [System.Collections.Concurrent.ConcurrentDictionary[string, string]] $_bgCache = [System.Collections.Concurrent.ConcurrentDictionary[string, string]]::new()

    static [hashtable] $ColorMap = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }

    static [int[]] ParseHexColor([string]$hexColor) {
        if ([string]::IsNullOrWhiteSpace($hexColor) -or -not $hexColor.StartsWith("#")) { return $null }
        $hex = $hexColor.Substring(1)
        if ($hex.Length -eq 3) { $hex = "$($hex[0])$($hex[0])$($hex[1])$($hex[1])$($hex[2])$($hex[2])" }
        if ($hex.Length -ne 6) { return $null }
        try {
            $r = [System.Convert]::ToInt32($hex.Substring(0, 2), 16)
            $g = [System.Convert]::ToInt32($hex.Substring(2, 2), 16)
            $b = [System.Convert]::ToInt32($hex.Substring(4, 2), 16)
            return @($r, $g, $b)
        } catch { return $null }
    }

    static [string] GetForegroundCode($color) {
        if ($color -is [ConsoleColor]) {
            return "`e[$([TuiAnsiHelper]::ColorMap[$color.ToString()] ?? 37)m"
        } elseif ($color -is [string] -and $color.StartsWith("#")) {
            return [TuiAnsiHelper]::GetForegroundSequence($color)
        } else {
            return "`e[37m" 
        }
    }

    static [string] GetBackgroundCode($color) {
        if ($color -is [ConsoleColor]) {
            $code = ([TuiAnsiHelper]::ColorMap[$color.ToString()] ?? 30) + 10
            return "`e[${code}m"
        } elseif ($color -is [string] -and $color.StartsWith("#")) {
            return [TuiAnsiHelper]::GetBackgroundSequence($color)
        } else {
            return "`e[40m" 
        }
    }

    static [string] GetForegroundSequence([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor)) { return "" }
        if ([TuiAnsiHelper]::_fgCache.ContainsKey($hexColor)) { 
            return [TuiAnsiHelper]::_fgCache[$hexColor] 
        }
        $rgb = [TuiAnsiHelper]::ParseHexColor($hexColor)
        if (-not $rgb) { return "" }
        $sequence = "`e[38;2;$($rgb[0]);$($rgb[1]);$($rgb[2])m"
        [TuiAnsiHelper]::_fgCache[$hexColor] = $sequence
        return $sequence
    }
    
    static [string] GetBackgroundSequence([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor)) { return "" }
        if ([TuiAnsiHelper]::_bgCache.ContainsKey($hexColor)) { 
            return [TuiAnsiHelper]::_bgCache[$hexColor] 
        }
        $rgb = [TuiAnsiHelper]::ParseHexColor($hexColor)
        if (-not $rgb) { return "" }
        $sequence = "`e[48;2;$($rgb[0]);$($rgb[1]);$($rgb[2])m"
        [TuiAnsiHelper]::_bgCache[$hexColor] = $sequence
        return $sequence
    }
    
    static [string] Reset() { return "`e[0m" }
    static [string] Bold() { return "`e[1m" }
    static [string] Underline() { return "`e[4m" }
    static [string] Italic() { return "`e[3m" }
}
#endregion

#region TuiCell Class - Core Compositor Unit with Truecolor Support
class TuiCell {
    [char] $Char = ' '
    $ForegroundColor = [ConsoleColor]::White
    $BackgroundColor = [ConsoleColor]::Black
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [string] $StyleFlags = "" 
    [int] $ZIndex = 0        
    [object] $Metadata = $null 

    TuiCell() { }
    TuiCell([char]$char) { $this.Char = $char }
    TuiCell([char]$char, $fg, $bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }
    TuiCell([char]$char, $fg, $bg, [bool]$bold, [bool]$underline) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Underline = $underline
    }
    TuiCell([object]$other) {
        $this.Char = $other.Char
        $this.ForegroundColor = $other.ForegroundColor
        $this.BackgroundColor = $other.BackgroundColor
        $this.Bold = $other.Bold
        $this.Underline = $other.Underline
        $this.Italic = $other.Italic
        $this.StyleFlags = $other.StyleFlags
        $this.ZIndex = $other.ZIndex
        $this.Metadata = $other.Metadata
    }

    [TuiCell] WithStyle($fg, $bg) {
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    [TuiCell] BlendWith([object]$other) {
        if ($null -eq $other) { return $this }
        
        if ($other.ZIndex -gt $this.ZIndex) { 
            return [TuiCell]::new($other)
        }
        
        if ($other.ZIndex -eq $this.ZIndex) {
            if ($other.Char -ne ' ' -or $other.Bold -or $other.Underline -or $other.Italic) {
                return [TuiCell]::new($other)
            }
            if ($other.BackgroundColor -ne $this.BackgroundColor) {
                return [TuiCell]::new($other)
            }
        }
        
        return $this
    }

    [bool] DiffersFrom([object]$other) {
        if ($null -eq $other) { return $true }
        
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic -or
                $this.ZIndex -ne $other.ZIndex)
    }

    [string] ToAnsiString() {
        $sb = [System.Text.StringBuilder]::new()
        $fgCode = [TuiAnsiHelper]::GetForegroundCode($this.ForegroundColor)
        $bgCode = [TuiAnsiHelper]::GetBackgroundCode($this.BackgroundColor)
        [void]$sb.Append($fgCode).Append($bgCode)
        if ($this.Bold) { [void]$sb.Append([TuiAnsiHelper]::Bold()) }
        if ($this.Underline) { [void]$sb.Append([TuiAnsiHelper]::Underline()) }
        if ($this.Italic) { [void]$sb.Append([TuiAnsiHelper]::Italic()) }
        [void]$sb.Append($this.Char)
        return $sb.ToString()
    }

    [hashtable] ToLegacyFormat() {
        return @{ Char = $this.Char; FG = $this.ForegroundColor; BG = $this.BackgroundColor }
    }
    
    [string] ToString() {
        return "TuiCell(Char='$($this.Char)', FG='$($this.ForegroundColor)', BG='$($this.BackgroundColor)', Bold=$($this.Bold), Underline=$($this.Underline), Italic=$($this.Italic), ZIndex=$($this.ZIndex))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    $Cells       # 2D array of TuiCells - no type constraint to avoid assignment issues
    [int] $Width             
    [int] $Height            
    [string] $Name            
    [bool] $IsDirty = $true  

    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        # Initialize cells in a simple way
        $this.InitializeCells()
        # Write-Verbose "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
    }

    hidden [void] InitializeCells() {
        # Create 2D array step by step to avoid assignment issues
        $tempArray = New-Object 'System.Object[,]' $this.Height,$this.Width
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $tempArray[$y,$x] = [TuiCell]::new()
            }
        }
        $this.Cells = $tempArray
    }

    [void] Clear() { $this.Clear([TuiCell]::new()) }

    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell) 
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "TuiBuffer '$($this.Name)' cleared with specified cell."
    }

    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) { return [TuiCell]::new() }
        return $this.Cells[$y, $x]
    }

    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        } else {
            # Write-Warning "Attempted to set cell out of bounds in TuiBuffer '$($this.Name)': ($x, $y) is outside 0..$($this.Width-1), 0..$($this.Height-1). Cell: '$($cell.Char)'."
        }
    }

    [void] WriteString([int]$x, [int]$y, [string]$text, $fg, $bg) {
        if ($y -lt 0 -or $y -ge $this.Height) {
            # Write-Warning "Skipping WriteString: Y coordinate ($y) out of bounds for buffer '$($this.Name)' (0..$($this.Height-1)). Text: '$text'."
            return
        }
        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break } 
            if ($currentX -ge 0) {
                $this.SetCell($currentX, $y, [TuiCell]::new($char, $fg, $bg))
            }
            $currentX++
        }
        $this.IsDirty = $true
        # Write-Verbose "WriteString: Wrote '$text' to buffer '$($this.Name)' at ($x, $y)."
    }

    [void] BlendBuffer([object]$other, [int]$offsetX, [int]$offsetY) {
        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "BlendBuffer: Blended buffer '$($other.Name)' onto '$($this.Name)' at ($offsetX, $offsetY)."
    }

    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        # Write-Verbose "GetSubBuffer: Created sub-buffer '$($subBuffer.Name)' from '$($this.Name)' at ($x, $y) with dimensions $($width)x$($height)."
        return $subBuffer
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height
        $this.Width = $newWidth
        $this.Height = $newHeight
        # Create new 2D array using helper method
        $this.InitializeCells()
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)
        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "TuiBuffer '$($this.Name)' resized from $($oldWidth)x$($oldHeight) to $($newWidth)x$($newHeight)."
    }

    [string] ToString() {
        return "TuiBuffer(Name='$($this.Name)', Width=$($this.Width), Height=$($this.Height), IsDirty=$($this.IsDirty))"
    }

    # Additional helper methods needed by rendering pipeline
    [void] DrawText([int]$x, [int]$y, [string]$text, $fg, $bg) {
        $this.WriteString($x, $y, $text, $fg, $bg)
    }
    
    [void] DrawBox([int]$x, [int]$y, [int]$width, [int]$height, $fg, $bg, [bool]$doubleLine = $false) {
        if ($doubleLine) {
            $topLeft = '╔'; $topRight = '╗'; $bottomLeft = '╚'; $bottomRight = '╝'
            $horizontal = '═'; $vertical = '║'
        } else {
            $topLeft = '┌'; $topRight = '┐'; $bottomLeft = '└'; $bottomRight = '┘'
            $horizontal = '─'; $vertical = '│'
        }
        
        # Top line
        $this.SetCell($x, $y, [TuiCell]::new($topLeft, $fg, $bg))
        for ($i = 1; $i -lt $width - 1; $i++) {
            $this.SetCell($x + $i, $y, [TuiCell]::new($horizontal, $fg, $bg))
        }
        $this.SetCell($x + $width - 1, $y, [TuiCell]::new($topRight, $fg, $bg))
        
        # Vertical lines
        for ($i = 1; $i -lt $height - 1; $i++) {
            $this.SetCell($x, $y + $i, [TuiCell]::new($vertical, $fg, $bg))
            $this.SetCell($x + $width - 1, $y + $i, [TuiCell]::new($vertical, $fg, $bg))
        }
        
        # Bottom line
        $this.SetCell($x, $y + $height - 1, [TuiCell]::new($bottomLeft, $fg, $bg))
        for ($i = 1; $i -lt $width - 1; $i++) {
            $this.SetCell($x + $i, $y + $height - 1, [TuiCell]::new($horizontal, $fg, $bg))
        }
        $this.SetCell($x + $width - 1, $y + $height - 1, [TuiCell]::new($bottomRight, $fg, $bg))
    }
    
    [void] FillRect([int]$x, [int]$y, [int]$width, [int]$height, [char]$char, $fg, $bg) {
        for ($py = $y; $py -lt $y + $height; $py++) {
            for ($px = $x; $px -lt $x + $width; $px++) {
                $this.SetCell($px, $py, [TuiCell]::new($char, $fg, $bg))
            }
        }
    }
    
    [TuiBuffer] Clone() {
        $clone = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name)_Clone")
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $clone.Cells[$y, $x] = [TuiCell]::new($this.Cells[$y, $x])
            }
        }
        return $clone
    }
}
#endregion

#region UIElement - Base Class for all UI Components
class UIElement {
    [string] $Name = "UIElement" 
    [int] $X = 0               
    [int] $Y = 0               
    [int] $Width = 10          
    [int] $Height = 3          
    [bool] $Visible = $true    
    [bool] $Enabled = $true    
    [bool] $IsFocusable = $false 
    [bool] $IsFocused = $false  
    [bool] $IsOverlay = $false
    [int] $TabIndex = 0        
    [int] $ZIndex = 0          
    [UIElement] $Parent = $null 
    [System.Collections.Generic.List[UIElement]] $Children 
    
    hidden [object] $_private_buffer = $null
    hidden [bool] $_needs_redraw = $true
    
    [hashtable] $Metadata = @{} 

    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        # Write-Verbose "UIElement 'Unnamed' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([string]$name) {
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        # Write-Verbose "UIElement '$($this.Name)' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "Unnamed.Buffer")
        # Write-Verbose "UIElement 'Unnamed' created at ($x, $y) with dimensions $($width)x$($height)."
    }

    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        return @{ X = $absX; Y = $absY }
    }

    [void] AddChild([object]$child) {
        try {
            if ($child -eq $this) { throw [System.ArgumentException]::new("Cannot add an element as its own child.") }
            if ($this.Children.Contains($child)) {
                Write-Warning "Child '$($child.Name)' is already a child of '$($this.Name)'. Skipping addition."
                return
            }
            if ($child.Parent -ne $null) {
                Write-Warning "Child '$($child.Name)' already has a parent ('$($child.Parent.Name)'). Consider removing it from its current parent first."
            }
            $child.Parent = $this
            $this.Children.Add($child)
            $this.RequestRedraw()
            # Write-Verbose "Added child '$($child.Name)' to parent '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add child '$($child.Name)' to '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] RemoveChild([object]$child) {
        try {
            if ($this.Children.Remove($child)) {
                $child.Parent = $null
                $this.RequestRedraw()
                # Write-Verbose "Removed child '$($child.Name)' from parent '$($this.Name)'."
            } else {
                Write-Warning "Child '$($child.Name)' not found in parent '$($this.Name)' for removal. No action taken."
            }
        }
        catch {
            Write-Error "Failed to remove child '$($child.Name)' from '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
        # Write-Verbose "Redraw requested for '$($this.Name)'."
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        try {
            if ($this.Width -eq $newWidth -and $this.Height -eq $newHeight) {
                Write-Verbose "Resize: Component '$($this.Name)' already has target dimensions ($($newWidth)x$($newHeight)). No change."
                return
            }
            $this.Width = $newWidth
            $this.Height = $newHeight
            if ($null -ne $this._private_buffer) {
                $this._private_buffer.Resize($newWidth, $newHeight)
            } else {
                $this._private_buffer = [TuiBuffer]::new($newWidth, $newHeight, "$($this.Name).Buffer")
                # Write-Verbose "Re-initialized buffer for '$($this.Name)' due to null buffer."
            }
            $this.RequestRedraw()
            $this.OnResize($newWidth, $newHeight)
            # Write-Verbose "Component '$($this.Name)' resized to $($newWidth)x$($newHeight)."
        }
        catch {
            Write-Error "Failed to resize component '$($this.Name)' to $($newWidth)x$($newHeight): $($_.Exception.Message)"
            throw
        }
    }

    [void] Move([int]$newX, [int]$newY) {
        if ($this.X -eq $newX -and $this.Y -eq $newY) {
            # Write-Verbose "Move: Component '$($this.Name)' already at target position ($($newX), $($newY)). No change."
            return
        }
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
        # Write-Verbose "Component '$($this.Name)' moved to ($newX, $newY)."
    }

    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height)
    }

    [object] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $child.X, $y - $child.Y)) {
                return $child
            }
        }
        return $null
    }

    [void] OnRender() 
    {
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
        # Write-Verbose "OnRender called for '$($this.Name)': Default buffer clear."
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) 
    {
        # Write-Verbose "OnResize called for '$($this.Name)': No custom resize logic."
    }

    [void] OnMove([int]$newX, [int]$newY) 
    {
        # Write-Verbose "OnMove called for '$($this.Name)': No custom move logic."
    }

    [void] OnFocus() 
    { 
        # Write-Verbose "OnFocus called for '$($this.Name)'." 
    }
    
    [void] OnBlur() 
    { 
        # Write-Verbose "OnBlur called for '$($this.Name)'." 
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) 
    {
        # Write-Verbose "HandleInput called for '$($this.Name)': Key: $($keyInfo.Key)."
        return $false
    }

    [void] Render() 
    {
        if (-not $this.Visible) { 
            # Write-Verbose "Skipping Render for '$($this.Name)': Not visible."
            return 
        }
        $this._RenderContent() 
    }

    hidden [void] _RenderContent() 
    {
        if (-not $this.Visible) { return }
        if ($this._needs_redraw -or ($null -eq $this._private_buffer)) {
            if ($null -eq $this._private_buffer -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
                $bufferWidth = [Math]::Max(1, $this.Width)
                $bufferHeight = [Math]::Max(1, $this.Height)
                $this._private_buffer = [TuiBuffer]::new($bufferWidth, $bufferHeight, "$($this.Name).Buffer")
                # Write-Verbose "Re-initialized buffer for '$($this.Name)' due to null or dimension mismatch ($($bufferWidth)x$($bufferHeight))."
            }
            $this.OnRender()
            $this._needs_redraw = $false
            # Write-Verbose "Rendered own content for '$($this.Name)'."
        }
        foreach ($child in $this.Children | Sort-Object ZIndex) { 
            if ($child.Visible) {
                $child.Render()
                if ($null -ne $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                    # Write-Verbose "Blended child '$($child.Name)' onto '$($this.Name)' at ($($child.X), $($child.Y))."
                }
            }
        }
    }

    [object] GetBuffer() 
    { 
        return $this._private_buffer 
    }
    
    [string] ToString() 
    {
        return "$($this.GetType().Name)(Name='$($this.Name)', X=$($this.X), Y=$($this.Y), Width=$($this.Width), Height=$($this.Height), Visible=$($this.Visible))"
    }
}
#endregion

#region Component - A generic container component
class Component : UIElement {
    Component([string]$name) : base($name) {
        $this.Name = $name
        # Write-Verbose "Component '$($this.Name)' created."
    }

    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent()
        # Write-Verbose "_RenderContent called for Component '$($this.Name)' (delegating to base UIElement)."
    }

    [string] ToString() {
        return "Component(Name='$($this.Name)', Children=$($this.Children.Count))"
    }
}
#endregion

#region Screen - Top-level Container for Application Views
class Screen : UIElement {
    [hashtable]$Services
    [object]$ServiceContainer 
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[UIElement]] $Panels
    
    $LastFocusedComponent
    
    hidden [bool] $_isInitialized = $false
    hidden [System.Collections.Generic.Dictionary[string, string]] $EventSubscriptions 

    Screen([string]$name, [hashtable]$services) : base($name) {
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        $this.ServiceContainer = $null
        # Write-Verbose "Screen '$($this.Name)' created with hashtable services."
    }

    Screen([string]$name, [object]$serviceContainer) : base($name) {
        $this.ServiceContainer = $serviceContainer
        $this.Services = [hashtable]::new()
        if ($this.ServiceContainer.PSObject.Methods['GetAllRegisteredServices'] -and $this.ServiceContainer.PSObject.Methods['GetService']) { 
            try {
                $registeredServices = $this.ServiceContainer.GetAllRegisteredServices()
                foreach ($service in $registeredServices) {
                    try {
                        $this.Services[$service.Name] = $this.ServiceContainer.GetService($service.Name)
                    } catch {
                        Write-Warning "Screen '$($this.Name)': Failed to resolve service '$($service.Name)' from container: $($_.Exception.Message)"
                    }
                }
                # Write-Verbose "Screen '$($this.Name)' populated Services hashtable from ServiceContainer."
            } catch {
                Write-Warning "Screen '$($this.Name)': Failed to enumerate services from container: $($_.Exception.Message)"
            }
        } else {
            Write-Warning "Screen '$($this.Name)' received a non-ServiceContainer object for DI. Services hashtable might be incomplete or inaccurate."
        }
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        # Write-Verbose "Screen '$($this.Name)' created with ServiceContainer."
    }

    [void] Initialize() { 
        # Write-Verbose "Initialize called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnEnter() { 
        # Write-Verbose "OnEnter called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnExit() { 
        # Write-Verbose "OnExit called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnResume() { 
        # Write-Verbose "OnResume called for Screen '$($this.Name)': Default (no-op)." 
    }

    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Write-Verbose "HandleInput called for Screen '$($this.Name)': Key: $($keyInfo.Key). Default (no-op)."
    }

    [void] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo) {
        $this.HandleInput($keyInfo)
    }

    [void] HandleResize([int]$newWidth, [int]$newHeight) {
        $this.Resize($newWidth, $newHeight)
    }

    [void] Cleanup() {
        try {
            # Write-Verbose "Cleanup called for Screen '$($this.Name)'."
            foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
                try {
                    if (Get-Command 'Unsubscribe-Event' -ErrorAction SilentlyContinue) {
                        Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value
                        Write-Verbose "Unsubscribed event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)'."
                    }
                }
                catch {
                    Write-Warning "Failed to unsubscribe event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)': $($_.Exception.Message)"
                }
            }
            $this.EventSubscriptions.Clear()
            foreach ($child in $this.Children) {
                if ($child.PSObject.Methods['Cleanup']) {
                    try { $child.Cleanup() } catch { Write-Warning "Failed to cleanup child '$($child.Name)': $($_.Exception.Message)" }
                }
            }
            $this.Panels.Clear()
            $this.Children.Clear()
            Write-Verbose "Cleaned up resources for screen: $($this.Name)."
        }
        catch {
            Write-Error "Error during Cleanup for screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] AddPanel([object]$panel) {
        try {
            $this.Panels.Add($panel)
            $this.AddChild($panel) 
            Write-Verbose "Added panel '$($panel.Name)' to screen '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add panel '$($panel.Name)' to screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        try {
            if (Get-Command 'Subscribe-Event' -ErrorAction SilentlyContinue) {
                $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
                $this.EventSubscriptions[$eventName] = $subscriptionId
                Write-Verbose "Screen '$($this.Name)' subscribed to event '$eventName' with HandlerId: $subscriptionId."
            } else {
                Write-Warning "Subscribe-Event function not available. Event subscription for '$eventName' failed."
            }
        }
        catch {
            Write-Error "Failed for screen '$($this.Name)' to subscribe to event '$eventName': $($_.Exception.Message)"
            throw
        }
    }
    
    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent()
        Write-Verbose "_RenderContent called for Screen '$($this.Name)' (rendering UIElement children, including panels)."
    }

    [string] ToString() {
        $panelCount = if ($this.Panels) { $this.Panels.Count } else { 0 }
        return "Screen(Name='$($this.Name)', Panels=$panelCount, Visible=$($this.Visible))"
    }

    [void] Render([TuiBuffer]$buffer) {
        # First render self
        $this._RenderContent()
        
        # Then blend our buffer onto the target
        if ($null -ne $this._private_buffer) {
            $buffer.BlendBuffer($this._private_buffer, 0, 0)
        }
    }
}
#endregion

#region ServiceContainer Class
class ServiceContainer {
    hidden [hashtable] $_services = @{}
    hidden [hashtable] $_serviceFactories = @{}

    ServiceContainer() {
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer created."
        }
        Write-Verbose "ServiceContainer: Instance constructed."
    }

    [void] Register([string]$name, [object]$serviceInstance) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }
        if ($null -eq $serviceInstance) { throw [System.ArgumentNullException]::new("serviceInstance") }

        if ($this._services.ContainsKey($name) -or $this._serviceFactories.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("A service or factory with the name '$name' is already registered.")
        }

        $this._services[$name] = $serviceInstance
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Registered eager service instance: '$name'."
        }
        Write-Verbose "ServiceContainer: Registered eager instance for '$name' of type '$($serviceInstance.GetType().Name)'."
    }

    [void] RegisterFactory([string]$name, [scriptblock]$factory, [bool]$isSingleton = $true) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }
        if ($null -eq $factory) { throw [System.ArgumentNullException]::new("factory") }

        if ($this._services.ContainsKey($name) -or $this._serviceFactories.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("A service or factory with the name '$name' is already registered.")
        }
        
        $this._serviceFactories[$name] = @{
            Factory = $factory
            IsSingleton = $isSingleton
            Instance = $null
        }
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Registered service factory: '$name' (Singleton: $isSingleton)."
        }
        Write-Verbose "ServiceContainer: Registered factory for '$name' (Singleton: $isSingleton)."
    }

    [object] GetService([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }

        if ($this._services.ContainsKey($name)) {
            Write-Verbose "ServiceContainer: Returning eager-loaded instance of '$name'."
            return $this._services[$name]
        }

        if ($this._serviceFactories.ContainsKey($name)) {
            return $this._InitializeServiceFromFactory($name, [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase))
        }

        $available = $this.GetAllRegisteredServices() | Select-Object -ExpandProperty Name
        throw [System.InvalidOperationException]::new("Service '$name' not found. Available services: $($available -join ', ')")
    }
    
    [object[]] GetAllRegisteredServices() {
        $list = [System.Collections.Generic.List[object]]::new()
        
        foreach ($key in $this._services.Keys) {
            $list.Add([pscustomobject]@{
                Name = $key
                Type = 'Instance'
                Initialized = $true
                Lifestyle = 'Singleton'
            })
        }
        
        foreach ($key in $this._serviceFactories.Keys) {
            $factoryInfo = $this._serviceFactories[$key]
            $list.Add([pscustomobject]@{
                Name = $key
                Type = 'Factory'
                Initialized = ($null -ne $factoryInfo.Instance)
                Lifestyle = if ($factoryInfo.IsSingleton) { 'Singleton' } else { 'Transient' }
            })
        }
        
        return $list.ToArray() | Sort-Object Name
    }

    [void] Cleanup() {
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer cleanup initiated."
        }
        Write-Verbose "ServiceContainer: Initiating cleanup of disposable singleton services."
        
        $instancesToClean = [System.Collections.Generic.List[object]]::new()
        $this._services.Values | ForEach-Object { $instancesToClean.Add($_) }
        $this._serviceFactories.Values | Where-Object { $_.IsSingleton -and $_.Instance } | ForEach-Object { $instancesToClean.Add($_.Instance) }

        foreach ($service in $instancesToClean) {
            if ($service -is [System.IDisposable]) {
                try {
                    Write-Verbose "ServiceContainer: Disposing service of type '$($service.GetType().FullName)'."
                    $service.Dispose()
                } catch {
                    if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                        Write-Log -Level Error -Message "Error disposing service of type '$($service.GetType().FullName)': $($_.Exception.Message)"
                    }
                }
            }
        }
        
        $this._services.Clear()
        $this._serviceFactories.Clear()
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer cleanup complete."
        }
        Write-Verbose "ServiceContainer: Cleanup complete. All service registries cleared."
    }

    hidden [object] _InitializeServiceFromFactory([string]$name, [System.Collections.Generic.HashSet[string]]$resolutionChain) {
        $factoryInfo = $this._serviceFactories[$name]
        
        if ($factoryInfo.IsSingleton -and $null -ne $factoryInfo.Instance) {
            Write-Verbose "ServiceContainer: Returning cached singleton instance of '$name'."
            return $factoryInfo.Instance
        }

        if ($resolutionChain.Contains($name)) {
            $chain = ($resolutionChain -join ' -> ') + " -> $name"
            throw [System.InvalidOperationException]::new("Circular dependency detected while resolving service '$name'. Chain: $chain")
        }
        [void]$resolutionChain.Add($name)
        
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Instantiating service '$name' from factory."
        }
        Write-Verbose "ServiceContainer: Invoking factory to create instance of '$name'."
        
        $serviceInstance = & $factoryInfo.Factory $this

        if ($factoryInfo.IsSingleton) {
            $factoryInfo.Instance = $serviceInstance
            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Cached singleton instance of service '$name'."
            }
            Write-Verbose "ServiceContainer: Cached new singleton instance of '$name'."
        }

        [void]$resolutionChain.Remove($name)
        
        return $serviceInstance
    }
}
#endregion

####\AllComponents.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#region Core UI Components

# ===== CLASS: LabelComponent =====
# Module: tui-components
# Dependencies: UIElement
# Purpose: Static text display
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor

    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 10
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            $fg = $this.ForegroundColor ?? [ConsoleColor]::White
            $bg = [ConsoleColor]::Black
            $this._private_buffer.WriteString(0, 0, $this.Text, $fg, $bg)
        }
        catch {
            # Silently handle errors in render
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}

# ===== CLASS: ButtonComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Interactive button with click events
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick

    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = if ($this.IsPressed) { [ConsoleColor]::DarkGray } else { [ConsoleColor]::Black }
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            $fgColor = if ($this.IsPressed) { [ConsoleColor]::Black } else { [ConsoleColor]::White }

            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this._private_buffer.SetCell($x, 0, [TuiCell]::new('-', $borderColor, $bgColor))
                $this._private_buffer.SetCell($x, $this.Height - 1, [TuiCell]::new('-', $borderColor, $bgColor))
            }
            for ($y = 0; $y -lt $this.Height; $y++) {
                $this._private_buffer.SetCell(0, $y, [TuiCell]::new('|', $borderColor, $bgColor))
                $this._private_buffer.SetCell($this.Width - 1, $y, [TuiCell]::new('|', $borderColor, $bgColor))
            }
            
            $this._private_buffer.SetCell(0, 0, [TuiCell]::new('+', $borderColor, $bgColor))
            $this._private_buffer.SetCell($this.Width - 1, 0, [TuiCell]::new('+', $borderColor, $bgColor))
            $this._private_buffer.SetCell(0, $this.Height - 1, [TuiCell]::new('+', $borderColor, $bgColor))
            $this._private_buffer.SetCell($this.Width - 1, $this.Height - 1, [TuiCell]::new('+', $borderColor, $bgColor))
            
            $textX = [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            $textY = [Math]::Floor(($this.Height - 1) / 2)
            $this._private_buffer.WriteString($textX, $textY, $this.Text, $fgColor, $bgColor)
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            try {
                $this.IsPressed = $true
                $this.RequestRedraw()
                
                if ($this.OnClick) {
                    & $this.OnClick
                }
                
                Start-Sleep -Milliseconds 50
                $this.IsPressed = $false
                $this.RequestRedraw()
                
                return $true
            }
            catch {
                $this.IsPressed = $false
                $this.RequestRedraw()
            }
        }
        return $false
    }
}

# ===== CLASS: TextBoxComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Text input with viewport scrolling, non-destructive cursor
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [ValidateRange(1, [int]::MaxValue)][int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    hidden [int]$_scrollOffset = 0
    [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor]$ForegroundColor = [ConsoleColor]::White
    [ConsoleColor]$BorderColor = [ConsoleColor]::Gray
    [ConsoleColor]$PlaceholderColor = [ConsoleColor]::DarkGray

    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = $this.BackgroundColor
            $borderColorValue = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { $this.BorderColor }
            $textColor = $this.ForegroundColor
            $placeholderColorValue = $this.PlaceholderColor
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $textColor, $bgColor))
            
            # Draw border
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this._private_buffer.SetCell($x, 0, [TuiCell]::new('-', $borderColorValue, $bgColor))
                $this._private_buffer.SetCell($x, $this.Height - 1, [TuiCell]::new('-', $borderColorValue, $bgColor))
            }
            for ($y = 0; $y -lt $this.Height; $y++) {
                $this._private_buffer.SetCell(0, $y, [TuiCell]::new('|', $borderColorValue, $bgColor))
                $this._private_buffer.SetCell($this.Width - 1, $y, [TuiCell]::new('|', $borderColorValue, $bgColor))
            }
            
            # Corners
            $this._private_buffer.SetCell(0, 0, [TuiCell]::new('+', $borderColorValue, $bgColor))
            $this._private_buffer.SetCell($this.Width - 1, 0, [TuiCell]::new('+', $borderColorValue, $bgColor))
            $this._private_buffer.SetCell(0, $this.Height - 1, [TuiCell]::new('+', $borderColorValue, $bgColor))
            $this._private_buffer.SetCell($this.Width - 1, $this.Height - 1, [TuiCell]::new('+', $borderColorValue, $bgColor))
            
            # Draw text or placeholder
            $contentY = 1
            $contentStartX = 1
            $contentWidth = $this.Width - 2
            
            if ($this.Text.Length -eq 0 -and $this.Placeholder) {
                # Draw placeholder
                $placeholderText = if ($this.Placeholder.Length -gt $contentWidth) {
                    $this.Placeholder.Substring(0, $contentWidth)
                } else { $this.Placeholder }
                
                $this._private_buffer.WriteString($contentStartX, $contentY, $placeholderText, $placeholderColorValue, $bgColor)
            }
            else {
                # Calculate scroll offset
                if ($this.CursorPosition -lt $this._scrollOffset) {
                    $this._scrollOffset = $this.CursorPosition
                }
                elseif ($this.CursorPosition -ge ($this._scrollOffset + $contentWidth)) {
                    $this._scrollOffset = $this.CursorPosition - $contentWidth + 1
                }
                
                # Draw visible portion of text
                $visibleText = ""
                if ($this.Text.Length -gt 0) {
                    $endPos = [Math]::Min($this._scrollOffset + $contentWidth, $this.Text.Length)
                    if ($this._scrollOffset -lt $this.Text.Length) {
                        $visibleText = $this.Text.Substring($this._scrollOffset, $endPos - $this._scrollOffset)
                    }
                }
                
                if ($visibleText) {
                    $this._private_buffer.WriteString($contentStartX, $contentY, $visibleText, $textColor, $bgColor)
                }
                
                # Draw cursor if focused
                if ($this.IsFocused) {
                    $cursorScreenPos = $this.CursorPosition - $this._scrollOffset
                    if ($cursorScreenPos -ge 0 -and $cursorScreenPos -lt $contentWidth) {
                        $cursorX = $contentStartX + $cursorScreenPos
                        $cursorChar = if ($cursorScreenPos -lt $visibleText.Length) { 
                            $visibleText[$cursorScreenPos] 
                        } else { ' ' }
                        
                        $this._private_buffer.SetCell($cursorX, $contentY, 
                            [TuiCell]::new($cursorChar, $bgColor, $textColor))
                    }
                }
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldText = $this.Text
        
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.CursorPosition++
                }
            }
            ([ConsoleKey]::Home) {
                $this.CursorPosition = 0
            }
            ([ConsoleKey]::End) {
                $this.CursorPosition = $this.Text.Length
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPosition, 1)
                }
            }
            default {
                if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                    if ($this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    }
                }
                else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            if ($oldText -ne $this.Text -and $this.OnChange) {
                try { & $this.OnChange $this $this.Text } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

# ===== CLASS: CheckBoxComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Boolean checkbox input
class CheckBoxComponent : UIElement {
    [string]$Text = ""
    [bool]$Checked = $false
    [scriptblock]$OnChange

    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            
            $checkMark = if ($this.Checked) { "[X]" } else { "[ ]" }
            $fg = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::White }
            $bg = [ConsoleColor]::Black
            
            $this._private_buffer.WriteString(0, 0, "$checkMark $($this.Text)", $fg, $bg)
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar) {
            $this.Checked = -not $this.Checked
            if ($this.OnChange) {
                try { & $this.OnChange $this $this.Checked } catch {}
            }
            $this.RequestRedraw()
            return $true
        }
        
        return $false
    }
}

# ===== CLASS: RadioButtonComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Exclusive selection with group management
class RadioButtonComponent : UIElement {
    [string]$Text = ""
    [bool]$Selected = $false
    [string]$GroupName = "default"
    [scriptblock]$OnChange
    static [hashtable]$_groups = @{}

    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear()
            
            $radioMark = if ($this.Selected) { "(o)" } else { "( )" }
            $fg = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::White }
            $bg = [ConsoleColor]::Black
            
            $this._private_buffer.WriteString(0, 0, "$radioMark $($this.Text)", $fg, $bg)
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar -and -not $this.Selected) {
            $this.Select()
            return $true
        }
        
        return $false
    }

    [void] Select() {
        # Deselect all others in group
        if ([RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            foreach ($radio in [RadioButtonComponent]::_groups[$this.GroupName]) {
                if ($radio -ne $this -and $radio.Selected) {
                    $radio.Selected = $false
                    $radio.RequestRedraw()
                    if ($radio.OnChange) {
                        try { & $radio.OnChange $radio $false } catch {}
                    }
                }
            }
        }
        
        $this.Selected = $true
        $this.RequestRedraw()
        if ($this.OnChange) {
            try { & $this.OnChange $this $true } catch {}
        }
    }

    [void] AddedToParent() {
        if (-not [RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            [RadioButtonComponent]::_groups[$this.GroupName] = [List[RadioButtonComponent]]::new()
        }
        [RadioButtonComponent]::_groups[$this.GroupName].Add($this)
    }

    [void] RemovedFromParent() {
        if ([RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            [RadioButtonComponent]::_groups[$this.GroupName].Remove($this)
        }
    }
}

#endregion Core UI Components

#region Advanced Components

# ===== CLASS: MultilineTextBoxComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Full text editor with scrolling
class MultilineTextBoxComponent : UIElement {
    [List[string]]$Lines
    [int]$CursorLine = 0
    [int]$CursorColumn = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [bool]$ReadOnly = $false
    [scriptblock]$OnChange
    [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor]$ForegroundColor = [ConsoleColor]::White
    [ConsoleColor]$BorderColor = [ConsoleColor]::Gray
    
    MultilineTextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Lines = [List[string]]::new()
        $this.Lines.Add("")
        $this.Width = 40
        $this.Height = 10
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = $this.BackgroundColor
            $fgColor = $this.ForegroundColor
            $borderColorValue = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { $this.BorderColor }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -ForegroundColor $borderColorValue -BackgroundColor $bgColor `
                -BorderStyle Single
            
            # Calculate visible area
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
            
            # Adjust scroll to keep cursor visible
            if ($this.CursorLine -lt $this.ScrollOffsetY) {
                $this.ScrollOffsetY = $this.CursorLine
            }
            elseif ($this.CursorLine -ge $this.ScrollOffsetY + $contentHeight) {
                $this.ScrollOffsetY = $this.CursorLine - $contentHeight + 1
            }
            
            if ($this.CursorColumn -lt $this.ScrollOffsetX) {
                $this.ScrollOffsetX = $this.CursorColumn
            }
            elseif ($this.CursorColumn -ge $this.ScrollOffsetX + $contentWidth) {
                $this.ScrollOffsetX = $this.CursorColumn - $contentWidth + 1
            }
            
            # Draw visible lines
            for ($y = 0; $y -lt $contentHeight; $y++) {
                $lineIndex = $y + $this.ScrollOffsetY
                if ($lineIndex -lt $this.Lines.Count) {
                    $line = $this.Lines[$lineIndex]
                    $visiblePart = ""
                    
                    if ($line.Length -gt $this.ScrollOffsetX) {
                        $endPos = [Math]::Min($this.ScrollOffsetX + $contentWidth, $line.Length)
                        $visiblePart = $line.Substring($this.ScrollOffsetX, $endPos - $this.ScrollOffsetX)
                    }
                    
                    if ($visiblePart) {
                        $this._private_buffer.WriteString(1, $y + 1, $visiblePart, $fgColor, $bgColor)
                    }
                }
            }
            
            # Draw cursor if focused
            if ($this.IsFocused -and -not $this.ReadOnly) {
                $cursorScreenY = $this.CursorLine - $this.ScrollOffsetY + 1
                $cursorScreenX = $this.CursorColumn - $this.ScrollOffsetX + 1
                
                if ($cursorScreenY -ge 1 -and $cursorScreenY -lt $this.Height - 1 -and
                    $cursorScreenX -ge 1 -and $cursorScreenX -lt $this.Width - 1) {
                    
                    $currentLine = $this.Lines[$this.CursorLine]
                    $cursorChar = ' '
                    if ($this.CursorColumn -lt $currentLine.Length) {
                        $cursorChar = $currentLine[$this.CursorColumn]
                    }
                    
                    $this._private_buffer.SetCell($cursorScreenX, $cursorScreenY,
                        [TuiCell]::new($cursorChar, $bgColor, $fgColor))
                }
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.ReadOnly) { return $false }
        
        $handled = $true
        $changed = $false
        
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorColumn -gt 0) {
                    $this.CursorColumn--
                }
                elseif ($this.CursorLine -gt 0) {
                    $this.CursorLine--
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
            }
            ([ConsoleKey]::RightArrow) {
                $currentLine = $this.Lines[$this.CursorLine]
                if ($this.CursorColumn -lt $currentLine.Length) {
                    $this.CursorColumn++
                }
                elseif ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.CursorLine++
                    $this.CursorColumn = 0
                }
            }
            ([ConsoleKey]::UpArrow) {
                if ($this.CursorLine -gt 0) {
                    $this.CursorLine--
                    $newLineLength = $this.Lines[$this.CursorLine].Length
                    if ($this.CursorColumn -gt $newLineLength) {
                        $this.CursorColumn = $newLineLength
                    }
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.CursorLine++
                    $newLineLength = $this.Lines[$this.CursorLine].Length
                    if ($this.CursorColumn -gt $newLineLength) {
                        $this.CursorColumn = $newLineLength
                    }
                }
            }
            ([ConsoleKey]::Home) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.CursorLine = 0
                    $this.CursorColumn = 0
                }
                else {
                    $this.CursorColumn = 0
                }
            }
            ([ConsoleKey]::End) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.CursorLine = $this.Lines.Count - 1
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
                else {
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
            }
            ([ConsoleKey]::Enter) {
                $currentLine = $this.Lines[$this.CursorLine]
                $beforeCursor = $currentLine.Substring(0, $this.CursorColumn)
                $afterCursor = $currentLine.Substring($this.CursorColumn)
                
                $this.Lines[$this.CursorLine] = $beforeCursor
                $this.Lines.Insert($this.CursorLine + 1, $afterCursor)
                
                $this.CursorLine++
                $this.CursorColumn = 0
                $changed = $true
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorColumn -gt 0) {
                    $currentLine = $this.Lines[$this.CursorLine]
                    $this.Lines[$this.CursorLine] = $currentLine.Remove($this.CursorColumn - 1, 1)
                    $this.CursorColumn--
                    $changed = $true
                }
                elseif ($this.CursorLine -gt 0) {
                    $currentLine = $this.Lines[$this.CursorLine]
                    $previousLine = $this.Lines[$this.CursorLine - 1]
                    $this.CursorColumn = $previousLine.Length
                    $this.Lines[$this.CursorLine - 1] = $previousLine + $currentLine
                    $this.Lines.RemoveAt($this.CursorLine)
                    $this.CursorLine--
                    $changed = $true
                }
            }
            ([ConsoleKey]::Delete) {
                $currentLine = $this.Lines[$this.CursorLine]
                if ($this.CursorColumn -lt $currentLine.Length) {
                    $this.Lines[$this.CursorLine] = $currentLine.Remove($this.CursorColumn, 1)
                    $changed = $true
                }
                elseif ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $nextLine = $this.Lines[$this.CursorLine + 1]
                    $this.Lines[$this.CursorLine] = $currentLine + $nextLine
                    $this.Lines.RemoveAt($this.CursorLine + 1)
                    $changed = $true
                }
            }
            default {
                if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                    $currentLine = $this.Lines[$this.CursorLine]
                    $this.Lines[$this.CursorLine] = $currentLine.Insert($this.CursorColumn, $key.KeyChar)
                    $this.CursorColumn++
                    $changed = $true
                }
                else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            if ($changed -and $this.OnChange) {
                try { & $this.OnChange $this $this.GetText() } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    [string] GetText() {
        return ($this.Lines -join "`n")
    }
    
    [void] SetText([string]$text) {
        $this.Lines.Clear()
        $splitLines = $text -split "`n"
        foreach ($line in $splitLines) {
            $this.Lines.Add($line)
        }
        if ($this.Lines.Count -eq 0) {
            $this.Lines.Add("")
        }
        $this.CursorLine = 0
        $this.CursorColumn = 0
        $this.ScrollOffsetY = 0
        $this.ScrollOffsetX = 0
        $this.RequestRedraw()
    }
}

# ===== CLASS: NumericInputComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Numeric input with spinners and validation
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$Minimum = [double]::MinValue
    [double]$Maximum = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [scriptblock]$OnChange
    hidden [string]$_textValue = "0"
    hidden [int]$_cursorPosition = 1
    
    NumericInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 15
        $this.Height = 3
        $this._textValue = $this.FormatValue($this.Value)
        $this._cursorPosition = $this._textValue.Length
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = [ConsoleColor]::Black
            $fgColor = [ConsoleColor]::White
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -ForegroundColor $borderColor -BackgroundColor $bgColor `
                -BorderStyle Single
            
            # Draw spinners
            $spinnerColor = if ($this.IsFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::DarkGray }
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new('▲', $spinnerColor, $bgColor))
            $this._private_buffer.SetCell($this.Width - 2, $this.Height - 2, [TuiCell]::new('▼', $spinnerColor, $bgColor))
            
            # Draw value
            $displayValue = $this._textValue
            $maxTextWidth = $this.Width - 4  # Border + spinner
            if ($displayValue.Length -gt $maxTextWidth) {
                $displayValue = $displayValue.Substring(0, $maxTextWidth)
            }
            
            $this._private_buffer.WriteString(1, 1, $displayValue, $fgColor, $bgColor)
            
            # Draw cursor if focused
            if ($this.IsFocused -and $this._cursorPosition -le $displayValue.Length) {
                $cursorX = 1 + $this._cursorPosition
                if ($cursorX -lt $this.Width - 2) {
                    $cursorChar = if ($this._cursorPosition -lt $this._textValue.Length) {
                        $this._textValue[$this._cursorPosition]
                    } else { ' ' }
                    
                    $this._private_buffer.SetCell($cursorX, 1, 
                        [TuiCell]::new($cursorChar, $bgColor, $fgColor))
                }
            }
        }
        catch {}
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldValue = $this.Value
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.IncrementValue()
            }
            ([ConsoleKey]::DownArrow) {
                $this.DecrementValue()
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this._cursorPosition -gt 0) {
                    $this._cursorPosition--
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this._cursorPosition -lt $this._textValue.Length) {
                    $this._cursorPosition++
                }
            }
            ([ConsoleKey]::Home) {
                $this._cursorPosition = 0
            }
            ([ConsoleKey]::End) {
                $this._cursorPosition = $this._textValue.Length
            }
            ([ConsoleKey]::Backspace) {
                if ($this._cursorPosition -gt 0) {
                    $this._textValue = $this._textValue.Remove($this._cursorPosition - 1, 1)
                    $this._cursorPosition--
                    $this.ParseAndValidate()
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this._cursorPosition -lt $this._textValue.Length) {
                    $this._textValue = $this._textValue.Remove($this._cursorPosition, 1)
                    $this.ParseAndValidate()
                }
            }
            ([ConsoleKey]::Enter) {
                $this.ParseAndValidate()
            }
            default {
                if ($key.KeyChar -and ($key.KeyChar -match '[0-9.\-]')) {
                    # Allow only valid numeric characters
                    if ($key.KeyChar -eq '.' -and $this._textValue.Contains('.')) {
                        # Only one decimal point allowed
                        $handled = $false
                    }
                    elseif ($key.KeyChar -eq '-' -and ($this._cursorPosition -ne 0 -or $this._textValue.Contains('-'))) {
                        # Minus only at beginning
                        $handled = $false
                    }
                    else {
                        $this._textValue = $this._textValue.Insert($this._cursorPosition, $key.KeyChar)
                        $this._cursorPosition++
                        $this.ParseAndValidate()
                    }
                }
                else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            if ($oldValue -ne $this.Value -and $this.OnChange) {
                try { & $this.OnChange $this $this.Value } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    hidden [void] IncrementValue() {
        $newValue = $this.Value + $this.Step
        if ($newValue -le $this.Maximum) {
            $this.Value = $newValue
            $this._textValue = $this.FormatValue($this.Value)
            $this._cursorPosition = $this._textValue.Length
        }
    }
    
    hidden [void] DecrementValue() {
        $newValue = $this.Value - $this.Step
        if ($newValue -ge $this.Minimum) {
            $this.Value = $newValue
            $this._textValue = $this.FormatValue($this.Value)
            $this._cursorPosition = $this._textValue.Length
        }
    }
    
    hidden [void] ParseAndValidate() {
        try {
            $parsedValue = [double]::Parse($this._textValue)
            $parsedValue = [Math]::Max($this.Minimum, [Math]::Min($this.Maximum, $parsedValue))
            $this.Value = $parsedValue
        }
        catch {
            # Keep current value if parse fails
        }
    }
    
    hidden [string] FormatValue([double]$value) {
        if ($this.DecimalPlaces -eq 0) {
            return [Math]::Truncate($value).ToString()
        }
        else {
            return $value.ToString("F$($this.DecimalPlaces)")
        }
    }
}

# ===== CLASS: DateInputComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Date picker with calendar interface
class DateInputComponent : UIElement {
    [DateTime]$Value = [DateTime]::Today
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [scriptblock]$OnChange
    hidden [bool]$_showCalendar = $false
    hidden [DateTime]$_viewMonth
    
    DateInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 1  # Expands to 10 when calendar shown
        $this._viewMonth = $this.Value
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = [ConsoleColor]::Black
            $fgColor = [ConsoleColor]::White
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            
            # Adjust height based on calendar visibility
            $renderHeight = if ($this._showCalendar) { 10 } else { 3 }
            if ($this.Height -ne $renderHeight) {
                $this.Height = $renderHeight
                $this.RequestRedraw()
                return
            }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            # Draw text box
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height 3 `
                -ForegroundColor $borderColor -BackgroundColor $bgColor `
                -BorderStyle Single
            
            # Draw date value
            $dateStr = $this.Value.ToString("yyyy-MM-dd")
            $this._private_buffer.WriteString(1, 1, $dateStr, $fgColor, $bgColor)
            
            # Draw calendar icon
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new('📅', $borderColor, $bgColor))
            
            # Draw calendar if shown
            if ($this._showCalendar) {
                $this.DrawCalendar(0, 3)
            }
        }
        catch {}
    }
    
    hidden [void] DrawCalendar([int]$startX, [int]$startY) {
        $bgColor = [ConsoleColor]::Black
        $fgColor = [ConsoleColor]::White
        $headerColor = [ConsoleColor]::Yellow
        $selectedColor = [ConsoleColor]::Cyan
        $todayColor = [ConsoleColor]::Green
        
        # Calendar border
        Write-TuiBox -Buffer $this._private_buffer -X $startX -Y $startY `
            -Width $this.Width -Height 7 `
            -ForegroundColor [ConsoleColor]::Gray -BackgroundColor $bgColor `
            -BorderStyle Single
        
        # Month/Year header
        $monthYearStr = $this._viewMonth.ToString("MMMM yyyy")
        $headerX = $startX + [Math]::Floor(($this.Width - $monthYearStr.Length) / 2)
        $this._private_buffer.WriteString($headerX, $startY + 1, $monthYearStr, $headerColor, $bgColor)
        
        # Navigation arrows
        $this._private_buffer.SetCell($startX + 1, $startY + 1, [TuiCell]::new('<', $headerColor, $bgColor))
        $this._private_buffer.SetCell($startX + $this.Width - 2, $startY + 1, [TuiCell]::new('>', $headerColor, $bgColor))
        
        # Day headers
        $dayHeaders = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
        $dayX = $startX + 2
        foreach ($day in $dayHeaders) {
            $this._private_buffer.WriteString($dayX, $startY + 2, $day, [ConsoleColor]::DarkGray, $bgColor)
            $dayX += 3
        }
        
        # Calendar days
        $firstDay = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, 1)
        $startDayOfWeek = [int]$firstDay.DayOfWeek
        $daysInMonth = [DateTime]::DaysInMonth($this._viewMonth.Year, $this._viewMonth.Month)
        
        $currentDay = 1
        $today = [DateTime]::Today
        
        for ($week = 0; $week -lt 6; $week++) {
            if ($currentDay -gt $daysInMonth) { break }
            
            for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                if ($currentDay -gt $daysInMonth) { break }
                
                $dayX = $startX + 2 + ($dayOfWeek * 3)
                $dayY = $startY + 3 + $week
                
                $currentDate = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, $currentDay)
                $dayStr = $currentDay.ToString().PadLeft(2)
                
                # Determine color
                $dayColor = $fgColor
                if ($currentDate -eq $this.Value) {
                    $dayColor = $selectedColor
                }
                elseif ($currentDate -eq $today) {
                    $dayColor = $todayColor
                }
                
                $this._private_buffer.WriteString($dayX, $dayY, $dayStr, $dayColor, $bgColor)
                $currentDay++
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldValue = $this.Value
        
        if (-not $this._showCalendar) {
            switch ($key.Key) {
                ([ConsoleKey]::Enter) { $this._showCalendar = $true }
                ([ConsoleKey]::Spacebar) { $this._showCalendar = $true }
                ([ConsoleKey]::DownArrow) { $this._showCalendar = $true }
                default { $handled = $false }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) { 
                    $this._showCalendar = $false 
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Previous month
                        $this._viewMonth = $this._viewMonth.AddMonths(-1)
                    }
                    else {
                        # Previous day
                        $newDate = $this.Value.AddDays(-1)
                        if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                            $this.Value = $newDate
                            $this._viewMonth = $newDate
                        }
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Next month
                        $this._viewMonth = $this._viewMonth.AddMonths(1)
                    }
                    else {
                        # Next day
                        $newDate = $this.Value.AddDays(1)
                        if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                            $this.Value = $newDate
                            $this._viewMonth = $newDate
                        }
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    # Previous week
                    $newDate = $this.Value.AddDays(-7)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._viewMonth = $newDate
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    # Next week
                    $newDate = $this.Value.AddDays(7)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._viewMonth = $newDate
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this._showCalendar = $false
                }
                ([ConsoleKey]::T) {
                    # Today
                    $today = [DateTime]::Today
                    if ($today -ge $this.MinDate -and $today -le $this.MaxDate) {
                        $this.Value = $today
                        $this._viewMonth = $today
                    }
                }
                default { $handled = $false }
            }
        }
        
        if ($handled) {
            if ($oldValue -ne $this.Value -and $this.OnChange) {
                try { & $this.OnChange $this $this.Value } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

# ===== CLASS: ComboBoxComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Dropdown with search and overlay rendering
class ComboBoxComponent : UIElement {
    [List[object]]$Items
    [int]$SelectedIndex = -1
    [string]$DisplayMember = ""
    [string]$ValueMember = ""
    [bool]$IsEditable = $false
    [string]$Text = ""
    [scriptblock]$OnSelectionChanged
    hidden [bool]$_isDropdownOpen = $false
    hidden [int]$_highlightedIndex = -1
    hidden [string]$_searchText = ""
    hidden [List[int]]$_filteredIndices
    
    ComboBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.Items = [List[object]]::new()
        $this._filteredIndices = [List[int]]::new()
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = [ConsoleColor]::Black
            $fgColor = [ConsoleColor]::White
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            # Draw main box
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -ForegroundColor $borderColor -BackgroundColor $bgColor `
                -BorderStyle Single
            
            # Draw selected/text value
            $displayText = ""
            if ($this.IsEditable) {
                $displayText = $this._searchText
            }
            elseif ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
                $item = $this.Items[$this.SelectedIndex]
                $displayText = $this.GetDisplayText($item)
            }
            
            $maxTextWidth = $this.Width - 4  # Border + dropdown arrow
            if ($displayText.Length -gt $maxTextWidth) {
                $displayText = $displayText.Substring(0, $maxTextWidth)
            }
            
            $this._private_buffer.WriteString(1, 1, $displayText, $fgColor, $bgColor)
            
            # Draw dropdown arrow
            $arrowChar = if ($this._isDropdownOpen) { '▲' } else { '▼' }
            $arrowColor = if ($this.IsFocused) { [ConsoleColor]::Yellow } else { [ConsoleColor]::DarkGray }
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new($arrowChar, $arrowColor, $bgColor))
            
            # Draw dropdown if open (as overlay)
            if ($this._isDropdownOpen) {
                $this.IsOverlay = $true
                $this.DrawDropdown()
            }
            else {
                $this.IsOverlay = $false
            }
        }
        catch {}
    }
    
    hidden [void] DrawDropdown() {
        $dropdownY = $this.Height
        $maxDropdownHeight = 10
        $dropdownHeight = [Math]::Min($this._filteredIndices.Count + 2, $maxDropdownHeight)
        
        if ($dropdownHeight -lt 3) { $dropdownHeight = 3 }  # Minimum height
        
        # Create dropdown buffer
        $dropdownBuffer = [TuiBuffer]::new($this.Width, $dropdownHeight)
        $dropdownBuffer.Name = "ComboDropdown"
        
        # Draw dropdown border
        Write-TuiBox -Buffer $dropdownBuffer -X 0 -Y 0 `
            -Width $this.Width -Height $dropdownHeight `
            -ForegroundColor [ConsoleColor]::Gray -BackgroundColor [ConsoleColor]::Black `
            -BorderStyle Single
        
        # Draw items
        $itemY = 1
        $maxItems = $dropdownHeight - 2
        $scrollOffset = 0
        
        if ($this._highlightedIndex -ge $maxItems) {
            $scrollOffset = $this._highlightedIndex - $maxItems + 1
        }
        
        for ($i = $scrollOffset; $i -lt $this._filteredIndices.Count -and $itemY -lt $dropdownHeight - 1; $i++) {
            $itemIndex = $this._filteredIndices[$i]
            $item = $this.Items[$itemIndex]
            $itemText = $this.GetDisplayText($item)
            
            $itemFg = [ConsoleColor]::White
            $itemBg = [ConsoleColor]::Black
            
            if ($i -eq $this._highlightedIndex) {
                $itemFg = [ConsoleColor]::Black
                $itemBg = [ConsoleColor]::Cyan
            }
            elseif ($itemIndex -eq $this.SelectedIndex) {
                $itemFg = [ConsoleColor]::Yellow
            }
            
            # Clear line and draw item
            for ($x = 1; $x -lt $this.Width - 1; $x++) {
                $dropdownBuffer.SetCell($x, $itemY, [TuiCell]::new(' ', $itemFg, $itemBg))
            }
            
            $maxTextWidth = $this.Width - 2
            if ($itemText.Length -gt $maxTextWidth) {
                $itemText = $itemText.Substring(0, $maxTextWidth - 3) + "..."
            }
            
            $dropdownBuffer.WriteString(1, $itemY, $itemText, $itemFg, $itemBg)
            $itemY++
        }
        
        # Blend dropdown buffer with main buffer at dropdown position
        $absPos = $this.GetAbsolutePosition()
        $dropX = 0
        $dropY = $dropdownY
        
        for ($y = 0; $y -lt $dropdownBuffer.Height; $y++) {
            for ($x = 0; $x -lt $dropdownBuffer.Width; $x++) {
                $cell = $dropdownBuffer.GetCell($x, $y)
                if ($cell) {
                    $this._private_buffer.SetCell($dropX + $x, $dropY + $y, $cell)
                }
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        
        if (-not $this._isDropdownOpen) {
            switch ($key.Key) {
                ([ConsoleKey]::Enter) { 
                    $this.OpenDropdown()
                }
                ([ConsoleKey]::Spacebar) {
                    if (-not $this.IsEditable) {
                        $this.OpenDropdown()
                    }
                    else {
                        $handled = $false
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    $this.OpenDropdown()
                }
                default {
                    if ($this.IsEditable -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                        $this._searchText += $key.KeyChar
                        $this.OpenDropdown()
                        $this.FilterItems()
                    }
                    else {
                        $handled = $false
                    }
                }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.CloseDropdown()
                }
                ([ConsoleKey]::Enter) {
                    if ($this._highlightedIndex -ge 0 -and $this._highlightedIndex -lt $this._filteredIndices.Count) {
                        $this.SelectItem($this._filteredIndices[$this._highlightedIndex])
                        $this.CloseDropdown()
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    if ($this._highlightedIndex -gt 0) {
                        $this._highlightedIndex--
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this._highlightedIndex -lt $this._filteredIndices.Count - 1) {
                        $this._highlightedIndex++
                    }
                }
                ([ConsoleKey]::Home) {
                    $this._highlightedIndex = 0
                }
                ([ConsoleKey]::End) {
                    $this._highlightedIndex = $this._filteredIndices.Count - 1
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.IsEditable -and $this._searchText.Length -gt 0) {
                        $this._searchText = $this._searchText.Substring(0, $this._searchText.Length - 1)
                        $this.FilterItems()
                    }
                }
                default {
                    if ($this.IsEditable -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                        $this._searchText += $key.KeyChar
                        $this.FilterItems()
                    }
                    else {
                        $handled = $false
                    }
                }
            }
        }
        
        if ($handled) {
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    hidden [void] OpenDropdown() {
        $this._isDropdownOpen = $true
        $this.FilterItems()
        
        # Set highlighted index to selected item
        if ($this.SelectedIndex -ge 0) {
            for ($i = 0; $i -lt $this._filteredIndices.Count; $i++) {
                if ($this._filteredIndices[$i] -eq $this.SelectedIndex) {
                    $this._highlightedIndex = $i
                    break
                }
            }
        }
        
        if ($this._highlightedIndex -eq -1 -and $this._filteredIndices.Count -gt 0) {
            $this._highlightedIndex = 0
        }
    }
    
    hidden [void] CloseDropdown() {
        $this._isDropdownOpen = $false
        $this.IsOverlay = $false
        if (-not $this.IsEditable) {
            $this._searchText = ""
        }
    }
    
    hidden [void] FilterItems() {
        $this._filteredIndices.Clear()
        
        if ($this._searchText -eq "") {
            # Show all items
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                $this._filteredIndices.Add($i)
            }
        }
        else {
            # Filter items based on search text
            $searchLower = $this._searchText.ToLower()
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                $itemText = $this.GetDisplayText($this.Items[$i]).ToLower()
                if ($itemText.Contains($searchLower)) {
                    $this._filteredIndices.Add($i)
                }
            }
        }
        
        # Reset highlighted index
        if ($this._highlightedIndex -ge $this._filteredIndices.Count) {
            $this._highlightedIndex = $this._filteredIndices.Count - 1
        }
        if ($this._highlightedIndex -lt 0 -and $this._filteredIndices.Count -gt 0) {
            $this._highlightedIndex = 0
        }
    }
    
    hidden [void] SelectItem([int]$index) {
        $oldIndex = $this.SelectedIndex
        $this.SelectedIndex = $index
        
        if (-not $this.IsEditable) {
            $this.Text = $this.GetDisplayText($this.Items[$index])
        }
        
        if ($oldIndex -ne $index -and $this.OnSelectionChanged) {
            try { & $this.OnSelectionChanged $this $index } catch {}
        }
    }
    
    hidden [string] GetDisplayText([object]$item) {
        if ($null -eq $item) { return "" }
        
        if ($this.DisplayMember -and $item.PSObject.Properties[$this.DisplayMember]) {
            return $item.$($this.DisplayMember).ToString()
        }
        
        return $item.ToString()
    }
}

# ===== CLASS: Table =====
# Module: advanced-data-components
# Dependencies: UIElement, TuiCell
# Purpose: High-performance data grid with virtual scrolling
class Table : UIElement {
    [List[PSObject]]$Items
    [List[string]]$Columns
    [hashtable]$ColumnWidths
    [int]$SelectedIndex = -1
    [bool]$ShowHeader = $true
    [bool]$ShowBorder = $true
    [bool]$AllowSelection = $true
    [scriptblock]$OnSelectionChanged
    hidden [int]$_scrollOffset = 0
    hidden [int]$_horizontalScroll = 0
    
    Table([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[PSObject]]::new()
        $this.Columns = [List[string]]::new()
        $this.ColumnWidths = @{}
        $this.Width = 80
        $this.Height = 20
    }
    
    [void] SetColumns([string[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
            if (-not $this.ColumnWidths.ContainsKey($col)) {
                $this.ColumnWidths[$col] = 15  # Default width
            }
        }
    }
    
    [void] AutoSizeColumns() {
        foreach ($col in $this.Columns) {
            $maxWidth = $col.Length
            
            foreach ($item in $this.Items) {
                if ($item.PSObject.Properties[$col]) {
                    $val = $item.$col
                    if ($null -ne $val) {
                        $len = $val.ToString().Length
                        if ($len -gt $maxWidth) {
                            $maxWidth = $len
                        }
                    }
                }
            }
            
            $this.ColumnWidths[$col] = [Math]::Min($maxWidth + 2, 30)  # Cap at 30
        }
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = [ConsoleColor]::Black
            $fgColor = [ConsoleColor]::White
            $borderColor = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Gray }
            $headerBg = [ConsoleColor]::DarkBlue
            $selectedBg = [ConsoleColor]::DarkCyan
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            $contentX = 0
            $contentY = 0
            $contentWidth = $this.Width
            $contentHeight = $this.Height
            
            # Draw border if enabled
            if ($this.ShowBorder) {
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                    -Width $this.Width -Height $this.Height `
                    -ForegroundColor $borderColor -BackgroundColor $bgColor `
                    -BorderStyle Single
                
                $contentX = 1
                $contentY = 1
                $contentWidth = $this.Width - 2
                $contentHeight = $this.Height - 2
            }
            
            $currentY = $contentY
            $dataStartY = $contentY
            
            # Draw header if enabled
            if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
                $this.DrawHeader($contentX, $currentY, $contentWidth, $headerBg)
                $currentY++
                $dataStartY++
                
                # Draw separator line
                for ($x = $contentX; $x -lt $contentX + $contentWidth; $x++) {
                    $this._private_buffer.SetCell($x, $currentY, [TuiCell]::new('-', $borderColor, $bgColor))
                }
                $currentY++
                $dataStartY++
            }
            
            # Calculate visible rows
            $visibleRows = $contentHeight - ($dataStartY - $contentY)
            if ($visibleRows -le 0) { return }
            
            # Adjust scroll offset to keep selection visible
            if ($this.AllowSelection -and $this.SelectedIndex -ge 0) {
                if ($this.SelectedIndex -lt $this._scrollOffset) {
                    $this._scrollOffset = $this.SelectedIndex
                }
                elseif ($this.SelectedIndex -ge $this._scrollOffset + $visibleRows) {
                    $this._scrollOffset = $this.SelectedIndex - $visibleRows + 1
                }
            }
            
            # Draw data rows
            for ($i = 0; $i -lt $visibleRows; $i++) {
                $itemIndex = $i + $this._scrollOffset
                if ($itemIndex -ge $this.Items.Count) { break }
                
                $item = $this.Items[$itemIndex]
                $rowBg = $bgColor
                $rowFg = $fgColor
                
                if ($this.AllowSelection -and $itemIndex -eq $this.SelectedIndex) {
                    $rowBg = $selectedBg
                    $rowFg = [ConsoleColor]::White
                }
                
                $this.DrawRow($item, $contentX, $currentY, $contentWidth, $rowFg, $rowBg)
                $currentY++
            }
            
            # Draw scrollbar if needed
            if ($this.Items.Count -gt $visibleRows) {
                $this.DrawScrollbar($contentX + $contentWidth - 1, $dataStartY, $visibleRows)
            }
        }
        catch {}
    }
    
    hidden [void] DrawHeader([int]$x, [int]$y, [int]$maxWidth, [ConsoleColor]$headerBg) {
        $currentX = $x - $this._horizontalScroll
        
        foreach ($col in $this.Columns) {
            $colWidth = $this.ColumnWidths[$col]
            
            if ($currentX + $colWidth -gt $x) {
                $visibleStart = [Math]::Max(0, $x - $currentX)
                $visibleWidth = [Math]::Min($colWidth - $visibleStart, $maxWidth - ($currentX - $x))
                
                if ($visibleWidth -gt 0) {
                    $headerText = $col
                    if ($headerText.Length -gt $visibleWidth) {
                        $headerText = $headerText.Substring(0, $visibleWidth - 1) + ">"
                    }
                    else {
                        $headerText = $headerText.PadRight($visibleWidth)
                    }
                    
                    $drawX = [Math]::Max($x, $currentX)
                    $this._private_buffer.WriteString($drawX, $y, $headerText, [ConsoleColor]::White, $headerBg)
                }
            }
            
            $currentX += $colWidth
            if ($currentX -ge $x + $maxWidth) { break }
        }
    }
    
    hidden [void] DrawRow([PSObject]$item, [int]$x, [int]$y, [int]$maxWidth, [ConsoleColor]$fg, [ConsoleColor]$bg) {
        # Clear row first
        for ($i = 0; $i -lt $maxWidth; $i++) {
            $this._private_buffer.SetCell($x + $i, $y, [TuiCell]::new(' ', $fg, $bg))
        }
        
        $currentX = $x - $this._horizontalScroll
        
        foreach ($col in $this.Columns) {
            $colWidth = $this.ColumnWidths[$col]
            
            if ($currentX + $colWidth -gt $x) {
                $value = ""
                if ($item.PSObject.Properties[$col]) {
                    $val = $item.$col
                    if ($null -ne $val) {
                        $value = $val.ToString()
                    }
                }
                
                $visibleStart = [Math]::Max(0, $x - $currentX)
                $visibleWidth = [Math]::Min($colWidth - $visibleStart, $maxWidth - ($currentX - $x))
                
                if ($visibleWidth -gt 0) {
                    if ($value.Length -gt $visibleWidth - 1) {
                        $value = $value.Substring(0, $visibleWidth - 2) + ".."
                    }
                    
                    $drawX = [Math]::Max($x, $currentX)
                    $this._private_buffer.WriteString($drawX, $y, $value, $fg, $bg)
                }
            }
            
            $currentX += $colWidth
            if ($currentX -ge $x + $maxWidth) { break }
        }
    }
    
    hidden [void] DrawScrollbar([int]$x, [int]$y, [int]$height) {
        $scrollbarHeight = [Math]::Max(1, [int]($height * $height / $this.Items.Count))
        $scrollbarPos = [int](($height - $scrollbarHeight) * $this._scrollOffset / ($this.Items.Count - $height))
        
        for ($i = 0; $i -lt $height; $i++) {
            if ($i -ge $scrollbarPos -and $i -lt $scrollbarPos + $scrollbarHeight) {
                $this._private_buffer.SetCell($x, $y + $i, [TuiCell]::new('█', [ConsoleColor]::DarkGray, [ConsoleColor]::Black))
            }
            else {
                $this._private_buffer.SetCell($x, $y + $i, [TuiCell]::new('│', [ConsoleColor]::DarkGray, [ConsoleColor]::Black))
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or -not $this.AllowSelection) { return $false }
        
        $handled = $true
        $oldSelection = $this.SelectedIndex
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                }
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
            }
            ([ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 4  # Account for border and header
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
            }
            ([ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 4
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this._horizontalScroll -gt 0) {
                    $this._horizontalScroll = [Math]::Max(0, $this._horizontalScroll - 5)
                }
            }
            ([ConsoleKey]::RightArrow) {
                $totalWidth = 0
                foreach ($col in $this.Columns) {
                    $totalWidth += $this.ColumnWidths[$col]
                }
                $maxScroll = [Math]::Max(0, $totalWidth - $this.Width + 2)
                $this._horizontalScroll = [Math]::Min($maxScroll, $this._horizontalScroll + 5)
            }
            default {
                $handled = $false
            }
        }
        
        if ($handled) {
            if ($oldSelection -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                try { & $this.OnSelectionChanged $this $this.SelectedIndex } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

#endregion Advanced Components

#region Panel Components

# ===== CLASS: Panel =====
# Module: panels-class
# Dependencies: UIElement, TuiCell
# Purpose: Container with layout management
class Panel : UIElement {
    [string]$Title = ""
    [string]$BorderStyle = "Single"
    [ConsoleColor]$BorderColor = [ConsoleColor]::Gray
    [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    [bool]$HasBorder = $true
    [string]$LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid
    [int]$Padding = 0
    [int]$Spacing = 1
    
    # Content area properties
    [int]$ContentX = 1
    [int]$ContentY = 1
    [int]$ContentWidth = 0
    [int]$ContentHeight = 0

    Panel([string]$name) : base($name) {
        $this.IsFocusable = $false
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgCell = [TuiCell]::new(' ', [ConsoleColor]::White, $this.BackgroundColor)
            $this._private_buffer.Clear($bgCell)

            # Calculate content area
            $this.ContentX = if ($this.HasBorder) { 1 } else { 0 }
            $this.ContentY = if ($this.HasBorder) { 1 } else { 0 }
            $this.ContentWidth = [Math]::Max(0, $this.Width - (if ($this.HasBorder) { 2 } else { 0 }))
            $this.ContentHeight = [Math]::Max(0, $this.Height - (if ($this.HasBorder) { 2 } else { 0 }))

            if ($this.HasBorder) {
                $borderColorToUse = $this.BorderColor
                if ($this.IsFocused) {
                    $borderColorToUse = [ConsoleColor]::Cyan
                }
                
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                    -Width $this.Width -Height $this.Height `
                    -ForegroundColor $borderColorToUse -BackgroundColor $this.BackgroundColor `
                    -BorderStyle $this.BorderStyle -Title $this.Title
            }

            # Apply layout to children
            $this.ApplyLayout()
        }
        catch {}
    }

    [void] ApplyLayout() {
        if ($this.LayoutType -eq "Manual") { return }

        $layoutX = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
        $layoutY = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
        $layoutWidth = [Math]::Max(0, $this.Width - (2 * $layoutX))
        $layoutHeight = [Math]::Max(0, $this.Height - (2 * $layoutY))

        $visibleChildren = @($this.Children | Where-Object { $_.Visible })
        if ($visibleChildren.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" {
                $currentY = $layoutY
                foreach ($child in $visibleChildren) {
                    $child.X = $layoutX
                    $child.Y = $currentY
                    $child.Width = [Math]::Min($child.Width, $layoutWidth)
                    $currentY += $child.Height + $this.Spacing
                }
            }
            "Horizontal" {
                $currentX = $layoutX
                foreach ($child in $visibleChildren) {
                    $child.X = $currentX
                    $child.Y = $layoutY
                    $child.Height = [Math]::Min($child.Height, $layoutHeight)
                    $currentX += $child.Width + $this.Spacing
                }
            }
            "Grid" {
                # Simple grid layout - arrange in rows
                $cols = [Math]::Max(1, [Math]::Floor($layoutWidth / 20))  # Assume 20 char min width
                $col = 0
                $row = 0
                $cellWidth = [Math]::Max(1, [Math]::Floor($layoutWidth / $cols))
                $cellHeight = 3  # Default height
                
                foreach ($child in $visibleChildren) {
                    $child.X = $layoutX + ($col * $cellWidth)
                    $child.Y = $layoutY + ($row * ($cellHeight + $this.Spacing))
                    $child.Width = [Math]::Max(1, $cellWidth - $this.Spacing)
                    $child.Height = $cellHeight
                    
                    $col++
                    if ($col -ge $cols) {
                        $col = 0
                        $row++
                    }
                }
            }
        }
    }

    [hashtable] GetContentArea() {
        $area = @{
            X = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
            Y = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
        }
        $area.Width = [Math]::Max(0, $this.Width - (2 * $area.X))
        $area.Height = [Math]::Max(0, $this.Height - (2 * $area.Y))
        return $area
    }
}

# ===== CLASS: ScrollablePanel =====
# Module: panels-class
# Dependencies: Panel, TuiCell
# Purpose: Panel with scrolling capabilities
class ScrollablePanel : Panel {
    [int]$ScrollOffsetY = 0
    [int]$MaxScrollY = 0
    [bool]$ShowScrollbar = $true
    hidden [int]$_contentHeight = 0

    ScrollablePanel([string]$name) : base($name) {
        $this.IsFocusable = $true
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # First render the base panel
        ([Panel]$this).OnRender()

        # Calculate content height
        $this._contentHeight = 0
        foreach ($child in $this.Children) {
            $childBottom = $child.Y + $child.Height
            if ($childBottom -gt $this._contentHeight) {
                $this._contentHeight = $childBottom
            }
        }

        # Calculate viewport
        $viewportHeight = $this.Height
        if ($this.HasBorder) { $viewportHeight -= 2 }
        
        $this.MaxScrollY = [Math]::Max(0, $this._contentHeight - $viewportHeight)

        # Draw scrollbar if needed
        if ($this.ShowScrollbar -and $this.MaxScrollY -gt 0) {
            $this.DrawScrollbar()
        }
    }

    hidden [void] DrawScrollbar() {
        $scrollbarX = $this.Width - 1
        if (-not $this.HasBorder) { $scrollbarX = $this.Width - 1 }
        
        $scrollbarY = if ($this.HasBorder) { 1 } else { 0 }
        $scrollbarHeight = $this.Height
        if ($this.HasBorder) { $scrollbarHeight -= 2 }

        # Calculate thumb size and position
        $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $scrollbarHeight / $this._contentHeight))
        $thumbPos = [int]($scrollbarHeight * $this.ScrollOffsetY / $this._contentHeight)

        # Draw scrollbar track and thumb
        for ($i = 0; $i -lt $scrollbarHeight; $i++) {
            $y = $scrollbarY + $i
            if ($i -ge $thumbPos -and $i -lt $thumbPos + $thumbSize) {
                $this._private_buffer.SetCell($scrollbarX, $y, 
                    [TuiCell]::new('█', [ConsoleColor]::DarkGray, $this.BackgroundColor))
            }
            else {
                $this._private_buffer.SetCell($scrollbarX, $y, 
                    [TuiCell]::new('│', [ConsoleColor]::DarkGray, $this.BackgroundColor))
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $false
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.ScrollOffsetY -gt 0) {
                    $this.ScrollUp()
                    $handled = $true
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.ScrollOffsetY -lt $this.MaxScrollY) {
                    $this.ScrollDown()
                    $handled = $true
                }
            }
            ([ConsoleKey]::PageUp) {
                $this.ScrollPageUp()
                $handled = $true
            }
            ([ConsoleKey]::PageDown) {
                $this.ScrollPageDown()
                $handled = $true
            }
            ([ConsoleKey]::Home) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.ScrollToTop()
                    $handled = $true
                }
            }
            ([ConsoleKey]::End) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.ScrollToBottom()
                    $handled = $true
                }
            }
        }

        if ($handled) {
            $this.RequestRedraw()
        }

        return $handled
    }

    [void] ScrollUp([int]$lines = 1) {
        $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY - $lines)
        $this.UpdateChildrenPositions()
    }

    [void] ScrollDown([int]$lines = 1) {
        $this.ScrollOffsetY = [Math]::Min($this.MaxScrollY, $this.ScrollOffsetY + $lines)
        $this.UpdateChildrenPositions()
    }

    [void] ScrollPageUp() {
        $pageSize = $this.Height
        if ($this.HasBorder) { $pageSize -= 2 }
        $this.ScrollUp($pageSize)
    }

    [void] ScrollPageDown() {
        $pageSize = $this.Height
        if ($this.HasBorder) { $pageSize -= 2 }
        $this.ScrollDown($pageSize)
    }

    [void] ScrollToTop() {
        $this.ScrollOffsetY = 0
        $this.UpdateChildrenPositions()
    }

    [void] ScrollToBottom() {
        $this.ScrollOffsetY = $this.MaxScrollY
        $this.UpdateChildrenPositions()
    }

    hidden [void] UpdateChildrenPositions() {
        # Virtual scrolling - adjust render positions based on scroll offset
        # This is handled during rendering by the compositor
    }
}

# ===== CLASS: GroupPanel =====
# Module: panels-class
# Dependencies: Panel
# Purpose: Themed panel for grouping
class GroupPanel : Panel {
    [bool]$IsExpanded = $true
    [bool]$CanCollapse = $true

    GroupPanel([string]$name) : base($name) {
        $this.BorderStyle = "Double"
        $this.BorderColor = [ConsoleColor]::DarkCyan
        $this.BackgroundColor = [ConsoleColor]::Black
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Show children only if expanded
        foreach ($child in $this.Children) {
            $child.Visible = $this.IsExpanded
        }

        # Adjust height if collapsed
        if (-not $this.IsExpanded -and $this.CanCollapse) {
            $this._originalHeight = $this.Height
            $this.Height = 3  # Just title bar
        }
        elseif ($this.IsExpanded -and $this._originalHeight) {
            $this.Height = $this._originalHeight
        }

        # Add expand/collapse indicator to title
        if ($this.CanCollapse -and $this.Title) {
            $indicator = if ($this.IsExpanded) { "[-]" } else { "[+]" }
            $this.Title = "$indicator $($this.Title.TrimStart('[+]', '[-]').Trim())"
        }

        ([Panel]$this).OnRender()
    }

    hidden [int]$_originalHeight = 0

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or -not $this.CanCollapse) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar) {
            $this.Toggle()
            return $true
        }
        
        return $false
    }

    [void] Toggle() {
        $this.IsExpanded = -not $this.IsExpanded
        $this.RequestRedraw()
    }
}

#endregion Panel Components

#region Composite Components

# ===== CLASS: ListBox =====
# Module: tui-components (wrapper)
# Dependencies: UIElement, TuiCell
# Purpose: Scrollable item list with selection
class ListBox : UIElement {
    [List[object]]$Items
    [int]$SelectedIndex = -1
    [ConsoleColor]$ForegroundColor = [ConsoleColor]::White
    [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor]$SelectedForegroundColor = [ConsoleColor]::Black
    [ConsoleColor]$SelectedBackgroundColor = [ConsoleColor]::Cyan
    [ConsoleColor]$BorderColor = [ConsoleColor]::Gray
    hidden [int]$ScrollOffset = 0

    ListBox([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[object]]::new()
        $this.Width = 30
        $this.Height = 10
    }

    [void] AddItem([object]$item) {
        $this.Items.Add($item)
        if ($this.SelectedIndex -eq -1 -and $this.Items.Count -eq 1) {
            $this.SelectedIndex = 0
        }
        $this.RequestRedraw()
    }

    [void] ClearItems() {
        $this.Items.Clear()
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.RequestRedraw()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', $this.ForegroundColor, $this.BackgroundColor))
            
            # Draw border
            $borderColorToUse = if ($this.IsFocused) { [ConsoleColor]::Cyan } else { $this.BorderColor }
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -ForegroundColor $borderColorToUse -BackgroundColor $this.BackgroundColor `
                -BorderStyle Single
            
            # Calculate visible area
            $contentY = 1
            $contentHeight = $this.Height - 2
            $contentX = 1
            $contentWidth = $this.Width - 2
            
            # Ensure selected item is visible
            $this.EnsureVisible($this.SelectedIndex)
            
            # Draw items
            for ($i = 0; $i -lt $contentHeight -and ($i + $this.ScrollOffset) -lt $this.Items.Count; $i++) {
                $itemIndex = $i + $this.ScrollOffset
                $item = $this.Items[$itemIndex]
                $itemText = if ($item -is [string]) { $item } else { $item.ToString() }
                
                if ($itemText.Length -gt $contentWidth) {
                    $itemText = $itemText.Substring(0, $contentWidth - 3) + "..."
                }
                
                $fg = $this.ForegroundColor
                $bg = $this.BackgroundColor
                
                if ($itemIndex -eq $this.SelectedIndex) {
                    $fg = $this.SelectedForegroundColor
                    $bg = $this.SelectedBackgroundColor
                    
                    # Fill entire row with selection color
                    for ($x = $contentX; $x -lt $contentX + $contentWidth; $x++) {
                        $this._private_buffer.SetCell($x, $contentY + $i, 
                            [TuiCell]::new(' ', $fg, $bg))
                    }
                }
                
                $this._private_buffer.WriteString($contentX, $contentY + $i, $itemText, $fg, $bg)
            }
            
            # Draw scrollbar if needed
            if ($this.Items.Count -gt $contentHeight) {
                $scrollbarX = $this.Width - 2
                $scrollbarHeight = $contentHeight
                $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $scrollbarHeight / $this.Items.Count))
                $thumbPos = [int]($scrollbarHeight * $this.ScrollOffset / $this.Items.Count)
                
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    if ($i -ge $thumbPos -and $i -lt $thumbPos + $thumbSize) {
                        $this._private_buffer.SetCell($scrollbarX, $contentY + $i, 
                            [TuiCell]::new('█', [ConsoleColor]::DarkGray, $this.BackgroundColor))
                    }
                    else {
                        $this._private_buffer.SetCell($scrollbarX, $contentY + $i, 
                            [TuiCell]::new('│', [ConsoleColor]::DarkGray, $this.BackgroundColor))
                    }
                }
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $true
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                }
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
            }
            ([ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 2
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
            }
            ([ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 2
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
            }
            default {
                $handled = $false
            }
        }
        
        if ($handled) {
            $this.RequestRedraw()
        }
        
        return $handled
    }

    [void] EnsureVisible([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Items.Count) { return }
        
        $visibleHeight = $this.Height - 2
        
        if ($index -lt $this.ScrollOffset) {
            $this.ScrollOffset = $index
        }
        elseif ($index -ge $this.ScrollOffset + $visibleHeight) {
            $this.ScrollOffset = $index - $visibleHeight + 1
        }
    }
}

# ===== CLASS: TextBox =====
# Module: tui-components (wrapper)
# Dependencies: TextBoxComponent
# Purpose: Enhanced wrapper around TextBoxComponent
class TextBox : UIElement {
    hidden [TextBoxComponent]$_textBox

    TextBox([string]$name) : base($name) {
        $this._textBox = [TextBoxComponent]::new($name + "_inner")
        $this.AddChild($this._textBox)
        $this.IsFocusable = $true
    }

    [string] GetText() { return $this._textBox.Text }
    [void] SetText([string]$value) { $this._textBox.Text = $value }
    
    [void] Clear() {
        $this._textBox.Text = ""
        $this._textBox.CursorPosition = 0
        $this._textBox.RequestRedraw()
    }

    [void] Focus() {
        if ($this.Parent -and $this.Parent._focusManager) {
            $this.Parent._focusManager.SetFocus($this)
        }
    }

    [void] OnResize() {
        if ($this._textBox) {
            $this._textBox.Width = $this.Width
            $this._textBox.Height = $this.Height
            $this._textBox.X = 0
            $this._textBox.Y = 0
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $this._textBox.HandleInput($key)
    }
}

# ===== CLASS: CommandPalette =====
# Module: command-palette
# Dependencies: UIElement, Panel, ListBox, TextBox
# Purpose: Searchable command interface
class CommandPalette : UIElement {
    hidden [ListBox]$_listBox
    hidden [TextBox]$_searchBox
    hidden [Panel]$_panel
    hidden [List[object]]$_allActions
    hidden [List[object]]$_filteredActions
    hidden [object]$_actionService
    hidden [scriptblock]$OnCancel
    hidden [scriptblock]$OnSelect

    CommandPalette([string]$name, [object]$actionService) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 60
        $this.Height = 20
        $this._actionService = $actionService
        
        $this.Initialize()
    }

    hidden [void] Initialize() {
        # Create main panel
        $this._panel = [Panel]::new("CommandPalette_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.BorderColor = [ConsoleColor]::Cyan
        $this._panel.BackgroundColor = [ConsoleColor]::Black
        $this._panel.Title = " Command Palette "
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this.AddChild($this._panel)

        # Create search box
        $this._searchBox = [TextBox]::new("CommandPalette_Search")
        $this._searchBox.X = 2
        $this._searchBox.Y = 1
        $this._searchBox.Width = $this.Width - 4
        $this._searchBox.Height = 3
        $this._searchBox._textBox.Placeholder = "Type to search commands..."
        $this._searchBox._textBox.OnChange = {
            param($sender, $text)
            $this.FilterActions($text)
        }.GetNewClosure()
        $this._panel.AddChild($this._searchBox)

        # Create list box
        $this._listBox = [ListBox]::new("CommandPalette_List")
        $this._listBox.X = 2
        $this._listBox.Y = 4
        $this._listBox.Width = $this.Width - 4
        $this._listBox.Height = $this.Height - 6
        $this._panel.AddChild($this._listBox)

        # Initialize action lists
        $this._allActions = [List[object]]::new()
        $this._filteredActions = [List[object]]::new()
    }

    [void] Show() {
        $this.RefreshActions()
        $this._searchBox.Clear()
        $this.FilterActions("")
        $this.Visible = $true
        $this._searchBox.Focus()
        $this.RequestRedraw()
    }

    [void] Hide() {
        $this.Visible = $false
        if ($this.OnCancel) {
            & $this.OnCancel
        }
        $this.RequestRedraw()
    }

    [void] RefreshActions() {
        $this._allActions.Clear()
        
        if ($this._actionService) {
            $actions = $this._actionService.GetAllActions()
            if ($actions -and $actions.Values) {
                foreach ($action in $actions.Values) {
                    if ($action) {
                        $this._allActions.Add($action)
                    }
                }
            }
        }
        
        # Sort by category and name
        $sorted = $this._allActions | Sort-Object Category, Name
        $this._allActions.Clear()
        foreach ($item in $sorted) {
            $this._allActions.Add($item)
        }
    }

    [void] FilterActions([string]$searchText) {
        $this._filteredActions.Clear()
        $this._listBox.ClearItems()
        
        if ([string]::IsNullOrWhiteSpace($searchText)) {
            # Show all actions
            foreach ($action in $this._allActions) {
                $this._filteredActions.Add($action)
                $displayText = if ($action.Category) { 
                    "[$($action.Category)] $($action.Name) - $($action.Description)" 
                } else { 
                    "$($action.Name) - $($action.Description)" 
                }
                $this._listBox.AddItem($displayText)
            }
        }
        else {
            # Fuzzy search
            $searchLower = $searchText.ToLower()
            foreach ($action in $this._allActions) {
                $nameMatch = $action.Name.ToLower().Contains($searchLower)
                $descMatch = $action.Description.ToLower().Contains($searchLower)
                $catMatch = $action.Category -and $action.Category.ToLower().Contains($searchLower)
                
                if ($nameMatch -or $descMatch -or $catMatch) {
                    $this._filteredActions.Add($action)
                    $displayText = if ($action.Category) { 
                        "[$($action.Category)] $($action.Name) - $($action.Description)" 
                    } else { 
                        "$($action.Name) - $($action.Description)" 
                    }
                    $this._listBox.AddItem($displayText)
                }
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Hide()
            return $true
        }
        
        if ($key.Key -eq [ConsoleKey]::Enter -and $this._listBox.SelectedIndex -ge 0) {
            $selectedAction = $this._filteredActions[$this._listBox.SelectedIndex]
            if ($selectedAction) {
                $this.Hide()
                if ($this.OnSelect) {
                    & $this.OnSelect $selectedAction
                }
                else {
                    # Execute action directly
                    $this._actionService.ExecuteAction($selectedAction.Name)
                }
            }
            return $true
        }
        
        # Pass input to search box or list box
        if ($key.Key -in @([ConsoleKey]::UpArrow, [ConsoleKey]::DownArrow, 
                          [ConsoleKey]::PageUp, [ConsoleKey]::PageDown)) {
            return $this._listBox.HandleInput($key)
        }
        else {
            return $this._searchBox.HandleInput($key)
        }
    }

    [void] OnResize() {
        if ($this._panel) {
            $this._panel.Width = $this.Width
            $this._panel.Height = $this.Height
            
            $this._searchBox.Width = $this.Width - 4
            $this._listBox.Width = $this.Width - 4
            $this._listBox.Height = $this.Height - 6
        }
    }
}

#endregion Composite Components

#region Dialog Components

# ===== CLASS: Dialog =====
# Module: dialog-system-class
# Dependencies: UIElement, Panel
# Purpose: Base class for modal dialogs
class Dialog : UIElement {
    [string]$Title = ""
    [string]$Message = ""
    hidden [Panel]$_panel
    hidden [object]$Result = $null
    hidden [bool]$_isComplete = $false
    [scriptblock]$OnClose

    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 50
        $this.Height = 10
        
        $this.InitializeDialog()
    }

    hidden [void] InitializeDialog() {
        $this._panel = [Panel]::new($this.Name + "_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.BorderColor = [ConsoleColor]::Yellow
        $this._panel.BackgroundColor = [ConsoleColor]::Black
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this.AddChild($this._panel)
    }

    [void] Show([string]$title, [string]$message) {
        $this.Title = $title
        $this.Message = $message
        $this._panel.Title = " $title "
        $this._isComplete = $false
        $this.Result = $null
        $this.Visible = $true
        $this.RequestRedraw()
    }

    [void] Close([object]$result) {
        $this.Result = $result
        $this._isComplete = $true
        $this.Visible = $false
        if ($this.OnClose) {
            & $this.OnClose $result
        }
        $this.RequestRedraw()
    }

    [object] ShowDialog([string]$title, [string]$message) {
        $this.Show($title, $message)
        
        # In a real implementation, this would block until dialog closes
        # For now, return immediately
        return $this.Result
    }
}

# ===== CLASS: AlertDialog =====
# Module: dialog-system-class
# Dependencies: Dialog, ButtonComponent
# Purpose: Simple message dialog
class AlertDialog : Dialog {
    hidden [ButtonComponent]$_okButton

    AlertDialog([string]$name) : base($name) {
        $this.Height = 8
        $this.InitializeAlert()
    }

    hidden [void] InitializeAlert() {
        # OK button
        $this._okButton = [ButtonComponent]::new($this.Name + "_OK")
        $this._okButton.Text = "OK"
        $this._okButton.Width = 10
        $this._okButton.Height = 3
        $this._okButton.OnClick = {
            $this.Close($true)
        }.GetNewClosure()
        $this._panel.AddChild($this._okButton)
    }

    [void] Show([string]$title, [string]$message) {
        ([Dialog]$this).Show($title, $message)
        
        # Position OK button
        $this._okButton.X = [Math]::Floor(($this.Width - $this._okButton.Width) / 2)
        $this._okButton.Y = $this.Height - 4
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            # Draw message
            $messageX = 2
            $messageY = 2
            $maxWidth = $this.Width - 4
            
            # Simple word wrap
            $words = $this.Message -split ' '
            $currentLine = ""
            $currentY = $messageY
            
            foreach ($word in $words) {
                if (($currentLine + " " + $word).Length -gt $maxWidth) {
                    if ($currentLine) {
                        $this._panel._private_buffer.WriteString($messageX, $currentY, 
                            $currentLine, [ConsoleColor]::White, [ConsoleColor]::Black)
                        $currentY++
                    }
                    $currentLine = $word
                }
                else {
                    $currentLine = if ($currentLine) { "$currentLine $word" } else { $word }
                }
            }
            
            if ($currentLine) {
                $this._panel._private_buffer.WriteString($messageX, $currentY, 
                    $currentLine, [ConsoleColor]::White, [ConsoleColor]::Black)
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape -or $key.Key -eq [ConsoleKey]::Enter) {
            $this.Close($true)
            return $true
        }
        
        return $this._okButton.HandleInput($key)
    }
}

# ===== CLASS: ConfirmDialog =====
# Module: dialog-system-class
# Dependencies: Dialog, ButtonComponent
# Purpose: Yes/No confirmation dialog
class ConfirmDialog : Dialog {
    hidden [ButtonComponent]$_yesButton
    hidden [ButtonComponent]$_noButton
    hidden [bool]$_focusOnYes = $true

    ConfirmDialog([string]$name) : base($name) {
        $this.Height = 8
        $this.InitializeConfirm()
    }

    hidden [void] InitializeConfirm() {
        # Yes button
        $this._yesButton = [ButtonComponent]::new($this.Name + "_Yes")
        $this._yesButton.Text = "Yes"
        $this._yesButton.Width = 10
        $this._yesButton.Height = 3
        $this._yesButton.OnClick = {
            $this.Close($true)
        }.GetNewClosure()
        $this._panel.AddChild($this._yesButton)

        # No button
        $this._noButton = [ButtonComponent]::new($this.Name + "_No")
        $this._noButton.Text = "No"
        $this._noButton.Width = 10
        $this._noButton.Height = 3
        $this._noButton.OnClick = {
            $this.Close($false)
        }.GetNewClosure()
        $this._panel.AddChild($this._noButton)
    }

    [void] Show([string]$title, [string]$message) {
        ([Dialog]$this).Show($title, $message)
        
        # Position buttons
        $buttonY = $this.Height - 4
        $totalWidth = $this._yesButton.Width + $this._noButton.Width + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        $this._yesButton.X = $startX
        $this._yesButton.Y = $buttonY
        
        $this._noButton.X = $startX + $this._yesButton.Width + 4
        $this._noButton.Y = $buttonY
        
        # Set initial focus
        $this._focusOnYes = $true
        $this.UpdateButtonFocus()
    }

    hidden [void] UpdateButtonFocus() {
        $this._yesButton.IsFocused = $this._focusOnYes
        $this._noButton.IsFocused = -not $this._focusOnYes
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            # Draw message (same as AlertDialog)
            $messageX = 2
            $messageY = 2
            $maxWidth = $this.Width - 4
            
            $words = $this.Message -split ' '
            $currentLine = ""
            $currentY = $messageY
            
            foreach ($word in $words) {
                if (($currentLine + " " + $word).Length -gt $maxWidth) {
                    if ($currentLine) {
                        $this._panel._private_buffer.WriteString($messageX, $currentY, 
                            $currentLine, [ConsoleColor]::White, [ConsoleColor]::Black)
                        $currentY++
                    }
                    $currentLine = $word
                }
                else {
                    $currentLine = if ($currentLine) { "$currentLine $word" } else { $word }
                }
            }
            
            if ($currentLine) {
                $this._panel._private_buffer.WriteString($messageX, $currentY, 
                    $currentLine, [ConsoleColor]::White, [ConsoleColor]::Black)
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Close($false)
            return $true
        }
        
        if ($key.Key -eq [ConsoleKey]::Tab -or $key.Key -eq [ConsoleKey]::LeftArrow -or 
            $key.Key -eq [ConsoleKey]::RightArrow) {
            $this._focusOnYes = -not $this._focusOnYes
            $this.UpdateButtonFocus()
            $this.RequestRedraw()
            return $true
        }
        
        if ($this._focusOnYes) {
            return $this._yesButton.HandleInput($key)
        }
        else {
            return $this._noButton.HandleInput($key)
        }
    }
}

# ===== CLASS: InputDialog =====
# Module: dialog-system-class
# Dependencies: Dialog, TextBoxComponent, ButtonComponent
# Purpose: Text input dialog
class InputDialog : Dialog {
    hidden [TextBoxComponent]$_inputBox
    hidden [ButtonComponent]$_okButton
    hidden [ButtonComponent]$_cancelButton
    hidden [bool]$_focusOnInput = $true
    hidden [int]$_focusIndex = 0  # 0=input, 1=ok, 2=cancel

    InputDialog([string]$name) : base($name) {
        $this.Height = 10
        $this.InitializeInput()
    }

    hidden [void] InitializeInput() {
        # Input box
        $this._inputBox = [TextBoxComponent]::new($this.Name + "_Input")
        $this._inputBox.Width = $this.Width - 4
        $this._inputBox.Height = 3
        $this._inputBox.X = 2
        $this._inputBox.Y = 4
        $this._panel.AddChild($this._inputBox)

        # OK button
        $this._okButton = [ButtonComponent]::new($this.Name + "_OK")
        $this._okButton.Text = "OK"
        $this._okButton.Width = 10
        $this._okButton.Height = 3
        $this._okButton.OnClick = {
            $this.Close($this._inputBox.Text)
        }.GetNewClosure()
        $this._panel.AddChild($this._okButton)

        # Cancel button
        $this._cancelButton = [ButtonComponent]::new($this.Name + "_Cancel")
        $this._cancelButton.Text = "Cancel"
        $this._cancelButton.Width = 10
        $this._cancelButton.Height = 3
        $this._cancelButton.OnClick = {
            $this.Close($null)
        }.GetNewClosure()
        $this._panel.AddChild($this._cancelButton)
    }

    [void] Show([string]$title, [string]$message, [string]$defaultValue = "") {
        ([Dialog]$this).Show($title, $message)
        
        $this._inputBox.Text = $defaultValue
        $this._inputBox.CursorPosition = $defaultValue.Length
        
        # Position buttons
        $buttonY = $this.Height - 4
        $totalWidth = $this._okButton.Width + $this._cancelButton.Width + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        $this._okButton.X = $startX
        $this._okButton.Y = $buttonY
        
        $this._cancelButton.X = $startX + $this._okButton.Width + 4
        $this._cancelButton.Y = $buttonY
        
        # Set initial focus
        $this._focusIndex = 0
        $this.UpdateFocus()
    }

    hidden [void] UpdateFocus() {
        $this._inputBox.IsFocused = ($this._focusIndex -eq 0)
        $this._okButton.IsFocused = ($this._focusIndex -eq 1)
        $this._cancelButton.IsFocused = ($this._focusIndex -eq 2)
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            # Draw message
            $this._panel._private_buffer.WriteString(2, 2, 
                $this.Message, [ConsoleColor]::White, [ConsoleColor]::Black)
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Close($null)
            return $true
        }
        
        if ($key.Key -eq [ConsoleKey]::Tab) {
            $this._focusIndex = ($this._focusIndex + 1) % 3
            $this.UpdateFocus()
            $this.RequestRedraw()
            return $true
        }
        
        switch ($this._focusIndex) {
            0 { return $this._inputBox.HandleInput($key) }
            1 { return $this._okButton.HandleInput($key) }
            2 { return $this._cancelButton.HandleInput($key) }
        }
        
        return $false
    }
}

#endregion Dialog Components

#region Navigation Components

# ===== CLASS: NavigationMenu =====
# Module: navigation-class
# Dependencies: UIElement, NavigationItem
# Purpose: Local menu component
class NavigationMenu : UIElement {
    [List[NavigationItem]]$Items
    [int]$SelectedIndex = 0
    [string]$Orientation = "Horizontal"  # Horizontal or Vertical
    [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor]$ForegroundColor = [ConsoleColor]::White
    [ConsoleColor]$SelectedBackgroundColor = [ConsoleColor]::DarkBlue
    [ConsoleColor]$SelectedForegroundColor = [ConsoleColor]::Yellow

    NavigationMenu([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[NavigationItem]]::new()
        $this.Height = 1
    }

    [void] AddItem([NavigationItem]$item) {
        $this.Items.Add($item)
        $this.RequestRedraw()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', $this.ForegroundColor, $this.BackgroundColor))
            
            if ($this.Orientation -eq "Horizontal") {
                $this.RenderHorizontal()
            }
            else {
                $this.RenderVertical()
            }
        }
        catch {}
    }

    hidden [void] RenderHorizontal() {
        $currentX = 0
        
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex -and $this.IsFocused)
            
            $fg = if ($isSelected) { $this.SelectedForegroundColor } else { $this.ForegroundColor }
            $bg = if ($isSelected) { $this.SelectedBackgroundColor } else { $this.BackgroundColor }
            
            # Draw item
            $text = " $($item.Text) "
            if ($item.Hotkey) {
                $text = " $($item.Text) ($($item.Hotkey)) "
            }
            
            if ($currentX + $text.Length -le $this.Width) {
                for ($x = 0; $x -lt $text.Length; $x++) {
                    $this._private_buffer.SetCell($currentX + $x, 0, 
                        [TuiCell]::new($text[$x], $fg, $bg))
                }
            }
            
            $currentX += $text.Length + 1
        }
    }

    hidden [void] RenderVertical() {
        $this.Height = [Math]::Max($this.Items.Count, 1)
        
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex -and $this.IsFocused)
            
            $fg = if ($isSelected) { $this.SelectedForegroundColor } else { $this.ForegroundColor }
            $bg = if ($isSelected) { $this.SelectedBackgroundColor } else { $this.BackgroundColor }
            
            # Clear line
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this._private_buffer.SetCell($x, $i, [TuiCell]::new(' ', $fg, $bg))
            }
            
            # Draw item
            $text = $item.Text
            if ($item.Hotkey) {
                $text = "$($item.Text) ($($item.Hotkey))"
            }
            
            if ($text.Length -gt $this.Width) {
                $text = $text.Substring(0, $this.Width - 3) + "..."
            }
            
            $this._private_buffer.WriteString(0, $i, $text, $fg, $bg)
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $true
        
        if ($this.Orientation -eq "Horizontal") {
            switch ($key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                        $this.SelectedIndex++
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this.ExecuteItem($this.SelectedIndex)
                }
                default {
                    # Check hotkeys
                    $handled = $this.CheckHotkey($key)
                }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                        $this.SelectedIndex++
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this.ExecuteItem($this.SelectedIndex)
                }
                default {
                    $handled = $this.CheckHotkey($key)
                }
            }
        }
        
        if ($handled) {
            $this.RequestRedraw()
        }
        
        return $handled
    }

    hidden [bool] CheckHotkey([System.ConsoleKeyInfo]$key) {
        foreach ($i in 0..($this.Items.Count - 1)) {
            $item = $this.Items[$i]
            if ($item.Hotkey -and $item.Hotkey.ToUpper() -eq $key.KeyChar.ToString().ToUpper()) {
                $this.SelectedIndex = $i
                $this.ExecuteItem($i)
                return $true
            }
        }
        return $false
    }

    hidden [void] ExecuteItem([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $item = $this.Items[$index]
            if ($item.Action) {
                try {
                    & $item.Action
                }
                catch {}
            }
        }
    }
}

#endregion Navigation Components


####\AllFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================

#region TUI Drawing Functions

function Write-TuiBox {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [TuiBuffer]$Buffer,
        
        [Parameter(Mandatory)]
        [int]$X,
        
        [Parameter(Mandatory)]
        [int]$Y,
        
        [Parameter(Mandatory)]
        [int]$Width,
        
        [Parameter(Mandatory)]
        [int]$Height,
        
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White,
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black,
        [string]$BorderStyle = "Single",
        [string]$Title = ""
    )
    
    try {
        if ($Width -le 0 -or $Height -le 0) {
            Write-Warning "Write-TuiBox: Invalid dimensions ($($Width)x$($Height)). Dimensions must be positive."
            return
        }
        
        $borders = Get-TuiBorderChars -Style $BorderStyle
        
        # Calculate effective drawing area
        $drawStartX = [Math]::Max(0, $X)
        $drawStartY = [Math]::Max(0, $Y)
        $drawEndX = [Math]::Min($Buffer.Width, $X + $Width)
        $drawEndY = [Math]::Min($Buffer.Height, $Y + $Height)
        
        if ($drawEndX -le $drawStartX -or $drawEndY -le $drawStartY) {
            Write-Verbose "Write-TuiBox: Effective drawing area is invalid after clipping. Skipping."
            return
        }
        
        # Fill background
        $fillCell = [TuiCell]::new(' ', $BorderColor, $BackgroundColor)
        for ($currentY = $drawStartY; $currentY -lt $drawEndY; $currentY++) {
            for ($currentX = $drawStartX; $currentX -lt $drawEndX; $currentX++) {
                $Buffer.SetCell($currentX, $currentY, [TuiCell]::new($fillCell))
            }
        }
        
        # Draw corners
        if ($X -ge 0 -and $Y -ge 0) { 
            $Buffer.SetCell($X, $Y, [TuiCell]::new($borders.TopLeft, $BorderColor, $BackgroundColor))
        }
        if (($X + $Width - 1) -lt $Buffer.Width -and $Y -ge 0) { 
            $Buffer.SetCell($X + $Width - 1, $Y, [TuiCell]::new($borders.TopRight, $BorderColor, $BackgroundColor))
        }
        if ($X -ge 0 -and ($Y + $Height - 1) -lt $Buffer.Height) { 
            $Buffer.SetCell($X, $Y + $Height - 1, [TuiCell]::new($borders.BottomLeft, $BorderColor, $BackgroundColor))
        }
        if (($X + $Width - 1) -lt $Buffer.Width -and ($Y + $Height - 1) -lt $Buffer.Height) { 
            $Buffer.SetCell($X + $Width - 1, $Y + $Height - 1, [TuiCell]::new($borders.BottomRight, $BorderColor, $BackgroundColor))
        }
        
        # Draw horizontal lines
        for ($i = 1; $i -lt $Width - 1; $i++) {
            if ($Y -ge 0 -and ($X + $i) -ge 0 -and ($X + $i) -lt $Buffer.Width) {
                $Buffer.SetCell($X + $i, $Y, [TuiCell]::new($borders.Horizontal, $BorderColor, $BackgroundColor))
            }
            if (($Y + $Height - 1) -ge 0 -and ($Y + $Height - 1) -lt $Buffer.Height -and ($X + $i) -ge 0 -and ($X + $i) -lt $Buffer.Width) {
                $Buffer.SetCell($X + $i, $Y + $Height - 1, [TuiCell]::new($borders.Horizontal, $BorderColor, $BackgroundColor))
            }
        }
        
        # Draw vertical lines
        for ($i = 1; $i -lt $Height - 1; $i++) {
            if ($X -ge 0 -and ($Y + $i) -ge 0 -and ($Y + $i) -lt $Buffer.Height) {
                $Buffer.SetCell($X, $Y + $i, [TuiCell]::new($borders.Vertical, $BorderColor, $BackgroundColor))
            }
            if (($X + $Width - 1) -ge 0 -and ($X + $Width - 1) -lt $Buffer.Width -and ($Y + $i) -ge 0 -and ($Y + $i) -lt $Buffer.Height) {
                $Buffer.SetCell($X + $Width - 1, $Y + $i, [TuiCell]::new($borders.Vertical, $BorderColor, $BackgroundColor))
            }
        }
        
        # Draw title if provided
        if ($Title -and $Title.Length -gt 0 -and $Y -ge 0) {
            $titleWithSpace = " $Title "
            $titleX = $X + [Math]::Floor(($Width - $titleWithSpace.Length) / 2)
            if ($titleX -ge 0) {
                $maxTitleLength = [Math]::Min($titleWithSpace.Length, $Width - 2)
                if ($maxTitleLength -gt 0) {
                    $displayTitle = $titleWithSpace.Substring(0, $maxTitleLength)
                    $Buffer.WriteString($titleX, $Y, $displayTitle, $BorderColor, $BackgroundColor)
                }
            }
        }
    }
    catch {
        Write-Error "Write-TuiBox error: $_"
    }
}

function Write-TuiText {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][string]$Text,
        [object]$ForegroundColor = [ConsoleColor]::White,
        [object]$BackgroundColor = [ConsoleColor]::Black,
        [bool]$Bold = $false,
        [bool]$Underline = $false,
        [bool]$Italic = $false,
        [int]$ZIndex = 0
    )
    
    try {
        if ($Y -lt 0 -or $Y -ge $Buffer.Height) {
            Write-Warning "Write-TuiText: Y coordinate ($Y) is out of bounds for buffer '$($Buffer.Name)' (0..$($Buffer.Height-1)). Text: '$Text'."
            return
        }
        
        $currentX = $X
        foreach ($char in $Text.ToCharArray()) {
            if ($currentX -ge $Buffer.Width) { break }
            if ($currentX -ge 0) {
                $cell = [TuiCell]::new($char, $ForegroundColor, $BackgroundColor, $Bold, $Underline)
                $cell.Italic = $Italic
                $cell.ZIndex = $ZIndex
                $Buffer.SetCell($currentX, $Y, $cell)
            }
            $currentX++
        }
        
        Write-Verbose "Write-TuiText: Wrote '$Text' to buffer '$($Buffer.Name)' at ($X, $Y)."
    }
    catch {
        Write-Error "Failed to write text to buffer '$($Buffer.Name)' at ($X, $Y): $($_.Exception.Message)"
        throw
    }
}

function Write-TuiBox {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [ValidateSet("Single", "Double", "Rounded", "Thick")][string]$BorderStyle = "Single",
        [object]$BorderColor = [ConsoleColor]::White,
        [object]$BackgroundColor = [ConsoleColor]::Black,
        [string]$Title = ""
    )
    
    try {
        if ($Width -le 0 -or $Height -le 0) {
            Write-Warning "Write-TuiBox: Invalid dimensions ($($Width)x$($Height)). Dimensions must be positive."
            return
        }
        
        $borders = Get-TuiBorderChars -Style $BorderStyle
        
        # Calculate effective drawing area
        $drawStartX = [Math]::Max(0, $X)
        $drawStartY = [Math]::Max(0, $Y)
        $drawEndX = [Math]::Min($Buffer.Width, $X + $Width)
        $drawEndY = [Math]::Min($Buffer.Height, $Y + $Height)
        
        if ($drawEndX -le $drawStartX -or $drawEndY -le $drawStartY) {
            Write-Verbose "Write-TuiBox: Effective drawing area is invalid after clipping. Skipping."
            return
        }
        
        # Fill background
        $fillCell = [TuiCell]::new(' ', $BorderColor, $BackgroundColor)
        for ($currentY = $drawStartY; $currentY -lt $drawEndY; $currentY++) {
            for ($currentX = $drawStartX; $currentX -lt $drawEndX; $currentX++) {
                $Buffer.SetCell($currentX, $currentY, [TuiCell]::new($fillCell))
            }
        }
        
        # Draw corners
        if ($X -ge 0 -and $Y -ge 0) { 
            $Buffer.SetCell($X, $Y, [TuiCell]::new($borders.TopLeft, $BorderColor, $BackgroundColor))
        }
        if (($X + $Width - 1) -lt $Buffer.Width -and $Y -ge 0) { 
            $Buffer.SetCell($X + $Width - 1, $Y, [TuiCell]::new($borders.TopRight, $BorderColor, $BackgroundColor))
        }
        if ($X -ge 0 -and ($Y + $Height - 1) -lt $Buffer.Height) { 
            $Buffer.SetCell($X, $Y + $Height - 1, [TuiCell]::new($borders.BottomLeft, $BorderColor, $BackgroundColor))
        }
        if (($X + $Width - 1) -lt $Buffer.Width -and ($Y + $Height - 1) -lt $Buffer.Height) { 
            $Buffer.SetCell($X + $Width - 1, $Y + $Height - 1, [TuiCell]::new($borders.BottomRight, $BorderColor, $BackgroundColor))
        }
        
        # Draw horizontal borders
        for ($cx = 1; $cx -lt ($Width - 1); $cx++) {
            if (($X + $cx) -ge 0 -and ($X + $cx) -lt $Buffer.Width) {
                if ($Y -ge 0 -and $Y -lt $Buffer.Height) { 
                    $Buffer.SetCell($X + $cx, $Y, [TuiCell]::new($borders.Horizontal, $BorderColor, $BackgroundColor))
                }
                if ($Height -gt 1 -and ($Y + $Height - 1) -ge 0 -and ($Y + $Height - 1) -lt $Buffer.Height) { 
                    $Buffer.SetCell($X + $cx, $Y + $Height - 1, [TuiCell]::new($borders.Horizontal, $BorderColor, $BackgroundColor))
                }
            }
        }
        
        # Draw vertical borders
        for ($cy = 1; $cy -lt ($Height - 1); $cy++) {
            if (($Y + $cy) -ge 0 -and ($Y + $cy) -lt $Buffer.Height) {
                if ($X -ge 0 -and $X -lt $Buffer.Width) { 
                    $Buffer.SetCell($X, $Y + $cy, [TuiCell]::new($borders.Vertical, $BorderColor, $BackgroundColor))
                }
                if ($Width -gt 1 -and ($X + $Width - 1) -ge 0 -and ($X + $Width - 1) -lt $Buffer.Width) { 
                    $Buffer.SetCell($X + $Width - 1, $Y + $cy, [TuiCell]::new($borders.Vertical, $BorderColor, $BackgroundColor))
                }
            }
        }
        
        # Draw title if provided
        if (-not [string]::IsNullOrEmpty($Title) -and $Y -ge 0 -and $Y -lt $Buffer.Height) {
            $titleText = " $Title "
            if ($titleText.Length -le ($Width - 2)) { 
                $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
                Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
            }
        }
        
        Write-Verbose "Write-TuiBox: Drew '$BorderStyle' box on buffer '$($Buffer.Name)' at ($X, $Y) with dimensions $($Width)x$($Height)."
    }
    catch {
        Write-Error "Failed to draw TUI box on buffer '$($Buffer.Name)' at ($X, $Y), $($Width)x$($Height): $($_.Exception.Message)"
        throw
    }
}

function Get-TuiBorderChars {
    [CmdletBinding()]
    param(
        [ValidateSet("Single", "Double", "Rounded", "Thick")][string]$Style = "Single"
    )
    
    try {
        $styles = @{
            Single = @{ 
                TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'; 
                Horizontal = '─'; Vertical = '│' 
            }
            Double = @{ 
                TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'; 
                Horizontal = '═'; Vertical = '║' 
            }
            Rounded = @{ 
                TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'; 
                Horizontal = '─'; Vertical = '│' 
            }
            Thick = @{ 
                TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'; 
                Horizontal = '━'; Vertical = '┃' 
            }
        }
        
        $selectedStyle = $styles[$Style]
        if ($null -eq $selectedStyle) {
            Write-Warning "Get-TuiBorderChars: Border style '$Style' not found. Returning 'Single' style."
            return $styles.Single
        }
        
        Write-Verbose "Get-TuiBorderChars: Retrieved TUI border characters for style: $Style."
        return $selectedStyle
    }
    catch {
        Write-Error "Failed to get TUI border characters for style '$Style': $($_.Exception.Message)"
        throw
    }
}

#endregion

#region Factory Functions

function New-TuiBuffer {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [string]$Name = "Unnamed"
    )
    return [TuiBuffer]::new($Width, $Height, $Name)
}

function New-TuiLabel {
    [CmdletBinding()]
    param([hashtable]$Props = @{})
    
    try {
        $labelName = $Props.Name ?? "Label_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        $label = [LabelComponent]::new($labelName)
        
        $Props.GetEnumerator() | ForEach-Object {
            if ($label.PSObject.Properties.Match($_.Name)) {
                $label.($_.Name) = $_.Value
            }
        }
        
        Write-Verbose "Created label '$labelName' with $($Props.Count) properties"
        return $label
    }
    catch {
        Write-Error "Failed to create label: $($_.Exception.Message)"
        throw
    }
}

function New-TuiButton {
    [CmdletBinding()]
    param([hashtable]$Props = @{})
    
    try {
        $buttonName = $Props.Name ?? "Button_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        $button = [ButtonComponent]::new($buttonName)
        
        $Props.GetEnumerator() | ForEach-Object {
            if ($button.PSObject.Properties.Match($_.Name)) {
                $button.($_.Name) = $_.Value
            }
        }
        
        Write-Verbose "Created button '$buttonName' with $($Props.Count) properties"
        return $button
    }
    catch {
        Write-Error "Failed to create button: $($_.Exception.Message)"
        throw
    }
}

function New-TuiTextBox {
    [CmdletBinding()]
    param([hashtable]$Props = @{})
    
    try {
        $textBoxName = $Props.Name ?? "TextBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        $textBox = [TextBoxComponent]::new($textBoxName)
        
        $Props.GetEnumerator() | ForEach-Object {
            if ($textBox.PSObject.Properties.Match($_.Name)) {
                $textBox.($_.Name) = $_.Value
            }
        }
        
        Write-Verbose "Created textbox '$textBoxName' with $($Props.Count) properties"
        return $textBox
    }
    catch {
        Write-Error "Failed to create textbox: $($_.Exception.Message)"
        throw
    }
}

function New-TuiCheckBox {
    [CmdletBinding()]
    param([hashtable]$Props = @{})
    
    try {
        $checkBoxName = $Props.Name ?? "CheckBox_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        $checkBox = [CheckBoxComponent]::new($checkBoxName)
        
        $Props.GetEnumerator() | ForEach-Object {
            if ($checkBox.PSObject.Properties.Match($_.Name)) {
                $checkBox.($_.Name) = $_.Value
            }
        }
        
        Write-Verbose "Created checkbox '$checkBoxName' with $($Props.Count) properties"
        return $checkBox
    }
    catch {
        Write-Error "Failed to create checkbox: $($_.Exception.Message)"
        throw
    }
}

function New-TuiRadioButton {
    [CmdletBinding()]
    param([hashtable]$Props = @{})
    
    try {
        $radioButtonName = $Props.Name ?? "RadioButton_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        $radioButton = [RadioButtonComponent]::new($radioButtonName)
        
        $Props.GetEnumerator() | ForEach-Object {
            if ($radioButton.PSObject.Properties.Match($_.Name)) {
                $radioButton.($_.Name) = $_.Value
            }
        }
        
        Write-Verbose "Created radio button '$radioButtonName' with $($Props.Count) properties"
        return $radioButton
    }
    catch {
        Write-Error "Failed to create radio button: $($_.Exception.Message)"
        throw
    }
}

#endregion

#region Theme Functions

function Get-ThemeColor {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$ColorName
    )
    
    if ($global:TuiState.Services.ThemeManager) {
        return $global:TuiState.Services.ThemeManager.GetColor($ColorName)
    }
    
    # Fallback if theme manager not available
    $defaultTheme = @{
        'Foreground' = [ConsoleColor]::White
        'Background' = [ConsoleColor]::Black
        'Accent' = [ConsoleColor]::Cyan
        'Header' = [ConsoleColor]::Cyan
        'Subtle' = [ConsoleColor]::DarkGray
        'Highlight' = [ConsoleColor]::Yellow
        'Border' = [ConsoleColor]::Gray
        'Selection' = [ConsoleColor]::DarkBlue
        'button.normal.background' = [ConsoleColor]::Black
        'button.normal.foreground' = [ConsoleColor]::White
        'button.normal.border' = [ConsoleColor]::Gray
        'button.focus.background' = [ConsoleColor]::Black
        'button.focus.foreground' = [ConsoleColor]::White
        'button.focus.border' = [ConsoleColor]::Cyan
        'button.pressed.background' = [ConsoleColor]::DarkGray
        'button.pressed.foreground' = [ConsoleColor]::Black
        'button.pressed.border' = [ConsoleColor]::Cyan
    }
    
    return $defaultTheme[$ColorName] ?? [ConsoleColor]::White
}

#endregion

#region Utility Functions

function Set-ComponentFocus {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][UIElement]$Component
    )
    
    # Find parent screen/container and clear other focus
    $parent = $Component.Parent
    while ($parent -and -not ($parent -is [Screen])) {
        $parent = $parent.Parent
    }
    
    if ($parent) {
        # Clear focus from all other focusable components
        $parent.Children | ForEach-Object {
            if ($_.IsFocusable -and $_.IsFocused -and $_ -ne $Component) {
                $_.IsFocused = $false
                $_.OnBlur()
                $_.RequestRedraw()
            }
        }
    }
    
    # Set focus on target component
    if ($Component.IsFocusable) {
        $Component.IsFocused = $true
        $Component.OnFocus()
        $Component.RequestRedraw()
        Write-Verbose "Set focus to component: $($Component.Name)"
    } else {
        Write-Warning "Component '$($Component.Name)' is not focusable"
    }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Message,
        [ValidateSet('Info', 'Warning', 'Error', 'Debug')]
        [string]$Level = 'Info'
    )
    
    # Simplified logging - in full app this would use Logger service
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    $logMessage = "[$timestamp] [$Level] $Message"
    
    switch ($Level) {
        'Error' { Write-Error $logMessage }
        'Warning' { Write-Warning $logMessage }
        'Debug' { Write-Debug $logMessage }
        default { Write-Verbose $logMessage }
    }
}

#endregion

#region Event System

function Subscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [Parameter(Mandatory)][scriptblock]$Handler,
        [string]$Source = ""
    )
    
    if ($global:TuiState.Services.EventManager) {
        return $global:TuiState.Services.EventManager.Subscribe($EventName, $Handler)
    }
    
    # Fallback
    $subscriptionId = [Guid]::NewGuid().ToString()
    Write-Verbose "Subscribed to event '$EventName' with handler ID: $subscriptionId"
    return $subscriptionId
}

function Unsubscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [Parameter(Mandatory)][string]$HandlerId
    )
    
    if ($global:TuiState.Services.EventManager) {
        $global:TuiState.Services.EventManager.Unsubscribe($EventName, $HandlerId)
    }
    Write-Verbose "Unsubscribed from event '$EventName' (Handler ID: $HandlerId)"
}

function Publish-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [hashtable]$EventData = @{}
    )
    
    if ($global:TuiState.Services.EventManager) {
        $global:TuiState.Services.EventManager.Publish($EventName, $EventData)
    }
    Write-Verbose "Published event '$EventName' with data: $($EventData | ConvertTo-Json -Compress)"
}

#endregion

#region Initialize Functions

function Initialize-Logger {
    [CmdletBinding()]
    param()
    
    $logger = [Logger]::new()
    Write-Verbose "Logger initialized at: $($logger.LogPath)"
    return $logger
}

function Initialize-EventManager {
    [CmdletBinding()]
    param()
    
    $eventManager = [EventManager]::new()
    Write-Verbose "EventManager initialized"
    return $eventManager
}

function Initialize-ThemeManager {
    [CmdletBinding()]
    param()
    
    $themeManager = [ThemeManager]::new()
    Write-Verbose "ThemeManager initialized with theme: $($themeManager.ThemeName)"
    return $themeManager
}

function Initialize-ActionService {
    [CmdletBinding()]
    param(
        [EventManager]$EventManager = $null
    )
    
    $actionService = if ($EventManager) {
        [ActionService]::new($EventManager)
    } else {
        [ActionService]::new()
    }
    Write-Verbose "ActionService initialized"
    return $actionService
}

function Initialize-DataManager {
    [CmdletBinding()]
    param(
        [string]$DataPath = (Join-Path $env:APPDATA "AxiomPhoenix\data.json"),
        [EventManager]$EventManager = $null
    )
    
    $dataManager = if ($EventManager) {
        [DataManager]::new($DataPath, $EventManager)
    } else {
        [DataManager]::new($DataPath)
    }
    Write-Verbose "DataManager initialized with path: $($dataManager.DataPath)"
    return $dataManager
}

function Initialize-ServiceContainer {
    [CmdletBinding()]
    param()
    
    $container = [ServiceContainer]::new()
    Write-Verbose "ServiceContainer initialized"
    return $container
}

function Initialize-NavigationService {
    [CmdletBinding()]
    param(
        [EventManager]$EventManager = $null
    )
    
    $navService = if ($EventManager) {
        [NavigationService]::new($EventManager)
    } else {
        [NavigationService]::new()
    }
    Write-Verbose "NavigationService initialized"
    return $navService
}

function Initialize-KeybindingService {
    [CmdletBinding()]
    param(
        [ActionService]$ActionService = $null
    )
    
    $kbService = if ($ActionService) {
        [KeybindingService]::new($ActionService)
    } else {
        [KeybindingService]::new()
    }
    Write-Verbose "KeybindingService initialized"
    return $kbService
}

function Initialize-TuiFrameworkService {
    [CmdletBinding()]
    param()
    
    $framework = [TuiFrameworkService]::new()
    Write-Verbose "TuiFrameworkService initialized"
    return $framework
}

#endregion


####\AllModels.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Models (No UI Dependencies)
# Data models, enums, and validation classes
# ==============================================================================

#region Enums

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

enum BillingType {
    Billable
    NonBillable
}

#endregion

#region Base Validation Class

# ===== CLASS: ValidationBase =====
# Module: models (from axiom)
# Dependencies: None
# Purpose: Provides common validation methods used across model classes
class ValidationBase {
    # Validates that a string value is not null, empty, or whitespace.
    # Throws an ArgumentException if the validation fails.
    static [void] ValidateNotEmpty(
        [string]$value,
        [string]$parameterName
    ) {
        try {
            if ([string]::IsNullOrWhiteSpace($value)) {
                $errorMessage = "Parameter '$($parameterName)' cannot be null or empty."
                throw [System.ArgumentException]::new($errorMessage, $parameterName)
            }
        }
        catch {
            # Re-throw to ensure calling context handles the exception
            throw
        }
    }
}

#endregion

#region Core Model Classes

# ===== CLASS: PmcTask =====
# Module: models (from axiom)
# Dependencies: ValidationBase, TaskStatus, TaskPriority enums
# Purpose: Represents a single task with lifecycle methods
class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString() # Unique identifier for the task
    [string]$Title                            # Short descriptive title
    [string]$Description                      # Detailed description
    [TaskStatus]$Status = [TaskStatus]::Pending # Current status of the task
    [TaskPriority]$Priority = [TaskPriority]::Medium # Importance level
    [string]$ProjectKey = "General"           # Associated project (key)
    [string]$Category                         # Alias for ProjectKey, for broader use
    [datetime]$CreatedAt = [datetime]::Now   # Timestamp of creation
    [datetime]$UpdatedAt = [datetime]::Now   # Last update timestamp
    [Nullable[datetime]]$DueDate             # Optional due date
    [string[]]$Tags = @()                     # Array of tags
    [int]$Progress = 0                        # Progress percentage (0-100)
    [bool]$Completed = $false                 # Convenience flag for completed status

    # Default constructor: Initializes a new task with default values.
    PmcTask() {}
    
    # Constructor: Initializes a new task with a title.
    PmcTask([string]$title) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title
    }
    
    # Constructor: Initializes a new task with common detailed properties.
    PmcTask(
        [string]$title,
        [string]$description,
        [TaskPriority]$priority,
        [string]$projectKey
    ) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")

        $this.Title = $title
        $this.Description = $description
        $this.Priority = $priority
        $this.ProjectKey = $projectKey
        $this.Category = $projectKey # Category is often an alias for ProjectKey
    }

    # Complete: Marks the task as completed, setting progress to 100% and updating timestamp.
    [void] Complete() {
        $this.Status = [TaskStatus]::Completed
        $this.Progress = 100
        $this.Completed = $true
        $this.UpdatedAt = [datetime]::Now
    }
    
    # Cancel: Marks the task as cancelled and updates timestamp.
    [void] Cancel() {
        $this.Status = [TaskStatus]::Cancelled
        $this.UpdatedAt = [datetime]::Now
    }
    
    # SetProgress: Updates the progress percentage and adjusts status accordingly.
    [void] SetProgress([int]$progress) {
        if ($progress -lt 0 -or $progress -gt 100) {
            throw [System.ArgumentOutOfRangeException]::new("progress", "Progress must be between 0 and 100.")
        }
        
        $this.Progress = $progress
        
        # Auto-update status based on progress
        if ($progress -eq 0 -and $this.Status -eq [TaskStatus]::InProgress) {
            $this.Status = [TaskStatus]::Pending
        }
        elseif ($progress -gt 0 -and $progress -lt 100) {
            $this.Status = [TaskStatus]::InProgress
        }
        elseif ($progress -eq 100) {
            $this.Complete()
        }
        
        $this.UpdatedAt = [datetime]::Now
    }
    
    # AddTag: Adds a tag to the task if not already present.
    [void] AddTag([string]$tag) {
        [ValidationBase]::ValidateNotEmpty($tag, "Tag")
        if ($this.Tags -notcontains $tag) {
            $this.Tags += $tag
            $this.UpdatedAt = [datetime]::Now
        }
    }
    
    # RemoveTag: Removes a tag from the task.
    [void] RemoveTag([string]$tag) {
        $this.Tags = $this.Tags | Where-Object { $_ -ne $tag }
        $this.UpdatedAt = [datetime]::Now
    }
    
    # GetAge: Returns the age of the task as a TimeSpan.
    [TimeSpan] GetAge() {
        return [datetime]::Now - $this.CreatedAt
    }
    
    # IsOverdue: Checks if the task is overdue based on DueDate.
    [bool] IsOverdue() {
        if ($null -eq $this.DueDate) { return $false }
        if ($this.Status -in @([TaskStatus]::Completed, [TaskStatus]::Cancelled)) { return $false }
        return [datetime]::Now -gt $this.DueDate
    }
    
    # Clone: Creates a deep copy of the task with a new ID.
    [PmcTask] Clone() {
        $clone = [PmcTask]::new()
        $clone.Title = $this.Title
        $clone.Description = $this.Description
        $clone.Status = $this.Status
        $clone.Priority = $this.Priority
        $clone.ProjectKey = $this.ProjectKey
        $clone.Category = $this.Category
        $clone.DueDate = $this.DueDate
        $clone.Tags = $this.Tags.Clone()
        $clone.Progress = $this.Progress
        $clone.Completed = $this.Completed
        # New task gets new timestamps and ID
        $clone.CreatedAt = [datetime]::Now
        $clone.UpdatedAt = [datetime]::Now
        return $clone
    }
    
    # ToString: Returns a string representation of the task.
    [string] ToString() {
        $statusSymbol = switch ($this.Status) {
            ([TaskStatus]::Pending) { "○" }
            ([TaskStatus]::InProgress) { "◐" }
            ([TaskStatus]::Completed) { "●" }
            ([TaskStatus]::Cancelled) { "✕" }
            default { "?" }
        }
        
        $prioritySymbol = switch ($this.Priority) {
            ([TaskPriority]::Low) { "↓" }
            ([TaskPriority]::Medium) { "→" }
            ([TaskPriority]::High) { "↑" }
            default { "-" }
        }
        
        $overdueFlag = if ($this.IsOverdue()) { " [OVERDUE]" } else { "" }
        
        return "$statusSymbol $prioritySymbol $($this.Title) ($($this.Progress)%)$overdueFlag"
    }
}

# ===== CLASS: PmcProject =====
# Module: models (from axiom)
# Dependencies: ValidationBase
# Purpose: Represents a project that contains multiple tasks
class PmcProject : ValidationBase {
    [string]$Key                              # Unique project key (e.g., "PROJ-001")
    [string]$Name                             # Project name
    [string]$Description                      # Project description
    [DateTime]$CreatedAt = [DateTime]::Now  # Creation timestamp
    [DateTime]$UpdatedAt = [DateTime]::Now  # Last update timestamp
    [string]$Owner                           # Project owner
    [string[]]$Tags = @()                    # Project tags
    [hashtable]$Metadata = @{}               # Additional project metadata
    [bool]$IsActive = $true                  # Whether project is active

    # Default constructor
    PmcProject() {}

    # Constructor with key and name
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key
        $this.Name = $name
    }

    # Constructor with full details
    PmcProject([string]$key, [string]$name, [string]$description, [string]$owner) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        [ValidationBase]::ValidateNotEmpty($owner, "Owner")
        
        $this.Key = $key
        $this.Name = $name
        $this.Description = $description
        $this.Owner = $owner
    }

    # Archive: Marks the project as inactive
    [void] Archive() {
        $this.IsActive = $false
        $this.UpdatedAt = [DateTime]::Now
    }

    # Activate: Marks the project as active
    [void] Activate() {
        $this.IsActive = $true
        $this.UpdatedAt = [DateTime]::Now
    }

    # AddTag: Adds a tag to the project if not already present
    [void] AddTag([string]$tag) {
        [ValidationBase]::ValidateNotEmpty($tag, "Tag")
        if ($this.Tags -notcontains $tag) {
            $this.Tags += $tag
            $this.UpdatedAt = [DateTime]::Now
        }
    }

    # RemoveTag: Removes a tag from the project
    [void] RemoveTag([string]$tag) {
        $this.Tags = $this.Tags | Where-Object { $_ -ne $tag }
        $this.UpdatedAt = [DateTime]::Now
    }

    # SetMetadata: Sets a metadata key-value pair
    [void] SetMetadata([string]$key, $value) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        $this.Metadata[$key] = $value
        $this.UpdatedAt = [DateTime]::Now
    }

    # GetMetadata: Gets a metadata value by key
    [object] GetMetadata([string]$key) {
        return $this.Metadata[$key]
    }

    # ToString: Returns a string representation of the project
    [string] ToString() {
        $status = if ($this.IsActive) { "Active" } else { "Archived" }
        return "[$($this.Key)] $($this.Name) - $status"
    }
}

# ===== CLASS: TimeEntry =====
# Module: models (from axiom)
# Dependencies: ValidationBase, BillingType enum
# Purpose: Represents a time entry for a task
class TimeEntry : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()  # Unique identifier
    [string]$TaskId                              # Associated task ID
    [string]$ProjectKey                          # Associated project key
    [DateTime]$StartTime                         # When work started
    [Nullable[DateTime]]$EndTime                 # When work ended (null if ongoing)
    [string]$Description                         # What was done
    [BillingType]$BillingType = [BillingType]::Billable # Billing classification
    [string]$UserId                              # Who logged the time
    [decimal]$HourlyRate = 0                    # Rate per hour (if applicable)
    [hashtable]$Metadata = @{}                   # Additional metadata

    # Default constructor
    TimeEntry() {}

    # Constructor with basic details
    TimeEntry([string]$taskId, [string]$projectKey, [DateTime]$startTime) {
        [ValidationBase]::ValidateNotEmpty($taskId, "TaskId")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")
        
        $this.TaskId = $taskId
        $this.ProjectKey = $projectKey
        $this.StartTime = $startTime
    }

    # GetDuration: Returns the duration of the time entry
    [TimeSpan] GetDuration() {
        if ($null -eq $this.EndTime) {
            return [DateTime]::Now - $this.StartTime
        }
        return $this.EndTime - $this.StartTime
    }

    # GetHours: Returns the duration in decimal hours
    [decimal] GetHours() {
        return [decimal]($this.GetDuration().TotalHours)
    }

    # GetTotalValue: Returns the monetary value of the time entry
    [decimal] GetTotalValue() {
        if ($this.BillingType -eq [BillingType]::NonBillable) {
            return 0
        }
        return $this.GetHours() * $this.HourlyRate
    }

    # Stop: Stops the timer on this entry
    [void] Stop() {
        if ($null -eq $this.EndTime) {
            $this.EndTime = [DateTime]::Now
        }
    }

    # IsRunning: Checks if the time entry is still running
    [bool] IsRunning() {
        return $null -eq $this.EndTime
    }

    # ToString: Returns a string representation of the time entry
    [string] ToString() {
        $duration = $this.GetDuration()
        $status = if ($this.IsRunning()) { "Running" } else { "Completed" }
        return "$($this.ProjectKey) - $($duration.ToString('hh\:mm\:ss')) [$status]"
    }
}

#endregion

#region Exception Classes

# ===== CLASS: HeliosException =====
# Module: exceptions (from axiom)
# Dependencies: None (inherits from System.Exception)
# Purpose: Base exception for all framework exceptions
class HeliosException : System.Exception {
    [string]$ErrorCode
    [hashtable]$Context = @{}
    [string]$Component
    [DateTime]$Timestamp
    
    HeliosException([string]$message) : base($message) {
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component) : base($message) {
        $this.Component = $component
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component, [hashtable]$context) : base($message) {
        $this.Component = $component
        $this.Context = $context
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $innerException) {
        $this.Component = $component
        $this.Context = $context
        $this.Timestamp = [DateTime]::Now
    }
}

# ===== CLASS: NavigationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for navigation-related errors
class NavigationException : HeliosException {
    NavigationException([string]$message) : base($message) {}
    NavigationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: ServiceInitializationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for service initialization failures
class ServiceInitializationException : HeliosException {
    ServiceInitializationException([string]$message) : base($message) {}
    ServiceInitializationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: ComponentRenderException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for component rendering failures
class ComponentRenderException : HeliosException {
    ComponentRenderException([string]$message) : base($message) {}
    ComponentRenderException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: StateMutationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for state mutation errors
class StateMutationException : HeliosException {
    StateMutationException([string]$message) : base($message) {}
    StateMutationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: InputHandlingException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for input handling errors
class InputHandlingException : HeliosException {
    InputHandlingException([string]$message) : base($message) {}
    InputHandlingException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: DataLoadException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for data loading errors
class DataLoadException : HeliosException {
    DataLoadException([string]$message) : base($message) {}
    DataLoadException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

#endregion

#region Navigation Classes

# ===== CLASS: NavigationItem =====
# Module: navigation-class (from axiom)
# Dependencies: None
# Purpose: Represents a menu item for local/contextual navigation
class NavigationItem {
    [string]$Key
    [string]$Label
    [scriptblock]$Action
    [bool]$Enabled = $true
    [bool]$Visible = $true
    [string]$Description = ""

    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key)) {
            throw [System.ArgumentException]::new("Navigation key cannot be null or empty")
        }
        if ([string]::IsNullOrWhiteSpace($label)) {
            throw [System.ArgumentException]::new("Navigation label cannot be null or empty")
        }
        if (-not $action) {
            throw [System.ArgumentNullException]::new("action", "Navigation action cannot be null")
        }

        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }

    [void] Execute() {
        try {
            if (-not $this.Enabled) {
                return
            }
            
            & $this.Action
        }
        catch {
            throw
        }
    }

    [string] ToString() {
        return "NavigationItem(Key='$($this.Key)', Label='$($this.Label)', Enabled=$($this.Enabled))"
    }
}

#endregion


####\AllRuntime.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Runtime (Load Last)
# TUI engine, screen management, and main application loop
# ==============================================================================

#region Global State

# Initialize global TUI state
$global:TuiState = @{
    Running = $false
    BufferWidth = 0
    BufferHeight = 0
    CompositorBuffer = $null
    PreviousCompositorBuffer = $null
    ScreenStack = @()  # Simple array instead of Stack
    CurrentScreen = $null
    IsDirty = $true
    FocusedComponent = $null
    CommandPalette = $null
    Services = @{}
    LastRenderTime = [datetime]::Now
    FrameCount = 0
    InputQueue = New-Object 'System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]'
    OverlayStack = @()  # Simple array instead of Stack
}

#endregion

#region Engine Management

function Initialize-TuiEngine {
    [CmdletBinding()]
    param()
    
    try {
        Write-Verbose "Initializing TUI Engine..."
        
        # Hide cursor
        [Console]::CursorVisible = $false
        
        # Clear screen
        [Console]::Clear()
        
        # Get initial console size
        $global:TuiState.BufferWidth = [Console]::WindowWidth
        $global:TuiState.BufferHeight = [Console]::WindowHeight
        
        Write-Host "Console size: $($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight)" -ForegroundColor Yellow
        
        # Create compositor buffers
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new(
            $global:TuiState.BufferWidth,
            $global:TuiState.BufferHeight,
            "Compositor"
        )
        
        $global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new(
            $global:TuiState.BufferWidth,
            $global:TuiState.BufferHeight,
            "PreviousCompositor"
        )
        
        Write-Verbose "TUI Engine initialized with buffer size: $($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight)"
    }
    catch {
        Write-Error "Failed to initialize TUI engine: $_"
        throw
    }
}

function Start-TuiEngine {
    [CmdletBinding()]
    param()
    
    try {
        Write-Verbose "Starting TUI Engine main loop..."
        
        $global:TuiState.Running = $true
        $frameTimer = [System.Diagnostics.Stopwatch]::new()
        
        while ($global:TuiState.Running) {
            $frameTimer.Restart()
            
            # Check for resize
            if ([Console]::WindowWidth -ne $global:TuiState.BufferWidth -or 
                [Console]::WindowHeight -ne $global:TuiState.BufferHeight) {
                Update-TuiEngineSize
            }
            
            # Process input
            Process-TuiInput
            
            # Render if dirty
            if ($global:TuiState.IsDirty) {
                Invoke-TuiRender
                $global:TuiState.IsDirty = $false
            }
            
            # Frame timing (target 60 FPS)
            $frameTimer.Stop()
            $frameTime = $frameTimer.ElapsedMilliseconds
            if ($frameTime -lt 16) {
                Start-Sleep -Milliseconds (16 - $frameTime)
            }
            
            $global:TuiState.FrameCount++
        }
        
        Write-Verbose "TUI Engine stopped after $($global:TuiState.FrameCount) frames"
    }
    catch {
        Write-Error "TUI Engine error: $_"
        Invoke-PanicHandler $_
    }
    finally {
        Stop-TuiEngine
    }
}

function Stop-TuiEngine {
    [CmdletBinding()]
    param()
    
    try {
        Write-Verbose "Stopping TUI Engine..."
        
        $global:TuiState.Running = $false
        
        # Cleanup current screen
        if ($global:TuiState.CurrentScreen) {
            try {
                $global:TuiState.CurrentScreen.OnExit()
                $global:TuiState.CurrentScreen.Cleanup()
            }
            catch {
                Write-Warning "Error cleaning up current screen: $_"
            }
        }
        
        # Cleanup services
        foreach ($service in $global:TuiState.Services.Values) {
            if ($service -and $service.PSObject.Methods.Match('Cleanup')) {
                try {
                    $service.Cleanup()
                }
                catch {
                    Write-Warning "Error cleaning up service: $_"
                }
            }
        }
        
        # Restore console
        [Console]::CursorVisible = $true
        [Console]::Clear()
        [Console]::SetCursorPosition(0, 0)
        
        Write-Verbose "TUI Engine stopped and cleaned up"
    }
    catch {
        Write-Error "Error stopping TUI engine: $_"
    }
}

function Update-TuiEngineSize {
    [CmdletBinding()]
    param()
    
    try {
        $newWidth = [Console]::WindowWidth
        $newHeight = [Console]::WindowHeight
        
        Write-Verbose "Console resized from $($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight) to ${newWidth}x${newHeight}"
        
        # Update state
        $global:TuiState.BufferWidth = $newWidth
        $global:TuiState.BufferHeight = $newHeight
        
        # Resize compositor buffers
        $global:TuiState.CompositorBuffer.Resize($newWidth, $newHeight)
        $global:TuiState.PreviousCompositorBuffer.Resize($newWidth, $newHeight)
        
        # Resize current screen
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.Resize($newWidth, $newHeight)
        }
        
        # Force full redraw
        $global:TuiState.IsDirty = $true
        [Console]::Clear()
    }
    catch {
        Write-Error "Failed to update engine size: $_"
    }
}

#endregion

#region Rendering System

function Invoke-TuiRender {
    [CmdletBinding()]
    param()
    
    try {
        $renderTimer = [System.Diagnostics.Stopwatch]::StartNew()
        
        # Clear compositor buffer
        $global:TuiState.CompositorBuffer.Clear()
        
        # Render current screen
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.Render()
            $screenBuffer = $global:TuiState.CurrentScreen.GetBuffer()
            if ($screenBuffer) {
                $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
            }
            
            # Render command palette if visible
            if ($global:TuiState.CommandPalette -and $global:TuiState.CommandPalette.Visible) {
                $global:TuiState.CommandPalette.Render()
                $paletteBuffer = $global:TuiState.CommandPalette.GetBuffer()
                if ($paletteBuffer) {
                    $global:TuiState.CompositorBuffer.BlendBuffer($paletteBuffer, 
                        [Math]::Floor(($global:TuiState.BufferWidth - $global:TuiState.CommandPalette.Width) / 2),
                        [Math]::Floor(($global:TuiState.BufferHeight - $global:TuiState.CommandPalette.Height) / 2)
                    )
                }
            }
            
            # Render overlays
            if ($global:TuiState.ContainsKey('OverlayStack') -and $global:TuiState.OverlayStack -and @($global:TuiState.OverlayStack).Count -gt 0) {
                foreach ($overlay in $global:TuiState.OverlayStack) {
                    if ($overlay -and $overlay.Visible) {
                        $overlay.Render()
                        $overlayBuffer = $overlay.GetBuffer()
                        if ($overlayBuffer) {
                            $global:TuiState.CompositorBuffer.BlendBuffer($overlayBuffer, $overlay.X, $overlay.Y)
                        }
                    }
                }
            }
        }
        
        # Differential rendering
        Render-DifferentialBuffer
        
        # Swap buffers
        $temp = $global:TuiState.PreviousCompositorBuffer
        $global:TuiState.PreviousCompositorBuffer = $global:TuiState.CompositorBuffer
        $global:TuiState.CompositorBuffer = $temp
        
        $renderTimer.Stop()
        
        if ($renderTimer.ElapsedMilliseconds -gt 16) {
            Write-Verbose "Slow frame: $($renderTimer.ElapsedMilliseconds)ms"
        }
    }
    catch {
        Write-Error "Render error: $_"
        throw
    }
}

function Render-DifferentialBuffer {
    [CmdletBinding()]
    param()
    
    try {
        $current = $global:TuiState.CompositorBuffer
        $previous = $global:TuiState.PreviousCompositorBuffer
        
        $ansiBuilder = [System.Text.StringBuilder]::new()
        $lastBgColor = $null
        $lastFgColor = $null
        $lastBold = $false
        $lastUnderline = $false
        $currentX = -1
        $currentY = -1
        
        for ($y = 0; $y -lt $current.Height; $y++) {
            for ($x = 0; $x -lt $current.Width; $x++) {
                $currentCell = $current.GetCell($x, $y)
                $previousCell = $previous.GetCell($x, $y)
                
                if ($currentCell.DiffersFrom($previousCell)) {
                    # Move cursor if needed
                    if ($currentX -ne $x -or $currentY -ne $y) {
                        [void]$ansiBuilder.Append("`e[$($y + 1);$($x + 1)H")
                        $currentX = $x
                        $currentY = $y
                    }
                    
                    # Apply styling if changed
                    if ($currentCell.BackgroundColor -ne $lastBgColor) {
                        [void]$ansiBuilder.Append([TuiAnsiHelper]::GetBackgroundCode($currentCell.BackgroundColor))
                        $lastBgColor = $currentCell.BackgroundColor
                    }
                    
                    if ($currentCell.ForegroundColor -ne $lastFgColor) {
                        [void]$ansiBuilder.Append([TuiAnsiHelper]::GetForegroundCode($currentCell.ForegroundColor))
                        $lastFgColor = $currentCell.ForegroundColor
                    }
                    
                    if ($currentCell.Bold -ne $lastBold) {
                        [void]$ansiBuilder.Append($(if ($currentCell.Bold) { "`e[1m" } else { "`e[22m" }))
                        $lastBold = $currentCell.Bold
                    }
                    
                    if ($currentCell.Underline -ne $lastUnderline) {
                        [void]$ansiBuilder.Append($(if ($currentCell.Underline) { "`e[4m" } else { "`e[24m" }))
                        $lastUnderline = $currentCell.Underline
                    }
                    
                    # Write character
                    [void]$ansiBuilder.Append($currentCell.Char)
                    $currentX++
                    
                    # Copy to previous buffer
                    $previous.SetCell($x, $y, [TuiCell]::new($currentCell))
                }
            }
        }
        
        # Reset styling at end
        if ($ansiBuilder.Length -gt 0) {
            [void]$ansiBuilder.Append("`e[0m")
            [Console]::Write($ansiBuilder.ToString())
        }
    }
    catch {
        Write-Error "Differential rendering error: $_"
        throw
    }
}

#endregion

#region Input Processing

function Process-TuiInput {
    [CmdletBinding()]
    param()
    
    try {
        if ([Console]::KeyAvailable) {
            $keyInfo = [Console]::ReadKey($true)
            
            # Check command palette first
            if ($global:TuiState.CommandPalette -and $global:TuiState.CommandPalette.Visible) {
                $handled = $global:TuiState.CommandPalette.HandleInput($keyInfo)
                if ($handled) {
                    $global:TuiState.IsDirty = $true
                    return
                }
            }
            
            # Check global hotkeys
            if ($global:TuiState.Services.KeybindingService) {
                $action = $global:TuiState.Services.KeybindingService.GetAction($keyInfo)
                
                if ($action) {
                    Write-Verbose "Processing global action: $action"
                    
                    switch ($action) {
                        "app.exit" {
                            $global:TuiState.Running = $false
                            return
                        }
                        "app.commandPalette" {
                            if ($global:TuiState.CommandPalette) {
                                $global:TuiState.CommandPalette.Show()
                                $global:TuiState.IsDirty = $true
                            }
                            return
                        }
                    }
                    
                    # Try to execute via ActionService
                    if ($global:TuiState.Services.ActionService) {
                        try {
                            $global:TuiState.Services.ActionService.ExecuteAction($action)
                            $global:TuiState.IsDirty = $true
                            return
                        }
                        catch {
                            Write-Verbose "Action execution failed: $_"
                        }
                    }
                }
            }
            
            # Pass to current screen
            if ($global:TuiState.CurrentScreen) {
                $global:TuiState.CurrentScreen.HandleInput($keyInfo)
                $global:TuiState.IsDirty = $true
            }
        }
    }
    catch {
        Write-Error "Input processing error: $_"
    }
}

#endregion

#region Screen Management

function Push-Screen {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [Screen]$Screen
    )
    
    try {
        Write-Verbose "Pushing screen: $($Screen.Name)"
        
        # Ensure ScreenStack exists
        if ($null -eq $global:TuiState.ScreenStack) {
            $global:TuiState.ScreenStack = @()
        }
        
        # Exit current screen
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.OnExit()
            $global:TuiState.ScreenStack += $global:TuiState.CurrentScreen
        }
        
        # Initialize and enter new screen
        $global:TuiState.CurrentScreen = $Screen
        
        # Resize screen to match console
        $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
        
        if (-not $Screen._isInitialized) {
            $Screen.Initialize()
            $Screen._isInitialized = $true
        }
        
        $Screen.OnEnter()
        $global:TuiState.IsDirty = $true
    }
    catch {
        Write-Error "Failed to push screen: $_"
        throw
    }
}

function Pop-Screen {
    [CmdletBinding()]
    param()
    
    try {
        # Ensure ScreenStack exists
        if ($null -eq $global:TuiState.ScreenStack) {
            $global:TuiState.ScreenStack = @()
        }
        
        if (@($global:TuiState.ScreenStack).Count -eq 0) {
            Write-Warning "No screens to pop"
            return
        }
        
        Write-Verbose "Popping screen"
        
        # Exit current screen
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.OnExit()
        }
        
        # Resume previous screen
        $previousScreen = $global:TuiState.ScreenStack[-1]
        if (@($global:TuiState.ScreenStack).Count -eq 1) {
            $global:TuiState.ScreenStack = @()
        } else {
            $count = @($global:TuiState.ScreenStack).Count
            $endIndex = $count - 2
            if ($endIndex -ge 0) {
                $global:TuiState.ScreenStack = @($global:TuiState.ScreenStack)[0..$endIndex]
            } else {
                $global:TuiState.ScreenStack = @()
            }
        }
        $global:TuiState.CurrentScreen = $previousScreen
        $previousScreen.OnResume()
        
        $global:TuiState.IsDirty = $true
    }
    catch {
        Write-Error "Failed to pop screen: $_"
        throw
    }
}

function Switch-Screen {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [Screen]$Screen
    )
    
    try {
        Write-Verbose "Switching to screen: $($Screen.Name)"
        
        # Exit current screen without pushing to stack
        if ($global:TuiState.CurrentScreen) {
            $global:TuiState.CurrentScreen.OnExit()
        }
        
        # Initialize and enter new screen
        $global:TuiState.CurrentScreen = $Screen
        
        # Resize screen to match console
        $Screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
        
        if (-not $Screen._isInitialized) {
            $Screen.Initialize()
            $Screen._isInitialized = $true
        }
        
        $Screen.OnEnter()
        $global:TuiState.IsDirty = $true
    }
    catch {
        Write-Error "Failed to switch screen: $_"
        throw
    }
}

#endregion

#region Overlay Management

function Show-TuiOverlay {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [UIElement]$Element
    )
    
    try {
        Write-Verbose "Showing overlay: $($Element.Name)"
        
        # Initialize overlay stack if needed
        if (-not $global:TuiState.ContainsKey('OverlayStack')) {
            $global:TuiState.OverlayStack = @()
        }
        
        # Push to overlay stack
        $global:TuiState.OverlayStack += $Element
        
        # Initialize if needed
        if ($Element -and $Element.PSObject.Methods.Match('Initialize') -and -not $Element._isInitialized) {
            $Element.Initialize()
            $Element._isInitialized = $true
        }
        
        # Enter the overlay
        if ($Element -and $Element.PSObject.Methods.Match('OnEnter')) {
            $Element.OnEnter()
        }
        
        $global:TuiState.IsDirty = $true
    }
    catch {
        Write-Error "Failed to show overlay: $_"
        throw
    }
}

function Close-TopTuiOverlay {
    [CmdletBinding()]
    param()
    
    try {
        if (-not $global:TuiState.ContainsKey('OverlayStack') -or @($global:TuiState.OverlayStack).Count -eq 0) {
            Write-Warning "No overlays to close"
            return
        }
        
        Write-Verbose "Closing top overlay"
        
        # Pop from overlay stack
        $overlay = $global:TuiState.OverlayStack[-1]
        if (@($global:TuiState.OverlayStack).Count -eq 1) {
            $global:TuiState.OverlayStack = @()
        } else {
            $count = @($global:TuiState.OverlayStack).Count
            $endIndex = $count - 2
            if ($endIndex -ge 0) {
                $global:TuiState.OverlayStack = @($global:TuiState.OverlayStack)[0..$endIndex]
            } else {
                $global:TuiState.OverlayStack = @()
            }
        }
        
        # Exit the overlay
        if ($overlay -and $overlay.PSObject.Methods.Match('OnExit')) {
            $overlay.OnExit()
        }
        
        # Cleanup if disposable
        if ($overlay -and $overlay.PSObject.Methods.Match('Cleanup')) {
            $overlay.Cleanup()
        }
        
        $global:TuiState.IsDirty = $true
    }
    catch {
        Write-Error "Failed to close overlay: $_"
        throw
    }
}

#endregion

#region Error Handling

function Invoke-PanicHandler {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [object]$Error
    )
    
    try {
        Write-Host "`n`n=== AXIOM-PHOENIX PANIC HANDLER ===" -ForegroundColor Red
        Write-Host "A critical error has occurred!" -ForegroundColor Red
        Write-Host ""
        
        # Error details
        Write-Host "Error Message:" -ForegroundColor Yellow
        Write-Host "  $($Error.Exception.Message)" -ForegroundColor White
        Write-Host ""
        
        Write-Host "Error Type:" -ForegroundColor Yellow
        Write-Host "  $($Error.Exception.GetType().FullName)" -ForegroundColor White
        Write-Host ""
        
        Write-Host "Stack Trace:" -ForegroundColor Yellow
        $Error.ScriptStackTrace -split "`n" | ForEach-Object {
            Write-Host "  $_" -ForegroundColor Gray
        }
        Write-Host ""
        
        # System info
        Write-Host "System Information:" -ForegroundColor Yellow
        Write-Host "  PowerShell: $($PSVersionTable.PSVersion)" -ForegroundColor Gray
        Write-Host "  OS: $([System.Environment]::OSVersion.VersionString)" -ForegroundColor Gray
        Write-Host "  Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" -ForegroundColor Gray
        Write-Host ""
        
        # Crash report location
        $crashReportPath = Join-Path $env:TEMP "axiom-phoenix-crash-$(Get-Date -Format 'yyyyMMdd-HHmmss').txt"
        
        $crashReport = @"
AXIOM-PHOENIX CRASH REPORT
Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')

ERROR DETAILS:
$($Error | Out-String)

SYSTEM INFORMATION:
PowerShell Version: $($PSVersionTable.PSVersion)
OS Version: $([System.Environment]::OSVersion.VersionString)
CLR Version: $($PSVersionTable.CLRVersion)
Host: $($Host.Name)

GLOBAL STATE:
$($global:TuiState | ConvertTo-Json -Depth 3)
"@
        
        $crashReport | Out-File -FilePath $crashReportPath -Force
        
        Write-Host "Crash report saved to:" -ForegroundColor Yellow
        Write-Host "  $crashReportPath" -ForegroundColor Cyan
        Write-Host ""
        
        Write-Host "Press any key to exit..." -ForegroundColor White
        [Console]::ReadKey($true) | Out-Null
    }
    catch {
        Write-Host "FATAL: Panic handler failed!" -ForegroundColor Magenta
        Write-Host $_.Exception.Message -ForegroundColor Red
    }
    finally {
        # Try to restore console
        try {
            [Console]::CursorVisible = $true
            [Console]::Clear()
        }
        catch {}
        
        # Exit
        exit 1
    }
}

#endregion

#region Application Entry

function Start-AxiomPhoenix {
    [CmdletBinding()]
    param(
        [ServiceContainer]$ServiceContainer,
        [Screen]$InitialScreen
    )
    
    try {
        Write-Verbose "Starting Axiom-Phoenix application..."
        
        # Store services
        $global:TuiState.Services = @{
            ServiceContainer = $ServiceContainer
        }
        
        # Extract key services for quick access
        $serviceNames = @(
            'ActionService', 'KeybindingService', 'NavigationService', 
            'DataManager', 'ThemeManager', 'EventManager', 'Logger'
        )
        
        foreach ($serviceName in $serviceNames) {
            try {
                $service = $ServiceContainer.GetService($serviceName)
                if ($service) {
                    $global:TuiState.Services[$serviceName] = $service
                }
            }
            catch {
                Write-Warning "Failed to get service '$serviceName': $_"
            }
        }
        
        # Create command palette if available
        $actionService = $ServiceContainer.GetService("ActionService")
        if ($actionService) {
            $global:TuiState.CommandPalette = [CommandPalette]::new("GlobalCommandPalette", $actionService)
            $global:TuiState.CommandPalette.RefreshActions()
        }
        
        # Initialize engine
        Initialize-TuiEngine
        
        # Verify ScreenStack still exists after engine init
        if ($null -eq $global:TuiState.ScreenStack) {
            $global:TuiState.ScreenStack = @()
        }
        
        # Set initial screen
        if ($InitialScreen) {
            Push-Screen -Screen $InitialScreen
        }
        else {
            Write-Warning "No initial screen provided"
        }
        
        # Start main loop
        Start-TuiEngine
    }
    catch {
        Write-Error "Application startup failed: $_"
        Write-Error "Error occurred at: $($_.InvocationInfo.ScriptLineNumber) in $($_.InvocationInfo.ScriptName)"
        Write-Error "Statement: $($_.InvocationInfo.Line)"
        Invoke-PanicHandler $_
    }
    finally {
        Stop-TuiEngine
    }
}

#endregion


####\AllScreens.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Screens (Load After Components)
# Application screens that extend Screen base class
# ==============================================================================

using namespace System.Collections.Generic

#region Screen Classes

class DashboardScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [Panel] $_summaryPanel
    hidden [Panel] $_statusPanel
    hidden [Panel] $_helpPanel
    #endregion

    #region State
    hidden [int] $_totalTasks = 0
    hidden [int] $_completedTasks = 0
    hidden [int] $_pendingTasks = 0
    #endregion

    DashboardScreen([object]$serviceContainer) : base("DashboardScreen", $serviceContainer) {}

    [void] Initialize() {
        Write-Host "DashboardScreen.Initialize called. Screen size: $($this.Width)x$($this.Height)" -ForegroundColor Green
        
        if (-not $this.ServiceContainer) {
            Write-Warning "DashboardScreen.Initialize: ServiceContainer is null"
            return
        }
        
        $this._mainPanel = [Panel]::new("Axiom-Phoenix Dashboard")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = "Axiom-Phoenix Dashboard"
        $this.AddChild($this._mainPanel)

        $summaryWidth = [Math]::Floor($this.Width * 0.5)
        $this._summaryPanel = [Panel]::new("Task Summary")
        $this._summaryPanel.X = 1
        $this._summaryPanel.Y = 1
        $this._summaryPanel.Width = $summaryWidth
        $this._summaryPanel.Height = 12
        $this._summaryPanel.Title = "Task Summary"
        $this._mainPanel.AddChild($this._summaryPanel)

        $helpX = $summaryWidth + 2
        $helpWidth = $this.Width - $helpX - 1
        $this._helpPanel = [Panel]::new("Quick Start")
        $this._helpPanel.X = $helpX
        $this._helpPanel.Y = 1
        $this._helpPanel.Width = $helpWidth
        $this._helpPanel.Height = 12
        $this._helpPanel.Title = "Quick Start"
        $this._mainPanel.AddChild($this._helpPanel)

        $this._statusPanel = [Panel]::new("System Status")
        $this._statusPanel.X = 1
        $this._statusPanel.Y = 14
        $this._statusPanel.Width = $this.Width - 2
        $this._statusPanel.Height = $this.Height - 15
        $this._statusPanel.Title = "System Status"
        $this._mainPanel.AddChild($this._statusPanel)
    }

    [void] OnEnter() {
        # Force a complete redraw of all panels
        if ($this._summaryPanel) { $this._summaryPanel.RequestRedraw() }
        if ($this._helpPanel) { $this._helpPanel.RequestRedraw() }
        if ($this._statusPanel) { $this._statusPanel.RequestRedraw() }
        if ($this._mainPanel) { $this._mainPanel.RequestRedraw() }
        
        if ($this.ServiceContainer) {
            $this._RefreshData($this.ServiceContainer.GetService("DataManager"))
        } else {
            Write-Warning "DashboardScreen.OnEnter: ServiceContainer is null, using defaults"
            $this._RefreshData($null)
        }
        
        # Force another redraw after data refresh
        $this.RequestRedraw()
    }

    hidden [void] _RefreshData([object]$dataManager) {
        if(-not $dataManager) {
            Write-Warning "DashboardScreen: DataManager service not found."
            $this._totalTasks = 0
            $this._completedTasks = 0
            $this._pendingTasks = 0
        } else {
            $allTasks = $dataManager.GetTasks()
            if ($allTasks) {
                $this._totalTasks = @($allTasks).Count
                $this._completedTasks = @($allTasks | Where-Object { $_.Completed }).Count
                $this._pendingTasks = $this._totalTasks - $this._completedTasks
            } else {
                $this._totalTasks = 0
                $this._completedTasks = 0
                $this._pendingTasks = 0
            }
        }
        $this._UpdateDisplay()
    }
    
    hidden [void] _UpdateDisplay() {
        $this._UpdateSummaryPanel()
        $this._UpdateHelpPanel()
        $this._UpdateStatusPanel()
        $this.RequestRedraw()
    }
    
    hidden [void] _UpdateSummaryPanel() {
        $panel = $this._summaryPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()

        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY

        # Simple text rendering using buffer
        $buffer.WriteString($contentX + 1, $contentY, "Task Overview", [ConsoleColor]::Cyan, [ConsoleColor]::Black)
        $lineWidth = [Math]::Max(0, $panel.ContentWidth - 2)
        if ($lineWidth -gt 0) {
            $buffer.WriteString($contentX + 1, $contentY + 1, ('─' * $lineWidth), [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
        }
        
        $buffer.WriteString($contentX + 1, $contentY + 3, "Total Tasks:    $($this._totalTasks)", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 4, "Completed:      $($this._completedTasks)", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 5, "Pending:        $($this._pendingTasks)", [ConsoleColor]::White, [ConsoleColor]::Black)
        
        $progress = $this._GetProgressBar()
        $buffer.WriteString($contentX + 1, $contentY + 7, "Overall Progress:", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 8, $progress, [ConsoleColor]::Yellow, [ConsoleColor]::Black)
        
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateHelpPanel() {
        $panel = $this._helpPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        $paletteHotkey = "Ctrl+P"
        
        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY
        
        $buffer.WriteString($contentX + 1, $contentY + 0, "Welcome to Axiom-Phoenix!", [ConsoleColor]::Cyan, [ConsoleColor]::Black)
        $lineWidth = [Math]::Max(0, $panel.ContentWidth - 2)
        if ($lineWidth -gt 0) {
            $buffer.WriteString($contentX + 1, $contentY + 1, ('─' * $lineWidth), [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
        }
        
        $buffer.WriteString($contentX + 1, $contentY + 3, "Press ", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 7, $contentY + 3, $paletteHotkey, [ConsoleColor]::Yellow, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 7 + $paletteHotkey.Length, $contentY + 3, " to open the", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 4, "Command Palette.", [ConsoleColor]::White, [ConsoleColor]::Black)

        $buffer.WriteString($contentX + 1, $contentY + 6, "All navigation and actions are", [ConsoleColor]::Gray, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 7, "now available from there.", [ConsoleColor]::Gray, [ConsoleColor]::Black)
        
        $panel.RequestRedraw()
    }
    
    hidden [void] _UpdateStatusPanel() {
        $panel = $this._statusPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()

        $memoryMB = try { [Math]::Round((Get-Process -Id $global:PID).WorkingSet64 / 1MB, 2) } catch { 0 }

        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY
        
        $buffer.WriteString($contentX + 1, $contentY, "Environment", [ConsoleColor]::Cyan, [ConsoleColor]::Black)
        $lineWidth = [Math]::Max(0, $panel.ContentWidth - 2)
        if ($lineWidth -gt 0) {
            $buffer.WriteString($contentX + 1, $contentY + 1, ('─' * $lineWidth), [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
        }
        
        $buffer.WriteString($contentX + 1, $contentY + 3, "PowerShell Version: $($global:PSVersionTable.PSVersion)", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 4, "Memory Usage: ${memoryMB} MB", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $contentY + 5, "Host: $($global:Host.Name)", [ConsoleColor]::White, [ConsoleColor]::Black)
        
        $panel.RequestRedraw()
    }
    
    hidden [string] _GetProgressBar() {
        if ($this._totalTasks -eq 0) { return "[No Tasks]" }
        $percentage = [Math]::Round(($this._completedTasks / $this._totalTasks) * 100)
        $barWidth = 20
        $filled = [Math]::Max(0, [Math]::Floor($barWidth * ($percentage / 100)))
        $empty = [Math]::Max(0, $barWidth - $filled)
        $filledBar = if ($filled -gt 0) { '█' * $filled } else { '' }
        $emptyBar = if ($empty -gt 0) { '░' * $empty } else { '' }
        return "[" + $filledBar + $emptyBar + "] $percentage%"
    }

    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Dashboard doesn't handle specific input - all navigation via command palette
        # Input not handled
    }
}

class TaskListScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [ScrollablePanel] $_taskListPanel
    hidden [Panel] $_detailPanel
    hidden [Panel] $_statusBar
    #endregion

    #region State
    hidden [System.Collections.Generic.List[PmcTask]] $_tasks
    hidden [int] $_selectedIndex = 0
    hidden [PmcTask] $_selectedTask
    hidden [string] $_filterText = ""
    hidden [TaskStatus] $_filterStatus = $null
    hidden [TaskPriority] $_filterPriority = $null
    #endregion

    TaskListScreen([object]$serviceContainer) : base("TaskListScreen", $serviceContainer) {}

    [void] Initialize() {
        if (-not $this.ServiceContainer) {
            Write-Warning "TaskListScreen.Initialize: ServiceContainer is null"
            return
        }
        
        $this._mainPanel = [Panel]::new("Task List")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = "Task List"
        $this.AddChild($this._mainPanel)

        # Task list panel (left side)
        $listWidth = [Math]::Floor($this.Width * 0.6)
        $this._taskListPanel = [ScrollablePanel]::new("Tasks")
        $this._taskListPanel.X = 1
        $this._taskListPanel.Y = 1
        $this._taskListPanel.Width = $listWidth
        $this._taskListPanel.Height = $this.Height - 4
        $this._taskListPanel.Title = "Tasks"
        $this._mainPanel.AddChild($this._taskListPanel)

        # Detail panel (right side)
        $detailX = $listWidth + 2
        $detailWidth = $this.Width - $detailX - 1
        $this._detailPanel = [Panel]::new("Task Details")
        $this._detailPanel.X = $detailX
        $this._detailPanel.Y = 1
        $this._detailPanel.Width = $detailWidth
        $this._detailPanel.Height = $this.Height - 4
        $this._detailPanel.Title = "Task Details"
        $this._mainPanel.AddChild($this._detailPanel)

        # Status bar
        $this._statusBar = [Panel]::new("StatusBar")
        $this._statusBar.X = 1
        $this._statusBar.Y = $this.Height - 2
        $this._statusBar.Width = $this.Width - 2
        $this._statusBar.Height = 1
        $this._statusBar.HasBorder = $false
        $this._mainPanel.AddChild($this._statusBar)
        
        $this._tasks = [System.Collections.Generic.List[PmcTask]]::new()
    }

    [void] OnEnter() {
        if ($this.ServiceContainer) {
            $this._RefreshTasks()
        }
        
        $this.RequestRedraw()
    }

    hidden [void] _RefreshTasks() {
        $dataManager = $this.ServiceContainer.GetService("DataManager")
        if (-not $dataManager) {
            Write-Warning "TaskListScreen: DataManager service not found"
            return
        }
        
        $allTasks = $dataManager.GetTasks()
        $this._tasks.Clear()
        if ($allTasks -and $allTasks.Count -gt 0) {
            $this._tasks.AddRange($allTasks)
        }
        
        # Apply filters if any
        if (-not [string]::IsNullOrEmpty($this._filterText)) {
            $filtered = $this._tasks | Where-Object { 
                $_.Title -like "*$($this._filterText)*" -or 
                $_.Description -like "*$($this._filterText)*" 
            }
            $this._tasks.Clear()
            if ($filtered) {
                $this._tasks.AddRange(@($filtered))
            }
        }
        
        if ($null -ne $this._filterStatus) {
            $filtered = $this._tasks | Where-Object { $_.Status -eq $this._filterStatus }
            $this._tasks.Clear()
            if ($filtered) {
                $this._tasks.AddRange(@($filtered))
            }
        }
        
        if ($null -ne $this._filterPriority) {
            $filtered = $this._tasks | Where-Object { $_.Priority -eq $this._filterPriority }
            $this._tasks.Clear()
            if ($filtered) {
                $this._tasks.AddRange(@($filtered))
            }
        }
        
        # Update selection
        if ($this._selectedIndex -ge @($this._tasks).Count) {
            $this._selectedIndex = [Math]::Max(0, @($this._tasks).Count - 1)
        }
        
        if ($this._tasks.Count -gt 0) {
            $this._selectedTask = $this._tasks[$this._selectedIndex]
        } else {
            $this._selectedTask = $null
        }
        
        $this._UpdateDisplay()
    }

    hidden [void] _UpdateDisplay() {
        $this._UpdateTaskList()
        $this._UpdateDetailPanel()
        $this._UpdateStatusBar()
        $this.RequestRedraw()
    }

    hidden [void] _UpdateTaskList() {
        $panel = $this._taskListPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY
        $contentHeight = $panel.ContentHeight
        
        if ($this._tasks.Count -eq 0) {
            $buffer.WriteString($contentX + 2, $contentY + 2, "No tasks found.", [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
            return
        }
        
        # Render tasks
        $startIndex = $panel.ScrollOffsetY
        $endIndex = [Math]::Min($startIndex + $contentHeight, $this._tasks.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $task = $this._tasks[$i]
            $y = $contentY + ($i - $startIndex)
            
            # Highlight selected task
            $bgColor = if ($i -eq $this._selectedIndex) { [ConsoleColor]::DarkGray } else { [ConsoleColor]::Black }
            $fgColor = if ($i -eq $this._selectedIndex) { [ConsoleColor]::White } else { [ConsoleColor]::Gray }
            
            # Status indicator
            $statusChar = switch ($task.Status) {
                ([TaskStatus]::Pending) { "○" }
                ([TaskStatus]::InProgress) { "◐" }
                ([TaskStatus]::Completed) { "●" }
                ([TaskStatus]::Cancelled) { "✕" }
                default { "?" }
            }
            
            # Priority indicator
            $priorityChar = switch ($task.Priority) {
                ([TaskPriority]::Low) { "↓" }
                ([TaskPriority]::Medium) { "→" }
                ([TaskPriority]::High) { "↑" }
                default { "-" }
            }
            
            # Truncate title if needed
            $maxTitleLength = $panel.ContentWidth - 10
            $title = if ($task.Title.Length -gt $maxTitleLength) {
                $task.Title.Substring(0, $maxTitleLength - 3) + "..."
            } else {
                $task.Title
            }
            
            $taskLine = "$statusChar $priorityChar $title"
            
            # Fill entire line with background color
            for ($x = 0; $x -lt $panel.ContentWidth; $x++) {
                $buffer.SetCell($contentX + $x, $y, [TuiCell]::new(' ', $fgColor, $bgColor))
            }
            
            $buffer.WriteString($contentX + 1, $y, $taskLine, $fgColor, $bgColor)
        }
        
        # Update scrollbar
        $panel.UpdateMaxScroll()
    }

    hidden [void] _UpdateDetailPanel() {
        $panel = $this._detailPanel
        if (-not $panel -or -not $this._selectedTask) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        $task = $this._selectedTask
        $buffer = $panel.GetBuffer()
        $contentX = $panel.ContentX
        $contentY = $panel.ContentY
        
        # Task details
        $y = $contentY
        $buffer.WriteString($contentX + 1, $y++, "Title: $($task.Title)", [ConsoleColor]::White, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $y++, "Status: $($task.Status)", [ConsoleColor]::Cyan, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $y++, "Priority: $($task.Priority)", [ConsoleColor]::Yellow, [ConsoleColor]::Black)
        $buffer.WriteString($contentX + 1, $y++, "Progress: $($task.Progress)%", [ConsoleColor]::Green, [ConsoleColor]::Black)
        
        $y++
        $buffer.WriteString($contentX + 1, $y++, "Description:", [ConsoleColor]::Gray, [ConsoleColor]::Black)
        
        if (-not [string]::IsNullOrEmpty($task.Description)) {
            # Word wrap description
            $words = $task.Description -split '\s+'
            $line = ""
            $maxLineLength = $panel.ContentWidth - 2
            
            foreach ($word in $words) {
                if (($line + " " + $word).Length -gt $maxLineLength) {
                    if ($line) {
                        $buffer.WriteString($contentX + 1, $y++, $line, [ConsoleColor]::White, [ConsoleColor]::Black)
                    }
                    $line = $word
                } else {
                    $line = if ($line) { "$line $word" } else { $word }
                }
            }
            
            if ($line) {
                $buffer.WriteString($contentX + 1, $y++, $line, [ConsoleColor]::White, [ConsoleColor]::Black)
            }
        } else {
            $buffer.WriteString($contentX + 1, $y++, "(No description)", [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
        }
        
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateStatusBar() {
        $panel = $this._statusBar
        if (-not $panel) { return }
        
        $buffer = $panel.GetBuffer()
        
        $statusText = "Tasks: $($this._tasks.Count) | Selected: $($this._selectedIndex + 1)"
        if ($this._filterText) {
            $statusText += " | Filter: '$($this._filterText)'"
        }
        
        $buffer.WriteString(0, 0, $statusText, [ConsoleColor]::White, [ConsoleColor]::Black)
        
        # Keyboard hints
        $hints = "↑↓: Navigate | Enter: Edit | D: Delete | N: New"
        $hintsX = $this.Width - $hints.Length - 3
        if ($hintsX -gt $statusText.Length + 2) {
            $buffer.WriteString($hintsX, 0, $hints, [ConsoleColor]::DarkGray, [ConsoleColor]::Black)
        }
        
        $panel.RequestRedraw()
    }

    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this._selectedIndex -gt 0) {
                    $this._selectedIndex--
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                    
                    # Adjust scroll if needed
                    if ($this._selectedIndex -lt $this._taskListPanel.ScrollOffsetY) {
                        $this._taskListPanel.ScrollUp()
                    }
                    
                    $this._UpdateDisplay()
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this._selectedIndex -lt $this._tasks.Count - 1) {
                    $this._selectedIndex++
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                    
                    # Adjust scroll if needed
                    $visibleEnd = $this._taskListPanel.ScrollOffsetY + $this._taskListPanel.ContentHeight - 1
                    if ($this._selectedIndex -gt $visibleEnd) {
                        $this._taskListPanel.ScrollDown()
                    }
                    
                    $this._UpdateDisplay()
                }
            }
            ([ConsoleKey]::PageUp) {
                $this._taskListPanel.ScrollUp($this._taskListPanel.ContentHeight)
                $this._selectedIndex = [Math]::Max(0, $this._selectedIndex - $this._taskListPanel.ContentHeight)
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::PageDown) {
                $this._taskListPanel.ScrollDown($this._taskListPanel.ContentHeight)
                $this._selectedIndex = [Math]::Min($this._tasks.Count - 1, $this._selectedIndex + $this._taskListPanel.ContentHeight)
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::Home) {
                $this._taskListPanel.ScrollToTop()
                $this._selectedIndex = 0
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::End) {
                $this._taskListPanel.ScrollToBottom()
                $this._selectedIndex = $this._tasks.Count - 1
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::Enter) {
                # Edit task - would trigger command palette or dialog
                Write-Verbose "TaskListScreen: Edit task requested for: $($this._selectedTask.Title)"
            }
            ([ConsoleKey]::D) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    # Delete task
                    Write-Verbose "TaskListScreen: Delete task requested for: $($this._selectedTask.Title)"
                }
            }
            ([ConsoleKey]::N) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    # New task
                    Write-Verbose "TaskListScreen: New task requested"
                }
            }
            default {
                # Unhandled key
            }
        }
    }
}

#endregion


####\AllServices.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================

#region Service Classes

# ===== CLASS: ActionService =====
# Module: action-service (from axiom)
# Dependencies: EventManager (optional)
# Purpose: Central command registry and execution service
class ActionService {
    [hashtable]$ActionRegistry = @{}
    [hashtable]$EventSubscriptions = @{}
    [object]$EventManager = $null
    
    ActionService() {
        Write-Verbose "ActionService: Initialized with empty registry"
    }
    
    ActionService([object]$eventManager) {
        $this.EventManager = $eventManager
        Write-Verbose "ActionService: Initialized with EventManager integration"
    }
    
    [void] RegisterAction([string]$actionName, [scriptblock]$action, [hashtable]$metadata = @{}) {
        try {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw "Action name cannot be null or empty"
            }
            if (-not $action) {
                throw "Action scriptblock cannot be null"
            }
            
            $actionData = @{
                Name = $actionName
                Action = $action
                Category = if ($metadata.ContainsKey('Category')) { $metadata.Category } else { "General" }
                Description = if ($metadata.ContainsKey('Description')) { $metadata.Description } else { "" }
                Hotkey = if ($metadata.ContainsKey('Hotkey')) { $metadata.Hotkey } else { "" }
                RegisteredAt = [datetime]::Now
                ExecutionCount = 0
                LastExecuted = $null
                Metadata = $metadata
            }
            
            $this.ActionRegistry[$actionName] = $actionData
            
            # Publish event if EventManager available
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Registered", @{
                    ActionName = $actionName
                    Category = $actionData.Category
                })
            }
            
            Write-Verbose "ActionService: Registered action '$actionName' in category '$($actionData.Category)'"
        }
        catch {
            Write-Error "Failed to register action '$actionName': $_"
            throw
        }
    }
    
    [void] UnregisterAction([string]$actionName) {
        if ($this.ActionRegistry.ContainsKey($actionName)) {
            $this.ActionRegistry.Remove($actionName)
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Unregistered", @{
                    ActionName = $actionName
                })
            }
            
            Write-Verbose "ActionService: Unregistered action '$actionName'"
        }
    }
    
    [object] ExecuteAction([string]$actionName, [hashtable]$parameters = @{}) {
        try {
            if (-not $this.ActionRegistry.ContainsKey($actionName)) {
                throw "Action '$actionName' not found in registry"
            }
            
            $actionData = $this.ActionRegistry[$actionName]
            
            # Update execution metadata
            $actionData.ExecutionCount++
            $actionData.LastExecuted = [datetime]::Now
            
            Write-Verbose "ActionService: Executing action '$actionName' with $($parameters.Count) parameters"
            
            # Execute the action
            $result = & $actionData.Action @parameters
            
            # Publish execution event
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Executed", @{
                    ActionName = $actionName
                    Parameters = $parameters
                    Success = $true
                })
            }
            
            return $result
        }
        catch {
            Write-Error "Failed to execute action '$actionName': $_"
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Executed", @{
                    ActionName = $actionName
                    Parameters = $parameters
                    Success = $false
                    Error = $_.ToString()
                })
            }
            
            throw
        }
    }
    
    [hashtable] GetAction([string]$actionName) {
        return $this.ActionRegistry[$actionName]
    }
    
    [hashtable] GetAllActions() {
        return $this.ActionRegistry
    }
    
    [hashtable[]] GetActionsByCategory([string]$category) {
        return @($this.ActionRegistry.Values | Where-Object { $_.Category -eq $category })
    }
    
    [void] RegisterDefaultActions() {
        # Register built-in actions
        $this.RegisterAction("app.exit", {
            Write-Verbose "Executing app.exit action"
            $global:TuiState.Running = $false
        }, @{
            Category = "Application"
            Description = "Exit the application"
            Hotkey = "Ctrl+Q"
        })
        
        $this.RegisterAction("app.help", {
            Write-Verbose "Executing app.help action"
            # Would show help screen
        }, @{
            Category = "Application"
            Description = "Show help"
            Hotkey = "F1"
        })
        
        Write-Verbose "ActionService: Registered default actions"
    }
}

# ===== CLASS: KeybindingService =====
# Module: keybinding-service (from axiom)
# Dependencies: ActionService (optional)
# Purpose: Global keyboard shortcut management
class KeybindingService {
    [hashtable]$KeyMap = @{}
    [hashtable]$GlobalHandlers = @{}
    [System.Collections.Generic.Stack[hashtable]]$ContextStack
    [ActionService]$ActionService
    [bool]$EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.Stack[hashtable]]::new()
        $this._InitializeDefaultBindings()
    }
    
    KeybindingService([ActionService]$actionService) {
        $this.ActionService = $actionService
        $this.ContextStack = [System.Collections.Generic.Stack[hashtable]]::new()
        $this._InitializeDefaultBindings()
    }
    
    hidden [void] _InitializeDefaultBindings() {
        # Default global bindings
        $this.SetBinding("Ctrl+Q", "app.exit", "Global")
        $this.SetBinding("F1", "app.help", "Global")
        $this.SetBinding("Ctrl+P", "app.commandPalette", "Global")
        
        # Navigation bindings
        $this.SetBinding("Tab", "navigation.nextComponent", "Global")
        $this.SetBinding("Shift+Tab", "navigation.previousComponent", "Global")
        
        # Arrow keys
        $this.SetBinding("UpArrow", "navigation.up", "Global")
        $this.SetBinding("DownArrow", "navigation.down", "Global")
        $this.SetBinding("LeftArrow", "navigation.left", "Global")
        $this.SetBinding("RightArrow", "navigation.right", "Global")
        
        Write-Verbose "KeybindingService: Initialized default keybindings"
    }
    
    [void] SetBinding([string]$keyPattern, [string]$actionName, [string]$context = "Global") {
        if (-not $this.KeyMap.ContainsKey($context)) {
            $this.KeyMap[$context] = @{}
        }
        
        $this.KeyMap[$context][$keyPattern] = $actionName
        Write-Verbose "KeybindingService: Bound '$keyPattern' to '$actionName' in context '$context'"
    }
    
    [void] RemoveBinding([string]$keyPattern, [string]$context = "Global") {
        if ($this.KeyMap.ContainsKey($context)) {
            $this.KeyMap[$context].Remove($keyPattern)
            Write-Verbose "KeybindingService: Removed binding for '$keyPattern' in context '$context'"
        }
    }
    
    [bool] IsAction([System.ConsoleKeyInfo]$keyInfo, [string]$actionName) {
        $keyPattern = $this._GetKeyPattern($keyInfo)
        
        # Check current context stack
        foreach ($context in $this.ContextStack) {
            if ($context.ContainsKey($keyPattern) -and $context[$keyPattern] -eq $actionName) {
                return $true
            }
        }
        
        # Check global context
        if ($this.KeyMap.ContainsKey("Global") -and 
            $this.KeyMap["Global"].ContainsKey($keyPattern) -and
            $this.KeyMap["Global"][$keyPattern] -eq $actionName) {
            return $true
        }
        
        return $false
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        $keyPattern = $this._GetKeyPattern($keyInfo)
        
        # Check current context stack (most recent first)
        foreach ($context in $this.ContextStack) {
            if ($context.ContainsKey($keyPattern)) {
                return $context[$keyPattern]
            }
        }
        
        # Check global context
        if ($this.KeyMap.ContainsKey("Global") -and $this.KeyMap["Global"].ContainsKey($keyPattern)) {
            return $this.KeyMap["Global"][$keyPattern]
        }
        
        return $null
    }
    
    [string] GetBindingDescription([System.ConsoleKeyInfo]$keyInfo) {
        $action = $this.GetAction($keyInfo)
        if ($action -and $this.ActionService) {
            $actionData = $this.ActionService.GetAction($action)
            if ($actionData) {
                return $actionData.Description
            }
        }
        return $null
    }
    
    hidden [string] _GetKeyPattern([System.ConsoleKeyInfo]$keyInfo) {
        $parts = @()
        
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) {
            $parts += "Ctrl"
        }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) {
            $parts += "Alt"
        }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) {
            $parts += "Shift"
        }
        
        $parts += $keyInfo.Key.ToString()
        
        return $parts -join "+"
    }
    
    [void] PushContext([hashtable]$contextBindings) {
        $this.ContextStack.Push($contextBindings)
        Write-Verbose "KeybindingService: Pushed new context with $($contextBindings.Count) bindings"
    }
    
    [void] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $removed = $this.ContextStack.Pop()
            Write-Verbose "KeybindingService: Popped context with $($removed.Count) bindings"
        }
    }
    
    [void] RegisterGlobalHandler([string]$handlerId, [scriptblock]$handler) {
        $this.GlobalHandlers[$handlerId] = $handler
        Write-Verbose "KeybindingService: Registered global handler '$handlerId'"
    }
    
    [void] UnregisterGlobalHandler([string]$handlerId) {
        $this.GlobalHandlers.Remove($handlerId)
        Write-Verbose "KeybindingService: Unregistered global handler '$handlerId'"
    }
}

# ===== CLASS: DataManager =====
# Module: data-manager (from axiom)
# Dependencies: EventManager (optional), PmcTask, PmcProject
# Purpose: High-performance data management with transactions
class DataManager {
    [hashtable]$Tasks = @{}
    [hashtable]$Projects = @{}
    [hashtable]$TasksByProject = @{}
    [string]$DataPath
    [EventManager]$EventManager
    [bool]$IsDirty = $false
    [bool]$AutoSave = $true
    [int]$BatchUpdateCount = 0
    [datetime]$LastSave = [datetime]::Now
    [hashtable]$Metadata = @{}
    [int]$MaxBackups = 5
    
    DataManager() {
        $this.DataPath = Join-Path $env:APPDATA "AxiomPhoenix\data.json"
        $this._Initialize()
    }
    
    DataManager([string]$dataPath) {
        $this.DataPath = $dataPath
        $this._Initialize()
    }
    
    DataManager([string]$dataPath, [EventManager]$eventManager) {
        $this.DataPath = $dataPath
        $this.EventManager = $eventManager
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $dataDir = Split-Path -Parent $this.DataPath
        if (-not (Test-Path $dataDir)) {
            New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
        }
        
        Write-Verbose "DataManager: Initialized with data path: $($this.DataPath)"
    }
    
    [void] LoadData() {
        try {
            if (Test-Path $this.DataPath) {
                $jsonContent = Get-Content -Path $this.DataPath -Raw
                $data = $jsonContent | ConvertFrom-Json -AsHashtable
                
                # Load tasks
                $this.Tasks.Clear()
                $this.TasksByProject.Clear()
                
                if ($data.ContainsKey('Tasks')) {
                    foreach ($taskData in $data.Tasks) {
                        $task = [PmcTask]::new()
                        # Map properties
                        $taskData.GetEnumerator() | ForEach-Object {
                            if ($task.PSObject.Properties.Match($_.Name)) {
                                $task.($_.Name) = $_.Value
                            }
                        }
                        
                        $this.Tasks[$task.Id] = $task
                        
                        # Update project index
                        if (-not $this.TasksByProject.ContainsKey($task.ProjectKey)) {
                            $this.TasksByProject[$task.ProjectKey] = @()
                        }
                        $this.TasksByProject[$task.ProjectKey] += $task.Id
                    }
                }
                
                # Load projects
                $this.Projects.Clear()
                if ($data.ContainsKey('Projects')) {
                    foreach ($projectData in $data.Projects) {
                        $project = [PmcProject]::new()
                        # Map properties
                        $projectData.GetEnumerator() | ForEach-Object {
                            if ($project.PSObject.Properties.Match($_.Name)) {
                                $project.($_.Name) = $_.Value
                            }
                        }
                        
                        $this.Projects[$project.Key] = $project
                    }
                }
                
                # Load metadata
                if ($data.ContainsKey('Metadata')) {
                    $this.Metadata = $data.Metadata
                }
                
                $this.IsDirty = $false
                Write-Verbose "DataManager: Loaded $($this.Tasks.Count) tasks and $($this.Projects.Count) projects"
                
                if ($this.EventManager) {
                    $this.EventManager.Publish("Data.Loaded", @{
                        TaskCount = $this.Tasks.Count
                        ProjectCount = $this.Projects.Count
                    })
                }
            }
            else {
                Write-Verbose "DataManager: No data file found at $($this.DataPath)"
            }
        }
        catch {
            Write-Error "Failed to load data: $_"
            throw [DataLoadException]::new("Failed to load data from $($this.DataPath)", "DataManager", @{}, $_)
        }
    }
    
    [void] SaveData() {
        try {
            if ($this.BatchUpdateCount -gt 0) {
                Write-Verbose "DataManager: Save deferred - batch update in progress"
                return
            }
            
            # Create backup if file exists
            if (Test-Path $this.DataPath) {
                $this._CreateBackup()
            }
            
            $data = @{
                Tasks = $this.Tasks.Values | ForEach-Object {
                    @{
                        Id = $_.Id
                        Title = $_.Title
                        Description = $_.Description
                        Status = $_.Status.ToString()
                        Priority = $_.Priority.ToString()
                        ProjectKey = $_.ProjectKey
                        Category = $_.Category
                        CreatedAt = $_.CreatedAt
                        UpdatedAt = $_.UpdatedAt
                        DueDate = $_.DueDate
                        Tags = $_.Tags
                        Progress = $_.Progress
                        Completed = $_.Completed
                    }
                }
                Projects = $this.Projects.Values | ForEach-Object {
                    @{
                        Key = $_.Key
                        Name = $_.Name
                        Description = $_.Description
                        CreatedAt = $_.CreatedAt
                        UpdatedAt = $_.UpdatedAt
                        Owner = $_.Owner
                        Tags = $_.Tags
                        Metadata = $_.Metadata
                        IsActive = $_.IsActive
                    }
                }
                Metadata = $this.Metadata
                SavedAt = [datetime]::Now
            }
            
            $jsonContent = $data | ConvertTo-Json -Depth 10
            Set-Content -Path $this.DataPath -Value $jsonContent -Force
            
            $this.IsDirty = $false
            $this.LastSave = [datetime]::Now
            
            Write-Verbose "DataManager: Saved $($this.Tasks.Count) tasks and $($this.Projects.Count) projects"
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Data.Saved", @{
                    TaskCount = $this.Tasks.Count
                    ProjectCount = $this.Projects.Count
                })
            }
        }
        catch {
            Write-Error "Failed to save data: $_"
            throw
        }
    }
    
    hidden [void] _CreateBackup() {
        try {
            $backupDir = Join-Path (Split-Path -Parent $this.DataPath) "backups"
            if (-not (Test-Path $backupDir)) {
                New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
            }
            
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $backupPath = Join-Path $backupDir "data_$timestamp.json"
            
            Copy-Item -Path $this.DataPath -Destination $backupPath -Force
            
            # Clean old backups
            $backups = Get-ChildItem -Path $backupDir -Filter "data_*.json" | 
                       Sort-Object -Property LastWriteTime -Descending
            
            if ($backups.Count -gt $this.MaxBackups) {
                $backups | Select-Object -Skip $this.MaxBackups | Remove-Item -Force
            }
            
            Write-Verbose "DataManager: Created backup at $backupPath"
        }
        catch {
            Write-Warning "Failed to create backup: $_"
        }
    }
    
    # Task operations
    [PmcTask[]] GetTasks() {
        if ($null -eq $this.Tasks) {
            Write-Warning "DataManager: Tasks collection is null"
            return @()
        }
        return @($this.Tasks.Values)
    }
    
    [PmcTask] GetTask([string]$id) {
        return $this.Tasks[$id]
    }
    
    [PmcTask[]] GetTasksByProject([string]$projectKey) {
        if ($this.TasksByProject.ContainsKey($projectKey)) {
            return $this.TasksByProject[$projectKey] | ForEach-Object { $this.Tasks[$_] } | Where-Object { $_ }
        }
        return @()
    }
    
    [void] AddTask([PmcTask]$task) {
        if (-not $task) {
            throw [ArgumentNullException]::new("task")
        }
        
        $this.Tasks[$task.Id] = $task
        
        # Update project index
        if (-not $this.TasksByProject.ContainsKey($task.ProjectKey)) {
            $this.TasksByProject[$task.ProjectKey] = @()
        }
        $this.TasksByProject[$task.ProjectKey] += $task.Id
        
        $this.IsDirty = $true
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Data.TaskAdded", @{ Task = $task })
        }
        
        if ($this.AutoSave -and $this.BatchUpdateCount -eq 0) {
            $this.SaveData()
        }
        
        Write-Verbose "DataManager: Added task '$($task.Title)' with ID: $($task.Id)"
    }
    
    [void] UpdateTask([PmcTask]$task) {
        if (-not $task) {
            throw [ArgumentNullException]::new("task")
        }
        
        if (-not $this.Tasks.ContainsKey($task.Id)) {
            throw "Task with ID '$($task.Id)' not found"
        }
        
        $oldTask = $this.Tasks[$task.Id]
        
        # Update project index if project changed
        if ($oldTask.ProjectKey -ne $task.ProjectKey) {
            # Remove from old project
            if ($this.TasksByProject.ContainsKey($oldTask.ProjectKey)) {
                $this.TasksByProject[$oldTask.ProjectKey] = 
                    $this.TasksByProject[$oldTask.ProjectKey] | Where-Object { $_ -ne $task.Id }
            }
            
            # Add to new project
            if (-not $this.TasksByProject.ContainsKey($task.ProjectKey)) {
                $this.TasksByProject[$task.ProjectKey] = @()
            }
            $this.TasksByProject[$task.ProjectKey] += $task.Id
        }
        
        $this.Tasks[$task.Id] = $task
        $this.IsDirty = $true
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Data.TaskUpdated", @{ 
                Task = $task
                OldTask = $oldTask
            })
        }
        
        if ($this.AutoSave -and $this.BatchUpdateCount -eq 0) {
            $this.SaveData()
        }
        
        Write-Verbose "DataManager: Updated task '$($task.Title)'"
    }
    
    [void] RemoveTask([string]$id) {
        if ($this.Tasks.ContainsKey($id)) {
            $task = $this.Tasks[$id]
            
            # Remove from project index
            if ($this.TasksByProject.ContainsKey($task.ProjectKey)) {
                $this.TasksByProject[$task.ProjectKey] = 
                    $this.TasksByProject[$task.ProjectKey] | Where-Object { $_ -ne $id }
            }
            
            $this.Tasks.Remove($id)
            $this.IsDirty = $true
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Data.TaskRemoved", @{ TaskId = $id })
            }
            
            if ($this.AutoSave -and $this.BatchUpdateCount -eq 0) {
                $this.SaveData()
            }
            
            Write-Verbose "DataManager: Removed task with ID: $id"
        }
    }
    
    # Project operations
    [PmcProject[]] GetProjects() {
        return @($this.Projects.Values)
    }
    
    [PmcProject] GetProject([string]$key) {
        return $this.Projects[$key]
    }
    
    [void] AddProject([PmcProject]$project) {
        if (-not $project) {
            throw [ArgumentNullException]::new("project")
        }
        
        $this.Projects[$project.Key] = $project
        $this.IsDirty = $true
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Data.ProjectAdded", @{ Project = $project })
        }
        
        if ($this.AutoSave -and $this.BatchUpdateCount -eq 0) {
            $this.SaveData()
        }
        
        Write-Verbose "DataManager: Added project '$($project.Name)' with key: $($project.Key)"
    }
    
    [void] UpdateProject([PmcProject]$project) {
        if (-not $project) {
            throw [ArgumentNullException]::new("project")
        }
        
        if (-not $this.Projects.ContainsKey($project.Key)) {
            throw "Project with key '$($project.Key)' not found"
        }
        
        $oldProject = $this.Projects[$project.Key]
        $this.Projects[$project.Key] = $project
        $this.IsDirty = $true
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Data.ProjectUpdated", @{ 
                Project = $project
                OldProject = $oldProject
            })
        }
        
        if ($this.AutoSave -and $this.BatchUpdateCount -eq 0) {
            $this.SaveData()
        }
        
        Write-Verbose "DataManager: Updated project '$($project.Name)'"
    }
    
    # Transaction support
    [void] BeginUpdate() {
        $this.BatchUpdateCount++
        Write-Verbose "DataManager: Began batch update (level: $($this.BatchUpdateCount))"
    }
    
    [void] EndUpdate() {
        $this.BatchUpdateCount--
        if ($this.BatchUpdateCount -eq 0 -and $this.IsDirty -and $this.AutoSave) {
            $this.SaveData()
        }
        Write-Verbose "DataManager: Ended batch update (level: $($this.BatchUpdateCount))"
    }
}

# ===== CLASS: NavigationService =====
# Module: navigation-service (from axiom)
# Dependencies: EventManager (optional)
# Purpose: Screen navigation and history management
class NavigationService {
    [System.Collections.Generic.Stack[Screen]]$NavigationStack
    [Screen]$CurrentScreen
    [EventManager]$EventManager
    [hashtable]$ScreenRegistry = @{}
    [int]$MaxStackSize = 10
    
    NavigationService() {
        $this.NavigationStack = [System.Collections.Generic.Stack[Screen]]::new()
    }
    
    NavigationService([EventManager]$eventManager) {
        $this.NavigationStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.EventManager = $eventManager
    }
    
    [void] RegisterScreen([string]$name, [Screen]$screen) {
        $this.ScreenRegistry[$name] = $screen
        Write-Verbose "NavigationService: Registered screen '$name'"
    }
    
    [void] NavigateTo([Screen]$screen) {
        if (-not $screen) {
            throw [ArgumentNullException]::new("screen")
        }
        
        try {
            # Exit current screen
            if ($this.CurrentScreen) {
                Write-Verbose "NavigationService: Exiting screen '$($this.CurrentScreen.Name)'"
                $this.CurrentScreen.OnExit()
                $this.NavigationStack.Push($this.CurrentScreen)
                
                # Limit stack size
                if ($this.NavigationStack.Count -gt $this.MaxStackSize) {
                    $tempStack = [System.Collections.Generic.Stack[Screen]]::new()
                    for ($i = 0; $i -lt $this.MaxStackSize - 1; $i++) {
                        $tempStack.Push($this.NavigationStack.Pop())
                    }
                    $this.NavigationStack.Clear()
                    while ($tempStack.Count -gt 0) {
                        $this.NavigationStack.Push($tempStack.Pop())
                    }
                }
            }
            
            # Enter new screen
            $this.CurrentScreen = $screen
            Write-Verbose "NavigationService: Entering screen '$($screen.Name)'"
            
            if (-not $screen._isInitialized) {
                $screen.Initialize()
                $screen._isInitialized = $true
            }
            
            $screen.OnEnter()
            
            # Publish navigation event
            if ($this.EventManager) {
                $this.EventManager.Publish("Navigation.ScreenChanged", @{
                    Screen = $screen
                    ScreenName = $screen.Name
                    StackDepth = $this.NavigationStack.Count
                })
            }
            
            # Update global state
            $global:TuiState.CurrentScreen = $screen
            $global:TuiState.IsDirty = $true
        }
        catch {
            Write-Error "NavigationService: Failed to navigate to screen '$($screen.Name)': $_"
            throw [NavigationException]::new(
                "Failed to navigate to screen '$($screen.Name)'",
                "NavigationService",
                @{ ScreenName = $screen.Name },
                $_
            )
        }
    }
    
    [void] NavigateToByName([string]$screenName) {
        if (-not $this.ScreenRegistry.ContainsKey($screenName)) {
            throw "Screen '$screenName' not found in registry"
        }
        
        $this.NavigateTo($this.ScreenRegistry[$screenName])
    }
    
    [bool] CanGoBack() {
        return $this.NavigationStack.Count -gt 0
    }
    
    [void] GoBack() {
        if (-not $this.CanGoBack()) {
            Write-Warning "NavigationService: Cannot go back - navigation stack is empty"
            return
        }
        
        try {
            # Exit current screen
            if ($this.CurrentScreen) {
                Write-Verbose "NavigationService: Exiting screen '$($this.CurrentScreen.Name)' (going back)"
                $this.CurrentScreen.OnExit()
            }
            
            # Pop and resume previous screen
            $previousScreen = $this.NavigationStack.Pop()
            $this.CurrentScreen = $previousScreen
            
            Write-Verbose "NavigationService: Resuming screen '$($previousScreen.Name)'"
            $previousScreen.OnResume()
            
            # Publish navigation event
            if ($this.EventManager) {
                $this.EventManager.Publish("Navigation.BackNavigation", @{
                    Screen = $previousScreen
                    ScreenName = $previousScreen.Name
                    StackDepth = $this.NavigationStack.Count
                })
            }
            
            # Update global state
            $global:TuiState.CurrentScreen = $previousScreen
            $global:TuiState.IsDirty = $true
        }
        catch {
            Write-Error "NavigationService: Failed to go back: $_"
            throw [NavigationException]::new(
                "Failed to navigate back",
                "NavigationService",
                @{ StackDepth = $this.NavigationStack.Count },
                $_
            )
        }
    }
    
    [void] Reset() {
        # Clean up all screens in stack
        while ($this.NavigationStack.Count -gt 0) {
            $screen = $this.NavigationStack.Pop()
            try {
                $screen.Cleanup()
            }
            catch {
                Write-Warning "NavigationService: Error cleaning up screen '$($screen.Name)': $_"
            }
        }
        
        # Clean up current screen
        if ($this.CurrentScreen) {
            try {
                $this.CurrentScreen.OnExit()
                $this.CurrentScreen.Cleanup()
            }
            catch {
                Write-Warning "NavigationService: Error cleaning up current screen: $_"
            }
            $this.CurrentScreen = $null
        }
        
        Write-Verbose "NavigationService: Reset complete"
    }
}

# ===== CLASS: ThemeManager =====
# Module: theme-manager (from axiom)
# Dependencies: None
# Purpose: Visual theming system with hot-swapping
class ThemeManager {
    [hashtable]$CurrentTheme = @{}
    [string]$ThemeName = "Default"
    [hashtable]$ThemeRegistry = @{}
    [string]$ThemePath
    
    ThemeManager() {
        $this.ThemePath = Join-Path $env:APPDATA "AxiomPhoenix\themes"
        $this._Initialize()
    }
    
    ThemeManager([string]$themePath) {
        $this.ThemePath = $themePath
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        if (-not (Test-Path $this.ThemePath)) {
            New-Item -ItemType Directory -Path $this.ThemePath -Force | Out-Null
        }
        
        $this.LoadDefaultTheme()
        Write-Verbose "ThemeManager: Initialized with theme path: $($this.ThemePath)"
    }
    
    [void] LoadDefaultTheme() {
        $this.CurrentTheme = @{
            # Base colors
            'Foreground' = [ConsoleColor]::White
            'Background' = [ConsoleColor]::Black
            'Accent' = [ConsoleColor]::Cyan
            'Header' = [ConsoleColor]::Cyan
            'Subtle' = [ConsoleColor]::DarkGray
            'Highlight' = [ConsoleColor]::Yellow
            'Border' = [ConsoleColor]::Gray
            'Selection' = [ConsoleColor]::DarkBlue
            'Error' = [ConsoleColor]::Red
            'Warning' = [ConsoleColor]::Yellow
            'Success' = [ConsoleColor]::Green
            'Info' = [ConsoleColor]::Cyan
            
            # Component-specific colors
            'button.normal.background' = [ConsoleColor]::Black
            'button.normal.foreground' = [ConsoleColor]::White
            'button.normal.border' = [ConsoleColor]::Gray
            'button.focus.background' = [ConsoleColor]::Black
            'button.focus.foreground' = [ConsoleColor]::White
            'button.focus.border' = [ConsoleColor]::Cyan
            'button.pressed.background' = [ConsoleColor]::DarkGray
            'button.pressed.foreground' = [ConsoleColor]::Black
            'button.pressed.border' = [ConsoleColor]::Cyan
            
            'textbox.normal.background' = [ConsoleColor]::Black
            'textbox.normal.foreground' = [ConsoleColor]::White
            'textbox.normal.border' = [ConsoleColor]::Gray
            'textbox.focus.background' = [ConsoleColor]::Black
            'textbox.focus.foreground' = [ConsoleColor]::White
            'textbox.focus.border' = [ConsoleColor]::Cyan
            'textbox.placeholder' = [ConsoleColor]::DarkGray
            
            'checkbox.normal.foreground' = [ConsoleColor]::White
            'checkbox.checked.foreground' = [ConsoleColor]::Green
            'checkbox.focus.foreground' = [ConsoleColor]::Cyan
            
            'panel.background' = [ConsoleColor]::Black
            'panel.foreground' = [ConsoleColor]::White
            'panel.border' = [ConsoleColor]::Gray
            'panel.title' = [ConsoleColor]::Cyan
            
            'list.item.normal' = [ConsoleColor]::White
            'list.item.selected' = [ConsoleColor]::Black
            'list.item.selected.background' = [ConsoleColor]::Cyan
            'list.scrollbar' = [ConsoleColor]::DarkGray
            
            'dialog.background' = [ConsoleColor]::Black
            'dialog.foreground' = [ConsoleColor]::White
            'dialog.border' = [ConsoleColor]::Yellow
            'dialog.title' = [ConsoleColor]::Yellow
            'dialog.shadow' = [ConsoleColor]::DarkGray
        }
        
        $this.ThemeName = "Default"
        Write-Verbose "ThemeManager: Loaded default theme"
    }
    
    [object] GetColor([string]$colorName) {
        if ($this.CurrentTheme.ContainsKey($colorName)) {
            return $this.CurrentTheme[$colorName]
        }
        
        # Fallback to base color
        if ($colorName -match '\.') {
            $baseColor = $colorName.Split('.')[0]
            if ($this.CurrentTheme.ContainsKey($baseColor)) {
                return $this.CurrentTheme[$baseColor]
            }
        }
        
        Write-Warning "ThemeManager: Color '$colorName' not found in theme, using White"
        return [ConsoleColor]::White
    }
    
    [void] SetColor([string]$colorName, [object]$color) {
        $this.CurrentTheme[$colorName] = $color
        Write-Verbose "ThemeManager: Set color '$colorName' to '$color'"
    }
    
    [void] LoadTheme([string]$themeName) {
        $themeFile = Join-Path $this.ThemePath "$themeName.json"
        
        if (-not (Test-Path $themeFile)) {
            throw "Theme file not found: $themeFile"
        }
        
        try {
            $themeData = Get-Content -Path $themeFile -Raw | ConvertFrom-Json -AsHashtable
            
            # Convert color values
            $this.CurrentTheme.Clear()
            foreach ($key in $themeData.Keys) {
                $value = $themeData[$key]
                
                # Handle ConsoleColor enum values
                if ($value -is [string] -and [Enum]::TryParse([ConsoleColor], $value, [ref]$null)) {
                    $this.CurrentTheme[$key] = [Enum]::Parse([ConsoleColor], $value)
                }
                # Handle hex colors
                elseif ($value -is [string] -and $value -match '^#[0-9A-Fa-f]{6}$') {
                    $this.CurrentTheme[$key] = $value
                }
                else {
                    $this.CurrentTheme[$key] = $value
                }
            }
            
            $this.ThemeName = $themeName
            Write-Verbose "ThemeManager: Loaded theme '$themeName' from file"
        }
        catch {
            Write-Error "Failed to load theme '$themeName': $_"
            throw
        }
    }
    
    [void] SaveTheme([string]$themeName) {
        $themeFile = Join-Path $this.ThemePath "$themeName.json"
        
        try {
            # Convert ConsoleColor enums to strings for JSON
            $themeData = @{}
            foreach ($key in $this.CurrentTheme.Keys) {
                $value = $this.CurrentTheme[$key]
                if ($value -is [ConsoleColor]) {
                    $themeData[$key] = $value.ToString()
                }
                else {
                    $themeData[$key] = $value
                }
            }
            
            $jsonContent = $themeData | ConvertTo-Json -Depth 10
            Set-Content -Path $themeFile -Value $jsonContent -Force
            
            Write-Verbose "ThemeManager: Saved theme '$themeName' to file"
        }
        catch {
            Write-Error "Failed to save theme '$themeName': $_"
            throw
        }
    }
    
    [hashtable] CreateTheme([string]$themeName, [hashtable]$baseTheme = @{}) {
        $newTheme = if ($baseTheme.Count -gt 0) { 
            $baseTheme.Clone() 
        } else { 
            $this.CurrentTheme.Clone() 
        }
        
        $this.ThemeRegistry[$themeName] = $newTheme
        Write-Verbose "ThemeManager: Created theme '$themeName'"
        
        return $newTheme
    }
    
    [void] ApplyTheme([string]$themeName) {
        if ($this.ThemeRegistry.ContainsKey($themeName)) {
            $this.CurrentTheme = $this.ThemeRegistry[$themeName].Clone()
            $this.ThemeName = $themeName
            Write-Verbose "ThemeManager: Applied theme '$themeName' from registry"
        }
        else {
            $this.LoadTheme($themeName)
        }
    }
}

# ===== CLASS: Logger =====
# Module: logger (from axiom)
# Dependencies: None
# Purpose: Application-wide logging with multiple outputs
class Logger {
    [string]$LogPath
    [System.Collections.Queue]$LogQueue
    [int]$MaxQueueSize = 1000
    [bool]$EnableFileLogging = $true
    [bool]$EnableConsoleLogging = $false
    [string]$MinimumLevel = "Info"
    [hashtable]$LevelPriority = @{
        'Trace' = 0
        'Debug' = 1
        'Info' = 2
        'Warning' = 3
        'Error' = 4
        'Fatal' = 5
    }
    
    Logger() {
        $this.LogPath = Join-Path $env:APPDATA "AxiomPhoenix\app.log"
        $this._Initialize()
    }
    
    Logger([string]$logPath) {
        $this.LogPath = $logPath
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $this.LogQueue = [System.Collections.Queue]::new()
        
        $logDir = Split-Path -Parent $this.LogPath
        if (-not (Test-Path $logDir)) {
            New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        }
        
        Write-Verbose "Logger: Initialized with log path: $($this.LogPath)"
    }
    
    [void] Log([string]$message, [string]$level = "Info") {
        # Check if we should log this level
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) {
            return
        }
        
        $logEntry = @{
            Timestamp = [DateTime]::Now
            Level = $level
            Message = $message
            ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        }
        
        # Add to queue
        $this.LogQueue.Enqueue($logEntry)
        
        # Flush if queue is getting large
        if ($this.LogQueue.Count -ge $this.MaxQueueSize) {
            $this.Flush()
        }
        
        # Console logging if enabled
        if ($this.EnableConsoleLogging) {
            $this._WriteToConsole($logEntry)
        }
    }
    
    [void] LogException([Exception]$exception, [string]$message = "") {
        $exceptionDetails = @{
            Message = if ($message) { $message } else { "Exception occurred" }
            ExceptionType = $exception.GetType().FullName
            ExceptionMessage = $exception.Message
            StackTrace = $exception.StackTrace
            InnerException = if ($exception.InnerException) { 
                $exception.InnerException.Message 
            } else { 
                $null 
            }
        }
        
        $detailsJson = $exceptionDetails | ConvertTo-Json -Compress
        $this.Log($detailsJson, "Error")
    }
    
    [void] Flush() {
        if ($this.LogQueue.Count -eq 0 -or -not $this.EnableFileLogging) {
            return
        }
        
        try {
            $logContent = [System.Text.StringBuilder]::new()
            
            while ($this.LogQueue.Count -gt 0) {
                $entry = $this.LogQueue.Dequeue()
                $logLine = "$($entry.Timestamp.ToString('yyyy-MM-dd HH:mm:ss.fff')) [$($entry.Level.ToUpper().PadRight(7))] [Thread:$($entry.ThreadId)] $($entry.Message)"
                [void]$logContent.AppendLine($logLine)
            }
            
            if ($logContent.Length -gt 0) {
                Add-Content -Path $this.LogPath -Value $logContent.ToString() -NoNewline
            }
        }
        catch {
            Write-Warning "Logger: Failed to flush logs: $_"
        }
    }
    
    hidden [void] _WriteToConsole([hashtable]$logEntry) {
        $color = switch ($logEntry.Level) {
            'Trace' { [ConsoleColor]::DarkGray }
            'Debug' { [ConsoleColor]::Gray }
            'Info' { [ConsoleColor]::White }
            'Warning' { [ConsoleColor]::Yellow }
            'Error' { [ConsoleColor]::Red }
            'Fatal' { [ConsoleColor]::Magenta }
            default { [ConsoleColor]::White }
        }
        
        $timestamp = $logEntry.Timestamp.ToString('HH:mm:ss')
        $prefix = "[$timestamp] [$($logEntry.Level.ToUpper())]"
        
        Write-Host $prefix -ForegroundColor $color -NoNewline
        Write-Host " $($logEntry.Message)" -ForegroundColor White
    }
    
    [void] Cleanup() {
        $this.Flush()
        Write-Verbose "Logger: Cleanup complete"
    }
}

# ===== CLASS: EventManager =====
# Module: event-system (from axiom)
# Dependencies: None
# Purpose: Pub/sub event system for decoupled communication
class EventManager {
    [hashtable]$EventHandlers = @{}
    [int]$NextHandlerId = 1
    [System.Collections.Generic.List[hashtable]]$EventHistory
    [int]$MaxHistorySize = 100
    [bool]$EnableHistory = $true
    
    EventManager() {
        $this.EventHistory = [System.Collections.Generic.List[hashtable]]::new()
        Write-Verbose "EventManager: Initialized"
    }
    
    [string] Subscribe([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) {
            throw [ArgumentException]::new("Event name cannot be null or empty")
        }
        if (-not $handler) {
            throw [ArgumentNullException]::new("handler")
        }
        
        if (-not $this.EventHandlers.ContainsKey($eventName)) {
            $this.EventHandlers[$eventName] = @{}
        }
        
        $handlerId = "handler_$($this.NextHandlerId)"
        $this.NextHandlerId++
        
        $this.EventHandlers[$eventName][$handlerId] = @{
            Handler = $handler
            SubscribedAt = [DateTime]::Now
            ExecutionCount = 0
        }
        
        Write-Verbose "EventManager: Subscribed handler '$handlerId' to event '$eventName'"
        return $handlerId
    }
    
    [void] Unsubscribe([string]$eventName, [string]$handlerId) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            if ($this.EventHandlers[$eventName].ContainsKey($handlerId)) {
                $this.EventHandlers[$eventName].Remove($handlerId)
                Write-Verbose "EventManager: Unsubscribed handler '$handlerId' from event '$eventName'"
                
                # Clean up empty event entries
                if ($this.EventHandlers[$eventName].Count -eq 0) {
                    $this.EventHandlers.Remove($eventName)
                }
            }
        }
    }
    
    [void] UnsubscribeAll([string]$eventName) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlerCount = $this.EventHandlers[$eventName].Count
            $this.EventHandlers.Remove($eventName)
            Write-Verbose "EventManager: Unsubscribed all $handlerCount handlers from event '$eventName'"
        }
    }
    
    [void] Publish([string]$eventName, [hashtable]$eventData = @{}) {
        Write-Verbose "EventManager: Publishing event '$eventName'"
        
        # Add to history if enabled
        if ($this.EnableHistory) {
            $historyEntry = @{
                EventName = $eventName
                EventData = $eventData.Clone()
                Timestamp = [DateTime]::Now
                HandlerCount = 0
            }
            
            $this.EventHistory.Add($historyEntry)
            
            # Trim history if needed
            if ($this.EventHistory.Count -gt $this.MaxHistorySize) {
                $this.EventHistory.RemoveAt(0)
            }
        }
        
        # Execute handlers
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlers = @($this.EventHandlers[$eventName].GetEnumerator())
            $handlerCount = $handlers.Count
            
            if ($this.EnableHistory) {
                $this.EventHistory[-1].HandlerCount = $handlerCount
            }
            
            foreach ($entry in $handlers) {
                try {
                    $handlerData = $entry.Value
                    $handlerData.ExecutionCount++
                    
                    Write-Verbose "EventManager: Executing handler '$($entry.Key)' for event '$eventName'"
                    & $handlerData.Handler $eventData
                }
                catch {
                    Write-Error "EventManager: Error in handler '$($entry.Key)' for event '$eventName': $_"
                }
            }
            
            Write-Verbose "EventManager: Published event '$eventName' to $handlerCount handlers"
        }
        else {
            Write-Verbose "EventManager: No handlers registered for event '$eventName'"
        }
    }
    
    [hashtable[]] GetEventHistory([string]$eventName = $null) {
        if ($eventName) {
            return $this.EventHistory | Where-Object { $_.EventName -eq $eventName }
        }
        return $this.EventHistory | ForEach-Object { $_ }
    }
    
    [void] ClearHistory() {
        $this.EventHistory.Clear()
        Write-Verbose "EventManager: Cleared event history"
    }
    
    [hashtable] GetEventInfo() {
        $info = @{
            RegisteredEvents = @{}
            TotalHandlers = 0
        }
        
        foreach ($eventName in $this.EventHandlers.Keys) {
            $handlers = $this.EventHandlers[$eventName]
            $info.RegisteredEvents[$eventName] = @{
                HandlerCount = $handlers.Count
                Handlers = $handlers.Keys | ForEach-Object { $_ }
            }
            $info.TotalHandlers += $handlers.Count
        }
        
        return $info
    }
}

# ===== CLASS: TuiFrameworkService =====
# Module: tui-framework (from axiom)
# Dependencies: None
# Purpose: Framework utilities and async operations
class TuiFrameworkService {
    [hashtable]$AsyncJobs = @{}
    [int]$NextJobId = 1
    [bool]$IsRunning = $false
    
    TuiFrameworkService() {
        Write-Verbose "TuiFrameworkService: Initialized"
    }
    
    [hashtable] StartAsync([scriptblock]$work, [string]$name = "") {
        try {
            $jobId = $this.NextJobId++
            $jobName = if ($name) { $name } else { "AsyncJob_$jobId" }
            
            # Use ThreadJob for lightweight async operations
            $job = Start-ThreadJob -ScriptBlock $work -Name $jobName
            
            $jobInfo = @{
                Id = $jobId
                Name = $jobName
                Job = $job
                StartedAt = [DateTime]::Now
                Status = "Running"
            }
            
            $this.AsyncJobs[$jobId] = $jobInfo
            
            Write-Verbose "TuiFrameworkService: Started async job '$jobName' with ID $jobId"
            return $jobInfo
        }
        catch {
            Write-Error "Failed to start async job: $_"
            throw
        }
    }
    
    [object] GetAsyncResults([int]$jobId, [bool]$wait = $false) {
        if (-not $this.AsyncJobs.ContainsKey($jobId)) {
            throw "Async job with ID $jobId not found"
        }
        
        $jobInfo = $this.AsyncJobs[$jobId]
        $job = $jobInfo.Job
        
        if ($wait) {
            Write-Verbose "TuiFrameworkService: Waiting for job $jobId to complete"
            Wait-Job -Job $job | Out-Null
        }
        
        if ($job.State -eq "Completed") {
            $result = Receive-Job -Job $job -Keep
            $jobInfo.Status = "Completed"
            return $result
        }
        elseif ($job.State -eq "Failed") {
            $jobInfo.Status = "Failed"
            $error = Receive-Job -Job $job -Keep
            throw "Async job $jobId failed: $error"
        }
        else {
            return $null
        }
    }
    
    [void] StopAllAsyncJobs() {
        Write-Verbose "TuiFrameworkService: Stopping all async jobs"
        
        foreach ($jobInfo in $this.AsyncJobs.Values) {
            try {
                if ($jobInfo.Job.State -eq "Running") {
                    Stop-Job -Job $jobInfo.Job
                    Remove-Job -Job $jobInfo.Job -Force
                }
            }
            catch {
                Write-Warning "Failed to stop job $($jobInfo.Id): $_"
            }
        }
        
        $this.AsyncJobs.Clear()
    }
    
    [hashtable] GetState() {
        return @{
            IsRunning = $this.IsRunning
            AsyncJobCount = $this.AsyncJobs.Count
            ActiveJobs = $this.AsyncJobs.Values | Where-Object { $_.Status -eq "Running" } | Measure-Object | Select-Object -ExpandProperty Count
        }
    }
    
    [bool] IsRunning() {
        return $this.IsRunning
    }
    
    [void] Start() {
        $this.IsRunning = $true
        Write-Verbose "TuiFrameworkService: Started"
    }
    
    [void] Stop() {
        $this.StopAllAsyncJobs()
        $this.IsRunning = $false
        Write-Verbose "TuiFrameworkService: Stopped"
    }
    
    [void] Cleanup() {
        $this.Stop()
    }
}

#endregion


####\debug-start-detailed.ps1
# Debug startup script with detailed error tracing
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

try {
    # Set location
    Set-Location $PSScriptRoot
    
    Write-Host "Loading framework files..." -ForegroundColor Cyan
    
    # Load in dependency order
    . .\AllBaseClasses.ps1
    Write-Host "✓ AllBaseClasses.ps1 loaded" -ForegroundColor Green
    
    . .\AllModels.ps1
    Write-Host "✓ AllModels.ps1 loaded" -ForegroundColor Green
    
    . .\AllComponents.ps1
    Write-Host "✓ AllComponents.ps1 loaded" -ForegroundColor Green
    
    . .\AllScreens.ps1
    Write-Host "✓ AllScreens.ps1 loaded" -ForegroundColor Green
    
    . .\AllFunctions.ps1
    Write-Host "✓ AllFunctions.ps1 loaded" -ForegroundColor Green
    
    . .\AllServices.ps1
    Write-Host "✓ AllServices.ps1 loaded" -ForegroundColor Green
    
    . .\AllRuntime.ps1
    Write-Host "✓ AllRuntime.ps1 loaded" -ForegroundColor Green
    
    Write-Host "`nInitializing services..." -ForegroundColor Cyan
    
    # Create service container
    $container = [ServiceContainer]::new()
    
    # Register services
    $container.Register("Logger", [Logger]::new())
    $container.Register("ThemeManager", [ThemeManager]::new())
    $container.Register("EventManager", [EventManager]::new())
    $container.Register("DataManager", [DataManager]::new())
    $container.Register("ActionService", [ActionService]::new())
    $container.Register("KeybindingService", [KeybindingService]::new())
    $container.Register("NavigationService", [NavigationService]::new())
    
    Write-Host "✓ Services registered" -ForegroundColor Green
    
    # Initialize theme
    $themeManager = $container.GetService("ThemeManager")
    $themeManager.LoadDefaultTheme()
    
    # Create dashboard
    Write-Host "`nCreating dashboard screen..." -ForegroundColor Cyan
    $dashboardScreen = [DashboardScreen]::new($container)
    Write-Host "✓ Dashboard created" -ForegroundColor Green
    
    # Start with detailed error catching
    Write-Host "`nStarting application..." -ForegroundColor Cyan
    
    # Override Process-TuiInput temporarily for debugging
    $originalProcessInput = Get-Command Process-TuiInput
    function Process-TuiInput {
        [CmdletBinding()]
        param()
        
        try {
            Write-Host "DEBUG: Process-TuiInput called" -ForegroundColor Yellow
            
            if ([Console]::KeyAvailable) {
                $keyInfo = [Console]::ReadKey($true)
                Write-Host "DEBUG: Key pressed: $($keyInfo.Key)" -ForegroundColor Yellow
                
                # Check command palette first
                if ($global:TuiState.CommandPalette -and $global:TuiState.CommandPalette.Visible) {
                    Write-Host "DEBUG: Passing to CommandPalette" -ForegroundColor Yellow
                    $handled = $global:TuiState.CommandPalette.HandleInput($keyInfo)
                    if ($handled) {
                        $global:TuiState.IsDirty = $true
                        return
                    }
                }
                
                # Pass to current screen
                if ($global:TuiState.CurrentScreen) {
                    Write-Host "DEBUG: Passing to CurrentScreen: $($global:TuiState.CurrentScreen.GetType().Name)" -ForegroundColor Yellow
                    
                    # Check if HandleInput exists
                    if ($global:TuiState.CurrentScreen.PSObject.Methods['HandleInput']) {
                        Write-Host "DEBUG: HandleInput method exists" -ForegroundColor Yellow
                        $global:TuiState.CurrentScreen.HandleInput($keyInfo)
                    } else {
                        Write-Host "DEBUG: HandleInput method NOT FOUND!" -ForegroundColor Red
                    }
                    
                    $global:TuiState.IsDirty = $true
                }
            }
        }
        catch {
            Write-Host "DEBUG ERROR in Process-TuiInput:" -ForegroundColor Red
            Write-Host "  Message: $($_.Exception.Message)" -ForegroundColor Red
            Write-Host "  Type: $($_.Exception.GetType().FullName)" -ForegroundColor Red
            Write-Host "  Target: $($_.Exception.TargetSite)" -ForegroundColor Red
            Write-Host "  Stack: $($_.ScriptStackTrace)" -ForegroundColor Red
            
            # Check for property access errors
            if ($_.Exception.Message -like "*property*cannot be found*") {
                Write-Host "  Property Access Error Detected!" -ForegroundColor Magenta
                Write-Host "  Attempting to access: $($_.Exception.Message -replace '.*property ''(.*)'' cannot.*', '$1')" -ForegroundColor Magenta
            }
            
            throw
        }
    }
    
    Start-AxiomPhoenix -ServiceContainer $container -InitialScreen $dashboardScreen
}
catch {
    Write-Host "`nDETAILED ERROR INFORMATION:" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Type: $($_.Exception.GetType().FullName)" -ForegroundColor Red
    Write-Host "ScriptStackTrace:" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    Write-Host "`nInvocationInfo:" -ForegroundColor Red
    Write-Host "  Line: $($_.InvocationInfo.Line)" -ForegroundColor Gray
    Write-Host "  ScriptLineNumber: $($_.InvocationInfo.ScriptLineNumber)" -ForegroundColor Gray
    Write-Host "  ScriptName: $($_.InvocationInfo.ScriptName)" -ForegroundColor Gray
    Write-Host "  PositionMessage: $($_.InvocationInfo.PositionMessage)" -ForegroundColor Gray
    
    Write-Host "`nPress any key to exit..." -ForegroundColor Yellow
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}


####\debug-start.ps1
# Debug startup script
$DebugPreference = "Continue"
$VerbosePreference = "Continue"

Write-Host "Starting in debug mode..." -ForegroundColor Yellow

try {
    & "$PSScriptRoot\Start.ps1"
} catch {
    Write-Host "`nDetailed error information:" -ForegroundColor Red
    Write-Host "Error: $_" -ForegroundColor Red
    Write-Host "`nException:" -ForegroundColor Yellow
    Write-Host $_.Exception -ForegroundColor Gray
    Write-Host "`nStack Trace:" -ForegroundColor Yellow
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    Write-Host "`nInvocation Info:" -ForegroundColor Yellow
    Write-Host $_.InvocationInfo.PositionMessage -ForegroundColor Gray
    
    # Keep console open
    Write-Host "`nPress any key to exit..." -ForegroundColor White
    [Console]::ReadKey($true) | Out-Null
}


####\filecopy.ps1
#------------------------------------------------------------------------------------------
# SCRIPT:      filecopy-and-concatenate.ps1
#
# DESCRIPTION: Finds specified file types in a given path and its subdirectories.
#              For each file, it can create a .txt copy and/or concatenate all
#              file contents into a single output file.
#
# FEATURES:
#   - Full parameter support for path, file types, and output name.
#   - Safety features: Supports -WhatIf and -Confirm for all file operations.
#   - Verbose output: Use the -Verbose switch to see detailed progress.
#   - Performance: Uses an efficient single-write operation for the concatenated file.
#   - Robustness: Uses idiomatic PowerShell for path manipulation and error handling.
#   - Compatibility: Works on Windows PowerShell 5.1 and newer.
#
# USAGE:
#   # Basic run in the current folder for PowerShell files
#   .\filecopy-and-concatenate.ps1 -Verbose
#
#   # Run on a different project, for C# files, with a different output name
#   .\filecopy-and-concatenate.ps1 -Path "C:\Projects\MyWebApp" -Include "*.cs" -OutputFileName "SourceCode.txt"
#
#   # Perform a "dry run" to see what would happen without making any changes
#   .\filecopy-and-concatenate.ps1 -Path "C:\SomethingImportant" -WhatIf
#
#   # To also create individual .txt copies of each file:
#   .\filecopy-and-concatenate.ps1 -CreateIndividualCopies -Verbose
#
#------------------------------------------------------------------------------------------

# Enable support for -WhatIf, -Confirm, and advanced parameter binding
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    # The starting directory to search in. Defaults to the current directory.
    [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "The root path to search for files.")]
    [string]
    $Path = (Get-Location).Path,

    # An array of file patterns to include. Defaults to PowerShell script files.
    [Parameter(Mandatory = $false, HelpMessage = "File patterns to include, e.g., '*.ps1', '*.psm1'.")]
    [string[]]
    $Include = @("*.ps1", "*.psm1"),

    # The name of the final concatenated output file.
    [Parameter(Mandatory = $false, HelpMessage = "Name of the concatenated output file.")]
    [string]
    $OutputFileName = "all.txt",
    
    # Switch to create a .txt copy of each individual file found.
    [Parameter(Mandatory = $false, HelpMessage = "If specified, creates a .txt copy of each found file.")]
    [switch]
    $CreateIndividualCopies
)

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Resolve-Path returns a PathInfo object. We use it for robustness.
    $resolvedPathObject = Resolve-Path -Path $Path
    $outputFilePath = Join-Path -Path $resolvedPathObject.Path -ChildPath $OutputFileName

    Write-Verbose "Starting operations in: $($resolvedPathObject.Path)"
    Write-Verbose "Searching for file types: $($Include -join ', ')"
    Write-Verbose "Output file will be: $outputFilePath"

    # --- Step 1: Find all specified files recursively ---
    $filesToProcess = Get-ChildItem -Path $resolvedPathObject.Path -Recurse -Include $Include -File

    if ($null -eq $filesToProcess) {
        Write-Warning "No files found matching the specified criteria."
        return # Exit gracefully if no files are found
    }

    Write-Verbose "Found $($filesToProcess.Count) files to process."

    # --- Step 2: Clear the existing output file if it exists ---
    if ((Test-Path $outputFilePath) -and $PSCmdlet.ShouldProcess($outputFilePath, "Remove existing output file")) {
        Remove-Item $outputFilePath -Force
    }

    # --- Step 3: Process each file for individual copies (if requested) ---
    if ($CreateIndividualCopies.IsPresent) {
        foreach ($file in $filesToProcess) {
            $txtCopyPath = [System.IO.Path]::ChangeExtension($file.FullName, ".txt")
            if ($PSCmdlet.ShouldProcess($txtCopyPath, "Copy from $($file.Name)")) {
                Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force
                Write-Verbose "Copied '$($file.Name)' to '$($txtCopyPath)'"
            }
        }
    }

    # --- Step 4: Concatenate all files into the output file (Efficiently) ---
    Write-Verbose "Starting concatenation of all files into '$OutputFileName'..."
    if ($PSCmdlet.ShouldProcess($outputFilePath, "Concatenate $($filesToProcess.Count) files")) {
        Set-Content -Path $outputFilePath -Encoding UTF8 -Value $(
            foreach ($file in $filesToProcess) {
                # CORRECTED LINE: Get the length from the .Path property of the PathInfo object.
                $basePathString = $resolvedPathObject.Path
                $relativePath = $file.FullName.Substring($basePathString.Length)
                $relativePath = '\' + $relativePath.TrimStart('\/') # Ensure consistent format like '\subdir\file.ps1'
                
                # Output the header for this file
                "####$relativePath"
                
                # Output the file's content
                Get-Content -Path $file.FullName -Raw -Encoding UTF8
                
                # Output a blank line for separation
                ""
            }
        )
        Write-Host "All operations complete. Concatenated content saved to '$outputFilePath'."
    }

}
catch {
    # A global catch block for any unexpected, terminating errors.
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    Write-Error "Script execution halted at line $($_.InvocationInfo.ScriptLineNumber): $($_.InvocationInfo.Line)"
}

####\Start.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Application Entry Point
# Loads all framework files and starts the application
# ==============================================================================

#region Script Configuration

# Clean session by removing any existing types
if ($global:TuiState) {
    Write-Host "Cleaning previous session..." -ForegroundColor Yellow
    try {
        if ($global:TuiState.Running) {
            $global:TuiState.Running = $false
        }
        Remove-Variable -Name TuiState -Scope Global -Force -ErrorAction SilentlyContinue
    } catch {}
}

# Remove any loaded types from previous runs
$typesToRemove = @(
    'TuiAnsiHelper', 'TuiCell', 'TuiBuffer', 'UIElement', 'Component', 'Screen', 'ServiceContainer',
    'ValidationBase', 'PmcTask', 'PmcProject', 'TimeEntry', 'NavigationItem',
    'LabelComponent', 'ButtonComponent', 'TextBoxComponent', 'CheckBoxComponent', 'RadioButtonComponent',
    'Panel', 'ScrollablePanel', 'GroupPanel', 'ListBox', 'TextBox', 'CommandPalette',
    'ActionService', 'KeybindingService', 'DataManager', 'NavigationService', 'ThemeManager', 'Logger', 'EventManager'
)

foreach ($typeName in $typesToRemove) {
    try {
        [System.Management.Automation.PSObject].Assembly.GetTypes() | 
            Where-Object { $_.Name -eq $typeName } | 
            ForEach-Object { 
                Remove-TypeData -TypeName $_.FullName -ErrorAction SilentlyContinue 
            }
    } catch {}
}

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
$VerbosePreference = 'SilentlyContinue'  # Change to 'Continue' for debug output

#endregion

#region Load Framework Files

try {
    Write-Host "Loading Axiom-Phoenix v4.0..." -ForegroundColor Cyan
    
    $scriptRoot = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent
    
    # Define files in dependency order (CRITICAL: Do not change order!)
    $filesToLoad = @(
        'AllBaseClasses.ps1'   # Foundation types with zero dependencies
        'AllModels.ps1'        # Data models, depends on base classes
        'AllComponents.ps1'    # UI components, depends on base + models
        'AllScreens.ps1'       # Screens, depends on all above
        'AllFunctions.ps1'     # Helper functions, can reference all classes
        'AllServices.ps1'      # Services, can use everything
        'AllRuntime.ps1'       # Engine and runtime, orchestrates everything
    )
    
    # Load each file
    foreach ($file in $filesToLoad) {
        $filePath = Join-Path $scriptRoot $file
        
        if (-not (Test-Path $filePath)) {
            throw "Required file not found: $filePath"
        }
        
        Write-Verbose "Loading: $file"
        . $filePath
    }
    
    Write-Host "Framework loaded successfully!" -ForegroundColor Green
}
catch {
    Write-Host "Failed to load framework files!" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    exit 1
}

#endregion

#region Initialize Services

try {
    Write-Host "Initializing services..." -ForegroundColor Cyan
    
    # Create service container
    $container = [ServiceContainer]::new()
    
    # Register core services
    $container.Register("Logger", [Logger]::new())
    $container.Register("EventManager", [EventManager]::new())
    $container.Register("ThemeManager", [ThemeManager]::new())
    
    # Register services that depend on EventManager
    $eventManager = $container.GetService("EventManager")
    $container.Register("ActionService", [ActionService]::new($eventManager))
    $container.Register("DataManager", [DataManager]::new((Join-Path $env:APPDATA "AxiomPhoenix\data.json"), $eventManager))
    $container.Register("NavigationService", [NavigationService]::new($eventManager))
    
    # Register services that depend on ActionService
    $actionService = $container.GetService("ActionService")
    $container.Register("KeybindingService", [KeybindingService]::new($actionService))
    
    # Register framework service
    $container.Register("TuiFrameworkService", [TuiFrameworkService]::new())
    
    # Initialize default actions
    $actionService.RegisterDefaultActions()
    
    # Register navigation actions
    $navService = $container.GetService("NavigationService")
    
    $actionService.RegisterAction("navigation.dashboard", {
        $dashboard = [DashboardScreen]::new($container)
        $navService.NavigateTo($dashboard)
    }, @{
        Category = "Navigation"
        Description = "Go to Dashboard"
    })
    
    $actionService.RegisterAction("navigation.taskList", {
        $taskList = [TaskListScreen]::new($container)
        $navService.NavigateTo($taskList)
    }, @{
        Category = "Navigation"
        Description = "Go to Task List"
    })
    
    Write-Host "Services initialized successfully!" -ForegroundColor Green
}
catch {
    Write-Host "Failed to initialize services!" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    exit 1
}

#endregion

#region Load Sample Data

try {
    Write-Host "Loading sample data..." -ForegroundColor Cyan
    
    $dataManager = $container.GetService("DataManager")
    
    # Try to load existing data first
    try {
        $dataManager.LoadData()
        
        if ($dataManager.Tasks.Count -eq 0) {
            throw "No existing data found"
        }
        
        Write-Host "Loaded $($dataManager.Tasks.Count) tasks from storage" -ForegroundColor Green
    }
    catch {
        Write-Host "Creating sample data..." -ForegroundColor Yellow
        
        # Create sample project
        $project = [PmcProject]::new("DEMO", "Demo Project", "Sample project for demonstration", "Admin")
        $dataManager.AddProject($project)
        
        # Create sample tasks
        $sampleTasks = @(
            @{
                Title = "Complete TUI Framework Migration"
                Description = "Migrate all axiom components to mono structure"
                Priority = [TaskPriority]::High
                Status = [TaskStatus]::InProgress
                Progress = 75
            },
            @{
                Title = "Write Documentation"
                Description = "Create comprehensive documentation for the framework"
                Priority = [TaskPriority]::Medium
                Status = [TaskStatus]::Pending
                Progress = 0
            },
            @{
                Title = "Add Unit Tests"
                Description = "Implement unit tests for core components"
                Priority = [TaskPriority]::Medium
                Status = [TaskStatus]::Pending
                Progress = 0
            },
            @{
                Title = "Optimize Rendering Performance"
                Description = "Profile and optimize the differential rendering system"
                Priority = [TaskPriority]::Low
                Status = [TaskStatus]::InProgress
                Progress = 30
            },
            @{
                Title = "Create Theme Editor"
                Description = "Build a visual theme editor screen"
                Priority = [TaskPriority]::Low
                Status = [TaskStatus]::Pending
                Progress = 0
            }
        )
        
        foreach ($taskData in $sampleTasks) {
            $task = [PmcTask]::new($taskData.Title, $taskData.Description, $taskData.Priority, "DEMO")
            $task.Status = $taskData.Status
            $task.Progress = $taskData.Progress
            
            if ($taskData.Progress -eq 100) {
                $task.Complete()
            }
            
            $dataManager.AddTask($task)
        }
        
        Write-Host "Created $($sampleTasks.Count) sample tasks" -ForegroundColor Green
    }
}
catch {
    Write-Warning "Failed to load sample data: $($_.Exception.Message)"
    # Continue anyway - app can run without data
}

#endregion

#region Start Application

try {
    Write-Host "`nStarting Axiom-Phoenix..." -ForegroundColor Cyan
    Write-Host "Press Ctrl+P to open the Command Palette" -ForegroundColor Yellow
    Write-Host "Press Ctrl+Q to exit`n" -ForegroundColor Yellow
    
    Start-Sleep -Seconds 2
    
    # Create initial screen
    $dashboardScreen = [DashboardScreen]::new($container)
    
    # Start the application
    Start-AxiomPhoenix -ServiceContainer $container -InitialScreen $dashboardScreen
}
catch {
    Write-Host "`nApplication error!" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    
    Write-Host "`nPress any key to exit..." -ForegroundColor White
    [Console]::ReadKey($true) | Out-Null
    exit 1
}
finally {
    # Ensure console is restored
    try {
        [Console]::CursorVisible = $true
        [Console]::Clear()
    }
    catch {}
}

#endregion


####\test-simple.ps1
# Simple test runner
$ErrorActionPreference = 'Stop'

try {
    Set-Location $PSScriptRoot
    
    # Load all files
    . .\AllBaseClasses.ps1
    . .\AllModels.ps1
    . .\AllComponents.ps1
    . .\AllScreens.ps1
    . .\AllFunctions.ps1
    . .\AllServices.ps1
    . .\AllRuntime.ps1
    
    # Create services
    $container = [ServiceContainer]::new()
    $container.Register("Logger", [Logger]::new())
    $container.Register("ThemeManager", [ThemeManager]::new())
    $container.Register("EventManager", [EventManager]::new())
    $container.Register("DataManager", [DataManager]::new())
    $container.Register("ActionService", [ActionService]::new())
    $container.Register("KeybindingService", [KeybindingService]::new())
    $container.Register("NavigationService", [NavigationService]::new())
    
    # Initialize theme
    $themeManager = $container.GetService("ThemeManager")
    $themeManager.LoadDefaultTheme()
    
    # Create and start application
    $dashboardScreen = [DashboardScreen]::new($container)
    Start-AxiomPhoenix -ServiceContainer $container -InitialScreen $dashboardScreen
}
catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor Gray
    Read-Host "Press Enter to exit"
}


####\test.ps1
# Test if classes and functions load
cd "C:\Users\jhnhe\Documents\GitHub\_XP\_mono"
.\Start.ps1 -LoadOnly

# Check if critical components exist
Write-Host "`nChecking critical components:" -ForegroundColor Cyan
Write-Host "TuiBuffer class: $([TuiBuffer] -ne $null)" -ForegroundColor Yellow
Write-Host "TuiCell class: $([TuiCell] -ne $null)" -ForegroundColor Yellow
Write-Host "ServiceContainer class: $([ServiceContainer] -ne $null)" -ForegroundColor Yellow
Write-Host "Start-TuiEngine function: $(Get-Command Start-TuiEngine -ErrorAction SilentlyContinue)" -ForegroundColor Yellow
Write-Host "Initialize-TuiEngine function: $(Get-Command Initialize-TuiEngine -ErrorAction SilentlyContinue)" -ForegroundColor Yellow


