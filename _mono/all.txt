####\New folder\AllBaseClasses.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ABC.###" to find specific sections.
# Each section ends with "END_PAGE: ABC.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#<!-- PAGE: ABC.001 - TuiAnsiHelper Class -->
#region TuiAnsiHelper - ANSI Code Generation with Truecolor Support

# ==============================================================================
# CLASS: TuiAnsiHelper
#
# INHERITS:
#   - None (Static Class)
#
# DEPENDENCIES:
#   - None from within the framework.
#
# PURPOSE:
#   A static utility class for generating ANSI escape codes. It specializes in
#   creating "truecolor" (24-bit) escape sequences from hex color strings,
#   which is essential for the framework's rich color support.
#
# KEY LOGIC:
#   - HexToRgb(): Parses a "#RRGGBB" hex string into its R, G, and B components.
#   - GetAnsiSequence(): Constructs the final ANSI escape code string by
#     combining foreground color, background color, and text attributes (bold,
#     italic, etc.) into a single sequence.
# ==============================================================================
class TuiAnsiHelper {
    static [hashtable] HexToRgb([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor) -or -not $hexColor.StartsWith("#") -or $hexColor.Length -ne 7) {
            # Cannot use Write-Log here as this file is loaded before AllFunctions.ps1
            return $null
        }
        try {
            return @{
                R = [System.Convert]::ToInt32($hexColor.Substring(1, 2), 16)
                G = [System.Convert]::ToInt32($hexColor.Substring(3, 2), 16)
                B = [System.Convert]::ToInt32($hexColor.Substring(5, 2), 16)
            }
        } catch {
            return $null
        }
    }

    static [string] GetAnsiSequence([string]$fgHex, [string]$bgHex, [hashtable]$attributes) {
        $sequences = [System.Collections.Generic.List[string]]::new()

        if (-not [string]::IsNullOrEmpty($fgHex)) {
            $rgb = [TuiAnsiHelper]::HexToRgb($fgHex)
            if ($rgb) { $sequences.Add("38;2;$($rgb.R);$($rgb.G);$($rgb.B)") }
        }

        if (-not [string]::IsNullOrEmpty($bgHex)) {
            $rgb = [TuiAnsiHelper]::HexToRgb($bgHex)
            if ($rgb) { $sequences.Add("48;2;$($rgb.R);$($rgb.G);$($rgb.B)") }
        }

        if ($attributes) {
            if ($attributes.Bold) { $sequences.Add("1") }
            if ($attributes.Italic) { $sequences.Add("3") }
            if ($attributes.Underline) { $sequences.Add("4") }
            if ($attributes.Strikethrough) { $sequences.Add("9") }
        }

        if ($sequences.Count -eq 0) { return "" }
        return "`e[$($sequences -join ';')m"
    }

    static [string] Reset() { return "`e[0m" }
}
#endregion
#<!-- END_PAGE: ABC.001 -->

#<!-- PAGE: ABC.002 - TuiCell Class -->
#region TuiCell Class - Core Compositor Unit with Truecolor Support

# ==============================================================================
# CLASS: TuiCell
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   Classes:
#     - TuiAnsiHelper (ABC.001)
#
# PURPOSE:
#   Represents a single character cell in the terminal grid. It encapsulates not
#   just the character, but its complete styling information: foreground color,
#   background color, attributes (bold, etc.), and Z-Index for layering.
#   This is the fundamental unit of rendering.
#
# KEY LOGIC:
#   - Stores colors as hex strings for truecolor support.
#   - `ToAnsiString()`: Uses `TuiAnsiHelper` to convert its properties into a
#     drawable string for the terminal.
#   - `DiffersFrom()`: An efficient method for comparing two cells, which is the
#     core of the differential rendering engine.
#   - `BlendWith()`: Defines how this cell is replaced by a cell from a layer
#     above it, respecting the Z-Index.
# ==============================================================================
class TuiCell {
    [char] $Char = ' '
    [string] $ForegroundColor = "#FFFFFF"
    [string] $BackgroundColor = "#000000"
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [bool] $Strikethrough = $false
    [int] $ZIndex = 0        
    [object] $Metadata = $null 

    TuiCell() { }
    TuiCell([char]$char) { $this.Char = $char }
    TuiCell([char]$char, [string]$fg, [string]$bg) {
        $this.Char = $char; $this.ForegroundColor = $fg; $this.BackgroundColor = $bg
    }
    TuiCell([char]$char, [string]$fg, [string]$bg, [bool]$bold, [bool]$italic, [bool]$underline, [bool]$strikethrough) {
        $this.Char = $char; $this.ForegroundColor = $fg; $this.BackgroundColor = $bg;
        $this.Bold = $bold; $this.Italic = $italic; $this.Underline = $underline; $this.Strikethrough = $strikethrough
    }
    TuiCell([object]$other) {
        $this.Char = $other.Char; $this.ForegroundColor = $other.ForegroundColor; $this.BackgroundColor = $other.BackgroundColor
        $this.Bold = $other.Bold; $this.Underline = $other.Underline; $this.Italic = $other.Italic; $this.Strikethrough = $other.Strikethrough
        $this.ZIndex = $other.ZIndex; $this.Metadata = $other.Metadata
    }

    [TuiCell] BlendWith([object]$other) {
        if ($null -eq $other) { return $this }
        if ($other.ZIndex -gt $this.ZIndex) { return [TuiCell]::new($other) }
        if ($other.ZIndex -lt $this.ZIndex) { return $this }
        return [TuiCell]::new($other)
    }

    [bool] DiffersFrom([object]$other) {
        if ($null -eq $other) { return $true }
        return ($this.Char -ne $other.Char -or $this.ForegroundColor -ne $other.ForegroundColor -or $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or $this.Underline -ne $other.Underline -or $this.Italic -ne $other.Italic -or
                $this.Strikethrough -ne $other.Strikethrough -or $this.ZIndex -ne $other.ZIndex)
    }

    [string] ToAnsiString() {
        $attributes = @{ Bold=$this.Bold; Italic=$this.Italic; Underline=$this.Underline; Strikethrough=$this.Strikethrough }
        return "$([TuiAnsiHelper]::GetAnsiSequence($this.ForegroundColor, $this.BackgroundColor, $attributes))$($this.Char)"
    }
}
#endregion
#<!-- END_PAGE: ABC.002 -->

#<!-- PAGE: ABC.003 - TuiBuffer Class -->
#region TuiBuffer Class - 2D Array of TuiCells

# ==============================================================================
# CLASS: TuiBuffer
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   Classes:
#     - TuiCell (ABC.002)
#
# PURPOSE:
#   A 2D grid of `TuiCell` objects that represents a rectangular area of the
#   terminal. It serves as an in-memory canvas for all UI components to draw
#   onto before being rendered to the screen.
#
# KEY LOGIC:
#   - `Cells`: The core `object[,]` array holding the TuiCell instances.
#   - Drawing Primitives: Provides methods like `SetCell`, `WriteString`, and
#     `FillRect` that allow components to draw content.
#   - `BlendBuffer`: The key compositing method. It overlays another buffer onto
#     this one, respecting the Z-Index of each cell to correctly layer content.
#   - `Resize`: Re-creates the cell grid with new dimensions, copying over the
#     old content.
# ==============================================================================
class TuiBuffer {
    $Cells
    [int] $Width             
    [int] $Height            
    [string] $Name            
    [bool] $IsDirty = $true  

    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.InitializeCells()
    }

    hidden [void] InitializeCells() {
        $tempArray = New-Object 'System.Object[,]' $this.Height,$this.Width
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $tempArray[$y,$x] = [TuiCell]::new()
            }
        }
        $this.Cells = $tempArray
    }

    [void] Clear([TuiCell]$fillCell = ([TuiCell]::new())) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell) 
            }
        }
        $this.IsDirty = $true
    }

    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) { return $null }
        return $this.Cells[$y, $x]
    }

    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    [void] WriteString([int]$x, [int]$y, [string]$text, [hashtable]$style = @{}) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) { return }
        
        $fg = $style.FG ?? "#FFFFFF"
        $bg = $style.BG ?? "#000000"
        $bold = [bool]($style.Bold ?? $false)
        $italic = [bool]($style.Italic ?? $false)
        $underline = [bool]($style.Underline ?? $false)
        $strikethrough = [bool]($style.Strikethrough ?? $false)
        $zIndex = [int]($style.ZIndex ?? 0)

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break } 
            if ($currentX -ge 0) {
                $cell = [TuiCell]::new($char, $fg, $bg, $bold, $italic, $underline, $strikethrough)
                $cell.ZIndex = $zIndex
                $this.SetCell($currentX, $y, $cell)
            }
            $currentX++
        }
    }

    [void] BlendBuffer([object]$other, [int]$offsetX, [int]$offsetY) {
        for ($y = 0; $y -lt $other.Height; $y++) {
            $targetY = $offsetY + $y
            if ($targetY -ge 0 -and $targetY -lt $this.Height) {
                for ($x = 0; $x -lt $other.Width; $x++) {
                    $targetX = $offsetX + $x
                    if ($targetX -ge 0 -and $targetX -lt $this.Width) {
                        $sourceCell = $other.GetCell($x, $y)
                        if ($sourceCell) {
                           $targetCell = $this.GetCell($targetX, $targetY)
                           $this.SetCell($targetX, $targetY, $targetCell.BlendWith($sourceCell))
                        }
                    }
                }
            }
        }
        $this.IsDirty = $true
    }

    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height") }
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                if ($sourceCell) { $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell)) }
            }
        }
        return $subBuffer
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight") }
        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height
        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.InitializeCells()
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)
        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }
        $this.IsDirty = $true
    }
    
    [void] FillRect([int]$x, [int]$y, [int]$width, [int]$height, [char]$char, [hashtable]$style = @{}) {
        $charString = [string]$char
        for ($py = $y; $py -lt $y + $height; $py++) {
            $this.WriteString($x, $py, $charString * $width, $style)
        }
    }
    
    [TuiBuffer] Clone() {
        $clone = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name)_Clone")
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $clone.Cells[$y, $x] = [TuiCell]::new($this.Cells[$y, $x])
            }
        }
        return $clone
    }
}
#endregion
#<!-- END_PAGE: ABC.003 -->

#<!-- PAGE: ABC.004 - UIElement Class -->
#region UIElement - Base Class for all UI Components

# ==============================================================================
# CLASS: UIElement
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   Classes:
#     - TuiBuffer (ABC.003)
#
# PURPOSE:
#   The abstract base class for ALL visual and interactive components in the
#   framework. It defines the common contract for position, size, visibility,
#   parent-child relationships, input handling, and the rendering lifecycle.
#
# KEY LOGIC:
#   - Defines core properties like X, Y, Width, Height, Parent, and Children.
#   - `_private_buffer`: Each element has its own TuiBuffer to draw on.
#   - `Render()` and `_RenderContent()`: The heart of the rendering pipeline.
#     `Render()` is the public entry point, while the virtual `_RenderContent()`
#     manages the on-demand rendering of the element itself and its children,
#     blending their buffers together.
#   - `HandleInput()`: A virtual method for components to implement their own
#     response to keyboard input.
#   - `RequestRedraw()`: A critical method that flags a component and its entire
#     parent hierarchy as "dirty", ensuring it gets redrawn on the next frame.
# ==============================================================================
class UIElement {
    [string] $Name = "UIElement" 
    [int] $X = 0; [int] $Y = 0; [int] $Width = 1; [int] $Height = 1
    [bool] $Visible = $true; [bool] $Enabled = $true
    [bool] $IsFocusable = $false; [bool] $IsFocused = $false
    [bool] $IsOverlay = $false
    [int] $TabIndex = 0; [int] $ZIndex = 0
    [UIElement] $Parent = $null 
    [System.Collections.Generic.List[UIElement]] $Children 
    
    hidden [TuiBuffer] $_private_buffer
    hidden [bool] $_needs_redraw = $true
    [hashtable] $Metadata = @{} 

    UIElement([string]$name = "UIElement") {
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        if ($this.Width -gt 0 -and $this.Height -gt 0) {
            $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        }
    }

    [hashtable] GetAbsolutePosition() {
        $absX = $this.X; $absY = $this.Y; $current = $this.Parent
        while ($current) { $absX += $current.X; $absY += $current.Y; $current = $current.Parent }
        return @{ X = $absX; Y = $absY }
    }

    [void] AddChild([UIElement]$child) {
        if ($child.Parent) { $child.Parent.RemoveChild($child) }
        $child.Parent = $this
        $this.Children.Add($child)
        if ($child.PSObject.Methods['AddedToParent']) { $child.AddedToParent() }
        $this.RequestRedraw()
    }

    [void] RemoveChild([UIElement]$child) {
        if ($this.Children.Remove($child)) {
            $child.Parent = $null
            if ($child.PSObject.Methods['RemovedFromParent']) { $child.RemovedFromParent() }
            $this.RequestRedraw()
        }
    }

    [void] RequestRedraw() {
        $this._needs_redraw = $true
        $this.Parent?.RequestRedraw()
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { return }
        if ($newHeight -le 0) { return }
        if ($this.Width -eq $newWidth -and $this.Height -eq $newHeight) { return }
        
        $this.Width = $newWidth
        $this.Height = $newHeight
        if ($this._private_buffer) { $this._private_buffer.Resize($newWidth, $newHeight) }
        else { $this._private_buffer = [TuiBuffer]::new($newWidth, $newHeight, "$($this.Name).Buffer") }
        
        $this.OnResize($newWidth, $newHeight)
        $this.RequestRedraw()
    }

    # --- VIRTUAL METHODS ---
    [void] OnRender() { if ($this._private_buffer) { $this._private_buffer.Clear() } }
    [void] OnResize([int]$newWidth, [int]$newHeight) { }
    [void] OnFocus() { }
    [void] OnBlur() { }
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) { return $false }

    [void] Cleanup() {
        foreach ($child in $this.Children) { $child.Cleanup() }
        $this.Children.Clear(); $this.Parent = $null; $this._private_buffer = $null
    }

    [void] Render() { if ($this.Visible) { $this._RenderContent() } }

    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }

        $parentDidRedraw = $this._needs_redraw
        if ($parentDidRedraw) {
            # Re-initialize buffer if dimensions are wrong
            if (($null -eq $this._private_buffer) -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
                $this._private_buffer = [TuiBuffer]::new([Math]::Max(1, $this.Width), [Math]::Max(1, $this.Height), "$($this.Name).Buffer")
            }
            $this.OnRender()
        }

        foreach ($child in $this.Children | Sort-Object ZIndex) { 
            if ($child.Visible) {
                $child.Render()
                if (($parentDidRedraw -or $child._needs_redraw) -and $child._private_buffer) {
                    $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
            }
        }
        $this._needs_redraw = $false
    }
    
    [TuiBuffer] GetBuffer() { return $this._private_buffer }
}
#endregion
#<!-- END_PAGE: ABC.004 -->

#<!-- PAGE: ABC.005 - Component Class -->
#region Component - A generic container component

# ==============================================================================
# CLASS: Component
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   - None
#
# PURPOSE:
#   A generic, empty container component that inherits from UIElement. It serves
#   as a basic building block or placeholder for composing UIs where a simple
#   grouping container is needed without the extra features of a `Panel`.
# ==============================================================================
class Component : UIElement {
    Component([string]$name) : base($name) { }
}
#endregion
#<!-- END_PAGE: ABC.005 -->

#<!-- PAGE: ABC.006 - Screen Class -->
#region Screen - Top-level Container for Application Views

# ==============================================================================
# CLASS: Screen
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Services:
#     - ServiceContainer (ABC.007)
#
# PURPOSE:
#   Represents a top-level application view, like a "Dashboard" or "Settings"
#   page. It's a specialized `UIElement` that fills the entire terminal window
#   and has direct access to the application's service container.
#
# KEY LOGIC:
#   - Its constructor accepts the main `ServiceContainer`, giving it and its
#     children access to all application services.
#   - Defines a screen-specific lifecycle (`Initialize`, `OnEnter`, `OnExit`,
#     `OnResume`) that is called by the `NavigationService`.
#   - `Cleanup` is responsible for unsubscribing from any events it subscribed
#     to during its lifetime, preventing memory leaks.
# ==============================================================================
class Screen : UIElement {
    [object]$ServiceContainer 
    [hashtable]$Services
    [System.Collections.Generic.Dictionary[string, string]] $EventSubscriptions 
    hidden [bool] $_isInitialized = $false
    
    Screen([string]$name, [object]$serviceContainer) : base($name) {
        $this.ServiceContainer = $serviceContainer
        $this.Services = [hashtable]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        if ($this.ServiceContainer) {
            $allServices = $this.ServiceContainer.GetAllRegisteredServices()
            foreach ($serviceInfo in $allServices) {
                $this.Services[$serviceInfo.Name] = $this.ServiceContainer.GetService($serviceInfo.Name)
            }
        }
    }

    # --- VIRTUAL METHODS for screen lifecycle ---
    [void] Initialize() { }
    [void] OnEnter() { }
    [void] OnExit() { }
    [void] OnResume() { }

    [void] Cleanup() {
        # Unsubscribe from events registered via SubscribeToEvent
        if (Get-Command 'Unsubscribe-Event' -ErrorAction SilentlyContinue) {
            foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
                try { Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value } catch {}
            }
        }
        $this.EventSubscriptions.Clear()
        
        # Call base UIElement cleanup
        ([UIElement]$this).Cleanup()
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        if (Get-Command 'Subscribe-Event' -ErrorAction SilentlyContinue) {
            $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
            $this.EventSubscriptions[$eventName] = $subscriptionId
        }
    }
}
#endregion
#<!-- END_PAGE: ABC.006 -->

#<!-- PAGE: ABC.007 - ServiceContainer Class -->
#region ServiceContainer Class

# ==============================================================================
# CLASS: ServiceContainer
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   - None
#
# PURPOSE:
#   A simple but effective Dependency Injection (DI) container. It is responsible
#   for instantiating, storing, and providing access to all the long-lived
#   service classes (e.g., DataManager, NavigationService) used by the application.
#
# KEY LOGIC:
#   - `Register`: Stores a pre-created instance of a service.
#   - `RegisterFactory`: Stores a scriptblock that can create a service on
#     demand. This allows for lazy-loading and singleton/transient lifestyles.
#   - `GetService`: The main retrieval method. It first checks for an already
#     created instance. If not found, it checks for a factory, invokes it, and
#     if the factory is a singleton, it caches the new instance for future calls.
#   - `_InitializeServiceFromFactory` includes logic to detect circular
#     dependencies during service resolution.
# ==============================================================================
class ServiceContainer {
    hidden [hashtable] $_services = @{}
    hidden [hashtable] $_serviceFactories = @{}

    [void] Register([string]$name, [object]$serviceInstance) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("name") }
        if ($null -eq $serviceInstance) { throw [System.ArgumentNullException]::new("serviceInstance") }
        if ($this._services.ContainsKey($name) -or $this._serviceFactories.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("A service with the name '$name' is already registered.")
        }
        $this._services[$name] = $serviceInstance
    }

    [void] RegisterFactory([string]$name, [scriptblock]$factory, [bool]$isSingleton = $true) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("name") }
        if ($null -eq $factory) { throw [System.ArgumentNullException]::new("factory") }
        if ($this._services.ContainsKey($name) -or $this._serviceFactories.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("A service with the name '$name' is already registered.")
        }
        $this._serviceFactories[$name] = @{ Factory = $factory; IsSingleton = $isSingleton; Instance = $null }
    }

    [object] GetService([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("name") }

        if ($this._services.ContainsKey($name)) { return $this._services[$name] }
        if ($this._serviceFactories.ContainsKey($name)) {
            return $this._InitializeServiceFromFactory($name, [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase))
        }

        $available = @($this.GetAllRegisteredServices().Name) -join ', '
        throw [System.InvalidOperationException]::new("Service '$name' not found. Available services: $available")
    }
    
    [object[]] GetAllRegisteredServices() {
        $list = [System.Collections.Generic.List[object]]::new()
        foreach ($key in $this._services.Keys) { $list.Add(@{ Name = $key; Type = 'Instance'; Initialized = $true; Lifestyle = 'Singleton' }) }
        foreach ($key in $this._serviceFactories.Keys) {
            $factoryInfo = $this._serviceFactories[$key]
            $list.Add(@{ Name = $key; Type = 'Factory'; Initialized = ($null -ne $factoryInfo.Instance); Lifestyle = if ($factoryInfo.IsSingleton) { 'Singleton' } else { 'Transient' } })
        }
        return $list.ToArray() | Sort-Object Name
    }

    [void] Cleanup() {
        $instancesToClean = [System.Collections.Generic.List[object]]::new()
        $instancesToClean.AddRange($this._services.Values)
        $this._serviceFactories.Values | Where-Object { $_.IsSingleton -and $_.Instance } | ForEach-Object { $instancesToClean.Add($_.Instance) }

        foreach ($service in $instancesToClean) {
            if ($service -is [System.IDisposable]) { try { $service.Dispose() } catch { } }
        }
        
        $this._services.Clear(); $this._serviceFactories.Clear()
    }

    hidden [object] _InitializeServiceFromFactory([string]$name, [System.Collections.Generic.HashSet[string]]$resolutionChain) {
        $factoryInfo = $this._serviceFactories[$name]
        if ($factoryInfo.IsSingleton -and $factoryInfo.Instance) { return $factoryInfo.Instance }
        if ($resolutionChain.Contains($name)) { throw [System.InvalidOperationException]::new("Circular dependency detected while resolving service '$name'.") }
        
        $resolutionChain.Add($name) | Out-Null
        $serviceInstance = & $factoryInfo.Factory $this
        if ($factoryInfo.IsSingleton) { $factoryInfo.Instance = $serviceInstance }
        $resolutionChain.Remove($name) | Out-Null
        
        return $serviceInstance
    }
}
#endregion
#<!-- END_PAGE: ABC.007 -->


####\New folder\AllComponents.ps1

#`path`: `C:\\Users\\jhnhe\\Documents\\GitHub\\_XP\\_mono\\AllComponents.ps1`

# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

##<!-- PAGE: ACO.001 - LabelComponent Class -->
#region Core UI Components

# ==============================================================================
# CLASS: LabelComponent
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Functions:
#     - Get-ThemeColor (AFU.004)
#     - Write-TuiText (AFU.001)
#
# PURPOSE:
#   Renders a single line of static, non-interactive text.
#
# KEY LOGIC:
#   OnRender() clears its buffer and uses Write-TuiText to draw its Text
#   property using theme-aware colors. It is not focusable.
# ==============================================================================
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor

    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 30  # Increased default width
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Clear buffer with theme background
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Get foreground color
        if ($this.ForegroundColor) {
            if ($this.ForegroundColor -is [ConsoleColor]) {
                # Convert ConsoleColor to hex if needed
                $fg = Get-ThemeColor("Foreground") # Use theme default instead
            } else {
                $fg = $this.ForegroundColor # Assume it's already hex
            }
        } else {
            $fg = Get-ThemeColor("Foreground")
        }
        
        # Draw text
        Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $this.Text -Style @{ FG = $fg; BG = $bgColor }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}
#<!-- END_PAGE: ACO.001 -->

#<!-- PAGE: ACO.002 - ButtonComponent Class -->
# ==============================================================================
# CLASS: ButtonComponent
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Functions:
#     - Get-ThemeColor (AFU.004)
#     - Write-TuiText (AFU.001)
#
# PURPOSE:
#   An interactive, focusable button that executes a scriptblock on click.
#
# KEY LOGIC:
#   - OnRender(): Changes its foreground/background colors based on its
#     IsFocused, IsPressed, and Enabled states, pulling colors from the
#     ThemeManager.
#   - HandleInput(): Listens for Enter or Spacebar keys to invoke the OnClick
#     scriptblock and briefly set the IsPressed state for visual feedback.
# ==============================================================================
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick

    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Clear buffer with theme background
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Determine colors based on state
        $fgColor = "#FFFFFF"
        $bgColor = "#333333"
        
        if ($this.IsPressed) {
            $fgColor = Get-ThemeColor("button.pressed.fg")
            $bgColor = Get-ThemeColor("button.pressed.bg")
        }
        elseif ($this.IsFocused) {
            $fgColor = Get-ThemeColor("button.focused.fg") 
            $bgColor = Get-ThemeColor("button.focused.bg")
        }
        elseif (-not $this.Enabled) {
            $fgColor = Get-ThemeColor("button.disabled.fg")
            $bgColor = Get-ThemeColor("button.disabled.bg")
        }
        else {
            $fgColor = Get-ThemeColor("button.normal.fg")
            $bgColor = Get-ThemeColor("button.normal.bg")
        }
        
        # Draw button background
        $style = @{ FG = $fgColor; BG = $bgColor }
        $this._private_buffer.FillRect(0, 0, $this.Width, $this.Height, ' ', $style)
        
        # Draw button text centered
        if (-not [string]::IsNullOrEmpty($this.Text)) {
            $textX = [Math]::Max(0, [Math]::Floor(($this.Width - $this.Text.Length) / 2))
            $textY = [Math]::Floor($this.Height / 2)
            
            Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -Style $style
        }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            try {
                $this.IsPressed = $true
                $this.RequestRedraw()
                
                if ($this.OnClick) {
                    & $this.OnClick
                }
                
                Start-Sleep -Milliseconds 50
                $this.IsPressed = $false
                $this.RequestRedraw()
                
                return $true
            }
            catch {
                $this.IsPressed = $false
                $this.RequestRedraw()
            }
        }
        return $false
    }
}

#<!-- END_PAGE: ACO.002 -->

#<!-- PAGE: ACO.003 - TextBoxComponent Class -->
# ==============================================================================
# CLASS: TextBoxComponent
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Functions:
#     - Get-ThemeColor (AFU.004)
#     - Write-TuiBox (AFU.001)
#     - Write-TuiText (AFU.001)
#
# PURPOSE:
#   A single-line text input field with placeholder text, cursor control, and
#   horizontal scrolling.
#
# KEY LOGIC:
#   - OnRender(): Draws a border and displays either the Text or Placeholder
#     property. It calculates a _scrollOffset to ensure the cursor is always
#     visible within the text area. The cursor is rendered non-destructively
#     by inverting the colors of the TuiCell beneath it.
#   - HandleInput(): Manages character insertion/deletion, cursor movement
#     (arrows, home, end), and invokes the OnChange scriptblock when the text
#     is modified.
# ==============================================================================
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [ValidateRange(1, [int]::MaxValue)][int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    hidden [int]$_scrollOffset = 0
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    [string]$PlaceholderColor = "#808080"

    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $bgColor = Get-ThemeColor("input.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        $fgColor = if ($this.IsFocused) { Get-ThemeColor("input.foreground") } else { Get-ThemeColor("Subtle") }
        $borderColorValue = if ($this.IsFocused) { Get-ThemeColor("Primary") } else { Get-ThemeColor("component.border") }
        
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
            -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            $contentY = 1
            $contentStartX = 1
            $contentWidth = $this.Width - 2
            
            if ($this.Text.Length -eq 0 -and $this.Placeholder) {
                $placeholderText = if ($this.Placeholder.Length -gt $contentWidth) {
                    $this.Placeholder.Substring(0, $contentWidth)
                } else { $this.Placeholder }
                
                $textStyle = @{ FG = Get-ThemeColor("input.placeholder"); BG = $bgColor }
                Write-TuiText -Buffer $this._private_buffer -X $contentStartX -Y $contentY -Text $placeholderText -Style $textStyle
            }
            else {
                if ($this.CursorPosition -lt $this._scrollOffset) {
                    $this._scrollOffset = $this.CursorPosition
                }
                elseif ($this.CursorPosition -ge ($this._scrollOffset + $contentWidth)) {
                    $this._scrollOffset = $this.CursorPosition - $contentWidth + 1
                }
                
                $visibleText = ""
                if ($this.Text.Length -gt 0) {
                    $endPos = [Math]::Min($this._scrollOffset + $contentWidth, $this.Text.Length)
                    if ($this._scrollOffset -lt $this.Text.Length) {
                        $visibleText = $this.Text.Substring($this._scrollOffset, $endPos - $this._scrollOffset)
                    }
                }
                
                if ($visibleText) {
                    $textStyle = @{ FG = $fgColor; BG = $bgColor }
                    Write-TuiText -Buffer $this._private_buffer -X $contentStartX -Y $contentY -Text $visibleText -Style $textStyle
                }
                
                if ($this.IsFocused) {
                    $cursorScreenPos = $this.CursorPosition - $this._scrollOffset
                    if ($cursorScreenPos -ge 0 -and $cursorScreenPos -lt $contentWidth) {
                        $cursorX = $contentStartX + $cursorScreenPos
                        $cellUnderCursor = $this._private_buffer.GetCell($cursorX, $contentY)
                        $cursorFg = $cellUnderCursor.BackgroundColor
                        $cursorBg = $cellUnderCursor.ForegroundColor
                        $newCell = [TuiCell]::new($cellUnderCursor.Char, $cursorBg, $cursorFg, $true)
                        $this._private_buffer.SetCell($cursorX, $contentY, $newCell)
                    }
                }
            }
            
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldText = $this.Text
        
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) { if ($this.CursorPosition -gt 0) { $this.CursorPosition-- } }
            ([ConsoleKey]::RightArrow) { if ($this.CursorPosition -lt $this.Text.Length) { $this.CursorPosition++ } }
            ([ConsoleKey]::Home) { $this.CursorPosition = 0 }
            ([ConsoleKey]::End) { $this.CursorPosition = $this.Text.Length }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPosition, 1)
                }
            }
            default {
                if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                    if ($this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    }
                }
                else { $handled = $false }
            }
        }
        
        if ($handled) {
            if ($oldText -ne $this.Text -and $this.OnChange) {
                try { & $this.OnChange $this $this.Text } catch {
                    Write-Log -Level Warning -Message "Error in TextBoxComponent '$($this.Name)' OnChange handler: $($_.Exception.Message)"
                }
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

#<!-- END_PAGE: ACO.003 -->

#<!-- PAGE: ACO.004 - CheckBoxComponent Class -->
# ==============================================================================
# CLASS: CheckBoxComponent
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Functions:
#     - Get-ThemeColor (AFU.004)
#     - Write-TuiText (AFU.001)
#
# PURPOSE:
#   Represents a boolean state (true/false) that the user can toggle.
#
# KEY LOGIC:
#   - OnRender(): Displays a box with an 'X' or a space depending on the
#     'Checked' property, alongside its descriptive text.
#   - HandleInput(): Listens for the Spacebar to toggle the 'Checked' state and
#     invokes the OnChange scriptblock.
# ==============================================================================
class CheckBoxComponent : UIElement {
    [string]$Text = ""
    [bool]$Checked = $false
    [scriptblock]$OnChange

    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        $fgColor = if ($this.IsFocused) { Get-ThemeColor("Primary") } else { Get-ThemeColor("Foreground") }
        $checkMark = if ($this.Checked) { "[X]" } else { "[ ]" }
        $fullText = "$checkMark $($this.Text)"
        
        Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $fullText -Style @{ FG = $fgColor; BG = $bgColor }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar) {
            $this.Checked = -not $this.Checked
            if ($this.OnChange) {
                try { & $this.OnChange $this $this.Checked } catch {
                    Write-Log -Level Warning -Message "Error in CheckBoxComponent '$($this.Name)' OnChange handler: $($_.Exception.Message)"
                }
            }
            $this.RequestRedraw()
            return $true
        }
        
        return $false
    }
}

#<!-- END_PAGE: ACO.004 -->

#<!-- PAGE: ACO.005 - RadioButtonComponent Class -->
# ==============================================================================
# CLASS: RadioButtonComponent
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Functions:
#     - Get-ThemeColor (AFU.004)
#     - Write-TuiText (AFU.001)
#
# PURPOSE:
#   Provides an exclusive selection within a named group. Only one radio button
#   in a group can be selected at a time.
#
# KEY LOGIC:
#   - A static hashtable `_groups` tracks all radio button instances by their
#     `GroupName`.
#   - `AddedToParent` lifecycle hook registers the instance with its group.
#   - `Select()` method is the core logic: it sets its own `Selected` state to
#     true and iterates through all other buttons in the same group, setting
#     their state to false.
#   - `HandleInput` calls `Select()` when the Spacebar is pressed.
# ==============================================================================
class RadioButtonComponent : UIElement {
    [string]$Text = ""
    [bool]$Selected = $false
    [string]$GroupName = "default"
    [scriptblock]$OnChange
    static [hashtable]$_groups = @{}

    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        $fgColor = if ($this.IsFocused) { Get-ThemeColor("Primary") } else { Get-ThemeColor("Foreground") }
        $radioMark = if ($this.Selected) { "(o)" } else { "( )" }
        $fullText = "$radioMark $($this.Text)"
        
        Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $fullText -Style @{ FG = $fgColor; BG = $bgColor }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar -and -not $this.Selected) {
            $this.Select()
            return $true
        }
        
        return $false
    }

    [void] Select() {
        if ([RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            foreach ($radio in [RadioButtonComponent]::_groups[$this.GroupName]) {
                if ($radio -ne $this -and $radio.Selected) {
                    $radio.Selected = $false
                    $radio.RequestRedraw()
                    if ($radio.OnChange) {
                        try { & $radio.OnChange $radio $false } catch {
                            Write-Log -Level Warning -Message "Error in RadioButtonComponent '$($radio.Name)' OnChange handler: $($_.Exception.Message)"
                        }
                    }
                }
            }
        }
        
        $this.Selected = $true
        $this.RequestRedraw()
        if ($this.OnChange) {
            try { & $this.OnChange $this $true } catch {
                Write-Log -Level Warning -Message "Error in RadioButtonComponent '$($this.Name)' OnChange handler: $($_.Exception.Message)"
            }
        }
    }

    [void] AddedToParent() {
        if (-not [RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            [RadioButtonComponent]::_groups[$this.GroupName] = [List[RadioButtonComponent]]::new()
        }
        [RadioButtonComponent]::_groups[$this.GroupName].Add($this)
    }

    [void] RemovedFromParent() {
        if ([RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            [RadioButtonComponent]::_groups[$this.GroupName].Remove($this)
        }
    }
}

#endregion Core UI Components

#region Advanced Components

#<!-- END_PAGE: ACO.005 -->

#<!-- PAGE: ACO.006 - MultilineTextBoxComponent Class -->
# ==============================================================================
# CLASS: MultilineTextBoxComponent
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Functions:
#     - Get-ThemeColor (AFU.004)
#     - Write-TuiBox (AFU.001)
#     - Write-TuiText (AFU.001)
#
# PURPOSE:
#   A full-featured multi-line text editor component with both vertical and
#   horizontal scrolling, word wrapping, and standard text editing controls.
#
# KEY LOGIC:
#   - State is stored in a `[List[string]]$Lines` property.
#   - `OnRender` calculates both vertical (`ScrollOffsetY`) and horizontal
#     (`ScrollOffsetX`) scroll offsets to keep the cursor in the viewport. It
#     then renders the visible subset of lines.
#   - `HandleInput` implements a comprehensive state machine for text editing,
#     including character insertion, deletion, line breaks (Enter), merging
#     lines (Backspace/Delete at edges), and cursor navigation.
# ==============================================================================
class MultilineTextBoxComponent : UIElement {
    [List[string]]$Lines
    [int]$CursorLine = 0
    [int]$CursorColumn = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [bool]$ReadOnly = $false
    [scriptblock]$OnChange
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    
    MultilineTextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Lines = [List[string]]::new()
        $this.Lines.Add("")
        $this.Width = 40
        $this.Height = 10
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor -ColorName "input.background" -DefaultColor $this.BackgroundColor
            $fgColor = Get-ThemeColor -ColorName "input.foreground" -DefaultColor $this.ForegroundColor
            $borderColorValue = if ($this.IsFocused) { Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF" } else { Get-ThemeColor -ColorName "component.border" -DefaultColor $this.BorderColor }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
            
            if ($this.CursorLine -lt $this.ScrollOffsetY) { $this.ScrollOffsetY = $this.CursorLine }
            elseif ($this.CursorLine -ge $this.ScrollOffsetY + $contentHeight) { $this.ScrollOffsetY = $this.CursorLine - $contentHeight + 1 }
            
            if ($this.CursorColumn -lt $this.ScrollOffsetX) { $this.ScrollOffsetX = $this.CursorColumn }
            elseif ($this.CursorColumn -ge $this.ScrollOffsetX + $contentWidth) { $this.ScrollOffsetX = $this.CursorColumn - $contentWidth + 1 }
            
            for ($y = 0; $y -lt $contentHeight; $y++) {
                $lineIndex = $y + $this.ScrollOffsetY
                if ($lineIndex -lt $this.Lines.Count) {
                    $line = $this.Lines[$lineIndex]
                    $visiblePart = ""
                    
                    if ($line.Length -gt $this.ScrollOffsetX) {
                        $endPos = [Math]::Min($this.ScrollOffsetX + $contentWidth, $line.Length)
                        $visiblePart = $line.Substring($this.ScrollOffsetX, $endPos - $this.ScrollOffsetX)
                    }
                    
                    if ($visiblePart) {
                        Write-TuiText -Buffer $this._private_buffer -X 1 -Y ($y + 1) -Text $visiblePart -Style @{ FG = $fgColor; BG = $bgColor }
                    }
                }
            }
            
            if ($this.IsFocused -and -not $this.ReadOnly) {
                $cursorScreenY = $this.CursorLine - $this.ScrollOffsetY + 1
                $cursorScreenX = $this.CursorColumn - $this.ScrollOffsetX + 1
                
                if ($cursorScreenY -ge 1 -and $cursorScreenY -lt $this.Height - 1 -and
                    $cursorScreenX -ge 1 -and $cursorScreenX -lt $this.Width - 1) {
                    
                    $currentLine = $this.Lines[$this.CursorLine]
                    $cursorChar = if ($this.CursorColumn -lt $currentLine.Length) { $currentLine[$this.CursorColumn] } else { ' ' }
                    
                    $this._private_buffer.SetCell($cursorScreenX, $cursorScreenY,
                        [TuiCell]::new($cursorChar, $bgColor, $fgColor))
                }
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.ReadOnly) { return $false }
        
        $handled = $true
        $changed = $false
        
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorColumn -gt 0) { $this.CursorColumn-- }
                elseif ($this.CursorLine -gt 0) {
                    $this.CursorLine--
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.CursorColumn -lt $this.Lines[$this.CursorLine].Length) { $this.CursorColumn++ }
                elseif ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.CursorLine++
                    $this.CursorColumn = 0
                }
            }
            ([ConsoleKey]::UpArrow) {
                if ($this.CursorLine -gt 0) {
                    $this.CursorLine--
                    $this.CursorColumn = [Math]::Min($this.CursorColumn, $this.Lines[$this.CursorLine].Length)
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.CursorLine++
                    $this.CursorColumn = [Math]::Min($this.CursorColumn, $this.Lines[$this.CursorLine].Length)
                }
            }
            ([ConsoleKey]::Home) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) { $this.CursorLine = 0 }
                $this.CursorColumn = 0
            }
            ([ConsoleKey]::End) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) { $this.CursorLine = $this.Lines.Count - 1 }
                $this.CursorColumn = $this.Lines[$this.CursorLine].Length
            }
            ([ConsoleKey]::Enter) {
                $currentLine = $this.Lines[$this.CursorLine]
                $this.Lines[$this.CursorLine] = $currentLine.Substring(0, $this.CursorColumn)
                $this.Lines.Insert($this.CursorLine + 1, $currentLine.Substring($this.CursorColumn))
                $this.CursorLine++
                $this.CursorColumn = 0
                $changed = $true
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorColumn -gt 0) {
                    $this.Lines[$this.CursorLine] = $this.Lines[$this.CursorLine].Remove($this.CursorColumn - 1, 1)
                    $this.CursorColumn--
                    $changed = $true
                }
                elseif ($this.CursorLine -gt 0) {
                    $previousLineLength = $this.Lines[$this.CursorLine - 1].Length
                    $this.Lines[$this.CursorLine - 1] += $this.Lines[$this.CursorLine]
                    $this.Lines.RemoveAt($this.CursorLine)
                    $this.CursorLine--
                    $this.CursorColumn = $previousLineLength
                    $changed = $true
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this.CursorColumn -lt $this.Lines[$this.CursorLine].Length) {
                    $this.Lines[$this.CursorLine] = $this.Lines[$this.CursorLine].Remove($this.CursorColumn, 1)
                    $changed = $true
                }
                elseif ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.Lines[$this.CursorLine] += $this.Lines[$this.CursorLine + 1]
                    $this.Lines.RemoveAt($this.CursorLine + 1)
                    $changed = $true
                }
            }
            default {
                if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                    $this.Lines[$this.CursorLine] = $this.Lines[$this.CursorLine].Insert($this.CursorColumn, $key.KeyChar)
                    $this.CursorColumn++
                    $changed = $true
                }
                else { $handled = $false }
            }
        }
        
        if ($handled) {
            if ($changed -and $this.OnChange) {
                try { & $this.OnChange $this $this.GetText() } catch {
                    Write-Log -Level Warning -Message "Error in MultilineTextBoxComponent '$($this.Name)' OnChange handler: $($_.Exception.Message)"
                }
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    [string] GetText() { return ($this.Lines -join "`n") }
    
    [void] SetText([string]$text) {
        $this.Lines.Clear()
        $this.Lines.AddRange(($text -split "`n"))
        if ($this.Lines.Count -eq 0) { $this.Lines.Add("") }
        $this.CursorLine = 0
        $this.CursorColumn = 0
        $this.ScrollOffsetY = 0
        $this.ScrollOffsetX = 0
        $this.RequestRedraw()
    }
}

#<!-- END_PAGE: ACO.006 -->

#<!-- PAGE: ACO.007 - NumericInputComponent Class -->
# ===== CLASS: NumericInputComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Numeric input with spinners and validation
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$Minimum = [double]::MinValue
    [double]$Maximum = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [scriptblock]$OnChange
    hidden [string]$_textValue = "0"
    hidden [int]$_cursorPosition = 1
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    
    NumericInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 15
        $this.Height = 3
        $this._textValue = $this.FormatValue($this.Value)
        $this._cursorPosition = $this._textValue.Length
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor -ColorName "input.background" -DefaultColor $this.BackgroundColor
            $fgColor = Get-ThemeColor -ColorName "input.foreground" -DefaultColor $this.ForegroundColor
            $borderColorValue = if ($this.IsFocused) { Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF" } else { Get-ThemeColor -ColorName "component.border" -DefaultColor $this.BorderColor }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            # Draw spinners
            $spinnerColor = if ($this.IsFocused) { "#FFFF00" } else { "#808080" }
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new('', $spinnerColor, $bgColor))
            $this._private_buffer.SetCell($this.Width - 2, $this.Height - 2, [TuiCell]::new('', $spinnerColor, $bgColor))
            
            # Draw value
            $displayValue = $this._textValue
            $maxTextWidth = $this.Width - 4  # Border + spinner
            if ($displayValue.Length -gt $maxTextWidth) {
                $displayValue = $displayValue.Substring(0, $maxTextWidth)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayValue -Style @{ FG = $fgColor; BG = $bgColor }
            
            # Draw cursor if focused
            if ($this.IsFocused -and $this._cursorPosition -le $displayValue.Length) {
                $cursorX = 1 + $this._cursorPosition
                if ($cursorX -lt $this.Width - 2) {
                    if ($this._cursorPosition -lt $this._textValue.Length) {
                        $cursorChar = $this._textValue[$this._cursorPosition]
                    } else { 
                        $cursorChar = ' ' 
                    }
                    
                    $this._private_buffer.SetCell($cursorX, 1, 
                        [TuiCell]::new($cursorChar, $bgColor, $fgColor))
                }
            }
        }
        catch {}
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldValue = $this.Value
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.IncrementValue()
            }
            ([ConsoleKey]::DownArrow) {
                $this.DecrementValue()
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this._cursorPosition -gt 0) {
                    $this._cursorPosition--
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this._cursorPosition -lt $this._textValue.Length) {
                    $this._cursorPosition++
                }
            }
            ([ConsoleKey]::Home) {
                $this._cursorPosition = 0
            }
            ([ConsoleKey]::End) {
                $this._cursorPosition = $this._textValue.Length
            }
            ([ConsoleKey]::Backspace) {
                if ($this._cursorPosition -gt 0) {
                    $this._textValue = $this._textValue.Remove($this._cursorPosition - 1, 1)
                    $this._cursorPosition--
                    $this.ParseAndValidate()
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this._cursorPosition -lt $this._textValue.Length) {
                    $this._textValue = $this._textValue.Remove($this._cursorPosition, 1)
                    $this.ParseAndValidate()
                }
            }
            ([ConsoleKey]::Enter) {
                $this.ParseAndValidate()
            }
            default {
                if ($key.KeyChar -and ($key.KeyChar -match '[0-9.\-]')) {
                    # Allow only valid numeric characters
                    if ($key.KeyChar -eq '.' -and $this._textValue.Contains('.')) {
                        # Only one decimal point allowed
                        $handled = $false
                    }
                    elseif ($key.KeyChar -eq '-' -and ($this._cursorPosition -ne 0 -or $this._textValue.Contains('-'))) {
                        # Minus only at beginning
                        $handled = $false
                    }
                    else {
                        $this._textValue = $this._textValue.Insert($this._cursorPosition, $key.KeyChar)
                        $this._cursorPosition++
                        $this.ParseAndValidate()
                    }
                }
                else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            if ($oldValue -ne $this.Value -and $this.OnChange) {
                try { & $this.OnChange $this $this.Value } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    hidden [void] IncrementValue() {
        $newValue = $this.Value + $this.Step
        if ($newValue -le $this.Maximum) {
            $this.Value = $newValue
            $this._textValue = $this.FormatValue($this.Value)
            $this._cursorPosition = $this._textValue.Length
        }
    }
    
    hidden [void] DecrementValue() {
        $newValue = $this.Value - $this.Step
        if ($newValue -ge $this.Minimum) {
            $this.Value = $newValue
            $this._textValue = $this.FormatValue($this.Value)
            $this._cursorPosition = $this._textValue.Length
        }
    }
    
    hidden [void] ParseAndValidate() {
        try {
            $parsedValue = [double]::Parse($this._textValue)
            $parsedValue = [Math]::Max($this.Minimum, [Math]::Min($this.Maximum, $parsedValue))
            $this.Value = $parsedValue
        }
        catch {
            # Keep current value if parse fails
        }
    }
    
    hidden [string] FormatValue([double]$value) {
        if ($this.DecimalPlaces -eq 0) {
            return [Math]::Truncate($value).ToString()
        }
        else {
            return $value.ToString("F$($this.DecimalPlaces)")
        }
    }
}

#<!-- END_PAGE: ACO.007 -->

#<!-- PAGE: ACO.008 - DateInputComponent Class -->
# ===== CLASS: DateInputComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Date picker with calendar interface
class DateInputComponent : UIElement {
    [DateTime]$Value = [DateTime]::Today
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [scriptblock]$OnChange
    hidden [bool]$_showCalendar = $false
    hidden [DateTime]$_viewMonth
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    
    DateInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 1  # Expands to 10 when calendar shown
        $this._viewMonth = $this.Value
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor -ColorName "input.background" -DefaultColor $this.BackgroundColor
            $fgColor = Get-ThemeColor -ColorName "input.foreground" -DefaultColor $this.ForegroundColor
            if ($this.IsFocused) { 
                $borderColorValue = Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF" 
            } else { 
                $borderColorValue = Get-ThemeColor -ColorName "component.border" -DefaultColor $this.BorderColor 
            }
            
            # Adjust height based on calendar visibility
            if ($this._showCalendar) { 
                $renderHeight = 10 
            } else { 
                $renderHeight = 3 
            }
            if ($this.Height -ne $renderHeight) {
                $this.Height = $renderHeight
                $this.RequestRedraw()
                return
            }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw text box
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height 3 `
                -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            # Draw date value
            $dateStr = $this.Value.ToString("yyyy-MM-dd")
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $dateStr -Style @{ FG = $fgColor; BG = $bgColor }
            
            # Draw calendar icon
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new('', $borderColorValue, $bgColor))
            
            # Draw calendar if shown
            if ($this._showCalendar) {
                $this.DrawCalendar(0, 3)
            }
        }
        catch {}
    }
    
    hidden [void] DrawCalendar([int]$startX, [int]$startY) {
        $bgColor = "#000000"
        $fgColor = "#FFFFFF"
        $headerColor = "#FFFF00"
        $selectedColor = "#00FFFF"
        $todayColor = "#00FF00"
        
        # Calendar border
        Write-TuiBox -Buffer $this._private_buffer -X $startX -Y $startY `
            -Width $this.Width -Height 7 `
            -Style @{ BorderFG = "#808080"; BG = $bgColor; BorderStyle = "Single" }
        
        # Month/Year header
        $monthYearStr = $this._viewMonth.ToString("MMMM yyyy")
        $headerX = $startX + [Math]::Floor(($this.Width - $monthYearStr.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $headerX -Y ($startY + 1) -Text $monthYearStr -Style @{ FG = $headerColor; BG = $bgColor }
        
        # Navigation arrows
        $this._private_buffer.SetCell($startX + 1, $startY + 1, [TuiCell]::new('<', $headerColor, $bgColor))
        $this._private_buffer.SetCell($startX + $this.Width - 2, $startY + 1, [TuiCell]::new('>', $headerColor, $bgColor))
        
        # Day headers
        $dayHeaders = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
        $dayX = $startX + 2
        foreach ($day in $dayHeaders) {
            Write-TuiText -Buffer $this._private_buffer -X $dayX -Y ($startY + 2) -Text $day -Style @{ FG = "#808080"; BG = $bgColor }
            $dayX += 3
        }
        
        # Calendar days
        $firstDay = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, 1)
        $startDayOfWeek = [int]$firstDay.DayOfWeek
        $daysInMonth = [DateTime]::DaysInMonth($this._viewMonth.Year, $this._viewMonth.Month)
        
        $currentDay = 1
        $today = [DateTime]::Today
        
        for ($week = 0; $week -lt 6; $week++) {
            if ($currentDay -gt $daysInMonth) { break }
            
            for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                if ($currentDay -gt $daysInMonth) { break }
                
                $dayX = $startX + 2 + ($dayOfWeek * 3)
                $dayY = $startY + 3 + $week
                
                $currentDate = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, $currentDay)
                $dayStr = $currentDay.ToString().PadLeft(2)
                
                # Determine color
                $dayColor = $fgColor
                if ($currentDate -eq $this.Value) {
                    $dayColor = $selectedColor
                }
                elseif ($currentDate -eq $today) {
                    $dayColor = $todayColor
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $dayX -Y $dayY -Text $dayStr -Style @{ FG = $dayColor; BG = $bgColor }
                $currentDay++
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldValue = $this.Value
        
        if (-not $this._showCalendar) {
            switch ($key.Key) {
                ([ConsoleKey]::Enter) { $this._showCalendar = $true }
                ([ConsoleKey]::Spacebar) { $this._showCalendar = $true }
                ([ConsoleKey]::DownArrow) { $this._showCalendar = $true }
                default { $handled = $false }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) { 
                    $this._showCalendar = $false 
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Previous month
                        $this._viewMonth = $this._viewMonth.AddMonths(-1)
                    }
                    else {
                        # Previous day
                        $newDate = $this.Value.AddDays(-1)
                        if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                            $this.Value = $newDate
                            $this._viewMonth = $newDate
                        }
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Next month
                        $this._viewMonth = $this._viewMonth.AddMonths(1)
                    }
                    else {
                        # Next day
                        $newDate = $this.Value.AddDays(1)
                        if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                            $this.Value = $newDate
                            $this._viewMonth = $newDate
                        }
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    # Previous week
                    $newDate = $this.Value.AddDays(-7)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._viewMonth = $newDate
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    # Next week
                    $newDate = $this.Value.AddDays(7)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._viewMonth = $newDate
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this._showCalendar = $false
                }
                ([ConsoleKey]::T) {
                    # Today
                    $today = [DateTime]::Today
                    if ($today -ge $this.MinDate -and $today -le $this.MaxDate) {
                        $this.Value = $today
                        $this._viewMonth = $today
                    }
                }
                default { $handled = $false }
            }
        }
        
        if ($handled) {
            if ($oldValue -ne $this.Value -and $this.OnChange) {
                try { & $this.OnChange $this $this.Value } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

#<!-- END_PAGE: ACO.008 -->

#<!-- PAGE: ACO.009 - ComboBoxComponent Class -->
# ===== CLASS: ComboBoxComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Dropdown with search and overlay rendering
class ComboBoxComponent : UIElement {
    [List[object]]$Items
    [int]$SelectedIndex = -1
    [string]$DisplayMember = ""
    [string]$ValueMember = ""
    [bool]$IsEditable = $false
    [string]$Text = ""
    [scriptblock]$OnSelectionChanged
    hidden [bool]$_isDropdownOpen = $false
    hidden [int]$_highlightedIndex = -1
    hidden [string]$_searchText = ""
    hidden [List[int]]$_filteredIndices
    
    ComboBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.Items = [List[object]]::new()
        $this._filteredIndices = [List[int]]::new()
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor("input.background")
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw main box
            if ($this.IsFocused) { 
                $borderColor = Get-ThemeColor("Primary") 
            } else { 
                $borderColor = Get-ThemeColor("component.border") 
            }
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = $borderColor; BG = $bgColor; BorderStyle = "Single" }
            
            # Draw selected text or placeholder
            $displayText = ""
            if ($this.IsEditable) {
                $displayText = $this._searchText
            }
            elseif ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
                $item = $this.Items[$this.SelectedIndex]
                $displayText = $this.GetDisplayText($item)
            }
            
            if ($displayText) { 
                $textColor = Get-ThemeColor("input.foreground") 
            } else { 
                $textColor = Get-ThemeColor("input.placeholder") 
            }
            
            $maxTextWidth = $this.Width - 4  # Border + dropdown arrow
            if ($displayText.Length -gt $maxTextWidth) {
                $displayText = $displayText.Substring(0, $maxTextWidth)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayText `
                -Style @{ FG = $textColor; BG = $bgColor }
            
            # Draw dropdown arrow
            if ($this._isDropdownOpen) { 
                $arrowChar = '' 
            } else { 
                $arrowChar = '' 
            }
            if ($this.IsFocused) { 
                $arrowColor = Get-ThemeColor("Accent") 
            } else { 
                $arrowColor = Get-ThemeColor("Subtle") 
            }
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new($arrowChar, $arrowColor, $bgColor))
            
            # Draw dropdown if open (as overlay)
            if ($this._isDropdownOpen) {
                $this.IsOverlay = $true
                $this.DrawDropdown()
            }
            else {
                $this.IsOverlay = $false
            }
        }
        catch {}
    }
    
    hidden [void] DrawDropdown() {
        $dropdownY = $this.Height
        $maxDropdownHeight = 10
        $dropdownHeight = [Math]::Min($this._filteredIndices.Count + 2, $maxDropdownHeight)
        
        if ($dropdownHeight -lt 3) { $dropdownHeight = 3 }  # Minimum height
        
        # Create dropdown buffer
        $dropdownBuffer = [TuiBuffer]::new($this.Width, $dropdownHeight)
        $dropdownBuffer.Name = "ComboDropdown"
        
        # Draw dropdown border
        Write-TuiBox -Buffer $dropdownBuffer -X 0 -Y 0 `
            -Width $this.Width -Height $dropdownHeight `
            -Style @{ BorderFG = Get-ThemeColor("component.border"); BG = Get-ThemeColor("input.background"); BorderStyle = "Single" }
        
        # Draw items
        $itemY = 1
        $maxItems = $dropdownHeight - 2
        $scrollOffset = 0
        
        if ($this._highlightedIndex -ge $maxItems) {
            $scrollOffset = $this._highlightedIndex - $maxItems + 1
        }
        
        for ($i = $scrollOffset; $i -lt $this._filteredIndices.Count -and $itemY -lt $dropdownHeight - 1; $i++) {
            $itemIndex = $this._filteredIndices[$i]
            $item = $this.Items[$itemIndex]
            $itemText = $this.GetDisplayText($item)
            
            $itemFg = Get-ThemeColor("list.item.normal")
            $itemBg = Get-ThemeColor("input.background")
            
            if ($i -eq $this._highlightedIndex) {
                $itemFg = Get-ThemeColor("list.item.selected")
                $itemBg = Get-ThemeColor("list.item.selected.background")
            }
            elseif ($itemIndex -eq $this.SelectedIndex) {
                $itemFg = Get-ThemeColor("Accent")
            }
            
            # Clear line and draw item
            for ($x = 1; $x -lt $this.Width - 1; $x++) {
                $dropdownBuffer.SetCell($x, $itemY, [TuiCell]::new(' ', $itemFg, $itemBg))
            }
            
            $maxTextWidth = $this.Width - 2
            if ($itemText.Length -gt $maxTextWidth) {
                $itemText = $itemText.Substring(0, $maxTextWidth - 3) + "..."
            }
            
            Write-TuiText -Buffer $dropdownBuffer -X 1 -Y $itemY -Text $itemText -Style @{ FG = $itemFg; BG = $itemBg }
            $itemY++
        }
        
        # Blend dropdown buffer with main buffer at dropdown position
        $absPos = $this.GetAbsolutePosition()
        $dropX = 0
        $dropY = $dropdownY
        
        for ($y = 0; $y -lt $dropdownBuffer.Height; $y++) {
            for ($x = 0; $x -lt $dropdownBuffer.Width; $x++) {
                $cell = $dropdownBuffer.GetCell($x, $y)
                if ($cell) {
                    $this._private_buffer.SetCell($dropX + $x, $dropY + $y, $cell)
                }
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        
        if (-not $this._isDropdownOpen) {
            switch ($key.Key) {
                ([ConsoleKey]::Enter) { 
                    $this.OpenDropdown()
                }
                ([ConsoleKey]::Spacebar) {
                    if (-not $this.IsEditable) {
                        $this.OpenDropdown()
                    }
                    else {
                        $handled = $false
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    $this.OpenDropdown()
                }
                default {
                    if ($this.IsEditable -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                        $this._searchText += $key.KeyChar
                        $this.OpenDropdown()
                        $this.FilterItems()
                    }
                    else {
                        $handled = $false
                    }
                }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.CloseDropdown()
                }
                ([ConsoleKey]::Enter) {
                    if ($this._highlightedIndex -ge 0 -and $this._highlightedIndex -lt $this._filteredIndices.Count) {
                        $this.SelectItem($this._filteredIndices[$this._highlightedIndex])
                        $this.CloseDropdown()
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    if ($this._highlightedIndex -gt 0) {
                        $this._highlightedIndex--
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this._highlightedIndex -lt $this._filteredIndices.Count - 1) {
                        $this._highlightedIndex++
                    }
                }
                ([ConsoleKey]::Home) {
                    $this._highlightedIndex = 0
                }
                ([ConsoleKey]::End) {
                    $this._highlightedIndex = $this._filteredIndices.Count - 1
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.IsEditable -and $this._searchText.Length -gt 0) {
                        $this._searchText = $this._searchText.Substring(0, $this._searchText.Length - 1)
                        $this.FilterItems()
                    }
                }
                default {
                    if ($this.IsEditable -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                        $this._searchText += $key.KeyChar
                        $this.FilterItems()
                    }
                    else {
                        $handled = $false
                    }
                }
            }
        }
        
        if ($handled) {
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    hidden [void] OpenDropdown() {
        $this._isDropdownOpen = $true
        $this.FilterItems()
        
        # Set highlighted index to selected item
        if ($this.SelectedIndex -ge 0) {
            for ($i = 0; $i -lt $this._filteredIndices.Count; $i++) {
                if ($this._filteredIndices[$i] -eq $this.SelectedIndex) {
                    $this._highlightedIndex = $i
                    break
                }
            }
        }
        
        if ($this._highlightedIndex -eq -1 -and $this._filteredIndices.Count -gt 0) {
            $this._highlightedIndex = 0
        }
    }
    
    hidden [void] CloseDropdown() {
        $this._isDropdownOpen = $false
        $this.IsOverlay = $false
        if (-not $this.IsEditable) {
            $this._searchText = ""
        }
    }
    
    hidden [void] FilterItems() {
        $this._filteredIndices.Clear()
        
        if ($this._searchText -eq "") {
            # Show all items
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                $this._filteredIndices.Add($i)
            }
        }
        else {
            # Filter items based on search text
            $searchLower = $this._searchText.ToLower()
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                $itemText = $this.GetDisplayText($this.Items[$i]).ToLower()
                if ($itemText.Contains($searchLower)) {
                    $this._filteredIndices.Add($i)
                }
            }
        }
        
        # Reset highlighted index
        if ($this._highlightedIndex -ge $this._filteredIndices.Count) {
            $this._highlightedIndex = $this._filteredIndices.Count - 1
        }
        if ($this._highlightedIndex -lt 0 -and $this._filteredIndices.Count -gt 0) {
            $this._highlightedIndex = 0
        }
    }
    
    hidden [void] SelectItem([int]$index) {
        $oldIndex = $this.SelectedIndex
        $this.SelectedIndex = $index
        
        if (-not $this.IsEditable) {
            $this.Text = $this.GetDisplayText($this.Items[$index])
        }
        
        if ($oldIndex -ne $index -and $this.OnSelectionChanged) {
            try { & $this.OnSelectionChanged $this $index } catch {}
        }
    }
    
    hidden [string] GetDisplayText([object]$item) {
        if ($null -eq $item) { return "" }
        
        if ($this.DisplayMember -and $item.PSObject.Properties[$this.DisplayMember]) {
            return $item.$($this.DisplayMember).ToString()
        }
        
        return $item.ToString()
    }
}

#<!-- END_PAGE: ACO.009 -->

#<!-- PAGE: ACO.010 - Table Class -->
# ==============================================================================
# CLASS: Table
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Functions:
#     - Get-ThemeColor (AFU.004)
#     - Write-TuiBox (AFU.001)
#     - Write-TuiText (AFU.001)
#
# PURPOSE:
#   A high-performance data grid for displaying tabular data with virtual
#   scrolling (both vertical and horizontal) and row selection.
#
# KEY LOGIC:
#   - Manages a list of `PSObject` items.
#   - `OnRender` is the core. It only draws the visible rows based on the
#     `_scrollOffset`. It calculates which rows and columns are in the
#     viewport and renders them, providing a "virtualized" view.
#   - `DrawHeader` and `DrawRow` handle the rendering of individual parts,
#     accounting for horizontal scroll position.
#   - `HandleInput` manages selection changes with arrow keys, PageUp/Down, etc.,
#     and updates the `_scrollOffset` to keep the selection in view.
# ==============================================================================
class Table : UIElement {
    [List[PSObject]]$Items
    [List[string]]$Columns
    [hashtable]$ColumnWidths
    [int]$SelectedIndex = -1
    [bool]$ShowHeader = $true
    [bool]$ShowBorder = $true
    [bool]$AllowSelection = $true
    [scriptblock]$OnSelectionChanged
    hidden [int]$_scrollOffset = 0
    hidden [int]$_horizontalScroll = 0
    
    Table([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[PSObject]]::new()
        $this.Columns = [List[string]]::new()
        $this.ColumnWidths = @{}
        $this.Width = 80
        $this.Height = 20
    }
    
    [void] SetColumns([string[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
            if (-not $this.ColumnWidths.ContainsKey($col)) {
                $this.ColumnWidths[$col] = 15
            }
        }
    }
    
    [void] AutoSizeColumns() {
        foreach ($col in $this.Columns) {
            $maxWidth = $col.Length
            
            foreach ($item in $this.Items) {
                if ($item.PSObject.Properties[$col]) {
                    $val = $item.$col
                    if ($null -ne $val) {
                        $len = $val.ToString().Length
                        if ($len -gt $maxWidth) { $maxWidth = $len }
                    }
                }
            }
            
            $this.ColumnWidths[$col] = [Math]::Min($maxWidth + 2, 30)
        }
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor("component.background")
            $fgColor = Get-ThemeColor("Foreground")
            $borderColor = if ($this.IsFocused) { Get-ThemeColor("Primary") } else { Get-ThemeColor("component.border") }
            $headerBg = Get-ThemeColor("list.header.bg")
            $selectedBg = Get-ThemeColor("list.item.selected.background")
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            $contentX = 0
            $contentY = 0
            $contentWidth = $this.Width
            $contentHeight = $this.Height
            
            if ($this.ShowBorder) {
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                    -Width $this.Width -Height $this.Height `
                    -Style @{ BorderFG = $borderColor; BG = $bgColor; BorderStyle = "Single" }
                
                $contentX = 1
                $contentY = 1
                $contentWidth = $this.Width - 2
                $contentHeight = $this.Height - 2
            }
            
            $currentY = $contentY
            $dataStartY = $contentY
            
            if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
                $this.DrawHeader($contentX, $currentY, $contentWidth, $headerBg)
                $currentY++
                $dataStartY++
                
                for ($x = $contentX; $x -lt $contentX + $contentWidth; $x++) {
                    $this._private_buffer.SetCell($x, $currentY, [TuiCell]::new('-', $borderColor, $bgColor))
                }
                $currentY++
                $dataStartY++
            }
            
            $visibleRows = $contentHeight - ($dataStartY - $contentY)
            if ($visibleRows -le 0) { return }
            
            if ($this.AllowSelection -and $this.SelectedIndex -ge 0) {
                if ($this.SelectedIndex -lt $this._scrollOffset) { $this._scrollOffset = $this.SelectedIndex }
                elseif ($this.SelectedIndex -ge $this._scrollOffset + $visibleRows) { $this._scrollOffset = $this.SelectedIndex - $visibleRows + 1 }
            }
            
            for ($i = 0; $i -lt $visibleRows; $i++) {
                $itemIndex = $i + $this._scrollOffset
                if ($itemIndex -ge $this.Items.Count) { break }
                
                $item = $this.Items[$itemIndex]
                $rowBg = $bgColor
                $rowFg = $fgColor
                
                if ($this.AllowSelection -and $itemIndex -eq $this.SelectedIndex) {
                    $rowBg = $selectedBg
                    $rowFg = Get-ThemeColor("list.item.selected")
                }
                
                $this.DrawRow($item, $contentX, $currentY, $contentWidth, $rowFg, $rowBg)
                $currentY++
            }
            
            if ($this.Items.Count -gt $visibleRows) {
                $this.DrawScrollbar($contentX + $contentWidth - 1, $dataStartY, $visibleRows)
            }
        }
        catch {}
    }
    
    hidden [void] DrawHeader([int]$x, [int]$y, [int]$maxWidth, [string]$headerBg) {
        $currentX = $x - $this._horizontalScroll
        
        foreach ($col in $this.Columns) {
            $colWidth = $this.ColumnWidths[$col]
            
            if ($currentX + $colWidth -gt $x) {
                $visibleStart = [Math]::Max(0, $x - $currentX)
                $visibleWidth = [Math]::Min($colWidth - $visibleStart, $maxWidth - ($currentX - $x))
                
                if ($visibleWidth -gt 0) {
                    $headerText = $col
                    if ($headerText.Length -gt $visibleWidth) { $headerText = $headerText.Substring(0, $visibleWidth - 1) + ">" }
                    else { $headerText = $headerText.PadRight($visibleWidth) }
                    
                    $drawX = [Math]::Max($x, $currentX)
                    Write-TuiText -Buffer $this._private_buffer -X $drawX -Y $y -Text $headerText -Style @{ FG = Get-ThemeColor("list.header.fg"); BG = $headerBg }
                }
            }
            
            $currentX += $colWidth
            if ($currentX -ge $x + $maxWidth) { break }
        }
    }
    
    hidden [void] DrawRow([PSObject]$item, [int]$x, [int]$y, [int]$maxWidth, [string]$fg, [string]$bg) {
        for ($i = 0; $i -lt $maxWidth; $i++) {
            $this._private_buffer.SetCell($x + $i, $y, [TuiCell]::new(' ', $fg, $bg))
        }
        
        $currentX = $x - $this._horizontalScroll
        
        foreach ($col in $this.Columns) {
            $colWidth = $this.ColumnWidths[$col]
            
            if ($currentX + $colWidth -gt $x) {
                $value = ""
                if ($item.PSObject.Properties[$col]) {
                    $val = $item.$col
                    if ($null -ne $val) { $value = $val.ToString() }
                }
                
                $visibleStart = [Math]::Max(0, $x - $currentX)
                $visibleWidth = [Math]::Min($colWidth - $visibleStart, $maxWidth - ($currentX - $x))
                
                if ($visibleWidth -gt 0) {
                    if ($value.Length -gt $visibleWidth - 1) {
                        $value = $value.Substring(0, $visibleWidth - 2) + ".."
                    }
                    
                    $drawX = [Math]::Max($x, $currentX)
                    Write-TuiText -Buffer $this._private_buffer -X $drawX -Y $y -Text $value -Style @{ FG = $fg; BG = $bg }
                }
            }
            
            $currentX += $colWidth
            if ($currentX -ge $x + $maxWidth) { break }
        }
    }
    
    hidden [void] DrawScrollbar([int]$x, [int]$y, [int]$height) {
        $scrollbarHeight = [Math]::Max(1, [int]($height * $height / $this.Items.Count))
        $scrollbarPos = [int](($height - $scrollbarHeight) * $this._scrollOffset / ($this.Items.Count - $height))
        
        $scrollbarColor = Get-ThemeColor("list.scrollbar")
        $bgColor = Get-ThemeColor("component.background")
        
        for ($i = 0; $i -lt $height; $i++) {
            $char = if ($i -ge $scrollbarPos -and $i -lt $scrollbarPos + $scrollbarHeight) { '' } else { '' }
            $this._private_buffer.SetCell($x, $y + $i, [TuiCell]::new($char, $scrollbarColor, $bgColor))
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or -not $this.AllowSelection) { return $false }
        
        $handled = $true
        $oldSelection = $this.SelectedIndex
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) { if ($this.SelectedIndex -gt 0) { $this.SelectedIndex-- } }
            ([ConsoleKey]::DownArrow) { if ($this.SelectedIndex -lt $this.Items.Count - 1) { $this.SelectedIndex++ } }
            ([ConsoleKey]::Home) { $this.SelectedIndex = 0 }
            ([ConsoleKey]::End) { $this.SelectedIndex = $this.Items.Count - 1 }
            ([ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 4
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
            }
            ([ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 4
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
            }
            ([ConsoleKey]::LeftArrow) { if ($this._horizontalScroll -gt 0) { $this._horizontalScroll = [Math]::Max(0, $this._horizontalScroll - 5) } }
            ([ConsoleKey]::RightArrow) {
                $totalWidth = ($this.ColumnWidths.Values | Measure-Object -Sum).Sum
                $maxScroll = [Math]::Max(0, $totalWidth - $this.Width + 2)
                $this._horizontalScroll = [Math]::Min($maxScroll, $this._horizontalScroll + 5)
            }
            default { $handled = $false }
        }
        
        if ($handled) {
            if ($oldSelection -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                try { & $this.OnSelectionChanged $this $this.SelectedIndex } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

#endregion Advanced Components

#region Panel Components

#<!-- END_PAGE: ACO.010 -->

#<!-- PAGE: ACO.011 - Panel Class -->
# ==============================================================================
# CLASS: Panel
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Functions:
#     - Get-ThemeColor (AFU.004)
#     - Write-TuiBox (AFU.001)
#
# PURPOSE:
#   A fundamental container component that can have a border, a title, and
#   manage the layout of its child components.
#
# KEY LOGIC:
#   - `OnRender`: Draws its border and title using `Write-TuiBox` and then
#     calls `ApplyLayout`.
#   - `ApplyLayout`: If `LayoutType` is not "Manual", it automatically positions
#     and sizes its children vertically, horizontally, or in a simple grid.
#   - `UpdateContentDimensions`: A helper method that calculates the available
#     area for children inside the borders. This is called on creation and
#     on resize.
# ==============================================================================
class Panel : UIElement {
    [string]$Title = ""
    [string]$BorderStyle = "Single"
    [string]$BorderColor = "#808080"
    [string]$BackgroundColor = "#000000"
    [bool]$HasBorder = $true
    [string]$LayoutType = "Manual"
    [int]$Padding = 0
    [int]$Spacing = 1
    
    [int]$ContentX = 1
    [int]$ContentY = 1
    [int]$ContentWidth = 0
    [int]$ContentHeight = 0

    Panel([string]$name) : base($name) {
        $this.IsFocusable = $false
        if ($this.Width -eq 0) { $this.Width = 30 }
        if ($this.Height -eq 0) { $this.Height = 10 }
        $this.UpdateContentDimensions()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor("component.background")
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            $this.UpdateContentDimensions()

            if ($this.HasBorder) {
                $borderColorValue = if ($this.IsFocused) { Get-ThemeColor("Primary") } else { Get-ThemeColor("component.border") }
                
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                    -Width $this.Width -Height $this.Height `
                    -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = $this.BorderStyle; TitleFG = Get-ThemeColor("component.title") } `
                    -Title $this.Title
            }

            $this.ApplyLayout()
        }
        catch {}
    }

    [void] ApplyLayout() {
        if ($this.LayoutType -eq "Manual") { return }

        $layoutX = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
        $layoutY = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
        $layoutWidth = [Math]::Max(0, $this.Width - (2 * $layoutX))
        $layoutHeight = [Math]::Max(0, $this.Height - (2 * $layoutY))

        $visibleChildren = @($this.Children | Where-Object { $_.Visible })
        if ($visibleChildren.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" {
                $currentY = $layoutY
                foreach ($child in $visibleChildren) {
                    $child.X = $layoutX
                    $child.Y = $currentY
                    $child.Width = [Math]::Min($child.Width, $layoutWidth)
                    $currentY += $child.Height + $this.Spacing
                }
            }
            "Horizontal" {
                $currentX = $layoutX
                foreach ($child in $visibleChildren) {
                    $child.X = $currentX
                    $child.Y = $layoutY
                    $child.Height = [Math]::Min($child.Height, $layoutHeight)
                    $currentX += $child.Width + $this.Spacing
                }
            }
            "Grid" {
                $cols = [Math]::Max(1, [Math]::Floor($layoutWidth / 20))
                $col = 0
                $row = 0
                $cellWidth = [Math]::Max(1, [Math]::Floor($layoutWidth / $cols))
                $cellHeight = 3
                
                foreach ($child in $visibleChildren) {
                    $child.X = $layoutX + ($col * $cellWidth)
                    $child.Y = $layoutY + ($row * ($cellHeight + $this.Spacing))
                    $child.Width = [Math]::Max(1, $cellWidth - $this.Spacing)
                    $child.Height = $cellHeight
                    
                    $col++
                    if ($col -ge $cols) {
                        $col = 0
                        $row++
                    }
                }
            }
        }
    }

    [hashtable] GetContentArea() {
        $area = @{
            X = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
            Y = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
        }
        $area.Width = [Math]::Max(0, $this.Width - (2 * $area.X))
        $area.Height = [Math]::Max(0, $this.Height - (2 * $area.Y))
        return $area
    }
    
    [void] UpdateContentDimensions() {
        $this.ContentX = if ($this.HasBorder) { 1 } else { 0 }
        $this.ContentY = if ($this.HasBorder) { 1 } else { 0 }
        $borderOffset = if ($this.HasBorder) { 2 } else { 0 }
        $this.ContentWidth = [Math]::Max(0, $this.Width - $borderOffset)
        $this.ContentHeight = [Math]::Max(0, $this.Height - $borderOffset)
    }
    
    [void] OnResize() {
        $this.UpdateContentDimensions()
        ([UIElement]$this).OnResize()
    }
}

#<!-- END_PAGE: ACO.011 -->

#<!-- PAGE: ACO.012 - ScrollablePanel Class -->
# ==============================================================================
# CLASS: ScrollablePanel
#
# INHERITS:
#   - Panel (ACO.011)
#
# DEPENDENCIES:
#   Classes:
#     - TuiBuffer (ABC.003)
#   Functions:
#     - Get-ThemeColor (AFU.004)
#
# PURPOSE:
#   A panel that provides vertical scrolling for content that exceeds its
#   visible height. This is a critical component for displaying large lists or
#   amounts of text.
#
# KEY LOGIC:
#   - It uses a `_virtual_buffer` which is potentially much taller than the
#     component itself.
#   - `_RenderContent` is the core. It first renders the base panel (border),
#     then renders ALL children onto the `_virtual_buffer`. Finally, it
#     calculates the visible "viewport" based on `ScrollOffsetY` and copies
#     only that portion from the `_virtual_buffer` to its main `_private_buffer`
#     for display.
#   - `HandleInput` (from base Panel, but focusable) and Scroll* methods
#     manipulate `ScrollOffsetY` to control the viewport.
# ==============================================================================
class ScrollablePanel : Panel {
    [int]$ScrollOffsetY = 0
    [int]$MaxScrollY = 0
    [bool]$ShowScrollbar = $true
    hidden [int]$_contentHeight = 0
    hidden [TuiBuffer]$_virtual_buffer = $null

    ScrollablePanel([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.{_virtual_buffer} = [TuiBuffer]::new($this.Width, 1000, "$($this.Name).Virtual") 
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) {
        ([Panel]$this).Resize($newWidth, $newHeight) 

        $targetVirtualWidth = $this.ContentWidth 
        if ($this.{_virtual_buffer}.Width -ne $targetVirtualWidth) {
            $this.{_virtual_buffer}.Resize($targetVirtualWidth, $this.{_virtual_buffer}.Height)
        }
        $this.UpdateMaxScroll()
        $this.RequestRedraw()
    }

    hidden [void] _RenderContent() {
        ([Panel]$this)._RenderContent()

        $this.{_virtual_buffer}.Clear([TuiCell]::new(' ', $this.BackgroundColor, $this.BackgroundColor))
        
        $actualContentBottom = 0
        foreach ($child in $this.Children | Sort-Object ZIndex) {
            if ($child.Visible) {
                $child.Render() 
                if ($null -ne $child._private_buffer) {
                    $this.{_virtual_buffer}.BlendBuffer($child._private_buffer, $child.X - $this.ContentX, $child.Y - $this.ContentY)
                }
                $childExtent = ($child.Y - $this.ContentY) + $child.Height
                if ($childExtent -gt $actualContentBottom) { $actualContentBottom = $childExtent }
            }
        }
        $this._contentHeight = $actualContentBottom

        $this.UpdateMaxScroll()

        $viewportWidth = [Math]::Max(1, $this.ContentWidth)
        $viewportHeight = [Math]::Max(1, $this.ContentHeight)

        $sourceX = 0
        $sourceY = $this.ScrollOffsetY
        
        $effectiveSourceHeight = [Math]::Min($viewportHeight, $this.{_virtual_buffer}.Height - $sourceY)
        if ($effectiveSourceHeight -le 0) {
            Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': No effective content for viewport."
            return
        }

        $visiblePortion = $this.{_virtual_buffer}.GetSubBuffer($sourceX, $sourceY, $viewportWidth, $effectiveSourceHeight)
        
        $this.{_private_buffer}.BlendBuffer($visiblePortion, $this.ContentX, $this.ContentY)

        if ($this.ShowScrollbar -and $this.MaxScrollY -gt 0) {
            $this.DrawScrollbar()
        }

        $this._needs_redraw = $false
    }

    [void] UpdateMaxScroll() {
        $viewportHeight = $this.ContentHeight
        
        $newVirtualHeight = [Math]::Max($this.{_virtual_buffer}.Height, $this._contentHeight)
        if ($newVirtualHeight -ne $this.{_virtual_buffer}.Height) {
            $this.{_virtual_buffer}.Resize($this.{_virtual_buffer}.Width, $newVirtualHeight)
            Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': Resized virtual buffer height to $newVirtualHeight."
        }

        $this.MaxScrollY = [Math]::Max(0, $this._contentHeight - $viewportHeight)
        $this.ScrollOffsetY = [Math]::Max(0, [Math]::Min($this.ScrollOffsetY, $this.MaxScrollY))
    }

    [void] DrawScrollbar() {
        $scrollbarX = $this.Width - 1
        $scrollbarY = if ($this.HasBorder) { 1 } else { 0 }
        $scrollbarTrackHeight = if ($this.HasBorder) { $this.Height - 2 } else { $this.Height }

        if ($this._contentHeight -le $scrollbarTrackHeight) { 
            $bgColor = Get-ThemeColor "Background"
            for ($i = 0; $i -lt $scrollbarTrackHeight; $i++) {
                $this.{_private_buffer}.SetCell($scrollbarX, $scrollbarY + $i, [TuiCell]::new(' ', $bgColor, $bgColor))
            }
            return 
        } 

        $scrollFg = Get-ThemeColor "list.scrollbar"
        $scrollBg = Get-ThemeColor "Background"

        $thumbSize = [Math]::Max(1, [int]($scrollbarTrackHeight * $scrollbarTrackHeight / $this._contentHeight))
        $thumbPos = if ($this.MaxScrollY -gt 0) { [int](($scrollbarTrackHeight - $thumbSize) * $this.ScrollOffsetY / $this.MaxScrollY) } else { 0 }
        
        for ($i = 0; $i -lt $scrollbarTrackHeight; $i++) {
            $y = $scrollbarY + $i
            $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { '' } else { '' }
            $this.{_private_buffer}.SetCell($scrollbarX, $y, [TuiCell]::new($char, $scrollFg, $scrollBg))
        }
    }

    [void] ScrollUp([int]$lines = 1) {
        $oldScroll = $this.ScrollOffsetY
        $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY - $lines)
        if ($this.ScrollOffsetY -ne $oldScroll) { $this.RequestRedraw() }
    }

    [void] ScrollDown([int]$lines = 1) {
        $oldScroll = $this.ScrollOffsetY
        $this.ScrollOffsetY = [Math]::Min($this.MaxScrollY, $this.ScrollOffsetY + $lines)
        if ($this.ScrollOffsetY -ne $oldScroll) { $this.RequestRedraw() }
    }

    [void] ScrollPageUp() { $this.ScrollUp($this.ContentHeight) }
    [void] ScrollPageDown() { $this.ScrollDown($this.ContentHeight) }
    [void] ScrollToTop() {
        if ($this.ScrollOffsetY -ne 0) {
            $this.ScrollOffsetY = 0
            $this.RequestRedraw()
        }
    }
    [void] ScrollToBottom() {
        if ($this.ScrollOffsetY -ne $this.MaxScrollY) {
            $this.ScrollOffsetY = $this.MaxScrollY
            $this.RequestRedraw()
        }
    }
}

#<!-- END_PAGE: ACO.012 -->

#<!-- PAGE: ACO.013 - GroupPanel Class -->
# ===== CLASS: GroupPanel =====
# Module: panels-class
# Dependencies: Panel
# Purpose: Themed panel for grouping
class GroupPanel : Panel {
    [bool]$IsExpanded = $true
    [bool]$CanCollapse = $true

    GroupPanel([string]$name) : base($name) {
        $this.BorderStyle = "Double"
        $this.BorderColor = "#008B8B"
        $this.BackgroundColor = "#000000"
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        foreach ($child in $this.Children) { $child.Visible = $this.IsExpanded }

        if (-not $this.IsExpanded -and $this.CanCollapse) {
            $this._originalHeight = $this.Height
            $this.Height = 3
        }
        elseif ($this.IsExpanded -and $this._originalHeight) {
            $this.Height = $this._originalHeight
        }

        if ($this.CanCollapse -and $this.Title) {
            $indicator = if ($this.IsExpanded) { "[-]" } else { "[+]" }
            $this.Title = "$indicator $($this.Title.TrimStart('[+]', '[-]').Trim())"
        }

        ([Panel]$this).OnRender()
    }

    hidden [int]$_originalHeight = 0

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or -not $this.CanCollapse) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar) {
            $this.Toggle()
            return $true
        }
        
        return $false
    }

    [void] Toggle() {
        $this.IsExpanded = -not $this.IsExpanded
        $this.RequestRedraw()
    }
}

#endregion Panel Components

#region Composite Components

#<!-- END_PAGE: ACO.013 -->

#<!-- PAGE: ACO.014 - ListBox Class -->
# ==============================================================================
# CLASS: ListBox
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Functions:
#     - Get-ThemeColor (AFU.004)
#     - Write-TuiBox (AFU.001)
#     - Write-TuiText (AFU.001)
#
# PURPOSE:
#   A simple, focusable component for displaying a scrollable list of items and
#   managing a single selection.
#
# KEY LOGIC:
#   - `OnRender` draws a border and then iterates through the visible subset of
#     `Items` based on the `ScrollOffset`. It highlights the `SelectedIndex`
#     with different colors.
#   - `HandleInput` manages selection changes via arrow keys, PageUp/Down, etc.
#   - `EnsureVisible` is a helper method called during rendering to adjust the
#     `ScrollOffset` so that the `SelectedIndex` is always in the viewport.
# ==============================================================================
class ListBox : UIElement {
    [List[object]]$Items
    [int]$SelectedIndex = -1
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BackgroundColor = "#000000"
    [string]$SelectedForegroundColor = "#000000"
    [string]$SelectedBackgroundColor = "#00FFFF"
    [string]$BorderColor = "#808080"
    hidden [int]$ScrollOffset = 0

    ListBox([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[object]]::new()
        $this.Width = 30
        $this.Height = 10
    }

    [void] AddItem([object]$item) {
        $this.Items.Add($item)
        if ($this.SelectedIndex -eq -1 -and $this.Items.Count -eq 1) { $this.SelectedIndex = 0 }
        $this.RequestRedraw()
    }

    [void] ClearItems() {
        $this.Items.Clear()
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.RequestRedraw()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
            -Style @{ BorderFG = Get-ThemeColor("component.border"); BG = $bgColor; BorderStyle = "Single" }
            
            $contentY = 1
            $contentHeight = $this.Height - 2
            $contentX = 1
            $contentWidth = $this.Width - 2
            
            $this.EnsureVisible($this.SelectedIndex)
            
            for ($i = 0; $i -lt $contentHeight -and ($i + $this.ScrollOffset) -lt $this.Items.Count; $i++) {
                $itemIndex = $i + $this.ScrollOffset
                $item = $this.Items[$itemIndex]
                $itemText = if ($item -is [string]) { $item } else { $item.ToString() }
                
                if ($itemText.Length -gt $contentWidth) { $itemText = $itemText.Substring(0, $contentWidth - 3) + "..." }
                
                $isSelected = ($itemIndex -eq $this.SelectedIndex)
                $fgColor = if ($isSelected) { Get-ThemeColor("list.item.selected") } else { Get-ThemeColor("list.item.normal") }
                $itemBgColor = if ($isSelected) { Get-ThemeColor("list.item.selected.background") } else { $bgColor }
                
                $this._private_buffer.FillRect(1, $contentY + $i, $this.Width - 2, 1, ' ', @{ BG = $itemBgColor })
                
                Write-TuiText -Buffer $this._private_buffer -X $contentX -Y ($contentY + $i) -Text $itemText `
                    -Style @{ FG = $fgColor; BG = $itemBgColor }
            }
            
            if ($this.Items.Count -gt $contentHeight) {
                $scrollbarX = $this.Width - 2
                $scrollbarHeight = $contentHeight
                $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $scrollbarHeight / $this.Items.Count))
                $thumbPos = if ($this.Items.Count -gt $scrollbarHeight) {
                    [int](($scrollbarHeight - $thumbSize) * $this.ScrollOffset / ($this.Items.Count - $scrollbarHeight))
                } else { 0 }
                
                $scrollbarColor = Get-ThemeColor "list.scrollbar"
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { '' } else { '' }
                    $this._private_buffer.SetCell($scrollbarX, $contentY + $i, [TuiCell]::new($char, $scrollbarColor, $bgColor))
                }
            }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $true
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) { if ($this.SelectedIndex -gt 0) { $this.SelectedIndex-- } }
            ([ConsoleKey]::DownArrow) { if ($this.SelectedIndex -lt $this.Items.Count - 1) { $this.SelectedIndex++ } }
            ([ConsoleKey]::Home) { $this.SelectedIndex = 0 }
            ([ConsoleKey]::End) { $this.SelectedIndex = $this.Items.Count - 1 }
            ([ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 2
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
            }
            ([ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 2
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
            }
            default { $handled = $false }
        }
        
        if ($handled) { $this.RequestRedraw() }
        
        return $handled
    }

    [void] EnsureVisible([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Items.Count) { return }
        
        $visibleHeight = $this.Height - 2
        
        if ($index -lt $this.ScrollOffset) { $this.ScrollOffset = $index }
        elseif ($index -ge $this.ScrollOffset + $visibleHeight) { $this.ScrollOffset = $index - $visibleHeight + 1 }
    }
}

#<!-- END_PAGE: ACO.014 -->

#<!-- PAGE: ACO.015 - TextBox Class -->
# ==============================================================================
# CLASS: TextBox
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Components:
#     - TextBoxComponent (ACO.003)
#   Services:
#     - FocusManager (ASE.009)
#
# PURPOSE:
#   An enhanced public-facing wrapper around the internal `TextBoxComponent`. It
#   composes the component as a child, simplifying its API for direct use.
#
# KEY LOGIC:
#   - It creates a `TextBoxComponent` as a child and delegates most of its
#     functionality (like `HandleInput`) to it.
#   - Provides simplified public methods like `GetText`, `SetText`, and `Clear`.
#   - `Focus` method provides a convenient way to set focus using the global
#     `FocusManager` service.
# ==============================================================================
class TextBox : UIElement {
    hidden [TextBoxComponent]$_textBox

    TextBox([string]$name) : base($name) {
        $this._textBox = [TextBoxComponent]::new($name + "_inner")
        $this.AddChild($this._textBox)
        $this.IsFocusable = $true
    }

    [string] GetText() { return $this._textBox.Text }
    [void] SetText([string]$value) { $this._textBox.Text = $value }
    
    [void] Clear() {
        $this._textBox.Text = ""
        $this._textBox.CursorPosition = 0
        $this._textBox.RequestRedraw()
    }

    [void] Focus() {
        $global:TuiState.Services.FocusManager?.SetFocus($this)
    }

    [void] OnResize() {
        if ($this._textBox) {
            $this._textBox.Width = $this.Width
            $this._textBox.Height = $this.Height
            $this._textBox.X = 0
            $this._textBox.Y = 0
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $this._textBox.HandleInput($key)
    }
}

#<!-- END_PAGE: ACO.015 -->

#<!-- PAGE: ACO.016 - CommandPalette Class -->
# ==============================================================================
# CLASS: CommandPalette
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Components:
#     - ListBox (ACO.014)
#     - TextBox (ACO.015)
#     - Panel (ACO.011)
#   Services:
#     - ActionService (ASE.001)
#
# PURPOSE:
#   A powerful, overlay-based command interface (like in VS Code) that allows
#   users to search for and execute any action registered with the ActionService.
#
# KEY LOGIC:
#   - Composes a Panel, TextBox, and ListBox to build its UI.
#   - `RefreshActions` gets all actions from the `ActionService`.
#   - `FilterActions` is called by the TextBox's OnChange event. It filters the
#     full action list based on the search text and populates the ListBox.
#   - `HandleInput` routes most key presses to the TextBox, but intercepts
#     up/down arrows for the ListBox and Enter to execute the selected action.
# ==============================================================================
class CommandPalette : UIElement {
    hidden [ListBox]$_listBox
    hidden [TextBox]$_searchBox
    hidden [Panel]$_panel
    hidden [List[object]]$_allActions
    hidden [List[object]]$_filteredActions
    hidden [object]$_actionService
    hidden [scriptblock]$OnCancel
    hidden [scriptblock]$OnSelect
    hidden [System.DateTime]$_lastSearchTime = [DateTime]::MinValue
    hidden [string]$_pendingSearchText = ""

    CommandPalette([string]$name, [object]$actionService) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 60
        $this.Height = 20
        $this._actionService = $actionService
        
        $this.Initialize()
    }

    hidden [void] Initialize() {
        $this._panel = [Panel]::new("CommandPalette_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.BorderColor = "#00FFFF"
        $this._panel.BackgroundColor = "#000000"
        $this._panel.Title = " Command Palette "
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this.AddChild($this._panel)

        $this._searchBox = [TextBox]::new("CommandPalette_Search")
        $this._searchBox.X = 2
        $this._searchBox.Y = 1
        $this._searchBox.Width = $this.Width - 4
        $this._searchBox.Height = 3
        $this._searchBox._textBox.Placeholder = "Type to search commands..."
        
        $commandPalette = $this
        $this._searchBox._textBox.OnChange = {
            param($sender, $text)
            $commandPalette.FilterActions($text)
        }.GetNewClosure()
        
        $this._panel.AddChild($this._searchBox)

        $this._listBox = [ListBox]::new("CommandPalette_List")
        $this._listBox.X = 2
        $this._listBox.Y = 4
        $this._listBox.Width = $this.Width - 4
        $this._listBox.Height = $this.Height - 6
        $this._panel.AddChild($this._listBox)

        $this._allActions = [List[object]]::new()
        $this._filteredActions = [List[object]]::new()
    }

    [void] Show() {
        $this.RefreshActions()
        $this._searchBox.Clear()
        $this.FilterActions("")
        $this.Visible = $true
        $this._searchBox.Focus()
        $this.RequestRedraw()
    }

    [void] Hide() {
        $this.Visible = $false
        if ($this.OnCancel) { & $this.OnCancel }
        $this.RequestRedraw()
    }

    [void] RefreshActions() {
        $this._allActions.Clear()
        
        if ($this._actionService) {
            $actions = $this._actionService.GetAllActions()
            if ($actions -and $actions.Values) {
                foreach ($action in ($actions.Values | Sort-Object Category, Name)) {
                    if ($action) { $this._allActions.Add($action) }
                }
            }
        }
    }

    [void] FilterActions([string]$searchText) {
        $now = [DateTime]::Now
        if (($now - $this._lastSearchTime).TotalMilliseconds -lt 100) {
            $this._pendingSearchText = $searchText
            return
        }
        $this._lastSearchTime = $now
        
        $this._filteredActions.Clear()
        $this._listBox.ClearItems()
        
        $actionsToDisplay = if ([string]::IsNullOrWhiteSpace($searchText)) { $this._allActions } else {
            $searchLower = $searchText.ToLower()
            @($this._allActions | Where-Object {
                $_.Name.ToLower().Contains($searchLower) -or
                ($_.Description -and $_.Description.ToLower().Contains($searchLower)) -or
                ($_.Category -and $_.Category.ToLower().Contains($searchLower))
            })
        }

        foreach ($action in $actionsToDisplay) {
            $this._filteredActions.Add($action)
            $displayText = if ($action.Category) { "[$($action.Category)] $($action.Name) - $($action.Description)" } else { "$($action.Name) - $($action.Description)" }
            $this._listBox.AddItem($displayText)
        }
        
        if ($this._filteredActions.Count -gt 0) { $this._listBox.SelectedIndex = 0 }
        
        $this._listBox.RequestRedraw()
        $this.RequestRedraw()
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Escape) { $this.Hide(); return $true }
        
        if ($key.Key -eq [ConsoleKey]::Enter) {
            if ($this._listBox.SelectedIndex -ge 0 -and $this._filteredActions.Count -gt 0) {
                $selectedAction = $this._filteredActions[$this._listBox.SelectedIndex]
                if ($selectedAction) {
                    $this.Hide()
                    if ($this.OnSelect) { & $this.OnSelect $selectedAction }
                    else { $this._actionService.ExecuteAction($selectedAction.Name, @{}) }
                    return $true
                }
            }
        }
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) { return $this._listBox.HandleInput($key) }
            ([ConsoleKey]::DownArrow) { return $this._listBox.HandleInput($key) }
            ([ConsoleKey]::PageUp) { return $this._listBox.HandleInput($key) }
            ([ConsoleKey]::PageDown) { return $this._listBox.HandleInput($key) }
            ([ConsoleKey]::Home) { return $this._listBox.HandleInput($key) }
            ([ConsoleKey]::End) { return $this._listBox.HandleInput($key) }
            ([ConsoleKey]::Tab) {
                $focusManager = $global:TuiState.Services.FocusManager
                if ($focusManager) {
                    if ($focusManager.FocusedComponent -eq $this._searchBox._textBox) { $focusManager.SetFocus($this._listBox) }
                    else { $focusManager.SetFocus($this._searchBox._textBox) }
                }
                return $true
            }
            default { return $this._searchBox.HandleInput($key) }
        }
        
        return $false
    }

    [void] OnResize() {
        if ($this._panel) {
            $this._panel.Width = $this.Width
            $this._panel.Height = $this.Height
            $this._panel.X = 0
            $this._panel.Y = 0
            
            if ($this._searchBox) { $this._searchBox.Width = $this.Width - 4 }
            if ($this._listBox) {
                $this._listBox.Width = $this.Width - 4
                $this._listBox.Height = $this.Height - 6
            }
        }
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        ([UIElement]$this).OnRender()
        $this._needs_redraw = $false
    }
}

#endregion Composite Components

#region Dialog Components

#<!-- END_PAGE: ACO.016 -->

#<!-- PAGE: ACO.017 - Dialog Class -->
# ==============================================================================
# CLASS: Dialog
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Components:
#     - Panel (ACO.011)
#   Services:
#     - EventManager (ASE.007)
#     - FocusManager (ASE.009)
#
# PURPOSE:
#   The abstract base class for all modal dialogs. It provides the core
#   functionality for showing, completing, and managing focus within a modal
#   context.
#
# KEY LOGIC:
#   - Is an `IsOverlay` component, meaning it's rendered on top of everything.
#   - `Show` makes the dialog visible and positions it.
#   - `Complete` is the primary method for closing the dialog. It sets a result,
#     invokes an `OnClose` callback, and crucially, publishes a
#     `Dialog.Completed` event, which the `DialogManager` service listens for
#     to handle the actual hiding and focus restoration.
#   - `SetInitialFocus` is called by the DialogManager to transfer focus to the
#     first focusable element inside the dialog.
# ==============================================================================
class Dialog : UIElement {
    [string]$Title = ""
    [string]$Message = ""
    hidden [Panel]$_panel
    hidden [object]$Result = $null
    hidden [bool]$_isComplete = $false
    [scriptblock]$OnClose
    [DialogResult]$DialogResult = [DialogResult]::None

    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 50
        $this.Height = 10
        
        $this.InitializeDialog()
    }

    hidden [void] InitializeDialog() {
        $this._panel = [Panel]::new($this.Name + "_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.BorderColor = "#00FFFF"
        $this._panel.BackgroundColor = "#000000"
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this.AddChild($this._panel)
    }

    [void] Show([string]$title, [string]$message) {
        $this.Title = $title
        $this.Message = $message
        $this._panel.Title = " $title "
        $this._isComplete = $false
        $this.Result = $null
        $this.Visible = $true
        $this.RequestRedraw()
    }

    [void] Complete([object]$result) {
        $this.Result = $result
        $this._isComplete = $true
        
        if ($this.OnClose) {
            try { & $this.OnClose $result } catch { 
                Write-Log -Level Warning -Message "Dialog '$($this.Name)': Error in OnClose callback: $($_.Exception.Message)" 
            }
        }
        
        $global:TuiState.Services.EventManager?.Publish("Dialog.Completed", @{ Dialog = $this; Result = $result })
    }

    [void] Close([object]$result) { $this.Complete($result) }

    [void] SetInitialFocus() {
        $firstFocusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible -and $_.Enabled } | Sort-Object TabIndex, Y, X | Select-Object -First 1
        if ($firstFocusable) {
            $global:TuiState.Services.FocusManager?.SetFocus($firstFocusable)
            Write-Log -Level Debug -Message "Dialog '$($this.Name)': Set initial focus to '$($firstFocusable.Name)'."
        }
    }

    [void] OnRender() {
        $this._panel.Title = " $this.Title "
        $this._panel.OnRender()
    }

    [object] ShowDialog([string]$title, [string]$message) {
        $this.Show($title, $message)
        return $this.Result
    }
}

#<!-- END_PAGE: ACO.017 -->

#<!-- PAGE: ACO.018 - AlertDialog Class -->
# ==============================================================================
# CLASS: AlertDialog
#
# INHERITS:
#   - Dialog (ACO.017)
#
# DEPENDENCIES:
#   Components:
#     - ButtonComponent (ACO.002)
#
# PURPOSE:
#   A simple modal dialog for displaying a message to the user with a single
#   "OK" button to dismiss it.
#
# KEY LOGIC:
#   - Composes a `ButtonComponent` for the "OK" button.
#   - The button's `OnClick` event calls `this.Complete($true)`.
#   - `HandleInput` listens for Enter or Escape as shortcuts to also complete
#     the dialog.
#   - `OnEnter` sets focus to the OK button when the dialog is shown.
#   - `OnRender` performs simple word-wrapping to display the message.
# ==============================================================================
class AlertDialog : Dialog {
    hidden [ButtonComponent]$_okButton

    AlertDialog([string]$name) : base($name) {
        $this.Height = 8
        $this.InitializeAlert()
    }

    hidden [void] InitializeAlert() {
        $this._okButton = [ButtonComponent]::new($this.Name + "_OK")
        $this._okButton.Text = "OK"
        $this._okButton.Width = 10
        $this._okButton.Height = 3
        $this._okButton.OnClick = {
            $this.Complete($true)
        }.GetNewClosure()
        $this._panel.AddChild($this._okButton)
    }

    [void] Show([string]$title, [string]$message) {
        ([Dialog]$this).Show($title, $message)
        $this._okButton.X = [Math]::Floor(($this.Width - $this._okButton.Width) / 2)
        $this._okButton.Y = $this.Height - 4
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            $panelContentX = $this._panel.ContentX
            $panelContentY = $this._panel.ContentY
            $maxWidth = $this.Width - 4
            $words = $this.Message -split ' '
            $currentLine = ""
            $currentY = $panelContentY + 1

            foreach ($word in $words) {
                if (($currentLine + " " + $word).Length -gt $maxWidth) {
                    if ($currentLine) {
                        Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
                        $currentY++
                    }
                    $currentLine = $word
                }
                else { $currentLine = if ($currentLine) { "$currentLine $word" } else { $word } }
            }
            if ($currentLine) {
                Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }

        if ($this._okButton.HandleInput($key)) { return $true }
        
        if ($key.Key -eq [ConsoleKey]::Escape -or $key.Key -eq [ConsoleKey]::Enter) {
            $this.Complete($true)
            return $true
        }
        return $false
    }

    [void] OnEnter() {
        $global:TuiState.Services.FocusManager?.SetFocus($this._okButton)
    }
}

#<!-- END_PAGE: ACO.018 -->

#<!-- PAGE: ACO.019 - ConfirmDialog Class -->
# ==============================================================================
# CLASS: ConfirmDialog
#
# INHERITS:
#   - Dialog (ACO.017)
#
# DEPENDENCIES:
#   Components:
#     - ButtonComponent (ACO.002)
#
# PURPOSE:
#   Presents a question to the user with "Yes" and "No" buttons, returning a
#   boolean result.
#
# KEY LOGIC:
#   - Composes two `ButtonComponent` children, "Yes" and "No".
#   - `OnClick` handlers for the buttons call `this.Complete($true)` or
#     `this.Complete($false)`.
#   - `OnEnter` uses `FocusManager` to set initial focus on the "Yes" button.
#   - `HandleInput` allows Left/Right arrow keys to toggle focus between the
#     two buttons, providing an intuitive navigation shortcut.
# ==============================================================================
class ConfirmDialog : Dialog {
    hidden [ButtonComponent]$_yesButton
    hidden [ButtonComponent]$_noButton

    ConfirmDialog([string]$name) : base($name) {
        $this.Height = 8
        $this.InitializeConfirm()
    }

    hidden [void] InitializeConfirm() {
        $this._yesButton = [ButtonComponent]::new($this.Name + "_Yes")
        $this._yesButton.Text = "Yes"
        $this._yesButton.Width = 10
        $this._yesButton.Height = 3
        $this._yesButton.TabIndex = 1
        $this._yesButton.OnClick = { $this.Complete($true) }.GetNewClosure()
        $this._panel.AddChild($this._yesButton)

        $this._noButton = [ButtonComponent]::new($this.Name + "_No")
        $this._noButton.Text = "No"
        $this._noButton.Width = 10
        $this._noButton.Height = 3
        $this._noButton.TabIndex = 2
        $this._noButton.OnClick = { $this.Complete($false) }.GetNewClosure()
        $this._panel.AddChild($this._noButton)
    }

    [void] Show([string]$title, [string]$message) {
        ([Dialog]$this).Show($title, $message)
        
        $buttonY = $this.Height - 4
        $totalWidth = $this._yesButton.Width + $this._noButton.Width + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        $this._yesButton.X = $startX
        $this._yesButton.Y = $buttonY
        $this._noButton.X = $startX + $this._yesButton.Width + 4
        $this._noButton.Y = $buttonY
    }

    [void] OnEnter() {
        $global:TuiState.Services.FocusManager?.SetFocus($this._yesButton)
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            $panelContentX = $this._panel.ContentX
            $panelContentY = $this._panel.ContentY
            $maxWidth = $this.Width - 4
            $words = $this.Message -split ' '
            $currentLine = ""
            $currentY = $panelContentY + 1
            
            foreach ($word in $words) {
                if (($currentLine + " " + $word).Length -gt $maxWidth) {
                    if ($currentLine) {
                        Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
                        $currentY++
                    }
                    $currentLine = $word
                }
                else { $currentLine = if ($currentLine) { "$currentLine $word" } else { $word } }
            }
            if ($currentLine) {
                Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -eq [ConsoleKey]::Escape) { $this.Complete($false); return $true }

        if ($key.Key -eq [ConsoleKey]::LeftArrow -or $key.Key -eq [ConsoleKey]::RightArrow) {
            $focusManager = $global:TuiState.Services.FocusManager
            if ($focusManager) {
                if ($focusManager.FocusedComponent -eq $this._yesButton) { $focusManager.SetFocus($this._noButton) }
                else { $focusManager.SetFocus($this._yesButton) }
                return $true
            }
        }
        
        return $false
    }
}

#<!-- END_PAGE: ACO.019 -->

#<!-- PAGE: ACO.020 - InputDialog Class -->
# ===== CLASS: InputDialog =====
# Module: dialog-system-class
# Dependencies: Dialog, TextBoxComponent, ButtonComponent
# Purpose: Text input dialog
class InputDialog : Dialog {
    hidden [TextBoxComponent]$_inputBox
    hidden [ButtonComponent]$_okButton
    hidden [ButtonComponent]$_cancelButton
    hidden [bool]$_focusOnInput = $true
    hidden [int]$_focusIndex = 0

    InputDialog([string]$name) : base($name) {
        $this.Height = 10
        $this.InitializeInput()
    }

    hidden [void] InitializeInput() {
        $this._inputBox = [TextBoxComponent]::new($this.Name + "_Input")
        $this._inputBox.Width = $this.Width - 4
        $this._inputBox.Height = 3
        $this._inputBox.X = 2
        $this._inputBox.Y = 4
        $this._panel.AddChild($this._inputBox)

        $this._okButton = [ButtonComponent]::new($this.Name + "_OK")
        $this._okButton.Text = "OK"
        $this._okButton.Width = 10
        $this._okButton.Height = 3
        $this._okButton.OnClick = { $this.Close($this._inputBox.Text) }.GetNewClosure()
        $this._panel.AddChild($this._okButton)

        $this._cancelButton = [ButtonComponent]::new($this.Name + "_Cancel")
        $this._cancelButton.Text = "Cancel"
        $this._cancelButton.Width = 10
        $this._cancelButton.Height = 3
        $this._cancelButton.OnClick = { $this.Close($null) }.GetNewClosure()
        $this._panel.AddChild($this._cancelButton)
    }

    [void] Show([string]$title, [string]$message, [string]$defaultValue = "") {
        ([Dialog]$this).Show($title, $message)
        
        $this._inputBox.Text = $defaultValue
        $this._inputBox.CursorPosition = $defaultValue.Length
        
        $buttonY = $this.Height - 4
        $totalWidth = $this._okButton.Width + $this._cancelButton.Width + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        $this._okButton.X = $startX
        $this._okButton.Y = $buttonY
        $this._cancelButton.X = $startX + $this._okButton.Width + 4
        $this._cancelButton.Y = $buttonY
        
        $this._focusIndex = 0
        $this.UpdateFocus()
    }

    hidden [void] UpdateFocus() {
        $this._inputBox.IsFocused = ($this._focusIndex -eq 0)
        $this._okButton.IsFocused = ($this._focusIndex -eq 1)
        $this._cancelButton.IsFocused = ($this._focusIndex -eq 2)
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            $this._panel._private_buffer.WriteString(2, 2, 
                $this.Message, [ConsoleColor]::White, [ConsoleColor]::Black)
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) { $this.Close($null); return $true }
        if ($key.Key -eq [ConsoleKey]::Tab) {
            $this._focusIndex = ($this._focusIndex + 1) % 3
            $this.UpdateFocus()
            $this.RequestRedraw()
            return $true
        }
        
        switch ($this._focusIndex) {
            0 { return $this._inputBox.HandleInput($key) }
            1 { return $this._okButton.HandleInput($key) }
            2 { return $this._cancelButton.HandleInput($key) }
        }
        
        return $false
    }
}

# ==============================================================================
# CLASS: TaskDialog
#
# INHERITS:
#   - Dialog (ACO.017)
#
# DEPENDENCIES:
#   Models:
#     - PmcTask (AMO.003)
#   Components:
#     - Various input components like TextBoxComponent, ComboBoxComponent, etc.
#
# PURPOSE:
#   A complex dialog form for creating or editing a `PmcTask` object.
#
# KEY LOGIC:
#   - It composes multiple input components (TextBox, ComboBox, etc.) to
#     represent the fields of a `PmcTask`.
#   - `Initialize` populates the input fields with the data from the `PmcTask`
#     object passed to its constructor.
#   - `GetTask` is called after the dialog is completed with an "OK" result.
#     It reads the values from the input components and updates the internal
#     `_task` object before returning it.
# ==============================================================================
class TaskDialog : Dialog {
    hidden [TextBoxComponent] $_titleBox
    hidden [MultilineTextBoxComponent] $_descriptionBox
    hidden [ComboBoxComponent] $_statusCombo
    hidden [ComboBoxComponent] $_priorityCombo
    hidden [NumericInputComponent] $_progressInput
    hidden [ButtonComponent] $_saveButton
    hidden [ButtonComponent] $_cancelButton
    hidden [PmcTask] $_task
    hidden [bool] $_isNewTask
    
    TaskDialog([string]$title, [PmcTask]$task) : base($title) {
        $this._task = if ($task) { $task } else { [PmcTask]::new() }
        $this._isNewTask = ($null -eq $task)
        $this.Width = 60
        $this.Height = 20
    }
    
    [void] Initialize() {
        ([Dialog]$this).Initialize()
        
        $contentY = 2
        $labelWidth = 12
        $inputX = $labelWidth + 2
        $inputWidth = $this.ContentWidth - $inputX - 2
        
        # Title
        $titleLabel = [LabelComponent]::new("TitleLabel"); $titleLabel.Text = "Title:"; $titleLabel.X = 2; $titleLabel.Y = $contentY; $this._panel.AddChild($titleLabel)
        $this._titleBox = [TextBoxComponent]::new("TitleBox"); $this._titleBox.X = $inputX; $this._titleBox.Y = $contentY; $this._titleBox.Width = $inputWidth; $this._titleBox.Height = 1; $this._titleBox.Text = $this._task.Title; $this._panel.AddChild($this._titleBox)
        $contentY += 2
        
        # Description
        $descLabel = [LabelComponent]::new("DescLabel"); $descLabel.Text = "Description:"; $descLabel.X = 2; $descLabel.Y = $contentY; $this._panel.AddChild($descLabel)
        $this._descriptionBox = [MultilineTextBoxComponent]::new("DescBox"); $this._descriptionBox.X = $inputX; $this._descriptionBox.Y = $contentY; $this._descriptionBox.Width = $inputWidth; $this._descriptionBox.Height = 3; $this._descriptionBox.Text = $this._task.Description; $this._panel.AddChild($this._descriptionBox)
        $contentY += 4
        
        # Status
        $statusLabel = [LabelComponent]::new("StatusLabel"); $statusLabel.Text = "Status:"; $statusLabel.X = 2; $statusLabel.Y = $contentY; $this._panel.AddChild($statusLabel)
        $this._statusCombo = [ComboBoxComponent]::new("StatusCombo"); $this._statusCombo.X = $inputX; $this._statusCombo.Y = $contentY; $this._statusCombo.Width = $inputWidth; $this._statusCombo.Height = 1; $this._statusCombo.Items = @([TaskStatus]::GetEnumNames()); $this._statusCombo.SelectedIndex = [Array]::IndexOf($this._statusCombo.Items, $this._task.Status.ToString()); $this._panel.AddChild($this._statusCombo)
        $contentY += 2
        
        # Priority
        $priorityLabel = [LabelComponent]::new("PriorityLabel"); $priorityLabel.Text = "Priority:"; $priorityLabel.X = 2; $priorityLabel.Y = $contentY; $this._panel.AddChild($priorityLabel)
        $this._priorityCombo = [ComboBoxComponent]::new("PriorityCombo"); $this._priorityCombo.X = $inputX; $this._priorityCombo.Y = $contentY; $this._priorityCombo.Width = $inputWidth; $this._priorityCombo.Height = 1; $this._priorityCombo.Items = @([TaskPriority]::GetEnumNames()); $this._priorityCombo.SelectedIndex = [Array]::IndexOf($this._priorityCombo.Items, $this._task.Priority.ToString()); $this._panel.AddChild($this._priorityCombo)
        $contentY += 2
        
        # Progress
        $progressLabel = [LabelComponent]::new("ProgressLabel"); $progressLabel.Text = "Progress %:"; $progressLabel.X = 2; $progressLabel.Y = $contentY; $this._panel.AddChild($progressLabel)
        $this._progressInput = [NumericInputComponent]::new("ProgressInput"); $this._progressInput.X = $inputX; $this._progressInput.Y = $contentY; $this._progressInput.Width = 10; $this._progressInput.Height = 1; $this._progressInput.MinValue = 0; $this._progressInput.MaxValue = 100; $this._progressInput.Value = $this._task.Progress; $this._panel.AddChild($this._progressInput)
        $contentY += 3
        
        # Buttons
        $buttonY = $this.ContentHeight - 3; $buttonWidth = 12; $spacing = 2; $totalButtonWidth = ($buttonWidth * 2) + $spacing; $startX = [Math]::Floor(($this.ContentWidth - $totalButtonWidth) / 2)
        $thisDialog = $this
        $this._saveButton = [ButtonComponent]::new("SaveButton"); $this._saveButton.Text = "Save"; $this._saveButton.X = $startX; $this._saveButton.Y = $buttonY; $this._saveButton.Width = $buttonWidth; $this._saveButton.Height = 1; $this._saveButton.OnClick = { $thisDialog.DialogResult = [DialogResult]::OK; $thisDialog.Complete($thisDialog.DialogResult) }.GetNewClosure(); $this._panel.AddChild($this._saveButton)
        $this._cancelButton = [ButtonComponent]::new("CancelButton"); $this._cancelButton.Text = "Cancel"; $this._cancelButton.X = $startX + $buttonWidth + $spacing; $this._cancelButton.Y = $buttonY; $this._cancelButton.Width = $buttonWidth; $this._cancelButton.Height = 1; $this._cancelButton.OnClick = { $thisDialog.DialogResult = [DialogResult]::Cancel; $thisDialog.Complete($thisDialog.DialogResult) }.GetNewClosure(); $this._panel.AddChild($this._cancelButton)
        
        Set-ComponentFocus -Component $this._titleBox
    }
    
    [PmcTask] GetTask() {
        if ($this.DialogResult -eq [DialogResult]::OK) {
            $this._task.Title = $this._titleBox.Text
            $this._task.Description = $this._descriptionBox.Text
            $this._task.Status = [TaskStatus]::($this._statusCombo.Items[$this._statusCombo.SelectedIndex])
            $this._task.Priority = [TaskPriority]::($this._priorityCombo.Items[$this._priorityCombo.SelectedIndex])
            $this._task.SetProgress($this._progressInput.Value)
            $this._task.UpdatedAt = [DateTime]::Now
        }
        return $this._task
    }
}

# ==============================================================================
# CLASS: TaskDeleteDialog
#
# INHERITS:
#   - ConfirmDialog (ACO.019)
#
# DEPENDENCIES:
#   Models:
#     - PmcTask (AMO.003)
#   Components:
#     - LabelComponent (ACO.001)
#
# PURPOSE:
#   A specialized confirmation dialog used specifically for deleting a task.
#   It enhances the standard ConfirmDialog by displaying the name of the task
#   being deleted.
#
# KEY LOGIC:
#   - It inherits all the "Yes/No" button logic from `ConfirmDialog`.
#   - `Initialize` overrides the base to add an extra `LabelComponent` that
#     shows the title of the `_task` object, providing context to the user.
# ==============================================================================
class TaskDeleteDialog : ConfirmDialog {
    hidden [PmcTask] $_task
    
    TaskDeleteDialog([PmcTask]$task) : base("Confirm Delete", "Are you sure you want to delete this task?") {
        $this._task = $task
    }
    
    [void] Initialize() {
        ([ConfirmDialog]$this).Initialize()
        
        if ($this._task) {
            $detailsLabel = [LabelComponent]::new("TaskDetails")
            $detailsLabel.Text = "Task: $($this._task.Title)"
            $detailsLabel.X = 2
            $detailsLabel.Y = 4
            $detailsLabel.ForegroundColor = Get-ThemeColor -ColorName "Warning" -DefaultColor "#FFA500"
            $this._panel.AddChild($detailsLabel)
        }
    }
}

#endregion Dialog Components

#region Navigation Components

#<!-- END_PAGE: ACO.020 -->

#<!-- PAGE: ACO.021 - NavigationMenu Class -->
# ==============================================================================
# CLASS: NavigationMenu
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Models:
#     - NavigationItem (AMO.005)
#
# PURPOSE:
#   A simple menu component for displaying a list of `NavigationItem` objects
#   either horizontally or vertically. Used for top-level or contextual menus.
#
# KEY LOGIC:
#   - `OnRender` calls either `RenderHorizontal` or `RenderVertical` based on
#     the `Orientation` property.
#   - `HandleInput` allows navigation with arrow keys appropriate for the
#     orientation. Pressing Enter executes the `Action` scriptblock of the
#     currently selected `NavigationItem`.
# ==============================================================================
class NavigationMenu : UIElement {
    [List[NavigationItem]]$Items
    [int]$SelectedIndex = 0
    [string]$Orientation = "Horizontal"
    [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor]$ForegroundColor = [ConsoleColor]::White
    [ConsoleColor]$SelectedBackgroundColor = [ConsoleColor]::DarkBlue
    [ConsoleColor]$SelectedForegroundColor = [ConsoleColor]::Yellow

    NavigationMenu([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[NavigationItem]]::new()
        $this.Height = 1
    }

    [void] AddItem([NavigationItem]$item) {
        $this.Items.Add($item)
        $this.RequestRedraw()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', $this.ForegroundColor, $this.BackgroundColor))
            if ($this.Orientation -eq "Horizontal") { $this.RenderHorizontal() }
            else { $this.RenderVertical() }
        }
        catch {}
    }

    hidden [void] RenderHorizontal() {
        $currentX = 0
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex -and $this.IsFocused)
            
            $fg = if ($isSelected) { $this.SelectedForegroundColor } else { $this.ForegroundColor }
            $bg = if ($isSelected) { $this.SelectedBackgroundColor } else { $this.BackgroundColor }
            
            $text = if ($item.Hotkey) { " $($item.Text) ($($item.Hotkey)) " } else { " $($item.Text) " }
            
            if ($currentX + $text.Length -le $this.Width) {
                for ($x = 0; $x -lt $text.Length; $x++) {
                    $this._private_buffer.SetCell($currentX + $x, 0, [TuiCell]::new($text[$x], $fg, $bg))
                }
            }
            $currentX += $text.Length + 1
        }
    }

    hidden [void] RenderVertical() {
        $this.Height = [Math]::Max($this.Items.Count, 1)
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex -and $this.IsFocused)
            
            $fg = if ($isSelected) { $this.SelectedForegroundColor } else { $this.ForegroundColor }
            $bg = if ($isSelected) { $this.SelectedBackgroundColor } else { $this.BackgroundColor }
            
            for ($x = 0; $x -lt $this.Width; $x++) { $this._private_buffer.SetCell($x, $i, [TuiCell]::new(' ', $fg, $bg)) }
            
            $text = if ($item.Hotkey) { "$($item.Text) ($($item.Hotkey))" } else { $item.Text }
            if ($text.Length -gt $this.Width) { $text = $text.Substring(0, $this.Width - 3) + "..." }
            
            $this._private_buffer.WriteString(0, $i, $text, $fg, $bg)
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $true
        
        if ($this.Orientation -eq "Horizontal") {
            switch ($key.Key) {
                ([ConsoleKey]::LeftArrow) { if ($this.SelectedIndex -gt 0) { $this.SelectedIndex-- } }
                ([ConsoleKey]::RightArrow) { if ($this.SelectedIndex -lt $this.Items.Count - 1) { $this.SelectedIndex++ } }
                ([ConsoleKey]::Enter) { $this.ExecuteItem($this.SelectedIndex) }
                default { $handled = $this.CheckHotkey($key) }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) { if ($this.SelectedIndex -gt 0) { $this.SelectedIndex-- } }
                ([ConsoleKey]::DownArrow) { if ($this.SelectedIndex -lt $this.Items.Count - 1) { $this.SelectedIndex++ } }
                ([ConsoleKey]::Enter) { $this.ExecuteItem($this.SelectedIndex) }
                default { $handled = $this.CheckHotkey($key) }
            }
        }
        
        if ($handled) { $this.RequestRedraw() }
        
        return $handled
    }

    hidden [bool] CheckHotkey([System.ConsoleKeyInfo]$key) {
        foreach ($i in 0..($this.Items.Count - 1)) {
            $item = $this.Items[$i]
            if ($item.Hotkey -and $item.Hotkey.ToUpper() -eq $key.KeyChar.ToString().ToUpper()) {
                $this.SelectedIndex = $i
                $this.ExecuteItem($i)
                return $true
            }
        }
        return $false
    }

    hidden [void] ExecuteItem([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $item = $this.Items[$index]
            if ($item.Action) { try { & $item.Action } catch {} }
        }
    }
}

#<!-- END_PAGE: ACO.021 -->

#endregion Navigation Components

#region Dialog Result Enum
enum DialogResult {
    None = 0
    OK = 1
    Cancel = 2
    Yes = 3
    No = 4
    Retry = 5
    Abort = 6
}
#endregion


####\New folder\AllFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#<!-- PAGE: AFU.001 - TUI Drawing Functions -->
#region TUI Drawing Functions

# ==============================================================================
# FUNCTION: Write-TuiText
#
# DEPENDENCIES:
#   Classes:
#     - TuiBuffer (ABC.003)
#
# PURPOSE:
#   A high-level wrapper around the `TuiBuffer.WriteString` method. It provides
#   a convenient, PowerShell-idiomatic way for UI components to draw text onto
#   a buffer without needing to instantiate `TuiCell` objects manually.
#
# KEY LOGIC:
#   - Accepts a `TuiBuffer` target, position, text, and a style hashtable.
#   - Delegates the actual drawing logic directly to the `WriteString` method
#     on the provided buffer instance.
# ==============================================================================
function Write-TuiText {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][string]$Text,
        [hashtable]$Style = @{}
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
    $Buffer.WriteString($X, $Y, $Text, $Style)
}

# ==============================================================================
# FUNCTION: Write-TuiBox
#
# DEPENDENCIES:
#   Functions:
#     - Get-TuiBorderChars (AFU.002)
#     - Write-TuiText (AFU.001)
#   Classes:
#     - TuiBuffer (ABC.003)
#
# PURPOSE:
#   Draws a styled box with borders and an optional title onto a buffer. This
#   is the primary function used by Panel components to render their frames.
#
# KEY LOGIC:
#   - Retrieves the correct border characters using `Get-TuiBorderChars`.
#   - Fills the background of the box area first.
#   - Draws the top, bottom, and side borders using `Write-TuiText`.
#   - Intelligently places and truncates the title on the top border.
#   - Handles small dimension edge cases (e.g., a 1x1 or 2x2 box).
# ==============================================================================
function Write-TuiBox {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [string]$Title = "",
        [hashtable]$Style = @{}
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }

    $borderStyleName = $Style.BorderStyle ?? "Single"
    $borderColor = $Style.BorderFG ?? "#808080"
    $bgColor = $Style.BG ?? "#000000"
    $titleColor = $Style.TitleFG ?? $borderColor
    $fillChar = [char]($Style.FillChar ?? ' ')

    $borders = Get-TuiBorderChars -Style $borderStyleName
    
    $generalStyle = @{ FG = $borderColor; BG = $bgColor }
    $fillStyle = @{ FG = $borderColor; BG = $bgColor }
    $titleTextStyle = @{ FG = $titleColor; BG = $bgColor }
    if ($Style.TitleStyle) { foreach ($key in $Style.TitleStyle.Keys) { $titleTextStyle[$key] = $Style.TitleStyle[$key] } }

    $Buffer.FillRect($X, $Y, $Width, $Height, $fillChar, $fillStyle)
    
    if ($Height -gt 0) {
        if ($Width -gt 1) { Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * [Math]::Max(0, $Width - 2))$($borders.TopRight)" -Style $generalStyle }
        elseif ($Width -eq 1) { $Buffer.SetCell($X, $Y, [TuiCell]::new($borders.Vertical, $generalStyle.FG, $generalStyle.BG)) }
    }

    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $i) -Text $borders.Vertical -Style $generalStyle
        if ($Width -gt 1) { Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -Style $generalStyle }
    }
    
    if ($Height -gt 1) {
        if ($Width -gt 1) { Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * [Math]::Max(0, $Width - 2))$($borders.BottomRight)" -Style $generalStyle }
        elseif ($Width -eq 1) { $Buffer.SetCell($X, $Y + $Height - 1, [TuiCell]::new($borders.Vertical, $generalStyle.FG, $generalStyle.BG)) }
    }

    if (-not [string]::IsNullOrEmpty($Title) -and $Width -gt 2) {
        $titleText = " $Title "
        $maxTitleLength = $Width - 2
        if ($titleText.Length -gt $maxTitleLength) { $titleText = $titleText.Substring(0, $maxTitleLength - 3) + "..." }
        
        $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
        Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -Style $titleTextStyle
    }
    
    $Buffer.IsDirty = $true
}

#endregion
#<!-- END_PAGE: AFU.001 -->

#<!-- PAGE: AFU.002 - Border Functions -->
#region Border Functions

# ==============================================================================
# FUNCTION: Get-TuiBorderChars
#
# DEPENDENCIES:
#   - None
#
# PURPOSE:
#   A simple data retrieval function. It acts as a lookup table for different
#   box-drawing character sets (e.g., Single, Double, Rounded).
#
# KEY LOGIC:
#   - Contains a static hashtable of predefined border styles.
#   - Returns the hashtable of characters corresponding to the requested style,
#     defaulting to "Single" if the style is not found.
# ==============================================================================
function Get-TuiBorderChars {
    [CmdletBinding()]
    param(
        [ValidateSet("Single", "Double", "Rounded", "Thick")][string]$Style = "Single"
    )
    
    $styles = @{
        Single = @{ TopLeft = ''; TopRight = ''; BottomLeft = ''; BottomRight = ''; Horizontal = ''; Vertical = '' }
        Double = @{ TopLeft = ''; TopRight = ''; BottomLeft = ''; BottomRight = ''; Horizontal = ''; Vertical = '' }
        Rounded = @{ TopLeft = ''; TopRight = ''; BottomLeft = ''; BottomRight = ''; Horizontal = ''; Vertical = '' }
        Thick = @{ TopLeft = ''; TopRight = ''; BottomLeft = ''; BottomRight = ''; Horizontal = ''; Vertical = '' }
    }
    
    return $styles[$Style] ?? $styles.Single
}

#endregion
#<!-- END_PAGE: AFU.002 -->

#<!-- PAGE: AFU.003 - Factory Functions -->
#region Factory Functions

# ==============================================================================
# FUNCTION: New-Tui* (e.g., New-TuiLabel, New-TuiButton)
#
# DEPENDENCIES:
#   Classes:
#     - Various component classes from AllComponents.ps1 (e.g., LabelComponent)
#
# PURPOSE:
#   Provides a set of convenient, PowerShell-idiomatic factory functions for
#   creating instances of common UI components.
#
# KEY LOGIC:
#   - Each function is a simple wrapper around the `[new]` constructor of a
#     component class.
#   - They expose common properties as parameters, allowing for concise,
#     declarative UI construction in screen initialization code.
# ==============================================================================
function New-TuiBuffer { [CmdletBinding()]param([int]$Width,[int]$Height,[string]$Name="Unnamed"); return [TuiBuffer]::new($Width, $Height, $Name) }
function New-TuiLabel { param([string]$Name,[string]$Text="",[int]$X=0,[int]$Y=0,[string]$Fg=$null); $c=[LabelComponent]::new($Name);$c.Text=$Text;$c.X=$X;$c.Y=$Y;if($Fg){$c.ForegroundColor=$Fg};return $c }
function New-TuiButton { param([string]$Name,[string]$Text="Button",[int]$X=0,[int]$Y=0,[int]$W=10,[int]$H=3,[scriptblock]$OnClick=$null); $c=[ButtonComponent]::new($Name);$c.Text=$Text;$c.X=$X;$c.Y=$Y;$c.Width=$W;$c.Height=$H;if($OnClick){$c.OnClick=$OnClick};return $c }
function New-TuiTextBox { param([string]$Name,[string]$Placeholder="",[int]$X=0,[int]$Y=0,[int]$W=20,[int]$H=3,[scriptblock]$OnChange=$null); $c=[TextBoxComponent]::new($Name);$c.Placeholder=$Placeholder;$c.X=$X;$c.Y=$Y;$c.Width=$W;$c.Height=$H;if($OnChange){$c.OnChange=$OnChange};return $c }
function New-TuiCheckBox { param([string]$Name,[string]$Text="Checkbox",[int]$X=0,[int]$Y=0,[bool]$Checked=$false,[scriptblock]$OnChange=$null); $c=[CheckBoxComponent]::new($Name);$c.Text=$Text;$c.X=$X;$c.Y=$Y;$c.Checked=$Checked;if($OnChange){$c.OnChange=$OnChange};return $c }
function New-TuiRadioButton { param([string]$Name,[string]$Text="Radio",[string]$Group="default",[int]$X=0,[int]$Y=0,[bool]$Selected=$false,[scriptblock]$OnChange=$null); $c=[RadioButtonComponent]::new($Name);$c.Text=$Text;$c.GroupName=$Group;$c.X=$X;$c.Y=$Y;$c.Selected=$Selected;if($OnChange){$c.OnChange=$OnChange};return $c }

#endregion
#<!-- END_PAGE: AFU.003 -->

#<!-- PAGE: AFU.004 - Theme Functions -->
#region Theme Functions

# ==============================================================================
# FUNCTION: Get-ThemeColor
#
# DEPENDENCIES:
#   Services:
#     - ThemeManager (ASE.005) (via $global:TuiState)
#
# PURPOSE:
#   The single point of access for all UI components to retrieve colors from the
#   currently active theme.
#
# KEY LOGIC:
#   - Retrieves the `ThemeManager` instance from the global state.
#   - Calls the manager's `GetColor` method to look up a color by its semantic
#     name (e.g., "button.focused.bg").
#   - Returns a default color if the `ThemeManager` isn't available or the
#     color name is not found, ensuring the UI never fails to render due to a
#     missing color definition.
# ==============================================================================
function Get-ThemeColor {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$ColorName,
        [string]$DefaultColor = "#808080"
    )
    $themeManager = $global:TuiState.Services.ThemeManager
    if ($themeManager) {
        $color = $themeManager.GetColor($ColorName, $DefaultColor)
        if ($color) { return $color }
    }
    return $DefaultColor
}

#endregion
#<!-- END_PAGE: AFU.004 -->

#<!-- PAGE: AFU.005 - Focus Management -->
#region Focus Management Functions

# ==============================================================================
# FUNCTION: Set-ComponentFocus
#
# DEPENDENCIES:
#   Services:
#     - FocusManager (ASE.009) (via $global:TuiState)
#
# PURPOSE:
#   A global convenience function to set input focus on a specific component.
#   (DEPRECATED in favor of direct service access).
#
# KEY LOGIC:
#   - Retrieves the `FocusManager` instance from the global state.
#   - Delegates the call directly to `FocusManager.SetFocus()`.
# ==============================================================================
function Set-ComponentFocus {
    [CmdletBinding()]
    param([Parameter(Mandatory)][UIElement]$Component)
    $global:TuiState.Services.FocusManager?.SetFocus($Component)
}

#endregion
#<!-- END_PAGE: AFU.005 -->

#<!-- PAGE: AFU.006 - Logging Functions -->
#region Logging Functions

# ==============================================================================
# FUNCTION: Write-Log
#
# DEPENDENCIES:
#   Services:
#     - Logger (ASE.006) (via $global:TuiState)
#
# PURPOSE:
#   The single, centralized function for all framework and application-level
#   logging. It provides a consistent logging interface that can be routed to
#   different outputs by the `Logger` service.
#
# KEY LOGIC:
#   - Attempts to get the `Logger` service instance from the global state.
#   - If the service is found, it calls the service's `Log` method, passing
#     the level, message, and any additional structured data.
#   - If the `Logger` service is not yet available (e.g., during initial
#     startup), it provides a fallback mechanism to write directly to the host
#     console with basic color-coding.
# ==============================================================================
function Write-Log {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][ValidateSet('Trace', 'Debug', 'Info', 'Warning', 'Error', 'Fatal')][string]$Level,
        [Parameter(Mandatory)][string]$Message,
        [object]$Data = $null
    )
    $logger = $global:TuiState.Services.Logger
    if ($logger) {
        $logger.Log($Level, $Message, $Data)
    }
    else {
        $timestamp = Get-Date -Format "HH:mm:ss"
        $prefix = "[$timestamp] [$Level]"
        $color = switch ($Level) {
            'Error' { 'Red' }
            'Warning' { 'Yellow' }
            'Info' { 'Cyan' }
            default { 'Gray' }
        }
        Write-Host "$prefix $Message" -ForegroundColor $color
    }
}

#endregion
#<!-- END_PAGE: AFU.006 -->

#<!-- PAGE: AFU.007 - Event Functions -->
#region Event System

# ==============================================================================
# FUNCTION: Subscribe-Event / Unsubscribe-Event / Publish-Event
#
# DEPENDENCIES:
#   Services:
#     - EventManager (ASE.007) (via $global:TuiState)
#
# PURPOSE:
#   A set of global convenience functions that act as wrappers around the
#   `EventManager` service. They provide a simple, global way for any part of
#   the code to participate in the event system.
#
# KEY LOGIC:
#   - Each function retrieves the `EventManager` instance from the global state.
#   - They delegate the call directly to the corresponding method on the service
#     instance (`Subscribe`, `Unsubscribe`, `Publish`).
# ==============================================================================
function Subscribe-Event {
    [CmdletBinding()]
    param([string]$EventName,[scriptblock]$Handler,[string]$Source="");
    return $global:TuiState.Services.EventManager?.Subscribe($EventName, $Handler)
}

function Unsubscribe-Event {
    [CmdletBinding()]
    param([string]$EventName,[string]$HandlerId);
    $global:TuiState.Services.EventManager?.Unsubscribe($EventName, $HandlerId)
}

function Publish-Event {
    [CmdletBinding()]
    param([string]$EventName,[hashtable]$EventData=@{});
    $global:TuiState.Services.EventManager?.Publish($EventName, $EventData)
}

#endregion
#<!-- END_PAGE: AFU.007 -->

#<!-- PAGE: AFU.008 - Error Handling -->
#region Error Handling Functions
#endregion
#<!-- END_PAGE: AFU.008 -->

#<!-- PAGE: AFU.009 - Input Processing -->
#region Input Processing Functions
#endregion
#<!-- END_PAGE: AFU.009 -->

#<!-- PAGE: AFU.010 - Utility Functions -->
#region Utility Functions
#endregion
#<!-- END_PAGE: AFU.010 -->


####\New folder\AllModels.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Models (No UI Dependencies) - UPDATED
# Data models, enums, and validation classes
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AMO.###" to find specific sections.
# Each section ends with "END_PAGE: AMO.###"
# ==============================================================================

#<!-- PAGE: AMO.001 - Enums -->
#region Enums

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

enum BillingType {
    Billable
    NonBillable
}

enum DialogResult {
    None
    OK
    Cancel
    Yes
    No
    Abort
    Retry
    Ignore
}

#endregion
#<!-- END_PAGE: AMO.001 -->

#<!-- PAGE: AMO.002 - ValidationBase Class -->
#region Base Validation Class

# ==============================================================================
# CLASS: ValidationBase
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   - None
#
# PURPOSE:
#   A static utility class providing common validation logic for other model
#   classes to inherit. This promotes code reuse for data integrity checks.
#
# KEY LOGIC:
#   - Contains static methods like `ValidateNotEmpty` to enforce data integrity
#     rules (e.g., a task title cannot be empty) in a consistent way across
#     the data model layer.
# ==============================================================================
class ValidationBase {
    static [void] ValidateNotEmpty(
        [string]$value,
        [string]$parameterName
    ) {
        if ([string]::IsNullOrWhiteSpace($value)) {
            throw [System.ArgumentException]::new("Parameter '$($parameterName)' cannot be null or empty.", $parameterName)
        }
    }
}

#endregion
#<!-- END_PAGE: AMO.002 -->

#<!-- PAGE: AMO.003 - Core Model Classes -->
#region Core Model Classes

# ==============================================================================
# CLASS: PmcTask
#
# INHERITS:
#   - ValidationBase (AMO.002)
#
# DEPENDENCIES:
#   Enums:
#     - TaskStatus (AMO.001)
#     - TaskPriority (AMO.001)
#
# PURPOSE:
#   Represents the core data entity for a single task. It is a plain data
#   object with its own internal business logic, holding no references to UI
#   components.
#
# KEY LOGIC:
#   - Contains properties for all task attributes (Title, Status, Priority, etc.).
#   - Provides business logic methods for state transitions, such as `Complete()`,
#     `SetProgress()`, and checks like `IsOverdue()`.
#   - Includes `ToLegacyFormat()` and `FromLegacyFormat()` static methods for
#     robust JSON serialization/deserialization, decoupling the live class
#     from the on-disk data format.
# ==============================================================================
class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()
    [string]$Title
    [string]$Description
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [string]$ProjectKey = "General"
    [string]$Category
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now
    [Nullable[datetime]]$DueDate
    [string[]]$Tags = @()
    [int]$Progress = 0
    [bool]$Completed = $false

    PmcTask() {}
    PmcTask([string]$title) {
        [ValidationBase]::ValidateNotEmpty($title, "Title"); $this.Title = $title
    }
    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) {
        [ValidationBase]::ValidateNotEmpty($title, "Title"); [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")
        $this.Title = $title; $this.Description = $description; $this.Priority = $priority; $this.ProjectKey = $projectKey
        $this.Category = $projectKey
    }

    [void] Complete() {
        $this.Status = [TaskStatus]::Completed; $this.Progress = 100; $this.Completed = $true; $this.UpdatedAt = [datetime]::Now
    }
    
    [void] SetProgress([int]$progress) {
        if ($progress -lt 0 -or $progress -gt 100) { throw [System.ArgumentOutOfRangeException]::new("progress", "Progress must be between 0 and 100.") }
        $this.Progress = $progress
        if ($progress -eq 100) { $this.Complete() }
        elseif ($progress -gt 0) { $this.Status = [TaskStatus]::InProgress }
        $this.UpdatedAt = [datetime]::Now
    }
    
    [bool] IsOverdue() {
        if (-not $this.DueDate) { return $false }
        if ($this.Status -in @([TaskStatus]::Completed, [TaskStatus]::Cancelled)) { return $false }
        return [datetime]::Now -gt $this.DueDate
    }
    
    [hashtable] ToLegacyFormat() {
        return @{
            Id = $this.Id; Title = $this.Title; Description = $this.Description; Status = $this.Status.ToString(); Priority = $this.Priority.ToString()
            ProjectKey = $this.ProjectKey; Category = $this.Category; CreatedAt = $this.CreatedAt.ToString("o"); UpdatedAt = $this.UpdatedAt.ToString("o")
            DueDate = if ($this.DueDate) { $this.DueDate.Value.ToString("o") } else { $null }
            Tags = $this.Tags; Progress = $this.Progress; Completed = $this.Completed
        }
    }
    
    static [PmcTask] FromLegacyFormat([hashtable]$data) {
        $task = [PmcTask]::new()
        foreach ($prop in @('Id','Title','Description','ProjectKey','Category')) { if ($data.ContainsKey($prop)) { $task.$prop = $data.$prop } }
        if ($data.Status) { $task.Status = [TaskStatus]$data.Status }
        if ($data.Priority) { $task.Priority = [TaskPriority]$data.Priority }
        if ($data.CreatedAt) { $task.CreatedAt = [DateTime]::Parse($data.CreatedAt) }
        if ($data.UpdatedAt) { $task.UpdatedAt = [DateTime]::Parse($data.UpdatedAt) }
        if ($data.DueDate) { $task.DueDate = [DateTime]::Parse($data.DueDate) }
        if ($data.Tags) { $task.Tags = @($data.Tags) }
        if ($data.ContainsKey('Progress')) { $task.Progress = [int]$data.Progress }
        if ($data.ContainsKey('Completed')) { $task.Completed = [bool]$data.Completed }
        return $task
    }
}

# ==============================================================================
# CLASS: PmcProject
#
# INHERITS:
#   - ValidationBase (AMO.002)
#
# DEPENDENCIES:
#   - None
#
# PURPOSE:
#   Represents a project, which acts as a logical container or category for a
#   group of tasks. It is a plain data object.
#
# KEY LOGIC:
#   - Contains properties like `Key` (a unique identifier), `Name`, and an
#     `IsActive` flag for archival purposes.
#   - Provides methods like `Archive()` and `Activate()` to manage its lifecycle.
#   - Includes `ToLegacyFormat()` and `FromLegacyFormat()` for robust JSON
#     serialization/deserialization.
# ==============================================================================
class PmcProject : ValidationBase {
    [string]$Key
    [string]$Name
    [string]$Description
    [DateTime]$CreatedAt = [DateTime]::Now
    [DateTime]$UpdatedAt = [DateTime]::Now
    [string]$Owner
    [bool]$IsActive = $true
    
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key"); [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key; $this.Name = $name
    }

    [void] Archive() { $this.IsActive = $false; $this.UpdatedAt = [DateTime]::Now }
    [void] Activate() { $this.IsActive = $true; $this.UpdatedAt = [DateTime]::Now }
}

# ==============================================================================
# CLASS: TimeEntry
#
# INHERITS:
#   - ValidationBase (AMO.002)
#
# DEPENDENCIES:
#   Enums:
#     - BillingType (AMO.001)
#
# PURPOSE:
#   Represents a discrete block of time logged against a specific task.
#
# KEY LOGIC:
#   - Links to a `TaskId` and `ProjectKey`.
#   - `GetDuration()` calculates the time elapsed between `StartTime` and
#     `EndTime` (or `Now` if the timer is still running).
#   - `Stop()` method finalizes the entry by setting the `EndTime`.
# ==============================================================================
class TimeEntry : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()
    [string]$TaskId
    [string]$ProjectKey
    [DateTime]$StartTime
    [Nullable[DateTime]]$EndTime
    [string]$Description
    [BillingType]$BillingType = [BillingType]::Billable
    
    TimeEntry([string]$taskId, [string]$projectKey, [DateTime]$startTime) {
        [ValidationBase]::ValidateNotEmpty($taskId, "TaskId"); [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")
        $this.TaskId = $taskId; $this.ProjectKey = $projectKey; $this.StartTime = $startTime
    }

    [TimeSpan] GetDuration() {
        if ($this.EndTime) { return $this.EndTime.Value - $this.StartTime }
        return [DateTime]::Now - $this.StartTime
    }

    [void] Stop() { if (-not $this.EndTime) { $this.EndTime = [DateTime]::Now } }
}

#endregion
#<!-- END_PAGE: AMO.003 -->

#<!-- PAGE: AMO.004 - Exception Classes -->
#region Exception Classes

# ==============================================================================
# CLASS: HeliosException
#
# INHERITS:
#   - System.Exception
#
# DEPENDENCIES:
#   - None
#
# PURPOSE:
#   The base exception for all custom exceptions within the Axiom-Phoenix
#   framework. This allows for a single `catch [HeliosException]` block to
#   handle all known framework errors.
#
# KEY LOGIC:
#   - Extends `System.Exception` to add framework-specific diagnostic data,
#     such as the `Component` where the error originated and additional `Context`
#     information, making debugging significantly easier.
# ==============================================================================
class HeliosException : System.Exception {
    [string]$Component
    [hashtable]$Context = @{}
    
    HeliosException([string]$message, [string]$component = "Framework", [hashtable]$context = @{}, [Exception]$innerException = $null) : base($message, $innerException) {
        $this.Component = $component
        $this.Context = $context
    }
}
class NavigationException : HeliosException { }
class ServiceInitializationException : HeliosException { }
class ComponentRenderException : HeliosException { }
class StateMutationException : HeliosException { }
class InputHandlingException : HeliosException { }
class DataLoadException : HeliosException { }

#endregion
#<!-- END_PAGE: AMO.004 -->

#<!-- PAGE: AMO.005 - Navigation Classes -->
#region Navigation Classes

# ==============================================================================
# CLASS: NavigationItem
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   - None
#
# PURPOSE:
#   A data model representing a single clickable or selectable item within a
#   `NavigationMenu` component. It decouples the menu's visual representation
#   from the action that is performed.
#
# KEY LOGIC:
#   - Encapsulates the display text (`Label`), the action to perform (`Action`
#     scriptblock), a unique `Key`, and its state (`Enabled`, `Visible`).
# ==============================================================================
class NavigationItem {
    [string]$Key
    [string]$Label
    [scriptblock]$Action
    [bool]$Enabled = $true
    [bool]$Visible = $true
    [string]$Description = ""

    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key)) { throw [System.ArgumentException]::new("key") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [System.ArgumentException]::new("label") }
        if (-not $action) { throw [System.ArgumentNullException]::new("action") }

        $this.Key = $key.ToUpper(); $this.Label = $label; $this.Action = $action
    }

    [void] Execute() { if ($this.Enabled) { & $this.Action } }
}

#endregion
#<!-- END_PAGE: AMO.005 -->


####\New folder\AllRuntime.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Runtime (Load Last)
# TUI engine, screen management, and main application loop
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ART.###" to find specific sections.
# Each section ends with "END_PAGE: ART.###"
# ==============================================================================

#<!-- PAGE: ART.001 - Global State -->
#region Global State

# $global:TuiState is the central, volatile state store for the running
# application. It holds references to the current screen, buffers, services,
# and engine control flags. It is initialized here and populated by
# Start-AxiomPhoenix.
$global:TuiState = @{
    Running = $false
    BufferWidth = 0
    BufferHeight = 0
    CompositorBuffer = $null
    PreviousCompositorBuffer = $null
    CurrentScreen = $null
    IsDirty = $true
    FocusedComponent = $null
    CommandPalette = $null
    Services = @{}
    ServiceContainer = $null
    LastRenderTime = [datetime]::Now
    FrameCount = 0
    OverlayStack = [System.Collections.Generic.List[UIElement]]::new()
}

# ==============================================================================
# FUNCTION: Invoke-WithErrorHandling (Internal Utility)
#
# PURPOSE:
#   A wrapper to execute a scriptblock within a try/catch block, centralizing
#   the logging of non-fatal errors that occur during UI operations.
#
# KEY LOGIC:
#   - Executes the provided ScriptBlock.
#   - If an exception is caught, it logs a structured error message using
#     Write-Log, including the component, context, and error details.
#   - It re-throws the exception so the original calling context can handle it
#     further if necessary.
# ==============================================================================
function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Component,
        [Parameter(Mandatory)][string]$Context,
        [Parameter(Mandatory)][scriptblock]$ScriptBlock,
        [hashtable]$AdditionalData = @{}
    )
    try {
        & $ScriptBlock
    }
    catch {
        $errorDetails = @{ Component = $Component; Context = $Context; ErrorMessage = $_.Exception.Message; StackTrace = $_.ScriptStackTrace }
        foreach ($key in $AdditionalData.Keys) { $errorDetails[$key] = $AdditionalData[$key] }
        Write-Log -Level Error -Message "Error in $Component during $Context: $($_.Exception.Message)" -Data $errorDetails
        throw
    }
}

#endregion
#<!-- END_PAGE: ART.001 -->

#<!-- PAGE: ART.002 - Engine Management -->
#region Engine Management

# ==============================================================================
# FUNCTION: Initialize-TuiEngine
#
# PURPOSE:
#   Prepares the console host for TUI rendering. This is one of the first
#   functions called when the application starts.
#
# KEY LOGIC:
#   - Sets the console output encoding to UTF-8 to support special characters.
#   - Hides the cursor and sets the window title.
#   - Calls `Update-TuiEngineSize` to get the initial console dimensions.
#   - Creates the main `CompositorBuffer` and `PreviousCompositorBuffer` based
#     on the console size.
# ==============================================================================
function Initialize-TuiEngine {
    [CmdletBinding()]
    param()
    try {
        Write-Log -Level Info -Message "Initializing TUI engine..."
        [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        [Console]::CursorVisible = $false
        $Host.UI.RawUI.WindowTitle = "Axiom-Phoenix v4.0"
        Clear-Host
        [Console]::SetCursorPosition(0, 0)
        
        Update-TuiEngineSize
        
        $width = $global:TuiState.BufferWidth
        $height = $global:TuiState.BufferHeight
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($width, $height, "Compositor")
        $global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new($width, $height, "PreviousCompositor")
        
        $bgColor = Get-ThemeColor -ColorName "Background" -DefaultColor "#000000"
        $fillCell = [TuiCell]::new(' ', $bgColor, $bgColor)
        $global:TuiState.CompositorBuffer.Clear($fillCell)
        $global:TuiState.PreviousCompositorBuffer.Clear($fillCell)
        
        Write-Log -Level Info -Message "TUI engine initialized. Buffer size: ${width}x${height}"
    }
    catch {
        Invoke-PanicHandler $_
    }
}

# ==============================================================================
# FUNCTION: Start-TuiEngine
#
# PURPOSE:
#   The main application loop. It runs continuously until the application is
#   instructed to exit.
#
# KEY LOGIC:
#   1. Checks for console window resize events and calls `Update-TuiEngineSize`
#      if detected.
#   2. Calls `Process-TuiInput` to handle any pending keyboard events.
#   3. Calls `Invoke-TuiRender` to draw the current state of the UI to the screen.
#   4. Implements frame-rate throttling by sleeping for a calculated duration
#      at the end of each loop to prevent high CPU usage and ensure a stable
#      refresh rate (typically targeting ~30 FPS).
# ==============================================================================
function Start-TuiEngine {
    [CmdletBinding()]
    param()
    try {
        Write-Log -Level Info -Message "Starting TUI Engine main loop..."
        $global:TuiState.Running = $true
        $frameTimer = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTimeMs = 33 # Target ~30 FPS
        
        while ($global:TuiState.Running) {
            $frameTimer.Restart()
            
            if ([Console]::WindowWidth -ne $global:TuiState.BufferWidth -or [Console]::WindowHeight -ne $global:TuiState.BufferHeight) {
                Update-TuiEngineSize
            }
            
            Process-TuiInput
            
            # Rendering is now driven by component state (_needs_redraw)
            Invoke-TuiRender
            
            $frameTimer.Stop()
            $elapsedMs = $frameTimer.ElapsedMilliseconds
            if ($elapsedMs -lt $targetFrameTimeMs) {
                Start-Sleep -Milliseconds ($targetFrameTimeMs - $elapsedMs)
            }
            $global:TuiState.FrameCount++
        }
    }
    catch {
        Invoke-PanicHandler $_
    }
    finally {
        Stop-TuiEngine
    }
}

# ==============================================================================
# FUNCTION: Stop-TuiEngine
#
# PURPOSE:
#   Gracefully shuts down the TUI engine and restores the console to its
#   original state.
#
# KEY LOGIC:
#   - Sets the global `Running` flag to false to terminate the main loop.
#   - Iterates through all registered services and calls their `Cleanup` method
#     if it exists. This ensures resources like file handles (Logger) and
#     event subscriptions are released.
#   - Makes the cursor visible again and clears the screen.
# ==============================================================================
function Stop-TuiEngine {
    [CmdletBinding()]
    param()
    try {
        Write-Log -Level Info -Message "Stopping TUI Engine..."
        $global:TuiState.Running = $false
        
        $global:TuiState.ServiceContainer?.Cleanup()
        
        [Console]::CursorVisible = $true
        [Console]::Clear()
        [Console]::SetCursorPosition(0, 0)
        Write-Host "Axiom-Phoenix session terminated."
    }
    catch {
        # Fallback to console write if logger fails during shutdown
        Write-Error "Error stopping TUI engine: $_"
    }
}

# ==============================================================================
# FUNCTION: Update-TuiEngineSize
#
# PURPOSE:
#   Handles console window resize events.
#
# KEY LOGIC:
#   - Reads the new dimensions from `[Console]::WindowWidth/Height`.
#   - Updates the corresponding values in `$global:TuiState`.
#   - Calls the `Resize` method on the main compositor buffers and the current
#     screen, which propagates the resize down the UI component tree.
#   - Forces a full redraw of the UI.
# ==============================================================================
function Update-TuiEngineSize {
    [CmdletBinding()]
    param()
    try {
        $newWidth = [Console]::WindowWidth
        $newHeight = [Console]::WindowHeight
        Write-Log -Level Debug -Message "Console resized to ${newWidth}x${newHeight}"
        
        $global:TuiState.BufferWidth = $newWidth
        $global:TuiState.BufferHeight = $newHeight
        
        $global:TuiState.CompositorBuffer?.Resize($newWidth, $newHeight)
        $global:TuiState.PreviousCompositorBuffer?.Resize($newWidth, $newHeight)
        $global:TuiState.CurrentScreen?.Resize($newWidth, $newHeight)
        
        $global:TuiState.IsDirty = $true
        if ($global:TuiState.CompositorBuffer) { [Console]::Clear() }
    }
    catch {
        Write-Log -Level Error -Message "Failed to update engine size: $($_.Exception.Message)" -Data $_
    }
}

#endregion
#<!-- END_PAGE: ART.002 -->

#<!-- PAGE: ART.003 - Rendering System -->
#region Rendering System

# ==============================================================================
# FUNCTION: Invoke-TuiRender
#
# PURPOSE:
#   The main rendering orchestrator, called once per frame from the engine loop.
#
# KEY LOGIC:
#   1. Clears the main `CompositorBuffer`.
#   2. Renders the `$global:TuiState.CurrentScreen` into its own buffer.
#   3. Blends the current screen's buffer onto the `CompositorBuffer`.
#   4. Renders any active overlays (like dialogs from the `OverlayStack`) on top,
#      blending them onto the `CompositorBuffer` in order.
#   5. Calls `Render-DifferentialBuffer` to perform the optimized write to the
#      console.
#   6. Clones the `CompositorBuffer` to `PreviousCompositorBuffer` in preparation
#      for the next frame's differential comparison.
# ==============================================================================
function Invoke-TuiRender {
    [CmdletBinding()]
    param()
    try {
        if (-not $global:TuiState.CompositorBuffer) { return }
        
        $bgColor = Get-ThemeColor -ColorName "Background" -DefaultColor "#000000"
        $global:TuiState.CompositorBuffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        $currentScreenToRender = $global:TuiState.CurrentScreen
        if ($currentScreenToRender) {
            $currentScreenToRender.Render()
            $screenBuffer = $currentScreenToRender.GetBuffer()
            if ($screenBuffer) {
                $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
            }
        }
        
        if ($global:TuiState.OverlayStack) {
            foreach ($overlay in $global:TuiState.OverlayStack) {
                if ($overlay -and $overlay.Visible) {
                    $overlay.Render()
                    $overlayBuffer = $overlay.GetBuffer()
                    if ($overlayBuffer) {
                        $global:TuiState.CompositorBuffer.BlendBuffer($overlayBuffer, $overlay.X, $overlay.Y)
                    }
                }
            }
        }
        
        Render-DifferentialBuffer
        
        $global:TuiState.PreviousCompositorBuffer = $global:TuiState.CompositorBuffer.Clone()
        
    }
    catch {
        Write-Log -Level Error -Message "Render error in Invoke-TuiRender: $($_.Exception.Message)" -Data $_
        # Do not re-throw from render loop to avoid crashing the app
    }
}

# ==============================================================================
# FUNCTION: Render-DifferentialBuffer
#
# PURPOSE:
#   The core of the rendering optimization. It compares the current frame's
#   compositor buffer with the previous frame's buffer and only writes the
#   changed cells to the terminal.
#
# KEY LOGIC:
#   - Iterates through every cell (X, Y) of the `CompositorBuffer`.
#   - Compares each `TuiCell` with the cell at the same position in the
#     `PreviousCompositorBuffer` using the cell's `DiffersFrom()` method.
#   - If a cell has changed, it builds up an ANSI escape code string to move the
#     cursor to that position and print the new cell's character with its new
#     styling.
#   - All changes are aggregated into a single `StringBuilder` and written to
#     the console in one operation to minimize screen flicker.
# ==============================================================================
function Render-DifferentialBuffer {
    [CmdletBinding()]
    param()
    try {
        $current = $global:TuiState.CompositorBuffer
        $previous = $global:TuiState.PreviousCompositorBuffer
        if (-not $current -or -not $previous) { return }
        
        $ansiBuilder = [System.Text.StringBuilder]::new()
        $lastX = -1; $lastY = -1
        
        for ($y = 0; $y -lt $current.Height; $y++) {
            for ($x = 0; $x -lt $current.Width; $x++) {
                $currentCell = $current.GetCell($x, $y)
                $previousCell = $previous.GetCell($x, $y)
                
                if ($currentCell.DiffersFrom($previousCell)) {
                    if ($lastY -ne $y -or $lastX -ne ($x - 1)) {
                        [void]$ansiBuilder.Append("`e[$($y + 1);$($x + 1)H")
                    }
                    [void]$ansiBuilder.Append($currentCell.ToAnsiString())
                    $lastX = $x; $lastY = $y
                }
            }
        }
        
        if ($ansiBuilder.Length -gt 0) {
            [void]$ansiBuilder.Append("`e[0m")
            [Console]::Write($ansiBuilder.ToString())
        }
    }
    catch {
        Write-Log -Level Error -Message "Differential rendering error: $($_.Exception.Message)" -Data $_
    }
}

#endregion
#<!-- END_PAGE: ART.003 -->

#<!-- PAGE: ART.004 - Input Processing -->
#region Input Processing

# ==============================================================================
# FUNCTION: Process-TuiInput
#
# PURPOSE:
#   The central input handling routine, called once per frame from the engine
#   loop. It determines which component should receive the keyboard input based
#   on a strict order of precedence.
#
# KEY LOGIC:
#   The order of precedence is:
#   1. **Overlays**: If an overlay (dialog) is active, it gets the first chance.
#   2. **Focused Component**: The component currently focused by `FocusManager`.
#   3. **Global Keybindings**: `KeybindingService` checks for global hotkeys.
#   4. **Current Screen**: The top-level screen gets a final chance.
#
#   If any layer in this chain handles the input (returns $true), processing stops.
# ==============================================================================
function Process-TuiInput {
    [CmdletBinding()]
    param()
    try {
        while ([Console]::KeyAvailable) {
            $keyInfo = [Console]::ReadKey($true)
            
            # 1. Overlay gets highest priority
            if ($global:TuiState.OverlayStack.Count -gt 0) {
                $topOverlay = $global:TuiState.OverlayStack[-1]
                if ($topOverlay?.HandleInput($keyInfo)) { $global:TuiState.IsDirty = $true; continue }
            }
            
            # 2. Focused component is next
            $focusManager = $global:TuiState.Services.FocusManager
            if ($focusManager.FocusedComponent?.HandleInput($keyInfo)) { $global:TuiState.IsDirty = $true; continue }

            # 3. Global Keybindings
            $keybindingService = $global:TuiState.Services.KeybindingService
            if ($keybindingService) {
                $action = $keybindingService.GetAction($keyInfo)
                if ($action) {
                    $global:TuiState.Services.ActionService?.ExecuteAction($action, @{})
                    $global:TuiState.IsDirty = $true
                    continue
                }
            }
            
            # 4. Current Screen gets last chance
            if ($global:TuiState.CurrentScreen?.HandleInput($keyInfo)) {
                $global:TuiState.IsDirty = $true
                continue
            }
        }
    }
    catch {
        Write-Log -Level Error -Message "Input processing error: $($_.Exception.Message)" -Data $_
    }
}

#endregion
#<!-- END_PAGE: ART.004 -->

#<!-- PAGE: ART.005 - Screen Management -->
#region Overlay Management
# DEPRECATED - Logic is now in DialogManager (ASE.009)
#endregion
#<!-- END_PAGE: ART.005 -->

#<!-- PAGE: ART.006 - Error Handling -->
#region Panic Handler

# ==============================================================================
# FUNCTION: Invoke-PanicHandler
#
# PURPOSE:
#   A last-resort error handler for unrecoverable exceptions that occur in the
#   main engine loop. Its job is to safely terminate the TUI, restore the
#   console, and display a helpful error report to the user.
#
# KEY LOGIC:
#   - Restores the console to a usable state (visible cursor, reset color).
#   - Prints a formatted error message including the exception message, type,
#     and stack trace.
#   - Gathers system information and a snapshot of the TUI state.
#   - Saves a detailed crash report to a log file in the user's temp directory.
#   - Halts execution and exits the application.
# ==============================================================================
function Invoke-PanicHandler {
    [CmdletBinding()]
    param([Parameter(Mandatory)][object]$ErrorRecord)
    
    try { [Console]::ResetColor(); [Console]::CursorVisible = $true; Clear-Host } catch { }
    
    Write-Host "`nPANIC: An unrecoverable error has occurred:`n" -ForegroundColor Red
    Write-Host "  Message: $($ErrorRecord.Exception.Message)" -ForegroundColor Yellow
    Write-Host "  Type:    $($ErrorRecord.Exception.GetType().FullName)" -ForegroundColor Yellow
    Write-Host "`nSTACK TRACE:`n$($ErrorRecord.ScriptStackTrace)" -ForegroundColor DarkGray
    
    $crashDir = Join-Path $env:TEMP "AxiomPhoenix\Crashes"
    if (-not (Test-Path $crashDir)) { New-Item -ItemType Directory -Path $crashDir -Force | Out-Null }
    $crashFile = Join-Path $crashDir "crash_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
    try {
        $ErrorRecord | ConvertTo-Json -Depth 5 | Out-File -FilePath $crashFile -Encoding UTF8
        Write-Host "`nCrash report saved to: $crashFile" -ForegroundColor Green
    } catch {
        Write-Host "`nFailed to save crash report: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    Write-Host "`nPress any key to exit..." -ForegroundColor Yellow
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    Stop-TuiEngine
    exit 1
}

# ==============================================================================
# FUNCTION: Start-AxiomPhoenix
#
# PURPOSE:
#   The main entry point for the entire application. It wires together all the
#   services and starts the TUI engine.
#
# KEY LOGIC:
#   - Takes the pre-configured `ServiceContainer` as a parameter.
#   - Populates the `$global:TuiState.Services` hashtable by resolving all
#     necessary services from the container. This makes them easily accessible
#     to the rest of the framework.
#   - Initializes the TUI engine via `Initialize-TuiEngine`.
#   - Uses the `NavigationService` to navigate to the provided initial screen.
#   - Calls `Start-TuiEngine` to begin the main application loop.
# ==============================================================================
function Start-AxiomPhoenix {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][ServiceContainer]$ServiceContainer,
        [Parameter(Mandatory)][Screen]$InitialScreen
    )
    
    try {
        $global:TuiState.ServiceContainer = $ServiceContainer
        $global:TuiState.Services = @{}
        $serviceNames = @('Logger', 'EventManager', 'ThemeManager', 'DataManager', 'ActionService', 'KeybindingService', 'NavigationService', 'FocusManager', 'DialogManager')
        foreach ($serviceName in $serviceNames) {
            try { $global:TuiState.Services[$serviceName] = $ServiceContainer.GetService($serviceName) }
            catch { Write-Log -Level Warning -Message "Failed to get required service '$serviceName': $($_.Exception.Message)" }
        }
        
        Initialize-TuiEngine
        
        $global:TuiState.Services.NavigationService.NavigateTo($InitialScreen)
        
        Start-TuiEngine
    }
    catch {
        Invoke-PanicHandler $_
    }
    finally {
        Stop-TuiEngine
    }
}

#endregion
#<!-- END_PAGE: ART.006 -->


####\New folder\AllScreens.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Screens (Load After Components)
# Application screens that extend Screen base class
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASC.###" to find specific sections.
# Each section ends with "END_PAGE: ASC.###"
# ==============================================================================

using namespace System.Collections.Generic

#<!-- PAGE: ASC.001 - DashboardScreen Class -->
#region Screen Classes

# ==============================================================================
# CLASS: DashboardScreen
#
# INHERITS:
#   - Screen (ABC.006)
#
# DEPENDENCIES:
#   Services:
#     - ServiceContainer (ABC.007)
#     - EventManager (ASE.007)
#     - DataManager (ASE.003)
#   Components:
#     - Panel (ACO.011)
#     - LabelComponent (ACO.001)
#
# PURPOSE:
#   Provides a high-level overview of the application's state, including
#   task summaries and system information. Acts as the initial landing page.
#
# KEY LOGIC:
#   - OnEnter: Subscribes to 'Tasks.Changed' event from EventManager to enable
#     reactive UI updates. Fetches initial data from DataManager.
#   - _RefreshData: Core logic to query the DataManager for task statistics.
#   - _UpdateSummaryPanel, _UpdateHelpPanel, _UpdateStatusPanel: These methods
#     dynamically create and configure LabelComponent children within their
#     respective Panel containers to display the latest data. This avoids
#     direct buffer manipulation in the screen class.
# ==============================================================================
class DashboardScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [Panel] $_summaryPanel
    hidden [Panel] $_statusPanel
    hidden [Panel] $_helpPanel
    #endregion

    #region State
    hidden [int] $_totalTasks = 0
    hidden [int] $_completedTasks = 0
    hidden [int] $_pendingTasks = 0
    hidden [string] $_dataChangeSubscriptionId = $null # Store event subscription ID
    #endregion

    DashboardScreen([object]$serviceContainer) : base("DashboardScreen", $serviceContainer) {}

    [void] Initialize() {
        if (-not $this.ServiceContainer) {
            Write-Log -Level Warning -Message "DashboardScreen.Initialize: ServiceContainer is null"
            return
        }
        
        # Ensure minimum size
        if ($this.Width -lt 80) { $this.Width = 80 }
        if ($this.Height -lt 24) { $this.Height = 24 }
        
        $this._mainPanel = [Panel]::new("Axiom-Phoenix Dashboard")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = "Axiom-Phoenix Dashboard"
        $this._mainPanel.UpdateContentDimensions()
        $this.AddChild($this._mainPanel)

        $summaryWidth = [Math]::Floor($this.Width * 0.5)
        $this._summaryPanel = [Panel]::new("Task Summary")
        $this._summaryPanel.X = 1
        $this._summaryPanel.Y = 1
        $this._summaryPanel.Width = $summaryWidth
        $this._summaryPanel.Height = 12
        $this._summaryPanel.Title = "Task Summary"
        $this._summaryPanel.UpdateContentDimensions()
        $this._mainPanel.AddChild($this._summaryPanel)

        $helpX = $summaryWidth + 2
        $helpWidth = $this.Width - $helpX - 1
        $this._helpPanel = [Panel]::new("Quick Start")
        $this._helpPanel.X = $helpX
        $this._helpPanel.Y = 1
        $this._helpPanel.Width = $helpWidth
        $this._helpPanel.Height = 12
        $this._helpPanel.Title = "Quick Start"
        $this._helpPanel.UpdateContentDimensions()
        $this._mainPanel.AddChild($this._helpPanel)

        $this._statusPanel = [Panel]::new("System Status")
        $this._statusPanel.X = 1
        $this._statusPanel.Y = 14
        $this._statusPanel.Width = $this.Width - 2
        $this._statusPanel.Height = $this.Height - 15
        $this._statusPanel.Title = "System Status"
        $this._statusPanel.UpdateContentDimensions()
        $this._mainPanel.AddChild($this._statusPanel)
    }

    [void] OnEnter() {
        # Subscribe to data change events for reactive updates
        $eventManager = $this.ServiceContainer?.GetService("EventManager")
        if ($eventManager) {
            # Create handler that properly captures $this
            $thisScreen = $this
            $handler = {
                param($eventData)
                Write-Log -Level Debug -Message "DashboardScreen received data change event. Refreshing..."
                $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
                $thisScreen._RefreshData($dataManager)
            }.GetNewClosure()
            
            # Subscribe to both task and project changes
            $this._dataChangeSubscriptionId = $eventManager.Subscribe("Tasks.Changed", $handler)
            Write-Log -Level Debug -Message "DashboardScreen subscribed to data change events"
        }
        
        # Force a complete redraw of all panels
        if ($this._summaryPanel) { $this._summaryPanel.RequestRedraw() }
        if ($this._helpPanel) { $this._helpPanel.RequestRedraw() }
        if ($this._statusPanel) { $this._statusPanel.RequestRedraw() }
        if ($this._mainPanel) { $this._mainPanel.RequestRedraw() }
        
        if ($this.ServiceContainer) {
            $this._RefreshData($this.ServiceContainer.GetService("DataManager"))
        } else {
            Write-Log -Level Warning -Message "DashboardScreen.OnEnter: ServiceContainer is null, using defaults"
            $this._RefreshData($null)
        }
        
        # Force another redraw after data refresh
        $this.RequestRedraw()
    }
    
    [void] OnExit() {
        # Unsubscribe from data change events
        $eventManager = $this.ServiceContainer?.GetService("EventManager")
        if ($eventManager -and $this._dataChangeSubscriptionId) {
            $eventManager.Unsubscribe("Tasks.Changed", $this._dataChangeSubscriptionId)
            $this._dataChangeSubscriptionId = $null
            Write-Log -Level Debug -Message "DashboardScreen unsubscribed from data change events"
        }
        
        # Call base OnExit
        ([Screen]$this).OnExit()
    }

    hidden [void] _RefreshData([object]$dataManager) {
        if(-not $dataManager) {
            Write-Log -Level Warning -Message "DashboardScreen: DataManager service not found."
            $this._totalTasks = 0
            $this._completedTasks = 0
            $this._pendingTasks = 0
        } else {
            $allTasks = $dataManager.GetTasks()
            if ($allTasks) {
                $this._totalTasks = @($allTasks).Count
                $this._completedTasks = @($allTasks | Where-Object { $_.Completed }).Count
                $this._pendingTasks = $this._totalTasks - $this._completedTasks
            } else {
                $this._totalTasks = 0
                $this._completedTasks = 0
                $this._pendingTasks = 0
            }
        }
        $this._UpdateDisplay()
    }
    
    hidden [void] _UpdateDisplay() {
        $this._UpdateSummaryPanel()
        $this._UpdateHelpPanel()
        $this._UpdateStatusPanel()
        $this.RequestRedraw()
    }
    
    hidden [void] _UpdateSummaryPanel() {
        $panel = $this._summaryPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        # Force content dimensions update
        $panel.UpdateContentDimensions()
        
        # Ensure we have a reasonable width
        $labelWidth = [Math]::Max(20, $panel.ContentWidth - 2)

        # Create label components instead of direct buffer drawing
        $titleLabel = [LabelComponent]::new("SummaryTitle")
        $titleLabel.Text = "Task Overview"
        $titleLabel.ForegroundColor = Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF"
        $titleLabel.X = 1
        $titleLabel.Y = 0
        $titleLabel.Width = $labelWidth
        $titleLabel.Height = 1
        $panel.AddChild($titleLabel)
        
        # Only create separator if there's space for it
        $lineWidth = [Math]::Max(0, $labelWidth)
        if ($lineWidth -gt 0) {
            $separatorLabel = [LabelComponent]::new("SummarySeparator")
            $separatorLabel.Text = '' * $lineWidth
            $separatorLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $separatorLabel.X = 1
            $separatorLabel.Y = 1
            $separatorLabel.Width = $labelWidth
            $separatorLabel.Height = 1
            $panel.AddChild($separatorLabel)
        }
        
        $totalLabel = [LabelComponent]::new("TotalTasks")
        $totalLabel.Text = "Total Tasks:    $($this._totalTasks)"
        $totalLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $totalLabel.X = 1
        $totalLabel.Y = 3
        $totalLabel.Width = $labelWidth
        $totalLabel.Height = 1
        $panel.AddChild($totalLabel)
        
        $completedLabel = [LabelComponent]::new("CompletedTasks")
        $completedLabel.Text = "Completed:      $($this._completedTasks)"
        $completedLabel.ForegroundColor = Get-ThemeColor -ColorName "Success" -DefaultColor "#00FF00"
        $completedLabel.X = 1
        $completedLabel.Y = 4
        $completedLabel.Width = $labelWidth
        $completedLabel.Height = 1
        $panel.AddChild($completedLabel)
        
        $pendingLabel = [LabelComponent]::new("PendingTasks")
        $pendingLabel.Text = "Pending:        $($this._pendingTasks)"
        $pendingLabel.ForegroundColor = Get-ThemeColor -ColorName "Warning" -DefaultColor "#FFA500"
        $pendingLabel.X = 1
        $pendingLabel.Y = 5
        $pendingLabel.Width = $labelWidth
        $pendingLabel.Height = 1
        $panel.AddChild($pendingLabel)
        
        # Create progress bar as labels
        if ($this._totalTasks -eq 0) { 
            $percentage = 0 
        } else { 
            $percentage = [Math]::Round(($this._completedTasks / $this._totalTasks) * 100) 
        }
        $progressLabel = [LabelComponent]::new("ProgressLabel")
        $progressLabel.Text = "Overall Progress: $percentage%"
        $progressLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $progressLabel.X = 1
        $progressLabel.Y = 7
        $progressLabel.Width = $labelWidth
        $progressLabel.Height = 1
        $panel.AddChild($progressLabel)
        
        # Progress bar visualization
        $barWidth = [Math]::Min(20, $labelWidth - 2)
        $filledWidth = [Math]::Floor($barWidth * $percentage / 100)
        $emptyWidth = $barWidth - $filledWidth
        $barText = "[" + ("" * $filledWidth) + ("" * $emptyWidth) + "]"
        
        $barLabel = [LabelComponent]::new("ProgressBar")
        $barLabel.Text = $barText
        $barLabel.ForegroundColor = Get-ThemeColor -ColorName "Success" -DefaultColor "#00FF00"
        $barLabel.X = 1
        $barLabel.Y = 8
        $barLabel.Width = $labelWidth
        $barLabel.Height = 1
        $panel.AddChild($barLabel)
        
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateHelpPanel() {
        $panel = $this._helpPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        # Force content dimensions update
        $panel.UpdateContentDimensions()
        
        # Ensure we have a reasonable width
        $labelWidth = [Math]::Max(20, $panel.ContentWidth - 2)
        
        $paletteHotkey = "Ctrl+P"
        
        # Create label components for help panel
        $welcomeLabel = [LabelComponent]::new("WelcomeLabel")
        $welcomeLabel.Text = "Welcome to Axiom-Phoenix!"
        $welcomeLabel.ForegroundColor = Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF"
        $welcomeLabel.X = 1
        $welcomeLabel.Y = 0
        $welcomeLabel.Width = $labelWidth
        $welcomeLabel.Height = 1
        $panel.AddChild($welcomeLabel)
        
        $lineWidth = [Math]::Max(0, $labelWidth)
        if ($lineWidth -gt 0) {
            $separatorLabel = [LabelComponent]::new("HelpSeparator")
            $separatorLabel.Text = '' * $lineWidth
            $separatorLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $separatorLabel.X = 1
            $separatorLabel.Y = 1
            $separatorLabel.Width = $labelWidth
            $separatorLabel.Height = 1
            $panel.AddChild($separatorLabel)
        }
        
        # Create multi-part label for the hotkey instruction
        $instructionLabel1 = [LabelComponent]::new("Instruction1")
        $instructionLabel1.Text = "Press $paletteHotkey to open the"
        $instructionLabel1.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $instructionLabel1.X = 1
        $instructionLabel1.Y = 3
        $instructionLabel1.Width = $labelWidth
        $instructionLabel1.Height = 1
        $panel.AddChild($instructionLabel1)
        
        $instructionLabel2 = [LabelComponent]::new("Instruction2")
        $instructionLabel2.Text = "Command Palette."
        $instructionLabel2.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $instructionLabel2.X = 1
        $instructionLabel2.Y = 4
        $instructionLabel2.Width = $labelWidth
        $instructionLabel2.Height = 1
        $panel.AddChild($instructionLabel2)

        $infoLabel1 = [LabelComponent]::new("InfoLabel1")
        $infoLabel1.Text = "All navigation and actions are"
        $infoLabel1.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
        $infoLabel1.X = 1
        $infoLabel1.Y = 6
        $infoLabel1.Width = $labelWidth
        $infoLabel1.Height = 1
        $panel.AddChild($infoLabel1)
        
        $infoLabel2 = [LabelComponent]::new("InfoLabel2")
        $infoLabel2.Text = "now available from there."
        $infoLabel2.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
        $infoLabel2.X = 1
        $infoLabel2.Y = 7
        $infoLabel2.Width = $labelWidth
        $infoLabel2.Height = 1
        $panel.AddChild($infoLabel2)
        
        $panel.RequestRedraw()
    }
    
    hidden [void] _UpdateStatusPanel() {
        $panel = $this._statusPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        # Force content dimensions update
        $panel.UpdateContentDimensions()
        
        # Ensure we have a reasonable width
        $labelWidth = [Math]::Max(20, $panel.ContentWidth - 2)

        $memoryMB = try { [Math]::Round((Get-Process -Id $global:PID).WorkingSet64 / 1MB, 2) } catch { 0 }

        # Create label components for status panel
        $titleLabel = [LabelComponent]::new("StatusTitle")
        $titleLabel.Text = "Environment"
        $titleLabel.ForegroundColor = Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF"
        $titleLabel.X = 1
        $titleLabel.Y = 0
        $titleLabel.Width = $labelWidth
        $titleLabel.Height = 1
        $panel.AddChild($titleLabel)
        
        $lineWidth = [Math]::Max(0, $labelWidth)
        if ($lineWidth -gt 0) {
            $separatorLabel = [LabelComponent]::new("StatusSeparator")
            $separatorLabel.Text = '' * $lineWidth
            $separatorLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $separatorLabel.X = 1
            $separatorLabel.Y = 1
            $separatorLabel.Width = $labelWidth
            $separatorLabel.Height = 1
            $panel.AddChild($separatorLabel)
        }
        
        $versionLabel = [LabelComponent]::new("PSVersion")
        $versionLabel.Text = "PowerShell Version: $($global:PSVersionTable.PSVersion)"
        $versionLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $versionLabel.X = 1
        $versionLabel.Y = 3
        $versionLabel.Width = $labelWidth
        $versionLabel.Height = 1
        $panel.AddChild($versionLabel)
        
        $memoryLabel = [LabelComponent]::new("MemoryUsage")
        $memoryLabel.Text = "Memory Usage: ${memoryMB} MB"
        $memoryLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $memoryLabel.X = 1
        $memoryLabel.Y = 4
        $memoryLabel.Width = $labelWidth
        $memoryLabel.Height = 1
        $panel.AddChild($memoryLabel)
        
        $hostLabel = [LabelComponent]::new("HostName")
        $hostLabel.Text = "Host: $($global:Host.Name)"
        $hostLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $hostLabel.X = 1
        $hostLabel.Y = 5
        $hostLabel.Width = $labelWidth
        $hostLabel.Height = 1
        $panel.AddChild($hostLabel)
        
        $panel.RequestRedraw()
    }


    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Dashboard doesn't handle specific input - all navigation via command palette
        # Input not handled
    }
}

#endregion
#<!-- END_PAGE: ASC.001 -->

#<!-- PAGE: ASC.002 - TaskListScreen Class -->
#region TaskListScreen Class

# ==============================================================================
# CLASS: TaskListScreen
#
# INHERITS:
#   - Screen (ABC.006)
#
# DEPENDENCIES:
#   Services:
#     - ServiceContainer (ABC.007)
#     - DataManager (ASE.003)
#     - DialogManager (ASE.009)
#     - EventManager (ASE.007)
#   Components:
#     - Panel (ACO.011)
#     - ScrollablePanel (ACO.012)
#     - ButtonComponent (ACO.002)
#     - TextBoxComponent (ACO.003)
#     - TaskDialog (ACO.020)
#     - TaskDeleteDialog (ACO.020)
#
# PURPOSE:
#   Displays a master-detail view of tasks. Provides UI for creating,
#   viewing, updating, and deleting tasks.
#
# KEY LOGIC:
#   - OnEnter: Subscribes to 'Tasks.Changed' event to automatically refresh the
#     list when data changes elsewhere in the application.
#   - _RefreshTasks: Reloads tasks from DataManager and applies the current
#     filter text.
#   - _UpdateTaskList: The core rendering logic for the list. It creates a Panel
#     for each task item and adds it as a child to the ScrollablePanel. This
#     delegates scrolling and rendering to the ScrollablePanel component, which
#     is more efficient than direct buffer drawing.
#   - _UpdateDetailPanel: Shows details for the currently selected task by
#     creating and updating LabelComponent children.
#   - HandleInput: Manages up/down selection, page up/down, and delegates
#     hotkeys (N, E, D, C) to invoke the OnClick scriptblocks of the
#     corresponding buttons.
#   - Button OnClick handlers use the DialogManager service to show TaskDialog
#     or TaskDeleteDialog modals, decoupling the screen from dialog management.
# ==============================================================================
class TaskListScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [ScrollablePanel] $_taskListPanel
    hidden [Panel] $_detailPanel
    hidden [Panel] $_statusBar
    hidden [ButtonComponent] $_newButton
    hidden [ButtonComponent] $_editButton
    hidden [ButtonComponent] $_deleteButton
    hidden [ButtonComponent] $_completeButton
    hidden [TextBoxComponent] $_filterBox
    #endregion

    #region State
    hidden [System.Collections.Generic.List[PmcTask]] $_tasks
    hidden [int] $_selectedIndex = 0
    hidden [PmcTask] $_selectedTask
    hidden [string] $_filterText = ""
    hidden [System.Nullable[TaskStatus]] $_filterStatus = $null
    hidden [System.Nullable[TaskPriority]] $_filterPriority = $null
    hidden [string] $_taskChangeSubscriptionId = $null # Store event subscription ID
    #endregion

    TaskListScreen([object]$serviceContainer) : base("TaskListScreen", $serviceContainer) {}

    [void] Initialize() {
        if (-not $this.ServiceContainer) {
            Write-Log -Level Warning -Message "TaskListScreen.Initialize: ServiceContainer is null"
            return
        }
        
        # Ensure minimum size
        if ($this.Width -lt 80) { $this.Width = 80 }
        if ($this.Height -lt 24) { $this.Height = 24 }
        
        $this._mainPanel = [Panel]::new("Task List")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = "Task List"
        $this._mainPanel.UpdateContentDimensions()
        $this.AddChild($this._mainPanel)

        # Add filter textbox at the top
        $this._filterBox = [TextBoxComponent]::new("FilterBox")
        $this._filterBox.Placeholder = "Type to filter tasks..."
        $this._filterBox.X = 2
        $this._filterBox.Y = 2
        $this._filterBox.Width = [Math]::Floor($this.Width * 0.6) - 4
        $this._filterBox.Height = 1
        $thisScreen = $this
        $this._filterBox.OnChange = {
            param($sender, $newText) # Corrected signature for TextBox OnChange
            $thisScreen._filterText = $newText
            $thisScreen._RefreshTasks()
            $thisScreen._UpdateDisplay()
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._filterBox)

        # Task list panel (left side)
        $listWidth = [Math]::Floor($this.Width * 0.6)
        $this._taskListPanel = [ScrollablePanel]::new("Tasks")
        $this._taskListPanel.X = 1
        $this._taskListPanel.Y = 4  # Move down to accommodate filter
        $this._taskListPanel.Width = $listWidth
        $this._taskListPanel.Height = $this.Height - 8  # Adjust for buttons and filter
        $this._taskListPanel.Title = "Tasks"
        $this._taskListPanel.UpdateContentDimensions()
        $this._mainPanel.AddChild($this._taskListPanel)

        # Detail panel (right side)
        $detailX = $listWidth + 2
        $detailWidth = $this.Width - $detailX - 1
        $this._detailPanel = [Panel]::new("Task Details")
        $this._detailPanel.X = $detailX
        $this._detailPanel.Y = 1
        $this._detailPanel.Width = $detailWidth
        $this._detailPanel.Height = $this.Height - 8  # Adjust for buttons
        $this._detailPanel.Title = "Task Details"
        $this._detailPanel.UpdateContentDimensions()
        $this._mainPanel.AddChild($this._detailPanel)

        # Status bar
        $this._statusBar = [Panel]::new("StatusBar")
        $this._statusBar.X = 1
        $this._statusBar.Y = $this.Height - 2
        $this._statusBar.Width = $this.Width - 2
        $this._statusBar.Height = 1
        $this._statusBar.HasBorder = $false
        $this._mainPanel.AddChild($this._statusBar)
        
        # Add CRUD action buttons at the bottom
        $buttonY = $this.Height - 3
        $buttonSpacing = 15
        $currentX = 2
        
        # New button
        $this._newButton = [ButtonComponent]::new("NewButton")
        $this._newButton.Text = "[N]ew Task"
        $this._newButton.X = $currentX
        $this._newButton.Y = $buttonY
        $this._newButton.Width = 12
        $this._newButton.Height = 1
        $this._newButton.OnClick = {
            $dialogManager = $thisScreen.ServiceContainer?.GetService("DialogManager")
            $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
            
            if ($dialogManager -and $dataManager) {
                $dialog = [TaskDialog]::new("New Task", $null)
                $dialogManager.ShowDialog($dialog)
                
                # Note: In a real app, this logic would be handled by a callback or event
                # after the dialog closes, not synchronously like this.
                if ($dialog.DialogResult -eq [DialogResult]::OK) {
                    $newTask = $dialog.GetTask()
                    $dataManager.AddTask($newTask)
                    $thisScreen._RefreshTasks()
                    $thisScreen._UpdateDisplay()
                    Write-Log -Level Info -Message "New task created: $($newTask.Title)"
                }
            }
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._newButton)
        $currentX += $buttonSpacing
        
        # Edit button
        $this._editButton = [ButtonComponent]::new("EditButton")
        $this._editButton.Text = "[E]dit Task"
        $this._editButton.X = $currentX
        $this._editButton.Y = $buttonY
        $this._editButton.Width = 12
        $this._editButton.Height = 1
        $this._editButton.OnClick = {
            $dialogManager = $thisScreen.ServiceContainer?.GetService("DialogManager")
            $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
            
            if ($dialogManager -and $dataManager -and $thisScreen._selectedTask) {
                $dialog = [TaskDialog]::new("Edit Task", $thisScreen._selectedTask)
                $dialogManager.ShowDialog($dialog)
                
                if ($dialog.DialogResult -eq [DialogResult]::OK) {
                    $updatedTask = $dialog.GetTask()
                    $dataManager.UpdateTask($updatedTask)
                    $thisScreen._RefreshTasks()
                    $thisScreen._UpdateDisplay()
                    Write-Log -Level Info -Message "Task updated: $($updatedTask.Title)"
                }
            }
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._editButton)
        $currentX += $buttonSpacing
        
        # Delete button
        $this._deleteButton = [ButtonComponent]::new("DeleteButton")
        $this._deleteButton.Text = "[D]elete Task"
        $this._deleteButton.X = $currentX
        $this._deleteButton.Y = $buttonY
        $this._deleteButton.Width = 14
        $this._deleteButton.Height = 1
        $this._deleteButton.OnClick = {
            $dialogManager = $thisScreen.ServiceContainer?.GetService("DialogManager")
            $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
            
            if ($dialogManager -and $dataManager -and $thisScreen._selectedTask) {
                $dialog = [TaskDeleteDialog]::new($thisScreen._selectedTask)
                $dialogManager.ShowDialog($dialog)
                
                if ($dialog.DialogResult -eq [DialogResult]::Yes) {
                    $dataManager.DeleteTask($thisScreen._selectedTask.Id)
                    $thisScreen._RefreshTasks()
                    $thisScreen._UpdateDisplay()
                    Write-Log -Level Info -Message "Task deleted: $($thisScreen._selectedTask.Title)"
                }
            }
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._deleteButton)
        $currentX += $buttonSpacing + 2
        
        # Complete button
        $this._completeButton = [ButtonComponent]::new("CompleteButton")
        $this._completeButton.Text = "[C]omplete"
        $this._completeButton.X = $currentX
        $this._completeButton.Y = $buttonY
        $this._completeButton.Width = 12
        $this._completeButton.Height = 1
        $this._completeButton.OnClick = {
            $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
            
            if ($dataManager -and $thisScreen._selectedTask) {
                $thisScreen._selectedTask.Complete()
                $dataManager.UpdateTask($thisScreen._selectedTask)
                $thisScreen._RefreshTasks()
                $thisScreen._UpdateDisplay()
                Write-Log -Level Info -Message "Task completed: $($thisScreen._selectedTask.Title)"
            }
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._completeButton)
        
        $this._tasks = [System.Collections.Generic.List[PmcTask]]::new()
    }

    [void] OnEnter() {
        # Subscribe to data change events for reactive updates
        $eventManager = $this.ServiceContainer?.GetService("EventManager")
        if ($eventManager) {
            # Create handler that properly captures $this
            $thisScreen = $this
            $handler = {
                param($eventData)
                Write-Log -Level Debug -Message "TaskListScreen received Tasks.Changed event. Refreshing tasks."
                $thisScreen._RefreshTasks()
                $thisScreen._UpdateDisplay()
            }.GetNewClosure()
            
            # Store subscription ID for later cleanup
            $this._taskChangeSubscriptionId = $eventManager.Subscribe("Tasks.Changed", $handler)
            Write-Log -Level Debug -Message "TaskListScreen subscribed to Tasks.Changed events"
        }
        
        if ($this.ServiceContainer) {
            $this._RefreshTasks()
        }
        
        $this.RequestRedraw()
    }
    
    [void] OnExit() {
        # Unsubscribe from data change events
        $eventManager = $this.ServiceContainer?.GetService("EventManager")
        if ($eventManager -and $this._taskChangeSubscriptionId) {
            $eventManager.Unsubscribe("Tasks.Changed", $this._taskChangeSubscriptionId)
            $this._taskChangeSubscriptionId = $null
            Write-Log -Level Debug -Message "TaskListScreen unsubscribed from Tasks.Changed events"
        }
        
        # Call base OnExit if needed
        ([Screen]$this).OnExit()
    }

    hidden [void] _RefreshTasks() {
        $dataManager = $this.ServiceContainer?.GetService("DataManager")
        if ($dataManager) {
            $allTasks = $dataManager.GetTasks()
            
            # Apply text filter if present
            if (![string]::IsNullOrWhiteSpace($this._filterText)) {
                $filterLower = $this._filterText.ToLower()
                $allTasks = @($allTasks | Where-Object {
                    $_.Title.ToLower().Contains($filterLower) -or
                    ($_.Description -and $_.Description.ToLower().Contains($filterLower))
                })
            }
            
            $this._tasks = [System.Collections.Generic.List[PmcTask]]::new()
            if ($allTasks) {
                # Fix: Explicitly cast each item to PmcTask to avoid type conversion error
                foreach ($task in $allTasks) {
                    if ($task -is [PmcTask]) {
                        $this._tasks.Add($task)
                    }
                }
            }
        } else {
            $this._tasks = [System.Collections.Generic.List[PmcTask]]::new()
        }
        
        # Reset selection if needed
        if ($this._selectedIndex -ge $this._tasks.Count) {
            $this._selectedIndex = [Math]::Max(0, $this._tasks.Count - 1)
        }
        
        if ($this._tasks.Count -gt 0) {
            $this._selectedTask = $this._tasks[$this._selectedIndex]
        } else {
            $this._selectedTask = $null
        }
    }

    hidden [void] _UpdateDisplay() {
        $this._UpdateTaskList()
        $this._UpdateDetailPanel()
        $this._UpdateStatusBar()
        $this.RequestRedraw()
    }

    hidden [void] _UpdateTaskList() {
        $panel = $this._taskListPanel
        if (-not $panel) { return }
        
        # CRITICAL: Clear the panel's CHILDREN, not its buffer directly.
        $panel.Children.Clear()
        
        if ($this._tasks.Count -eq 0) {
            # Add a label to show there are no tasks
            $noTasksLabel = [LabelComponent]::new("NoTasksLabel")
            $noTasksLabel.X = 2
            $noTasksLabel.Y = 2
            $noTasksLabel.Text = "No tasks found."
            $noTasksLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $panel.AddChild($noTasksLabel)
            $panel.RequestRedraw()
            return
        }
        
        for ($i = 0; $i -lt $this._tasks.Count; $i++) {
            $task = $this._tasks[$i]
            
            # Create a Panel for each task item (to support background color)
            $taskPanel = [Panel]::new("TaskItem_$($task.Id)")
            $taskPanel.X = 0
            $taskPanel.Y = $i # Y position is its index in the list
            $panelContentWidth = if ($panel.ContentWidth -le 0) { [Math]::Max(30, $panel.Width - 2) } else { $panel.ContentWidth }
            $taskPanel.Width = $panelContentWidth
            $taskPanel.Height = 1
            $taskPanel.HasBorder = $false
            
            # Set background based on selection
            $is_selected = ($i -eq $this._selectedIndex)
            $taskPanel.BackgroundColor = if ($is_selected) { Get-ThemeColor -ColorName "list.item.selected.background" -DefaultColor "#0000FF" } else { Get-ThemeColor -ColorName "Background" -DefaultColor "#000000" }
            
            # Create a Label component for the task text
            $taskLabel = [LabelComponent]::new("TaskLabel_$($task.Id)")
            $taskLabel.X = 1 # Indent slightly
            $taskLabel.Y = 0 # Relative to the task panel
            $taskLabel.Width = [Math]::Max(20, $panelContentWidth - 2) # Set proper width
            $taskLabel.Height = 1
            
            # Status indicator
            $statusChar = switch ($task.Status) {
                ([TaskStatus]::Pending) { "" }
                ([TaskStatus]::InProgress) { "" }
                ([TaskStatus]::Completed) { "" }
                ([TaskStatus]::Cancelled) { "" }
                default { "?" }
            }
            
            # Priority indicator
            $priorityChar = switch ($task.Priority) {
                ([TaskPriority]::Low) { "" }
                ([TaskPriority]::Medium) { "" }
                ([TaskPriority]::High) { "" }
                default { "-" }
            }
            
            # Truncate title if needed
            $maxTitleLength = [Math]::Max(10, $panelContentWidth - 6) # Ensure minimum length
            if ($task.Title.Length -gt $maxTitleLength -and $maxTitleLength -gt 3) {
                $title = $task.Title.Substring(0, [Math]::Max(1, $maxTitleLength - 3)) + "..."
            } else {
                $title = $task.Title
            }
            
            $taskLine = "$statusChar $priorityChar $title"
            $taskLabel.Text = $taskLine
            
            # Set text color based on selection
            if ($is_selected) { 
                $taskLabel.ForegroundColor = Get-ThemeColor -ColorName "list.item.selected" -DefaultColor "#FFFFFF" 
            } else { 
                $taskLabel.ForegroundColor = Get-ThemeColor -ColorName "list.item.normal" -DefaultColor "#C0C0C0" 
            }
            
            # Add the label to the task panel
            $taskPanel.AddChild($taskLabel)
            
            # Add the task panel as a CHILD of the scrollable panel
            $panel.AddChild($taskPanel)
        }
        
        # The ScrollablePanel's own Render method will now correctly handle everything else.
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateDetailPanel() {
        $panel = $this._detailPanel
        if (-not $panel -or -not $this._selectedTask) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        # Force content dimensions update
        $panel.UpdateContentDimensions()
        
        $task = $this._selectedTask
        $y = 1 # Start position relative to panel
        
        # Title label
        $titleLabel = [LabelComponent]::new("DetailTitle")
        $titleLabel.X = 1
        $titleLabel.Y = $y++
        $titleLabel.Text = "Title: $($task.Title)"
        $titleLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $panel.AddChild($titleLabel)
        
        # Status label
        $statusLabel = [LabelComponent]::new("DetailStatus")
        $statusLabel.X = 1
        $statusLabel.Y = $y++
        $statusLabel.Text = "Status: $($task.Status)"
        $statusLabel.ForegroundColor = Get-ThemeColor -ColorName "Info" -DefaultColor "#00BFFF"
        $panel.AddChild($statusLabel)
        
        # Priority label
        $priorityLabel = [LabelComponent]::new("DetailPriority")
        $priorityLabel.X = 1
        $priorityLabel.Y = $y++
        $priorityLabel.Text = "Priority: $($task.Priority)"
        $priorityLabel.ForegroundColor = Get-ThemeColor -ColorName "Warning" -DefaultColor "#FFA500"
        $panel.AddChild($priorityLabel)
        
        # Progress label
        $progressLabel = [LabelComponent]::new("DetailProgress")
        $progressLabel.X = 1
        $progressLabel.Y = $y++
        $progressLabel.Text = "Progress: $($task.Progress)%"
        $progressLabel.ForegroundColor = Get-ThemeColor -ColorName "Success" -DefaultColor "#00FF00"
        $panel.AddChild($progressLabel)
        
        $y++ # Empty line
        
        # Description header
        $descHeaderLabel = [LabelComponent]::new("DetailDescHeader")
        $descHeaderLabel.X = 1
        $descHeaderLabel.Y = $y++
        $descHeaderLabel.Text = "Description:"
        $descHeaderLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
        $panel.AddChild($descHeaderLabel)
        
        if (-not [string]::IsNullOrEmpty($task.Description)) {
            # Word wrap description
            $words = $task.Description -split '\s+'
            $line = ""
            $maxLineLength = [Math]::Max(10, $panel.ContentWidth - 2)
            $lineIndex = 0
            
            foreach ($word in $words) {
                if (($line + " " + $word).Length -gt $maxLineLength) {
                    if ($line) {
                        # Create label for this line
                        $descLineLabel = [LabelComponent]::new("DetailDescLine$lineIndex")
                        $descLineLabel.X = 1
                        $descLineLabel.Y = $y++
                        $descLineLabel.Text = $line
                        $descLineLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
                        $panel.AddChild($descLineLabel)
                        $lineIndex++
                    }
                    $line = $word
                } else {
                    if ($line) { 
                        $line = "$line $word" 
                    } else { 
                        $line = $word 
                    }
                }
            }
            
            if ($line) {
                # Create label for last line
                $descLineLabel = [LabelComponent]::new("DetailDescLine$lineIndex")
                $descLineLabel.X = 1
                $descLineLabel.Y = $y++
                $descLineLabel.Text = $line
                $descLineLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
                $panel.AddChild($descLineLabel)
            }
        } else {
            $noDescLabel = [LabelComponent]::new("DetailNoDesc")
            $noDescLabel.X = 1
            $noDescLabel.Y = $y++
            $noDescLabel.Text = "(No description)"
            $noDescLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $panel.AddChild($noDescLabel)
        }
        
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateStatusBar() {
        $panel = $this._statusBar
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        # Set panel background color
        $panel.BackgroundColor = Get-ThemeColor -ColorName "status.bar.bg" -DefaultColor "#1E1E1E"
        
        # Status text label
        $statusText = "Tasks: $($this._tasks.Count) | Selected: $($this._selectedIndex + 1)"
        if ($this._filterText) {
            $statusText += " | Filter: '$($this._filterText)'"
        }
        
        $statusLabel = [LabelComponent]::new("StatusText")
        $statusLabel.X = 0
        $statusLabel.Y = 0
        $statusLabel.Text = $statusText
        $statusLabel.ForegroundColor = Get-ThemeColor -ColorName "status.bar.fg" -DefaultColor "#FFFFFF"
        $panel.AddChild($statusLabel)
        
        # Keyboard hints label
        $hints = ": Navigate | Enter: Edit | D: Delete | N: New"
        $hintsX = $this.Width - $hints.Length - 3
        if ($hintsX -gt $statusText.Length + 2) {
            $hintsLabel = [LabelComponent]::new("StatusHints")
            $hintsLabel.X = $hintsX
            $hintsLabel.Y = 0
            $hintsLabel.Text = $hints
            $hintsLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $panel.AddChild($hintsLabel)
        }
        
        $panel.RequestRedraw()
    }

    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this._selectedIndex -gt 0) {
                    $this._selectedIndex--
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                    
                    # Adjust scroll if needed
                    if ($this._selectedIndex -lt $this._taskListPanel.ScrollOffsetY) {
                        $this._taskListPanel.ScrollUp()
                    }
                    
                    $this._UpdateDisplay()
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this._selectedIndex -lt $this._tasks.Count - 1) {
                    $this._selectedIndex++
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                    
                    # Adjust scroll if needed
                    $visibleEnd = $this._taskListPanel.ScrollOffsetY + $this._taskListPanel.ContentHeight - 1
                    if ($this._selectedIndex -gt $visibleEnd) {
                        $this._taskListPanel.ScrollDown()
                    }
                    
                    $this._UpdateDisplay()
                }
            }
            ([ConsoleKey]::PageUp) {
                $this._taskListPanel.ScrollUp($this._taskListPanel.ContentHeight)
                $this._selectedIndex = [Math]::Max(0, $this._selectedIndex - $this._taskListPanel.ContentHeight)
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::PageDown) {
                $this._taskListPanel.ScrollDown($this._taskListPanel.ContentHeight)
                $this._selectedIndex = [Math]::Min($this._tasks.Count - 1, $this._selectedIndex + $this._taskListPanel.ContentHeight)
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::Home) {
                $this._taskListPanel.ScrollToTop()
                $this._selectedIndex = 0
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::End) {
                $this._taskListPanel.ScrollToBottom()
                $this._selectedIndex = $this._tasks.Count - 1
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::Enter) {
                # Edit task
                if ($this._selectedTask -and $this._editButton) {
                    $this._editButton.OnClick.Invoke()
                }
            }
            ([ConsoleKey]::N) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    # New task
                    $this._newButton.OnClick.Invoke()
                }
            }
            ([ConsoleKey]::E) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None -and $this._selectedTask) {
                    # Edit task
                    $this._editButton.OnClick.Invoke()
                }
            }
            ([ConsoleKey]::D) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None -and $this._selectedTask) {
                    # Delete task
                    $this._deleteButton.OnClick.Invoke()
                }
            }
            ([ConsoleKey]::C) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None -and $this._selectedTask) {
                    # Complete task
                    $this._completeButton.OnClick.Invoke()
                }
            }
            default {
                # Unhandled key
            }
        }
    }
}

#endregion
#<!-- END_PAGE: ASC.002 -->

# ==============================================================================
# CLASS: ThemePickerScreen
#
# INHERITS:
#   - Screen (ABC.006)
#
# DEPENDENCIES:
#   Services:
#     - ServiceContainer (ABC.007)
#     - ThemeManager (ASE.005)
#     - NavigationService (ASE.004)
#     - EventManager (ASE.007)
#   Components:
#     - ScrollablePanel (ACO.012)
#     - Panel (ACO.011)
#     - LabelComponent (ACO.001)
#
# PURPOSE:
#   Provides a UI for users to select and apply a new visual theme for the
#   entire application.
#
# KEY LOGIC:
#   - Initialize: Fetches the list of available themes from ThemeManager and
#     stores the original theme name for cancellation.
#   - _UpdateThemeList: Dynamically creates Panel and LabelComponent children to
#     represent each available theme, highlighting the selected one.
#   - HandleInput:
#     - Up/Down Arrows: Changes _selectedIndex and triggers a redraw.
#     - Enter: Applies the selected theme using ThemeManager.LoadTheme(),
#       publishes a 'Theme.Changed' event, and uses NavigationService.GoBack()
#       to close the screen.
#     - Escape: Restores the original theme and uses NavigationService.GoBack()
#       to cancel.
# ==============================================================================
class ThemePickerScreen : Screen {
    hidden [ScrollablePanel] $_themePanel
    hidden [Panel] $_mainPanel
    hidden [array] $_themes
    hidden [int] $_selectedIndex = 0
    hidden $_themeManager
    hidden [string] $_originalTheme
    
    ThemePickerScreen([object]$serviceContainer) : base("ThemePickerScreen", $serviceContainer) {}
    
    [void] Initialize() {
        # Get theme manager
        $this._themeManager = $this.ServiceContainer?.GetService("ThemeManager")
        if (-not $this._themeManager) {
            Write-Log -Level Warning -Message "ThemePickerScreen: ThemeManager not found"
            return
        }
        
        # Get available themes
        $this._themes = $this._themeManager.GetAvailableThemes()
        Write-Log -Level Debug -Message "ThemePickerScreen: Found $($this._themes.Count) themes: $($this._themes -join ', ')"
        
        # Store original theme
        $this._originalTheme = $this._themeManager.ThemeName
        
        # Main panel
        $this._mainPanel = [Panel]::new("Theme Selector")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = "Select Theme"
        $this.AddChild($this._mainPanel)
        
        # Instructions
        $instructionLabel = [LabelComponent]::new("Instructions")
        $instructionLabel.Text = "Use  to navigate, Enter to select theme, Esc to cancel"
        $instructionLabel.X = 2
        $instructionLabel.Y = 2
        $instructionLabel.Width = [Math]::Min(60, $this.Width - 4)
        $instructionLabel.Height = 1
        $instructionLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
        $this._mainPanel.AddChild($instructionLabel)
        
        # Theme scrollable panel
        $panelWidth = [Math]::Min(60, $this.Width - 10)
        $panelHeight = [Math]::Min(20, $this.Height - 8)
        $panelX = [Math]::Floor(($this.Width - $panelWidth) / 2)
        
        $this._themePanel = [ScrollablePanel]::new("ThemeList")
        $this._themePanel.X = $panelX
        $this._themePanel.Y = 4
        $this._themePanel.Width = $panelWidth
        $this._themePanel.Height = $panelHeight
        $this._themePanel.Title = "Available Themes"
        $this._themePanel.ShowScrollbar = $true
        $this._mainPanel.AddChild($this._themePanel)
        
        # Find current theme index
        $currentTheme = $this._themeManager.ThemeName
        $selectedIdx = 0
        for ($i = 0; $i -lt $this._themes.Count; $i++) {
            if ($this._themes[$i] -eq $currentTheme) {
                $selectedIdx = $i
                break
            }
        }
        $this._selectedIndex = $selectedIdx
        
        # Update display
        $this._UpdateThemeList()
    }
    
    hidden [void] _UpdateThemeList() {
        # Clear the panel
        $this._themePanel.Children.Clear()
        
        # Add theme items
        for ($i = 0; $i -lt $this._themes.Count; $i++) {
            $themeName = $this._themes[$i]
            $isSelected = ($i -eq $this._selectedIndex)
            
            # Create panel for each theme item
            $itemPanel = [Panel]::new("ThemeItem_$i")
            $itemPanel.X = 0
            $itemPanel.Y = $i
            $itemPanel.Width = $this._themePanel.ContentWidth
            $itemPanel.Height = 1
            $itemPanel.HasBorder = $false
            
            # Set background based on selection
            $itemPanel.BackgroundColor = if ($isSelected) { 
                Get-ThemeColor -ColorName "list.item.selected.background" -DefaultColor "#0000FF" 
            } else { 
                Get-ThemeColor -ColorName "Background" -DefaultColor "#000000" 
            }
            
            # Create label for theme name
            $themeLabel = [LabelComponent]::new("ThemeLabel_$i")
            $themeLabel.X = 2
            $themeLabel.Y = 0
            $themeLabel.Width = $itemPanel.Width - 4
            $themeLabel.Height = 1
            
            # Format display text
            $indicator = if ($isSelected) { " " } else { "  " }
            $currentMarker = if ($themeName -eq $this._originalTheme) { " (current)" } else { "" }
            $themeLabel.Text = "$indicator$themeName$currentMarker"
            
            # Set text color based on selection
            $themeLabel.ForegroundColor = if ($isSelected) { 
                Get-ThemeColor -ColorName "list.item.selected" -DefaultColor "#FFFFFF" 
            } else { 
                Get-ThemeColor -ColorName "list.item.normal" -DefaultColor "#C0C0C0" 
            }
            
            $itemPanel.AddChild($themeLabel)
            $this._themePanel.AddChild($itemPanel)
        }
        
        # Ensure selected item is visible
        if ($this._selectedIndex -lt $this._themePanel.ScrollOffsetY) {
            $this._themePanel.ScrollOffsetY = $this._selectedIndex
        } elseif ($this._selectedIndex >= $this._themePanel.ScrollOffsetY + $this._themePanel.ContentHeight) {
            $this._themePanel.ScrollOffsetY = $this._selectedIndex - $this._themePanel.ContentHeight + 1
        }
        
        $this._themePanel.RequestRedraw()
    }
    
    [void] OnEnter() {
        $this.RequestRedraw()
    }
    
    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this._selectedIndex -gt 0) {
                    $this._selectedIndex--
                    if ($this._selectedIndex -lt $this._themePanel.ScrollOffsetY) {
                        $this._themePanel.ScrollUp()
                    }
                    $this._UpdateThemeList()
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this._selectedIndex -lt $this._themes.Count - 1) {
                    $this._selectedIndex++
                    $visibleEnd = $this._themePanel.ScrollOffsetY + $this._themePanel.ContentHeight - 1
                    if ($this._selectedIndex -gt $visibleEnd) {
                        $this._themePanel.ScrollDown()
                    }
                    $this._UpdateThemeList()
                }
            }
            ([ConsoleKey]::Enter) {
                # Apply selected theme
                if ($this._selectedIndex -ge 0 -and $this._selectedIndex -lt $this._themes.Count) {
                    $selectedTheme = $this._themes[$this._selectedIndex]
                    $this._themeManager.LoadTheme($selectedTheme)
                    Write-Log -Level Info -Message "Applied theme: $selectedTheme"
                    
                    # Publish theme change event
                    $eventManager = $this.ServiceContainer?.GetService("EventManager")
                    if ($eventManager) {
                        $eventManager.Publish("Theme.Changed", @{ Theme = $selectedTheme })
                    }
                    
                    # Go back
                    $navService = $this.ServiceContainer?.GetService("NavigationService")
                    if ($navService -and $navService.CanGoBack()) {
                        $navService.GoBack()
                    }
                }
            }
            ([ConsoleKey]::Escape) {
                # Restore original theme and cancel
                $this._themeManager.LoadTheme($this._originalTheme)
                
                $navService = $this.ServiceContainer?.GetService("NavigationService")
                if ($navService -and $navService.CanGoBack()) {
                    $navService.GoBack()
                }
            }
            ([ConsoleKey]::Home) {
                $this._selectedIndex = 0
                $this._themePanel.ScrollToTop()
                $this._UpdateThemeList()
            }
            ([ConsoleKey]::End) {
                $this._selectedIndex = $this._themes.Count - 1
                $this._themePanel.ScrollToBottom()
                $this._UpdateThemeList()
            }
            default {
                # Unhandled key
            }
        }
    }
}

#<!-- PAGE: ASC.003 - Screen Utilities -->
#region Screen Utilities

# No specific screen utility functions currently implemented
# This section reserved for future screen helper functions

#endregion
#<!-- END_PAGE: ASC.003 -->


####\New folder\AllServices.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

#<!-- PAGE: ASE.001 - ActionService Class -->
#region Service Classes

# ==============================================================================
# CLASS: ActionService
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   Services:
#     - EventManager (ASE.007) (optional)
#
# PURPOSE:
#   Provides a central registry for all application commands ("actions"). This
#   decouples the invoker of a command (e.g., a keybinding, a menu item) from
#   the implementation of the command itself.
#
# KEY LOGIC:
#   - `RegisterAction`: Adds a named action (a scriptblock) along with metadata
#     like Category and Description to an internal hashtable.
#   - `ExecuteAction`: Looks up an action by its name and invokes the
#     scriptblock, passing in parameters. It also handles metadata updates
#     (execution count) and publishes `Action.Executed` events.
#   - `Get*` methods allow other parts of the UI (like the CommandPalette) to
#     discover and list available actions.
# ==============================================================================
class ActionService {
    [hashtable]$ActionRegistry = @{}
    [hashtable]$EventSubscriptions = @{}
    [object]$EventManager = $null
    
    ActionService() {
        Write-Log -Level Debug -Message "ActionService: Initialized with empty registry"
    }
    
    ActionService([object]$eventManager) {
        $this.EventManager = $eventManager
        Write-Log -Level Debug -Message "ActionService: Initialized with EventManager integration"
    }
    
    [void] RegisterAction([string]$actionName, [scriptblock]$action, [hashtable]$metadata = @{}) {
        try {
            if ([string]::IsNullOrWhiteSpace($actionName)) { throw "Action name cannot be null or empty" }
            if (-not $action) { throw "Action scriptblock cannot be null" }
            
            $actionData = @{
                Name = $actionName; Action = $action; Metadata = $metadata
                Category = $metadata.Category ?? "General"
                Description = $metadata.Description ?? ""
                Hotkey = $metadata.Hotkey ?? ""
                RegisteredAt = [datetime]::Now; ExecutionCount = 0; LastExecuted = $null
            }
            
            $this.ActionRegistry[$actionName] = $actionData
            $this.EventManager?.Publish("Action.Registered", @{ ActionName = $actionName; Category = $actionData.Category })
            Write-Log -Level Debug -Message "ActionService: Registered action '$actionName' in category '$($actionData.Category)'"
        }
        catch {
            Write-Log -Level Error -Message "Failed to register action '$actionName': $_" -Data $_
            throw
        }
    }
    
    [void] UnregisterAction([string]$actionName) {
        if ($this.ActionRegistry.ContainsKey($actionName)) {
            $this.ActionRegistry.Remove($actionName)
            $this.EventManager?.Publish("Action.Unregistered", @{ ActionName = $actionName })
            Write-Log -Level Debug -Message "ActionService: Unregistered action '$actionName'"
        }
    }
    
    [object] ExecuteAction([string]$actionName, [hashtable]$parameters = @{}) {
        try {
            if (-not $this.ActionRegistry.ContainsKey($actionName)) { throw "Action '$actionName' not found in registry" }
            
            $actionData = $this.ActionRegistry[$actionName]
            $actionData.ExecutionCount++; $actionData.LastExecuted = [datetime]::Now
            
            Write-Log -Level Info -Message "ActionService: Executing action '$actionName'"
            
            $result = & $actionData.Action @parameters
            
            $this.EventManager?.Publish("Action.Executed", @{ ActionName = $actionName; Parameters = $parameters; Success = $true })
            return $result
        }
        catch {
            Write-Log -Level Error -Message "Failed to execute action '$actionName': $($_.Exception.Message)" -Data $_
            $this.EventManager?.Publish("Action.Executed", @{ ActionName = $actionName; Parameters = $parameters; Success = $false; Error = $_.ToString() })
            throw
        }
    }
    
    [hashtable] GetAction([string]$actionName) { return $this.ActionRegistry[$actionName] }
    [hashtable] GetAllActions() { return $this.ActionRegistry }
    [hashtable[]] GetActionsByCategory([string]$category) { return @($this.ActionRegistry.Values | Where-Object { $_.Category -eq $category }) }
    
    [void] RegisterDefaultActions() {
        $this.RegisterAction("app.exit", { $global:TuiState.Running = $false }, @{ Category = "Application"; Description = "Exit the application" })
        $this.RegisterAction("app.help", { }, @{ Category = "Application"; Description = "Show help" })
        $this.RegisterAction("app.commandPalette", { $global:TuiState.CommandPalette?.Show(); $global:TuiState.IsDirty = $true }, @{ Category = "Application"; Description = "Show command palette" })
        
        $this.RegisterAction("ui.theme.picker", {
            $navService = $global:TuiState.Services.NavigationService; $container = $global:TuiState.Services.ServiceContainer
            $themeScreen = [ThemePickerScreen]::new($container); $themeScreen.Initialize(); $navService.NavigateTo($themeScreen)
        }, @{ Category = "UI"; Description = "Change Theme" })

        $this.RegisterAction("navigation.dashboard", {
            $navService = $global:TuiState.Services.NavigationService; $container = $global:TuiState.Services.ServiceContainer
            $dashScreen = [DashboardScreen]::new($container); $dashScreen.Initialize(); $navService.NavigateTo($dashScreen)
        }, @{ Category = "Navigation"; Description = "Go to Dashboard" })
        
        $this.RegisterAction("navigation.taskList", {
            $navService = $global:TuiState.Services.NavigationService; $container = $global:TuiState.Services.ServiceContainer
            $taskScreen = [TaskListScreen]::new($container); $taskScreen.Initialize(); $navService.NavigateTo($taskScreen)
        }, @{ Category = "Navigation"; Description = "Go to Task List" })
        
        Write-Log -Level Debug -Message "ActionService: Registered default actions"
    }
}

#endregion
#<!-- END_PAGE: ASE.001 -->

#<!-- PAGE: ASE.002 - KeybindingService Class -->
#region KeybindingService Class

# ==============================================================================
# CLASS: KeybindingService
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   Services:
#     - ActionService (ASE.001) (optional)
#
# PURPOSE:
#   Translates raw keyboard input (`ConsoleKeyInfo`) into named actions. It
#   supports different contexts, allowing keybindings to change depending on
#   which part of the UI is active.
#
# KEY LOGIC:
#   - `_GetKeyPattern`: Converts a `ConsoleKeyInfo` object into a canonical
#     string format (e.g., "Ctrl+Shift+A"). This is the key used in the maps.
#   - `SetBinding`: Maps a key pattern string to an action name string within a
#     given context (e.g., "Global", "Editor").
#   - `GetAction`: The main lookup method. Given a `ConsoleKeyInfo`, it generates
#     the pattern and checks for a matching action, first in the contextual
#     key maps and then falling back to the "Global" map.
# ==============================================================================
class KeybindingService {
    [hashtable]$KeyMap = @{}
    [hashtable]$GlobalHandlers = @{}
    [System.Collections.Generic.Stack[hashtable]]$ContextStack
    [ActionService]$ActionService
    [bool]$EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.Stack[hashtable]]::new()
        $this._InitializeDefaultBindings()
    }
    
    KeybindingService([ActionService]$actionService) {
        $this.ActionService = $actionService
        $this.ContextStack = [System.Collections.Generic.Stack[hashtable]]::new()
        $this._InitializeDefaultBindings()
    }
    
    hidden [void] _InitializeDefaultBindings() {
        $this.SetBinding("Ctrl+Q", "app.exit", "Global")
        $this.SetBinding("F1", "app.help", "Global")
        $this.SetBinding("Ctrl+P", "app.commandPalette", "Global")
        $this.SetBinding("Ctrl+D", "navigation.dashboard", "Global")
        $this.SetBinding("Ctrl+T", "navigation.taskList", "Global")
        $this.SetBinding("Tab", "navigation.nextComponent", "Global")
        $this.SetBinding("Shift+Tab", "navigation.previousComponent", "Global")
        Write-Log -Level Debug -Message "KeybindingService: Initialized default keybindings"
    }
    
    [void] SetBinding([string]$keyPattern, [string]$actionName, [string]$context = "Global") {
        if (-not $this.KeyMap.ContainsKey($context)) { $this.KeyMap[$context] = @{} }
        $this.KeyMap[$context][$keyPattern] = $actionName
        Write-Log -Level Debug -Message "KeybindingService: Bound '$keyPattern' to '$actionName' in context '$context'"
    }
    
    [void] RemoveBinding([string]$keyPattern, [string]$context = "Global") {
        if ($this.KeyMap.ContainsKey($context)) {
            $this.KeyMap[$context].Remove($keyPattern)
            Write-Log -Level Debug -Message "KeybindingService: Removed binding for '$keyPattern' in context '$context'"
        }
    }
    
    [bool] IsAction([System.ConsoleKeyInfo]$keyInfo, [string]$actionName) {
        $keyPattern = $this._GetKeyPattern($keyInfo)
        foreach ($context in $this.ContextStack) { if ($context.ContainsKey($keyPattern) -and $context[$keyPattern] -eq $actionName) { return $true } }
        return ($this.KeyMap.Global?.$keyPattern -eq $actionName)
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        $keyPattern = $this._GetKeyPattern($keyInfo)
        foreach ($context in $this.ContextStack) { if ($context.ContainsKey($keyPattern)) { return $context[$keyPattern] } }
        return $this.KeyMap.Global?.$keyPattern
    }
    
    [string] GetBindingDescription([System.ConsoleKeyInfo]$keyInfo) {
        $action = $this.GetAction($keyInfo)
        if ($action -and $this.ActionService) { return $this.ActionService.GetAction($action)?.Description }
        return $null
    }
    
    hidden [string] _GetKeyPattern([System.ConsoleKeyInfo]$keyInfo) {
        $parts = [System.Collections.Generic.List[string]]::new()
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) { $parts.Add("Ctrl") }
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt) { $parts.Add("Alt") }
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift) { $parts.Add("Shift") }
        $parts.Add($keyInfo.Key.ToString())
        return $parts -join "+"
    }
    
    [void] PushContext([hashtable]$contextBindings) {
        $this.ContextStack.Push($contextBindings)
        Write-Log -Level Debug -Message "KeybindingService: Pushed new context with $($contextBindings.Count) bindings"
    }
    
    [void] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $removed = $this.ContextStack.Pop()
            Write-Log -Level Debug -Message "KeybindingService: Popped context with $($removed.Count) bindings"
        }
    }
    
    [void] RegisterGlobalHandler([string]$handlerId, [scriptblock]$handler) {
        $this.GlobalHandlers[$handlerId] = $handler
        Write-Log -Level Debug -Message "KeybindingService: Registered global handler '$handlerId'"
    }
    
    [void] UnregisterGlobalHandler([string]$handlerId) {
        $this.GlobalHandlers.Remove($handlerId)
        Write-Log -Level Debug -Message "KeybindingService: Unregistered global handler '$handlerId'"
    }

    [void] Cleanup() {
        $this.KeyMap.Clear(); $this.GlobalHandlers.Clear(); $this.ContextStack.Clear()
        Write-Log -Level Debug -Message "KeybindingService: Cleanup complete"
    }
}

#endregion
#<!-- END_PAGE: ASE.002 -->

#<!-- PAGE: ASE.003 - DataManager Class -->
#region DataManager Class

# ==============================================================================
# CLASS: DataManager
#
# INHERITS:
#   - System.IDisposable
#
# DEPENDENCIES:
#   Models:
#     - PmcTask (AMO.003)
#     - PmcProject (AMO.003)
#   Services:
#     - EventManager (ASE.007) (optional)
#
# PURPOSE:
#   Handles all data persistence for the application. It loads and saves the
#   application's state (tasks, projects) to a JSON file, provides safe
#   CRUD operations, and manages automatic backups.
#
# KEY LOGIC:
#   - Uses Dictionaries (`_taskIndex`, `_projectIndex`) for fast O(1) lookups
#     of items by their ID/Key.
#   - `LoadData`/`SaveData`: Serializes and deserializes the entire data model
#     to/from JSON. `SaveData` also calls `CreateBackup`.
#   - `CreateBackup`: Manages a rotating set of timestamped backup files.
#   - `BeginUpdate`/`EndUpdate`: Provides a transactional mechanism to batch
#     multiple data modifications, preventing multiple file saves in a short
#     period and ensuring data consistency. A save only occurs when the
#     outermost transaction is completed.
# ==============================================================================
class DataManager : System.IDisposable {
    hidden [System.Collections.Generic.Dictionary[string, PmcTask]]$_taskIndex
    hidden [System.Collections.Generic.Dictionary[string, PmcProject]]$_projectIndex
    hidden [string]$_dataFilePath
    hidden [string]$_backupPath
    hidden [datetime]$_lastSaveTime
    hidden [bool]$_dataModified = $false
    hidden [int]$_updateTransactionCount = 0
    
    [hashtable]$Metadata = @{}
    [bool]$AutoSave = $true
    [int]$BackupCount = 5
    [EventManager]$EventManager = $null
    
    DataManager([string]$dataPath, [EventManager]$eventManager = $null) {
        $this._dataFilePath = $dataPath
        $this.EventManager = $eventManager
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $this._taskIndex = [System.Collections.Generic.Dictionary[string, PmcTask]]::new([System.StringComparer]::OrdinalIgnoreCase)
        $this._projectIndex = [System.Collections.Generic.Dictionary[string, PmcProject]]::new([System.StringComparer]::OrdinalIgnoreCase)
        
        $baseDir = Split-Path -Path $this._dataFilePath -Parent
        $this._backupPath = Join-Path $baseDir "backups"
        
        if (-not (Test-Path $baseDir)) { New-Item -ItemType Directory -Path $baseDir -Force | Out-Null }
        if (-not (Test-Path $this._backupPath)) { New-Item -ItemType Directory -Path $this._backupPath -Force | Out-Null }
        
        Write-Log -Level Info -Message "DataManager: Initialized with path '$($this._dataFilePath)'"
    }
    
    [void] LoadData() {
        try {
            if (-not (Test-Path $this._dataFilePath)) { Write-Log -Level Info -Message "DataManager: No existing data file found at '$($this._dataFilePath)'"; return }
            $jsonContent = Get-Content -Path $this._dataFilePath -Raw -Encoding UTF8
            if ([string]::IsNullOrWhiteSpace($jsonContent)) { Write-Log -Level Info -Message "DataManager: Data file is empty"; return }
            
            $data = $jsonContent | ConvertFrom-Json -AsHashtable
            $this._taskIndex.Clear(); $this._projectIndex.Clear()
            
            if ($data.Tasks) { foreach ($taskData in $data.Tasks) { try { $task = [PmcTask]::FromLegacyFormat($taskData); $this._taskIndex[$task.Id] = $task } catch { Write-Log -Level Warning -Message "DataManager: Failed to load task: $($_.Exception.Message)" } } }
            if ($data.Projects) { foreach ($projectData in $data.Projects) { try { $project = [PmcProject]::FromLegacyFormat($projectData); $this._projectIndex[$project.Key] = $project } catch { Write-Log -Level Warning -Message "DataManager: Failed to load project: $($_.Exception.Message)" } } }
            if ($data.Metadata) { $this.Metadata = $data.Metadata.Clone() }
            
            $this._lastSaveTime = [datetime]::Now; $this._dataModified = $false
            Write-Log -Level Info -Message "DataManager: Loaded $($this._taskIndex.Count) tasks and $($this._projectIndex.Count) projects"
            $this.EventManager?.Publish("Data.Loaded", @{ TaskCount = $this._taskIndex.Count; ProjectCount = $this._projectIndex.Count; Source = $this._dataFilePath })
        }
        catch {
            Write-Log -Level Error -Message "DataManager: Failed to load data from '$($this._dataFilePath)': $($_.Exception.Message)" -Data $_
            throw
        }
    }
    
    [void] SaveData() {
        if ($this._updateTransactionCount -gt 0) { Write-Log -Level Debug -Message "DataManager: SaveData deferred - inside update transaction (level $($this._updateTransactionCount))"; return }
        
        try {
            $this.CreateBackup()
            $saveData = @{ Tasks = @(); Projects = @(); Metadata = $this.Metadata.Clone(); SavedAt = [datetime]::Now; Version = "4.0" }
            foreach ($task in $this._taskIndex.Values) { $saveData.Tasks += $task.ToLegacyFormat() }
            foreach ($project in $this._projectIndex.Values) { $saveData.Projects += $project.ToLegacyFormat() }
            
            $saveData | ConvertTo-Json -Depth 10 | Set-Content -Path $this._dataFilePath -Encoding UTF8 -Force
            $this._lastSaveTime = [datetime]::Now; $this._dataModified = $false
            
            Write-Log -Level Info -Message "DataManager: Data saved to '$($this._dataFilePath)'"
            $this.EventManager?.Publish("Data.Saved", @{ TaskCount = $saveData.Tasks.Count; ProjectCount = $saveData.Projects.Count; Destination = $this._dataFilePath })
        }
        catch {
            Write-Log -Level Error -Message "DataManager: Failed to save data: $($_.Exception.Message)" -Data $_
            throw
        }
    }
    
    hidden [void] CreateBackup() {
        try {
            if (Test-Path $this._dataFilePath) {
                $timestamp = (Get-Date).ToString("yyyyMMdd-HHmmss")
                $backupFileName = "data-backup-$timestamp.json"
                $backupFilePath = Join-Path $this._backupPath $backupFileName
                Copy-Item -Path $this._dataFilePath -Destination $backupFilePath -Force
                
                if ($this.BackupCount -gt 0) {
                    $backups = Get-ChildItem -Path $this._backupPath -Filter "data-backup-*.json" | Sort-Object LastWriteTime -Descending
                    if ($backups.Count -gt $this.BackupCount) {
                        $backups | Select-Object -Skip $this.BackupCount | Remove-Item -Force -Verbose:$false
                    }
                }
            }
        }
        catch { Write-Log -Level Warning -Message "DataManager: Failed to create backup: $($_.Exception.Message)" }
    }
    
    [void] BeginUpdate() { $this._updateTransactionCount++; Write-Log -Level Debug -Message "DataManager: Began update transaction. Depth: $($this._updateTransactionCount)" }
    [void] EndUpdate([bool]$forceSave = $false) {
        if ($this._updateTransactionCount -gt 0) { $this._updateTransactionCount-- }
        Write-Log -Level Debug -Message "DataManager: Ended update transaction. Depth: $($this._updateTransactionCount)"
        if ($this._updateTransactionCount -eq 0 -and ($this._dataModified -or $forceSave)) { if ($this.AutoSave -or $forceSave) { $this.SaveData() } }
    }
    
    [PmcTask[]] GetTasks() { return @($this._taskIndex.Values) }
    [PmcTask] GetTask([string]$taskId) { if ($this._taskIndex.ContainsKey($taskId)) { return $this._taskIndex[$taskId] } return $null }
    [PmcTask[]] GetTasksByProject([string]$projectKey) { return @($this._taskIndex.Values | Where-Object { $_.ProjectKey -eq $projectKey }) }
    
    [PmcTask] AddTask([PmcTask]$task) {
        if (-not $task) { throw [System.ArgumentNullException]::new("task") }
        if ([string]::IsNullOrEmpty($task.Id)) { $task.Id = [guid]::NewGuid().ToString() }
        if ($this._taskIndex.ContainsKey($task.Id)) { throw [System.InvalidOperationException]::new("Task with ID '$($task.Id)' already exists") }
        
        $this._taskIndex[$task.Id] = $task; $this._dataModified = $true
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) { $this.SaveData() }
        $this.EventManager?.Publish("Tasks.Changed", @{ Action = "Created"; Task = $task })
        return $task
    }
    
    [PmcTask] UpdateTask([PmcTask]$task) {
        if (-not $task) { throw [System.ArgumentNullException]::new("task") }
        if (-not $this._taskIndex.ContainsKey($task.Id)) { throw [System.InvalidOperationException]::new("Task with ID '$($task.Id)' not found") }
        
        $task.UpdatedAt = [datetime]::Now
        $this._taskIndex[$task.Id] = $task; $this._dataModified = $true
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) { $this.SaveData() }
        $this.EventManager?.Publish("Tasks.Changed", @{ Action = "Updated"; Task = $task })
        return $task
    }
    
    [bool] DeleteTask([string]$taskId) {
        if (-not $this._taskIndex.ContainsKey($taskId)) { return $false }
        
        $this._taskIndex.Remove($taskId) | Out-Null; $this._dataModified = $true
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) { $this.SaveData() }
        $this.EventManager?.Publish("Tasks.Changed", @{ Action = "Deleted"; TaskId = $taskId })
        return $true
    }
    
    [PmcProject[]] GetProjects() { return @($this._projectIndex.Values) }
    [PmcProject] GetProject([string]$projectKey) { if ($this._projectIndex.ContainsKey($projectKey)) { return $this._projectIndex[$projectKey] } return $null }
    
    [void] Dispose() {
        Write-Log -Level Debug -Message "DataManager: Disposing - checking for unsaved data"
        if ($this._dataModified) { try { $this.ForceSave() } catch { Write-Log -Level Warning -Message "DataManager: Failed to save data during dispose: $($_.Exception.Message)" } }
    }
    
    [void] ForceSave() { $originalCount = $this._updateTransactionCount; $this._updateTransactionCount = 0; try { $this.SaveData() } finally { $this._updateTransactionCount = $originalCount } }
    [void] Cleanup() { $this.Dispose() }
}

#endregion
#<!-- END_PAGE: ASE.003 -->

#<!-- PAGE: ASE.004 - NavigationService Class -->
#region NavigationService Class

# ==============================================================================
# CLASS: NavigationService
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   Classes:
#     - Screen (ABC.006)
#   Services:
#     - EventManager (ASE.007) (optional)
#
# PURPOSE:
#   Manages the application's screen flow. It maintains a navigation stack,
#   allowing for forward and backward navigation between different `Screen`
#   instances.
#
# KEY LOGIC:
#   - A `Stack[Screen]` is used to keep track of the navigation history.
#   - `NavigateTo`: The core forward-navigation method. It calls `OnExit` on
#     the current screen, pushes it to the stack, sets the new screen as
#     current, and calls `OnEnter` on the new screen. It also updates the
#     `$global:TuiState.CurrentScreen`.
#   - `GoBack`: Pops a screen from the stack, calls `OnExit` and `Cleanup` on
#     the current screen, and then calls `OnResume` on the newly restored
#     screen.
# ==============================================================================
class NavigationService {
    [System.Collections.Generic.Stack[Screen]]$NavigationStack
    [Screen]$CurrentScreen
    [EventManager]$EventManager
    [hashtable]$ScreenRegistry
    [int]$MaxStackSize = 10
    [object]$ServiceContainer

    NavigationService([object]$serviceContainer) {
        $this.ServiceContainer = $serviceContainer
        $this.EventManager = $this.ServiceContainer.GetService("EventManager")
        $this.NavigationStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.ScreenRegistry = @{}
    }

    [void] NavigateTo([Screen]$screen) {
        if ($null -eq $screen) { throw [System.ArgumentNullException]::new("screen") }
        
        try {
            if ($this.CurrentScreen) {
                Write-Log -Level Debug -Message "NavigationService: Exiting screen '$($this.CurrentScreen.Name)'"
                $this.CurrentScreen.OnExit()
                $this.NavigationStack.Push($this.CurrentScreen)
            }
            
            $this.CurrentScreen = $screen
            Write-Log -Level Debug -Message "NavigationService: Entering screen '$($screen.Name)'"
            
            if (-not $screen._isInitialized) {
                $screen.Initialize(); $screen._isInitialized = $true
            }
            
            $screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            $screen.OnEnter()
            
            $this.EventManager?.Publish("Navigation.ScreenChanged", @{ Screen = $screen; ScreenName = $screen.Name; StackDepth = $this.NavigationStack.Count })
            
            $global:TuiState.CurrentScreen = $screen
            $global:TuiState.Services.FocusManager?.ReleaseFocus()
            $global:TuiState.IsDirty = $true

        }
        catch {
            Write-Log -Level Error -Message "NavigationService: Failed to navigate to screen '$($screen.Name)': $($_.Exception.Message)" -Data $_
            throw
        }
    }

    [void] NavigateToByName([string]$screenName) {
        if (-not $this.ScreenRegistry.ContainsKey($screenName)) {
            throw [System.ArgumentException]::new("Screen '$screenName' not found in registry. Registered: $($this.ScreenRegistry.Keys -join ', ').", "screenName")
        }
        $this.NavigateTo($this.ScreenRegistry[$screenName])
    }
    
    [bool] CanGoBack() { return $this.NavigationStack.Count -gt 0 }
    
    [void] GoBack() {
        if (-not $this.CanGoBack()) { Write-Log -Level Warning -Message "NavigationService: Cannot go back - navigation stack is empty"; return }
        
        try {
            if ($this.CurrentScreen) {
                $this.CurrentScreen.OnExit(); $this.CurrentScreen.Cleanup()
            }
            
            $previousScreen = $this.NavigationStack.Pop()
            $this.CurrentScreen = $previousScreen
            Write-Log -Level Debug -Message "NavigationService: Resuming screen '$($previousScreen.Name)'"
            
            $previousScreen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)
            $previousScreen.OnResume()
            
            $this.EventManager?.Publish("Navigation.BackNavigation", @{ Screen = $previousScreen; ScreenName = $previousScreen.Name; StackDepth = $this.NavigationStack.Count })
            
            $global:TuiState.CurrentScreen = $previousScreen
            $global:TuiState.Services.FocusManager?.ReleaseFocus()
            $global:TuiState.IsDirty = $true
        }
        catch {
            Write-Log -Level Error -Message "NavigationService: Failed to go back: $($_.Exception.Message)" -Data $_
            throw
        }
    }
    
    [void] Reset() {
        while ($this.NavigationStack.Count -gt 0) { $this.NavigationStack.Pop().Cleanup() }
        if ($this.CurrentScreen) { $this.CurrentScreen.OnExit(); $this.CurrentScreen.Cleanup(); $this.CurrentScreen = $null }
        Write-Log -Level Debug -Message "NavigationService: Reset complete, all screens cleaned up."
    }
}

#endregion
#<!-- END_PAGE: ASE.004 -->

#<!-- PAGE: ASE.005 - ThemeManager Class -->
#region ThemeManager Class

# ==============================================================================
# CLASS: ThemeManager
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   - None
#
# PURPOSE:
#   Manages the application's visual themes. It stores multiple themes as
#   hashtables of color definitions and provides a central point of access for
#   all UI components to retrieve theme-aware colors.
#
# KEY LOGIC:
#   - `InitializeThemes` defines the built-in themes (e.g., "Synthwave"). Each
#     theme is a hashtable mapping a semantic color name (e.g.,
#     "button.focused.bg") to a hex color string.
#   - `LoadTheme`: Switches the active theme.
#   - `GetColor`: The primary method used by components. It retrieves a color
#     from the current theme by its semantic name, ensuring a consistent look
#     and feel that can be changed globally.
# ==============================================================================
class ThemeManager {
    [hashtable]$CurrentTheme = @{}
    [string]$ThemeName = "Synthwave"
    [hashtable]$Themes = @{}
    
    ThemeManager() {
        $this.InitializeThemes()
        $this.LoadTheme($this.ThemeName)
    }
    
    [void] InitializeThemes() {
        # Synthwave Theme
        $this.Themes["Synthwave"] = @{ "Background"="#0a0e27";"Foreground"="#f92aad";"Subtle"="#72f1b8";"Primary"="#ff6ac1";"Accent"="#ffcc00";"Error"="#ff006e";"Warning"="#ffbe0b";"Success"="#3bf4fb";"Info"="#8338ec";"component.background"="#0a0e27";"component.border"="#f92aad";"component.title"="#ffcc00";"input.background"="#1a1e3a";"input.foreground"="#f92aad";"input.placeholder"="#72f1b8";"button.normal.fg"="#0a0e27";"button.normal.bg"="#f92aad";"button.focused.fg"="#0a0e27";"button.focused.bg"="#ff6ac1";"button.pressed.fg"="#0a0e27";"button.pressed.bg"="#ffcc00";"button.disabled.fg"="#555555";"button.disabled.bg"="#2a2e4a";"list.header.fg"="#ffcc00";"list.header.bg"="#1a1e3a";"list.item.normal"="#f92aad";"list.item.selected"="#0a0e27";"list.item.selected.background"="#ff6ac1";"list.scrollbar"="#72f1b8" }
        # Aurora Theme
        $this.Themes["Aurora"] = @{ "Background"="#011627";"Foreground"="#d6deeb";"Subtle"="#7fdbca";"Primary"="#82aaff";"Accent"="#21c7a8";"Error"="#ef5350";"Warning"="#ffeb95";"Success"="#22da6e";"Info"="#82aaff";"component.background"="#011627";"component.border"="#5f7e97";"component.title"="#21c7a8";"input.background"="#0e293f";"input.foreground"="#d6deeb";"input.placeholder"="#637777";"button.normal.fg"="#011627";"button.normal.bg"="#82aaff";"button.focused.fg"="#011627";"button.focused.bg"="#21c7a8";"button.pressed.fg"="#011627";"button.pressed.bg"="#c792ea";"button.disabled.fg"="#444444";"button.disabled.bg"="#1d3b53";"list.header.fg"="#21c7a8";"list.header.bg"="#0e293f";"list.item.normal"="#d6deeb";"list.item.selected"="#011627";"list.item.selected.background"="#82aaff";"list.scrollbar"="#5f7e97" }
        # Forest Theme
        $this.Themes["Forest"] = @{ "Background"="#0d1117";"Foreground"="#c9d1d9";"Subtle"="#8b949e";"Primary"="#58a6ff";"Accent"="#56d364";"Error"="#f85149";"Warning"="#f0883e";"Success"="#56d364";"Info"="#58a6ff";"component.background"="#0d1117";"component.border"="#30363d";"component.title"="#56d364";"input.background"="#161b22";"input.foreground"="#c9d1d9";"input.placeholder"="#484f58";"button.normal.fg"="#0d1117";"button.normal.bg"="#58a6ff";"button.focused.fg"="#0d1117";"button.focused.bg"="#56d364";"button.pressed.fg"="#0d1117";"button.pressed.bg"="#d29922";"button.disabled.fg"="#484f58";"button.disabled.bg"="#21262d";"list.header.fg"="#56d364";"list.header.bg"="#161b22";"list.item.normal"="#c9d1d9";"list.item.selected"="#0d1117";"list.item.selected.background"="#58a6ff";"list.scrollbar"="#8b949e" }
    }
    
    [void] LoadTheme([string]$themeName) {
        if ($this.Themes.ContainsKey($themeName)) {
            $this.CurrentTheme = $this.Themes[$themeName].Clone()
            $this.ThemeName = $themeName
        }
    }
    
    [string] GetColor([string]$colorName, [string]$defaultColor = "#808080") {
        return $this.CurrentTheme[$colorName] ?? $defaultColor
    }
    
    [string[]] GetAvailableThemes() { return @($this.Themes.Keys | Sort-Object) }
}

#endregion
#<!-- END_PAGE: ASE.005 -->

#<!-- PAGE: ASE.006 - Logger Class -->
#region Logger Class

# ==============================================================================
# CLASS: Logger
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   - None
#
# PURPOSE:
#   Provides a robust, application-wide logging service. All diagnostic
#   messages from the framework should be routed through this service.
#
# KEY LOGIC:
#   - `Log`: The primary method. It checks the message's level against the
#     `MinimumLevel` before processing. It creates a structured log entry
#     (hashtable) with a timestamp, level, message, and thread ID.
#   - `LogQueue`: A `System.Collections.Queue` is used to batch log messages
#     in memory before writing them to a file.
#   - `Flush`: Writes the contents of the queue to the specified log file. This
#     is called automatically when the queue is full or manually on cleanup.
# ==============================================================================
class Logger {
    [string]$LogPath
    [System.Collections.Queue]$LogQueue
    [int]$MaxQueueSize = 1000
    [bool]$EnableFileLogging = $true
    [bool]$EnableConsoleLogging = $false
    [string]$MinimumLevel = "Info"
    [hashtable]$LevelPriority = @{ 'Trace' = 0; 'Debug' = 1; 'Info' = 2; 'Warning' = 3; 'Error' = 4; 'Fatal' = 5 }
    
    Logger([string]$logPath) {
        $this.LogPath = $logPath
        $this.LogQueue = [System.Collections.Queue]::new()
        $logDir = Split-Path -Parent $this.LogPath
        if (-not (Test-Path $logDir)) { New-Item -ItemType Directory -Path $logDir -Force | Out-Null }
    }
    
    [void] Log([string]$level, [string]$message, [object]$Data = $null) {
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) { return }
        $finalMessage = if($Data) { "$message | Data: $($Data | ConvertTo-Json -Compress -Depth 5)" } else { $message }
        $logEntry = @{ Timestamp = [DateTime]::Now; Level = $level; Message = $finalMessage; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId }
        $this.LogQueue.Enqueue($logEntry)
        if ($this.LogQueue.Count -ge $this.MaxQueueSize) { $this.Flush() }
        if ($this.EnableConsoleLogging) { $this._WriteToConsole($logEntry) }
    }
    
    [void] Flush() {
        if ($this.LogQueue.Count -eq 0 -or -not $this.EnableFileLogging) { return }
        try {
            $logContent = [System.Text.StringBuilder]::new()
            while ($this.LogQueue.Count -gt 0) {
                $entry = $this.LogQueue.Dequeue()
                $logLine = "$($entry.Timestamp.ToString('yyyy-MM-dd HH:mm:ss.fff')) [$($entry.Level.ToUpper().PadRight(7))] [T$($entry.ThreadId)] $($entry.Message)"
                [void]$logContent.AppendLine($logLine)
            }
            if ($logContent.Length -gt 0) { Add-Content -Path $this.LogPath -Value $logContent.ToString() -NoNewline }
        }
        catch { Write-Warning "Logger: Failed to flush logs: $_" }
    }
    
    hidden [void] _WriteToConsole([hashtable]$logEntry) {
        # This is for debug purposes and should not be used in the final TUI
    }
    
    [void] Cleanup() { $this.Flush() }
}

#endregion
#<!-- END_PAGE: ASE.006 -->

#<!-- PAGE: ASE.007 - EventManager Class -->
#region EventManager Class

# ==============================================================================
# CLASS: EventManager
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   - None
#
# PURPOSE:
#   Implements a publish-subscribe pattern to allow for decoupled communication
#   between different parts of the framework. This prevents components from
#   needing direct references to each other.
#
# KEY LOGIC:
#   - `Subscribe`: Adds a scriptblock (handler) to a list of handlers for a
#     named event. Returns a unique handler ID for unsubscribing.
#   - `Publish`: Given an event name, it iterates through all subscribed
#     handlers for that event and invokes them, passing along event data.
#   - `Unsubscribe`: Removes a specific handler from an event's subscription list.
# ==============================================================================
class EventManager {
    [hashtable]$EventHandlers = @{}
    [int]$NextHandlerId = 1
    
    EventManager() {
        Write-Log -Level Debug -Message "EventManager: Initialized"
    }
    
    [string] Subscribe([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) { throw [ArgumentException]::new("Event name cannot be null or empty") }
        if (-not $handler) { throw [ArgumentNullException]::new("handler") }
        
        if (-not $this.EventHandlers.ContainsKey($eventName)) { $this.EventHandlers[$eventName] = @{} }
        $handlerId = "handler_$($this.NextHandlerId++)"
        $this.EventHandlers[$eventName][$handlerId] = @{ Handler = $handler; SubscribedAt = [DateTime]::Now }
        Write-Log -Level Debug -Message "EventManager: Subscribed handler '$handlerId' to event '$eventName'"
        return $handlerId
    }
    
    [void] Unsubscribe([string]$eventName, [string]$handlerId) {
        if ($this.EventHandlers[$eventName]?.ContainsKey($handlerId)) {
            $this.EventHandlers[$eventName].Remove($handlerId)
            if ($this.EventHandlers[$eventName].Count -eq 0) { $this.EventHandlers.Remove($eventName) }
            Write-Log -Level Debug -Message "EventManager: Unsubscribed handler '$handlerId' from event '$eventName'"
        }
    }
    
    [void] Publish([string]$eventName, [hashtable]$eventData = @{}) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlers = @($this.EventHandlers[$eventName].GetEnumerator())
            Write-Log -Level Debug -Message "EventManager: Publishing event '$eventName' to $($handlers.Count) handlers."
            foreach ($entry in $handlers) {
                try { & $entry.Value.Handler $eventData }
                catch { Write-Log -Level Error -Message "EventManager: Error in handler '$($entry.Key)' for event '$eventName': $($_.Exception.Message)" -Data $_ }
            }
        }
    }
}

#endregion
#<!-- END_PAGE: ASE.007 -->

#<!-- PAGE: ASE.008 - TuiFrameworkService Class -->
#region TuiFrameworkService Class

# ===== CLASS: TuiFrameworkService =====
# Module: tui-framework (from axiom)
# Dependencies: None
# Purpose: Framework utilities and async operations
class TuiFrameworkService {
    [hashtable]$AsyncJobs = @{}
    [int]$NextJobId = 1
    
    TuiFrameworkService() {}
}

#endregion
#<!-- END_PAGE: ASE.008 -->

#<!-- PAGE: ASE.009 - FocusManager Class -->
#region Additional Service Classes

# ==============================================================================
# CLASS: FocusManager
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   Classes:
#     - UIElement (ABC.004)
#   Services:
#     - EventManager (ASE.007) (optional)
#
# PURPOSE:
#   Provides a centralized, authoritative source for which UI component has
#   input focus. This is critical for routing keyboard input correctly.
#
# KEY LOGIC:
#   - `SetFocus`: The core method. It correctly blurs the previously focused
#     component (setting `IsFocused` to false and calling `OnBlur`) before
#     focusing the new component (setting `IsFocused` to true and calling `OnFocus`).
#   - `MoveFocus`: Implements Tab and Shift+Tab navigation. It queries the
#     current screen for all focusable children, sorts them by TabIndex/position,
#     and calls `SetFocus` on the next or previous one in the sequence.
#   - `ReleaseFocus`: A convenience method to blur the current component without
#     focusing a new one.
# ==============================================================================
class FocusManager {
    [UIElement]$FocusedComponent = $null
    [EventManager]$EventManager = $null

    FocusManager([EventManager]$eventManager = $null) {
        $this.EventManager = $eventManager
    }

    [void] SetFocus([UIElement]$component) {
        if ($this.FocusedComponent -eq $component) { return }
        
        if ($this.FocusedComponent) {
            $this.FocusedComponent.IsFocused = $false
            $this.FocusedComponent.OnBlur()
            $this.FocusedComponent.RequestRedraw()
            Write-Log -Level Debug -Message "FocusManager: Blurred '$($this.FocusedComponent.Name)'."
        }

        $this.FocusedComponent = $null
        if ($component -and $component.IsFocusable -and $component.Enabled -and $component.Visible) {
            $this.FocusedComponent = $component
            $component.IsFocused = $true
            $component.OnFocus()
            $component.RequestRedraw()
            Write-Log -Level Debug -Message "FocusManager: Focused '$($component.Name)'."
            $this.EventManager?.Publish("Focus.Changed", @{ ComponentName = $component.Name; Component = $component })
        }
        $global:TuiState.IsDirty = $true
    }

    [void] MoveFocus([bool]$reverse = $false) {
        if (-not $global:TuiState.CurrentScreen) { return }

        $focusableComponents = [System.Collections.Generic.List[UIElement]]::new()
        $this._FindFocusableRecursive($global:TuiState.CurrentScreen, $focusableComponents)
        
        if ($focusableComponents.Count -eq 0) { $this.SetFocus($null); return }
        
        $sorted = $focusableComponents | Sort-Object { $_.TabIndex * 10000 + $_.Y * 100 + $_.X }
        $currentIndex = if ($this.FocusedComponent) { $sorted.IndexOf($this.FocusedComponent) } else { -1 }
        
        $nextIndex = if ($currentIndex -eq -1) {
            if ($reverse) { $sorted.Count - 1 } else { 0 }
        } else {
            ($currentIndex + ($if ($reverse) { -1 } else { 1 }) + $sorted.Count) % $sorted.Count
        }
        
        $this.SetFocus($sorted[$nextIndex])
    }

    hidden [void] _FindFocusableRecursive([UIElement]$component, [System.Collections.Generic.List[UIElement]]$list) {
        if ($component -and $component.IsFocusable -and $component.Visible -and $component.Enabled) { $list.Add($component) }
        foreach ($child in $component.Children) { $this._FindFocusableRecursive($child, $list) }
    }

    [void] ReleaseFocus() { $this.SetFocus($null) }
    [void] Cleanup() { $this.FocusedComponent = $null }
}

# ==============================================================================
# CLASS: DialogManager
#
# INHERITS:
#   - None
#
# DEPENDENCIES:
#   Classes:
#     - UIElement (ABC.004)
#   Services:
#     - EventManager (ASE.007)
#     - FocusManager (ASE.009)
#
# PURPOSE:
#   Manages the lifecycle of modal dialogs and other overlays. It ensures that
#   dialogs are rendered on top of other content and that input focus is
#   handled correctly.
#
# KEY LOGIC:
#   - `ShowDialog`: Positions the dialog, adds it to the global `OverlayStack`
#     for rendering, and crucially, tells the `FocusManager` to set focus to
#     the dialog's first focusable child. It also saves the previously focused
#     component.
#   - `HideDialog`: Removes the dialog from the `OverlayStack`, calls its
#     `Cleanup` method, and tells `FocusManager` to restore focus to the
#     component that was focused before the dialog appeared.
# ==============================================================================
class DialogManager {
    hidden [System.Collections.Generic.List[UIElement]] $_activeDialogs = [System.Collections.Generic.List[UIElement]]::new()
    [EventManager]$EventManager
    [FocusManager]$FocusManager

    DialogManager([EventManager]$eventManager, [FocusManager]$focusManager) {
        $this.EventManager = $eventManager
        $this.FocusManager = $focusManager
    }

    [void] ShowDialog([UIElement]$dialog) {
        if (-not $dialog) { throw [System.ArgumentNullException]::new("dialog") }
        
        $dialog.X = [Math]::Max(0, [Math]::Floor(($global:TuiState.BufferWidth - $dialog.Width) / 2))
        $dialog.Y = [Math]::Max(0, [Math]::Floor(($global:TuiState.BufferHeight - $dialog.Height) / 2))

        $dialog.Metadata.PreviousFocus = $this.FocusManager?.FocusedComponent
        $this.FocusManager?.ReleaseFocus()

        $this._activeDialogs.Add($dialog)
        $dialog.Visible = $true
        $dialog.IsOverlay = $true
        $global:TuiState.OverlayStack.Add($dialog)
        
        if ($dialog.PSObject.Methods['Initialize'] -and -not $dialog._isInitialized) {
            $dialog.Initialize(); $dialog._isInitialized = $true
        }
        if ($dialog.PSObject.Methods['OnEnter']) { $dialog.OnEnter() }

        $dialog.RequestRedraw()
        Write-Log -Level Info -Message "DialogManager: Showing dialog '$($dialog.Name)' at X=$($dialog.X), Y=$($dialog.Y)."
        
        if ($dialog.PSObject.Methods['SetInitialFocus']) { $dialog.SetInitialFocus() }
        else { $this.FocusManager?.SetFocus($dialog) }
    }

    [void] HideDialog([UIElement]$dialog) {
        if (-not $dialog) { return }

        if ($this._activeDialogs.Remove($dialog)) {
            $dialog.Visible = $false; $dialog.IsOverlay = $false
            if ($global:TuiState.OverlayStack.Contains($dialog)) { $global:TuiState.OverlayStack.Remove($dialog) }
            $dialog.Cleanup()

            $this.FocusManager?.SetFocus($dialog.Metadata.PreviousFocus)
            $dialog.RequestRedraw()
            Write-Log -Level Info -Message "DialogManager: Hiding dialog '$($dialog.Name)'."
        }
    }

    [void] Cleanup() {
        foreach ($dialog in $this._activeDialogs.ToArray()) { $this.HideDialog($dialog) }
        $this._activeDialogs.Clear()
    }
}

#endregion
#<!-- END_PAGE: ASE.009 -->


####\New folder\Apply-CommandPaletteFix.ps1
# ==============================================================================
# Apply-CommandPaletteFix.ps1
# This script replaces the CommandPalette class in AllComponents.ps1
# ==============================================================================

Write-Host "`nApplying CommandPalette FINAL FIX..." -ForegroundColor Green
Write-Host "This will replace the CommandPalette class in AllComponents.ps1" -ForegroundColor Yellow

# Read the current AllComponents.ps1
$componentsFile = Join-Path $PSScriptRoot "AllComponents.ps1"
$content = Get-Content -Path $componentsFile -Raw

if (-not $content) {
    Write-Error "Could not read AllComponents.ps1"
    exit 1
}

# Create backup
$backupFile = Join-Path $PSScriptRoot "AllComponents.ps1.backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
Copy-Item -Path $componentsFile -Destination $backupFile -Force
Write-Host "Created backup: $backupFile" -ForegroundColor Gray

# Find the CommandPalette class section
$startMarker = "#<!-- PAGE: ACO.016 - CommandPalette Class -->"
$endMarker = "#<!-- END_PAGE: ACO.016 -->"

$startIndex = $content.IndexOf($startMarker)
$endIndex = $content.IndexOf($endMarker)

if ($startIndex -eq -1 -or $endIndex -eq -1) {
    Write-Error "Could not find CommandPalette class markers in AllComponents.ps1"
    exit 1
}

# Include the end marker in the replacement
$endIndex = $endIndex + $endMarker.Length

Write-Host "Found CommandPalette section at positions $startIndex to $endIndex" -ForegroundColor Gray

# Read the fixed CommandPalette class
$fixedContent = @'
#<!-- PAGE: ACO.016 - CommandPalette Class -->
# ===== CLASS: CommandPalette =====
# Module: command-palette
# Dependencies: UIElement, Panel, ListBox, TextBoxComponent
# Purpose: Searchable command interface - FINAL FIXED VERSION
class CommandPalette : UIElement {
    hidden [ListBox]$_listBox
    hidden [TextBoxComponent]$_searchBox  # Using TextBoxComponent directly
    hidden [Panel]$_panel
    hidden [List[object]]$_allActions
    hidden [List[object]]$_filteredActions
    hidden [object]$_actionService
    hidden [scriptblock]$OnCancel
    hidden [scriptblock]$OnSelect

    CommandPalette([string]$name, [object]$actionService) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 60
        $this.Height = 20
        $this._actionService = $actionService
        
        $this.Initialize()
    }

    hidden [void] Initialize() {
        # Create main panel
        $this._panel = [Panel]::new("CommandPalette_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.BorderColor = "#00FFFF"
        $this._panel.BackgroundColor = "#000000"
        $this._panel.Title = " Command Palette (Ctrl+P) "
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this._panel.X = 0
        $this._panel.Y = 0
        $this.AddChild($this._panel)

        # Create search box using TextBoxComponent directly
        $this._searchBox = [TextBoxComponent]::new("CommandPalette_Search")
        $this._searchBox.X = 2
        $this._searchBox.Y = 1
        $this._searchBox.Width = $this.Width - 4
        $this._searchBox.Height = 3
        $this._searchBox.Placeholder = "Type to search commands..."
        
        # Set up search handler with proper closure
        $paletteRef = $this
        $this._searchBox.OnChange = {
            param($sender, $text)
            $paletteRef.FilterActions($text)
        }.GetNewClosure()
        
        $this._panel.AddChild($this._searchBox)

        # Create list box
        $this._listBox = [ListBox]::new("CommandPalette_List")
        $this._listBox.X = 2
        $this._listBox.Y = 4
        $this._listBox.Width = $this.Width - 4
        $this._listBox.Height = $this.Height - 6
        $this._panel.AddChild($this._listBox)

        # Initialize action lists
        $this._allActions = [List[object]]::new()
        $this._filteredActions = [List[object]]::new()
    }

    [void] Show() {
        # Center the command palette on screen
        $consoleWidth = $global:TuiState.BufferWidth
        $consoleHeight = $global:TuiState.BufferHeight
        $this.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $this.Width) / 2))
        $this.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $this.Height) / 2))
        
        # Refresh available actions
        $this.RefreshActions()
        
        # Clear search box
        $this._searchBox.Text = ""
        $this._searchBox.CursorPosition = 0
        $this._searchBox._scrollOffset = 0
        
        # Show all actions initially
        $this.FilterActions("")
        
        # Make visible
        $this.Visible = $true
        
        # Set focus to search box
        $focusManager = $global:TuiState.Services.FocusManager
        if ($focusManager) {
            $focusManager.SetFocus($this._searchBox)
        }
        
        # Request redraw
        $this.RequestRedraw()
        $global:TuiState.IsDirty = $true
    }

    [void] Hide() {
        $this.Visible = $false
        
        # Clear search on hide
        $this._searchBox.Text = ""
        $this._searchBox.CursorPosition = 0
        
        # Force a full screen redraw
        $global:TuiState.IsDirty = $true
        
        # Restore focus to current screen
        $navService = $global:TuiState.Services.NavigationService
        if ($navService -and $navService.CurrentScreen) {
            $navService.CurrentScreen.RequestRedraw()
            
            # Try to restore focus to a focusable element on the screen
            $focusManager = $global:TuiState.Services.FocusManager
            if ($focusManager) {
                $focusManager.FocusNext()
            }
        }
        
        if ($this.OnCancel) {
            & $this.OnCancel
        }
    }

    [void] RefreshActions() {
        $this._allActions.Clear()
        
        if ($this._actionService) {
            $actions = $this._actionService.GetAllActions()
            
            if ($actions -and $actions.Count -gt 0) {
                foreach ($key in $actions.Keys) {
                    $action = $actions[$key]
                    if ($action) {
                        $this._allActions.Add($action)
                    }
                }
            }
        }
        
        # Sort by category and name
        $sorted = $this._allActions | Sort-Object Category, Name
        $this._allActions.Clear()
        foreach ($item in $sorted) {
            $this._allActions.Add($item)
        }
    }

    [void] FilterActions([string]$searchText) {
        $this._filteredActions.Clear()
        $this._listBox.ClearItems()
        
        if ([string]::IsNullOrWhiteSpace($searchText)) {
            # Show all actions
            foreach ($action in $this._allActions) {
                $this._filteredActions.Add($action)
                $displayText = $this.FormatActionDisplay($action)
                $this._listBox.AddItem($displayText)
            }
        }
        else {
            # Filter actions
            $searchLower = $searchText.ToLower()
            foreach ($action in $this._allActions) {
                $nameMatch = $action.Name -and $action.Name.ToLower().Contains($searchLower)
                $descMatch = $action.Description -and $action.Description.ToLower().Contains($searchLower)
                $catMatch = $action.Category -and $action.Category.ToLower().Contains($searchLower)
                
                if ($nameMatch -or $descMatch -or $catMatch) {
                    $this._filteredActions.Add($action)
                    $displayText = $this.FormatActionDisplay($action)
                    $this._listBox.AddItem($displayText)
                }
            }
        }
        
        # Set selection to first item if we have results
        if ($this._filteredActions.Count -gt 0) {
            $this._listBox.SelectedIndex = 0
        }
        
        # Ensure list is refreshed
        $this._listBox.RequestRedraw()
        $this.RequestRedraw()
    }

    hidden [string] FormatActionDisplay([object]$action) {
        $parts = @()
        if ($action.Category) {
            $parts += "[$($action.Category)]"
        }
        $parts += $action.Name
        if ($action.Description) {
            $parts += "- $($action.Description)"
        }
        return $parts -join " "
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        # Handle Escape - always close
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Hide()
            return $true
        }
        
        # Handle Enter - execute selected action
        if ($key.Key -eq [ConsoleKey]::Enter) {
            if ($this._listBox.SelectedIndex -ge 0 -and 
                $this._listBox.SelectedIndex -lt $this._filteredActions.Count) {
                
                $selectedAction = $this._filteredActions[$this._listBox.SelectedIndex]
                
                if ($selectedAction) {
                    # Hide first
                    $this.Hide()
                    
                    # Then execute
                    if ($this.OnSelect) {
                        & $this.OnSelect $selectedAction
                    }
                    else {
                        # Execute action directly through action service
                        try {
                            $this._actionService.ExecuteAction($selectedAction.Name, @{})
                        }
                        catch {
                            Write-Log -Level "Error" -Message "Failed to execute action: $_"
                        }
                    }
                    return $true
                }
            }
            # If no selection, just stay open and let the Enter be handled by search box
            return $false
        }
        
        # Handle navigation keys - send to list box
        if ($key.Key -in @([ConsoleKey]::UpArrow, [ConsoleKey]::DownArrow, 
                          [ConsoleKey]::PageUp, [ConsoleKey]::PageDown,
                          [ConsoleKey]::Home, [ConsoleKey]::End)) {
            
            # Send to list box
            $handled = $this._listBox.HandleInput($key)
            if ($handled) {
                $this.RequestRedraw()
            }
            return $handled
        }
        
        # All other input goes to search box
        $handled = $this._searchBox.HandleInput($key)
        if ($handled) {
            $this.RequestRedraw()
        }
        return $handled
    }
    
    # Override OnRender to handle rendering properly
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Clear our buffer
        $bgColor = "#000000"
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # The panel and its children will render themselves through the normal hierarchy
        $this._needs_redraw = $false
    }
}

#<!-- END_PAGE: ACO.016 -->
'@

# Replace the CommandPalette section
$beforeSection = $content.Substring(0, $startIndex)
$afterSection = $content.Substring($endIndex)
$newContent = $beforeSection + $fixedContent + $afterSection

# Write the updated content
Set-Content -Path $componentsFile -Value $newContent -NoNewline -Encoding UTF8

Write-Host "`nCommandPalette fix applied successfully!" -ForegroundColor Green
Write-Host "`nKey changes made:" -ForegroundColor Yellow
Write-Host "  1. Using TextBoxComponent directly instead of TextBox wrapper" -ForegroundColor Gray
Write-Host "  2. Fixed Enter key handling to work regardless of focus" -ForegroundColor Gray
Write-Host "  3. Fixed text box width calculation" -ForegroundColor Gray
Write-Host "  4. Improved focus management" -ForegroundColor Gray
Write-Host "  5. Better action display formatting" -ForegroundColor Gray

Write-Host "`nTo test the fix:" -ForegroundColor Yellow
Write-Host "  1. Restart the application (.\Start.ps1)" -ForegroundColor Gray
Write-Host "  2. Press Ctrl+P to open Command Palette" -ForegroundColor Gray
Write-Host "  3. Type to search for commands" -ForegroundColor Gray
Write-Host "  4. Use arrows to navigate, Enter to execute" -ForegroundColor Gray
Write-Host "  5. Press Escape to close" -ForegroundColor Gray

Write-Host "`nBackup created at: $backupFile" -ForegroundColor Gray



####\New folder\apply-json-fixes.ps1
# Additional fixes for JSON serialization depth warnings

Write-Host "Applying additional fixes for JSON serialization issues..." -ForegroundColor Yellow

# 1. Add null output to any method that might accidentally output objects
$files = @{
    "AllServices.ps1" = @(
        # FocusManager.SetFocus - ensure it doesn't output anything
        @{
            Find = '$this.EventManager.Publish("Focus.Changed", @{ ComponentName = $component.Name; Component = $component })'
            Replace = '$this.EventManager.Publish("Focus.Changed", @{ ComponentName = $component.Name; Component = $component }) | Out-Null'
        }
    )
    "AllComponents.ps1" = @(
        # CommandPalette.Show - ensure no output
        @{
            Find = '$global:TuiState.OverlayStack.Add($this)'
            Replace = '$global:TuiState.OverlayStack.Add($this) | Out-Null'
        },
        # CommandPalette.Hide - ensure no output  
        @{
            Find = '$global:TuiState.OverlayStack.Remove($this)'
            Replace = '$global:TuiState.OverlayStack.Remove($this) | Out-Null'
        }
    )
}

foreach ($file in $files.Keys) {
    $filePath = Join-Path "C:\Users\jhnhe\Documents\GitHub\_XP\_mono" $file
    if (Test-Path $filePath) {
        $content = Get-Content $filePath -Raw
        $modified = $false
        
        foreach ($fix in $files[$file]) {
            if ($content -match [regex]::Escape($fix.Find)) {
                $content = $content -replace [regex]::Escape($fix.Find), $fix.Replace
                $modified = $true
                Write-Host "  Fixed: $($fix.Find -replace '\s+', ' ') in $file" -ForegroundColor Green
            }
        }
        
        if ($modified) {
            Set-Content $filePath $content -NoNewline
        }
    }
}

# 2. Create a wrapper for Write-Verbose that filters out complex objects
$wrapperPath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\fix-verbose-output.ps1"
$wrapperContent = @'
# Add this to the beginning of Start.ps1 to prevent verbose output of complex objects

# Override Write-Verbose to prevent serialization of complex objects
$global:OriginalWriteVerbose = Get-Command Write-Verbose -CommandType Cmdlet
function global:Write-Verbose {
    [CmdletBinding()]
    param(
        [Parameter(Position=0, ValueFromPipeline=$true)]
        [string]$Message
    )
    
    # Filter out messages that might contain serialized objects
    if ($Message -notmatch '\[UIElement:' -and 
        $Message -notmatch 'System\.Collections' -and
        $Message -notmatch '@{') {
        & $global:OriginalWriteVerbose $Message
    }
}
'@

Set-Content $wrapperPath $wrapperContent

Write-Host "`nCreated fix-verbose-output.ps1 - consider adding this to Start.ps1 if verbose output still causes issues" -ForegroundColor Cyan
Write-Host "`nDone! The JSON serialization warnings should be resolved." -ForegroundColor Green



####\New folder\check-all-syntax.ps1
# Comprehensive syntax check for all PowerShell files in the project
$projectPath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono"
$files = @(
    "AllBaseClasses.ps1",
    "AllModels.ps1", 
    "AllComponents.ps1",
    "AllScreens.ps1",
    "AllFunctions.ps1",
    "AllServices.ps1",
    "AllRuntime.ps1",
    "Start.ps1"
)

$hasErrors = $false

foreach ($file in $files) {
    $filePath = Join-Path $projectPath $file
    Write-Host "Checking $file..." -ForegroundColor Yellow
    
    try {
        $errors = $null
        $tokens = $null
        $ast = [System.Management.Automation.Language.Parser]::ParseFile(
            $filePath,
            [ref]$tokens,
            [ref]$errors
        )
        
        if ($errors -and $errors.Count -gt 0) {
            $hasErrors = $true
            Write-Host "  ERROR in $file`:" -ForegroundColor Red
            foreach ($error in $errors) {
                Write-Host "    Line $($error.Extent.StartLineNumber): $($error.Message)" -ForegroundColor Red
            }
        } else {
            Write-Host "  OK" -ForegroundColor Green
        }
    } catch {
        $hasErrors = $true
        Write-Host "  CRITICAL ERROR in $file`:" -ForegroundColor Red
        Write-Host "    $($_.Exception.Message)" -ForegroundColor Red
    }
}

if (-not $hasErrors) {
    Write-Host "`nAll files have valid syntax!" -ForegroundColor Green
} else {
    Write-Host "`nSome files have syntax errors. Please fix them before running the application." -ForegroundColor Red
}



####\New folder\check-syntax-issues.ps1
# Search for potential switch statement syntax issues in AllComponents.ps1

$content = Get-Content "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AllComponents.ps1" -Raw

# Find lines with the problematic pattern: multiple ConsoleKey cases separated by semicolons
$pattern = '\)\s*;\s*\([^)]*ConsoleKey'
$matches = [regex]::Matches($content, $pattern, [System.Text.RegularExpressions.RegexOptions]::Multiline)

Write-Host "Searching for switch statement syntax issues..." -ForegroundColor Cyan

if ($matches.Count -eq 0) {
    Write-Host " No other similar syntax issues found!" -ForegroundColor Green
} else {
    Write-Host "Found $($matches.Count) potential issues:" -ForegroundColor Yellow
    
    foreach ($match in $matches) {
        # Get line number
        $lineNumber = ($content.Substring(0, $match.Index) -split "`n").Count
        
        # Get the line content
        $lines = $content -split "`n"
        $lineContent = $lines[$lineNumber - 1]
        
        Write-Host "`nLine $lineNumber`:" -ForegroundColor Red
        Write-Host "  $($lineContent.Trim())" -ForegroundColor Gray
    }
}

# Also check if our fix was successful by verifying the fixed line
Write-Host "`n`nVerifying our fix at line 2550..." -ForegroundColor Cyan
$lines = $content -split "`n"
if ($lines.Count -gt 2549) {
    $fixedLine = $lines[2549].Trim()
    if ($fixedLine -like '*{$_ -in*') {
        Write-Host " Fix successfully applied!" -ForegroundColor Green
        Write-Host "  Line 2550: $fixedLine" -ForegroundColor Gray
    } else {
        Write-Host " Fix may not have been applied correctly" -ForegroundColor Red
        Write-Host "  Line 2550: $fixedLine" -ForegroundColor Gray
    }
}



####\New folder\CommandPalette_FINAL_FIX.ps1
# ==============================================================================
# CommandPalette FINAL FIX - Complete working implementation
# This replaces the CommandPalette class in AllComponents.ps1
# ==============================================================================

# ===== CLASS: CommandPalette =====
# Module: command-palette
# Dependencies: UIElement, Panel, ListBox, TextBoxComponent
# Purpose: Searchable command interface - FINAL FIXED VERSION
class CommandPalette : UIElement {
    hidden [ListBox]$_listBox
    hidden [TextBoxComponent]$_searchBox  # Using TextBoxComponent directly
    hidden [Panel]$_panel
    hidden [List[object]]$_allActions
    hidden [List[object]]$_filteredActions
    hidden [object]$_actionService
    hidden [scriptblock]$OnCancel
    hidden [scriptblock]$OnSelect

    CommandPalette([string]$name, [object]$actionService) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 60
        $this.Height = 20
        $this._actionService = $actionService
        
        $this.Initialize()
    }

    hidden [void] Initialize() {
        # Create main panel
        $this._panel = [Panel]::new("CommandPalette_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.BorderColor = "#00FFFF"
        $this._panel.BackgroundColor = "#000000"
        $this._panel.Title = " Command Palette (Ctrl+P) "
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this._panel.X = 0
        $this._panel.Y = 0
        $this.AddChild($this._panel)

        # Create search box using TextBoxComponent directly
        $this._searchBox = [TextBoxComponent]::new("CommandPalette_Search")
        $this._searchBox.X = 2
        $this._searchBox.Y = 1
        $this._searchBox.Width = $this.Width - 4
        $this._searchBox.Height = 3
        $this._searchBox.Placeholder = "Type to search commands..."
        
        # Set up search handler with proper closure
        $paletteRef = $this
        $this._searchBox.OnChange = {
            param($sender, $text)
            $paletteRef.FilterActions($text)
        }.GetNewClosure()
        
        $this._panel.AddChild($this._searchBox)

        # Create list box
        $this._listBox = [ListBox]::new("CommandPalette_List")
        $this._listBox.X = 2
        $this._listBox.Y = 4
        $this._listBox.Width = $this.Width - 4
        $this._listBox.Height = $this.Height - 6
        $this._panel.AddChild($this._listBox)

        # Initialize action lists
        $this._allActions = [List[object]]::new()
        $this._filteredActions = [List[object]]::new()
    }

    [void] Show() {
        # Center the command palette on screen
        $consoleWidth = $global:TuiState.BufferWidth
        $consoleHeight = $global:TuiState.BufferHeight
        $this.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $this.Width) / 2))
        $this.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $this.Height) / 2))
        
        # Refresh available actions
        $this.RefreshActions()
        
        # Clear search box
        $this._searchBox.Text = ""
        $this._searchBox.CursorPosition = 0
        $this._searchBox._scrollOffset = 0
        
        # Show all actions initially
        $this.FilterActions("")
        
        # Make visible
        $this.Visible = $true
        
        # Set focus to search box
        $focusManager = $global:TuiState.Services.FocusManager
        if ($focusManager) {
            $focusManager.SetFocus($this._searchBox)
        }
        
        # Request redraw
        $this.RequestRedraw()
        $global:TuiState.IsDirty = $true
    }

    [void] Hide() {
        $this.Visible = $false
        
        # Clear search on hide
        $this._searchBox.Text = ""
        $this._searchBox.CursorPosition = 0
        
        # Force a full screen redraw
        $global:TuiState.IsDirty = $true
        
        # Restore focus to current screen
        $navService = $global:TuiState.Services.NavigationService
        if ($navService -and $navService.CurrentScreen) {
            $navService.CurrentScreen.RequestRedraw()
            
            # Try to restore focus to a focusable element on the screen
            $focusManager = $global:TuiState.Services.FocusManager
            if ($focusManager) {
                $focusManager.FocusNext()
            }
        }
        
        if ($this.OnCancel) {
            & $this.OnCancel
        }
    }

    [void] RefreshActions() {
        $this._allActions.Clear()
        
        if ($this._actionService) {
            $actions = $this._actionService.GetAllActions()
            
            if ($actions -and $actions.Count -gt 0) {
                foreach ($key in $actions.Keys) {
                    $action = $actions[$key]
                    if ($action) {
                        $this._allActions.Add($action)
                    }
                }
            }
        }
        
        # Sort by category and name
        $sorted = $this._allActions | Sort-Object Category, Name
        $this._allActions.Clear()
        foreach ($item in $sorted) {
            $this._allActions.Add($item)
        }
    }

    [void] FilterActions([string]$searchText) {
        $this._filteredActions.Clear()
        $this._listBox.ClearItems()
        
        if ([string]::IsNullOrWhiteSpace($searchText)) {
            # Show all actions
            foreach ($action in $this._allActions) {
                $this._filteredActions.Add($action)
                $displayText = $this.FormatActionDisplay($action)
                $this._listBox.AddItem($displayText)
            }
        }
        else {
            # Filter actions
            $searchLower = $searchText.ToLower()
            foreach ($action in $this._allActions) {
                $nameMatch = $action.Name -and $action.Name.ToLower().Contains($searchLower)
                $descMatch = $action.Description -and $action.Description.ToLower().Contains($searchLower)
                $catMatch = $action.Category -and $action.Category.ToLower().Contains($searchLower)
                
                if ($nameMatch -or $descMatch -or $catMatch) {
                    $this._filteredActions.Add($action)
                    $displayText = $this.FormatActionDisplay($action)
                    $this._listBox.AddItem($displayText)
                }
            }
        }
        
        # Set selection to first item if we have results
        if ($this._filteredActions.Count -gt 0) {
            $this._listBox.SelectedIndex = 0
        }
        
        # Ensure list is refreshed
        $this._listBox.RequestRedraw()
        $this.RequestRedraw()
    }

    hidden [string] FormatActionDisplay([object]$action) {
        $parts = @()
        if ($action.Category) {
            $parts += "[$($action.Category)]"
        }
        $parts += $action.Name
        if ($action.Description) {
            $parts += "- $($action.Description)"
        }
        return $parts -join " "
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        # Handle Escape - always close
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Hide()
            return $true
        }
        
        # Handle Enter - execute selected action
        if ($key.Key -eq [ConsoleKey]::Enter) {
            if ($this._listBox.SelectedIndex -ge 0 -and 
                $this._listBox.SelectedIndex -lt $this._filteredActions.Count) {
                
                $selectedAction = $this._filteredActions[$this._listBox.SelectedIndex]
                
                if ($selectedAction) {
                    # Hide first
                    $this.Hide()
                    
                    # Then execute
                    if ($this.OnSelect) {
                        & $this.OnSelect $selectedAction
                    }
                    else {
                        # Execute action directly through action service
                        try {
                            $this._actionService.ExecuteAction($selectedAction.Name, @{})
                        }
                        catch {
                            Write-Log -Level "Error" -Message "Failed to execute action: $_"
                        }
                    }
                    return $true
                }
            }
            # If no selection, just stay open and let the Enter be handled by search box
            return $false
        }
        
        # Handle navigation keys - send to list box
        if ($key.Key -in @([ConsoleKey]::UpArrow, [ConsoleKey]::DownArrow, 
                          [ConsoleKey]::PageUp, [ConsoleKey]::PageDown,
                          [ConsoleKey]::Home, [ConsoleKey]::End)) {
            
            # Send to list box
            $handled = $this._listBox.HandleInput($key)
            if ($handled) {
                $this.RequestRedraw()
            }
            return $handled
        }
        
        # All other input goes to search box
        $handled = $this._searchBox.HandleInput($key)
        if ($handled) {
            $this.RequestRedraw()
        }
        return $handled
    }
    
    # Override OnRender to handle rendering properly
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Clear our buffer
        $bgColor = "#000000"
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # The panel and its children will render themselves through the normal hierarchy
        $this._needs_redraw = $false
    }
}



####\New folder\CommandPalette_Fixed.ps1
# ===== CLASS: CommandPalette =====
# Module: command-palette
# Dependencies: UIElement, Panel, ListBox, TextBox
# Purpose: Searchable command interface
class CommandPalette : UIElement {
    hidden [ListBox]$_listBox
    hidden [TextBox]$_searchBox
    hidden [Panel]$_panel
    hidden [List[object]]$_allActions
    hidden [List[object]]$_filteredActions
    hidden [object]$_actionService
    hidden [scriptblock]$OnCancel
    hidden [scriptblock]$OnSelect
    hidden [System.DateTime]$_lastSearchTime = [DateTime]::MinValue
    hidden [string]$_pendingSearchText = ""

    CommandPalette([string]$name, [object]$actionService) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 60
        $this.Height = 20
        $this._actionService = $actionService
        
        $this.Initialize()
    }

    hidden [void] Initialize() {
        # Create main panel
        $this._panel = [Panel]::new("CommandPalette_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.BorderColor = "#00FFFF"    # FIXED: Cyan in hex
        $this._panel.BackgroundColor = "#000000" # FIXED: Black in hex
        $this._panel.Title = " Command Palette "
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this.AddChild($this._panel)

        # Create search box
        $this._searchBox = [TextBox]::new("CommandPalette_Search")
        $this._searchBox.X = 2
        $this._searchBox.Y = 1
        $this._searchBox.Width = $this.Width - 4
        $this._searchBox.Height = 3
        $this._searchBox._textBox.Placeholder = "Type to search commands..."
        
        # Fix the OnChange handler to properly capture $this
        $commandPalette = $this
        $this._searchBox._textBox.OnChange = {
            param($sender, $text)
            $commandPalette.FilterActions($text)
        }.GetNewClosure()
        
        $this._panel.AddChild($this._searchBox)

        # Create list box
        $this._listBox = [ListBox]::new("CommandPalette_List")
        $this._listBox.X = 2
        $this._listBox.Y = 4
        $this._listBox.Width = $this.Width - 4
        $this._listBox.Height = $this.Height - 6
        $this._panel.AddChild($this._listBox)

        # Initialize action lists
        $this._allActions = [List[object]]::new()
        $this._filteredActions = [List[object]]::new()
    }

    [void] Show() {
        # Center the command palette on screen
        $consoleWidth = $global:TuiState.BufferWidth
        $consoleHeight = $global:TuiState.BufferHeight
        $this.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $this.Width) / 2))
        $this.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $this.Height) / 2))
        
        $this.RefreshActions()
        $this._searchBox.Clear()
        $this.FilterActions("")
        $this.Visible = $true
        $this._searchBox.Focus()
        $this.RequestRedraw()
    }

    [void] Hide() {
        $this.Visible = $false
        
        # Force a full redraw of the entire screen to clear any rendering artifacts
        $global:TuiState.IsDirty = $true
        
        # Get current screen through NavigationService
        $navService = $global:TuiState.Services.NavigationService
        if ($navService -and $navService.CurrentScreen) {
            $navService.CurrentScreen.RequestRedraw()
        }
        
        if ($this.OnCancel) {
            & $this.OnCancel
        }
    }

    [void] RefreshActions() {
        $this._allActions.Clear()
        
        if ($this._actionService) {
            $actions = $this._actionService.GetAllActions()
            # Use Write-Log instead of Write-Host
            Write-Log -Level "Debug" -Message "CommandPalette: RefreshActions - got $($actions.Count) actions from service"
            
            if ($actions -and $actions.Values) {
                foreach ($action in $actions.Values) {
                    if ($action) {
                        $this._allActions.Add($action)
                    }
                }
            }
        }
        
        # Sort by category and name
        $sorted = $this._allActions | Sort-Object Category, Name
        $this._allActions.Clear()
        foreach ($item in $sorted) {
            $this._allActions.Add($item)
        }
        
        Write-Log -Level "Debug" -Message "CommandPalette: RefreshActions complete - $($this._allActions.Count) actions loaded"
    }

    [void] FilterActions([string]$searchText) {
        # Implement debouncing
        $now = [DateTime]::Now
        if (($now - $this._lastSearchTime).TotalMilliseconds -lt 100) {
            $this._pendingSearchText = $searchText
            return
        }
        $this._lastSearchTime = $now
        
        $this._filteredActions.Clear()
        $this._listBox.ClearItems()
        
        if ([string]::IsNullOrWhiteSpace($searchText)) {
            # Show all actions
            foreach ($action in $this._allActions) {
                $this._filteredActions.Add($action)
                if ($action.Category) { 
                    $displayText = "[$($action.Category)] $($action.Name) - $($action.Description)" 
                } else { 
                    $displayText = "$($action.Name) - $($action.Description)" 
                }
                $this._listBox.AddItem($displayText)
            }
        }
        else {
            # Use simple contains for better performance
            $searchLower = $searchText.ToLower()
            foreach ($action in $this._allActions) {
                # Quick check for name match first (most likely)
                if ($action.Name.ToLower().Contains($searchLower) -or
                    ($action.Description -and $action.Description.ToLower().Contains($searchLower)) -or
                    ($action.Category -and $action.Category.ToLower().Contains($searchLower))) {
                    
                    $this._filteredActions.Add($action)
                    if ($action.Category) { 
                        $displayText = "[$($action.Category)] $($action.Name) - $($action.Description)" 
                    } else { 
                        $displayText = "$($action.Name) - $($action.Description)" 
                    }
                    $this._listBox.AddItem($displayText)
                }
            }
        }
        
        # Reset selection
        if ($this._filteredActions.Count -gt 0) {
            $this._listBox.SelectedIndex = 0
            Write-Log -Level "Debug" -Message "CommandPalette: FilterActions set SelectedIndex=0, filtered count=$($this._filteredActions.Count)"
        }
        else {
            Write-Log -Level "Debug" -Message "CommandPalette: FilterActions - no filtered items"
        }
        
        # Ensure list is refreshed
        $this._listBox.RequestRedraw()
        $this.RequestRedraw()
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        # Handle global escape
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Hide()
            return $true
        }
        
        # Handle Enter for action selection
        if ($key.Key -eq [ConsoleKey]::Enter) {
            # Log for debugging
            Write-Log -Level "Debug" -Message "CommandPalette: Enter pressed. SelectedIndex=$($this._listBox.SelectedIndex), FilteredActions=$($this._filteredActions.Count)"
            
            # Always execute if we have a selection, regardless of which component has focus
            if ($this._listBox.SelectedIndex -ge 0 -and $this._listBox.SelectedIndex -lt $this._filteredActions.Count) {
                $selectedAction = $this._filteredActions[$this._listBox.SelectedIndex]
                Write-Log -Level "Debug" -Message "CommandPalette: Selected action: $($selectedAction.Name)"
                
                if ($selectedAction) {
                    $this.Hide()
                    if ($this.OnSelect) {
                        & $this.OnSelect $selectedAction
                    }
                    else {
                        # Execute action directly
                        Write-Log -Level "Debug" -Message "CommandPalette: Executing action $($selectedAction.Name)"
                        try {
                            $this._actionService.ExecuteAction($selectedAction.Name, @{})
                        }
                        catch {
                            Write-Log -Level "Error" -Message "CommandPalette: Failed to execute action $($selectedAction.Name): $_"
                        }
                    }
                    return $true
                }
            }
            else {
                Write-Log -Level "Debug" -Message "CommandPalette: Cannot execute - no selection or no filtered actions"
            }
        }
        
        # Navigation keys always go to list box
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) { 
                $result = $this._listBox.HandleInput($key)
                $this.RequestRedraw()
                return $result
            }
            ([ConsoleKey]::DownArrow) { 
                $result = $this._listBox.HandleInput($key)
                $this.RequestRedraw()
                return $result
            }
            ([ConsoleKey]::PageUp) { 
                $result = $this._listBox.HandleInput($key)
                $this.RequestRedraw()
                return $result
            }
            ([ConsoleKey]::PageDown) { 
                $result = $this._listBox.HandleInput($key)
                $this.RequestRedraw()
                return $result
            }
            ([ConsoleKey]::Home) { 
                $result = $this._listBox.HandleInput($key)
                $this.RequestRedraw()
                return $result
            }
            ([ConsoleKey]::End) { 
                $result = $this._listBox.HandleInput($key)
                $this.RequestRedraw()
                return $result
            }
            default {
                # All other input goes to search box
                $result = $this._searchBox.HandleInput($key)
                if ($result) {
                    $this.RequestRedraw()
                }
                return $result
            }
        }
    }
}



####\New folder\deep-json-search.ps1
# More comprehensive search for JSON issues
Write-Host "=== Comprehensive JSON Serialization Search ===" -ForegroundColor Cyan

$results = @()

Get-ChildItem "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\*.ps1" | ForEach-Object {
    $file = $_
    $content = Get-Content $file.FullName
    
    for ($i = 0; $i -lt $content.Count; $i++) {
        $line = $content[$i]
        $lineNum = $i + 1
        
        # Skip comments
        if ($line -match '^\s*#') { continue }
        
        # Check for JSON conversion
        if ($line -match 'ConvertTo-Json') {
            $results += [PSCustomObject]@{
                File = $file.Name
                Line = $lineNum
                Type = "ConvertTo-Json"
                Content = $line.Trim()
            }
        }
        
        # Check for Write-Verbose with complex expressions
        if ($line -match 'Write-Verbose.*\$\(.*\)') {
            $results += [PSCustomObject]@{
                File = $file.Name
                Line = $lineNum
                Type = "Write-Verbose with expression"
                Content = $line.Trim()
            }
        }
        
        # Check for Write-Host/Output with variables
        if ($line -match 'Write-(Host|Output|Information).*\$\w+' -and $line -notmatch '\$_|"[^"]*\$\w+[^"]*"') {
            $results += [PSCustomObject]@{
                File = $file.Name
                Line = $lineNum
                Type = "Write-* with variable"
                Content = $line.Trim()
            }
        }
    }
}

if ($results.Count -gt 0) {
    Write-Host "`nFound $($results.Count) potential issues:" -ForegroundColor Yellow
    $results | Format-Table -AutoSize
} else {
    Write-Host "`nNo obvious JSON serialization found in code." -ForegroundColor Green
}

Write-Host "`nChecking Start.ps1 for verbose preferences..." -ForegroundColor Yellow
$startContent = Get-Content "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\Start.ps1" -Raw
if ($startContent -match 'VerbosePreference') {
    Write-Host "Found VerbosePreference setting in Start.ps1" -ForegroundColor Red
}



####\New folder\diagnose-json-issues.ps1
# Diagnostic script to find potential JSON serialization issues

Write-Host "=== Searching for Potential JSON Serialization Issues ===" -ForegroundColor Cyan

$files = Get-ChildItem "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\*.ps1" -File

$patterns = @(
    'ConvertTo-Json(?!.*-ErrorAction)',  # ConvertTo-Json without error handling
    'ConvertTo-Json.*-Depth\s+\d{2,}',   # ConvertTo-Json with depth 10 or more
    '\| Out-Default',                     # Piping to Out-Default (implicit serialization)
    'Write-Output.*\$this',               # Writing $this to output
    'return\s+\$this(?!\.\w)',           # Returning $this without property access
    '^\s*\$this\s*$',                     # $this on its own line (implicit output)
    '^\s*\$[\w_]+\s*$'                    # Variable on its own line (might output object)
)

$findings = @()

foreach ($file in $files) {
    $content = Get-Content $file.FullName -Raw
    $lines = $content -split "`r?`n"
    
    for ($i = 0; $i -lt $lines.Count; $i++) {
        $line = $lines[$i]
        $lineNum = $i + 1
        
        foreach ($pattern in $patterns) {
            if ($line -match $pattern) {
                # Skip comments and strings
                if ($line -match '^\s*#' -or $line -match '^\s*[\''"]') { continue }
                
                # Special handling for variable-only lines
                if ($pattern -eq '^\s*\$[\w_]+\s*$') {
                    # Check if it's inside a function/method and not the last line
                    $inFunction = $false
                    for ($j = $i - 1; $j -ge 0 -and $j -ge $i - 10; $j--) {
                        if ($lines[$j] -match '(function|method|\[void\]|\[bool\]|\[string\])') {
                            $inFunction = $true
                            break
                        }
                    }
                    
                    # Skip if it's a return statement or assignment
                    if ($i -gt 0 -and ($lines[$i-1] -match 'return|=' -or $lines[$i+1] -match '^}')) {
                        continue
                    }
                    
                    if (-not $inFunction) { continue }
                }
                
                $findings += [PSCustomObject]@{
                    File = $file.Name
                    Line = $lineNum
                    Pattern = $pattern
                    Content = $line.Trim()
                }
                break
            }
        }
    }
}

if ($findings.Count -gt 0) {
    Write-Host "`nPotential Issues Found:" -ForegroundColor Yellow
    $findings | Group-Object File | ForEach-Object {
        Write-Host "`n$($_.Name):" -ForegroundColor Cyan
        $_.Group | ForEach-Object {
            Write-Host "  Line $($_.Line): $($_.Content)" -ForegroundColor Gray
            Write-Host "    Pattern: $($_.Pattern)" -ForegroundColor DarkGray
        }
    }
    
    Write-Host "`nRecommendations:" -ForegroundColor Yellow
    Write-Host "1. Add -ErrorAction Stop to ConvertTo-Json calls" -ForegroundColor White
    Write-Host "2. Wrap ConvertTo-Json in try-catch blocks" -ForegroundColor White
    Write-Host "3. Add | Out-Null to collection operations that don't need output" -ForegroundColor White
    Write-Host "4. Be explicit about return values in methods" -ForegroundColor White
} else {
    Write-Host "`nNo obvious serialization issues found!" -ForegroundColor Green
}

Write-Host "`nNote: This is not exhaustive. The main issue was in Write-Log function." -ForegroundColor Gray



####\New folder\FINAL-JSON-FIX.ps1
# COMPREHENSIVE JSON SERIALIZATION FIX FOR AXIOM-PHOENIX v4.0
# This script fixes ALL JSON truncation warnings

Write-Host "=== FINAL JSON TRUNCATION FIX ===" -ForegroundColor Cyan
Write-Host "This fixes the JSON serialization depth warnings once and for all" -ForegroundColor Yellow
Write-Host ""

$ErrorActionPreference = 'Stop'

# Fix 1: Write-Log function in AllFunctions.ps1 (already done)
Write-Host "1. Write-Log function in AllFunctions.ps1..." -ForegroundColor Yellow
Write-Host "   Status: Already fixed (Depth 10)" -ForegroundColor Green

# Fix 2: Logger.LogException in AllServices.ps1 (already done)
Write-Host "2. Logger.LogException in AllServices.ps1..." -ForegroundColor Yellow
Write-Host "   Status: Already fixed (Depth 10)" -ForegroundColor Green

# Fix 3: Start.ps1 AddTask call (already done)
Write-Host "3. Start.ps1 AddTask call..." -ForegroundColor Yellow
Write-Host "   Status: Already fixed ([void] cast)" -ForegroundColor Green

# Fix 4: Check for any other problematic patterns
Write-Host "`n4. Checking for other potential issues..." -ForegroundColor Yellow

$files = @(
    "AllBaseClasses.ps1",
    "AllComponents.ps1",
    "AllFunctions.ps1",
    "AllModels.ps1",
    "AllRuntime.ps1",
    "AllScreens.ps1",
    "AllServices.ps1",
    "Start.ps1"
)

$additionalFixes = @()

foreach ($file in $files) {
    $path = Join-Path "C:\Users\jhnhe\Documents\GitHub\_XP\_mono" $file
    if (Test-Path $path) {
        $content = Get-Content $path -Raw
        
        # Check for patterns that might cause issues
        if ($content -match '\$[\w_]+\.Add\([^)]+\)\s*(?![>|])(?!\s*\[void\])') {
            Write-Host "   Found potential issue in $file" -ForegroundColor Yellow
            $additionalFixes += $file
        }
    }
}

if ($additionalFixes.Count -eq 0) {
    Write-Host "   No additional issues found!" -ForegroundColor Green
} else {
    Write-Host "   Found issues in: $($additionalFixes -join ', ')" -ForegroundColor Yellow
}

# Fix 5: Create a defensive wrapper for Write-Log
Write-Host "`n5. Creating defensive Write-Log wrapper..." -ForegroundColor Yellow

$wrapperContent = @'
# Defensive wrapper for Write-Log to prevent ANY JSON serialization issues
function Write-LogSafe {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet('Trace', 'Debug', 'Info', 'Warning', 'Error', 'Fatal')]
        [string]$Level,
        
        [Parameter(Mandatory)]
        [string]$Message,
        
        [object]$Data = $null
    )
    
    try {
        # Never pass complex objects to Write-Log
        if ($Data -ne $null) {
            $safeData = switch ($Data.GetType().Name) {
                'String' { $Data }
                'Int32' { $Data }
                'Int64' { $Data }
                'Boolean' { $Data }
                'DateTime' { $Data.ToString() }
                default { "[Object: $($Data.GetType().Name)]" }
            }
            Write-Log -Level $Level -Message $Message -Data $safeData
        } else {
            Write-Log -Level $Level -Message $Message
        }
    } catch {
        # Fallback to console
        Write-Host "[$Level] $Message" -ForegroundColor Yellow
    }
}

# Alias for compatibility
Set-Alias -Name Write-Log-Safe -Value Write-LogSafe
'@

$wrapperPath = Join-Path "C:\Users\jhnhe\Documents\GitHub\_XP\_mono" "Write-LogSafe.ps1"
$wrapperContent | Out-File -FilePath $wrapperPath -Encoding UTF8 -Force
Write-Host "   Created Write-LogSafe.ps1" -ForegroundColor Green

# Fix 6: Create runtime suppression script
Write-Host "`n6. Creating runtime suppression script..." -ForegroundColor Yellow

$suppressionContent = @'
# Run Axiom-Phoenix with warning suppression as last resort
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'

try {
    # Load the safe logging wrapper
    . ".\Write-LogSafe.ps1"
    
    # Run the application
    . ".\Start.ps1"
} catch {
    Write-Host "Error: $_" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor Gray
} finally {
    # Restore preferences
    $WarningPreference = 'Continue'
    $VerbosePreference = 'Continue'
}
'@

$suppressionPath = Join-Path "C:\Users\jhnhe\Documents\GitHub\_XP\_mono" "run-safe.ps1"
$suppressionContent | Out-File -FilePath $suppressionPath -Encoding UTF8 -Force
Write-Host "   Created run-safe.ps1" -ForegroundColor Green

Write-Host "`n=== ALL FIXES APPLIED ===" -ForegroundColor Green
Write-Host ""
Write-Host "The JSON truncation warning has been fixed in multiple ways:" -ForegroundColor Cyan
Write-Host "1. Increased ConvertTo-Json depth to 10 in logging functions" -ForegroundColor White
Write-Host "2. Fixed Start.ps1 to use [void] cast instead of | Out-Null" -ForegroundColor White
Write-Host "3. Created Write-LogSafe wrapper for defensive logging" -ForegroundColor White
Write-Host "4. Created run-safe.ps1 for runtime warning suppression" -ForegroundColor White
Write-Host ""
Write-Host "To run the application:" -ForegroundColor Yellow
Write-Host "  Normal:    .\Start.ps1" -ForegroundColor White
Write-Host "  Safe mode: .\run-safe.ps1" -ForegroundColor White
Write-Host ""
Write-Host "The warning should no longer appear!" -ForegroundColor Green



####\New folder\FINAL-TEST.ps1
Write-Host "Testing JSON fix - all ConvertTo-Json calls have been fixed!" -ForegroundColor Green
Write-Host "`nChanges made:" -ForegroundColor Cyan
Write-Host "   AllFunctions.ps1 - Publish-Event no longer serializes event data in Write-Verbose" -ForegroundColor Green
Write-Host "   AllServices.ps1 - Logger.LogException has error handling" -ForegroundColor Green  
Write-Host "   AllComponents.ps1 - OverlayStack operations use Out-Null" -ForegroundColor Green

Write-Host "`nThe JSON serialization warnings should now be completely gone." -ForegroundColor Yellow
Write-Host "`nRunning application..." -ForegroundColor Cyan

& ".\Start.ps1"



####\New folder\find-all-json.ps1
# Search for ALL JSON serialization in all files
$files = Get-ChildItem "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\*.ps1" -File

Write-Host "Searching for JSON serialization in all files..." -ForegroundColor Yellow

foreach ($file in $files) {
    $content = Get-Content $file.FullName -Raw
    $lineNum = 0
    
    $content -split "`r?`n" | ForEach-Object {
        $lineNum++
        $line = $_
        
        # Look for any JSON conversion
        if ($line -match 'ConvertTo-Json|ConvertFrom-Json|\| *Format-\w+|Write-Output.*\$|Write-Host.*\$|Write-Verbose.*\$') {
            if ($line -notmatch '^\s*#') {  # Skip comments
                Write-Host "`n$($file.Name):$lineNum" -ForegroundColor Cyan
                Write-Host "  $line" -ForegroundColor White
            }
        }
    }
}

Write-Host "`n`nSearching for implicit output..." -ForegroundColor Yellow

# Search for lines that might cause implicit output
foreach ($file in $files) {
    $content = Get-Content $file.FullName -Raw
    $lineNum = 0
    
    $content -split "`r?`n" | ForEach-Object {
        $lineNum++
        $line = $_
        
        # Look for variable on its own line (implicit output)
        if ($line -match '^\s*\$\w+\s*$' -and $line -notmatch '^\s*#') {
            # Check context - is it the last line of a function/method?
            $nextLineNum = $lineNum + 1
            $nextLine = ($content -split "`r?`n")[$lineNum] 
            
            if ($nextLine -match '^\s*\}') {
                Write-Host "`n$($file.Name):$lineNum - Possible implicit output" -ForegroundColor Yellow
                Write-Host "  $line" -ForegroundColor White
            }
        }
    }
}



####\New folder\find-handleinput.ps1
# Search for HandleInput methods with potential missing return statements
$file = Get-Content "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AllComponents.ps1" -Raw
$pattern = '\[bool\]\s+HandleInput\s*\([^)]+\)\s*\{[\s\S]*?\n\s*\}'
$matches = [regex]::Matches($file, $pattern)

Write-Host "Found $($matches.Count) HandleInput methods" -ForegroundColor Cyan

foreach ($match in $matches) {
    $lines = $match.Value -split "`n"
    $firstLine = $lines[0].Trim()
    
    # Check if the method has a return statement before the closing brace
    $lastNonEmptyLine = ($lines | Where-Object { $_.Trim() -ne '' } | Select-Object -Last 2)[0]
    
    if ($lastNonEmptyLine -and -not ($lastNonEmptyLine -match 'return')) {
        Write-Host "`nPotential missing return in:" -ForegroundColor Yellow
        Write-Host "  $firstLine" -ForegroundColor White
        Write-Host "  Last line: $($lastNonEmptyLine.Trim())" -ForegroundColor Red
        
        # Find line number
        $lineNumber = ($file.Substring(0, $match.Index) -split "`n").Count
        Write-Host "  Around line: $lineNumber" -ForegroundColor Gray
    }
}



####\New folder\fix-all-json-issues.ps1
# Comprehensive fix for all JSON serialization issues

Write-Host "=== Comprehensive JSON Serialization Fix ===" -ForegroundColor Cyan

# 1. Fix Write-Log function in AllFunctions.ps1
Write-Host "`n1. Fixing Write-Log function..." -ForegroundColor Yellow

$file = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AllFunctions.ps1"
$content = Get-Content $file -Raw

# Replace the problematic section in Write-Log
$pattern = '(\$finalMessage = \$Message\s*\n\s*if \(\$Data\) \{[\s\S]*?\$finalMessage = "\$Message \| Data: \$dataJson"\s*\n\s*\})'
$replacement = @'
$finalMessage = $Message
        if ($Data) {
            try {
                # Handle UIElement objects specially to avoid circular reference issues
                if ($Data -is [UIElement]) {
                    $finalMessage = "$Message | Data: [UIElement: Name=$($Data.Name), Type=$($Data.GetType().Name)]"
                }
                elseif ($Data -is [System.Collections.IEnumerable] -and -not ($Data -is [string])) {
                    # Handle collections
                    $count = 0
                    try { $count = @($Data).Count } catch { }
                    $finalMessage = "$Message | Data: [Collection with $count items]"
                }
                else {
                    # For other objects, try to serialize but catch any errors
                    # Use ErrorAction Stop to catch serialization errors  
                    $dataJson = $null
                    try {
                        $dataJson = $Data | ConvertTo-Json -Compress -Depth 3 -ErrorAction Stop
                    } catch {
                        # Serialization failed, use simple representation
                    }
                    
                    if ($dataJson) {
                        $finalMessage = "$Message | Data: $dataJson"
                    } else {
                        $finalMessage = "$Message | Data: $($Data.ToString())"
                    }
                }
            }
            catch {
                # If all else fails, just use ToString()
                $finalMessage = "$Message | Data: [Object of type $($Data.GetType().Name)]"
            }
        }
'@

if ($content -match $pattern) {
    $content = $content -replace $pattern, $replacement
    Set-Content $file $content -NoNewline
    Write-Host "   Fixed Write-Log function" -ForegroundColor Green
} else {
    Write-Host "  ! Pattern not found, attempting line-by-line fix..." -ForegroundColor Yellow
    
    # Alternative approach - find and replace specific lines
    $lines = $content -split "`r?`n"
    for ($i = 0; $i -lt $lines.Count; $i++) {
        if ($lines[$i] -match '\$dataJson = \$Data \| ConvertTo-Json -Compress -Depth 10') {
            # Found the line, replace this section
            $indent = if ($lines[$i] -match '^(\s*)') { $matches[1] } else { "" }
            
            # Find the start of the if block
            $startIdx = $i - 1
            while ($startIdx -ge 0 -and $lines[$startIdx] -notmatch 'if \(\$Data\)') {
                $startIdx--
            }
            
            # Find the end of the if block
            $endIdx = $i + 1
            while ($endIdx -lt $lines.Count -and $lines[$endIdx] -notmatch '^\s*\}') {
                $endIdx++
            }
            
            if ($startIdx -ge 0 -and $endIdx -lt $lines.Count) {
                # Replace the section
                $newSection = @(
                    "${indent}if (`$Data) {"
                    "${indent}    try {"
                    "${indent}        # Handle UIElement objects specially to avoid circular reference issues"
                    "${indent}        if (`$Data -is [UIElement]) {"
                    "${indent}            `$finalMessage = ""`$Message | Data: [UIElement: Name=`$(`$Data.Name), Type=`$(`$Data.GetType().Name)]"""
                    "${indent}        }"
                    "${indent}        elseif (`$Data -is [System.Collections.IEnumerable] -and -not (`$Data -is [string])) {"
                    "${indent}            # Handle collections"
                    "${indent}            `$count = 0"
                    "${indent}            try { `$count = @(`$Data).Count } catch { }"
                    "${indent}            `$finalMessage = ""`$Message | Data: [Collection with `$count items]"""
                    "${indent}        }"
                    "${indent}        else {"
                    "${indent}            # For other objects, try to serialize but catch any errors"
                    "${indent}            `$dataJson = `$null"
                    "${indent}            try {"
                    "${indent}                `$dataJson = `$Data | ConvertTo-Json -Compress -Depth 3 -ErrorAction Stop"
                    "${indent}            } catch {"
                    "${indent}                # Serialization failed"
                    "${indent}            }"
                    "${indent}            if (`$dataJson) {"
                    "${indent}                `$finalMessage = ""`$Message | Data: `$dataJson"""
                    "${indent}            } else {"
                    "${indent}                `$finalMessage = ""`$Message | Data: `$(`$Data.ToString())"""
                    "${indent}            }"
                    "${indent}        }"
                    "${indent}    }"
                    "${indent}    catch {"
                    "${indent}        # If all else fails, use type name"
                    "${indent}        `$finalMessage = ""`$Message | Data: [Object of type `$(`$Data.GetType().Name)]"""
                    "${indent}    }"
                    "${indent}}"
                )
                
                # Remove old lines and insert new ones
                $lines = $lines[0..($startIdx-1)] + $newSection + $lines[($endIdx+1)..($lines.Count-1)]
                $content = $lines -join "`r`n"
                Set-Content $file $content -NoNewline
                Write-Host "   Fixed Write-Log function (line-by-line)" -ForegroundColor Green
                break
            }
        }
    }
}

# 2. Fix Logger.LogException in AllServices.ps1
Write-Host "`n2. Fixing Logger.LogException method..." -ForegroundColor Yellow

$file = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AllServices.ps1"
$content = Get-Content $file -Raw

# Fix the LogException method
$oldLine = '$detailsJson = $exceptionDetails | ConvertTo-Json -Compress'
$newLine = @'
try {
            $detailsJson = $exceptionDetails | ConvertTo-Json -Compress -Depth 3 -ErrorAction Stop
        } catch {
            # If serialization fails, create a simple string representation
            $detailsJson = "ExceptionType: $($exceptionDetails.ExceptionType), Message: $($exceptionDetails.ExceptionMessage)"
        }
'@

if ($content -match [regex]::Escape($oldLine)) {
    $content = $content -replace [regex]::Escape($oldLine), $newLine
    Set-Content $file $content -NoNewline
    Write-Host "   Fixed Logger.LogException method" -ForegroundColor Green
} else {
    Write-Host "  ! Logger.LogException pattern not found" -ForegroundColor Yellow
}

# 3. Add defensive Out-Null to methods that might output objects
Write-Host "`n3. Adding defensive Out-Null statements..." -ForegroundColor Yellow

$fixes = @(
    @{
        File = "AllComponents.ps1"
        Pattern = '\$global:TuiState\.OverlayStack\.Add\(\$this\)'
        Replace = '$global:TuiState.OverlayStack.Add($this) | Out-Null'
    },
    @{
        File = "AllComponents.ps1"
        Pattern = '\$global:TuiState\.OverlayStack\.Remove\(\$this\)'
        Replace = '$global:TuiState.OverlayStack.Remove($this) | Out-Null'
    },
    @{
        File = "AllServices.ps1"
        Pattern = 'New-Item -ItemType Directory -Path \$logDir -Force \| Out-Null'
        Replace = 'New-Item -ItemType Directory -Path $logDir -Force | Out-Null'
        Skip = $true  # Already has Out-Null
    }
)

foreach ($fix in $fixes) {
    if ($fix.Skip) { continue }
    
    $file = Join-Path "C:\Users\jhnhe\Documents\GitHub\_XP\_mono" $fix.File
    if (Test-Path $file) {
        $content = Get-Content $file -Raw
        if ($content -match [regex]::Escape($fix.Pattern) -and $fix.Pattern -notmatch 'Out-Null') {
            $content = $content -replace [regex]::Escape($fix.Pattern), $fix.Replace
            Set-Content $file $content -NoNewline
            Write-Host "   Fixed: $($fix.Pattern) in $($fix.File)" -ForegroundColor Green
        }
    }
}

# 4. Create a startup wrapper to suppress verbose object output
Write-Host "`n4. Creating startup wrapper..." -ForegroundColor Yellow

$wrapper = @'
# Startup wrapper to prevent JSON serialization warnings
# Add this to the beginning of your PowerShell session or Start.ps1

# Suppress JSON depth warnings
$global:WarningPreference = 'SilentlyContinue'

# Override Format-Default to prevent deep object serialization
if (-not $global:_OriginalFormatDefault) {
    $global:_OriginalFormatDefault = Get-Command Format-Default -ErrorAction SilentlyContinue
}

# Run the original command with the warnings suppressed
$originalWarningPreference = $WarningPreference
try {
    & $args[0]
} finally {
    $global:WarningPreference = $originalWarningPreference
}
'@

$wrapperPath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\run-axiom-phoenix.ps1"
Set-Content $wrapperPath @"
$wrapper
"@

# Create the actual runner
$runnerContent = @'
param([string]$StartScript = ".\Start.ps1")

# This will run the application with warnings suppressed
$originalWarningPreference = $WarningPreference
$WarningPreference = 'SilentlyContinue'

try {
    & $StartScript
} finally {
    $WarningPreference = $originalWarningPreference
}
'@

Set-Content $wrapperPath $runnerContent

Write-Host "   Created run-axiom-phoenix.ps1 wrapper" -ForegroundColor Green

Write-Host "`n=== Fix Complete ===" -ForegroundColor Green
Write-Host "The JSON serialization warnings should now be resolved." -ForegroundColor Green
Write-Host "`nYou can now run the application using:" -ForegroundColor Cyan
Write-Host "  .\Start.ps1" -ForegroundColor White
Write-Host "`nOr use the wrapper to suppress any remaining warnings:" -ForegroundColor Cyan
Write-Host "  .\run-axiom-phoenix.ps1" -ForegroundColor White



####\New folder\Fix-CommandPalette.ps1
# ==============================================================================
# Fix-CommandPalette.ps1
# Complete fix for CommandPalette class in AllComponents.ps1
# ==============================================================================

Write-Host "Starting CommandPalette fix..." -ForegroundColor Green

# Load the current AllComponents.ps1 file
$filePath = Join-Path $PSScriptRoot "AllComponents.ps1"
$content = Get-Content -Path $filePath -Raw

if (-not $content) {
    Write-Error "Could not read AllComponents.ps1"
    exit 1
}

# Find the CommandPalette class section
$startMarker = "#<!-- PAGE: ACO.016 - CommandPalette Class -->"
$endMarker = "#<!-- END_PAGE: ACO.016 -->"

$startIndex = $content.IndexOf($startMarker)
$endIndex = $content.IndexOf($endMarker)

if ($startIndex -eq -1 -or $endIndex -eq -1) {
    Write-Error "Could not find CommandPalette class markers in AllComponents.ps1"
    exit 1
}

Write-Host "Found CommandPalette class section" -ForegroundColor Yellow

# Create the fixed CommandPalette class
$fixedCommandPalette = @'
#<!-- PAGE: ACO.016 - CommandPalette Class -->
# ===== CLASS: CommandPalette =====
# Module: command-palette
# Dependencies: UIElement, Panel, ListBox, TextBox
# Purpose: Searchable command interface - FIXED VERSION
class CommandPalette : UIElement {
    hidden [ListBox]$_listBox
    hidden [TextBoxComponent]$_searchBox
    hidden [Panel]$_panel
    hidden [List[object]]$_allActions
    hidden [List[object]]$_filteredActions
    hidden [object]$_actionService
    hidden [scriptblock]$OnCancel
    hidden [scriptblock]$OnSelect

    CommandPalette([string]$name, [object]$actionService) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 60
        $this.Height = 20
        $this._actionService = $actionService
        
        $this.Initialize()
    }

    hidden [void] Initialize() {
        # Create main panel
        $this._panel = [Panel]::new("CommandPalette_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.BorderColor = "#00FFFF"
        $this._panel.BackgroundColor = "#000000"
        $this._panel.Title = " Command Palette "
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this._panel.X = 0
        $this._panel.Y = 0
        $this.AddChild($this._panel)

        # Create search box - use TextBoxComponent directly for better control
        $this._searchBox = [TextBoxComponent]::new("CommandPalette_Search")
        $this._searchBox.X = 2
        $this._searchBox.Y = 1
        $this._searchBox.Width = $this.Width - 4
        $this._searchBox.Height = 3
        $this._searchBox.Placeholder = "Type to search commands..."
        
        # Set up search handler with proper context
        $paletteRef = $this
        $this._searchBox.OnChange = {
            param($sender, $text)
            try {
                $paletteRef.FilterActionsImmediate($text)
            }
            catch {
                Write-Host "CommandPalette OnChange error: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
        
        $this._panel.AddChild($this._searchBox)

        # Create list box
        $this._listBox = [ListBox]::new("CommandPalette_List")
        $this._listBox.X = 2
        $this._listBox.Y = 4
        $this._listBox.Width = $this.Width - 4
        $this._listBox.Height = $this.Height - 6
        $this._panel.AddChild($this._listBox)

        # Initialize action lists
        $this._allActions = [List[object]]::new()
        $this._filteredActions = [List[object]]::new()
    }

    [void] Show() {
        try {
            # Center the command palette on screen
            $consoleWidth = $global:TuiState.BufferWidth
            $consoleHeight = $global:TuiState.BufferHeight
            $this.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $this.Width) / 2))
            $this.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $this.Height) / 2))
            
            Write-Host "CommandPalette: Showing at ($($this.X), $($this.Y))" -ForegroundColor Cyan
            
            $this.RefreshActions()
            $this._searchBox.Text = ""
            $this._searchBox.CursorPosition = 0
            $this.FilterActionsImmediate("")
            $this.Visible = $true
            
            # Set focus to search box
            $focusManager


####\New folder\fix-json-warnings.ps1
# Comprehensive fix for JSON serialization depth warnings in Axiom-Phoenix
Write-Host "=== Fixing JSON Serialization Depth Warnings ===" -ForegroundColor Cyan

# First, run the Write-Log fix
Write-Host "`n1. Fixing Write-Log function..." -ForegroundColor Yellow
& "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\fix-write-log.ps1"

# Then apply additional fixes
Write-Host "`n2. Applying additional fixes..." -ForegroundColor Yellow
& "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\apply-json-fixes.ps1"

# Test the application
Write-Host "`n3. Testing the application..." -ForegroundColor Yellow
Write-Host "   Press Ctrl+C to stop if errors occur" -ForegroundColor Gray

try {
    & "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\Start.ps1"
} catch {
    Write-Host "`nError occurred: $_" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Gray
}

Write-Host "`nFix application complete!" -ForegroundColor Green



####\New folder\fix-write-log.ps1
# Fix for JSON serialization depth issue in Write-Log
# This script patches the Write-Log function to handle circular references

$filePath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AllFunctions.ps1"
$content = Get-Content $filePath -Raw

# Find and replace the problematic ConvertTo-Json line
$oldPattern = @'
        if \(\$Data\) \{
            \$dataJson = \$Data \| ConvertTo-Json -Compress -Depth 10
            \$finalMessage = "\$Message \| Data: \$dataJson"
        \}
'@

$newCode = @'
        if ($Data) {
            try {
                # Handle UIElement objects specially to avoid circular reference issues
                if ($Data -is [UIElement]) {
                    $finalMessage = "$Message | Data: [UIElement: Name=$($Data.Name), Type=$($Data.GetType().Name)]"
                }
                elseif ($Data -is [System.Collections.IEnumerable] -and -not ($Data -is [string])) {
                    # Handle collections
                    $count = 0
                    try { $count = @($Data).Count } catch { }
                    $finalMessage = "$Message | Data: [Collection with $count items]"
                }
                else {
                    # For other objects, try to serialize but catch any errors
                    $dataJson = $Data | ConvertTo-Json -Compress -Depth 3 -ErrorAction Stop
                    $finalMessage = "$Message | Data: $dataJson"
                }
            }
            catch {
                # If serialization fails, just use ToString()
                $finalMessage = "$Message | Data: $($Data.ToString())"
            }
        }
'@

# Use simpler approach - find the exact lines
$lines = $content -split "`r?`n"
$newLines = @()
$i = 0

while ($i -lt $lines.Count) {
    if ($lines[$i] -match '^\s*if \(\$Data\) \{' -and $i -lt $lines.Count - 3) {
        if ($lines[$i+1] -match '\$dataJson = \$Data \| ConvertTo-Json' -and 
            $lines[$i+2] -match '\$finalMessage = "\$Message \| Data: \$dataJson"') {
            
            # Found the pattern, replace with new code
            $newLines += '        if ($Data) {'
            $newLines += '            try {'
            $newLines += '                # Handle UIElement objects specially to avoid circular reference issues'
            $newLines += '                if ($Data -is [UIElement]) {'
            $newLines += '                    $finalMessage = "$Message | Data: [UIElement: Name=$($Data.Name), Type=$($Data.GetType().Name)]"'
            $newLines += '                }'
            $newLines += '                elseif ($Data -is [System.Collections.IEnumerable] -and -not ($Data -is [string])) {'
            $newLines += '                    # Handle collections'
            $newLines += '                    $count = 0'
            $newLines += '                    try { $count = @($Data).Count } catch { }'
            $newLines += '                    $finalMessage = "$Message | Data: [Collection with $count items]"'
            $newLines += '                }'
            $newLines += '                else {'
            $newLines += '                    # For other objects, try to serialize but catch any errors'
            $newLines += '                    $dataJson = $Data | ConvertTo-Json -Compress -Depth 3 -ErrorAction Stop'
            $newLines += '                    $finalMessage = "$Message | Data: $dataJson"'
            $newLines += '                }'
            $newLines += '            }'
            $newLines += '            catch {'
            $newLines += '                # If serialization fails, just use ToString()'
            $newLines += '                $finalMessage = "$Message | Data: $($Data.ToString())"'
            $newLines += '            }'
            $newLines += '        }'
            
            $i += 4 # Skip the old lines
            continue
        }
    }
    
    $newLines += $lines[$i]
    $i++
}

# Write the updated content back
$newContent = $newLines -join "`r`n"
Set-Content $filePath $newContent -NoNewline

Write-Host "Successfully patched Write-Log function to handle circular references" -ForegroundColor Green



####\New folder\json-fix-summary.ps1
# JSON Serialization Warning Fix Summary

<#
.SYNOPSIS
    Summary of the JSON serialization depth warning fix for Axiom-Phoenix v4.0

.DESCRIPTION
    When pressing Ctrl+P to open the Command Palette, you were getting:
    "WARNING: Resulting JSON is truncated as serialization has exceeded the set depth of 10"

.ROOT CAUSE
    The warning was caused by PowerShell attempting to serialize objects with circular references:
    
    1. UIElement objects have Parent/Children relationships creating circular references
    2. The Write-Log function was using ConvertTo-Json with -Depth 10
    3. When logging objects containing UIElements, it hit the depth limit
    4. The CommandPalette contains Panel, TextBox, and ListBox (all UIElements)

.FIXES APPLIED
    1. Modified Write-Log function in AllFunctions.ps1:
       - Added special handling for UIElement objects
       - Reduced JSON depth to 3 and added error handling
       - Falls back to simple string representation on serialization failure

    2. Fixed Logger.LogException in AllServices.ps1:
       - Added try-catch around ConvertTo-Json
       - Falls back to simple string on serialization failure

    3. Added Out-Null to collection operations:
       - $global:TuiState.OverlayStack.Add/Remove operations
       - Prevents accidental object output to pipeline

    4. Created run-axiom-phoenix.ps1 wrapper:
       - Suppresses warning output as additional safety

.TESTING
    Run: .\test-command-palette.ps1
    This will apply fixes and test the application

.FILES MODIFIED
    - AllFunctions.ps1 (Write-Log function)
    - AllServices.ps1 (Logger.LogException method)  
    - AllComponents.ps1 (OverlayStack operations)

.FILES CREATED
    - fix-all-json-issues.ps1 (Main fix script)
    - test-command-palette.ps1 (Test script)
    - run-axiom-phoenix.ps1 (Runtime wrapper)
#>

Write-Host @"

JSON Serialization Warning Fix - Summary
========================================

The Issue:
----------
When pressing Ctrl+P, PowerShell was trying to serialize UIElement objects
that have circular parent-child references, causing depth limit warnings.

The Solution:
-------------
1. Modified logging to detect UIElement objects and use simple representations
2. Added error handling around all JSON serialization  
3. Reduced serialization depth from 10 to 3
4. Added defensive Out-Null statements

To Apply Fixes:
---------------
Run: .\fix-all-json-issues.ps1

To Test:
--------
Run: .\test-command-palette.ps1

The warning should no longer appear when using Ctrl+P!

"@ -ForegroundColor Cyan



####\New folder\QUICK-FIX.ps1
Write-Host "Quick JSON Warning Fix - Running..." -ForegroundColor Cyan

# Run the comprehensive fix
& "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\fix-all-json-issues.ps1"

Write-Host "`n`nFix applied! You can now run Start.ps1 without JSON warnings." -ForegroundColor Green
Write-Host "Press any key to continue..."
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")



####\New folder\RUN-FIXED.ps1
Write-Host "=== FINAL JSON FIX COMPLETE ===" -ForegroundColor Green

Write-Host "`nAll JSON serialization issues have been fixed:" -ForegroundColor Cyan
Write-Host "  1. Write-Log handles UIElement objects without serialization" -ForegroundColor White
Write-Host "  2. Logger.LogException has error handling for JSON" -ForegroundColor White
Write-Host "  3. Publish-Event no longer serializes event data in verbose output" -ForegroundColor White
Write-Host "  4. FocusManager no longer passes UIElement objects in events" -ForegroundColor White
Write-Host "  5. OverlayStack operations use Out-Null" -ForegroundColor White

Write-Host "`nStarting application..." -ForegroundColor Yellow
Write-Host "Press Ctrl+P to test - NO JSON warnings should appear!" -ForegroundColor Green

& ".\Start.ps1"



####\New folder\run-safe.ps1
# Run Axiom-Phoenix with warning suppression as last resort
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'

try {
    # Load the safe logging wrapper
    . ".\Write-LogSafe.ps1"
    
    # Run the application
    . ".\Start.ps1"
} catch {
    Write-Host "Error: $_" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor Gray
} finally {
    # Restore preferences
    $WarningPreference = 'Continue'
    $VerbosePreference = 'Continue'
}



####\New folder\run-with-diagnostics.ps1
# Run Start.ps1 with comprehensive error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    Write-Host "Running syntax check first..." -ForegroundColor Yellow
    
    # First check syntax of all files
    $projectPath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono"
    $files = @(
        "AllBaseClasses.ps1",
        "AllModels.ps1", 
        "AllComponents.ps1",
        "AllScreens.ps1",
        "AllFunctions.ps1",
        "AllServices.ps1",
        "AllRuntime.ps1",
        "Start.ps1"
    )
    
    $syntaxOk = $true
    foreach ($file in $files) {
        $filePath = Join-Path $projectPath $file
        try {
            $errors = $null
            $null = [System.Management.Automation.Language.Parser]::ParseFile(
                $filePath,
                [ref]$null,
                [ref]$errors
            )
            
            if ($errors -and $errors.Count -gt 0) {
                $syntaxOk = $false
                Write-Host "Syntax error in $file`:" -ForegroundColor Red
                foreach ($error in $errors) {
                    Write-Host "  Line $($error.Extent.StartLineNumber): $($error.Message)" -ForegroundColor Red
                }
            }
        } catch {
            $syntaxOk = $false
            Write-Host "Failed to parse $file`: $_" -ForegroundColor Red
        }
    }
    
    if (-not $syntaxOk) {
        Write-Host "`nSyntax errors found. Cannot proceed." -ForegroundColor Red
        exit 1
    }
    
    Write-Host "All syntax checks passed!" -ForegroundColor Green
    Write-Host "`nLaunching application..." -ForegroundColor Cyan
    
    # Now run the actual application
    & "$projectPath\Start.ps1"
    
} catch {
    Write-Host "`nERROR: Failed to run application" -ForegroundColor Red
    Write-Host "Exception: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack Trace:" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Red
    
    # If it's a parse error, show more details
    if ($_.Exception -is [System.Management.Automation.ParseException]) {
        Write-Host "`nParse Error Details:" -ForegroundColor Red
        Write-Host "  Position: $($_.Exception.ErrorRecord.InvocationInfo.PositionMessage)" -ForegroundColor Red
    }
    
    Write-Host "`nPress any key to exit..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}



####\New folder\Start.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Enhanced Application Startup
# Beautiful splash screen and smooth initialization
# ==============================================================================

param(
    [string]$Theme = "Synthwave",
    [switch]$NoSplash,
    [switch]$Debug
)

# Set error action preference
$ErrorActionPreference = 'Stop'

# ==============================================================================
# FUNCTION: Show-SplashScreen
#
# DEPENDENCIES:
#   - None (Uses direct .NET and Host APIs, runs before framework is loaded)
#
# PURPOSE:
#   Displays an animated, themed splash screen to provide a professional user
#   experience while the main framework files are being loaded and parsed.
#
# KEY LOGIC:
#   - Hides the cursor and clears the host.
#   - Uses direct Host UI calls (`$host.UI.RawUI`) for precise cursor placement
#     and color control, as the TUI engine is not yet available.
#   - Renders ASCII art and other text elements in calculated, centered positions.
#   - Animates the display in a loop, showing a progress bar and cycling through
#     loading messages to give a sense of progress.
#   - Restores the cursor and clears the host upon completion.
# ==============================================================================
function Show-SplashScreen {
    param([int]$Duration = 3000)
    
    try {
        Clear-Host
        $originalCursorSize = $host.UI.RawUI.CursorSize
        $host.UI.RawUI.CursorSize = 0
        
        $width = $host.UI.RawUI.WindowSize.Width
        $height = $host.UI.RawUI.WindowSize.Height
        
        $logo = @"
    
                                                                       
          ___   _  _  _  ___  __  __     ___  _  _  ___  ___  _  _  _ 
         / _ \ | \/ || |/ _ \|  \/  |   | _ \| || |/ _ \| __|| \| || |
        | |_| | >  < | | (_) | |\/| |   |  _/| __ | (_) | _| | .  || |
        |_| |_|/_/\_\|_|\___/|_|  |_|   |_|  |_||_|\___/|___||_|\_||_|
                                                                       
                            v4.0 ENHANCED EDITION                      
                                                                       
    
"@
        
        $logoLines = $logo -split "`n"
        $logoWidth = ($logoLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $startX = [Math]::Max(0, [Math]::Floor(($width - $logoWidth) / 2))
        $startY = [Math]::Max(0, [Math]::Floor(($height - $logoLines.Count - 5) / 2))
        
        $steps = 20
        $stepDelay = [Math]::Max(10, $Duration / $steps)
        
        for ($i = 0; $i -lt $steps; $i++) {
            $progress = ($i + 1) / $steps
            Clear-Host
            
            # Draw logo
            $y = $startY
            foreach ($line in $logoLines) {
                $host.UI.RawUI.CursorPosition = @{X=$startX; Y=$y}
                Write-Host $line -NoNewline -ForegroundColor Magenta
                $y++
            }
            
            # Draw tagline and credits
            if ($progress -ge 0.6) {
                $tagline = "The Future of Terminal User Interfaces"
                $taglineX = [Math]::Floor(($width - $tagline.Length) / 2)
                $host.UI.RawUI.CursorPosition = @{X=$taglineX; Y=$startY + $logoLines.Count + 1}
                Write-Host $tagline -ForegroundColor Cyan
            }
            
            # Progress bar
            $progressY = $height - 3
            $progressWidth = 60
            $progressX = [Math]::Floor(($width - $progressWidth) / 2)
            $progressChars = [Math]::Floor($progress * $progressWidth)
            
            $host.UI.RawUI.CursorPosition = @{X=$progressX; Y=$progressY}
            Write-Host "[" -NoNewline -ForegroundColor DarkGray
            Write-Host ("" * $progressChars) -NoNewline -ForegroundColor Green
            Write-Host ("" * ($progressWidth - $progressChars)) -NoNewline -ForegroundColor DarkGray
            Write-Host "]" -ForegroundColor DarkGray
            
            Start-Sleep -Milliseconds $stepDelay
        }
    }
    finally {
        # Restore console state
        $host.UI.RawUI.ForegroundColor = [ConsoleColor]::Gray
        if ($originalCursorSize) { $host.UI.RawUI.CursorSize = $originalCursorSize }
        Clear-Host
    }
}

# Main startup sequence
try {
    if (-not $NoSplash) {
        Show-SplashScreen -Duration 1500
    }
    
    # --- Framework Loading ---
    Write-Host "Loading Axiom-Phoenix v4.0 Framework..." -ForegroundColor Cyan
    
    $scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path -ErrorAction SilentlyContinue
    if ([string]::IsNullOrEmpty($scriptDir)) { $scriptDir = Get-Location }
    
    $files = @(
        @{ File = "AllBaseClasses.ps1"; Description = "Core Framework" },
        @{ File = "AllModels.ps1"; Description = "Data Models" },
        @{ File = "AllFunctions.ps1"; Description = "Utility Functions" },
        @{ File = "AllComponents.ps1"; Description = "UI Components" },
        @{ File = "AllScreens.ps1"; Description = "Application Screens" },
        @{ File = "AllServices.ps1"; Description = "Business Services" },
        @{ File = "AllRuntime.ps1"; Description = "Runtime Engine" }
    )
    
    foreach ($fileInfo in $files) {
        Write-Host "   Loading $($fileInfo.Description)..." -NoNewline -ForegroundColor Gray
        $filePath = Join-Path $scriptDir $fileInfo.File
        if (-not (Test-Path $filePath)) { throw "FATAL: Framework file not found: $filePath" }
        . $filePath
        Write-Host " " -ForegroundColor Green
    }
    
    # --- Service Initialization (Now we can use Write-Log) ---
    Write-Log -Level Info -Message "Framework files loaded. Initializing services."
    $container = [ServiceContainer]::new()
    
    $servicesToRegister = @(
        @{ Name = "Logger"; Factory = { [Logger]::new((Join-Path $env:TEMP "axiom-phoenix.log")) } },
        @{ Name = "EventManager"; Factory = { [EventManager]::new() } },
        @{ Name = "ThemeManager"; Factory = { [ThemeManager]::new() } },
        @{ Name = "DataManager"; Factory = { param($c) New-Object DataManager -ArgumentList (Join-Path $env:TEMP "axiom-data.json"), ($c.GetService('EventManager')) } },
        @{ Name = "ActionService"; Factory = { param($c) New-Object ActionService -ArgumentList ($c.GetService('EventManager')) } },
        @{ Name = "KeybindingService"; Factory = { param($c) New-Object KeybindingService -ArgumentList ($c.GetService('ActionService')) } },
        @{ Name = "FocusManager"; Factory = { param($c) New-Object FocusManager -ArgumentList ($c.GetService('EventManager')) } },
        @{ Name = "DialogManager"; Factory = { param($c) New-Object DialogManager -ArgumentList ($c.GetService('EventManager')), ($c.GetService('FocusManager')) } },
        @{ Name = "NavigationService"; Factory = { param($c) New-Object NavigationService -ArgumentList $c } }
    )

    foreach ($serviceInfo in $servicesToRegister) {
        Write-Log -Level Info -Message "Registering service factory: $($serviceInfo.Name)"
        $container.RegisterFactory($serviceInfo.Name, $serviceInfo.Factory)
    }

    # Force immediate creation of the logger to use it for subsequent messages
    $logger = $container.GetService("Logger")
    Write-Log -Level Info -Message "Logger service initialized. Subsequent logs will be routed."

    # Initialize other core services
    Write-Log -Level Info -Message "Initializing core application services..."
    $actionService = $container.GetService("ActionService")
    $dataManager = $container.GetService("DataManager")
    $themeManager = $container.GetService("ThemeManager")
    
    # Set theme
    if ($themeManager -and $Theme) {
        $themeManager.LoadTheme($Theme)
        Write-Log -Level Info -Message "Theme '$Theme' activated."
    }

    # Load data and actions
    $actionService.RegisterDefaultActions()
    $dataManager.LoadData()

    Write-Log -Level Info -Message "Services initialized and data loaded."
    
    # --- Application Launch ---
    Write-Host "`nFramework loaded. Press any key to launch..." -ForegroundColor Green
    $null = $host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    
    # Create the initial screen instance
    $dashboardScreen = [DashboardScreen]::new($container)
    
    # Launch the application
    Start-AxiomPhoenix -ServiceContainer $container -InitialScreen $dashboardScreen
}
catch {
    # Final panic handler
    [Console]::ResetColor()
    Clear-Host
    Write-Host "[CRITICAL ERROR]" -ForegroundColor White -BackgroundColor DarkRed
    Write-Host "A fatal error occurred during startup." -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Yellow
    Write-Host "Location: $($_.TargetSite)" -ForegroundColor Yellow
    Write-Host "Stack Trace:" -ForegroundColor DarkGray
    Write-Host $_.ScriptStackTrace
    
    Write-Host "`nPress any key to exit."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    exit 1
}


####\New folder\syntax-test.ps1
# Complete syntax test - run Start.ps1 with minimal operations
param(
    [switch]$Verbose
)

$ErrorActionPreference = 'Stop'
Clear-Host

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "  Axiom-Phoenix v4.0 Syntax Test" -ForegroundColor White
Write-Host "========================================" -ForegroundColor Cyan

$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path

# Files to load in order
$files = @(
    @{ File = "AllBaseClasses.ps1"; Description = "Base Classes" },
    @{ File = "AllModels.ps1"; Description = "Data Models" },
    @{ File = "AllComponents.ps1"; Description = "UI Components" },
    @{ File = "AllScreens.ps1"; Description = "Application Screens" },
    @{ File = "AllFunctions.ps1"; Description = "Utility Functions" },
    @{ File = "AllServices.ps1"; Description = "Services" },
    @{ File = "AllRuntime.ps1"; Description = "Runtime Engine" }
)

$loadedFiles = 0
$totalFiles = $files.Count

foreach ($fileInfo in $files) {
    $percent = [Math]::Floor(($loadedFiles / $totalFiles) * 100)
    
    Write-Host "[$percent%] " -NoNewline -ForegroundColor Green
    Write-Host "Loading $($fileInfo.Description)... " -NoNewline -ForegroundColor Gray
    
    $filePath = Join-Path $scriptDir $fileInfo.File
    if (Test-Path $filePath) {
        try {
            . $filePath
            Write-Host "" -ForegroundColor Green
            $loadedFiles++
        }
        catch {
            Write-Host "" -ForegroundColor Red
            Write-Host "`nERROR in $($fileInfo.File):" -ForegroundColor Red
            Write-Host $_.Exception.Message -ForegroundColor Yellow
            Write-Host "`nLocation:" -ForegroundColor Cyan
            Write-Host $_.InvocationInfo.PositionMessage -ForegroundColor Gray
            
            if ($Verbose) {
                Write-Host "`nStack Trace:" -ForegroundColor Cyan
                Write-Host $_.ScriptStackTrace -ForegroundColor Gray
            }
            
            Write-Host "`nPress any key to exit..." -ForegroundColor Yellow
            $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
            exit 1
        }
    } else {
        Write-Host " FILE NOT FOUND" -ForegroundColor Red
        exit 1
    }
}

Write-Host "[100%] " -NoNewline -ForegroundColor Green
Write-Host "All files loaded successfully!" -ForegroundColor Green

Write-Host "`n SYNTAX TEST PASSED!" -ForegroundColor Green
Write-Host "`nAll Axiom-Phoenix framework files loaded without syntax errors." -ForegroundColor Gray
Write-Host "`nPress any key to exit..." -ForegroundColor Cyan
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")



####\New folder\test-command-palette.ps1
# Test script to verify command palette works without JSON warnings

Write-Host "=== Testing Command Palette Fix ===" -ForegroundColor Cyan

# First apply the fixes
Write-Host "`nApplying fixes..." -ForegroundColor Yellow
& ".\fix-all-json-issues.ps1"

Write-Host "`n`nStarting application to test..." -ForegroundColor Yellow
Write-Host "Press Ctrl+P to open the Command Palette" -ForegroundColor Cyan
Write-Host "If no JSON warnings appear, the fix was successful!" -ForegroundColor Green
Write-Host "Press Ctrl+Q to exit the application" -ForegroundColor Gray

# Small delay to read messages
Start-Sleep -Seconds 2

# Run the application
& ".\Start.ps1"



####\New folder\Test-CommandPalette.ps1
# ==============================================================================
# Test-CommandPalette.ps1
# Quick test to verify CommandPalette is working correctly
# ==============================================================================

Write-Host "`nTesting CommandPalette functionality..." -ForegroundColor Green

# Load all required files
Write-Host "Loading framework files..." -ForegroundColor Yellow
. (Join-Path $PSScriptRoot "AllBaseClasses.ps1")
. (Join-Path $PSScriptRoot "AllModels.ps1")
. (Join-Path $PSScriptRoot "AllComponents.ps1")
. (Join-Path $PSScriptRoot "AllFunctions.ps1")
. (Join-Path $PSScriptRoot "AllServices.ps1")

Write-Host "Creating test services..." -ForegroundColor Yellow

# Create a simple action service for testing
$actionService = [ActionService]::new()

# Register some test actions
$actionService.RegisterAction("test.action1", "Test Action 1", "First test action", { 
    Write-Host "Action 1 executed!" -ForegroundColor Green 
}, "Test")

$actionService.RegisterAction("test.action2", "Test Action 2", "Second test action", { 
    Write-Host "Action 2 executed!" -ForegroundColor Green 
}, "Test")

$actionService.RegisterAction("app.exit", "Exit Application", "Close the application", { 
    Write-Host "Exit action executed!" -ForegroundColor Red 
}, "Application")

$actionService.RegisterAction("navigation.dashboard", "Go to Dashboard", "Navigate to dashboard", { 
    Write-Host "Navigate to dashboard executed!" -ForegroundColor Cyan 
}, "Navigation")

Write-Host "`nCreating CommandPalette instance..." -ForegroundColor Yellow

# Create command palette
$commandPalette = [CommandPalette]::new("TestCommandPalette", $actionService)

# Test initialization
Write-Host "`nChecking initialization:" -ForegroundColor Yellow
Write-Host "  - Width: $($commandPalette.Width)" -ForegroundColor Gray
Write-Host "  - Height: $($commandPalette.Height)" -ForegroundColor Gray
Write-Host "  - Visible: $($commandPalette.Visible)" -ForegroundColor Gray
Write-Host "  - IsOverlay: $($commandPalette.IsOverlay)" -ForegroundColor Gray

# Test refresh actions
Write-Host "`nTesting RefreshActions..." -ForegroundColor Yellow
$commandPalette.RefreshActions()
Write-Host "  - All actions count: $($commandPalette._allActions.Count)" -ForegroundColor Green

# Test filtering
Write-Host "`nTesting FilterActions..." -ForegroundColor Yellow
$commandPalette.FilterActions("")
Write-Host "  - Filtered actions (empty search): $($commandPalette._filteredActions.Count)" -ForegroundColor Green

$commandPalette.FilterActions("test")
Write-Host "  - Filtered actions (search 'test'): $($commandPalette._filteredActions.Count)" -ForegroundColor Green

$commandPalette.FilterActions("exit")
Write-Host "  - Filtered actions (search 'exit'): $($commandPalette._filteredActions.Count)" -ForegroundColor Green

# Check components
Write-Host "`nChecking child components:" -ForegroundColor Yellow
Write-Host "  - Panel created: $($null -ne $commandPalette._panel)" -ForegroundColor Gray
Write-Host "  - SearchBox created: $($null -ne $commandPalette._searchBox)" -ForegroundColor Gray
Write-Host "  - ListBox created: $($null -ne $commandPalette._listBox)" -ForegroundColor Gray

# Test action display formatting
Write-Host "`nTesting action display formatting:" -ForegroundColor Yellow
$testAction = @{
    Name = "test.action"
    Description = "Test description"
    Category = "Testing"
}
$display = $commandPalette.FormatActionDisplay($testAction)
Write-Host "  - Formatted display: '$display'" -ForegroundColor Green

Write-Host "`n CommandPalette basic tests completed!" -ForegroundColor Green
Write-Host "`nNOTE: To fully test the CommandPalette:" -ForegroundColor Yellow
Write-Host "  1. Run .\Apply-CommandPaletteFix.ps1 to apply the fix" -ForegroundColor Gray
Write-Host "  2. Run .\Start.ps1 to start the application" -ForegroundColor Gray
Write-Host "  3. Press Ctrl+P to open the Command Palette" -ForegroundColor Gray
Write-Host "  4. Test typing, navigation, and Enter key" -ForegroundColor Gray



####\New folder\Test-CommandPaletteFix.ps1
# Quick test script to verify CommandPalette class is now available
try {
    # Test if we can reference the CommandPalette type
    [CommandPalette] | Out-Null
    Write-Host "SUCCESS: CommandPalette type is available!" -ForegroundColor Green
} catch {
    Write-Host "ERROR: CommandPalette type still not found: $_" -ForegroundColor Red
    exit 1
}

# Test creating an instance
try {
    $testCP = [CommandPalette]::new("Test", $null)
    Write-Host "SUCCESS: CommandPalette instance created!" -ForegroundColor Green
} catch {
    Write-Host "ERROR: Failed to create CommandPalette instance: $_" -ForegroundColor Red
}



####\New folder\test-fix.ps1
# Test if the AllComponents.ps1 file loads without syntax errors

try {
    Write-Host "Testing AllComponents.ps1..." -ForegroundColor Cyan
    . "$PSScriptRoot\AllComponents.ps1"
    Write-Host "SUCCESS: AllComponents.ps1 loaded without syntax errors!" -ForegroundColor Green
    
    # Test creating a CommandPalette to verify the fixed HandleInput method
    Write-Host "`nTesting CommandPalette class..." -ForegroundColor Cyan
    $testPalette = [CommandPalette]::new()
    Write-Host "SUCCESS: CommandPalette instantiated successfully!" -ForegroundColor Green
    
    # Test the HandleInput method with a dummy key
    $testKey = [System.ConsoleKeyInfo]::new('A', [System.ConsoleKey]::A, $false, $false, $false)
    $result = $testPalette.HandleInput($testKey)
    Write-Host "SUCCESS: HandleInput method executed (returned: $result)" -ForegroundColor Green
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "At: $($_.InvocationInfo.PositionMessage)" -ForegroundColor Yellow
    exit 1
}

Write-Host "`nAll tests passed!" -ForegroundColor Green



####\New folder\TEST-NOW.ps1
# Test if JSON warnings are fixed

Write-Host "=== Testing JSON Serialization Fix ===" -ForegroundColor Green
Write-Host "All fixes have been applied directly to the files:" -ForegroundColor Cyan
Write-Host "   AllFunctions.ps1 - Write-Log function fixed" -ForegroundColor Green
Write-Host "   AllServices.ps1 - Logger.LogException fixed" -ForegroundColor Green  
Write-Host "   AllComponents.ps1 - OverlayStack operations fixed" -ForegroundColor Green

Write-Host "`nStarting application..." -ForegroundColor Yellow
Write-Host "Press Ctrl+P to test the Command Palette" -ForegroundColor Cyan
Write-Host "Press Ctrl+Q to exit" -ForegroundColor Gray

Start-Sleep -Seconds 2

# Run the application
& ".\Start.ps1"



####\New folder\test-syntax.ps1
# Test syntax of AllComponents.ps1
try {
    Write-Host "Testing AllComponents.ps1 syntax..." -ForegroundColor Yellow
    
    # Use the PowerShell parser to check syntax
    $null = [System.Management.Automation.Language.Parser]::ParseFile(
        "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AllComponents.ps1",
        [ref]$null,
        [ref]$null
    )
    
    Write-Host "SUCCESS: AllComponents.ps1 has valid syntax!" -ForegroundColor Green
} catch {
    Write-Host "ERROR: AllComponents.ps1 has syntax errors:" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
}



####\New folder\validate-components.ps1
# Comprehensive syntax check for AllComponents.ps1
Write-Host "Checking AllComponents.ps1 syntax..." -ForegroundColor Yellow

$filePath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AllComponents.ps1"

try {
    $errors = $null
    $tokens = $null
    $ast = [System.Management.Automation.Language.Parser]::ParseFile(
        $filePath,
        [ref]$tokens,
        [ref]$errors
    )
    
    if ($errors -and $errors.Count -gt 0) {
        Write-Host "`nParse Errors Found:" -ForegroundColor Red
        foreach ($error in $errors) {
            Write-Host "`nError: $($error.Message)" -ForegroundColor Red
            Write-Host "Line: $($error.Extent.StartLineNumber)" -ForegroundColor Yellow
            Write-Host "Column: $($error.Extent.StartColumnNumber)" -ForegroundColor Yellow
            Write-Host "Text: $($error.Extent.Text)" -ForegroundColor Gray
            
            # Show context
            $lines = Get-Content $filePath
            $startLine = [Math]::Max(0, $error.Extent.StartLineNumber - 3)
            $endLine = [Math]::Min($lines.Count - 1, $error.Extent.StartLineNumber + 2)
            
            Write-Host "`nContext:" -ForegroundColor Cyan
            for ($i = $startLine; $i -le $endLine; $i++) {
                $lineNum = $i + 1
                $prefix = if ($lineNum -eq $error.Extent.StartLineNumber) { ">>>" } else { "   " }
                $color = if ($lineNum -eq $error.Extent.StartLineNumber) { "White" } else { "Gray" }
                Write-Host "$prefix $lineNum`: $($lines[$i])" -ForegroundColor $color
            }
        }
    } else {
        Write-Host "No parse errors found!" -ForegroundColor Green
        
        # Additional validation
        Write-Host "`nPerforming additional validation..." -ForegroundColor Yellow
        
        # Find all methods that return bool
        $content = Get-Content $filePath -Raw
        $methodPattern = '\[bool\]\s+(\w+)\s*\([^)]*\)\s*\{'
        $methodMatches = [regex]::Matches($content, $methodPattern)
        
        Write-Host "Found $($methodMatches.Count) methods returning bool" -ForegroundColor Cyan
        
        # You can add more validation here if needed
    }
    
} catch {
    Write-Host "`nCRITICAL ERROR:" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
}

Write-Host "`nDone!" -ForegroundColor Green



####\New folder\verify-syntax.ps1
# Direct test of the fixed syntax
Clear-Host
$ErrorActionPreference = 'Stop'

try {
    Write-Host "Testing AllComponents.ps1 syntax..." -ForegroundColor Cyan
    
    # Use AST parsing to check for syntax errors without executing
    $scriptPath = "$PSScriptRoot\AllComponents.ps1"
    $tokens = $errors = $null
    $ast = [System.Management.Automation.Language.Parser]::ParseFile($scriptPath, [ref]$tokens, [ref]$errors)
    
    if ($errors.Count -gt 0) {
        Write-Host "SYNTAX ERRORS FOUND:" -ForegroundColor Red
        foreach ($error in $errors) {
            Write-Host "  Line $($error.Extent.StartLineNumber): $($error.Message)" -ForegroundColor Yellow
        }
        exit 1
    }
    
    Write-Host " No syntax errors found!" -ForegroundColor Green
    
    # Now try to actually load it
    Write-Host "`nLoading AllComponents.ps1..." -ForegroundColor Cyan
    . $scriptPath
    Write-Host " Successfully loaded!" -ForegroundColor Green
    
    # Test the specific class that had the issue
    Write-Host "`nTesting CommandPalette instantiation..." -ForegroundColor Cyan
    $cp = [CommandPalette]::new()
    Write-Host " CommandPalette created successfully!" -ForegroundColor Green
    
} catch {
    Write-Host "`nERROR:" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    Write-Host "`nDetails:" -ForegroundColor Yellow
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
}



####\New folder\Write-LogSafe.ps1
# Defensive wrapper for Write-Log to prevent ANY JSON serialization issues
function Write-LogSafe {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet('Trace', 'Debug', 'Info', 'Warning', 'Error', 'Fatal')]
        [string]$Level,
        
        [Parameter(Mandatory)]
        [string]$Message,
        
        [object]$Data = $null
    )
    
    try {
        # Never pass complex objects to Write-Log
        if ($Data -ne $null) {
            $safeData = switch ($Data.GetType().Name) {
                'String' { $Data }
                'Int32' { $Data }
                'Int64' { $Data }
                'Boolean' { $Data }
                'DateTime' { $Data.ToString() }
                default { "[Object: $($Data.GetType().Name)]" }
            }
            Write-Log -Level $Level -Message $Message -Data $safeData
        } else {
            Write-Log -Level $Level -Message $Message
        }
    } catch {
        # Fallback to console
        Write-Host "[$Level] $Message" -ForegroundColor Yellow
    }
}

# Alias for compatibility
Set-Alias -Name Write-Log-Safe -Value Write-LogSafe



####\allbaseclasses.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ABC.###" to find specific sections.
# Each section ends with "END_PAGE: ABC.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#<!-- PAGE: ABC.001 - TuiAnsiHelper Class -->
#region TuiAnsiHelper - ANSI Code Generation with Truecolor Support
class TuiAnsiHelper {
    # No caches needed, sequences are generated dynamically now.

    static [hashtable] HexToRgb([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor) -or -not $hexColor.StartsWith("#") -or $hexColor.Length -ne 7) {
            Write-Log -Level Warning -Message "Invalid hex color format: '$hexColor'"
            return $null
        }
        try {
            return @{
                R = [System.Convert]::ToInt32($hexColor.Substring(1, 2), 16)
                G = [System.Convert]::ToInt32($hexColor.Substring(3, 2), 16)
                B = [System.Convert]::ToInt32($hexColor.Substring(5, 2), 16)
            }
        } catch {
            Write-Log -Level Warning -Message "Error parsing hex color '$hexColor': $($_.Exception.Message)"
            return $null
        }
    }

    static [string] GetAnsiSequence([string]$fgHex, [string]$bgHex, [hashtable]$attributes) {
        $sequences = [System.Collections.Generic.List[string]]::new()

        # Foreground color (Truecolor - SGR 38;2)
        if (-not [string]::IsNullOrEmpty($fgHex)) {
            $rgb = [TuiAnsiHelper]::HexToRgb($fgHex)
            if ($rgb) {
                $sequences.Add("38;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Background color (Truecolor - SGR 48;2)
        if (-not [string]::IsNullOrEmpty($bgHex)) {
            $rgb = [TuiAnsiHelper]::HexToRgb($bgHex)
            if ($rgb) {
                $sequences.Add("48;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Style attributes
        if ($attributes) {
            if ($attributes.ContainsKey('Bold') -and [bool]$attributes['Bold']) { $sequences.Add("1") }
            if ($attributes.ContainsKey('Italic') -and [bool]$attributes['Italic']) { $sequences.Add("3") }
            if ($attributes.ContainsKey('Underline') -and [bool]$attributes['Underline']) { $sequences.Add("4") }
            if ($attributes.ContainsKey('Strikethrough') -and [bool]$attributes['Strikethrough']) { $sequences.Add("9") }
        }

        if ($sequences.Count -eq 0) { return "" }
        return "`e[$($sequences -join ';')m"
    }

    static [string] Reset() { return "`e[0m" }
}
#endregion
#<!-- END_PAGE: ABC.001 -->

#<!-- PAGE: ABC.002 - TuiCell Class -->
#region TuiCell Class - Core Compositor Unit with Truecolor Support
class TuiCell {
    [char] $Char = ' '
    [string] $ForegroundColor = "#FFFFFF" # Changed to string for hex color
    [string] $BackgroundColor = "#000000" # Changed to string for hex color
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [bool] $Strikethrough = $false # NEW Property for additional style
    [int] $ZIndex = 0        
    [object] $Metadata = $null 

    TuiCell() { }
    TuiCell([char]$char) { $this.Char = $char }
    
    # Constructor with 3 parameters (char, fg, bg)
    TuiCell([char]$char, [string]$fg, [string]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }
    
    # Full constructor with all parameters
    TuiCell([char]$char, [string]$fg, [string]$bg, [bool]$bold, [bool]$italic, [bool]$underline, [bool]$strikethrough) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Italic = $italic
        $this.Underline = $underline
        $this.Strikethrough = $strikethrough # Assign new property
    }
    
    # Copy Constructor: Ensure it copies all new properties
    TuiCell([object]$other) {
        $this.Char = $other.Char
        $this.ForegroundColor = $other.ForegroundColor
        $this.BackgroundColor = $other.BackgroundColor
        $this.Bold = $other.Bold
        $this.Underline = $other.Underline
        $this.Italic = $other.Italic
        $this.Strikethrough = $other.Strikethrough # Make sure this is copied
        $this.ZIndex = $other.ZIndex
        $this.Metadata = $other.Metadata
    }

    [TuiCell] WithStyle([string]$fg, [string]$bg) { # Parameter types changed
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    [TuiCell] BlendWith([object]$other) {
        if ($null -eq $other) { return $this }
        
        # If Z-Indexes are different, the higher one wins.
        if ($other.ZIndex -gt $this.ZIndex) { return [TuiCell]::new($other) }
        if ($other.ZIndex -lt $this.ZIndex) { return $this }

        # If Z-Indexes are the same, the 'other' (top) cell wins by default.
        # This is the most common and intuitive blending mode.
        # A more advanced system could check for a special transparent color.
        return [TuiCell]::new($other)
    }

    [bool] DiffersFrom([object]$other) {
        if ($null -eq $other) { return $true }
        
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic -or
                $this.Strikethrough -ne $other.Strikethrough -or # NEW: Compare Strikethrough
                $this.ZIndex -ne $other.ZIndex)
    }

    [string] ToAnsiString() {
        # This is the crucial update to use the new TuiAnsiHelper.GetAnsiSequence
        $attributes = @{ 
            Bold=$this.Bold; Italic=$this.Italic; Underline=$this.Underline; Strikethrough=$this.Strikethrough 
        }
        $sequence = [TuiAnsiHelper]::GetAnsiSequence($this.ForegroundColor, $this.BackgroundColor, $attributes)
        return "$sequence$($this.Char)" # Append character directly
    }

    [hashtable] ToLegacyFormat() {
        return @{ Char = $this.Char; FG = $this.ForegroundColor; BG = $this.BackgroundColor }
    }
    
    [string] ToString() {
        return "TuiCell(Char='$($this.Char)', FG='$($this.ForegroundColor)', BG='$($this.BackgroundColor)', Bold=$($this.Bold), Underline=$($this.Underline), Italic=$($this.Italic), Strikethrough=$($this.Strikethrough), ZIndex=$($this.ZIndex))"
    }
}
#endregion
#<!-- END_PAGE: ABC.002 -->

#<!-- PAGE: ABC.003 - TuiBuffer Class -->
#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    $Cells       # 2D array of TuiCells - no type constraint to avoid assignment issues
    [int] $Width             
    [int] $Height            
    [string] $Name            
    [bool] $IsDirty = $true  

    # Constructor with 2 parameters
    TuiBuffer([int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.Width = $width
        $this.Height = $height
        $this.Name = "Unnamed"
        # Initialize cells in a simple way
        $this.InitializeCells()
        # Write-Verbose "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
    }

    # Constructor with 3 parameters
    TuiBuffer([int]$width, [int]$height, [string]$name) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        # Initialize cells in a simple way
        $this.InitializeCells()
        # Write-Verbose "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
    }

    hidden [void] InitializeCells() {
        # Create 2D array step by step to avoid assignment issues
        $tempArray = New-Object 'System.Object[,]' $this.Height,$this.Width
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $tempArray[$y,$x] = [TuiCell]::new()
            }
        }
        $this.Cells = $tempArray
    }

    [void] Clear() { $this.Clear([TuiCell]::new()) }

    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell) 
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "TuiBuffer '$($this.Name)' cleared with specified cell."
    }

    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) { return [TuiCell]::new() }
        return $this.Cells[$y, $x]
    }

    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        } else {
            Write-Log -Level Warning -Message "Attempted to set cell out of bounds in TuiBuffer '$($this.Name)': ($x, $y) is outside 0..$($this.Width-1), 0..$($this.Height-1). Cell: '$($cell.Char)'."
        }
    }

    [void] WriteString([int]$x, [int]$y, [string]$text, [hashtable]$style = @{}) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            Write-Log -Level Debug -Message "WriteString: Skipped for buffer '$($this.Name)' due to empty text or out-of-bounds Y."
            return
        }
        
        # Extract properties from the style object, providing safe defaults (now expecting hex colors)
        # Use hashtable indexing syntax to avoid "property not found" errors
        $fg = if ($style.ContainsKey('FG')) { $style['FG'] } else { "#FFFFFF" } # Default Foreground hex
        $bg = if ($style.ContainsKey('BG')) { $style['BG'] } else { "#000000" } # Default Background hex
        $bold = if ($style.ContainsKey('Bold')) { [bool]$style['Bold'] } else { $false }
        $italic = if ($style.ContainsKey('Italic')) { [bool]$style['Italic'] } else { $false }
        $underline = if ($style.ContainsKey('Underline')) { [bool]$style['Underline'] } else { $false }
        $strikethrough = if ($style.ContainsKey('Strikethrough')) { [bool]$style['Strikethrough'] } else { $false }
        $zIndex = if ($style.ContainsKey('ZIndex')) { [int]$style['ZIndex'] } else { 0 }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break } 
            if ($currentX -ge 0) {
                # Pass all style parameters to TuiCell constructor
                $cell = [TuiCell]::new($char, $fg, $bg, $bold, $italic, $underline, $strikethrough)
                $cell.ZIndex = $zIndex # Assign ZIndex
                $this.SetCell($currentX, $y, $cell)
            }
            $currentX++
        }
        $this.IsDirty = $true
        Write-Log -Level Debug -Message "WriteString: Wrote '$text' to buffer '$($this.Name)' at ($x, $y)."
    }

    [void] BlendBuffer([object]$other, [int]$offsetX, [int]$offsetY) {
        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "BlendBuffer: Blended buffer '$($other.Name)' onto '$($this.Name)' at ($offsetX, $offsetY)."
    }

    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        # Write-Verbose "GetSubBuffer: Created sub-buffer '$($subBuffer.Name)' from '$($this.Name)' at ($x, $y) with dimensions $($width)x$($height)."
        return $subBuffer
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height
        $this.Width = $newWidth
        $this.Height = $newHeight
        # Create new 2D array using helper method
        $this.InitializeCells()
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)
        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "TuiBuffer '$($this.Name)' resized from $($oldWidth)x$($oldHeight) to $($newWidth)x$($newHeight)."
    }

    [string] ToString() {
        return "TuiBuffer(Name='$($this.Name)', Width=$($this.Width), Height=$($this.Height), IsDirty=$($this.IsDirty))"
    }

    # Additional helper methods needed by rendering pipeline
    [void] DrawText([int]$x, [int]$y, [string]$text, [hashtable]$style = @{}) {
        $this.WriteString($x, $y, $text, $style)
    }
    
    [void] DrawBox([int]$x, [int]$y, [int]$width, [int]$height, [hashtable]$style = @{}) {
        # This will now internally call the new Write-TuiBox function in AllFunctions.ps1
        # It's better to delegate complex drawing like boxes to the global functions.
        Write-TuiBox -Buffer $this -X $x -Y $y -Width $width -Height $height -Style $style
    }
    
    [void] FillRect([int]$x, [int]$y, [int]$width, [int]$height, [char]$char, [hashtable]$style = @{}) {
        # Create a single character string and use WriteString to fill the rectangle
        # This simplifies the logic by leveraging WriteString's styling capabilities.
        $charString = "$char" # Convert char to string
        for ($py = $y; $py -lt $y + $height; $py++) {
            # Write a line of characters
            $this.WriteString($x, $py, $charString * $width, $style)
        }
    }
    
    [TuiBuffer] Clone() {
        $clone = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name)_Clone")
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $clone.Cells[$y, $x] = [TuiCell]::new($this.Cells[$y, $x])
            }
        }
        return $clone
    }
}
#endregion
#<!-- END_PAGE: ABC.003 -->

#<!-- PAGE: ABC.004 - UIElement Class -->
#region UIElement - Base Class for all UI Components

# ==============================================================================
# CLASS: UIElement
#
# INHERITS:
#   - None (base class)
#
# DEPENDENCIES:
#   Classes:
#     - TuiBuffer (ABC.003)
#     - TuiCell (ABC.002)
#   Services:
#     - TuiFrameworkService (ASE.010) - for dimension access
#
# PURPOSE:
#   Foundation class for all UI components in the framework. Provides core
#   functionality for positioning, sizing, visibility, focus management,
#   hierarchical parent-child relationships, and the rendering lifecycle.
#
# KEY LOGIC:
#   - OnRender: Override to define component-specific rendering
#   - _RenderContent: Core rendering pipeline with optimization
#   - HandleInput: Process keyboard/mouse input
#   - AddChild/RemoveChild: Manage component hierarchy
#   - RequestRedraw: Mark component as needing redraw
#   - Lifecycle: Initialize  OnRender  HandleInput  Cleanup
# ==============================================================================
class UIElement {
    [string] $Name = "UIElement" 
    [int] $X = 0               
    [int] $Y = 0               
    [int] $Width = 30          
    [int] $Height = 10          
    [bool] $Visible = $true    
    [bool] $Enabled = $true    
    [bool] $IsFocusable = $false 
    [bool] $IsFocused = $false  
    [bool] $IsOverlay = $false
    [int] $TabIndex = 0        
    [int] $ZIndex = 0          
    [UIElement] $Parent = $null 
    [System.Collections.Generic.List[UIElement]] $Children 
    
    hidden [object] $_private_buffer = $null
    hidden [bool] $_needs_redraw = $true
    
    [hashtable] $Metadata = @{} 

    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        # Write-Verbose "UIElement 'Unnamed' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([string]$name) {
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        # Write-Verbose "UIElement '$($this.Name)' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "Unnamed.Buffer")
        # Write-Verbose "UIElement 'Unnamed' created at ($x, $y) with dimensions $($width)x$($height)."
    }

    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        return @{ X = $absX; Y = $absY }
    }

    [void] AddChild([object]$child) {
        try {
            if ($child -eq $this) { throw [System.ArgumentException]::new("Cannot add an element as its own child.") }
            if ($this.Children.Contains($child)) {
                Write-Warning "Child '$($child.Name)' is already a child of '$($this.Name)'. Skipping addition."
                return
            }
            if ($child.Parent -ne $null) {
                Write-Warning "Child '$($child.Name)' already has a parent ('$($child.Parent.Name)'). Consider removing it from its current parent first."
            }
            $child.Parent = $this
            $this.Children.Add($child)
            
            # Call the lifecycle hook if the child has it defined
            if ($child.PSObject.Methods['AddedToParent']) {
                try {
                    $child.AddedToParent()
                }
                catch {
                    Write-Warning "Error calling AddedToParent on child '$($child.Name)': $($_.Exception.Message)"
                }
            }
            
            $this.RequestRedraw()
            # Write-Verbose "Added child '$($child.Name)' to parent '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add child '$($child.Name)' to '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] RemoveChild([object]$child) {
        try {
            if ($this.Children.Remove($child)) {
                $child.Parent = $null
                
                # Call the lifecycle hook if the child has it defined
                if ($child.PSObject.Methods['RemovedFromParent']) {
                    try {
                        $child.RemovedFromParent()
                    }
                    catch {
                        Write-Warning "Error calling RemovedFromParent on child '$($child.Name)': $($_.Exception.Message)"
                    }
                }
                
                $this.RequestRedraw()
                # Write-Verbose "Removed child '$($child.Name)' from parent '$($this.Name)'."
            } else {
                Write-Warning "Child '$($child.Name)' not found in parent '$($this.Name)' for removal. No action taken."
            }
        }
        catch {
            Write-Error "Failed to remove child '$($child.Name)' from '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
        # Write-Verbose "Redraw requested for '$($this.Name)'."
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        try {
            if ($this.Width -eq $newWidth -and $this.Height -eq $newHeight) {
                Write-Verbose "Resize: Component '$($this.Name)' already has target dimensions ($($newWidth)x$($newHeight)). No change."
                return
            }
            $this.Width = $newWidth
            $this.Height = $newHeight
            if ($null -ne $this._private_buffer) {
                $this._private_buffer.Resize($newWidth, $newHeight)
            } else {
                $this._private_buffer = [TuiBuffer]::new($newWidth, $newHeight, "$($this.Name).Buffer")
                # Write-Verbose "Re-initialized buffer for '$($this.Name)' due to null buffer."
            }
            $this.RequestRedraw()
            $this.OnResize($newWidth, $newHeight)
            # Write-Verbose "Component '$($this.Name)' resized to $($newWidth)x$($newHeight)."
        }
        catch {
            Write-Error "Failed to resize component '$($this.Name)' to $($newWidth)x$($newHeight): $($_.Exception.Message)"
            throw
        }
    }

    [void] Move([int]$newX, [int]$newY) {
        if ($this.X -eq $newX -and $this.Y -eq $newY) {
            # Write-Verbose "Move: Component '$($this.Name)' already at target position ($($newX), $($newY)). No change."
            return
        }
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
        # Write-Verbose "Component '$($this.Name)' moved to ($newX, $newY)."
    }

    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height)
    }

    [object] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $child.X, $y - $child.Y)) {
                return $child
            }
        }
        return $null
    }

    [void] OnRender() 
    {
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
        # Write-Verbose "OnRender called for '$($this.Name)': Default buffer clear."
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) 
    {
        # Write-Verbose "OnResize called for '$($this.Name)': No custom resize logic."
    }

    [void] OnMove([int]$newX, [int]$newY) 
    {
        # Write-Verbose "OnMove called for '$($this.Name)': No custom move logic."
    }

    [void] OnFocus() 
    { 
        # Write-Verbose "OnFocus called for '$($this.Name)'." 
    }
    
    [void] OnBlur() 
    { 
        # Write-Verbose "OnBlur called for '$($this.Name)'." 
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) 
    {
        # Write-Verbose "HandleInput called for '$($this.Name)': Key: $($keyInfo.Key)."
        return $false
    }

    [void] Cleanup()
    {
        # Cleanup all children recursively
        foreach ($child in $this.Children) {
            if ($child.PSObject.Methods['Cleanup']) {
                try { 
                    $child.Cleanup() 
                } 
                catch { 
                    Write-Warning "Failed to cleanup child '$($child.Name)': $($_.Exception.Message)" 
                }
            }
        }
        
        # Clear references
        $this.Children.Clear()
        $this.Parent = $null
        $this._private_buffer = $null
        
        # Write-Verbose "Cleanup completed for UIElement '$($this.Name)'."
    }

    [void] Render() 
    {
        if (-not $this.Visible) { 
            # Write-Verbose "Skipping Render for '$($this.Name)': Not visible."
            return 
        }
        $this._RenderContent() 
    }

    hidden [void] _RenderContent() 
    {
        if (-not $this.Visible) { return }
        
        # Phase 1: Render Self (if needed)
        $parentDidRedraw = $false
        if ($this._needs_redraw -or ($null -eq $this._private_buffer) -or 
            ($this._private_buffer.Width -ne $this.Width) -or 
            ($this._private_buffer.Height -ne $this.Height)) {
            
            try {
                # Ensure buffer exists and is correct size
                if ($null -eq $this._private_buffer -or 
                    $this._private_buffer.Width -ne $this.Width -or 
                    $this._private_buffer.Height -ne $this.Height) {
                    
                    $bufferWidth = [Math]::Max(1, $this.Width)
                    $bufferHeight = [Math]::Max(1, $this.Height)
                    $this._private_buffer = [TuiBuffer]::new($bufferWidth, $bufferHeight, "$($this.Name).Buffer")
                    
                    if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                        Write-Log -Level Debug -Message "UIElement '$($this.Name)': Buffer resized to ${bufferWidth}x${bufferHeight}"
                    }
                }
                
                # Render component content
                $this.OnRender()
                $parentDidRedraw = $true
                
                if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                    Write-Log -Level Debug -Message "UIElement '$($this.Name)': Rendered own content"
                }
            }
            catch {
                if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                    Write-Log -Level Error -Message "UIElement '$($this.Name)': OnRender() failed: $($_.Exception.Message)"
                }
                throw
            }
        }
        
        # Phase 2: Render and Blend Children (with optimization)
        foreach ($child in $this.Children | Sort-Object ZIndex) {
            if ($child.Visible) {
                try {
                    # Always recurse to allow children to render if they need to
                    $child._RenderContent()
                    
                    # OPTIMIZATION: Only blend if parent redrew OR child redrew
                    $childNeedsBlending = $parentDidRedraw -or $child._needs_redraw
                    
                    if ($childNeedsBlending -and $null -ne $child._private_buffer) {
                        # Bounds checking for child position
                        if ($child.X -lt $this.Width -and $child.Y -lt $this.Height -and 
                            $child.X + $child.Width -gt 0 -and $child.Y + $child.Height -gt 0) {
                            
                            $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                            
                            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                                Write-Log -Level Debug -Message "UIElement '$($this.Name)': Blended child '$($child.Name)' at ($($child.X), $($child.Y))"
                            }
                        }
                        else {
                            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                                Write-Log -Level Debug -Message "UIElement '$($this.Name)': Child '$($child.Name)' is out of bounds, skipping blend"
                            }
                        }
                    }
                }
                catch {
                    if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                        Write-Log -Level Error -Message "UIElement '$($this.Name)': Error rendering child '$($child.Name)': $($_.Exception.Message)"
                    }
                    # Continue with other children even if one fails
                }
            }
        }
        
        # Phase 3: Reset redraw flag for next frame
        $this._needs_redraw = $false
    }

    [object] GetBuffer() 
    { 
        return $this._private_buffer 
    }
    
    [string] ToString() 
    {
        return "$($this.GetType().Name)(Name='$($this.Name)', X=$($this.X), Y=$($this.Y), Width=$($this.Width), Height=$($this.Height), Visible=$($this.Visible))"
    }
}
#endregion
#<!-- END_PAGE: ABC.004 -->

#<!-- PAGE: ABC.005 - Component Class -->
#region Component - A generic container component
class Component : UIElement {
    Component([string]$name) : base($name) {
        $this.Name = $name
        # Write-Verbose "Component '$($this.Name)' created."
    }

    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent()
        # Write-Verbose "_RenderContent called for Component '$($this.Name)' (delegating to base UIElement)."
    }

    [string] ToString() {
        return "Component(Name='$($this.Name)', Children=$($this.Children.Count))"
    }
}
#endregion
#<!-- END_PAGE: ABC.005 -->

#<!-- PAGE: ABC.006 - Screen Class -->
#region Screen - Top-level Container for Application Views

# ==============================================================================
# CLASS: Screen
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Classes:
#     - UIElement (ABC.004)
#     - ServiceContainer (ABC.007)
#   Services:
#     - All registered services via ServiceContainer
#
# PURPOSE:
#   Top-level container for application views. Screens represent complete
#   UI states (like Dashboard, Task List, Settings) and integrate with the
#   service container for dependency injection.
#
# KEY LOGIC:
#   - Initialize: Set up screen resources and state
#   - OnEnter: Called when navigating to this screen
#   - OnExit: Called when leaving this screen
#   - HandleInput: Process screen-level input
#   - SubscribeToEvent: Register for application events
#   - Cleanup: Unsubscribe from events and release resources
# ==============================================================================
class Screen : UIElement {
    [hashtable]$Services
    [object]$ServiceContainer 
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[UIElement]] $Panels
    
    $LastFocusedComponent
    
    hidden [bool] $_isInitialized = $false
    hidden [System.Collections.Generic.Dictionary[string, string]] $EventSubscriptions 

    Screen([string]$name, [hashtable]$services) : base($name) {
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        $this.ServiceContainer = $null
        # Write-Verbose "Screen '$($this.Name)' created with hashtable services."
    }

    Screen([string]$name, [object]$serviceContainer) : base($name) {
        $this.ServiceContainer = $serviceContainer
        $this.Services = [hashtable]::new()
        if ($this.ServiceContainer.PSObject.Methods['GetAllRegisteredServices'] -and $this.ServiceContainer.PSObject.Methods['GetService']) { 
            try {
                $registeredServices = $this.ServiceContainer.GetAllRegisteredServices()
                foreach ($service in $registeredServices) {
                    try {
                        $this.Services[$service.Name] = $this.ServiceContainer.GetService($service.Name)
                    } catch {
                        Write-Warning "Screen '$($this.Name)': Failed to resolve service '$($service.Name)' from container: $($_.Exception.Message)"
                    }
                }
                # Write-Verbose "Screen '$($this.Name)' populated Services hashtable from ServiceContainer."
            } catch {
                Write-Warning "Screen '$($this.Name)': Failed to enumerate services from container: $($_.Exception.Message)"
            }
        } else {
            Write-Warning "Screen '$($this.Name)' received a non-ServiceContainer object for DI. Services hashtable might be incomplete or inaccurate."
        }
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        # Write-Verbose "Screen '$($this.Name)' created with ServiceContainer."
    }

    [void] Initialize() { 
        # Write-Verbose "Initialize called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnEnter() { 
        # Write-Verbose "OnEnter called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnExit() { 
        # Write-Verbose "OnExit called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnResume() { 
        # Write-Verbose "OnResume called for Screen '$($this.Name)': Default (no-op)." 
    }

    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Write-Verbose "HandleInput called for Screen '$($this.Name)': Key: $($keyInfo.Key). Default (no-op)."
    }

    [void] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo) {
        $this.HandleInput($keyInfo)
    }

    [void] HandleResize([int]$newWidth, [int]$newHeight) {
        $this.Resize($newWidth, $newHeight)
    }

    [void] Cleanup() {
        try {
            # Write-Verbose "Cleanup called for Screen '$($this.Name)'."
            
            # Screen-specific cleanup: Unsubscribe from events
            foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
                try {
                    if (Get-Command 'Unsubscribe-Event' -ErrorAction SilentlyContinue) {
                        Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value
                        Write-Verbose "Unsubscribed event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)'."
                    }
                }
                catch {
                    Write-Warning "Failed to unsubscribe event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)': $($_.Exception.Message)"
                }
            }
            $this.EventSubscriptions.Clear()
            
            # Clear screen-specific collections
            $this.Panels.Clear()
            $this.State.Clear()
            
            # Call base UIElement cleanup (handles children recursively)
            ([UIElement]$this).Cleanup()
            
            Write-Verbose "Cleaned up resources for screen: $($this.Name)."
        }
        catch {
            Write-Error "Error during Cleanup for screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] AddPanel([object]$panel) {
        try {
            $this.Panels.Add($panel)
            $this.AddChild($panel) 
            Write-Verbose "Added panel '$($panel.Name)' to screen '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add panel '$($panel.Name)' to screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        try {
            if (Get-Command 'Subscribe-Event' -ErrorAction SilentlyContinue) {
                $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
                $this.EventSubscriptions[$eventName] = $subscriptionId
                Write-Verbose "Screen '$($this.Name)' subscribed to event '$eventName' with HandlerId: $subscriptionId."
            } else {
                Write-Warning "Subscribe-Event function not available. Event subscription for '$eventName' failed."
            }
        }
        catch {
            Write-Error "Failed for screen '$($this.Name)' to subscribe to event '$eventName': $($_.Exception.Message)"
            throw
        }
    }
    
    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent()
        Write-Verbose "_RenderContent called for Screen '$($this.Name)' (rendering UIElement children, including panels)."
    }

    [string] ToString() {
        $panelCount = if ($this.Panels) { $this.Panels.Count } else { 0 }
        return "Screen(Name='$($this.Name)', Panels=$panelCount, Visible=$($this.Visible))"
    }

    [void] Render([TuiBuffer]$buffer) {
        # First render self
        $this._RenderContent()
        
        # Then blend our buffer onto the target
        if ($null -ne $this._private_buffer) {
            $buffer.BlendBuffer($this._private_buffer, 0, 0)
        }
    }
}
#endregion
#<!-- END_PAGE: ABC.006 -->

#<!-- PAGE: ABC.007 - ServiceContainer Class -->
#region ServiceContainer Class
class ServiceContainer {
    hidden [hashtable] $_services = @{}
    hidden [hashtable] $_serviceFactories = @{}

    ServiceContainer() {
        # Don't use Write-Log during construction - Logger doesn't exist yet
        Write-Verbose "ServiceContainer: Instance constructed."
    }

    [void] Register([string]$name, [object]$serviceInstance) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }
        if ($null -eq $serviceInstance) { throw [System.ArgumentNullException]::new("serviceInstance") }

        if ($this._services.ContainsKey($name) -or $this._serviceFactories.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("A service or factory with the name '$name' is already registered.")
        }

        $this._services[$name] = $serviceInstance
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Registered eager service instance: '$name'."
        }
        Write-Verbose "ServiceContainer: Registered eager instance for '$name' of type '$($serviceInstance.GetType().Name)'."
    }

    [void] RegisterFactory([string]$name, [scriptblock]$factory, [bool]$isSingleton = $true) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }
        if ($null -eq $factory) { throw [System.ArgumentNullException]::new("factory") }

        if ($this._services.ContainsKey($name) -or $this._serviceFactories.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("A service or factory with the name '$name' is already registered.")
        }
        
        $this._serviceFactories[$name] = @{
            Factory = $factory
            IsSingleton = $isSingleton
            Instance = $null
        }
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Registered service factory: '$name' (Singleton: $isSingleton)."
        }
        Write-Verbose "ServiceContainer: Registered factory for '$name' (Singleton: $isSingleton)."
    }

    [object] GetService([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }

        if ($this._services.ContainsKey($name)) {
            Write-Verbose "ServiceContainer: Returning eager-loaded instance of '$name'."
            return $this._services[$name]
        }

        if ($this._serviceFactories.ContainsKey($name)) {
            return $this._InitializeServiceFromFactory($name, [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase))
        }

        $available = $this.GetAllRegisteredServices() | Select-Object -ExpandProperty Name
        throw [System.InvalidOperationException]::new("Service '$name' not found. Available services: $($available -join ', ')")
    }
    
    [object[]] GetAllRegisteredServices() {
        $list = [System.Collections.Generic.List[object]]::new()
        
        foreach ($key in $this._services.Keys) {
            $list.Add([pscustomobject]@{
                Name = $key
                Type = 'Instance'
                Initialized = $true
                Lifestyle = 'Singleton'
            })
        }
        
        foreach ($key in $this._serviceFactories.Keys) {
            $factoryInfo = $this._serviceFactories[$key]
            $list.Add([pscustomobject]@{
                Name = $key
                Type = 'Factory'
                Initialized = ($null -ne $factoryInfo.Instance)
                Lifestyle = if ($factoryInfo.IsSingleton) { 'Singleton' } else { 'Transient' }
            })
        }
        
        return $list.ToArray() | Sort-Object Name
    }

    [void] Cleanup() {
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer cleanup initiated."
        }
        Write-Verbose "ServiceContainer: Initiating cleanup of disposable singleton services."
        
        $instancesToClean = [System.Collections.Generic.List[object]]::new()
        $this._services.Values | ForEach-Object { $instancesToClean.Add($_) }
        $this._serviceFactories.Values | Where-Object { $_.IsSingleton -and $_.Instance } | ForEach-Object { $instancesToClean.Add($_.Instance) }

        foreach ($service in $instancesToClean) {
            if ($service -is [System.IDisposable]) {
                try {
                    Write-Verbose "ServiceContainer: Disposing service of type '$($service.GetType().FullName)'."
                    $service.Dispose()
                } catch {
                    if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                        Write-Log -Level Error -Message "Error disposing service of type '$($service.GetType().FullName)': $($_.Exception.Message)"
                    }
                }
            }
        }
        
        $this._services.Clear()
        $this._serviceFactories.Clear()
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer cleanup complete."
        }
        Write-Verbose "ServiceContainer: Cleanup complete. All service registries cleared."
    }

    hidden [object] _InitializeServiceFromFactory([string]$name, [System.Collections.Generic.HashSet[string]]$resolutionChain) {
        $factoryInfo = $this._serviceFactories[$name]
        
        if ($factoryInfo.IsSingleton -and $null -ne $factoryInfo.Instance) {
            Write-Verbose "ServiceContainer: Returning cached singleton instance of '$name'."
            return $factoryInfo.Instance
        }

        if ($resolutionChain.Contains($name)) {
            $chain = ($resolutionChain -join ' -> ') + " -> $name"
            throw [System.InvalidOperationException]::new("Circular dependency detected while resolving service '$name'. Chain: $chain")
        }
        [void]$resolutionChain.Add($name)
        
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Instantiating service '$name' from factory."
        }
        Write-Verbose "ServiceContainer: Invoking factory to create instance of '$name'."
        
        $serviceInstance = & $factoryInfo.Factory $this

        if ($factoryInfo.IsSingleton) {
            $factoryInfo.Instance = $serviceInstance
            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Cached singleton instance of service '$name'."
            }
            Write-Verbose "ServiceContainer: Cached new singleton instance of '$name'."
        }

        [void]$resolutionChain.Remove($name)
        
        return $serviceInstance
    }
}
#endregion
#<!-- END_PAGE: ABC.007 -->



####\AllComponents.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

##<!-- PAGE: ACO.001 - LabelComponent Class -->
#region Core UI Components

# ===== CLASS: LabelComponent =====
# Module: tui-components
# Dependencies: UIElement
# Purpose: Static text display
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor

    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 30  # Increased default width
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Clear buffer with theme background
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Get foreground color
        if ($this.ForegroundColor) {
            if ($this.ForegroundColor -is [ConsoleColor]) {
                # Convert ConsoleColor to hex if needed
                $fg = Get-ThemeColor("Foreground") # Use theme default instead
            } else {
                $fg = $this.ForegroundColor # Assume it's already hex
            }
        } else {
            $fg = Get-ThemeColor("Foreground")
        }
        
        # Draw text
        Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $this.Text -Style @{ FG = $fg; BG = $bgColor }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}
#<!-- END_PAGE: ACO.001 -->

#<!-- PAGE: ACO.002 - ButtonComponent Class -->
# ===== CLASS: ButtonComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Interactive button with click events
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick

    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Clear buffer with theme background
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Determine colors based on state
        $fgColor = "#FFFFFF"
        $bgColor = "#333333"
        
        if ($this.IsPressed) {
            $fgColor = Get-ThemeColor("button.pressed.fg")
            $bgColor = Get-ThemeColor("button.pressed.bg")
        }
        elseif ($this.IsFocused) {
            $fgColor = Get-ThemeColor("button.focused.fg") 
            $bgColor = Get-ThemeColor("button.focused.bg")
        }
        elseif (-not $this.Enabled) {
            $fgColor = Get-ThemeColor("button.disabled.fg")
            $bgColor = Get-ThemeColor("button.disabled.bg")
        }
        else {
            $fgColor = Get-ThemeColor("button.normal.fg")
            $bgColor = Get-ThemeColor("button.normal.bg")
        }
        
        # Draw button background
        $style = @{ FG = $fgColor; BG = $bgColor }
        $this._private_buffer.FillRect(0, 0, $this.Width, $this.Height, ' ', $style)
        
        # Draw button text centered
        if (-not [string]::IsNullOrEmpty($this.Text)) {
            $textX = [Math]::Max(0, [Math]::Floor(($this.Width - $this.Text.Length) / 2))
            $textY = [Math]::Floor($this.Height / 2)
            
            Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -Style $style
        }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            try {
                $this.IsPressed = $true
                $this.RequestRedraw()
                
                if ($this.OnClick) {
                    & $this.OnClick
                }
                
                Start-Sleep -Milliseconds 50
                $this.IsPressed = $false
                $this.RequestRedraw()
                
                return $true
            }
            catch {
                $this.IsPressed = $false
                $this.RequestRedraw()
            }
        }
        return $false
    }
}

#<!-- END_PAGE: ACO.002 -->

#<!-- PAGE: ACO.003 - TextBoxComponent Class -->
# ===== CLASS: TextBoxComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Text input with viewport scrolling, non-destructive cursor
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [ValidateRange(1, [int]::MaxValue)][int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    hidden [int]$_scrollOffset = 0
    [string]$BackgroundColor = "#000000" # Changed from ConsoleColor to hex string
    [string]$ForegroundColor = "#FFFFFF" # Changed from ConsoleColor to hex string
    [string]$BorderColor = "#808080" # Changed from ConsoleColor to hex string
    [string]$PlaceholderColor = "#808080" # Changed from ConsoleColor to hex string

    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Clear buffer with theme background
        $bgColor = Get-ThemeColor("input.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Determine colors
        $fgColor = if ($this.IsFocused) { Get-ThemeColor("input.foreground") } else { Get-ThemeColor("Subtle") }
        $bgColor = Get-ThemeColor("input.background")
        $borderColorValue = if ($this.IsFocused) { Get-ThemeColor("Primary") } else { Get-ThemeColor("component.border") }
        
        # Draw border
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
            -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            # Draw text or placeholder
            $contentY = 1
            $contentStartX = 1
            $contentWidth = $this.Width - 2
            
            if ($this.Text.Length -eq 0 -and $this.Placeholder) {
                # Draw placeholder
                $placeholderText = if ($this.Placeholder.Length -gt $contentWidth) {
                    $this.Placeholder.Substring(0, $contentWidth)
                } else { $this.Placeholder }
                
                $textStyle = @{ FG = Get-ThemeColor("input.placeholder"); BG = $bgColor }
                Write-TuiText -Buffer $this._private_buffer -X $contentStartX -Y $contentY -Text $placeholderText -Style $textStyle
            }
            else {
                # Calculate scroll offset
                if ($this.CursorPosition -lt $this._scrollOffset) {
                    $this._scrollOffset = $this.CursorPosition
                }
                elseif ($this.CursorPosition -ge ($this._scrollOffset + $contentWidth)) {
                    $this._scrollOffset = $this.CursorPosition - $contentWidth + 1
                }
                
                # Draw visible portion of text
                $visibleText = ""
                if ($this.Text.Length -gt 0) {
                    $endPos = [Math]::Min($this._scrollOffset + $contentWidth, $this.Text.Length)
                    if ($this._scrollOffset -lt $this.Text.Length) {
                        $visibleText = $this.Text.Substring($this._scrollOffset, $endPos - $this._scrollOffset)
                    }
                }
                
                if ($visibleText) {
                    $textStyle = @{ FG = $fgColor; BG = $bgColor }
                    Write-TuiText -Buffer $this._private_buffer -X $contentStartX -Y $contentY -Text $visibleText -Style $textStyle
                }
                
                # Draw cursor if focused (non-destructive - inverts colors)
                if ($this.IsFocused) {
                    $cursorScreenPos = $this.CursorPosition - $this._scrollOffset
                    if ($cursorScreenPos -ge 0 -and $cursorScreenPos -lt $contentWidth) {
                        $cursorX = $contentStartX + $cursorScreenPos
                        
                        # Get the cell that is ALREADY at the cursor's position
                        $cellUnderCursor = $this._private_buffer.GetCell($cursorX, $contentY)
                        
                        # Invert its colors to represent the cursor (non-destructive)
                        $cursorFg = $cellUnderCursor.BackgroundColor
                        $cursorBg = $cellUnderCursor.ForegroundColor
                        $newCell = [TuiCell]::new($cellUnderCursor.Char, $cursorBg, $cursorFg, $true) # Make it bold
                        $this._private_buffer.SetCell($cursorX, $contentY, $newCell)
                    }
                }
            }
            
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldText = $this.Text
        
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.CursorPosition++
                }
            }
            ([ConsoleKey]::Home) {
                $this.CursorPosition = 0
            }
            ([ConsoleKey]::End) {
                $this.CursorPosition = $this.Text.Length
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPosition, 1)
                }
            }
            default {
                if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                    if ($this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    }
                }
                else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            if ($oldText -ne $this.Text -and $this.OnChange) {
                try { 
                    & $this.OnChange $this $this.Text 
                } catch {
                    # Ignore errors in onChange handler
                }
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

#<!-- END_PAGE: ACO.003 -->

#<!-- PAGE: ACO.004 - CheckBoxComponent Class -->
# ===== CLASS: CheckBoxComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Boolean checkbox input
class CheckBoxComponent : UIElement {
    [string]$Text = ""
    [bool]$Checked = $false
    [scriptblock]$OnChange

    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        if ($this.IsFocused) { 
            $fgColor = Get-ThemeColor("Primary") 
        } else { 
            $fgColor = Get-ThemeColor("Foreground") 
        }
        if ($this.Checked) { 
            $checkMark = "[X]" 
        } else { 
            $checkMark = "[ ]" 
        }
        $fullText = "$checkMark $($this.Text)"
        
        Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $fullText -Style @{ FG = $fgColor; BG = $bgColor }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar) {
            $this.Checked = -not $this.Checked
            if ($this.OnChange) {
                try { 
                    & $this.OnChange $this $this.Checked 
                } catch {
                    # Ignore errors in onChange handler
                }
            }
            $this.RequestRedraw()
            return $true
        }
        
        return $false
    }
}

#<!-- END_PAGE: ACO.004 -->

#<!-- PAGE: ACO.005 - RadioButtonComponent Class -->
# ===== CLASS: RadioButtonComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Exclusive selection with group management
class RadioButtonComponent : UIElement {
    [string]$Text = ""
    [bool]$Selected = $false
    [string]$GroupName = "default"
    [scriptblock]$OnChange
    static [hashtable]$_groups = @{}

    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        if ($this.IsFocused) { 
            $fgColor = Get-ThemeColor("Primary") 
        } else { 
            $fgColor = Get-ThemeColor("Foreground") 
        }
        if ($this.Selected) { 
            $radioMark = "(o)" 
        } else { 
            $radioMark = "( )" 
        }
        $fullText = "$radioMark $($this.Text)"
        
        Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $fullText -Style @{ FG = $fgColor; BG = $bgColor }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar -and -not $this.Selected) {
            $this.Select()
            return $true
        }
        
        return $false
    }

    [void] Select() {
        # Deselect all others in group
        if ([RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            foreach ($radio in [RadioButtonComponent]::_groups[$this.GroupName]) {
                if ($radio -ne $this -and $radio.Selected) {
                    $radio.Selected = $false
                    $radio.RequestRedraw()
                    if ($radio.OnChange) {
                        try { 
                            & $radio.OnChange $radio $false 
                        } catch {
                            # Ignore errors in onChange handler
                        }
                    }
                }
            }
        }
        
        $this.Selected = $true
        $this.RequestRedraw()
        if ($this.OnChange) {
            try { 
                & $this.OnChange $this $true 
            } catch {
                # Ignore errors in onChange handler
            }
        }
    }

    [void] AddedToParent() {
        if (-not [RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            [RadioButtonComponent]::_groups[$this.GroupName] = [List[RadioButtonComponent]]::new()
        }
        [RadioButtonComponent]::_groups[$this.GroupName].Add($this)
    }

    [void] RemovedFromParent() {
        if ([RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            [RadioButtonComponent]::_groups[$this.GroupName].Remove($this)
        }
    }
}

#endregion Core UI Components

#region Advanced Components

#<!-- END_PAGE: ACO.005 -->

#<!-- PAGE: ACO.006 - MultilineTextBoxComponent Class -->
# ===== CLASS: MultilineTextBoxComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Full text editor with scrolling
class MultilineTextBoxComponent : UIElement {
    [List[string]]$Lines
    [int]$CursorLine = 0
    [int]$CursorColumn = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [bool]$ReadOnly = $false
    [scriptblock]$OnChange
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    
    MultilineTextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Lines = [List[string]]::new()
        $this.Lines.Add("")
        $this.Width = 40
        $this.Height = 10
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor -ColorName "input.background" -DefaultColor $this.BackgroundColor
            $fgColor = Get-ThemeColor -ColorName "input.foreground" -DefaultColor $this.ForegroundColor
            $borderColorValue = if ($this.IsFocused) { Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF" } else { Get-ThemeColor -ColorName "component.border" -DefaultColor $this.BorderColor }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            # Calculate visible area
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
            
            # Adjust scroll to keep cursor visible
            if ($this.CursorLine -lt $this.ScrollOffsetY) {
                $this.ScrollOffsetY = $this.CursorLine
            }
            elseif ($this.CursorLine -ge $this.ScrollOffsetY + $contentHeight) {
                $this.ScrollOffsetY = $this.CursorLine - $contentHeight + 1
            }
            
            if ($this.CursorColumn -lt $this.ScrollOffsetX) {
                $this.ScrollOffsetX = $this.CursorColumn
            }
            elseif ($this.CursorColumn -ge $this.ScrollOffsetX + $contentWidth) {
                $this.ScrollOffsetX = $this.CursorColumn - $contentWidth + 1
            }
            
            # Draw visible lines
            for ($y = 0; $y -lt $contentHeight; $y++) {
                $lineIndex = $y + $this.ScrollOffsetY
                if ($lineIndex -lt $this.Lines.Count) {
                    $line = $this.Lines[$lineIndex]
                    $visiblePart = ""
                    
                    if ($line.Length -gt $this.ScrollOffsetX) {
                        $endPos = [Math]::Min($this.ScrollOffsetX + $contentWidth, $line.Length)
                        $visiblePart = $line.Substring($this.ScrollOffsetX, $endPos - $this.ScrollOffsetX)
                    }
                    
                    if ($visiblePart) {
                        Write-TuiText -Buffer $this._private_buffer -X 1 -Y ($y + 1) -Text $visiblePart -Style @{ FG = $fgColor; BG = $bgColor }
                    }
                }
            }
            
            # Draw cursor if focused
            if ($this.IsFocused -and -not $this.ReadOnly) {
                $cursorScreenY = $this.CursorLine - $this.ScrollOffsetY + 1
                $cursorScreenX = $this.CursorColumn - $this.ScrollOffsetX + 1
                
                if ($cursorScreenY -ge 1 -and $cursorScreenY -lt $this.Height - 1 -and
                    $cursorScreenX -ge 1 -and $cursorScreenX -lt $this.Width - 1) {
                    
                    $currentLine = $this.Lines[$this.CursorLine]
                    $cursorChar = ' '
                    if ($this.CursorColumn -lt $currentLine.Length) {
                        $cursorChar = $currentLine[$this.CursorColumn]
                    }
                    
                    $this._private_buffer.SetCell($cursorScreenX, $cursorScreenY,
                        [TuiCell]::new($cursorChar, $bgColor, $fgColor))
                }
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.ReadOnly) { return $false }
        
        $handled = $true
        $changed = $false
        
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorColumn -gt 0) {
                    $this.CursorColumn--
                }
                elseif ($this.CursorLine -gt 0) {
                    $this.CursorLine--
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
            }
            ([ConsoleKey]::RightArrow) {
                $currentLine = $this.Lines[$this.CursorLine]
                if ($this.CursorColumn -lt $currentLine.Length) {
                    $this.CursorColumn++
                }
                elseif ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.CursorLine++
                    $this.CursorColumn = 0
                }
            }
            ([ConsoleKey]::UpArrow) {
                if ($this.CursorLine -gt 0) {
                    $this.CursorLine--
                    $newLineLength = $this.Lines[$this.CursorLine].Length
                    if ($this.CursorColumn -gt $newLineLength) {
                        $this.CursorColumn = $newLineLength
                    }
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.CursorLine++
                    $newLineLength = $this.Lines[$this.CursorLine].Length
                    if ($this.CursorColumn -gt $newLineLength) {
                        $this.CursorColumn = $newLineLength
                    }
                }
            }
            ([ConsoleKey]::Home) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.CursorLine = 0
                    $this.CursorColumn = 0
                }
                else {
                    $this.CursorColumn = 0
                }
            }
            ([ConsoleKey]::End) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.CursorLine = $this.Lines.Count - 1
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
                else {
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
            }
            ([ConsoleKey]::Enter) {
                $currentLine = $this.Lines[$this.CursorLine]
                $beforeCursor = $currentLine.Substring(0, $this.CursorColumn)
                $afterCursor = $currentLine.Substring($this.CursorColumn)
                
                $this.Lines[$this.CursorLine] = $beforeCursor
                $this.Lines.Insert($this.CursorLine + 1, $afterCursor)
                
                $this.CursorLine++
                $this.CursorColumn = 0
                $changed = $true
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorColumn -gt 0) {
                    $currentLine = $this.Lines[$this.CursorLine]
                    $this.Lines[$this.CursorLine] = $currentLine.Remove($this.CursorColumn - 1, 1)
                    $this.CursorColumn--
                    $changed = $true
                }
                elseif ($this.CursorLine -gt 0) {
                    $currentLine = $this.Lines[$this.CursorLine]
                    $previousLine = $this.Lines[$this.CursorLine - 1]
                    $this.CursorColumn = $previousLine.Length
                    $this.Lines[$this.CursorLine - 1] = $previousLine + $currentLine
                    $this.Lines.RemoveAt($this.CursorLine)
                    $this.CursorLine--
                    $changed = $true
                }
            }
            ([ConsoleKey]::Delete) {
                $currentLine = $this.Lines[$this.CursorLine]
                if ($this.CursorColumn -lt $currentLine.Length) {
                    $this.Lines[$this.CursorLine] = $currentLine.Remove($this.CursorColumn, 1)
                    $changed = $true
                }
                elseif ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $nextLine = $this.Lines[$this.CursorLine + 1]
                    $this.Lines[$this.CursorLine] = $currentLine + $nextLine
                    $this.Lines.RemoveAt($this.CursorLine + 1)
                    $changed = $true
                }
            }
            default {
                if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                    $currentLine = $this.Lines[$this.CursorLine]
                    $this.Lines[$this.CursorLine] = $currentLine.Insert($this.CursorColumn, $key.KeyChar)
                    $this.CursorColumn++
                    $changed = $true
                }
                else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            if ($changed -and $this.OnChange) {
                try { & $this.OnChange $this $this.GetText() } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    [string] GetText() {
        return ($this.Lines -join "`n")
    }
    
    [void] SetText([string]$text) {
        $this.Lines.Clear()
        $splitLines = $text -split "`n"
        foreach ($line in $splitLines) {
            $this.Lines.Add($line)
        }
        if ($this.Lines.Count -eq 0) {
            $this.Lines.Add("")
        }
        $this.CursorLine = 0
        $this.CursorColumn = 0
        $this.ScrollOffsetY = 0
        $this.ScrollOffsetX = 0
        $this.RequestRedraw()
    }
}

#<!-- END_PAGE: ACO.006 -->

#<!-- PAGE: ACO.007 - NumericInputComponent Class -->
# ===== CLASS: NumericInputComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Numeric input with spinners and validation
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$Minimum = [double]::MinValue
    [double]$Maximum = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [scriptblock]$OnChange
    hidden [string]$_textValue = "0"
    hidden [int]$_cursorPosition = 1
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    
    NumericInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 15
        $this.Height = 3
        $this._textValue = $this.FormatValue($this.Value)
        $this._cursorPosition = $this._textValue.Length
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor -ColorName "input.background" -DefaultColor $this.BackgroundColor
            $fgColor = Get-ThemeColor -ColorName "input.foreground" -DefaultColor $this.ForegroundColor
            $borderColorValue = if ($this.IsFocused) { Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF" } else { Get-ThemeColor -ColorName "component.border" -DefaultColor $this.BorderColor }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            # Draw spinners
            $spinnerColor = if ($this.IsFocused) { "#FFFF00" } else { "#808080" }
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new('', $spinnerColor, $bgColor))
            $this._private_buffer.SetCell($this.Width - 2, $this.Height - 2, [TuiCell]::new('', $spinnerColor, $bgColor))
            
            # Draw value
            $displayValue = $this._textValue
            $maxTextWidth = $this.Width - 4  # Border + spinner
            if ($displayValue.Length -gt $maxTextWidth) {
                $displayValue = $displayValue.Substring(0, $maxTextWidth)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayValue -Style @{ FG = $fgColor; BG = $bgColor }
            
            # Draw cursor if focused
            if ($this.IsFocused -and $this._cursorPosition -le $displayValue.Length) {
                $cursorX = 1 + $this._cursorPosition
                if ($cursorX -lt $this.Width - 2) {
                    if ($this._cursorPosition -lt $this._textValue.Length) {
                        $cursorChar = $this._textValue[$this._cursorPosition]
                    } else { 
                        $cursorChar = ' ' 
                    }
                    
                    $this._private_buffer.SetCell($cursorX, 1, 
                        [TuiCell]::new($cursorChar, $bgColor, $fgColor))
                }
            }
        }
        catch {}
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldValue = $this.Value
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.IncrementValue()
            }
            ([ConsoleKey]::DownArrow) {
                $this.DecrementValue()
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this._cursorPosition -gt 0) {
                    $this._cursorPosition--
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this._cursorPosition -lt $this._textValue.Length) {
                    $this._cursorPosition++
                }
            }
            ([ConsoleKey]::Home) {
                $this._cursorPosition = 0
            }
            ([ConsoleKey]::End) {
                $this._cursorPosition = $this._textValue.Length
            }
            ([ConsoleKey]::Backspace) {
                if ($this._cursorPosition -gt 0) {
                    $this._textValue = $this._textValue.Remove($this._cursorPosition - 1, 1)
                    $this._cursorPosition--
                    $this.ParseAndValidate()
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this._cursorPosition -lt $this._textValue.Length) {
                    $this._textValue = $this._textValue.Remove($this._cursorPosition, 1)
                    $this.ParseAndValidate()
                }
            }
            ([ConsoleKey]::Enter) {
                $this.ParseAndValidate()
            }
            default {
                if ($key.KeyChar -and ($key.KeyChar -match '[0-9.\-]')) {
                    # Allow only valid numeric characters
                    if ($key.KeyChar -eq '.' -and $this._textValue.Contains('.')) {
                        # Only one decimal point allowed
                        $handled = $false
                    }
                    elseif ($key.KeyChar -eq '-' -and ($this._cursorPosition -ne 0 -or $this._textValue.Contains('-'))) {
                        # Minus only at beginning
                        $handled = $false
                    }
                    else {
                        $this._textValue = $this._textValue.Insert($this._cursorPosition, $key.KeyChar)
                        $this._cursorPosition++
                        $this.ParseAndValidate()
                    }
                }
                else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            if ($oldValue -ne $this.Value -and $this.OnChange) {
                try { & $this.OnChange $this $this.Value } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    hidden [void] IncrementValue() {
        $newValue = $this.Value + $this.Step
        if ($newValue -le $this.Maximum) {
            $this.Value = $newValue
            $this._textValue = $this.FormatValue($this.Value)
            $this._cursorPosition = $this._textValue.Length
        }
    }
    
    hidden [void] DecrementValue() {
        $newValue = $this.Value - $this.Step
        if ($newValue -ge $this.Minimum) {
            $this.Value = $newValue
            $this._textValue = $this.FormatValue($this.Value)
            $this._cursorPosition = $this._textValue.Length
        }
    }
    
    hidden [void] ParseAndValidate() {
        try {
            $parsedValue = [double]::Parse($this._textValue)
            $parsedValue = [Math]::Max($this.Minimum, [Math]::Min($this.Maximum, $parsedValue))
            $this.Value = $parsedValue
        }
        catch {
            # Keep current value if parse fails
        }
    }
    
    hidden [string] FormatValue([double]$value) {
        if ($this.DecimalPlaces -eq 0) {
            return [Math]::Truncate($value).ToString()
        }
        else {
            return $value.ToString("F$($this.DecimalPlaces)")
        }
    }
}

#<!-- END_PAGE: ACO.007 -->

#<!-- PAGE: ACO.008 - DateInputComponent Class -->
# ===== CLASS: DateInputComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Date picker with calendar interface
class DateInputComponent : UIElement {
    [DateTime]$Value = [DateTime]::Today
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [scriptblock]$OnChange
    hidden [bool]$_showCalendar = $false
    hidden [DateTime]$_viewMonth
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    
    DateInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 1  # Expands to 10 when calendar shown
        $this._viewMonth = $this.Value
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor -ColorName "input.background" -DefaultColor $this.BackgroundColor
            $fgColor = Get-ThemeColor -ColorName "input.foreground" -DefaultColor $this.ForegroundColor
            if ($this.IsFocused) { 
                $borderColorValue = Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF" 
            } else { 
                $borderColorValue = Get-ThemeColor -ColorName "component.border" -DefaultColor $this.BorderColor 
            }
            
            # Adjust height based on calendar visibility
            if ($this._showCalendar) { 
                $renderHeight = 10 
            } else { 
                $renderHeight = 3 
            }
            if ($this.Height -ne $renderHeight) {
                $this.Height = $renderHeight
                $this.RequestRedraw()
                return
            }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw text box
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height 3 `
                -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            # Draw date value
            $dateStr = $this.Value.ToString("yyyy-MM-dd")
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $dateStr -Style @{ FG = $fgColor; BG = $bgColor }
            
            # Draw calendar icon
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new('', $borderColorValue, $bgColor))
            
            # Draw calendar if shown
            if ($this._showCalendar) {
                $this.DrawCalendar(0, 3)
            }
        }
        catch {}
    }
    
    hidden [void] DrawCalendar([int]$startX, [int]$startY) {
        $bgColor = "#000000"
        $fgColor = "#FFFFFF"
        $headerColor = "#FFFF00"
        $selectedColor = "#00FFFF"
        $todayColor = "#00FF00"
        
        # Calendar border
        Write-TuiBox -Buffer $this._private_buffer -X $startX -Y $startY `
            -Width $this.Width -Height 7 `
            -Style @{ BorderFG = "#808080"; BG = $bgColor; BorderStyle = "Single" }
        
        # Month/Year header
        $monthYearStr = $this._viewMonth.ToString("MMMM yyyy")
        $headerX = $startX + [Math]::Floor(($this.Width - $monthYearStr.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $headerX -Y ($startY + 1) -Text $monthYearStr -Style @{ FG = $headerColor; BG = $bgColor }
        
        # Navigation arrows
        $this._private_buffer.SetCell($startX + 1, $startY + 1, [TuiCell]::new('<', $headerColor, $bgColor))
        $this._private_buffer.SetCell($startX + $this.Width - 2, $startY + 1, [TuiCell]::new('>', $headerColor, $bgColor))
        
        # Day headers
        $dayHeaders = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
        $dayX = $startX + 2
        foreach ($day in $dayHeaders) {
            Write-TuiText -Buffer $this._private_buffer -X $dayX -Y ($startY + 2) -Text $day -Style @{ FG = "#808080"; BG = $bgColor }
            $dayX += 3
        }
        
        # Calendar days
        $firstDay = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, 1)
        $startDayOfWeek = [int]$firstDay.DayOfWeek
        $daysInMonth = [DateTime]::DaysInMonth($this._viewMonth.Year, $this._viewMonth.Month)
        
        $currentDay = 1
        $today = [DateTime]::Today
        
        for ($week = 0; $week -lt 6; $week++) {
            if ($currentDay -gt $daysInMonth) { break }
            
            for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                if ($currentDay -gt $daysInMonth) { break }
                
                $dayX = $startX + 2 + ($dayOfWeek * 3)
                $dayY = $startY + 3 + $week
                
                $currentDate = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, $currentDay)
                $dayStr = $currentDay.ToString().PadLeft(2)
                
                # Determine color
                $dayColor = $fgColor
                if ($currentDate -eq $this.Value) {
                    $dayColor = $selectedColor
                }
                elseif ($currentDate -eq $today) {
                    $dayColor = $todayColor
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $dayX -Y $dayY -Text $dayStr -Style @{ FG = $dayColor; BG = $bgColor }
                $currentDay++
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldValue = $this.Value
        
        if (-not $this._showCalendar) {
            switch ($key.Key) {
                ([ConsoleKey]::Enter) { $this._showCalendar = $true }
                ([ConsoleKey]::Spacebar) { $this._showCalendar = $true }
                ([ConsoleKey]::DownArrow) { $this._showCalendar = $true }
                default { $handled = $false }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) { 
                    $this._showCalendar = $false 
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Previous month
                        $this._viewMonth = $this._viewMonth.AddMonths(-1)
                    }
                    else {
                        # Previous day
                        $newDate = $this.Value.AddDays(-1)
                        if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                            $this.Value = $newDate
                            $this._viewMonth = $newDate
                        }
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Next month
                        $this._viewMonth = $this._viewMonth.AddMonths(1)
                    }
                    else {
                        # Next day
                        $newDate = $this.Value.AddDays(1)
                        if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                            $this.Value = $newDate
                            $this._viewMonth = $newDate
                        }
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    # Previous week
                    $newDate = $this.Value.AddDays(-7)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._viewMonth = $newDate
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    # Next week
                    $newDate = $this.Value.AddDays(7)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._viewMonth = $newDate
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this._showCalendar = $false
                }
                ([ConsoleKey]::T) {
                    # Today
                    $today = [DateTime]::Today
                    if ($today -ge $this.MinDate -and $today -le $this.MaxDate) {
                        $this.Value = $today
                        $this._viewMonth = $today
                    }
                }
                default { $handled = $false }
            }
        }
        
        if ($handled) {
            if ($oldValue -ne $this.Value -and $this.OnChange) {
                try { & $this.OnChange $this $this.Value } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

#<!-- END_PAGE: ACO.008 -->

#<!-- PAGE: ACO.009 - ComboBoxComponent Class -->
# ===== CLASS: ComboBoxComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Dropdown with search and overlay rendering
class ComboBoxComponent : UIElement {
    [List[object]]$Items
    [int]$SelectedIndex = -1
    [string]$DisplayMember = ""
    [string]$ValueMember = ""
    [bool]$IsEditable = $false
    [string]$Text = ""
    [scriptblock]$OnSelectionChanged
    hidden [bool]$_isDropdownOpen = $false
    hidden [int]$_highlightedIndex = -1
    hidden [string]$_searchText = ""
    hidden [List[int]]$_filteredIndices
    
    ComboBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.Items = [List[object]]::new()
        $this._filteredIndices = [List[int]]::new()
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor("input.background")
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw main box
            if ($this.IsFocused) { 
                $borderColor = Get-ThemeColor("Primary") 
            } else { 
                $borderColor = Get-ThemeColor("component.border") 
            }
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = $borderColor; BG = $bgColor; BorderStyle = "Single" }
            
            # Draw selected text or placeholder
            $displayText = ""
            if ($this.IsEditable) {
                $displayText = $this._searchText
            }
            elseif ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
                $item = $this.Items[$this.SelectedIndex]
                $displayText = $this.GetDisplayText($item)
            }
            
            if ($displayText) { 
                $textColor = Get-ThemeColor("input.foreground") 
            } else { 
                $textColor = Get-ThemeColor("input.placeholder") 
            }
            
            $maxTextWidth = $this.Width - 4  # Border + dropdown arrow
            if ($displayText.Length -gt $maxTextWidth) {
                $displayText = $displayText.Substring(0, $maxTextWidth)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayText `
                -Style @{ FG = $textColor; BG = $bgColor }
            
            # Draw dropdown arrow
            if ($this._isDropdownOpen) { 
                $arrowChar = '' 
            } else { 
                $arrowChar = '' 
            }
            if ($this.IsFocused) { 
                $arrowColor = Get-ThemeColor("Accent") 
            } else { 
                $arrowColor = Get-ThemeColor("Subtle") 
            }
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new($arrowChar, $arrowColor, $bgColor))
            
            # Draw dropdown if open (as overlay)
            if ($this._isDropdownOpen) {
                $this.IsOverlay = $true
                $this.DrawDropdown()
            }
            else {
                $this.IsOverlay = $false
            }
        }
        catch {}
    }
    
    hidden [void] DrawDropdown() {
        $dropdownY = $this.Height
        $maxDropdownHeight = 10
        $dropdownHeight = [Math]::Min($this._filteredIndices.Count + 2, $maxDropdownHeight)
        
        if ($dropdownHeight -lt 3) { $dropdownHeight = 3 }  # Minimum height
        
        # Create dropdown buffer
        $dropdownBuffer = [TuiBuffer]::new($this.Width, $dropdownHeight)
        $dropdownBuffer.Name = "ComboDropdown"
        
        # Draw dropdown border
        Write-TuiBox -Buffer $dropdownBuffer -X 0 -Y 0 `
            -Width $this.Width -Height $dropdownHeight `
            -Style @{ BorderFG = Get-ThemeColor("component.border"); BG = Get-ThemeColor("input.background"); BorderStyle = "Single" }
        
        # Draw items
        $itemY = 1
        $maxItems = $dropdownHeight - 2
        $scrollOffset = 0
        
        if ($this._highlightedIndex -ge $maxItems) {
            $scrollOffset = $this._highlightedIndex - $maxItems + 1
        }
        
        for ($i = $scrollOffset; $i -lt $this._filteredIndices.Count -and $itemY -lt $dropdownHeight - 1; $i++) {
            $itemIndex = $this._filteredIndices[$i]
            $item = $this.Items[$itemIndex]
            $itemText = $this.GetDisplayText($item)
            
            $itemFg = Get-ThemeColor("list.item.normal")
            $itemBg = Get-ThemeColor("input.background")
            
            if ($i -eq $this._highlightedIndex) {
                $itemFg = Get-ThemeColor("list.item.selected")
                $itemBg = Get-ThemeColor("list.item.selected.background")
            }
            elseif ($itemIndex -eq $this.SelectedIndex) {
                $itemFg = Get-ThemeColor("Accent")
            }
            
            # Clear line and draw item
            for ($x = 1; $x -lt $this.Width - 1; $x++) {
                $dropdownBuffer.SetCell($x, $itemY, [TuiCell]::new(' ', $itemFg, $itemBg))
            }
            
            $maxTextWidth = $this.Width - 2
            if ($itemText.Length -gt $maxTextWidth) {
                $itemText = $itemText.Substring(0, $maxTextWidth - 3) + "..."
            }
            
            Write-TuiText -Buffer $dropdownBuffer -X 1 -Y $itemY -Text $itemText -Style @{ FG = $itemFg; BG = $itemBg }
            $itemY++
        }
        
        # Blend dropdown buffer with main buffer at dropdown position
        $absPos = $this.GetAbsolutePosition()
        $dropX = 0
        $dropY = $dropdownY
        
        for ($y = 0; $y -lt $dropdownBuffer.Height; $y++) {
            for ($x = 0; $x -lt $dropdownBuffer.Width; $x++) {
                $cell = $dropdownBuffer.GetCell($x, $y)
                if ($cell) {
                    $this._private_buffer.SetCell($dropX + $x, $dropY + $y, $cell)
                }
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        
        if (-not $this._isDropdownOpen) {
            switch ($key.Key) {
                ([ConsoleKey]::Enter) { 
                    $this.OpenDropdown()
                }
                ([ConsoleKey]::Spacebar) {
                    if (-not $this.IsEditable) {
                        $this.OpenDropdown()
                    }
                    else {
                        $handled = $false
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    $this.OpenDropdown()
                }
                default {
                    if ($this.IsEditable -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                        $this._searchText += $key.KeyChar
                        $this.OpenDropdown()
                        $this.FilterItems()
                    }
                    else {
                        $handled = $false
                    }
                }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.CloseDropdown()
                }
                ([ConsoleKey]::Enter) {
                    if ($this._highlightedIndex -ge 0 -and $this._highlightedIndex -lt $this._filteredIndices.Count) {
                        $this.SelectItem($this._filteredIndices[$this._highlightedIndex])
                        $this.CloseDropdown()
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    if ($this._highlightedIndex -gt 0) {
                        $this._highlightedIndex--
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this._highlightedIndex -lt $this._filteredIndices.Count - 1) {
                        $this._highlightedIndex++
                    }
                }
                ([ConsoleKey]::Home) {
                    $this._highlightedIndex = 0
                }
                ([ConsoleKey]::End) {
                    $this._highlightedIndex = $this._filteredIndices.Count - 1
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.IsEditable -and $this._searchText.Length -gt 0) {
                        $this._searchText = $this._searchText.Substring(0, $this._searchText.Length - 1)
                        $this.FilterItems()
                    }
                }
                default {
                    if ($this.IsEditable -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                        $this._searchText += $key.KeyChar
                        $this.FilterItems()
                    }
                    else {
                        $handled = $false
                    }
                }
            }
        }
        
        if ($handled) {
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    hidden [void] OpenDropdown() {
        $this._isDropdownOpen = $true
        $this.FilterItems()
        
        # Set highlighted index to selected item
        if ($this.SelectedIndex -ge 0) {
            for ($i = 0; $i -lt $this._filteredIndices.Count; $i++) {
                if ($this._filteredIndices[$i] -eq $this.SelectedIndex) {
                    $this._highlightedIndex = $i
                    break
                }
            }
        }
        
        if ($this._highlightedIndex -eq -1 -and $this._filteredIndices.Count -gt 0) {
            $this._highlightedIndex = 0
        }
    }
    
    hidden [void] CloseDropdown() {
        $this._isDropdownOpen = $false
        $this.IsOverlay = $false
        if (-not $this.IsEditable) {
            $this._searchText = ""
        }
    }
    
    hidden [void] FilterItems() {
        $this._filteredIndices.Clear()
        
        if ($this._searchText -eq "") {
            # Show all items
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                $this._filteredIndices.Add($i)
            }
        }
        else {
            # Filter items based on search text
            $searchLower = $this._searchText.ToLower()
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                $itemText = $this.GetDisplayText($this.Items[$i]).ToLower()
                if ($itemText.Contains($searchLower)) {
                    $this._filteredIndices.Add($i)
                }
            }
        }
        
        # Reset highlighted index
        if ($this._highlightedIndex -ge $this._filteredIndices.Count) {
            $this._highlightedIndex = $this._filteredIndices.Count - 1
        }
        if ($this._highlightedIndex -lt 0 -and $this._filteredIndices.Count -gt 0) {
            $this._highlightedIndex = 0
        }
    }
    
    hidden [void] SelectItem([int]$index) {
        $oldIndex = $this.SelectedIndex
        $this.SelectedIndex = $index
        
        if (-not $this.IsEditable) {
            $this.Text = $this.GetDisplayText($this.Items[$index])
        }
        
        if ($oldIndex -ne $index -and $this.OnSelectionChanged) {
            try { & $this.OnSelectionChanged $this $index } catch {}
        }
    }
    
    hidden [string] GetDisplayText([object]$item) {
        if ($null -eq $item) { return "" }
        
        if ($this.DisplayMember -and $item.PSObject.Properties[$this.DisplayMember]) {
            return $item.$($this.DisplayMember).ToString()
        }
        
        return $item.ToString()
    }
}

#<!-- END_PAGE: ACO.009 -->

#<!-- PAGE: ACO.010 - Table Class -->
# ===== CLASS: Table =====
# Module: advanced-data-components
# Dependencies: UIElement, TuiCell
# Purpose: High-performance data grid with virtual scrolling
class Table : UIElement {
    [List[PSObject]]$Items
    [List[string]]$Columns
    [hashtable]$ColumnWidths
    [int]$SelectedIndex = -1
    [bool]$ShowHeader = $true
    [bool]$ShowBorder = $true
    [bool]$AllowSelection = $true
    [scriptblock]$OnSelectionChanged
    hidden [int]$_scrollOffset = 0
    hidden [int]$_horizontalScroll = 0
    
    Table([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[PSObject]]::new()
        $this.Columns = [List[string]]::new()
        $this.ColumnWidths = @{}
        $this.Width = 80
        $this.Height = 20
    }
    
    [void] SetColumns([string[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
            if (-not $this.ColumnWidths.ContainsKey($col)) {
                $this.ColumnWidths[$col] = 15  # Default width
            }
        }
    }
    
    [void] AutoSizeColumns() {
        foreach ($col in $this.Columns) {
            $maxWidth = $col.Length
            
            foreach ($item in $this.Items) {
                if ($item.PSObject.Properties[$col]) {
                    $val = $item.$col
                    if ($null -ne $val) {
                        $len = $val.ToString().Length
                        if ($len -gt $maxWidth) {
                            $maxWidth = $len
                        }
                    }
                }
            }
            
            $this.ColumnWidths[$col] = [Math]::Min($maxWidth + 2, 30)  # Cap at 30
        }
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor("component.background")
            $fgColor = Get-ThemeColor("Foreground")
            if ($this.IsFocused) { 
                $borderColor = Get-ThemeColor("Primary") 
            } else { 
                $borderColor = Get-ThemeColor("component.border") 
            }
            $headerBg = Get-ThemeColor("list.header.bg")
            $selectedBg = Get-ThemeColor("list.item.selected.background")
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            $contentX = 0
            $contentY = 0
            $contentWidth = $this.Width
            $contentHeight = $this.Height
            
            # Draw border if enabled
            if ($this.ShowBorder) {
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                    -Width $this.Width -Height $this.Height `
                    -Style @{ BorderFG = $borderColor; BG = $bgColor; BorderStyle = "Single" }
                
                $contentX = 1
                $contentY = 1
                $contentWidth = $this.Width - 2
                $contentHeight = $this.Height - 2
            }
            
            $currentY = $contentY
            $dataStartY = $contentY
            
            # Draw header if enabled
            if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
                $this.DrawHeader($contentX, $currentY, $contentWidth, $headerBg)
                $currentY++
                $dataStartY++
                
                # Draw separator line
                for ($x = $contentX; $x -lt $contentX + $contentWidth; $x++) {
                    $this._private_buffer.SetCell($x, $currentY, [TuiCell]::new('-', $borderColor, $bgColor))
                }
                $currentY++
                $dataStartY++
            }
            
            # Calculate visible rows
            $visibleRows = $contentHeight - ($dataStartY - $contentY)
            if ($visibleRows -le 0) { return }
            
            # Adjust scroll offset to keep selection visible
            if ($this.AllowSelection -and $this.SelectedIndex -ge 0) {
                if ($this.SelectedIndex -lt $this._scrollOffset) {
                    $this._scrollOffset = $this.SelectedIndex
                }
                elseif ($this.SelectedIndex -ge $this._scrollOffset + $visibleRows) {
                    $this._scrollOffset = $this.SelectedIndex - $visibleRows + 1
                }
            }
            
            # Draw data rows
            for ($i = 0; $i -lt $visibleRows; $i++) {
                $itemIndex = $i + $this._scrollOffset
                if ($itemIndex -ge $this.Items.Count) { break }
                
                $item = $this.Items[$itemIndex]
                $rowBg = $bgColor
                $rowFg = $fgColor
                
                if ($this.AllowSelection -and $itemIndex -eq $this.SelectedIndex) {
                    $rowBg = $selectedBg
                    $rowFg = Get-ThemeColor("list.item.selected")
                }
                
                $this.DrawRow($item, $contentX, $currentY, $contentWidth, $rowFg, $rowBg)
                $currentY++
            }
            
            # Draw scrollbar if needed
            if ($this.Items.Count -gt $visibleRows) {
                $this.DrawScrollbar($contentX + $contentWidth - 1, $dataStartY, $visibleRows)
            }
        }
        catch {}
    }
    
    hidden [void] DrawHeader([int]$x, [int]$y, [int]$maxWidth, [string]$headerBg) {
        $currentX = $x - $this._horizontalScroll
        
        foreach ($col in $this.Columns) {
            $colWidth = $this.ColumnWidths[$col]
            
            if ($currentX + $colWidth -gt $x) {
                $visibleStart = [Math]::Max(0, $x - $currentX)
                $visibleWidth = [Math]::Min($colWidth - $visibleStart, $maxWidth - ($currentX - $x))
                
                if ($visibleWidth -gt 0) {
                    $headerText = $col
                    if ($headerText.Length -gt $visibleWidth) {
                        $headerText = $headerText.Substring(0, $visibleWidth - 1) + ">"
                    }
                    else {
                        $headerText = $headerText.PadRight($visibleWidth)
                    }
                    
                    $drawX = [Math]::Max($x, $currentX)
                    Write-TuiText -Buffer $this._private_buffer -X $drawX -Y $y -Text $headerText -Style @{ FG = Get-ThemeColor("list.header.fg"); BG = $headerBg }
                }
            }
            
            $currentX += $colWidth
            if ($currentX -ge $x + $maxWidth) { break }
        }
    }
    
    hidden [void] DrawRow([PSObject]$item, [int]$x, [int]$y, [int]$maxWidth, [string]$fg, [string]$bg) {
        # Clear row first
        for ($i = 0; $i -lt $maxWidth; $i++) {
            $this._private_buffer.SetCell($x + $i, $y, [TuiCell]::new(' ', $fg, $bg))
        }
        
        $currentX = $x - $this._horizontalScroll
        
        foreach ($col in $this.Columns) {
            $colWidth = $this.ColumnWidths[$col]
            
            if ($currentX + $colWidth -gt $x) {
                $value = ""
                if ($item.PSObject.Properties[$col]) {
                    $val = $item.$col
                    if ($null -ne $val) {
                        $value = $val.ToString()
                    }
                }
                
                $visibleStart = [Math]::Max(0, $x - $currentX)
                $visibleWidth = [Math]::Min($colWidth - $visibleStart, $maxWidth - ($currentX - $x))
                
                if ($visibleWidth -gt 0) {
                    if ($value.Length -gt $visibleWidth - 1) {
                        $value = $value.Substring(0, $visibleWidth - 2) + ".."
                    }
                    
                    $drawX = [Math]::Max($x, $currentX)
                    Write-TuiText -Buffer $this._private_buffer -X $drawX -Y $y -Text $value -Style @{ FG = $fg; BG = $bg }
                }
            }
            
            $currentX += $colWidth
            if ($currentX -ge $x + $maxWidth) { break }
        }
    }
    
    hidden [void] DrawScrollbar([int]$x, [int]$y, [int]$height) {
        $scrollbarHeight = [Math]::Max(1, [int]($height * $height / $this.Items.Count))
        $scrollbarPos = [int](($height - $scrollbarHeight) * $this._scrollOffset / ($this.Items.Count - $height))
        
        $scrollbarColor = Get-ThemeColor("list.scrollbar")
        $bgColor = Get-ThemeColor("component.background")
        
        for ($i = 0; $i -lt $height; $i++) {
            $char = if ($i -ge $scrollbarPos -and $i -lt $scrollbarPos + $scrollbarHeight) { '' } else { '' }
            $this._private_buffer.SetCell($x, $y + $i, [TuiCell]::new($char, $scrollbarColor, $bgColor))
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or -not $this.AllowSelection) { return $false }
        
        $handled = $true
        $oldSelection = $this.SelectedIndex
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                }
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
            }
            ([ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 4  # Account for border and header
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
            }
            ([ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 4
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this._horizontalScroll -gt 0) {
                    $this._horizontalScroll = [Math]::Max(0, $this._horizontalScroll - 5)
                }
            }
            ([ConsoleKey]::RightArrow) {
                $totalWidth = 0
                foreach ($col in $this.Columns) {
                    $totalWidth += $this.ColumnWidths[$col]
                }
                $maxScroll = [Math]::Max(0, $totalWidth - $this.Width + 2)
                $this._horizontalScroll = [Math]::Min($maxScroll, $this._horizontalScroll + 5)
            }
            default {
                $handled = $false
            }
        }
        
        if ($handled) {
            if ($oldSelection -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                try { & $this.OnSelectionChanged $this $this.SelectedIndex } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

#endregion Advanced Components

#region Panel Components

#<!-- END_PAGE: ACO.010 -->

#<!-- PAGE: ACO.011 - Panel Class -->
# ===== CLASS: Panel =====
# Module: panels-class
# Dependencies: UIElement, TuiCell
# Purpose: Container with layout management
class Panel : UIElement {
    [string]$Title = ""
    [string]$BorderStyle = "Single"
    [string]$BorderColor = "#808080"     # FIXED: Changed from ConsoleColor to hex string
    [string]$BackgroundColor = "#000000" # FIXED: Changed from ConsoleColor to hex string
    [bool]$HasBorder = $true
    [string]$LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid
    [int]$Padding = 0
    [int]$Spacing = 1
    
    # Content area properties
    [int]$ContentX = 1
    [int]$ContentY = 1
    [int]$ContentWidth = 0
    [int]$ContentHeight = 0

    Panel([string]$name) : base($name) {
        $this.IsFocusable = $false
        # Set reasonable defaults
        if ($this.Width -eq 0) { $this.Width = 30 }
        if ($this.Height -eq 0) { $this.Height = 10 }
        # Calculate initial content dimensions
        $this.UpdateContentDimensions()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor("component.background")
            $bgCell = [TuiCell]::new(' ', $bgColor, $bgColor)
            $this._private_buffer.Clear($bgCell)

            # Update content area dimensions
            $this.UpdateContentDimensions()

            if ($this.HasBorder) {
                if ($this.IsFocused) { 
                    $borderColorValue = Get-ThemeColor("Primary") 
                } else { 
                    $borderColorValue = Get-ThemeColor("component.border") 
                }
                
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                    -Width $this.Width -Height $this.Height `
                    -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = $this.BorderStyle; TitleFG = Get-ThemeColor("component.title") } `
                    -Title $this.Title
            }

            # Apply layout to children
            $this.ApplyLayout()
        }
        catch {}
    }

    [void] ApplyLayout() {
        if ($this.LayoutType -eq "Manual") { return }

        if ($this.HasBorder) { 
            $layoutX = 1 + $this.Padding 
        } else { 
            $layoutX = $this.Padding 
        }
        if ($this.HasBorder) { 
            $layoutY = 1 + $this.Padding 
        } else { 
            $layoutY = $this.Padding 
        }
        $layoutWidth = [Math]::Max(0, $this.Width - (2 * $layoutX))
        $layoutHeight = [Math]::Max(0, $this.Height - (2 * $layoutY))

        $visibleChildren = @($this.Children | Where-Object { $_.Visible })
        if ($visibleChildren.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" {
                $currentY = $layoutY
                foreach ($child in $visibleChildren) {
                    $child.X = $layoutX
                    $child.Y = $currentY
                    $child.Width = [Math]::Min($child.Width, $layoutWidth)
                    $currentY += $child.Height + $this.Spacing
                }
            }
            "Horizontal" {
                $currentX = $layoutX
                foreach ($child in $visibleChildren) {
                    $child.X = $currentX
                    $child.Y = $layoutY
                    $child.Height = [Math]::Min($child.Height, $layoutHeight)
                    $currentX += $child.Width + $this.Spacing
                }
            }
            "Grid" {
                # Simple grid layout - arrange in rows
                $cols = [Math]::Max(1, [Math]::Floor($layoutWidth / 20))  # Assume 20 char min width
                $col = 0
                $row = 0
                $cellWidth = [Math]::Max(1, [Math]::Floor($layoutWidth / $cols))
                $cellHeight = 3  # Default height
                
                foreach ($child in $visibleChildren) {
                    $child.X = $layoutX + ($col * $cellWidth)
                    $child.Y = $layoutY + ($row * ($cellHeight + $this.Spacing))
                    $child.Width = [Math]::Max(1, $cellWidth - $this.Spacing)
                    $child.Height = $cellHeight
                    
                    $col++
                    if ($col -ge $cols) {
                        $col = 0
                        $row++
                    }
                }
            }
        }
    }

    [hashtable] GetContentArea() {
        $area = @{
            X = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
            Y = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
        }
        $area.Width = [Math]::Max(0, $this.Width - (2 * $area.X))
        $area.Height = [Math]::Max(0, $this.Height - (2 * $area.Y))
        return $area
    }
    
    # New method to update content dimensions
    [void] UpdateContentDimensions() {
        $this.ContentX = if ($this.HasBorder) { 1 } else { 0 }
        $this.ContentY = if ($this.HasBorder) { 1 } else { 0 }
        $borderOffset = if ($this.HasBorder) { 2 } else { 0 }
        $this.ContentWidth = [Math]::Max(0, $this.Width - $borderOffset)
        $this.ContentHeight = [Math]::Max(0, $this.Height - $borderOffset)
    }
    
    # Override Resize to update content dimensions
    [void] OnResize() {
        $this.UpdateContentDimensions()
        ([UIElement]$this).OnResize()
    }
}

#<!-- END_PAGE: ACO.011 -->

#<!-- PAGE: ACO.012 - ScrollablePanel Class -->
# ===== CLASS: ScrollablePanel =====
# Module: panels-class
# Dependencies: Panel, TuiCell
# Purpose: Panel with scrolling capabilities
class ScrollablePanel : Panel {
    [int]$ScrollOffsetY = 0
    [int]$MaxScrollY = 0
    [bool]$ShowScrollbar = $true
    hidden [int]$_contentHeight = 0 # This will be the virtual content height
    hidden [TuiBuffer]$_virtual_buffer = $null # NEW: To hold the entire scrollable content

    ScrollablePanel([string]$name) : base($name) {
        $this.IsFocusable = $true
        # Initialize _virtual_buffer with initial dimensions. Will be resized later based on content.
        # Start with max possible height or a reasonable large value, will grow as children are added
        $this.{_virtual_buffer} = [TuiBuffer]::new($this.Width, 1000, "$($this.Name).Virtual") 
    }

    # Override OnResize to ensure virtual buffer matches actual content area needs
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Call base Panel resize, which updates Width, Height, and _private_buffer
        ([Panel]$this).Resize($newWidth, $newHeight) 

        # Ensure the virtual buffer is wide enough for the content area
        $targetVirtualWidth = $this.ContentWidth 
        if ($this.{_virtual_buffer}.Width -ne $targetVirtualWidth) {
            $this.{_virtual_buffer}.Resize($targetVirtualWidth, $this.{_virtual_buffer}.Height) # Only resize width for now
        }
        $this.UpdateMaxScroll() # Recalculate max scroll on resize
        $this.RequestRedraw()
    }

    # Override _RenderContent to implement virtual scrolling logic
    hidden [void] _RenderContent() {
        # 1. First, render the base Panel. This clears its own _private_buffer and draws borders/title.
        # This implicitly calls ([Panel]$this).OnRender()
        ([Panel]$this)._RenderContent()

        # 2. Render all children onto the _virtual_buffer
        $this.{_virtual_buffer}.Clear([TuiCell]::new(' ', $this.BackgroundColor, $this.BackgroundColor)) # Clear virtual buffer
        
        $actualContentBottom = 0
        foreach ($child in $this.Children | Sort-Object ZIndex) {
            if ($child.Visible) {
                # Render each child to its own private buffer
                $child.Render() 
                if ($null -ne $child._private_buffer) {
                    # Blend child's buffer onto our _virtual_buffer at its original coordinates
                    # (relative to the panel's content area)
                    $this.{_virtual_buffer}.BlendBuffer($child._private_buffer, $child.X - $this.ContentX, $child.Y - $this.ContentY)
                }
                # Track the maximum vertical extent of children to determine virtual height
                $childExtent = ($child.Y - $this.ContentY) + $child.Height
                if ($childExtent -gt $actualContentBottom) {
                    $actualContentBottom = $childExtent
                }
            }
        }
        $this._contentHeight = $actualContentBottom # Update actual content height

        # 3. Update MaxScrollY and clamp ScrollOffsetY
        $this.UpdateMaxScroll()

        # 4. Extract the visible portion from _virtual_buffer and blend it onto _private_buffer
        #    This accounts for the scroll offset when drawing to screen.
        $viewportWidth = $this.ContentWidth
        $viewportHeight = $this.ContentHeight
        
        # Ensure target size for sub-buffer is positive
        $viewportWidth = [Math]::Max(1, $viewportWidth)
        $viewportHeight = [Math]::Max(1, $viewportHeight)

        $sourceX = 0 # No horizontal scrolling for now, but easily extendable
        $sourceY = $this.ScrollOffsetY
        
        # Get sub-buffer, ensure it's not trying to read beyond virtual buffer bounds
        $effectiveSourceHeight = [Math]::Min($viewportHeight, $this.{_virtual_buffer}.Height - $sourceY)
        if ($effectiveSourceHeight -le 0) {
            # No content to display in viewport
            # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': No effective content for viewport."
            return
        }

        $visiblePortion = $this.{_virtual_buffer}.GetSubBuffer($sourceX, $sourceY, $viewportWidth, $effectiveSourceHeight)
        
        # Blend the visible portion onto our own _private_buffer, at the content area
        $this.{_private_buffer}.BlendBuffer($visiblePortion, $this.ContentX, $this.ContentY)

        # 5. Draw scrollbar if needed (uses _private_buffer and current ScrollOffsetY)
        if ($this.ShowScrollbar -and $this.MaxScrollY -gt 0) {
            $this.DrawScrollbar()
        }

        $this._needs_redraw = $false
    }

    # Helper method to calculate MaxScrollY and clamp ScrollOffsetY
    [void] UpdateMaxScroll() {
        $viewportHeight = $this.ContentHeight # Use ContentHeight as the available rendering area
        
        # Ensure virtual buffer height is at least content height
        $currentVirtualHeight = $this.{_virtual_buffer}.Height
        $newVirtualHeight = [Math]::Max($currentVirtualHeight, $this._contentHeight)
        if ($newVirtualHeight -ne $currentVirtualHeight) {
            $this.{_virtual_buffer}.Resize($this.{_virtual_buffer}.Width, $newVirtualHeight)
            # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': Resized virtual buffer height to $newVirtualHeight."
        }

        $this.MaxScrollY = [Math]::Max(0, $this._contentHeight - $viewportHeight)
        $this.ScrollOffsetY = [Math]::Max(0, [Math]::Min($this.ScrollOffsetY, $this.MaxScrollY))
        # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': ContentHeight=$($this._contentHeight), ViewportHeight=$($viewportHeight), MaxScrollY=$($this.MaxScrollY), ScrollOffsetY=$($this.ScrollOffsetY)."
    }

    # Keep DrawScrollbar, HandleInput, ScrollUp/Down/PageUp/Down/ToTop/Bottom methods.
    # Ensure DrawScrollbar uses the correct ScrollOffsetY, MaxScrollY, and _contentHeight for calculations.
    # Update SetCell calls in DrawScrollbar to use hex colors.
    [void] DrawScrollbar() {
        $scrollbarX = $this.Width - 1
        if ($this.HasBorder) { 
            $scrollbarY = 1 
        } else { 
            $scrollbarY = 0 
        }
        if ($this.HasBorder) { 
            $scrollbarTrackHeight = $this.Height - 2 
        } else { 
            $scrollbarTrackHeight = $this.Height - 0 
        }

        if ($this._contentHeight -le $scrollbarTrackHeight) { 
            # If content fits, clear any previous scrollbar
            $bgColor = Get-ThemeColor "Background"
            for ($i = 0; $i -lt $scrollbarTrackHeight; $i++) {
                $this.{_private_buffer}.SetCell($scrollbarX, $scrollbarY + $i, [TuiCell]::new(' ', $bgColor, $bgColor))
            }
            return 
        } 

        $scrollFg = Get-ThemeColor "list.scrollbar"
        $scrollBg = Get-ThemeColor "Background"

        # Calculate thumb size and position
        $thumbSize = [Math]::Max(1, [int]($scrollbarTrackHeight * $scrollbarTrackHeight / $this._contentHeight))
        $thumbPos = [int](($scrollbarTrackHeight - $thumbSize) * $this.ScrollOffsetY / $this.MaxScrollY)
        
        for ($i = 0; $i -lt $scrollbarTrackHeight; $i++) {
            $y = $scrollbarY + $i
            $char = '' # Default track character
            
            if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) {
                $char = '' # Thumb character
            }
            $this.{_private_buffer}.SetCell($scrollbarX, $y, [TuiCell]::new($char, $scrollFg, $scrollBg))
        }
    }

    # Ensure other scrolling methods call RequestRedraw and UpdateMaxScroll
    [void] ScrollUp([int]$lines = 1) {
        $oldScroll = $this.ScrollOffsetY
        $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY - $lines)
        if ($this.ScrollOffsetY -ne $oldScroll) {
            $this.RequestRedraw()
            # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': Scrolled up to $($this.ScrollOffsetY)."
        }
    }

    [void] ScrollDown([int]$lines = 1) {
        $oldScroll = $this.ScrollOffsetY
        $this.ScrollOffsetY = [Math]::Min($this.MaxScrollY, $this.ScrollOffsetY + $lines)
        if ($this.ScrollOffsetY -ne $oldScroll) {
            $this.RequestRedraw()
            # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': Scrolled down to $($this.ScrollOffsetY)."
        }
    }

    [void] ScrollPageUp() {
        $pageSize = $this.ContentHeight
        $this.ScrollUp($pageSize)
    }

    [void] ScrollPageDown() {
        $pageSize = $this.ContentHeight
        $this.ScrollDown($pageSize)
    }

    [void] ScrollToTop() {
        $oldScroll = $this.ScrollOffsetY
        $this.ScrollOffsetY = 0
        if ($this.ScrollOffsetY -ne $oldScroll) {
            $this.RequestRedraw()
            # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': Scrolled to top."
        }
    }

    [void] ScrollToBottom() {
        $oldScroll = $this.ScrollOffsetY
        $this.ScrollOffsetY = $this.MaxScrollY
        if ($this.ScrollOffsetY -ne $oldScroll) {
            $this.RequestRedraw()
            # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': Scrolled to bottom."
        }
    }
}

#<!-- END_PAGE: ACO.012 -->

#<!-- PAGE: ACO.013 - GroupPanel Class -->
# ===== CLASS: GroupPanel =====
# Module: panels-class
# Dependencies: Panel
# Purpose: Themed panel for grouping
class GroupPanel : Panel {
    [bool]$IsExpanded = $true
    [bool]$CanCollapse = $true

    GroupPanel([string]$name) : base($name) {
        $this.BorderStyle = "Double"
        $this.BorderColor = "#008B8B"     # FIXED: DarkCyan in hex
        $this.BackgroundColor = "#000000" # FIXED: Black in hex
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Show children only if expanded
        foreach ($child in $this.Children) {
            $child.Visible = $this.IsExpanded
        }

        # Adjust height if collapsed
        if (-not $this.IsExpanded -and $this.CanCollapse) {
            $this._originalHeight = $this.Height
            $this.Height = 3  # Just title bar
        }
        elseif ($this.IsExpanded -and $this._originalHeight) {
            $this.Height = $this._originalHeight
        }

        # Add expand/collapse indicator to title
        if ($this.CanCollapse -and $this.Title) {
            $indicator = if ($this.IsExpanded) { "[-]" } else { "[+]" }
            $this.Title = "$indicator $($this.Title.TrimStart('[+]', '[-]').Trim())"
        }

        ([Panel]$this).OnRender()
    }

    hidden [int]$_originalHeight = 0

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or -not $this.CanCollapse) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar) {
            $this.Toggle()
            return $true
        }
        
        return $false
    }

    [void] Toggle() {
        $this.IsExpanded = -not $this.IsExpanded
        $this.RequestRedraw()
    }
}

#endregion Panel Components

#region Composite Components

#<!-- END_PAGE: ACO.013 -->

#<!-- PAGE: ACO.014 - ListBox Class -->
# ===== CLASS: ListBox =====
# Module: tui-components (wrapper)
# Dependencies: UIElement, TuiCell
# Purpose: Scrollable item list with selection
class ListBox : UIElement {
    [List[object]]$Items
    [int]$SelectedIndex = -1
    [string]$ForegroundColor = "#FFFFFF" # Changed from ConsoleColor to hex string
    [string]$BackgroundColor = "#000000" # Changed from ConsoleColor to hex string
    [string]$SelectedForegroundColor = "#000000" # Changed from ConsoleColor to hex string
    [string]$SelectedBackgroundColor = "#00FFFF" # Changed from ConsoleColor to hex string
    [string]$BorderColor = "#808080" # Changed from ConsoleColor to hex string
    hidden [int]$ScrollOffset = 0

    ListBox([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[object]]::new()
        $this.Width = 30
        $this.Height = 10
    }

    [void] AddItem([object]$item) {
        $this.Items.Add($item)
        if ($this.SelectedIndex -eq -1 -and $this.Items.Count -eq 1) {
            $this.SelectedIndex = 0
        }
        $this.RequestRedraw()
    }

    [void] ClearItems() {
        $this.Items.Clear()
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.RequestRedraw()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Draw border
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
            -Style @{ BorderFG = Get-ThemeColor("component.border"); BG = $bgColor; BorderStyle = "Single" }
            
            # Calculate visible area
            $contentY = 1
            $contentHeight = $this.Height - 2
            $contentX = 1
            $contentWidth = $this.Width - 2
            
            # Ensure selected item is visible
            $this.EnsureVisible($this.SelectedIndex)
            
            # Draw items
            for ($i = 0; $i -lt $contentHeight -and ($i + $this.ScrollOffset) -lt $this.Items.Count; $i++) {
                $itemIndex = $i + $this.ScrollOffset
                $item = $this.Items[$itemIndex]
                if ($item -is [string]) { 
                    $itemText = $item 
                } else { 
                    $itemText = $item.ToString() 
                }
                
                if ($itemText.Length -gt $contentWidth) {
                    $itemText = $itemText.Substring(0, $contentWidth - 3) + "..."
                }
                
                $isSelected = ($itemIndex -eq $this.SelectedIndex)
                if ($isSelected) { 
                    $fgColor = Get-ThemeColor("list.item.selected") 
                } else { 
                    $fgColor = Get-ThemeColor("list.item.normal") 
                }
                if ($isSelected) { 
                    $itemBgColor = Get-ThemeColor("list.item.selected.background") 
                } else { 
                    $itemBgColor = $bgColor 
                }
                
                # Draw item background
                $this._private_buffer.FillRect(1, $contentY + $i, $this.Width - 2, 1, ' ', @{ BG = $itemBgColor })
                
                # Draw item text
                Write-TuiText -Buffer $this._private_buffer -X $contentX -Y ($contentY + $i) -Text $itemText `
                    -Style @{ FG = $fgColor; BG = $itemBgColor }
            }
            
            # Draw scrollbar if needed
            if ($this.Items.Count -gt $contentHeight) {
                $scrollbarX = $this.Width - 2
                $scrollbarHeight = $contentHeight
                $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $scrollbarHeight / $this.Items.Count))
                $thumbPos = if ($this.Items.Count -gt $scrollbarHeight) {
                    [int](($scrollbarHeight - $thumbSize) * $this.ScrollOffset / ($this.Items.Count - $scrollbarHeight))
                } else { 0 }
                
                $scrollbarColor = Get-ThemeColor "list.scrollbar"
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { '' } else { '' }
                    $this._private_buffer.SetCell($scrollbarX, $contentY + $i, 
                        [TuiCell]::new($char, $scrollbarColor, $bgColor))
                }
            }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $true
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                }
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
            }
            ([ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 2
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
            }
            ([ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 2
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
            }
            default {
                $handled = $false
            }
        }
        
        if ($handled) {
            $this.RequestRedraw()
        }
        
        return $handled
    }

    [void] EnsureVisible([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Items.Count) { return }
        
        $visibleHeight = $this.Height - 2
        
        if ($index -lt $this.ScrollOffset) {
            $this.ScrollOffset = $index
        }
        elseif ($index -ge $this.ScrollOffset + $visibleHeight) {
            $this.ScrollOffset = $index - $visibleHeight + 1
        }
    }
}

#<!-- END_PAGE: ACO.014 -->

#<!-- PAGE: ACO.015 - TextBox Class -->
# ===== CLASS: TextBox =====
# Module: tui-components (wrapper)
# Dependencies: TextBoxComponent
# Purpose: Enhanced wrapper around TextBoxComponent

class TextBox : UIElement {
    hidden [TextBoxComponent]$_textBox

    TextBox([string]$name) : base($name) {
        $this._textBox = [TextBoxComponent]::new($name + "_inner")
        # CRITICAL FIX: Immediately size the inner component to match the wrapper's current size.
        $this._textBox.Resize($this.Width, $this.Height)
        $this.AddChild($this._textBox)
        $this.IsFocusable = $true
    }

    [string] GetText() { return $this._textBox.Text }
    [void] SetText([string]$value) { $this._textBox.Text = $value }
    
    [void] Clear() {
        $this._textBox.Text = ""
        $this._textBox.CursorPosition = 0
        $this._textBox.RequestRedraw()
    }

    [void] Focus() {
        $focusManager = $global:TuiState.Services.FocusManager
        if ($focusManager) {
            $focusManager.SetFocus($this)
        }
    }

    [void] OnFocus() {
        ([UIElement]$this).OnFocus()
        if ($this._textBox) {
            $this._textBox.IsFocused = $true
            $this._textBox.OnFocus()
            $this._textBox.RequestRedraw()
        }
    }

    [void] OnBlur() {
        ([UIElement]$this).OnBlur()
        if ($this._textBox) {
            $this._textBox.IsFocused = $false
            $this._textBox.OnBlur()
            $this._textBox.RequestRedraw()
        }
    }

    [void] OnResize() {
        if ($this._textBox) {
            $this._textBox.Width = $this.Width
            $this._textBox.Height = $this.Height
            $this._textBox.X = 0
            $this._textBox.Y = 0
            # Ensure the inner component's buffer is also resized.
            $this._textBox.Resize($this.Width, $this.Height)
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $this._textBox.HandleInput($key)
    }
}

#<!-- END_PAGE: ACO.015 -->

#<!-- PAGE: ACO.016 - CommandPalette Class -->
# ===== CLASS: CommandPalette =====
# Module: command-palette
# Dependencies: UIElement, Panel, ListBox, TextBoxComponent
# Purpose: Searchable command interface - FINAL FIXED VERSION
class CommandPalette : UIElement {
    hidden [ListBox]$_listBox
    hidden [TextBoxComponent]$_searchBox
    hidden [Panel]$_panel
    hidden [List[object]]$_allActions
    hidden [List[object]]$_filteredActions
    hidden [object]$_actionService
    hidden [scriptblock]$OnCancel
    hidden [scriptblock]$OnSelect

    CommandPalette([string]$name, [object]$actionService) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 60
        $this.Height = 20
        $this._actionService = $actionService
        
        $this.Initialize()
    }

    hidden [void] Initialize() {
        $this._panel = [Panel]::new("CommandPalette_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.Title = " Command Palette "
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this.AddChild($this._panel)

        $this._searchBox = [TextBoxComponent]::new("CommandPalette_Search")
        $this._searchBox.X = 2
        $this._searchBox.Y = 1
        $this._searchBox.Width = $this.Width - 4
        $this._searchBox.Height = 3
        $this._searchBox.Placeholder = "Type to search commands..."
        
        $paletteRef = $this
        $this._searchBox.OnChange = { param($sender, $text) $paletteRef.FilterActions($text) }.GetNewClosure()
        $this._panel.AddChild($this._searchBox)

        $this._listBox = [ListBox]::new("CommandPalette_List")
        $this._listBox.X = 2
        $this._listBox.Y = 4
        $this._listBox.Width = $this.Width - 4
        $this._listBox.Height = $this.Height - 6
        $this._panel.AddChild($this._listBox)

        $this._allActions = [List[object]]::new()
        $this._filteredActions = [List[object]]::new()
    }

    [void] Show() {
        $consoleWidth = $global:TuiState.BufferWidth
        $consoleHeight = $global:TuiState.BufferHeight
        $this.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $this.Width) / 2))
        $this.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $this.Height) / 2))
        
        $this.RefreshActions()
        $this._searchBox.Text = ""
        $this._searchBox.CursorPosition = 0
        $this.FilterActions("")
        $this.Visible = $true
        
        if (-not $global:TuiState.OverlayStack.Contains($this)) {
            $global:TuiState.OverlayStack.Add($this)
        }
        
        $global:TuiState.Services.FocusManager?.SetFocus($this._searchBox)
        $global:TuiState.IsDirty = $true
    }

    [void] Hide() {
        $this.Visible = $false
        if ($global:TuiState.OverlayStack.Contains($this)) {
            $global:TuiState.OverlayStack.Remove($this)
        }
        $global:TuiState.Services.FocusManager?.ReleaseFocus()
        $global:TuiState.IsDirty = $true
        if ($this.OnCancel) { & $this.OnCancel }
    }

    [void] RefreshActions() {
        $this._allActions.Clear()
        if ($this._actionService) {
            $this._allActions.AddRange(($this._actionService.GetAllActions().Values | Sort-Object Category, Name))
        }
    }

    [void] FilterActions([string]$searchText) {
        $this._filteredActions.Clear()
        $this._listBox.ClearItems()
        
        $actionsToDisplay = if ([string]::IsNullOrWhiteSpace($searchText)) { $this._allActions } else {
            $searchLower = $searchText.ToLower()
            @($this._allActions | Where-Object {
                $_.Name.ToLower().Contains($searchLower) -or
                ($_.Description -and $_.Description.ToLower().Contains($searchLower)) -or
                ($_.Category -and $_.Category.ToLower().Contains($searchLower))
            })
        }

        foreach ($action in $actionsToDisplay) {
            $this._filteredActions.Add($action)
            $displayText = if ($action.Category) { "[$($action.Category)] $($action.Name)" } else { $action.Name }
            $this._listBox.AddItem("$displayText - $($action.Description)")
        }
        
        if ($this._filteredActions.Count -gt 0) { $this._listBox.SelectedIndex = 0 }
        $this.RequestRedraw()
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        switch ($key.Key) {
            ([ConsoleKey]::Escape) { $this.Hide(); return $true }
            ([ConsoleKey]::Enter) {
                if ($this._listBox.SelectedIndex -ge 0 -and $this._listBox.SelectedIndex -lt $this._filteredActions.Count) {
                    $selectedAction = $this._filteredActions[$this._listBox.SelectedIndex]
                    if ($selectedAction) {
                        $this.Hide()
                        $this._actionService.ExecuteAction($selectedAction.Name, @{})
                    }
                }
                return $true # Consume enter even if no action taken
            }
            {$_ -in @([ConsoleKey]::UpArrow, [ConsoleKey]::DownArrow, [ConsoleKey]::PageUp, [ConsoleKey]::PageDown, [ConsoleKey]::Home, [ConsoleKey]::End)} {
                return $this._listBox.HandleInput($key)
            }
            default { return $false }
        }
        return $false # Ensure all code paths return a value
    }
}

#endregion Composite Components

#region Dialog Components

#<!-- END_PAGE: ACO.016 -->

#<!-- PAGE: ACO.017 - Dialog Class -->
# ===== CLASS: Dialog =====
# Module: dialog-system-class
# Dependencies: UIElement, Panel
# Purpose: Base class for modal dialogs
class Dialog : UIElement {
    [string]$Title = ""
    [string]$Message = ""
    hidden [Panel]$_panel
    hidden [object]$Result = $null
    hidden [bool]$_isComplete = $false
    [scriptblock]$OnClose
    [DialogResult]$DialogResult = [DialogResult]::None

    Dialog([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 50
        $this.Height = 10
        
        $this.InitializeDialog()
    }

    hidden [void] InitializeDialog() {
        $this._panel = [Panel]::new($this.Name + "_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.BorderColor = "#00FFFF"    # FIXED: Use hex string for border
        $this._panel.BackgroundColor = "#000000" # FIXED: Use hex string for background
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this.AddChild($this._panel)
    }

    [void] Show([string]$title, [string]$message) {
        $this.Title = $title
        $this.Message = $message
        $this._panel.Title = " $title "
        $this._isComplete = $false
        $this.Result = $null
        $this.Visible = $true
        $this.RequestRedraw()
    }

    # Renamed from Close to Complete to match guide
    [void] Complete([object]$result) {
        $this.Result = $result
        $this._isComplete = $true
        
        # Call the OnClose scriptblock if provided
        if ($this.OnClose) {
            try { 
                & $this.OnClose $result 
            } catch { 
                # Write-Log -Level Warning -Message "Dialog '$($this.Name)': Error in OnClose callback: $($_.Exception.Message)" 
            }
        }
        
        # Publish a general dialog close event for DialogManager to pick up
        if ($global:TuiState.Services.EventManager) {
            $global:TuiState.Services.EventManager.Publish("Dialog.Completed", @{ Dialog = $this; Result = $result })
        }
        # The DialogManager will then call HideDialog for actual UI removal and focus restoration.
    }

    # Legacy method for compatibility
    [void] Close([object]$result) {
        $this.Complete($result)
    }

    # New method for DialogManager to call to set initial focus within the dialog
    [void] SetInitialFocus() {
        $firstFocusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible -and $_.Enabled } | Sort-Object TabIndex, Y, X | Select-Object -First 1
        if ($firstFocusable -and $global:TuiState.Services.FocusManager) {
            $global:TuiState.Services.FocusManager.SetFocus($firstFocusable)
            # Write-Log -Level Debug -Message "Dialog '$($this.Name)': Set initial focus to '$($firstFocusable.Name)'."
        }
    }

    # Update Title on render
    [void] OnRender() {
        # Base Panel's OnRender already draws border and title using ThemeManager colors
        $this._panel.Title = " $this.Title " # Ensure title is updated on panel
        $this._panel.OnRender() # Render the internal panel
    }

    [object] ShowDialog([string]$title, [string]$message) {
        $this.Show($title, $message)
        
        # In a real implementation, this would block until dialog closes
        # For now, return immediately
        return $this.Result
    }
}

#<!-- END_PAGE: ACO.017 -->

#<!-- PAGE: ACO.018 - AlertDialog Class -->
# ===== CLASS: AlertDialog =====
# Module: dialog-system-class
# Dependencies: Dialog, ButtonComponent
# Purpose: Simple message dialog
class AlertDialog : Dialog {
    hidden [ButtonComponent]$_okButton

    AlertDialog([string]$name) : base($name) {
        $this.Height = 8
        $this.InitializeAlert()
    }

    hidden [void] InitializeAlert() {
        # OK button
        $this._okButton = [ButtonComponent]::new($this.Name + "_OK")
        $this._okButton.Text = "OK"
        $this._okButton.Width = 10
        $this._okButton.Height = 3
        $this._okButton.OnClick = {
            $this.Complete($true)
        }.GetNewClosure()
        $this._panel.AddChild($this._okButton)
    }

    [void] Show([string]$title, [string]$message) {
        ([Dialog]$this).Show($title, $message)
        
        # Position OK button
        $this._okButton.X = [Math]::Floor(($this.Width - $this._okButton.Width) / 2)
        $this._okButton.Y = $this.Height - 4
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            # Draw message within the dialog's panel content area
            $panelContentX = $this._panel.ContentX
            $panelContentY = $this._panel.ContentY
            $maxWidth = $this.Width - 4 # Panel width - 2*border - 2*padding

            # Simple word wrap (use Write-TuiText)
            $words = $this.Message -split ' '
            $currentLine = ""
            $currentY = $panelContentY + 1 # Start drawing message below title

            foreach ($word in $words) {
                if (($currentLine + " " + $word).Length -gt $maxWidth) {
                    if ($currentLine) {
                        Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
                        $currentY++
                    }
                    $currentLine = $word
                }
                else {
                    $currentLine = if ($currentLine) { "$currentLine $word" } else { $word }
                }
            }
            if ($currentLine) {
                Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }

        # Let OK button handle input first
        if ($this._okButton.HandleInput($key)) { return $true }
        
        if ($key.Key -eq [ConsoleKey]::Escape -or $key.Key -eq [ConsoleKey]::Enter) {
            $this.Complete($true) # Complete dialog
            return $true
        }
        return $false
    }

    [void] OnEnter() {
        # Set focus to the OK button when dialog appears
        $global:TuiState.Services.FocusManager?.SetFocus($this._okButton)
    }
}

#<!-- END_PAGE: ACO.018 -->

#<!-- PAGE: ACO.019 - ConfirmDialog Class -->
# ===== CLASS: ConfirmDialog =====
# Module: dialog-system-class
# Dependencies: Dialog, ButtonComponent
# Purpose: Yes/No confirmation dialog
class ConfirmDialog : Dialog {
    hidden [ButtonComponent]$_yesButton
    hidden [ButtonComponent]$_noButton
    # Removed manual focus tracking - will use FocusManager instead

    ConfirmDialog([string]$name) : base($name) {
        $this.Height = 8
        $this.InitializeConfirm()
    }

    hidden [void] InitializeConfirm() {
        # Yes button
        $this._yesButton = [ButtonComponent]::new($this.Name + "_Yes")
        $this._yesButton.Text = "Yes"
        $this._yesButton.Width = 10
        $this._yesButton.Height = 3
        $this._yesButton.TabIndex = 1 # Explicitly set tab order
        $this._yesButton.OnClick = {
            $this.Complete($true)
        }.GetNewClosure()
        $this._panel.AddChild($this._yesButton)

        # No button
        $this._noButton = [ButtonComponent]::new($this.Name + "_No")
        $this._noButton.Text = "No"
        $this._noButton.Width = 10
        $this._noButton.Height = 3
        $this._noButton.TabIndex = 2 # Explicitly set tab order
        $this._noButton.OnClick = {
            $this.Complete($false)
        }.GetNewClosure()
        $this._panel.AddChild($this._noButton)
    }

    [void] Show([string]$title, [string]$message) {
        ([Dialog]$this).Show($title, $message)
        
        # Position buttons
        $buttonY = $this.Height - 4
        $totalWidth = $this._yesButton.Width + $this._noButton.Width + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        $this._yesButton.X = $startX
        $this._yesButton.Y = $buttonY
        
        $this._noButton.X = $startX + $this._yesButton.Width + 4
        $this._noButton.Y = $buttonY
        
    }

    [void] OnEnter() {
        # When the dialog is shown, tell the FocusManager to focus the first element (Yes button)
        $global:TuiState.Services.FocusManager?.SetFocus($this._yesButton)
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            # Draw message (same as AlertDialog)
            $panelContentX = $this._panel.ContentX
            $panelContentY = $this._panel.ContentY
            $maxWidth = $this.Width - 4
            
            $words = $this.Message -split ' '
            $currentLine = ""
            $currentY = $panelContentY + 1
            
            foreach ($word in $words) {
                if (($currentLine + " " + $word).Length -gt $maxWidth) {
                    if ($currentLine) {
                        Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
                        $currentY++
                    }
                    $currentLine = $word
                }
                else {
                    $currentLine = if ($currentLine) { "$currentLine $word" } else { $word }
                }
            }
            
            if ($currentLine) {
                Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }

        # Handle Escape to cancel
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Complete($false) # Using new Complete method
            return $true
        }

        # The global input handler will route Tab/Shift+Tab to the FocusManager.
        # Left/Right arrow keys can be used to switch between Yes/No buttons
        if ($key.Key -eq [ConsoleKey]::LeftArrow -or $key.Key -eq [ConsoleKey]::RightArrow) {
            $focusManager = $global:TuiState.Services.FocusManager
            if ($focusManager) {
                # Toggle focus between the two buttons
                if ($focusManager.FocusedComponent -eq $this._yesButton) {
                    $focusManager.SetFocus($this._noButton)
                } else {
                    $focusManager.SetFocus($this._yesButton)
                }
                return $true
            }
        }
        
        # Let the focused child handle the input
        # The FocusManager will have already routed input to the focused button
        return $false
    }
}

#<!-- END_PAGE: ACO.019 -->

#<!-- PAGE: ACO.020 - InputDialog Class -->
# ===== CLASS: InputDialog =====
# Module: dialog-system-class
# Dependencies: Dialog, TextBoxComponent, ButtonComponent
# Purpose: Text input dialog
class InputDialog : Dialog {
    hidden [TextBoxComponent]$_inputBox
    hidden [ButtonComponent]$_okButton
    hidden [ButtonComponent]$_cancelButton
    hidden [bool]$_focusOnInput = $true
    hidden [int]$_focusIndex = 0  # 0=input, 1=ok, 2=cancel

    InputDialog([string]$name) : base($name) {
        $this.Height = 10
        $this.InitializeInput()
    }

    hidden [void] InitializeInput() {
        # Input box
        $this._inputBox = [TextBoxComponent]::new($this.Name + "_Input")
        $this._inputBox.Width = $this.Width - 4
        $this._inputBox.Height = 3
        $this._inputBox.X = 2
        $this._inputBox.Y = 4
        $this._panel.AddChild($this._inputBox)

        # OK button
        $this._okButton = [ButtonComponent]::new($this.Name + "_OK")
        $this._okButton.Text = "OK"
        $this._okButton.Width = 10
        $this._okButton.Height = 3
        $this._okButton.OnClick = {
            $this.Close($this._inputBox.Text)
        }.GetNewClosure()
        $this._panel.AddChild($this._okButton)

        # Cancel button
        $this._cancelButton = [ButtonComponent]::new($this.Name + "_Cancel")
        $this._cancelButton.Text = "Cancel"
        $this._cancelButton.Width = 10
        $this._cancelButton.Height = 3
        $this._cancelButton.OnClick = {
            $this.Close($null)
        }.GetNewClosure()
        $this._panel.AddChild($this._cancelButton)
    }

    [void] Show([string]$title, [string]$message, [string]$defaultValue = "") {
        ([Dialog]$this).Show($title, $message)
        
        $this._inputBox.Text = $defaultValue
        $this._inputBox.CursorPosition = $defaultValue.Length
        
        # Position buttons
        $buttonY = $this.Height - 4
        $totalWidth = $this._okButton.Width + $this._cancelButton.Width + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        $this._okButton.X = $startX
        $this._okButton.Y = $buttonY
        
        $this._cancelButton.X = $startX + $this._okButton.Width + 4
        $this._cancelButton.Y = $buttonY
        
        # Set initial focus
        $this._focusIndex = 0
        $this.UpdateFocus()
    }

    hidden [void] UpdateFocus() {
        $this._inputBox.IsFocused = ($this._focusIndex -eq 0)
        $this._okButton.IsFocused = ($this._focusIndex -eq 1)
        $this._cancelButton.IsFocused = ($this._focusIndex -eq 2)
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            # Draw message
            $this._panel._private_buffer.WriteString(2, 2, 
                $this.Message, [ConsoleColor]::White, [ConsoleColor]::Black)
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Close($null)
            return $true
        }
        
        if ($key.Key -eq [ConsoleKey]::Tab) {
            $this._focusIndex = ($this._focusIndex + 1) % 3
            $this.UpdateFocus()
            $this.RequestRedraw()
            return $true
        }
        
        switch ($this._focusIndex) {
            0 { return $this._inputBox.HandleInput($key) }
            1 { return $this._okButton.HandleInput($key) }
            2 { return $this._cancelButton.HandleInput($key) }
        }
        
        return $false
    }
}

# Task Create/Edit Dialog
class TaskDialog : Dialog {
    hidden [TextBoxComponent] $_titleBox
    hidden [MultilineTextBoxComponent] $_descriptionBox
    hidden [ComboBoxComponent] $_statusCombo
    hidden [ComboBoxComponent] $_priorityCombo
    hidden [NumericInputComponent] $_progressInput
    hidden [ButtonComponent] $_saveButton
    hidden [ButtonComponent] $_cancelButton
    hidden [PmcTask] $_task
    hidden [bool] $_isNewTask
    
    TaskDialog([string]$title, [PmcTask]$task) : base($title) {
        $this._task = if ($task) { $task } else { [PmcTask]::new() }
        $this._isNewTask = ($null -eq $task)
        $this.Width = 60
        $this.Height = 20
    }
    
    [void] Initialize() {
        ([Dialog]$this).Initialize()
        
        $contentY = 2
        $labelWidth = 12
        $inputX = $labelWidth + 2
        $inputWidth = $this.ContentWidth - $inputX - 2
        
        # Title
        $titleLabel = [LabelComponent]::new("TitleLabel")
        $titleLabel.Text = "Title:"
        $titleLabel.X = 2
        $titleLabel.Y = $contentY
        $this._panel.AddChild($titleLabel)
        
        $this._titleBox = [TextBoxComponent]::new("TitleBox")
        $this._titleBox.X = $inputX
        $this._titleBox.Y = $contentY
        $this._titleBox.Width = $inputWidth
        $this._titleBox.Height = 1
        $this._titleBox.Text = $this._task.Title
        $this._panel.AddChild($this._titleBox)
        $contentY += 2
        
        # Description
        $descLabel = [LabelComponent]::new("DescLabel")
        $descLabel.Text = "Description:"
        $descLabel.X = 2
        $descLabel.Y = $contentY
        $this._panel.AddChild($descLabel)
        
        $this._descriptionBox = [MultilineTextBoxComponent]::new("DescBox")
        $this._descriptionBox.X = $inputX
        $this._descriptionBox.Y = $contentY
        $this._descriptionBox.Width = $inputWidth
        $this._descriptionBox.Height = 3
        $this._descriptionBox.Text = $this._task.Description
        $this._panel.AddChild($this._descriptionBox)
        $contentY += 4
        
        # Status
        $statusLabel = [LabelComponent]::new("StatusLabel")
        $statusLabel.Text = "Status:"
        $statusLabel.X = 2
        $statusLabel.Y = $contentY
        $this._panel.AddChild($statusLabel)
        
        $this._statusCombo = [ComboBoxComponent]::new("StatusCombo")
        $this._statusCombo.X = $inputX
        $this._statusCombo.Y = $contentY
        $this._statusCombo.Width = $inputWidth
        $this._statusCombo.Height = 1
        $this._statusCombo.Items = @([TaskStatus]::GetEnumNames())
        $this._statusCombo.SelectedIndex = [Array]::IndexOf($this._statusCombo.Items, $this._task.Status.ToString())
        $this._panel.AddChild($this._statusCombo)
        $contentY += 2
        
        # Priority
        $priorityLabel = [LabelComponent]::new("PriorityLabel")
        $priorityLabel.Text = "Priority:"
        $priorityLabel.X = 2
        $priorityLabel.Y = $contentY
        $this._panel.AddChild($priorityLabel)
        
        $this._priorityCombo = [ComboBoxComponent]::new("PriorityCombo")
        $this._priorityCombo.X = $inputX
        $this._priorityCombo.Y = $contentY
        $this._priorityCombo.Width = $inputWidth
        $this._priorityCombo.Height = 1
        $this._priorityCombo.Items = @([TaskPriority]::GetEnumNames())
        $this._priorityCombo.SelectedIndex = [Array]::IndexOf($this._priorityCombo.Items, $this._task.Priority.ToString())
        $this._panel.AddChild($this._priorityCombo)
        $contentY += 2
        
        # Progress
        $progressLabel = [LabelComponent]::new("ProgressLabel")
        $progressLabel.Text = "Progress %:"
        $progressLabel.X = 2
        $progressLabel.Y = $contentY
        $this._panel.AddChild($progressLabel)
        
        $this._progressInput = [NumericInputComponent]::new("ProgressInput")
        $this._progressInput.X = $inputX
        $this._progressInput.Y = $contentY
        $this._progressInput.Width = 10
        $this._progressInput.Height = 1
        $this._progressInput.MinValue = 0
        $this._progressInput.MaxValue = 100
        $this._progressInput.Value = $this._task.Progress
        $this._panel.AddChild($this._progressInput)
        $contentY += 3
        
        # Buttons
        $buttonY = $this.ContentHeight - 3
        $buttonWidth = 12
        $spacing = 2
        $totalButtonWidth = ($buttonWidth * 2) + $spacing
        $startX = [Math]::Floor(($this.ContentWidth - $totalButtonWidth) / 2)
        
        $this._saveButton = [ButtonComponent]::new("SaveButton")
        $this._saveButton.Text = "Save"
        $this._saveButton.X = $startX
        $this._saveButton.Y = $buttonY
        $this._saveButton.Width = $buttonWidth
        $this._saveButton.Height = 1
        $thisDialog = $this
        $this._saveButton.OnClick = {
            $thisDialog.DialogResult = [DialogResult]::OK
            $thisDialog.Complete($thisDialog.DialogResult)
        }.GetNewClosure()
        $this._panel.AddChild($this._saveButton)
        
        $this._cancelButton = [ButtonComponent]::new("CancelButton")
        $this._cancelButton.Text = "Cancel"
        $this._cancelButton.X = $startX + $buttonWidth + $spacing
        $this._cancelButton.Y = $buttonY
        $this._cancelButton.Width = $buttonWidth
        $this._cancelButton.Height = 1
        $this._cancelButton.OnClick = {
            $thisDialog.DialogResult = [DialogResult]::Cancel
            $thisDialog.Complete($thisDialog.DialogResult)
        }.GetNewClosure()
        $this._panel.AddChild($this._cancelButton)
        
        # Set initial focus
        Set-ComponentFocus -Component $this._titleBox
    }
    
    [PmcTask] GetTask() {
        if ($this.DialogResult -eq [DialogResult]::OK) {
            # Update task with form values
            $this._task.Title = $this._titleBox.Text
            $this._task.Description = $this._descriptionBox.Text
            $this._task.Status = [TaskStatus]::($this._statusCombo.Items[$this._statusCombo.SelectedIndex])
            $this._task.Priority = [TaskPriority]::($this._priorityCombo.Items[$this._priorityCombo.SelectedIndex])
            $this._task.SetProgress($this._progressInput.Value)
            $this._task.UpdatedAt = [DateTime]::Now
        }
        return $this._task
    }
}

# Task Delete Confirmation Dialog
class TaskDeleteDialog : ConfirmDialog {
    hidden [PmcTask] $_task
    
    TaskDeleteDialog([PmcTask]$task) : base("Confirm Delete", "Are you sure you want to delete this task?") {
        $this._task = $task
    }
    
    [void] Initialize() {
        ([ConfirmDialog]$this).Initialize()
        
        # Add task details to the message
        if ($this._task) {
            $detailsLabel = [LabelComponent]::new("TaskDetails")
            $detailsLabel.Text = "Task: $($this._task.Title)"
            $detailsLabel.X = 2
            $detailsLabel.Y = 4
            $detailsLabel.ForegroundColor = Get-ThemeColor -ColorName "Warning" -DefaultColor "#FFA500"
            $this._panel.AddChild($detailsLabel)
        }
    }
}

#endregion Dialog Components

#region Navigation Components

#<!-- END_PAGE: ACO.020 -->

#<!-- PAGE: ACO.021 - NavigationMenu Class -->
# ===== CLASS: NavigationMenu =====
# Module: navigation-class
# Dependencies: UIElement, NavigationItem
# Purpose: Local menu component
class NavigationMenu : UIElement {
    [List[NavigationItem]]$Items
    [int]$SelectedIndex = 0
    [string]$Orientation = "Horizontal"  # Horizontal or Vertical
    [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    [ConsoleColor]$ForegroundColor = [ConsoleColor]::White
    [ConsoleColor]$SelectedBackgroundColor = [ConsoleColor]::DarkBlue
    [ConsoleColor]$SelectedForegroundColor = [ConsoleColor]::Yellow

    NavigationMenu([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[NavigationItem]]::new()
        $this.Height = 1
    }

    [void] AddItem([NavigationItem]$item) {
        $this.Items.Add($item)
        $this.RequestRedraw()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', $this.ForegroundColor, $this.BackgroundColor))
            
            if ($this.Orientation -eq "Horizontal") {
                $this.RenderHorizontal()
            }
            else {
                $this.RenderVertical()
            }
        }
        catch {}
    }

    hidden [void] RenderHorizontal() {
        $currentX = 0
        
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex -and $this.IsFocused)
            
            $fg = if ($isSelected) { $this.SelectedForegroundColor } else { $this.ForegroundColor }
            $bg = if ($isSelected) { $this.SelectedBackgroundColor } else { $this.BackgroundColor }
            
            # Draw item
            $text = " $($item.Text) "
            if ($item.Hotkey) {
                $text = " $($item.Text) ($($item.Hotkey)) "
            }
            
            if ($currentX + $text.Length -le $this.Width) {
                for ($x = 0; $x -lt $text.Length; $x++) {
                    $this._private_buffer.SetCell($currentX + $x, 0, 
                        [TuiCell]::new($text[$x], $fg, $bg))
                }
            }
            
            $currentX += $text.Length + 1
        }
    }

    hidden [void] RenderVertical() {
        $this.Height = [Math]::Max($this.Items.Count, 1)
        
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex -and $this.IsFocused)
            
            $fg = if ($isSelected) { $this.SelectedForegroundColor } else { $this.ForegroundColor }
            $bg = if ($isSelected) { $this.SelectedBackgroundColor } else { $this.BackgroundColor }
            
            # Clear line
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this._private_buffer.SetCell($x, $i, [TuiCell]::new(' ', $fg, $bg))
            }
            
            # Draw item
            $text = $item.Text
            if ($item.Hotkey) {
                $text = "$($item.Text) ($($item.Hotkey))"
            }
            
            if ($text.Length -gt $this.Width) {
                $text = $text.Substring(0, $this.Width - 3) + "..."
            }
            
            $this._private_buffer.WriteString(0, $i, $text, $fg, $bg)
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $true
        
        if ($this.Orientation -eq "Horizontal") {
            switch ($key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                        $this.SelectedIndex++
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this.ExecuteItem($this.SelectedIndex)
                }
                default {
                    # Check hotkeys
                    $handled = $this.CheckHotkey($key)
                }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                        $this.SelectedIndex++
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this.ExecuteItem($this.SelectedIndex)
                }
                default {
                    $handled = $this.CheckHotkey($key)
                }
            }
        }
        
        if ($handled) {
            $this.RequestRedraw()
        }
        
        return $handled
    }

    hidden [bool] CheckHotkey([System.ConsoleKeyInfo]$key) {
        foreach ($i in 0..($this.Items.Count - 1)) {
            $item = $this.Items[$i]
            if ($item.Hotkey -and $item.Hotkey.ToUpper() -eq $key.KeyChar.ToString().ToUpper()) {
                $this.SelectedIndex = $i
                $this.ExecuteItem($i)
                return $true
            }
        }
        return $false
    }

    hidden [void] ExecuteItem([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $item = $this.Items[$index]
            if ($item.Action) {
                try {
                    & $item.Action
                }
                catch {}
            }
        }
    }
}

#<!-- END_PAGE: ACO.021 -->

#endregion Navigation Components

#region Dialog Result Enum
enum DialogResult {
    None = 0
    OK = 1
    Cancel = 2
    Yes = 3
    No = 4
    Retry = 5
    Abort = 6
}
#endregion



####\AllFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#<!-- PAGE: AFU.001 - TUI Drawing Functions -->
#region TUI Drawing Functions

function Write-TuiText {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][string]$Text,
        [hashtable]$Style = @{} # Accepts a hashtable for all style properties
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { 
        # Write-Log -Level Debug -Message "Write-TuiText: Skipped for buffer '$($Buffer.Name)' due to empty text."
        return 
    }
    
    # Now simply pass the style hashtable to TuiBuffer.WriteString
    $Buffer.WriteString($X, $Y, $Text, $Style)
    
    # Write-Log -Level Debug -Message "Write-TuiText: Wrote '$Text' to buffer '$($Buffer.Name)' at ($X, $Y)."
}

function Write-TuiBox {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [string]$Title = "",
        [hashtable]$Style = @{} # All visual aspects now passed via Style hashtable
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) {
        # Write-Log -Level Warning -Message "Write-TuiBox: Invalid dimensions ($($Width)x$($Height)). Dimensions must be positive."
        return
    }

    # Extract properties from the style object with safe fallbacks.
    $borderStyleName = if ($Style.ContainsKey('BorderStyle')) { $Style['BorderStyle'] } else { "Single" }
    $borderColor = if ($Style.ContainsKey('BorderFG')) { $Style['BorderFG'] } else { "#808080" } # Default border color (gray hex)
    $bgColor = if ($Style.ContainsKey('BG')) { $Style['BG'] } else { "#000000" }           # Default background color (black hex)
    $titleColor = if ($Style.ContainsKey('TitleFG')) { $Style['TitleFG'] } else { $borderColor } # Title defaults to border color
    $fillChar = if ($Style.ContainsKey('FillChar')) { [char]$Style['FillChar'] } else { ' ' }   # Optional fill character

    $borders = Get-TuiBorderChars -Style $borderStyleName
    
    # Define style objects for child calls to Write-TuiText.
    $generalStyle = @{ FG = $borderColor; BG = $bgColor } # For borders
    $fillStyle = @{ FG = $borderColor; BG = $bgColor }    # For fill area (fill char uses border fg)
    
    $titleTextStyle = @{ FG = $titleColor; BG = $bgColor }
    # Merge any additional title style overrides (e.g., Bold = $true for title)
    if ($Style.ContainsKey('TitleStyle') -and $Style['TitleStyle']) {
        foreach ($key in $Style['TitleStyle'].Keys) { $titleTextStyle[$key] = $Style['TitleStyle'][$key] }
    }

    # Fill background of the entire box area first
    $Buffer.FillRect($X, $Y, $Width, $Height, $fillChar, $fillStyle)
    
    # Top border - handle edge cases for small dimensions
    if ($Height -gt 0) {
        if ($Width > 2) {
            # Normal case: Width >= 3
            $middlePart = $borders.Horizontal * ($Width - 2)
            Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text "$($borders.TopLeft)$middlePart$($borders.TopRight)" -Style $generalStyle
        } elseif ($Width -eq 2) {
            # Special case: Width = 2 (just corners)
            Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.TopRight)" -Style $generalStyle
        } elseif ($Width -eq 1) {
            # Special case: Width = 1 (just a vertical line segment)
            $Buffer.SetCell($X, $Y, [TuiCell]::new($borders.Vertical, $generalStyle.FG, $generalStyle.BG))
        }
    }

    # Side borders
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $i) -Text $borders.Vertical -Style $generalStyle
        if ($Width -gt 1) {
            Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -Style $generalStyle
        }
    }
    
    # Bottom border - handle edge cases for small dimensions
    if ($Height -gt 1) {
        if ($Width > 2) {
            # Normal case: Width >= 3
            $middlePart = $borders.Horizontal * ($Width - 2)
            Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$middlePart$($borders.BottomRight)" -Style $generalStyle
        } elseif ($Width -eq 2) {
            # Special case: Width = 2 (just corners)
            Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.BottomRight)" -Style $generalStyle
        } elseif ($Width -eq 1) {
            # Special case: Width = 1 (just a vertical line segment)
            $Buffer.SetCell($X, $Y + $Height - 1, [TuiCell]::new($borders.Vertical, $generalStyle.FG, $generalStyle.BG))
        }
    }

    # Draw title if specified
    if (-not [string]::IsNullOrEmpty($Title) -and $Y -ge 0 -and $Y -lt $Buffer.Height) {
        $titleText = " $Title "
        
        # Truncate title if too long
        $maxTitleLength = $Width - 2
        if ($titleText.Length -gt $maxTitleLength -and $maxTitleLength -gt 3) {
            $titleText = $titleText.Substring(0, $maxTitleLength - 3) + "..."
        }
        
        if ($titleText.Length -le ($Width - 2) -and $Width -gt 2) {
            $titleAlignment = $Style.TitleAlignment ?? "TopBorder" # Default to current behavior
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            
            # Calculate title Y position based on alignment
            $titleY = $Y # Default to top border
            switch ($titleAlignment) {
                "TopBorder" { $titleY = $Y }  # Default - on the top border
                "Top" { $titleY = $Y + 1 }    # Just inside the top border
                "Center" { $titleY = $Y + [Math]::Floor($Height / 2) }  # Vertically centered
                "Bottom" { $titleY = $Y + $Height - 2 }  # Just inside the bottom border
                default { $titleY = $Y }      # Fallback to top border
            }
            
            # Ensure title Y is within buffer bounds
            if ($titleY -ge 0 -and $titleY -lt $Buffer.Height) {
                Write-TuiText -Buffer $Buffer -X $titleX -Y $titleY -Text $titleText -Style $titleTextStyle
            }
        }
    }
    
    $Buffer.IsDirty = $true
    # Write-Log -Level Debug -Message "Write-TuiBox: Drew '$borderStyleName' box on buffer '$($Buffer.Name)' at ($X, $Y) with dimensions $($Width)x$($Height)."
}

#endregion
#<!-- END_PAGE: AFU.001 -->

#<!-- PAGE: AFU.002 - Border Functions -->
#region Border Functions

function Get-TuiBorderChars {
    [CmdletBinding()]
    param(
        [ValidateSet("Single", "Double", "Rounded", "Thick")][string]$Style = "Single"
    )
    
    $styles = @{
        Single = @{ 
            TopLeft = ''; TopRight = ''; BottomLeft = ''; BottomRight = ''; 
            Horizontal = ''; Vertical = '' 
        }
        Double = @{ 
            TopLeft = ''; TopRight = ''; BottomLeft = ''; BottomRight = ''; 
            Horizontal = ''; Vertical = '' 
        }
        Rounded = @{ 
            TopLeft = ''; TopRight = ''; BottomLeft = ''; BottomRight = ''; 
            Horizontal = ''; Vertical = '' 
        }
        Thick = @{ 
            TopLeft = ''; TopRight = ''; BottomLeft = ''; BottomRight = ''; 
            Horizontal = ''; Vertical = '' 
        }
    }
    
    $selectedStyle = $styles[$Style]
    if ($null -eq $selectedStyle) {
        Write-Warning "Get-TuiBorderChars: Border style '$Style' not found. Returning 'Single' style."
        return $styles.Single
    }
    
    Write-Verbose "Get-TuiBorderChars: Retrieved TUI border characters for style: $Style."
    return $selectedStyle
}

#endregion
#<!-- END_PAGE: AFU.002 -->

#<!-- PAGE: AFU.003 - Factory Functions -->
#region Factory Functions

function New-TuiBuffer {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [string]$Name = "Unnamed"
    )
    return [TuiBuffer]::new($Width, $Height, $Name)
}

function New-TuiLabel {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Text = "",
        [int]$X = 0,
        [int]$Y = 0,
        [string]$ForegroundColor = $null
    )
    
    $label = [LabelComponent]::new($Name)
    $label.Text = $Text
    $label.X = $X
    $label.Y = $Y
    if ($ForegroundColor) {
        $label.ForegroundColor = $ForegroundColor
    }
    return $label
}

function New-TuiButton {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Text = "Button",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 10,
        [int]$Height = 3,
        [scriptblock]$OnClick = $null
    )
    
    $button = [ButtonComponent]::new($Name)
    $button.Text = $Text
    $button.X = $X
    $button.Y = $Y
    $button.Width = $Width
    $button.Height = $Height
    if ($OnClick) {
        $button.OnClick = $OnClick
    }
    return $button
}

function New-TuiTextBox {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Placeholder = "",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 20,
        [int]$Height = 3,
        [int]$MaxLength = 100,
        [scriptblock]$OnChange = $null
    )
    
    $textBox = [TextBoxComponent]::new($Name)
    $textBox.Placeholder = $Placeholder
    $textBox.X = $X
    $textBox.Y = $Y
    $textBox.Width = $Width
    $textBox.Height = $Height
    $textBox.MaxLength = $MaxLength
    if ($OnChange) {
        $textBox.OnChange = $OnChange
    }
    return $textBox
}

function New-TuiCheckBox {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Text = "Checkbox",
        [int]$X = 0,
        [int]$Y = 0,
        [bool]$Checked = $false,
        [scriptblock]$OnChange = $null
    )
    
    $checkBox = [CheckBoxComponent]::new($Name)
    $checkBox.Text = $Text
    $checkBox.X = $X
    $checkBox.Y = $Y
    $checkBox.Checked = $Checked
    if ($OnChange) {
        $checkBox.OnChange = $OnChange
    }
    return $checkBox
}

function New-TuiRadioButton {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Text = "Radio",
        [string]$GroupName = "default",
        [int]$X = 0,
        [int]$Y = 0,
        [bool]$Selected = $false,
        [scriptblock]$OnChange = $null
    )
    
    $radioButton = [RadioButtonComponent]::new($Name)
    $radioButton.Text = $Text
    $radioButton.GroupName = $GroupName
    $radioButton.X = $X
    $radioButton.Y = $Y
    $radioButton.Selected = $Selected
    if ($OnChange) {
        $radioButton.OnChange = $OnChange
    }
    return $radioButton
}

#endregion
#<!-- END_PAGE: AFU.003 -->

#<!-- PAGE: AFU.004 - Theme Functions -->
#region Theme Functions

function Get-ThemeColor {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ColorName,
        
        [string]$DefaultColor = "#808080"
    )
    
    $themeManager = $global:TuiState.Services.ThemeManager
    if ($themeManager) {
        # ThemeManager.GetColor already guarantees hex format
        $color = $themeManager.GetColor($ColorName)
        if ($color) {
            return $color
        }
    }
    
    # Write-Log -Level Debug -Message "Get-ThemeColor: Color '$ColorName' not found, using default '$DefaultColor'"
    return $DefaultColor
}

#endregion
#<!-- END_PAGE: AFU.004 -->

#<!-- PAGE: AFU.005 - Focus Management -->
#region Focus Management Functions

function Set-ComponentFocus {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][UIElement]$Component
    )
    
    # This function is now obsolete - use FocusManager service instead
    $focusManager = $global:TuiState.Services.FocusManager
    if ($focusManager) {
        $focusManager.SetFocus($Component)
    } else {
        Write-Warning "Set-ComponentFocus is deprecated. FocusManager service not available."
    }
}

#endregion
#<!-- END_PAGE: AFU.005 -->

#<!-- PAGE: AFU.006 - Logging Functions -->
#region Logging Functions

function Write-Log {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet('Trace', 'Debug', 'Info', 'Warning', 'Error', 'Fatal')]
        [string]$Level,
        
        [Parameter(Mandatory)]
        [string]$Message,
        
        [object]$Data = $null
    )
    
    # Try to get logger from global state first
    $logger = $null
    try {
        if ($global:TuiState -and 
            $global:TuiState.Services -and 
            $global:TuiState.Services -is [hashtable] -and
            $global:TuiState.Services.ContainsKey('Logger')) {
            $logger = $global:TuiState.Services['Logger']
        }
    }
    catch {
        # Silently ignore any errors accessing global state
        $logger = $null
    }
    
    if ($logger) {
        # Combine message and data into a single log entry for better correlation
        $finalMessage = $Message
        if ($Data) {
            try {
                # Handle UIElement objects specially to avoid circular reference issues
                if ($Data -is [UIElement]) {
                    $finalMessage = "$Message | Data: [UIElement: Name=$($Data.Name), Type=$($Data.GetType().Name)]"
                }
                elseif ($Data -is [System.Collections.IEnumerable] -and -not ($Data -is [string])) {
                    # Handle collections
                    $count = 0
                    try { $count = @($Data).Count } catch { }
                    $finalMessage = "$Message | Data: [Collection with $count items]"
                }
                else {
                    # For other objects, try to serialize but catch any errors
                    $dataJson = $null
                    try {
                        $dataJson = $Data | ConvertTo-Json -Compress -Depth 10 -ErrorAction Stop
                    } catch {
                        # Serialization failed, use simple representation
                    }
                    
                    if ($dataJson) {
                        $finalMessage = "$Message | Data: $dataJson"
                    } else {
                        $finalMessage = "$Message | Data: $($Data.ToString())"
                    }
                }
            }
            catch {
                # If all else fails, just use type name
                $finalMessage = "$Message | Data: [Object of type $($Data.GetType().Name)]"
            }
        }
        # Logger.Log method signature is: Log([string]$message, [string]$level = "Info")
        $logger.Log($finalMessage, $Level)
    }
    else {
        # Fallback to console if logger not available
        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        $prefix = "[$timestamp] [$Level]"
        
        switch ($Level) {
            'Error' { Write-Host "$prefix $Message" -ForegroundColor Red }
            'Warning' { Write-Host "$prefix $Message" -ForegroundColor Yellow }
            'Info' { Write-Host "$prefix $Message" -ForegroundColor Cyan }
            'Debug' { Write-Host "$prefix $Message" -ForegroundColor Gray }
            default { Write-Host "$prefix $Message" }
        }
    }
}

#endregion
#<!-- END_PAGE: AFU.006 -->

#<!-- PAGE: AFU.007 - Event Functions -->
#region Event System

function Subscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [Parameter(Mandatory)][scriptblock]$Handler,
        [string]$Source = ""
    )
    
    if ($global:TuiState.Services.EventManager) {
        return $global:TuiState.Services.EventManager.Subscribe($EventName, $Handler)
    }
    
    # Fallback
    $subscriptionId = [Guid]::NewGuid().ToString()
    Write-Verbose "Subscribed to event '$EventName' with handler ID: $subscriptionId"
    return $subscriptionId
}

function Unsubscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [Parameter(Mandatory)][string]$HandlerId
    )
    
    if ($global:TuiState.Services.EventManager) {
        $global:TuiState.Services.EventManager.Unsubscribe($EventName, $HandlerId)
    }
    Write-Verbose "Unsubscribed from event '$EventName' (Handler ID: $HandlerId)"
}

function Publish-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [hashtable]$EventData = @{}
    )
    
    if ($global:TuiState.Services.EventManager) {
        $global:TuiState.Services.EventManager.Publish($EventName, $EventData)
    }
    Write-Verbose "Published event '$EventName'"
}

#endregion
#<!-- END_PAGE: AFU.007 -->

#<!-- PAGE: AFU.008 - Error Handling -->
#region Error Handling Functions

# No specific error handling functions currently implemented
# This section reserved for future error management utilities

#endregion
#<!-- END_PAGE: AFU.008 -->

#<!-- PAGE: AFU.009 - Input Processing -->
#region Input Processing Functions

# No specific input processing functions currently implemented
# This section reserved for future input handling utilities

#endregion
#<!-- END_PAGE: AFU.009 -->

#<!-- PAGE: AFU.010 - Utility Functions -->
#region Utility Functions

# Initialize functions removed - Start.ps1 now uses direct service instantiation

#endregion
#<!-- END_PAGE: AFU.010 -->



####\AllModels.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Models (No UI Dependencies) - UPDATED
# Data models, enums, and validation classes
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AMO.###" to find specific sections.
# Each section ends with "END_PAGE: AMO.###"
# ==============================================================================

#<!-- PAGE: AMO.001 - Enums -->
#region Enums

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

enum BillingType {
    Billable
    NonBillable
}

enum DialogResult {
    None
    OK
    Cancel
    Yes
    No
    Abort
    Retry
    Ignore
}

#endregion
#<!-- END_PAGE: AMO.001 -->

#<!-- PAGE: AMO.002 - ValidationBase Class -->
#region Base Validation Class

# ===== CLASS: ValidationBase =====
# Module: models (from axiom)
# Dependencies: None
# Purpose: Provides common validation methods used across model classes
class ValidationBase {
    # Validates that a string value is not null, empty, or whitespace.
    # Throws an ArgumentException if the validation fails.
    static [void] ValidateNotEmpty(
        [string]$value,
        [string]$parameterName
    ) {
        try {
            if ([string]::IsNullOrWhiteSpace($value)) {
                $errorMessage = "Parameter '$($parameterName)' cannot be null or empty."
                throw [System.ArgumentException]::new($errorMessage, $parameterName)
            }
        }
        catch {
            # Re-throw to ensure calling context handles the exception
            throw
        }
    }
}

#endregion
#<!-- END_PAGE: AMO.002 -->

#<!-- PAGE: AMO.003 - Core Model Classes -->
#region Core Model Classes

# ===== CLASS: PmcTask =====
# Module: models (from axiom)
# Dependencies: ValidationBase, TaskStatus, TaskPriority enums
# Purpose: Represents a single task with lifecycle methods
class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString() # Unique identifier for the task
    [string]$Title                            # Short descriptive title
    [string]$Description                      # Detailed description
    [TaskStatus]$Status = [TaskStatus]::Pending # Current status of the task
    [TaskPriority]$Priority = [TaskPriority]::Medium # Importance level
    [string]$ProjectKey = "General"           # Associated project (key)
    [string]$Category                         # Alias for ProjectKey, for broader use
    [datetime]$CreatedAt = [datetime]::Now   # Timestamp of creation
    [datetime]$UpdatedAt = [datetime]::Now   # Last update timestamp
    [Nullable[datetime]]$DueDate             # Optional due date
    [string[]]$Tags = @()                     # Array of tags
    [int]$Progress = 0                        # Progress percentage (0-100)
    [bool]$Completed = $false                 # Convenience flag for completed status

    # Default constructor: Initializes a new task with default values.
    PmcTask() {}
    
    # Constructor: Initializes a new task with a title.
    PmcTask([string]$title) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title
    }
    
    # Constructor: Initializes a new task with common detailed properties.
    PmcTask(
        [string]$title,
        [string]$description,
        [TaskPriority]$priority,
        [string]$projectKey
    ) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")

        $this.Title = $title
        $this.Description = $description
        $this.Priority = $priority
        $this.ProjectKey = $projectKey
        $this.Category = $projectKey # Category is often an alias for ProjectKey
    }

    # Complete: Marks the task as completed, setting progress to 100% and updating timestamp.
    [void] Complete() {
        $this.Status = [TaskStatus]::Completed
        $this.Progress = 100
        $this.Completed = $true
        $this.UpdatedAt = [datetime]::Now
    }
    
    # Cancel: Marks the task as cancelled and updates timestamp.
    [void] Cancel() {
        $this.Status = [TaskStatus]::Cancelled
        $this.UpdatedAt = [datetime]::Now
    }
    
    # SetProgress: Updates the progress percentage and adjusts status accordingly.
    [void] SetProgress([int]$progress) {
        if ($progress -lt 0 -or $progress -gt 100) {
            throw [System.ArgumentOutOfRangeException]::new("progress", "Progress must be between 0 and 100.")
        }
        
        $this.Progress = $progress
        
        # Auto-update status based on progress
        if ($progress -eq 0 -and $this.Status -eq [TaskStatus]::InProgress) {
            $this.Status = [TaskStatus]::Pending
        }
        elseif ($progress -gt 0 -and $progress -lt 100) {
            $this.Status = [TaskStatus]::InProgress
        }
        elseif ($progress -eq 100) {
            $this.Complete()
        }
        
        $this.UpdatedAt = [datetime]::Now
    }
    
    # AddTag: Adds a tag to the task if not already present.
    [void] AddTag([string]$tag) {
        [ValidationBase]::ValidateNotEmpty($tag, "Tag")
        if ($this.Tags -notcontains $tag) {
            $this.Tags += $tag
            $this.UpdatedAt = [datetime]::Now
        }
    }
    
    # RemoveTag: Removes a tag from the task.
    [void] RemoveTag([string]$tag) {
        $this.Tags = $this.Tags | Where-Object { $_ -ne $tag }
        $this.UpdatedAt = [datetime]::Now
    }
    
    # GetAge: Returns the age of the task as a TimeSpan.
    [TimeSpan] GetAge() {
        return [datetime]::Now - $this.CreatedAt
    }
    
    # IsOverdue: Checks if the task is overdue based on DueDate.
    [bool] IsOverdue() {
        if ($null -eq $this.DueDate) { return $false }
        if ($this.Status -in @([TaskStatus]::Completed, [TaskStatus]::Cancelled)) { return $false }
        return [datetime]::Now -gt $this.DueDate
    }
    
    # Clone: Creates a deep copy of the task with a new ID.
    [PmcTask] Clone() {
        $clone = [PmcTask]::new()
        $clone.Title = $this.Title
        $clone.Description = $this.Description
        $clone.Status = $this.Status
        $clone.Priority = $this.Priority
        $clone.ProjectKey = $this.ProjectKey
        $clone.Category = $this.Category
        $clone.DueDate = $this.DueDate
        $clone.Tags = $this.Tags.Clone()
        $clone.Progress = $this.Progress
        $clone.Completed = $this.Completed
        # New task gets new timestamps and ID
        $clone.CreatedAt = [datetime]::Now
        $clone.UpdatedAt = [datetime]::Now
        return $clone
    }
    
    # ToLegacyFormat: Converts task to hashtable for JSON serialization
    [hashtable] ToLegacyFormat() {
        return @{
            Id = $this.Id
            Title = $this.Title
            Description = $this.Description
            Status = $this.Status.ToString()
            Priority = $this.Priority.ToString()
            ProjectKey = $this.ProjectKey
            Category = $this.Category
            CreatedAt = $this.CreatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
            UpdatedAt = $this.UpdatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
            DueDate = if ($this.DueDate) { $this.DueDate.ToString("yyyy-MM-ddTHH:mm:ss") } else { $null }
            Tags = $this.Tags
            Progress = $this.Progress
            Completed = $this.Completed
        }
    }
    
    # FromLegacyFormat: Creates task from hashtable (JSON deserialization)
    static [PmcTask] FromLegacyFormat([hashtable]$data) {
        $task = [PmcTask]::new()
        
        if ($data.ContainsKey('Id')) { $task.Id = $data.Id }
        if ($data.ContainsKey('Title')) { $task.Title = $data.Title }
        if ($data.ContainsKey('Description')) { $task.Description = $data.Description }
        if ($data.ContainsKey('Status')) { 
            $task.Status = [System.Enum]::Parse([TaskStatus], $data.Status, $true)
        }
        if ($data.ContainsKey('Priority')) { 
            $task.Priority = [System.Enum]::Parse([TaskPriority], $data.Priority, $true)
        }
        if ($data.ContainsKey('ProjectKey')) { $task.ProjectKey = $data.ProjectKey }
        if ($data.ContainsKey('Category')) { $task.Category = $data.Category }
        if ($data.ContainsKey('CreatedAt')) { 
            $task.CreatedAt = [DateTime]::Parse($data.CreatedAt)
        }
        if ($data.ContainsKey('UpdatedAt')) { 
            $task.UpdatedAt = [DateTime]::Parse($data.UpdatedAt)
        }
        if ($data.ContainsKey('DueDate') -and $data.DueDate) { 
            $task.DueDate = [DateTime]::Parse($data.DueDate)
        }
        if ($data.ContainsKey('Tags')) { $task.Tags = @($data.Tags) }
        if ($data.ContainsKey('Progress')) { $task.Progress = [int]$data.Progress }
        if ($data.ContainsKey('Completed')) { $task.Completed = [bool]$data.Completed }
        
        return $task
    }
    
    # ToString: Returns a string representation of the task.
    [string] ToString() {
        $statusSymbol = switch ($this.Status) {
            ([TaskStatus]::Pending) { "" }
            ([TaskStatus]::InProgress) { "" }
            ([TaskStatus]::Completed) { "" }
            ([TaskStatus]::Cancelled) { "" }
            default { "?" }
        }
        
        $prioritySymbol = switch ($this.Priority) {
            ([TaskPriority]::Low) { "" }
            ([TaskPriority]::Medium) { "" }
            ([TaskPriority]::High) { "" }
            default { "-" }
        }
        
        $overdueFlag = if ($this.IsOverdue()) { " [OVERDUE]" } else { "" }
        
        return "$statusSymbol $prioritySymbol $($this.Title) ($($this.Progress)%)$overdueFlag"
    }
}

# ===== CLASS: PmcProject =====
# Module: models (from axiom)
# Dependencies: ValidationBase
# Purpose: Represents a project that contains multiple tasks
class PmcProject : ValidationBase {
    [string]$Key                              # Unique project key (e.g., "PROJ-001")
    [string]$Name                             # Project name
    [string]$Description                      # Project description
    [DateTime]$CreatedAt = [DateTime]::Now  # Creation timestamp
    [DateTime]$UpdatedAt = [DateTime]::Now  # Last update timestamp
    [string]$Owner                           # Project owner
    [string[]]$Tags = @()                    # Project tags
    [hashtable]$Metadata = @{}               # Additional project metadata
    [bool]$IsActive = $true                  # Whether project is active
    
    # Enhanced properties from reference implementation
    [string]$ID1                             # Optional secondary identifier
    [Nullable[datetime]]$BFDate              # Bring-Forward date for follow-ups
    [string]$ProjectFolderPath               # Full path to the project's root folder on disk
    [string]$CaaFileName                     # Relative name of the associated CAA file
    [string]$RequestFileName                 # Relative name of the associated Request file
    [string]$T2020FileName                   # Relative name of the associated T2020 file

    # Default constructor
    PmcProject() {}

    # Constructor with key and name
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key
        $this.Name = $name
    }

    # Constructor with full details
    PmcProject([string]$key, [string]$name, [string]$description, [string]$owner) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        [ValidationBase]::ValidateNotEmpty($owner, "Owner")
        
        $this.Key = $key
        $this.Name = $name
        $this.Description = $description
        $this.Owner = $owner
    }

    # Archive: Marks the project as inactive
    [void] Archive() {
        $this.IsActive = $false
        $this.UpdatedAt = [DateTime]::Now
    }

    # Activate: Marks the project as active
    [void] Activate() {
        $this.IsActive = $true
        $this.UpdatedAt = [DateTime]::Now
    }

    # AddTag: Adds a tag to the project if not already present
    [void] AddTag([string]$tag) {
        [ValidationBase]::ValidateNotEmpty($tag, "Tag")
        if ($this.Tags -notcontains $tag) {
            $this.Tags += $tag
            $this.UpdatedAt = [DateTime]::Now
        }
    }

    # RemoveTag: Removes a tag from the project
    [void] RemoveTag([string]$tag) {
        $this.Tags = $this.Tags | Where-Object { $_ -ne $tag }
        $this.UpdatedAt = [DateTime]::Now
    }

    # SetMetadata: Sets a metadata key-value pair
    [void] SetMetadata([string]$key, $value) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        $this.Metadata[$key] = $value
        $this.UpdatedAt = [DateTime]::Now
    }

    # GetMetadata: Gets a metadata value by key
    [object] GetMetadata([string]$key) {
        return $this.Metadata[$key]
    }
    
    # ToLegacyFormat: Converts project to hashtable for JSON serialization
    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key
            Name = $this.Name
            Description = $this.Description
            CreatedAt = $this.CreatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
            UpdatedAt = $this.UpdatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
            Owner = $this.Owner
            Tags = $this.Tags
            Metadata = $this.Metadata.Clone()
            IsActive = $this.IsActive
        }
    }
    
    # FromLegacyFormat: Creates project from hashtable (JSON deserialization)
    static [PmcProject] FromLegacyFormat([hashtable]$data) {
        $project = [PmcProject]::new()
        
        if ($data.ContainsKey('Key')) { $project.Key = $data.Key }
        if ($data.ContainsKey('Name')) { $project.Name = $data.Name }
        if ($data.ContainsKey('Description')) { $project.Description = $data.Description }
        if ($data.ContainsKey('CreatedAt')) { 
            $project.CreatedAt = [DateTime]::Parse($data.CreatedAt)
        }
        if ($data.ContainsKey('UpdatedAt')) { 
            $project.UpdatedAt = [DateTime]::Parse($data.UpdatedAt)
        }
        if ($data.ContainsKey('Owner')) { $project.Owner = $data.Owner }
        if ($data.ContainsKey('Tags')) { $project.Tags = @($data.Tags) }
        if ($data.ContainsKey('Metadata')) { $project.Metadata = $data.Metadata.Clone() }
        if ($data.ContainsKey('IsActive')) { $project.IsActive = [bool]$data.IsActive }
        
        return $project
    }

    # ToString: Returns a string representation of the project
    [string] ToString() {
        $status = if ($this.IsActive) { "Active" } else { "Archived" }
        return "[$($this.Key)] $($this.Name) - $status"
    }
}

# ===== CLASS: TimeEntry =====
# Module: models (from axiom)
# Dependencies: ValidationBase, BillingType enum
# Purpose: Represents a time entry for a task
class TimeEntry : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()  # Unique identifier
    [string]$TaskId                              # Associated task ID
    [string]$ProjectKey                          # Associated project key
    [DateTime]$StartTime                         # When work started
    [Nullable[DateTime]]$EndTime                 # When work ended (null if ongoing)
    [string]$Description                         # What was done
    [BillingType]$BillingType = [BillingType]::Billable # Billing classification
    [string]$UserId                              # Who logged the time
    [decimal]$HourlyRate = 0                    # Rate per hour (if applicable)
    [hashtable]$Metadata = @{}                   # Additional metadata

    # Default constructor
    TimeEntry() {}

    # Constructor with basic details
    TimeEntry([string]$taskId, [string]$projectKey, [DateTime]$startTime) {
        [ValidationBase]::ValidateNotEmpty($taskId, "TaskId")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")
        
        $this.TaskId = $taskId
        $this.ProjectKey = $projectKey
        $this.StartTime = $startTime
    }

    # GetDuration: Returns the duration of the time entry
    [TimeSpan] GetDuration() {
        if ($null -eq $this.EndTime) {
            return [DateTime]::Now - $this.StartTime
        }
        return $this.EndTime - $this.StartTime
    }

    # GetHours: Returns the duration in decimal hours
    [decimal] GetHours() {
        return [decimal]($this.GetDuration().TotalHours)
    }

    # GetTotalValue: Returns the monetary value of the time entry
    [decimal] GetTotalValue() {
        if ($this.BillingType -eq [BillingType]::NonBillable) {
            return 0
        }
        return $this.GetHours() * $this.HourlyRate
    }

    # Stop: Stops the timer on this entry
    [void] Stop() {
        if ($null -eq $this.EndTime) {
            $this.EndTime = [DateTime]::Now
        }
    }

    # IsRunning: Checks if the time entry is still running
    [bool] IsRunning() {
        return $null -eq $this.EndTime
    }

    # ToString: Returns a string representation of the time entry
    [string] ToString() {
        $duration = $this.GetDuration()
        $status = if ($this.IsRunning()) { "Running" } else { "Completed" }
        return "$($this.ProjectKey) - $($duration.ToString('hh\:mm\:ss')) [$status]"
    }
}

#endregion
#<!-- END_PAGE: AMO.003 -->

#<!-- PAGE: AMO.004 - Exception Classes -->
#region Exception Classes

# ===== CLASS: HeliosException =====
# Module: exceptions (from axiom)
# Dependencies: None (inherits from System.Exception)
# Purpose: Base exception for all framework exceptions
class HeliosException : System.Exception {
    [string]$ErrorCode
    [hashtable]$Context = @{}
    [string]$Component
    [DateTime]$Timestamp
    
    HeliosException([string]$message) : base($message) {
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component) : base($message) {
        $this.Component = $component
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component, [hashtable]$context) : base($message) {
        $this.Component = $component
        $this.Context = $context
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $innerException) {
        $this.Component = $component
        $this.Context = $context
        $this.Timestamp = [DateTime]::Now
    }
}

# ===== CLASS: NavigationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for navigation-related errors
class NavigationException : HeliosException {
    NavigationException([string]$message) : base($message) {}
    NavigationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: ServiceInitializationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for service initialization failures
class ServiceInitializationException : HeliosException {
    ServiceInitializationException([string]$message) : base($message) {}
    ServiceInitializationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: ComponentRenderException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for component rendering failures
class ComponentRenderException : HeliosException {
    ComponentRenderException([string]$message) : base($message) {}
    ComponentRenderException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: StateMutationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for state mutation errors
class StateMutationException : HeliosException {
    StateMutationException([string]$message) : base($message) {}
    StateMutationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: InputHandlingException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for input handling errors
class InputHandlingException : HeliosException {
    InputHandlingException([string]$message) : base($message) {}
    InputHandlingException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: DataLoadException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for data loading errors
class DataLoadException : HeliosException {
    DataLoadException([string]$message) : base($message) {}
    DataLoadException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

#endregion
#<!-- END_PAGE: AMO.004 -->

#<!-- PAGE: AMO.005 - Navigation Classes -->
#region Navigation Classes

# ===== CLASS: NavigationItem =====
# Module: navigation-class (from axiom)
# Dependencies: None
# Purpose: Represents a menu item for local/contextual navigation
class NavigationItem {
    [string]$Key
    [string]$Label
    [scriptblock]$Action
    [bool]$Enabled = $true
    [bool]$Visible = $true
    [string]$Description = ""

    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key)) {
            throw [System.ArgumentException]::new("Navigation key cannot be null or empty")
        }
        if ([string]::IsNullOrWhiteSpace($label)) {
            throw [System.ArgumentException]::new("Navigation label cannot be null or empty")
        }
        if (-not $action) {
            throw [System.ArgumentNullException]::new("action", "Navigation action cannot be null")
        }

        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }

    [void] Execute() {
        try {
            if (-not $this.Enabled) {
                return
            }
            
            & $this.Action
        }
        catch {
            throw
        }
    }

    [string] ToString() {
        return "NavigationItem(Key='$($this.Key)', Label='$($this.Label)', Enabled=$($this.Enabled))"
    }
}

#endregion
#<!-- END_PAGE: AMO.005 -->



####\AllRuntime.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Runtime (Load Last)
# TUI engine, screen management, and main application loop
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ART.###" to find specific sections.
# Each section ends with "END_PAGE: ART.###"
# ==============================================================================

#<!-- PAGE: ART.001 - Global State -->
#region Global State

# Initialize global TUI state
$global:TuiState = @{
    Running = $false
    BufferWidth = 0
    BufferHeight = 0
    CompositorBuffer = $null
    PreviousCompositorBuffer = $null
    ScreenStack = [System.Collections.Generic.Stack[Screen]]::new() # CHANGED TO GENERIC STACK
    CurrentScreen = $null
    IsDirty = $true
    FocusedComponent = $null
    CommandPalette = $null
    Services = @{}
    LastRenderTime = [datetime]::Now
    FrameCount = 0
    InputQueue = New-Object 'System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]'
    OverlayStack = [System.Collections.Generic.List[UIElement]]::new() # CHANGED TO GENERIC LIST
    # Added for input thread management
    CancellationTokenSource = $null
    InputRunspace = $null
    InputPowerShell = $null
    InputAsyncResult = $null
}

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Component,
        
        [Parameter(Mandatory)]
        [string]$Context,
        
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock,
        
        [hashtable]$AdditionalData = @{}
    )
    
    try {
        & $ScriptBlock
    }
    catch {
        $errorDetails = @{
            Component = $Component
            Context = $Context
            ErrorMessage = $_.Exception.Message
            ErrorType = $_.Exception.GetType().FullName
            StackTrace = $_.ScriptStackTrace
            Timestamp = [datetime]::Now
        }
        
        foreach ($key in $AdditionalData.Keys) {
            $errorDetails[$key] = $AdditionalData[$key]
        }
        
        $logger = $global:TuiState.Services.Logger
        if ($logger) {
            $logger.Log("Error", "Error in $Component during $Context : $($_.Exception.Message)")
            $logger.Log("Debug", "Error details: $($errorDetails | ConvertTo-Json -Compress -Depth 10)")
        }
        
        # Re-throw for caller to handle if needed
        throw
    }
}
#endregion
#<!-- END_PAGE: ART.001 -->

#<!-- PAGE: ART.002 - Engine Management -->
#region Engine Management

function Initialize-TuiEngine {
    [CmdletBinding()]
    param()
    
    try {
        Write-Log -Level Info -Message "Initializing TUI engine..."
        
        # Store original console state
        $global:TuiState.OriginalWindowTitle = $Host.UI.RawUI.WindowTitle
        $global:TuiState.OriginalCursorVisible = [Console]::CursorVisible
        
        # Configure console
        [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        $env:PYTHONIOENCODING = "utf-8"
        [Console]::CursorVisible = $false
        $Host.UI.RawUI.WindowTitle = "Axiom-Phoenix v4.0 TUI Framework"
        
        # Clear screen and hide cursor
        Clear-Host
        [Console]::SetCursorPosition(0, 0)
        
        # Get initial size
        Update-TuiEngineSize
        
        # Create compositor buffers
        $width = $global:TuiState.BufferWidth
        $height = $global:TuiState.BufferHeight
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($width, $height, "Compositor")
        $global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new($width, $height, "PreviousCompositor")
        
        # Clear with theme background
        $bgColor = Get-ThemeColor -ColorName "Background" -DefaultColor "#000000"
        $global:TuiState.CompositorBuffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        $global:TuiState.PreviousCompositorBuffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        Write-Log -Level Info -Message "TUI engine initialized. Buffer size: ${width}x${height}"
    }
    catch {
        Invoke-WithErrorHandling -Component "TuiEngine" -Context "Initialization" -ScriptBlock { throw } `
            -AdditionalData @{ Phase = "EngineInit" }
    }
}

function Start-TuiEngine {
    [CmdletBinding()]
    param(
        [int]$TargetFPS = 30,
        [switch]$EnablePerformanceMonitoring,
        [int]$PerformanceReportInterval = 300  # frames
    )
    
    try {
        Write-Log -Level Info -Message "Starting TUI Engine with target FPS: $TargetFPS"
        
        # Calculate frame timing
        $targetFrameTime = [timespan]::FromSeconds(1.0 / $TargetFPS)
        $frameStopwatch = [System.Diagnostics.Stopwatch]::new()
        $performanceStopwatch = [System.Diagnostics.Stopwatch]::new()
        
        # Performance monitoring variables
        $frameTimeHistory = [System.Collections.Generic.Queue[double]]::new()
        $maxHistorySize = 60  # Keep last 60 frame times
        $slowFrameCount = 0
        $skippedFrameCount = 0
        
        $global:TuiState.Running = $true
        $global:TuiState.FrameCount = 0
        
        if ($EnablePerformanceMonitoring) {
            $performanceStopwatch.Start()
        }
        
        while ($global:TuiState.Running) {
            $frameStopwatch.Restart()
            
            try {
                # Phase 1: Handle console resize
                if ([Console]::WindowWidth -ne $global:TuiState.BufferWidth -or 
                    [Console]::WindowHeight -ne $global:TuiState.BufferHeight) {
                    
                    Invoke-WithErrorHandling -Component "TuiEngine" -Context "Resize" -ScriptBlock {
                        Update-TuiEngineSize
                    }
                }
                
                # Phase 2: Process input (always process input for responsiveness)
                Invoke-WithErrorHandling -Component "TuiEngine" -Context "Input" -ScriptBlock {
                    Process-TuiInput
                }
                
                # Phase 3: Render frame
                # Always render to maintain consistent frame rate and handle animations
                Invoke-WithErrorHandling -Component "TuiEngine" -Context "Render" -ScriptBlock {
                    Invoke-TuiRender
                }
                
                $global:TuiState.FrameCount++
                
                # Phase 4: Performance monitoring
                if ($EnablePerformanceMonitoring) {
                    $frameTime = $frameStopwatch.ElapsedMilliseconds
                    
                    # Track frame times
                    $frameTimeHistory.Enqueue($frameTime)
                    if ($frameTimeHistory.Count -gt $maxHistorySize) {
                        $frameTimeHistory.Dequeue()
                    }
                    
                    # Count slow frames
                    if ($frameTime -gt $targetFrameTime.TotalMilliseconds) {
                        $slowFrameCount++
                    }
                    
                    # Report performance every N frames
                    if ($global:TuiState.FrameCount % $PerformanceReportInterval -eq 0) {
                        $avgFrameTime = ($frameTimeHistory | Measure-Object -Average).Average
                        $maxFrameTime = ($frameTimeHistory | Measure-Object -Maximum).Maximum
                        $currentFPS = if ($avgFrameTime -gt 0) { 1000.0 / $avgFrameTime } else { 0 }
                        
                        Write-Log -Level Info -Message "TUI Performance Report - Frame: $($global:TuiState.FrameCount), Avg FPS: $([Math]::Round($currentFPS, 1)), Avg Frame Time: $([Math]::Round($avgFrameTime, 1))ms, Max Frame Time: $([Math]::Round($maxFrameTime, 1))ms, Slow Frames: $slowFrameCount, Skipped: $skippedFrameCount"
                        
                        # Reset counters
                        $slowFrameCount = 0
                        $skippedFrameCount = 0
                    }
                }
                
                # Phase 5: Frame rate throttling
                $frameStopwatch.Stop()
                $elapsedTime = $frameStopwatch.Elapsed
                
                if ($elapsedTime -lt $targetFrameTime) {
                    # We have time to spare - sleep for the remainder
                    $sleepTime = $targetFrameTime - $elapsedTime
                    if ($sleepTime.TotalMilliseconds -gt 0) {
                        Start-Sleep -Milliseconds $sleepTime.TotalMilliseconds
                    }
                }
                elseif ($elapsedTime.TotalMilliseconds -gt $targetFrameTime.TotalMilliseconds * 2) {
                    # Frame took more than twice the target time - we're falling behind
                    $skippedFrameCount++
                    
                    if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                        Write-Log -Level Warning -Message "TUI Engine: Frame $($global:TuiState.FrameCount) took $([Math]::Round($elapsedTime.TotalMilliseconds, 1))ms (target: $([Math]::Round($targetFrameTime.TotalMilliseconds, 1))ms)"
                    }
                }
            }
            catch {
                Write-Log -Level Error -Message "TUI Engine: Frame $($global:TuiState.FrameCount) error: $($_.Exception.Message)"
                
                # Don't exit on frame errors - try to continue
                Start-Sleep -Milliseconds 50  # Brief pause to prevent tight error loop
            }
        }
        
        # Final performance report
        if ($EnablePerformanceMonitoring -and $performanceStopwatch.IsRunning) {
            $performanceStopwatch.Stop()
            $totalSeconds = $performanceStopwatch.Elapsed.TotalSeconds
            $avgFPS = if ($totalSeconds -gt 0) { $global:TuiState.FrameCount / $totalSeconds } else { 0 }
            
            Write-Log -Level Info -Message "TUI Engine stopped after $($global:TuiState.FrameCount) frames in $([Math]::Round($totalSeconds, 1))s. Average FPS: $([Math]::Round($avgFPS, 1))"
        }
        else {
            Write-Log -Level Info -Message "TUI Engine stopped after $($global:TuiState.FrameCount) frames"
        }
    }
    catch {
        Write-Log -Level Error -Message "TUI Engine critical error: $($_.Exception.Message)"
        Invoke-PanicHandler $_
    }
    finally {
        Stop-TuiEngine
    }
}

function Stop-TuiEngine {
    [CmdletBinding()]
    param(
        [switch]$Force
    )
    
    try {
        Write-Verbose "Stopping TUI Engine..."
        
        $global:TuiState.Running = $false
        
        # Cleanup current screen via NavigationService
        $navService = $global:TuiState.Services.NavigationService
        if ($navService -and $navService.CurrentScreen) {
            try {
                $navService.CurrentScreen.OnExit()
                $navService.CurrentScreen.Cleanup()
            }
            catch {
                Write-Verbose "Error cleaning up current screen: $_"
            }
        }
        
        # Cleanup services
        foreach ($service in $global:TuiState.Services.Values) {
            if ($service -and $service.PSObject -and $service.PSObject.Methods -and 
                $service.PSObject.Methods.Name -contains 'Cleanup') {
                try {
                    $service.Cleanup()
                }
                catch {
                    Write-Verbose "Error cleaning up service: $_"
                }
            }
        }
        
        # Restore console
        [Console]::CursorVisible = $true
        [Console]::Clear()
        [Console]::SetCursorPosition(0, 0)
        
        Write-Verbose "TUI Engine stopped and cleaned up"
    }
    catch {
        Write-Error "Error stopping TUI engine: $_"
    }
}

function Update-TuiEngineSize {
    [CmdletBinding()]
    param()
    
    try {
        $newWidth = [Console]::WindowWidth
        $newHeight = [Console]::WindowHeight
        
        Write-Verbose "Console resized from $($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight) to ${newWidth}x${newHeight}"
        
        # Update state
        $global:TuiState.BufferWidth = $newWidth
        $global:TuiState.BufferHeight = $newHeight
        
        # Resize compositor buffers only if they exist
        if ($null -ne $global:TuiState.CompositorBuffer) {
            $global:TuiState.CompositorBuffer.Resize($newWidth, $newHeight)
        }
        if ($null -ne $global:TuiState.PreviousCompositorBuffer) {
            $global:TuiState.PreviousCompositorBuffer.Resize($newWidth, $newHeight)
        }
        
        # Resize current screen
        $navService = $global:TuiState.Services.NavigationService
        if ($navService -and $navService.CurrentScreen) {
            $navService.CurrentScreen.Resize($newWidth, $newHeight)
        }
        
        # Force full redraw
        $global:TuiState.IsDirty = $true
        if ($null -ne $global:TuiState.CompositorBuffer) {
            [Console]::Clear()
        }
    }
    catch {
        Write-Error "Failed to update engine size: $_"
    }
}

#endregion
#<!-- END_PAGE: ART.002 -->

#<!-- PAGE: ART.003 - Rendering System -->
#region Rendering System

function Invoke-TuiRender {
    [CmdletBinding()]
    param()
    
    try {
        $renderTimer = [System.Diagnostics.Stopwatch]::StartNew()
        
        # Ensure compositor buffer exists
        if ($null -eq $global:TuiState.CompositorBuffer) {
            Write-Verbose "Compositor buffer is null, skipping render"
            return
        }
        
        # Clear compositor buffer
        $global:TuiState.CompositorBuffer.Clear()
        
        Write-Verbose "Starting render frame $($global:TuiState.FrameCount)"
        
        # Get the current screen from global state (NavigationService updates this)
        $currentScreenToRender = $global:TuiState.CurrentScreen
        
        # Render current screen
        if ($currentScreenToRender) {
            try {
                # Render the screen which will update its internal buffer
                $currentScreenToRender.Render()
                
                # Get the screen's buffer
                $screenBuffer = $currentScreenToRender.GetBuffer()
                
                if ($screenBuffer) {
                    # Blend screen buffer into compositor
                    $global:TuiState.CompositorBuffer.BlendBuffer($screenBuffer, 0, 0)
                }
                else {
                    Write-Verbose "Screen buffer is null for $($currentScreenToRender.Name)"
                }
            }
            catch {
                Write-Error "Error rendering screen: $_"
                throw
            }
            
            # Render command palette if visible
            if ($global:TuiState.CommandPalette -and $global:TuiState.CommandPalette.Visible) {
                try {
                    $global:TuiState.CommandPalette.Render()
                    $paletteBuffer = $global:TuiState.CommandPalette.GetBuffer()
                    if ($paletteBuffer) {
                        # Command palette position was set during initialization
                        $global:TuiState.CompositorBuffer.BlendBuffer($paletteBuffer, 
                            $global:TuiState.CommandPalette.X,
                            $global:TuiState.CommandPalette.Y
                        )
                    }
                }
                catch {
                    Write-Verbose "Error rendering command palette: $_"
                }
            }
            
            # Render overlays
            if ($global:TuiState.ContainsKey('OverlayStack') -and $global:TuiState.OverlayStack -and @($global:TuiState.OverlayStack).Count -gt 0) {
                foreach ($overlay in $global:TuiState.OverlayStack) {
                    if ($overlay -and $overlay.Visible) {
                        $overlay.Render()
                        $overlayBuffer = $overlay.GetBuffer()
                        if ($overlayBuffer) {
                            $global:TuiState.CompositorBuffer.BlendBuffer($overlayBuffer, $overlay.X, $overlay.Y)
                        }
                    }
                }
            }
        }
        
        # Force full redraw on first frame by making previous buffer different
        if ($global:TuiState.FrameCount -eq 0) {
            Write-Verbose "First frame - initializing previous buffer for differential rendering"
            # Fill previous buffer with different content to force full redraw
            for ($y = 0; $y -lt $global:TuiState.PreviousCompositorBuffer.Height; $y++) {
                for ($x = 0; $x -lt $global:TuiState.PreviousCompositorBuffer.Width; $x++) {
                    $global:TuiState.PreviousCompositorBuffer.SetCell($x, $y, 
                        [TuiCell]::new('?', "#404040", "#404040"))
                }
            }
        }
        
        # Differential rendering - compare current compositor to previous
        Render-DifferentialBuffer
        
        # Swap buffers for next frame - MUST happen AFTER rendering
        # Use the efficient Clone() method instead of manual copying
        $global:TuiState.PreviousCompositorBuffer = $global:TuiState.CompositorBuffer.Clone()
        
        # Clear compositor for next frame
        $bgColor = Get-ThemeColor -ColorName "Background" -DefaultColor "#000000"
        $global:TuiState.CompositorBuffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        $renderTimer.Stop()
        
        if ($renderTimer.ElapsedMilliseconds -gt 16) {
            Write-Verbose "Slow frame: $($renderTimer.ElapsedMilliseconds)ms"
        }
    }
    catch {
        Write-Error "Render error: $_"
        throw
    }
}

function Render-DifferentialBuffer {
    [CmdletBinding()]
    param()
    
    try {
        $current = $global:TuiState.CompositorBuffer
        $previous = $global:TuiState.PreviousCompositorBuffer
        
        # Ensure both buffers exist
        if ($null -eq $current -or $null -eq $previous) {
            Write-Verbose "Compositor buffers not initialized, skipping differential render"
            return
        }
        
        $ansiBuilder = [System.Text.StringBuilder]::new()
        $currentX = -1
        $currentY = -1
        $changeCount = 0
        
        for ($y = 0; $y -lt $current.Height; $y++) {
            for ($x = 0; $x -lt $current.Width; $x++) {
                $currentCell = $current.GetCell($x, $y)
                $previousCell = $previous.GetCell($x, $y)
                
                if ($currentCell.DiffersFrom($previousCell)) {
                    $changeCount++
                    
                    # Move cursor if needed
                    if ($currentX -ne $x -or $currentY -ne $y) {
                        [void]$ansiBuilder.Append("`e[$($y + 1);$($x + 1)H")
                        $currentX = $x
                        $currentY = $y
                    }
                    
                    # Use cell's ToAnsiString method which handles all styling
                    [void]$ansiBuilder.Append($currentCell.ToAnsiString())
                    $currentX++
                    
                    # Copy to previous buffer
                    $previous.SetCell($x, $y, [TuiCell]::new($currentCell))
                }
            }
        }
        
        # Log changes on first few frames
        if ($global:TuiState.FrameCount -lt 5) {
            Write-Verbose "Frame $($global:TuiState.FrameCount): $changeCount cells changed"
        }
        
        # Reset styling at end
        if ($ansiBuilder.Length -gt 0) {
            [void]$ansiBuilder.Append("`e[0m")
            [Console]::Write($ansiBuilder.ToString())
        }
    }
    catch {
        Write-Error "Differential rendering error: $_"
        throw
    }
}

#endregion
#<!-- END_PAGE: ART.003 -->

#<!-- PAGE: ART.004 - Input Processing -->
#region Input Processing

# PURPOSE:
#   Re-architects the input loop to be "focus-first," establishing a clear and correct
#   input processing hierarchy. This is the definitive fix for the UI lockup.
#
# LOGIC:
#   1. PRIORITY 1: FOCUSED COMPONENT - The component currently tracked by the FocusManager
#      (e.g., the CommandPalette's text box) ALWAYS gets the first chance to handle the key.
#      If it returns $true, the input cycle for that key is complete.
#   2. PRIORITY 2: BUBBLE TO OVERLAY - If the focused component returns $false, and an
#      overlay is active, the overlay container itself gets a chance to handle the key.
#      This is for container-level actions like 'Escape' to close. The input cycle stops
#      here to enforce modality.
#   3. PRIORITY 3 & 4: GLOBALS & SCREEN - If no overlay is active, the event continues
#      to global keybindings and finally to the base screen.
#
function Process-TuiInput {
    [CmdletBinding()]
    param()
    try {
        while ([Console]::KeyAvailable) {
            $keyInfo = [Console]::ReadKey($true)
            $focusManager = $global:TuiState.Services.FocusManager
            $keybindingService = $global:TuiState.Services.KeybindingService

            # Priority 1: The globally focused component ALWAYS gets the first chance.
            if ($focusManager.FocusedComponent?.HandleInput($keyInfo)) {
                $global:TuiState.IsDirty = $true
                continue
            }

            # Priority 2: If focus was not handled, "bubble up". Check for an active overlay.
            if ($global:TuiState.OverlayStack.Count -gt 0) {
                $topOverlay = $global:TuiState.OverlayStack[-1]
                # Let the overlay container handle keys the child did not (e.g., Escape).
                if ($topOverlay?.HandleInput($keyInfo)) {
                    $global:TuiState.IsDirty = $true
                }
                # Always 'continue' to enforce modal behavior, consuming the input.
                continue
            }

            # --- Only runs if no overlay is active ---

            # Priority 3: Global Keybindings (e.g., Ctrl+Q).
            $action = $keybindingService?.GetAction($keyInfo)
            if ($action) {
                $global:TuiState.Services.ActionService?.ExecuteAction($action, @{})
                $global:TuiState.IsDirty = $true
                continue
            }

            # Priority 4: The Current Screen gets the last chance.
            if ($global:TuiState.CurrentScreen?.HandleInput($keyInfo)) {
                $global:TuiState.IsDirty = $true
                continue
            }
        }
    }
    catch {
        Write-Log -Level Error -Message "Input processing error: $($_.Exception.Message)" -Data $_
    }
}

#endregion
#<!-- END_PAGE: ART.004 -->

#<!-- PAGE: ART.005 - Screen Management -->
#region Overlay Management

function Show-TuiOverlay {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [UIElement]$Overlay
    )
    
    Write-Warning "Show-TuiOverlay is deprecated. Use DialogManager.ShowDialog() for dialogs or manage overlays directly."
    
    # Use DialogManager if the overlay is a Dialog
    if ($Overlay.GetType().Name -match "Dialog") {
        $dialogManager = $global:TuiState.Services.DialogManager
        if ($dialogManager) {
            $dialogManager.ShowDialog($Overlay)
            return
        }
    }
    
    # For non-dialog overlays, handle manually (deprecated path)
    if (-not $global:TuiState.OverlayStack) {
        $global:TuiState.OverlayStack = [System.Collections.Generic.List[UIElement]]::new()
    }
    
    # Position overlay at center
    $consoleWidth = $global:TuiState.BufferWidth
    $consoleHeight = $global:TuiState.BufferHeight
    $Overlay.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $Overlay.Width) / 2))
    $Overlay.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $Overlay.Height) / 2))
    
    $Overlay.Visible = $true
    $Overlay.IsOverlay = $true
    $global:TuiState.OverlayStack.Add($Overlay)
    $global:TuiState.IsDirty = $true
    
    # Write-Log -Level Debug -Message "Show-TuiOverlay: Displayed overlay '$($Overlay.Name)' at X=$($Overlay.X), Y=$($Overlay.Y)"
}

function Close-TopTuiOverlay {
    [CmdletBinding()]
    param()
    
    Write-Warning "Close-TopTuiOverlay is deprecated. Use DialogManager.HideDialog() for dialogs or manage overlays directly."
    
    if ($global:TuiState.OverlayStack.Count -eq 0) {
        # Write-Log -Level Warning -Message "Close-TopTuiOverlay: No overlays to close"
        return
    }
    
    $topOverlay = $global:TuiState.OverlayStack[-1]
    
    # Use DialogManager if it's a Dialog
    if ($topOverlay.GetType().Name -match "Dialog") {
        $dialogManager = $global:TuiState.Services.DialogManager
        if ($dialogManager) {
            $dialogManager.HideDialog($topOverlay)
            return
        }
    }
    
    # Manual removal for non-dialog overlays (deprecated path)
    $global:TuiState.OverlayStack.RemoveAt($global:TuiState.OverlayStack.Count - 1)
    $topOverlay.Visible = $false
    $topOverlay.IsOverlay = $false
    $topOverlay.Cleanup()
    $global:TuiState.IsDirty = $true
    
    # Write-Log -Level Debug -Message "Close-TopTuiOverlay: Closed overlay '$($topOverlay.Name)'"
}

#endregion
#<!-- END_PAGE: ART.005 -->

#<!-- PAGE: ART.006 - Error Handling -->
#region Panic Handler

function Invoke-PanicHandler {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [object]$ErrorRecord
    )
    
    # Ensure we're in a safe state to write to console
    try {
        [Console]::ResetColor()
        [Console]::CursorVisible = $true
        Clear-Host
    } catch { }
    
    Write-Host "`n`n" -NoNewline
    Write-Host "================================ PANIC HANDLER ================================" -ForegroundColor Red
    Write-Host ""
    Write-Host "An unrecoverable error has occurred:" -ForegroundColor Yellow
    Write-Host ""
    
    # Error details
    Write-Host "ERROR: " -ForegroundColor Red -NoNewline
    Write-Host $ErrorRecord.Exception.Message
    Write-Host ""
    Write-Host "TYPE: " -ForegroundColor Yellow -NoNewline
    Write-Host $ErrorRecord.Exception.GetType().FullName
    Write-Host ""
    
    # Stack trace
    Write-Host "STACK TRACE:" -ForegroundColor Yellow
    $stackLines = $ErrorRecord.ScriptStackTrace -split "`n"
    foreach ($line in $stackLines) {
        Write-Host "  $line" -ForegroundColor DarkGray
    }
    Write-Host ""
    
    # System info
    Write-Host "SYSTEM INFO:" -ForegroundColor Yellow
    Write-Host "  PowerShell: $($PSVersionTable.PSVersion)" -ForegroundColor DarkGray
    Write-Host "  Platform: $($PSVersionTable.Platform)" -ForegroundColor DarkGray
    Write-Host "  OS: $($PSVersionTable.OS)" -ForegroundColor DarkGray
    Write-Host "  Host: $($Host.Name) v$($Host.Version)" -ForegroundColor DarkGray
    Write-Host ""
    
    # Save crash report
    $crashDir = Join-Path $env:TEMP "AxiomPhoenix\Crashes"
    if (-not (Test-Path $crashDir)) {
        New-Item -ItemType Directory -Path $crashDir -Force | Out-Null
    }
    
    $crashFile = Join-Path $crashDir "crash_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
    $crashReport = @{
        Timestamp = [datetime]::Now
        Error = @{
            Message = $ErrorRecord.Exception.Message
            Type = $ErrorRecord.Exception.GetType().FullName
            StackTrace = $ErrorRecord.ScriptStackTrace
            InnerException = if ($ErrorRecord.Exception.InnerException) { $ErrorRecord.Exception.InnerException.Message } else { $null }
        }
        System = @{
            PowerShell = $PSVersionTable.PSVersion.ToString()
            Platform = $PSVersionTable.Platform
            OS = $PSVersionTable.OS
            Host = "$($Host.Name) v$($Host.Version)"
        }
        GlobalState = @{
            Running = $global:TuiState.Running
            BufferSize = "$($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight)"
            CurrentScreen = if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.Name } else { "None" }
            OverlayCount = if ($global:TuiState.OverlayStack) { $global:TuiState.OverlayStack.Count } else { 0 }
        }
    }
    
    try {
        $crashReport | ConvertTo-Json -Depth 10 | Out-File -FilePath $crashFile -Encoding UTF8
        Write-Host "Crash report saved to: $crashFile" -ForegroundColor Green
    } catch {
        Write-Host "Failed to save crash report: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    Write-Host ""
    Write-Host "=============================================================================" -ForegroundColor Red
    Write-Host ""
    Write-Host "Press any key to exit..." -ForegroundColor Yellow
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    
    # Final cleanup
    try {
        Stop-TuiEngine -Force
    } catch { }
    
    exit 1
}

function Start-AxiomPhoenix {
    [CmdletBinding()]
    param(
        [ServiceContainer]$ServiceContainer,
        [Screen]$InitialScreen
    )
    
    try {
        # Write-Log -Level Info -Message "Starting Axiom-Phoenix application..."
        
        # Store services
        $global:TuiState.Services = @{
            ServiceContainer = $ServiceContainer
        }
        
        # Extract key services for quick access
        $serviceNames = @(
            'ActionService', 'KeybindingService', 'NavigationService', 
            'DataManager', 'ThemeManager', 'EventManager', 'Logger', 'FocusManager', 'DialogManager', 'TuiFrameworkService' # Add new services
        )
        
        foreach ($serviceName in $serviceNames) {
            try {
                $service = $ServiceContainer.GetService($serviceName)
                if ($service) {
                    $global:TuiState.Services[$serviceName] = $service
                }
            }
            catch {
                # Write-Log -Level Warning -Message "Failed to get service '$serviceName': $($_.Exception.Message)" -Data $_
            }
        }
        
        # Create command palette if available
        $actionService = $global:TuiState.Services.ActionService
        if ($actionService) {
            $global:TuiState.CommandPalette = [CommandPalette]::new("GlobalCommandPalette", $actionService)
            $global:TuiState.CommandPalette.RefreshActions()
        }
        
        # Initialize engine
        Initialize-TuiEngine
        
        # Get the NavigationService instance directly from global state
        $navService = $global:TuiState.Services.NavigationService

        # Set initial screen using NavigationService (CRUCIAL FIX)
        if ($InitialScreen) {
            $navService.NavigateTo($InitialScreen) # Use the service directly
        }
        else {
            # Write-Log -Level Warning -Message "No initial screen provided. Application might not display anything."
        }
        
        # Start main loop
        Start-TuiEngine
    }
    catch {
        # Use Invoke-PanicHandler for critical startup errors
        Invoke-PanicHandler $_
    }
    finally {
        Stop-TuiEngine # Ensure cleanup even if startup fails
    }
}

#endregion
#<!-- END_PAGE: ART.006 -->



####\AllScreens.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Screens (Load After Components)
# Application screens that extend Screen base class
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASC.###" to find specific sections.
# Each section ends with "END_PAGE: ASC.###"
# ==============================================================================

using namespace System.Collections.Generic

#<!-- PAGE: ASC.001 - DashboardScreen Class -->
#region Screen Classes

class DashboardScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [Panel] $_summaryPanel
    hidden [Panel] $_statusPanel
    hidden [Panel] $_helpPanel
    #endregion

    #region State
    hidden [int] $_totalTasks = 0
    hidden [int] $_completedTasks = 0
    hidden [int] $_pendingTasks = 0
    hidden [string] $_dataChangeSubscriptionId = $null # Store event subscription ID
    #endregion

    DashboardScreen([object]$serviceContainer) : base("DashboardScreen", $serviceContainer) {}

    [void] Initialize() {
        Write-Verbose "DashboardScreen.Initialize called. Screen size: $($this.Width)x$($this.Height)"
        
        if (-not $this.ServiceContainer) {
            Write-Verbose "DashboardScreen.Initialize: ServiceContainer is null"
            return
        }
        
        # Ensure minimum size
        if ($this.Width -lt 80) { $this.Width = 80 }
        if ($this.Height -lt 24) { $this.Height = 24 }
        
        $this._mainPanel = [Panel]::new("Axiom-Phoenix Dashboard")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = "Axiom-Phoenix Dashboard"
        $this._mainPanel.UpdateContentDimensions()
        $this.AddChild($this._mainPanel)

        $summaryWidth = [Math]::Floor($this.Width * 0.5)
        $this._summaryPanel = [Panel]::new("Task Summary")
        $this._summaryPanel.X = 1
        $this._summaryPanel.Y = 1
        $this._summaryPanel.Width = $summaryWidth
        $this._summaryPanel.Height = 12
        $this._summaryPanel.Title = "Task Summary"
        $this._summaryPanel.UpdateContentDimensions()
        $this._mainPanel.AddChild($this._summaryPanel)

        $helpX = $summaryWidth + 2
        $helpWidth = $this.Width - $helpX - 1
        $this._helpPanel = [Panel]::new("Quick Start")
        $this._helpPanel.X = $helpX
        $this._helpPanel.Y = 1
        $this._helpPanel.Width = $helpWidth
        $this._helpPanel.Height = 12
        $this._helpPanel.Title = "Quick Start"
        $this._helpPanel.UpdateContentDimensions()
        $this._mainPanel.AddChild($this._helpPanel)

        $this._statusPanel = [Panel]::new("System Status")
        $this._statusPanel.X = 1
        $this._statusPanel.Y = 14
        $this._statusPanel.Width = $this.Width - 2
        $this._statusPanel.Height = $this.Height - 15
        $this._statusPanel.Title = "System Status"
        $this._statusPanel.UpdateContentDimensions()
        $this._mainPanel.AddChild($this._statusPanel)
    }

    [void] OnEnter() {
        # Subscribe to data change events for reactive updates
        $eventManager = $this.ServiceContainer?.GetService("EventManager")
        if ($eventManager) {
            # Create handler that properly captures $this
            $thisScreen = $this
            $handler = {
                param($eventData)
                Write-Verbose "DashboardScreen received data change event. Refreshing..."
                $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
                $thisScreen._RefreshData($dataManager)
            }.GetNewClosure()
            
            # Subscribe to both task and project changes
            $this._dataChangeSubscriptionId = $eventManager.Subscribe("Tasks.Changed", $handler)
            Write-Verbose "DashboardScreen subscribed to data change events"
        }
        
        # Force a complete redraw of all panels
        if ($this._summaryPanel) { $this._summaryPanel.RequestRedraw() }
        if ($this._helpPanel) { $this._helpPanel.RequestRedraw() }
        if ($this._statusPanel) { $this._statusPanel.RequestRedraw() }
        if ($this._mainPanel) { $this._mainPanel.RequestRedraw() }
        
        if ($this.ServiceContainer) {
            $this._RefreshData($this.ServiceContainer.GetService("DataManager"))
        } else {
            Write-Verbose "DashboardScreen.OnEnter: ServiceContainer is null, using defaults"
            $this._RefreshData($null)
        }
        
        # Force another redraw after data refresh
        $this.RequestRedraw()
    }
    
    [void] OnExit() {
        # Unsubscribe from data change events
        $eventManager = $this.ServiceContainer?.GetService("EventManager")
        if ($eventManager -and $this._dataChangeSubscriptionId) {
            $eventManager.Unsubscribe("Tasks.Changed", $this._dataChangeSubscriptionId)
            $this._dataChangeSubscriptionId = $null
            Write-Verbose "DashboardScreen unsubscribed from data change events"
        }
        
        # Call base OnExit
        ([Screen]$this).OnExit()
    }

    hidden [void] _RefreshData([object]$dataManager) {
        if(-not $dataManager) {
            Write-Verbose "DashboardScreen: DataManager service not found."
            $this._totalTasks = 0
            $this._completedTasks = 0
            $this._pendingTasks = 0
        } else {
            $allTasks = $dataManager.GetTasks()
            if ($allTasks) {
                $this._totalTasks = @($allTasks).Count
                $this._completedTasks = @($allTasks | Where-Object { $_.Completed }).Count
                $this._pendingTasks = $this._totalTasks - $this._completedTasks
            } else {
                $this._totalTasks = 0
                $this._completedTasks = 0
                $this._pendingTasks = 0
            }
        }
        $this._UpdateDisplay()
    }
    
    hidden [void] _UpdateDisplay() {
        $this._UpdateSummaryPanel()
        $this._UpdateHelpPanel()
        $this._UpdateStatusPanel()
        $this.RequestRedraw()
    }
    
    hidden [void] _UpdateSummaryPanel() {
        $panel = $this._summaryPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        # Force content dimensions update
        $panel.UpdateContentDimensions()
        
        # Ensure we have a reasonable width
        $labelWidth = [Math]::Max(20, $panel.ContentWidth - 2)

        # Create label components instead of direct buffer drawing
        $titleLabel = [LabelComponent]::new("SummaryTitle")
        $titleLabel.Text = "Task Overview"
        $titleLabel.ForegroundColor = Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF"
        $titleLabel.X = 1
        $titleLabel.Y = 0
        $titleLabel.Width = $labelWidth
        $titleLabel.Height = 1
        $panel.AddChild($titleLabel)
        
        # Only create separator if there's space for it
        $lineWidth = [Math]::Max(0, $labelWidth)
        if ($lineWidth -gt 0) {
            $separatorLabel = [LabelComponent]::new("SummarySeparator")
            $separatorLabel.Text = '' * $lineWidth
            $separatorLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $separatorLabel.X = 1
            $separatorLabel.Y = 1
            $separatorLabel.Width = $labelWidth
            $separatorLabel.Height = 1
            $panel.AddChild($separatorLabel)
        }
        
        $totalLabel = [LabelComponent]::new("TotalTasks")
        $totalLabel.Text = "Total Tasks:    $($this._totalTasks)"
        $totalLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $totalLabel.X = 1
        $totalLabel.Y = 3
        $totalLabel.Width = $labelWidth
        $totalLabel.Height = 1
        $panel.AddChild($totalLabel)
        
        $completedLabel = [LabelComponent]::new("CompletedTasks")
        $completedLabel.Text = "Completed:      $($this._completedTasks)"
        $completedLabel.ForegroundColor = Get-ThemeColor -ColorName "Success" -DefaultColor "#00FF00"
        $completedLabel.X = 1
        $completedLabel.Y = 4
        $completedLabel.Width = $labelWidth
        $completedLabel.Height = 1
        $panel.AddChild($completedLabel)
        
        $pendingLabel = [LabelComponent]::new("PendingTasks")
        $pendingLabel.Text = "Pending:        $($this._pendingTasks)"
        $pendingLabel.ForegroundColor = Get-ThemeColor -ColorName "Warning" -DefaultColor "#FFA500"
        $pendingLabel.X = 1
        $pendingLabel.Y = 5
        $pendingLabel.Width = $labelWidth
        $pendingLabel.Height = 1
        $panel.AddChild($pendingLabel)
        
        # Create progress bar as labels
        if ($this._totalTasks -eq 0) { 
            $percentage = 0 
        } else { 
            $percentage = [Math]::Round(($this._completedTasks / $this._totalTasks) * 100) 
        }
        $progressLabel = [LabelComponent]::new("ProgressLabel")
        $progressLabel.Text = "Overall Progress: $percentage%"
        $progressLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $progressLabel.X = 1
        $progressLabel.Y = 7
        $progressLabel.Width = $labelWidth
        $progressLabel.Height = 1
        $panel.AddChild($progressLabel)
        
        # Progress bar visualization
        $barWidth = [Math]::Min(20, $labelWidth - 2)
        $filledWidth = [Math]::Floor($barWidth * $percentage / 100)
        $emptyWidth = $barWidth - $filledWidth
        $barText = "[" + ("" * $filledWidth) + ("" * $emptyWidth) + "]"
        
        $barLabel = [LabelComponent]::new("ProgressBar")
        $barLabel.Text = $barText
        $barLabel.ForegroundColor = Get-ThemeColor -ColorName "Success" -DefaultColor "#00FF00"
        $barLabel.X = 1
        $barLabel.Y = 8
        $barLabel.Width = $labelWidth
        $barLabel.Height = 1
        $panel.AddChild($barLabel)
        
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateHelpPanel() {
        $panel = $this._helpPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        # Force content dimensions update
        $panel.UpdateContentDimensions()
        
        # Ensure we have a reasonable width
        $labelWidth = [Math]::Max(20, $panel.ContentWidth - 2)
        
        $paletteHotkey = "Ctrl+P"
        
        # Create label components for help panel
        $welcomeLabel = [LabelComponent]::new("WelcomeLabel")
        $welcomeLabel.Text = "Welcome to Axiom-Phoenix!"
        $welcomeLabel.ForegroundColor = Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF"
        $welcomeLabel.X = 1
        $welcomeLabel.Y = 0
        $welcomeLabel.Width = $labelWidth
        $welcomeLabel.Height = 1
        $panel.AddChild($welcomeLabel)
        
        $lineWidth = [Math]::Max(0, $labelWidth)
        if ($lineWidth -gt 0) {
            $separatorLabel = [LabelComponent]::new("HelpSeparator")
            $separatorLabel.Text = '' * $lineWidth
            $separatorLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $separatorLabel.X = 1
            $separatorLabel.Y = 1
            $separatorLabel.Width = $labelWidth
            $separatorLabel.Height = 1
            $panel.AddChild($separatorLabel)
        }
        
        # Create multi-part label for the hotkey instruction
        $instructionLabel1 = [LabelComponent]::new("Instruction1")
        $instructionLabel1.Text = "Press $paletteHotkey to open the"
        $instructionLabel1.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $instructionLabel1.X = 1
        $instructionLabel1.Y = 3
        $instructionLabel1.Width = $labelWidth
        $instructionLabel1.Height = 1
        $panel.AddChild($instructionLabel1)
        
        $instructionLabel2 = [LabelComponent]::new("Instruction2")
        $instructionLabel2.Text = "Command Palette."
        $instructionLabel2.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $instructionLabel2.X = 1
        $instructionLabel2.Y = 4
        $instructionLabel2.Width = $labelWidth
        $instructionLabel2.Height = 1
        $panel.AddChild($instructionLabel2)

        $infoLabel1 = [LabelComponent]::new("InfoLabel1")
        $infoLabel1.Text = "All navigation and actions are"
        $infoLabel1.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
        $infoLabel1.X = 1
        $infoLabel1.Y = 6
        $infoLabel1.Width = $labelWidth
        $infoLabel1.Height = 1
        $panel.AddChild($infoLabel1)
        
        $infoLabel2 = [LabelComponent]::new("InfoLabel2")
        $infoLabel2.Text = "now available from there."
        $infoLabel2.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
        $infoLabel2.X = 1
        $infoLabel2.Y = 7
        $infoLabel2.Width = $labelWidth
        $infoLabel2.Height = 1
        $panel.AddChild($infoLabel2)
        
        $panel.RequestRedraw()
    }
    
    hidden [void] _UpdateStatusPanel() {
        $panel = $this._statusPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        # Force content dimensions update
        $panel.UpdateContentDimensions()
        
        # Ensure we have a reasonable width
        $labelWidth = [Math]::Max(20, $panel.ContentWidth - 2)

        $memoryMB = try { [Math]::Round((Get-Process -Id $global:PID).WorkingSet64 / 1MB, 2) } catch { 0 }

        # Create label components for status panel
        $titleLabel = [LabelComponent]::new("StatusTitle")
        $titleLabel.Text = "Environment"
        $titleLabel.ForegroundColor = Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF"
        $titleLabel.X = 1
        $titleLabel.Y = 0
        $titleLabel.Width = $labelWidth
        $titleLabel.Height = 1
        $panel.AddChild($titleLabel)
        
        $lineWidth = [Math]::Max(0, $labelWidth)
        if ($lineWidth -gt 0) {
            $separatorLabel = [LabelComponent]::new("StatusSeparator")
            $separatorLabel.Text = '' * $lineWidth
            $separatorLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $separatorLabel.X = 1
            $separatorLabel.Y = 1
            $separatorLabel.Width = $labelWidth
            $separatorLabel.Height = 1
            $panel.AddChild($separatorLabel)
        }
        
        $versionLabel = [LabelComponent]::new("PSVersion")
        $versionLabel.Text = "PowerShell Version: $($global:PSVersionTable.PSVersion)"
        $versionLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $versionLabel.X = 1
        $versionLabel.Y = 3
        $versionLabel.Width = $labelWidth
        $versionLabel.Height = 1
        $panel.AddChild($versionLabel)
        
        $memoryLabel = [LabelComponent]::new("MemoryUsage")
        $memoryLabel.Text = "Memory Usage: ${memoryMB} MB"
        $memoryLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $memoryLabel.X = 1
        $memoryLabel.Y = 4
        $memoryLabel.Width = $labelWidth
        $memoryLabel.Height = 1
        $panel.AddChild($memoryLabel)
        
        $hostLabel = [LabelComponent]::new("HostName")
        $hostLabel.Text = "Host: $($global:Host.Name)"
        $hostLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $hostLabel.X = 1
        $hostLabel.Y = 5
        $hostLabel.Width = $labelWidth
        $hostLabel.Height = 1
        $panel.AddChild($hostLabel)
        
        $panel.RequestRedraw()
    }


    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Dashboard doesn't handle specific input - all navigation via command palette
        # Input not handled
    }
}

#endregion
#<!-- END_PAGE: ASC.001 -->

#<!-- PAGE: ASC.002 - TaskListScreen Class -->
#region TaskListScreen Class

class TaskListScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [ScrollablePanel] $_taskListPanel
    hidden [Panel] $_detailPanel
    hidden [Panel] $_statusBar
    hidden [ButtonComponent] $_newButton
    hidden [ButtonComponent] $_editButton
    hidden [ButtonComponent] $_deleteButton
    hidden [ButtonComponent] $_completeButton
    hidden [TextBoxComponent] $_filterBox
    #endregion

    #region State
    hidden [System.Collections.Generic.List[PmcTask]] $_tasks
    hidden [int] $_selectedIndex = 0
    hidden [PmcTask] $_selectedTask
    hidden [string] $_filterText = ""
    hidden [System.Nullable[TaskStatus]] $_filterStatus = $null
    hidden [System.Nullable[TaskPriority]] $_filterPriority = $null
    hidden [string] $_taskChangeSubscriptionId = $null # Store event subscription ID
    #endregion

    TaskListScreen([object]$serviceContainer) : base("TaskListScreen", $serviceContainer) {}

    [void] Initialize() {
        if (-not $this.ServiceContainer) {
            Write-Verbose "TaskListScreen.Initialize: ServiceContainer is null"
            return
        }
        
        # Ensure minimum size
        if ($this.Width -lt 80) { $this.Width = 80 }
        if ($this.Height -lt 24) { $this.Height = 24 }
        
        $this._mainPanel = [Panel]::new("Task List")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = "Task List"
        $this._mainPanel.UpdateContentDimensions()
        $this.AddChild($this._mainPanel)

        # Add filter textbox at the top
        $this._filterBox = [TextBoxComponent]::new("FilterBox")
        $this._filterBox.Placeholder = "Type to filter tasks..."
        $this._filterBox.X = 2
        $this._filterBox.Y = 2
        $this._filterBox.Width = [Math]::Floor($this.Width * 0.6) - 4
        $this._filterBox.Height = 1
        $thisScreen = $this
        $this._filterBox.OnChange = {
            param($newText)
            $thisScreen._filterText = $newText
            $thisScreen._RefreshTasks()
            $thisScreen._UpdateDisplay()
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._filterBox)

        # Task list panel (left side)
        $listWidth = [Math]::Floor($this.Width * 0.6)
        $this._taskListPanel = [ScrollablePanel]::new("Tasks")
        $this._taskListPanel.X = 1
        $this._taskListPanel.Y = 4  # Move down to accommodate filter
        $this._taskListPanel.Width = $listWidth
        $this._taskListPanel.Height = $this.Height - 8  # Adjust for buttons and filter
        $this._taskListPanel.Title = "Tasks"
        $this._taskListPanel.UpdateContentDimensions()
        $this._mainPanel.AddChild($this._taskListPanel)

        # Detail panel (right side)
        $detailX = $listWidth + 2
        $detailWidth = $this.Width - $detailX - 1
        $this._detailPanel = [Panel]::new("Task Details")
        $this._detailPanel.X = $detailX
        $this._detailPanel.Y = 1
        $this._detailPanel.Width = $detailWidth
        $this._detailPanel.Height = $this.Height - 8  # Adjust for buttons
        $this._detailPanel.Title = "Task Details"
        $this._detailPanel.UpdateContentDimensions()
        $this._mainPanel.AddChild($this._detailPanel)

        # Status bar
        $this._statusBar = [Panel]::new("StatusBar")
        $this._statusBar.X = 1
        $this._statusBar.Y = $this.Height - 2
        $this._statusBar.Width = $this.Width - 2
        $this._statusBar.Height = 1
        $this._statusBar.HasBorder = $false
        $this._mainPanel.AddChild($this._statusBar)
        
        # Add CRUD action buttons at the bottom
        $buttonY = $this.Height - 3
        $buttonSpacing = 15
        $currentX = 2
        
        # New button
        $this._newButton = [ButtonComponent]::new("NewButton")
        $this._newButton.Text = "[N]ew Task"
        $this._newButton.X = $currentX
        $this._newButton.Y = $buttonY
        $this._newButton.Width = 12
        $this._newButton.Height = 1
        $this._newButton.OnClick = {
            $dialogManager = $thisScreen.ServiceContainer?.GetService("DialogManager")
            $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
            
            if ($dialogManager -and $dataManager) {
                $dialog = [TaskDialog]::new("New Task", $null)
                $dialogManager.ShowDialog($dialog)
                
                if ($dialog.DialogResult -eq [DialogResult]::OK) {
                    $newTask = $dialog.GetTask()
                    $dataManager.AddTask($newTask)
                    $thisScreen._RefreshTasks()
                    $thisScreen._UpdateDisplay()
                    Write-Verbose "New task created: $($newTask.Title)"
                }
            }
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._newButton)
        $currentX += $buttonSpacing
        
        # Edit button
        $this._editButton = [ButtonComponent]::new("EditButton")
        $this._editButton.Text = "[E]dit Task"
        $this._editButton.X = $currentX
        $this._editButton.Y = $buttonY
        $this._editButton.Width = 12
        $this._editButton.Height = 1
        $this._editButton.OnClick = {
            $dialogManager = $thisScreen.ServiceContainer?.GetService("DialogManager")
            $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
            
            if ($dialogManager -and $dataManager -and $thisScreen._selectedTask) {
                $dialog = [TaskDialog]::new("Edit Task", $thisScreen._selectedTask)
                $dialogManager.ShowDialog($dialog)
                
                if ($dialog.DialogResult -eq [DialogResult]::OK) {
                    $updatedTask = $dialog.GetTask()
                    $dataManager.UpdateTask($updatedTask)
                    $thisScreen._RefreshTasks()
                    $thisScreen._UpdateDisplay()
                    Write-Verbose "Task updated: $($updatedTask.Title)"
                }
            }
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._editButton)
        $currentX += $buttonSpacing
        
        # Delete button
        $this._deleteButton = [ButtonComponent]::new("DeleteButton")
        $this._deleteButton.Text = "[D]elete Task"
        $this._deleteButton.X = $currentX
        $this._deleteButton.Y = $buttonY
        $this._deleteButton.Width = 14
        $this._deleteButton.Height = 1
        $this._deleteButton.OnClick = {
            $dialogManager = $thisScreen.ServiceContainer?.GetService("DialogManager")
            $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
            
            if ($dialogManager -and $dataManager -and $thisScreen._selectedTask) {
                $dialog = [TaskDeleteDialog]::new($thisScreen._selectedTask)
                $dialogManager.ShowDialog($dialog)
                
                if ($dialog.DialogResult -eq [DialogResult]::Yes) {
                    $dataManager.DeleteTask($thisScreen._selectedTask.Id)
                    $thisScreen._RefreshTasks()
                    $thisScreen._UpdateDisplay()
                    Write-Verbose "Task deleted: $($thisScreen._selectedTask.Title)"
                }
            }
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._deleteButton)
        $currentX += $buttonSpacing + 2
        
        # Complete button
        $this._completeButton = [ButtonComponent]::new("CompleteButton")
        $this._completeButton.Text = "[C]omplete"
        $this._completeButton.X = $currentX
        $this._completeButton.Y = $buttonY
        $this._completeButton.Width = 12
        $this._completeButton.Height = 1
        $this._completeButton.OnClick = {
            $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
            
            if ($dataManager -and $thisScreen._selectedTask) {
                $thisScreen._selectedTask.Complete()
                $dataManager.UpdateTask($thisScreen._selectedTask)
                $thisScreen._RefreshTasks()
                $thisScreen._UpdateDisplay()
                Write-Verbose "Task completed: $($thisScreen._selectedTask.Title)"
            }
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._completeButton)
        
        $this._tasks = [System.Collections.Generic.List[PmcTask]]::new()
    }

    [void] OnEnter() {
        # Subscribe to data change events for reactive updates
        $eventManager = $this.ServiceContainer?.GetService("EventManager")
        if ($eventManager) {
            # Create handler that properly captures $this
            $thisScreen = $this
            $handler = {
                param($eventData)
                Write-Verbose "TaskListScreen received Tasks.Changed event. Refreshing tasks."
                $thisScreen._RefreshTasks()
                $thisScreen._UpdateDisplay()
            }.GetNewClosure()
            
            # Store subscription ID for later cleanup
            $this._taskChangeSubscriptionId = $eventManager.Subscribe("Tasks.Changed", $handler)
            Write-Verbose "TaskListScreen subscribed to Tasks.Changed events"
        }
        
        if ($this.ServiceContainer) {
            $this._RefreshTasks()
        }
        
        $this.RequestRedraw()
    }
    
    [void] OnExit() {
        # Unsubscribe from data change events
        $eventManager = $this.ServiceContainer?.GetService("EventManager")
        if ($eventManager -and $this._taskChangeSubscriptionId) {
            $eventManager.Unsubscribe("Tasks.Changed", $this._taskChangeSubscriptionId)
            $this._taskChangeSubscriptionId = $null
            Write-Verbose "TaskListScreen unsubscribed from Tasks.Changed events"
        }
        
        # Call base OnExit if needed
        ([Screen]$this).OnExit()
    }

    hidden [void] _RefreshTasks() {
        $dataManager = $this.ServiceContainer?.GetService("DataManager")
        if ($dataManager) {
            $allTasks = $dataManager.GetTasks()
            
            # Apply text filter if present
            if (![string]::IsNullOrWhiteSpace($this._filterText)) {
                $filterLower = $this._filterText.ToLower()
                $allTasks = @($allTasks | Where-Object {
                    $_.Title.ToLower().Contains($filterLower) -or
                    ($_.Description -and $_.Description.ToLower().Contains($filterLower))
                })
            }
            
            $this._tasks = [System.Collections.Generic.List[PmcTask]]::new()
            if ($allTasks) {
                # Fix: Explicitly cast each item to PmcTask to avoid type conversion error
                foreach ($task in $allTasks) {
                    if ($task -is [PmcTask]) {
                        $this._tasks.Add($task)
                    }
                }
            }
        } else {
            $this._tasks = [System.Collections.Generic.List[PmcTask]]::new()
        }
        
        # Reset selection if needed
        if ($this._selectedIndex -ge $this._tasks.Count) {
            $this._selectedIndex = [Math]::Max(0, $this._tasks.Count - 1)
        }
        
        if ($this._tasks.Count -gt 0) {
            $this._selectedTask = $this._tasks[$this._selectedIndex]
        } else {
            $this._selectedTask = $null
        }
    }

    hidden [void] _UpdateDisplay() {
        $this._UpdateTaskList()
        $this._UpdateDetailPanel()
        $this._UpdateStatusBar()
        $this.RequestRedraw()
    }

    hidden [void] _UpdateTaskList() {
        $panel = $this._taskListPanel
        if (-not $panel) { return }
        
        # CRITICAL: Clear the panel's CHILDREN, not its buffer directly.
        $panel.Children.Clear()
        
        if ($this._tasks.Count -eq 0) {
            # Add a label to show there are no tasks
            $noTasksLabel = [LabelComponent]::new("NoTasksLabel")
            $noTasksLabel.X = 2
            $noTasksLabel.Y = 2
            $noTasksLabel.Text = "No tasks found."
            $noTasksLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $panel.AddChild($noTasksLabel)
            $panel.RequestRedraw()
            return
        }
        
        for ($i = 0; $i -lt $this._tasks.Count; $i++) {
            $task = $this._tasks[$i]
            
            # Create a Panel for each task item (to support background color)
            $taskPanel = [Panel]::new("TaskItem_$($task.Id)")
            $taskPanel.X = 0
            $taskPanel.Y = $i # Y position is its index in the list
            $panelContentWidth = if ($panel.ContentWidth -le 0) { [Math]::Max(30, $panel.Width - 2) } else { $panel.ContentWidth }
            $taskPanel.Width = $panelContentWidth
            $taskPanel.Height = 1
            $taskPanel.HasBorder = $false
            
            # Set background based on selection
            $is_selected = ($i -eq $this._selectedIndex)
            $taskPanel.BackgroundColor = if ($is_selected) { Get-ThemeColor -ColorName "list.item.selected.background" -DefaultColor "#0000FF" } else { Get-ThemeColor -ColorName "Background" -DefaultColor "#000000" }
            
            # Create a Label component for the task text
            $taskLabel = [LabelComponent]::new("TaskLabel_$($task.Id)")
            $taskLabel.X = 1 # Indent slightly
            $taskLabel.Y = 0 # Relative to the task panel
            $taskLabel.Width = [Math]::Max(20, $panelContentWidth - 2) # Set proper width
            $taskLabel.Height = 1
            
            # Status indicator
            $statusChar = switch ($task.Status) {
                ([TaskStatus]::Pending) { "" }
                ([TaskStatus]::InProgress) { "" }
                ([TaskStatus]::Completed) { "" }
                ([TaskStatus]::Cancelled) { "" }
                default { "?" }
            }
            
            # Priority indicator
            $priorityChar = switch ($task.Priority) {
                ([TaskPriority]::Low) { "" }
                ([TaskPriority]::Medium) { "" }
                ([TaskPriority]::High) { "" }
                default { "-" }
            }
            
            # Truncate title if needed
            $maxTitleLength = [Math]::Max(10, $panelContentWidth - 6) # Ensure minimum length
            if ($task.Title.Length -gt $maxTitleLength -and $maxTitleLength -gt 3) {
                $title = $task.Title.Substring(0, [Math]::Max(1, $maxTitleLength - 3)) + "..."
            } else {
                $title = $task.Title
            }
            
            $taskLine = "$statusChar $priorityChar $title"
            $taskLabel.Text = $taskLine
            
            # Set text color based on selection
            if ($is_selected) { 
                $taskLabel.ForegroundColor = Get-ThemeColor -ColorName "list.item.selected" -DefaultColor "#FFFFFF" 
            } else { 
                $taskLabel.ForegroundColor = Get-ThemeColor -ColorName "list.item.normal" -DefaultColor "#C0C0C0" 
            }
            
            # Add the label to the task panel
            $taskPanel.AddChild($taskLabel)
            
            # Add the task panel as a CHILD of the scrollable panel
            $panel.AddChild($taskPanel)
        }
        
        # The ScrollablePanel's own Render method will now correctly handle everything else.
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateDetailPanel() {
        $panel = $this._detailPanel
        if (-not $panel -or -not $this._selectedTask) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        # Force content dimensions update
        $panel.UpdateContentDimensions()
        
        $task = $this._selectedTask
        $y = 1 # Start position relative to panel
        
        # Title label
        $titleLabel = [LabelComponent]::new("DetailTitle")
        $titleLabel.X = 1
        $titleLabel.Y = $y++
        $titleLabel.Text = "Title: $($task.Title)"
        $titleLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
        $panel.AddChild($titleLabel)
        
        # Status label
        $statusLabel = [LabelComponent]::new("DetailStatus")
        $statusLabel.X = 1
        $statusLabel.Y = $y++
        $statusLabel.Text = "Status: $($task.Status)"
        $statusLabel.ForegroundColor = Get-ThemeColor -ColorName "Info" -DefaultColor "#00BFFF"
        $panel.AddChild($statusLabel)
        
        # Priority label
        $priorityLabel = [LabelComponent]::new("DetailPriority")
        $priorityLabel.X = 1
        $priorityLabel.Y = $y++
        $priorityLabel.Text = "Priority: $($task.Priority)"
        $priorityLabel.ForegroundColor = Get-ThemeColor -ColorName "Warning" -DefaultColor "#FFA500"
        $panel.AddChild($priorityLabel)
        
        # Progress label
        $progressLabel = [LabelComponent]::new("DetailProgress")
        $progressLabel.X = 1
        $progressLabel.Y = $y++
        $progressLabel.Text = "Progress: $($task.Progress)%"
        $progressLabel.ForegroundColor = Get-ThemeColor -ColorName "Success" -DefaultColor "#00FF00"
        $panel.AddChild($progressLabel)
        
        $y++ # Empty line
        
        # Description header
        $descHeaderLabel = [LabelComponent]::new("DetailDescHeader")
        $descHeaderLabel.X = 1
        $descHeaderLabel.Y = $y++
        $descHeaderLabel.Text = "Description:"
        $descHeaderLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
        $panel.AddChild($descHeaderLabel)
        
        if (-not [string]::IsNullOrEmpty($task.Description)) {
            # Word wrap description
            $words = $task.Description -split '\s+'
            $line = ""
            $maxLineLength = [Math]::Max(10, $panel.ContentWidth - 2)
            $lineIndex = 0
            
            foreach ($word in $words) {
                if (($line + " " + $word).Length -gt $maxLineLength) {
                    if ($line) {
                        # Create label for this line
                        $descLineLabel = [LabelComponent]::new("DetailDescLine$lineIndex")
                        $descLineLabel.X = 1
                        $descLineLabel.Y = $y++
                        $descLineLabel.Text = $line
                        $descLineLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
                        $panel.AddChild($descLineLabel)
                        $lineIndex++
                    }
                    $line = $word
                } else {
                    if ($line) { 
                        $line = "$line $word" 
                    } else { 
                        $line = $word 
                    }
                }
            }
            
            if ($line) {
                # Create label for last line
                $descLineLabel = [LabelComponent]::new("DetailDescLine$lineIndex")
                $descLineLabel.X = 1
                $descLineLabel.Y = $y++
                $descLineLabel.Text = $line
                $descLineLabel.ForegroundColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
                $panel.AddChild($descLineLabel)
            }
        } else {
            $noDescLabel = [LabelComponent]::new("DetailNoDesc")
            $noDescLabel.X = 1
            $noDescLabel.Y = $y++
            $noDescLabel.Text = "(No description)"
            $noDescLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $panel.AddChild($noDescLabel)
        }
        
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateStatusBar() {
        $panel = $this._statusBar
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        
        # Set panel background color
        $panel.BackgroundColor = Get-ThemeColor -ColorName "status.bar.bg" -DefaultColor "#1E1E1E"
        
        # Status text label
        $statusText = "Tasks: $($this._tasks.Count) | Selected: $($this._selectedIndex + 1)"
        if ($this._filterText) {
            $statusText += " | Filter: '$($this._filterText)'"
        }
        
        $statusLabel = [LabelComponent]::new("StatusText")
        $statusLabel.X = 0
        $statusLabel.Y = 0
        $statusLabel.Text = $statusText
        $statusLabel.ForegroundColor = Get-ThemeColor -ColorName "status.bar.fg" -DefaultColor "#FFFFFF"
        $panel.AddChild($statusLabel)
        
        # Keyboard hints label
        $hints = ": Navigate | Enter: Edit | D: Delete | N: New"
        $hintsX = $this.Width - $hints.Length - 3
        if ($hintsX -gt $statusText.Length + 2) {
            $hintsLabel = [LabelComponent]::new("StatusHints")
            $hintsLabel.X = $hintsX
            $hintsLabel.Y = 0
            $hintsLabel.Text = $hints
            $hintsLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
            $panel.AddChild($hintsLabel)
        }
        
        $panel.RequestRedraw()
    }

    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this._selectedIndex -gt 0) {
                    $this._selectedIndex--
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                    
                    # Adjust scroll if needed
                    if ($this._selectedIndex -lt $this._taskListPanel.ScrollOffsetY) {
                        $this._taskListPanel.ScrollUp()
                    }
                    
                    $this._UpdateDisplay()
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this._selectedIndex -lt $this._tasks.Count - 1) {
                    $this._selectedIndex++
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                    
                    # Adjust scroll if needed
                    $visibleEnd = $this._taskListPanel.ScrollOffsetY + $this._taskListPanel.ContentHeight - 1
                    if ($this._selectedIndex -gt $visibleEnd) {
                        $this._taskListPanel.ScrollDown()
                    }
                    
                    $this._UpdateDisplay()
                }
            }
            ([ConsoleKey]::PageUp) {
                $this._taskListPanel.ScrollUp($this._taskListPanel.ContentHeight)
                $this._selectedIndex = [Math]::Max(0, $this._selectedIndex - $this._taskListPanel.ContentHeight)
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::PageDown) {
                $this._taskListPanel.ScrollDown($this._taskListPanel.ContentHeight)
                $this._selectedIndex = [Math]::Min($this._tasks.Count - 1, $this._selectedIndex + $this._taskListPanel.ContentHeight)
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::Home) {
                $this._taskListPanel.ScrollToTop()
                $this._selectedIndex = 0
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::End) {
                $this._taskListPanel.ScrollToBottom()
                $this._selectedIndex = $this._tasks.Count - 1
                if ($this._tasks.Count -gt 0) {
                    $this._selectedTask = $this._tasks[$this._selectedIndex]
                }
                $this._UpdateDisplay()
            }
            ([ConsoleKey]::Enter) {
                # Edit task
                if ($this._selectedTask -and $this._editButton) {
                    $this._editButton.OnClick.Invoke()
                }
            }
            ([ConsoleKey]::N) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    # New task
                    $this._newButton.OnClick.Invoke()
                }
            }
            ([ConsoleKey]::E) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None -and $this._selectedTask) {
                    # Edit task
                    $this._editButton.OnClick.Invoke()
                }
            }
            ([ConsoleKey]::D) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None -and $this._selectedTask) {
                    # Delete task
                    $this._deleteButton.OnClick.Invoke()
                }
            }
            ([ConsoleKey]::C) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None -and $this._selectedTask) {
                    # Complete task
                    $this._completeButton.OnClick.Invoke()
                }
            }
            default {
                # Unhandled key
            }
        }
    }
}

#endregion
#<!-- END_PAGE: ASC.002 -->

class ThemePickerScreen : Screen {
    hidden [ScrollablePanel] $_themePanel
    hidden [Panel] $_mainPanel
    hidden [array] $_themes
    hidden [int] $_selectedIndex = 0
    hidden $_themeManager  # Remove type annotation since ThemeManager is defined later
    hidden [string] $_originalTheme  # Store original theme to restore on cancel
    
    ThemePickerScreen([object]$serviceContainer) : base("ThemePickerScreen", $serviceContainer) {}
    
    [void] Initialize() {
        # Get theme manager
        $this._themeManager = $this.ServiceContainer?.GetService("ThemeManager")
        if (-not $this._themeManager) {
            Write-Verbose "ThemePickerScreen: ThemeManager not found"
            return
        }
        
        # Get available themes
        $this._themes = $this._themeManager.GetAvailableThemes()
        Write-Verbose "ThemePickerScreen: Found $($this._themes.Count) themes: $($this._themes -join ', ')"
        
        # Store original theme
        $this._originalTheme = $this._themeManager.ThemeName
        
        # Main panel
        $this._mainPanel = [Panel]::new("Theme Selector")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = "Select Theme"
        $this.AddChild($this._mainPanel)
        
        # Instructions
        $instructionLabel = [LabelComponent]::new("Instructions")
        $instructionLabel.Text = "Use  to navigate, Enter to select theme, Esc to cancel"
        $instructionLabel.X = 2
        $instructionLabel.Y = 2
        $instructionLabel.Width = [Math]::Min(60, $this.Width - 4)
        $instructionLabel.Height = 1
        $instructionLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
        $this._mainPanel.AddChild($instructionLabel)
        
        # Theme scrollable panel
        $panelWidth = [Math]::Min(60, $this.Width - 10)
        $panelHeight = [Math]::Min(20, $this.Height - 8)
        $panelX = [Math]::Floor(($this.Width - $panelWidth) / 2)
        
        $this._themePanel = [ScrollablePanel]::new("ThemeList")
        $this._themePanel.X = $panelX
        $this._themePanel.Y = 4
        $this._themePanel.Width = $panelWidth
        $this._themePanel.Height = $panelHeight
        $this._themePanel.Title = "Available Themes"
        $this._themePanel.ShowScrollbar = $true
        $this._mainPanel.AddChild($this._themePanel)
        
        # Find current theme index
        $currentTheme = $this._themeManager.ThemeName
        $selectedIdx = 0
        for ($i = 0; $i -lt $this._themes.Count; $i++) {
            if ($this._themes[$i] -eq $currentTheme) {
                $selectedIdx = $i
                break
            }
        }
        $this._selectedIndex = $selectedIdx
        
        # Update display
        $this._UpdateThemeList()
    }
    
    hidden [void] _UpdateThemeList() {
        # Clear the panel
        $this._themePanel.Children.Clear()
        
        # Add theme items
        for ($i = 0; $i -lt $this._themes.Count; $i++) {
            $themeName = $this._themes[$i]
            $isSelected = ($i -eq $this._selectedIndex)
            
            # Create panel for each theme item
            $itemPanel = [Panel]::new("ThemeItem_$i")
            $itemPanel.X = 0
            $itemPanel.Y = $i
            $itemPanel.Width = $this._themePanel.ContentWidth
            $itemPanel.Height = 1
            $itemPanel.HasBorder = $false
            
            # Set background based on selection
            $itemPanel.BackgroundColor = if ($isSelected) { 
                Get-ThemeColor -ColorName "list.item.selected.background" -DefaultColor "#0000FF" 
            } else { 
                Get-ThemeColor -ColorName "Background" -DefaultColor "#000000" 
            }
            
            # Create label for theme name
            $themeLabel = [LabelComponent]::new("ThemeLabel_$i")
            $themeLabel.X = 2
            $themeLabel.Y = 0
            $themeLabel.Width = $itemPanel.Width - 4
            $themeLabel.Height = 1
            
            # Format display text
            $indicator = if ($isSelected) { " " } else { "  " }
            $currentMarker = if ($themeName -eq $this._originalTheme) { " (current)" } else { "" }
            $themeLabel.Text = "$indicator$themeName$currentMarker"
            
            # Set text color based on selection
            $themeLabel.ForegroundColor = if ($isSelected) { 
                Get-ThemeColor -ColorName "list.item.selected" -DefaultColor "#FFFFFF" 
            } else { 
                Get-ThemeColor -ColorName "list.item.normal" -DefaultColor "#C0C0C0" 
            }
            
            $itemPanel.AddChild($themeLabel)
            $this._themePanel.AddChild($itemPanel)
        }
        
        # Ensure selected item is visible
        if ($this._selectedIndex -lt $this._themePanel.ScrollOffsetY) {
            $this._themePanel.ScrollOffsetY = $this._selectedIndex
        } elseif ($this._selectedIndex -ge ($this._themePanel.ScrollOffsetY + $this._themePanel.ContentHeight)) {
            $this._themePanel.ScrollOffsetY = $this._selectedIndex - $this._themePanel.ContentHeight + 1
        }
        
        $this._themePanel.RequestRedraw()
    }
    
    [void] OnEnter() {
        $this.RequestRedraw()
    }
    
    [void] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this._selectedIndex -gt 0) {
                    $this._selectedIndex--
                    if ($this._selectedIndex -lt $this._themePanel.ScrollOffsetY) {
                        $this._themePanel.ScrollUp()
                    }
                    $this._UpdateThemeList()
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this._selectedIndex -lt $this._themes.Count - 1) {
                    $this._selectedIndex++
                    $visibleEnd = $this._themePanel.ScrollOffsetY + $this._themePanel.ContentHeight - 1
                    if ($this._selectedIndex -gt $visibleEnd) {
                        $this._themePanel.ScrollDown()
                    }
                    $this._UpdateThemeList()
                }
            }
            ([ConsoleKey]::Enter) {
                # Apply selected theme
                if ($this._selectedIndex -ge 0 -and $this._selectedIndex -lt $this._themes.Count) {
                    $selectedTheme = $this._themes[$this._selectedIndex]
                    $this._themeManager.LoadTheme($selectedTheme)
                    Write-Verbose "Applied theme: $selectedTheme"
                    
                    # Publish theme change event
                    $eventManager = $this.ServiceContainer?.GetService("EventManager")
                    if ($eventManager) {
                        $eventManager.Publish("Theme.Changed", @{ Theme = $selectedTheme })
                    }
                    
                    # Go back
                    $navService = $this.ServiceContainer?.GetService("NavigationService")
                    if ($navService -and $navService.CanGoBack()) {
                        $navService.GoBack()
                    }
                }
            }
            ([ConsoleKey]::Escape) {
                # Restore original theme and cancel
                $this._themeManager.LoadTheme($this._originalTheme)
                
                $navService = $this.ServiceContainer?.GetService("NavigationService")
                if ($navService -and $navService.CanGoBack()) {
                    $navService.GoBack()
                }
            }
            ([ConsoleKey]::Home) {
                $this._selectedIndex = 0
                $this._themePanel.ScrollToTop()
                $this._UpdateThemeList()
            }
            ([ConsoleKey]::End) {
                $this._selectedIndex = $this._themes.Count - 1
                $this._themePanel.ScrollToBottom()
                $this._UpdateThemeList()
            }
            default {
                # Unhandled key
            }
        }
    }
}

#<!-- PAGE: ASC.003 - Screen Utilities -->
#region Screen Utilities

# No specific screen utility functions currently implemented
# This section reserved for future screen helper functions

#endregion
#<!-- END_PAGE: ASC.003 -->



####\AllServices.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

#<!-- PAGE: ASE.001 - ActionService Class -->
#region Service Classes

# ===== CLASS: ActionService =====
# Module: action-service (from axiom)
# Dependencies: EventManager (optional)
# Purpose: Central command registry and execution service
class ActionService {
    [hashtable]$ActionRegistry = @{}
    [hashtable]$EventSubscriptions = @{}
    [object]$EventManager = $null
    
    ActionService() {
        Write-Verbose "ActionService: Initialized with empty registry"
    }
    
    ActionService([object]$eventManager) {
        $this.EventManager = $eventManager
        Write-Verbose "ActionService: Initialized with EventManager integration"
    }
    
    [void] RegisterAction([string]$actionName, [scriptblock]$action, [hashtable]$metadata = @{}) {
        try {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw "Action name cannot be null or empty"
            }
            if (-not $action) {
                throw "Action scriptblock cannot be null"
            }
            
            $actionData = @{
                Name = $actionName
                Action = $action
                Category = if ($metadata.ContainsKey('Category')) { $metadata.Category } else { "General" }
                Description = if ($metadata.ContainsKey('Description')) { $metadata.Description } else { "" }
                Hotkey = if ($metadata.ContainsKey('Hotkey')) { $metadata.Hotkey } else { "" }
                RegisteredAt = [datetime]::Now
                ExecutionCount = 0
                LastExecuted = $null
                Metadata = $metadata
            }
            
            $this.ActionRegistry[$actionName] = $actionData
            
            # Publish event if EventManager available
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Registered", @{
                    ActionName = $actionName
                    Category = $actionData.Category
                })
            }
            
            Write-Verbose "ActionService: Registered action '$actionName' in category '$($actionData.Category)'"
        }
        catch {
            Write-Error "Failed to register action '$actionName': $_"
            throw
        }
    }
    
    [void] UnregisterAction([string]$actionName) {
        if ($this.ActionRegistry.ContainsKey($actionName)) {
            $this.ActionRegistry.Remove($actionName)
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Unregistered", @{
                    ActionName = $actionName
                })
            }
            
            Write-Verbose "ActionService: Unregistered action '$actionName'"
        }
    }
    
    [object] ExecuteAction([string]$actionName, [hashtable]$parameters = @{}) {
        try {
            if (-not $this.ActionRegistry.ContainsKey($actionName)) {
                throw "Action '$actionName' not found in registry"
            }
            
            $actionData = $this.ActionRegistry[$actionName]
            
            # Update execution metadata
            $actionData.ExecutionCount++
            $actionData.LastExecuted = [datetime]::Now
            
            Write-Verbose "ActionService: Executing action '$actionName' with $($parameters.Count) parameters"
            
            # Execute the action
            $result = & $actionData.Action @parameters
            
            # Publish execution event
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Executed", @{
                    ActionName = $actionName
                    Parameters = $parameters
                    Success = $true
                })
            }
            
            return $result
        }
        catch {
            Write-Error "Failed to execute action '$actionName': $_"
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Executed", @{
                    ActionName = $actionName
                    Parameters = $parameters
                    Success = $false
                    Error = $_.ToString()
                })
            }
            
            throw
        }
    }
    
    [hashtable] GetAction([string]$actionName) {
        return $this.ActionRegistry[$actionName]
    }
    
    [hashtable] GetAllActions() {
        return $this.ActionRegistry
    }
    
    [hashtable[]] GetActionsByCategory([string]$category) {
        return @($this.ActionRegistry.Values | Where-Object { $_.Category -eq $category })
    }
    
    [void] RegisterDefaultActions() {
        # Register built-in actions
        $this.RegisterAction("app.exit", {
            Write-Verbose "Executing app.exit action"
            $global:TuiState.Running = $false
        }, @{
            Category = "Application"
            Description = "Exit the application"
            Hotkey = "Ctrl+Q"
        })
        
        $this.RegisterAction("app.help", {
            Write-Verbose "Executing app.help action"
            # Would show help screen
        }, @{
            Category = "Application"
            Description = "Show help"
            Hotkey = "F1"
        })
        
        $this.RegisterAction("app.commandPalette", {
            Write-Verbose "Executing app.commandPalette action"
            if ($global:TuiState.CommandPalette) {
                $global:TuiState.CommandPalette.Show()
                $global:TuiState.IsDirty = $true
            }
        }, @{
            Category = "Application"
            Description = "Show command palette"
            Hotkey = "Ctrl+P"
        })
        
        # Theme picker action
        $this.RegisterAction("ui.theme.picker", {
            $navService = $global:TuiState.Services.NavigationService
            $container = $global:TuiState.ServiceContainer
            $themeScreen = [ThemePickerScreen]::new($container)
            $themeScreen.Initialize()
            $navService.NavigateTo($themeScreen)
        }, @{
            Category = "UI"
            Description = "Change Theme"
        })
        
        # Task management actions
        $this.RegisterAction("task.new", {
            $navService = $global:TuiState.Services.NavigationService
            $currentScreen = $navService?.CurrentScreen
            if ($currentScreen -is [TaskListScreen]) {
                $currentScreen._newButton.OnClick.Invoke()
            }
        }, @{
            Category = "Tasks"
            Description = "New Task"
        })
        
        $this.RegisterAction("task.list", {
            $navService = $global:TuiState.Services.NavigationService
            $container = $global:TuiState.ServiceContainer
            $taskScreen = [TaskListScreen]::new($container)
            $taskScreen.Initialize()
            $navService.NavigateTo($taskScreen)
        }, @{
            Category = "Tasks"
            Description = "View All Tasks"
        })
        
        # Add navigation.taskList action for consistency
        $this.RegisterAction("navigation.taskList", {
            $navService = $global:TuiState.Services.NavigationService
            $container = $global:TuiState.ServiceContainer
            $taskScreen = [TaskListScreen]::new($container)
            $taskScreen.Initialize()
            $navService.NavigateTo($taskScreen)
        }, @{
            Category = "Navigation"
            Description = "Go to Task List"
        })
        
        Write-Verbose "ActionService: Registered default actions"
    }
}

#endregion
#<!-- END_PAGE: ASE.001 -->

#<!-- PAGE: ASE.002 - KeybindingService Class -->
#region KeybindingService Class

# ===== CLASS: KeybindingService =====
# Module: keybinding-service (from axiom)
# Dependencies: ActionService (optional)
# Purpose: Global keyboard shortcut management
class KeybindingService {
    [hashtable]$KeyMap = @{}
    [hashtable]$GlobalHandlers = @{}
    [System.Collections.Generic.Stack[hashtable]]$ContextStack
    [ActionService]$ActionService
    [bool]$EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.Stack[hashtable]]::new()
        $this._InitializeDefaultBindings()
    }
    
    KeybindingService([ActionService]$actionService) {
        $this.ActionService = $actionService
        $this.ContextStack = [System.Collections.Generic.Stack[hashtable]]::new()
        $this._InitializeDefaultBindings()
    }
    
    hidden [void] _InitializeDefaultBindings() {
        # Default global bindings
        $this.SetBinding("Ctrl+Q", "app.exit", "Global")
        $this.SetBinding("F1", "app.help", "Global")
        $this.SetBinding("Ctrl+P", "app.commandPalette", "Global")
        
        # Navigation bindings
        $this.SetBinding("Tab", "navigation.nextComponent", "Global")
        $this.SetBinding("Shift+Tab", "navigation.previousComponent", "Global")
        
        # Arrow keys
        $this.SetBinding("UpArrow", "navigation.up", "Global")
        $this.SetBinding("DownArrow", "navigation.down", "Global")
        $this.SetBinding("LeftArrow", "navigation.left", "Global")
        $this.SetBinding("RightArrow", "navigation.right", "Global")
        
        Write-Verbose "KeybindingService: Initialized default keybindings"
    }
    
    [void] SetBinding([string]$keyPattern, [string]$actionName, [string]$context = "Global") {
        if (-not $this.KeyMap.ContainsKey($context)) {
            $this.KeyMap[$context] = @{}
        }
        
        $this.KeyMap[$context][$keyPattern] = $actionName
        Write-Verbose "KeybindingService: Bound '$keyPattern' to '$actionName' in context '$context'"
    }
    
    [void] RemoveBinding([string]$keyPattern, [string]$context = "Global") {
        if ($this.KeyMap.ContainsKey($context)) {
            $this.KeyMap[$context].Remove($keyPattern)
            Write-Verbose "KeybindingService: Removed binding for '$keyPattern' in context '$context'"
        }
    }
    
    [bool] IsAction([System.ConsoleKeyInfo]$keyInfo, [string]$actionName) {
        $keyPattern = $this._GetKeyPattern($keyInfo)
        
        # Check current context stack
        foreach ($context in $this.ContextStack) {
            if ($context.ContainsKey($keyPattern) -and $context[$keyPattern] -eq $actionName) {
                return $true
            }
        }
        
        # Check global context
        if ($this.KeyMap.ContainsKey("Global") -and 
            $this.KeyMap["Global"].ContainsKey($keyPattern) -and
            $this.KeyMap["Global"][$keyPattern] -eq $actionName) {
            return $true
        }
        
        return $false
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        $keyPattern = $this._GetKeyPattern($keyInfo)
        
        # Check current context stack (most recent first)
        foreach ($context in $this.ContextStack) {
            if ($context.ContainsKey($keyPattern)) {
                return $context[$keyPattern]
            }
        }
        
        # Check global context
        if ($this.KeyMap.ContainsKey("Global") -and $this.KeyMap["Global"].ContainsKey($keyPattern)) {
            return $this.KeyMap["Global"][$keyPattern]
        }
        
        return $null
    }
    
    [string] GetBindingDescription([System.ConsoleKeyInfo]$keyInfo) {
        $action = $this.GetAction($keyInfo)
        if ($action -and $this.ActionService) {
            $actionData = $this.ActionService.GetAction($action)
            if ($actionData) {
                return $actionData.Description
            }
        }
        return $null
    }
    
    hidden [string] _GetKeyPattern([System.ConsoleKeyInfo]$keyInfo) {
        $parts = @()
        
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) {
            $parts += "Ctrl"
        }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) {
            $parts += "Alt"
        }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) {
            $parts += "Shift"
        }
        
        $parts += $keyInfo.Key.ToString()
        
        return $parts -join "+"
    }
    
    [void] PushContext([hashtable]$contextBindings) {
        $this.ContextStack.Push($contextBindings)
        Write-Verbose "KeybindingService: Pushed new context with $($contextBindings.Count) bindings"
    }
    
    [void] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $removed = $this.ContextStack.Pop()
            Write-Verbose "KeybindingService: Popped context with $($removed.Count) bindings"
        }
    }
    
    [void] RegisterGlobalHandler([string]$handlerId, [scriptblock]$handler) {
        $this.GlobalHandlers[$handlerId] = $handler
        Write-Verbose "KeybindingService: Registered global handler '$handlerId'"
    }
    
    [void] UnregisterGlobalHandler([string]$handlerId) {
        $this.GlobalHandlers.Remove($handlerId)
        Write-Verbose "KeybindingService: Unregistered global handler '$handlerId'"
    }
    
    [void] SetDefaultBindings() {
        # Application control
        $this.SetBinding("Ctrl+Q", "app.exit", "Global")
        $this.SetBinding("Escape", "app.cancel", "Global")
        $this.SetBinding("F1", "app.help", "Global")
        $this.SetBinding("Ctrl+P", "app.commandPalette", "Global")
        
        # Navigation
        $this.SetBinding("Tab", "nav.nextField", "Global")
        $this.SetBinding("Shift+Tab", "nav.previousField", "Global")
        $this.SetBinding("Enter", "nav.select", "Global")
        $this.SetBinding("Space", "nav.toggle", "Global")
        
        # Movement
        $this.SetBinding("UpArrow", "nav.up", "Global")
        $this.SetBinding("DownArrow", "nav.down", "Global")
        $this.SetBinding("LeftArrow", "nav.left", "Global")
        $this.SetBinding("RightArrow", "nav.right", "Global")
        $this.SetBinding("PageUp", "nav.pageUp", "Global")
        $this.SetBinding("PageDown", "nav.pageDown", "Global")
        $this.SetBinding("Home", "nav.home", "Global")
        $this.SetBinding("End", "nav.end", "Global")
        
        # Screen navigation
        $this.SetBinding("Ctrl+N", "screen.new", "Global")
        $this.SetBinding("Ctrl+D", "screen.dashboard", "Global")
        $this.SetBinding("Ctrl+T", "screen.tasks", "Global")
        $this.SetBinding("Ctrl+B", "nav.back", "Global")
    }
    
    [void] Cleanup() {
        $this.KeyMap.Clear()
        $this.GlobalHandlers.Clear()
        $this.ContextStack.Clear()
    }
}

#endregion
#<!-- END_PAGE: ASE.002 -->

#<!-- PAGE: ASE.003 - DataManager Class -->
#region DataManager Class

# ===== CLASS: DataManager =====
# Module: data-manager (from axiom)
# Dependencies: EventManager (optional), PmcTask, PmcProject
# Purpose: High-performance data management with transactions, backups, and robust serialization
class DataManager : System.IDisposable {
    # Private fields for high-performance indexes
    hidden [System.Collections.Generic.Dictionary[string, PmcTask]]$_taskIndex
    hidden [System.Collections.Generic.Dictionary[string, PmcProject]]$_projectIndex
    hidden [string]$_dataFilePath
    hidden [string]$_backupPath
    hidden [datetime]$_lastSaveTime
    hidden [bool]$_dataModified = $false
    hidden [int]$_updateTransactionCount = 0
    
    # Public properties
    [hashtable]$Metadata = @{}
    [bool]$AutoSave = $true
    [int]$BackupCount = 5
    [EventManager]$EventManager = $null
    
    DataManager([string]$dataPath) {
        $this._dataFilePath = $dataPath
        $this._Initialize()
    }
    
    DataManager([string]$dataPath, [EventManager]$eventManager) {
        $this._dataFilePath = $dataPath
        $this.EventManager = $eventManager
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        # Initialize indexes
        $this._taskIndex = [System.Collections.Generic.Dictionary[string, PmcTask]]::new()
        $this._projectIndex = [System.Collections.Generic.Dictionary[string, PmcProject]]::new()
        
        # Set up directories
        $baseDir = Split-Path -Path $this._dataFilePath -Parent
        $this._backupPath = Join-Path $baseDir "backups"
        
        # Ensure directories exist
        if (-not (Test-Path $baseDir)) {
            New-Item -ItemType Directory -Path $baseDir -Force | Out-Null
        }
        if (-not (Test-Path $this._backupPath)) {
            New-Item -ItemType Directory -Path $this._backupPath -Force | Out-Null
        }
        
        Write-Verbose "DataManager: Initialized with path '$($this._dataFilePath)'"
    }
    
    [void] LoadData() {
        try {
            if (-not (Test-Path $this._dataFilePath)) {
                Write-Verbose "DataManager: No existing data file found at '$($this._dataFilePath)'"
                return
            }
            
            $jsonContent = Get-Content -Path $this._dataFilePath -Raw -Encoding UTF8
            if ([string]::IsNullOrWhiteSpace($jsonContent)) {
                Write-Verbose "DataManager: Data file is empty"
                return
            }
            
            $data = $jsonContent | ConvertFrom-Json -AsHashtable
            
            # Clear existing data
            $this._taskIndex.Clear()
            $this._projectIndex.Clear()
            
            # Load tasks using FromLegacyFormat
            if ($data.ContainsKey('Tasks')) {
                foreach ($taskData in $data.Tasks) {
                    try {
                        $task = [PmcTask]::FromLegacyFormat($taskData)
                        $this._taskIndex[$task.Id] = $task
                    }
                    catch {
                        Write-Warning "DataManager: Failed to load task: $($_.Exception.Message)"
                    }
                }
            }
            
            # Load projects using FromLegacyFormat
            if ($data.ContainsKey('Projects')) {
                foreach ($projectData in $data.Projects) {
                    try {
                        $project = [PmcProject]::FromLegacyFormat($projectData)
                        $this._projectIndex[$project.Key] = $project
                    }
                    catch {
                        Write-Warning "DataManager: Failed to load project: $($_.Exception.Message)"
                    }
                }
            }
            
            # Load metadata
            if ($data.ContainsKey('Metadata')) {
                $this.Metadata = $data.Metadata.Clone()
            }
            
            $this._lastSaveTime = [datetime]::Now
            $this._dataModified = $false
            
            Write-Verbose "DataManager: Loaded $($this._taskIndex.Count) tasks and $($this._projectIndex.Count) projects"
            
            # Publish event
            if ($this.EventManager) {
                $this.EventManager.Publish("Data.Loaded", @{
                    TaskCount = $this._taskIndex.Count
                    ProjectCount = $this._projectIndex.Count
                    Source = $this._dataFilePath
                })
            }
        }
        catch {
            Write-Error "DataManager: Failed to load data from '$($this._dataFilePath)': $($_.Exception.Message)"
            throw
        }
    }
    
    [void] SaveData() {
        if ($this._updateTransactionCount -gt 0) {
            Write-Verbose "DataManager: SaveData deferred - inside update transaction (level $($this._updateTransactionCount))"
            return
        }
        
        try {
            $this.CreateBackup()
            
            $saveData = @{
                Tasks = @()
                Projects = @()
                Metadata = $this.Metadata.Clone()
                SavedAt = [datetime]::Now
                Version = "4.0"
            }
            
            # Convert tasks to legacy format for serialization
            foreach ($task in $this._taskIndex.Values) {
                $saveData.Tasks += $task.ToLegacyFormat()
            }
            
            # Convert projects to legacy format for serialization
            foreach ($project in $this._projectIndex.Values) {
                $saveData.Projects += $project.ToLegacyFormat()
            }
            
            $saveData | ConvertTo-Json -Depth 10 | Set-Content -Path $this._dataFilePath -Encoding UTF8 -Force
            $this._lastSaveTime = [datetime]::Now
            $this._dataModified = $false
            
            Write-Verbose "DataManager: Data saved to '$($this._dataFilePath)'"
            
            # Publish event
            if ($this.EventManager) {
                $this.EventManager.Publish("Data.Saved", @{
                    TaskCount = $saveData.Tasks.Count
                    ProjectCount = $saveData.Projects.Count
                    Destination = $this._dataFilePath
                })
            }
        }
        catch {
            Write-Error "DataManager: Failed to save data: $($_.Exception.Message)"
            throw
        }
    }
    
    hidden [void] CreateBackup() {
        try {
            if (Test-Path $this._dataFilePath) {
                $timestamp = (Get-Date).ToString("yyyyMMdd-HHmmss")
                $backupFileName = "data-backup-$timestamp.json"
                $backupFilePath = Join-Path $this._backupPath $backupFileName
                
                Copy-Item -Path $this._dataFilePath -Destination $backupFilePath -Force
                
                # Manage backup rotation
                if ($this.BackupCount -gt 0) {
                    $backups = Get-ChildItem -Path $this._backupPath -Filter "data-backup-*.json" | 
                               Sort-Object LastWriteTime -Descending
                    
                    if ($backups.Count -gt $this.BackupCount) {
                        $backupsToDelete = $backups | Select-Object -Skip $this.BackupCount
                        foreach ($backup in $backupsToDelete) {
                            Remove-Item -Path $backup.FullName -Force
                            Write-Verbose "DataManager: Removed old backup '$($backup.Name)'"
                        }
                    }
                }
                
                Write-Verbose "DataManager: Created backup '$backupFileName'"
            }
        }
        catch {
            Write-Warning "DataManager: Failed to create backup: $($_.Exception.Message)"
        }
    }
    
    # Transactional update methods
    [void] BeginUpdate() {
        $this._updateTransactionCount++
        Write-Verbose "DataManager: Began update transaction. Depth: $($this._updateTransactionCount)"
    }
    
    [void] EndUpdate() {
        $this.EndUpdate($false)
    }
    
    [void] EndUpdate([bool]$forceSave) {
        if ($this._updateTransactionCount -gt 0) {
            $this._updateTransactionCount--
        }
        
        Write-Verbose "DataManager: Ended update transaction. Depth: $($this._updateTransactionCount)"
        
        if ($this._updateTransactionCount -eq 0 -and ($this._dataModified -or $forceSave)) {
            if ($this.AutoSave -or $forceSave) {
                $this.SaveData()
            }
        }
    }
    
    # Task management methods
    [PmcTask[]] GetTasks() {
        return @($this._taskIndex.Values)
    }
    
    [PmcTask] GetTask([string]$taskId) {
        if ($this._taskIndex.ContainsKey($taskId)) {
            return $this._taskIndex[$taskId]
        }
        return $null
    }
    
    [PmcTask[]] GetTasksByProject([string]$projectKey) {
        return @($this._taskIndex.Values | Where-Object { $_.ProjectKey -eq $projectKey })
    }
    
    [PmcTask] AddTask([PmcTask]$task) {
        if ($null -eq $task) {
            throw [System.ArgumentNullException]::new("task", "Task cannot be null")
        }
        
        if ([string]::IsNullOrEmpty($task.Id)) {
            $task.Id = [guid]::NewGuid().ToString()
        }
        
        if ($this._taskIndex.ContainsKey($task.Id)) {
            throw [System.InvalidOperationException]::new("Task with ID '$($task.Id)' already exists")
        }
        
        $this._taskIndex[$task.Id] = $task
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Tasks.Changed", @{ Action = "Created"; Task = $task })
        }
        
        Write-Verbose "DataManager: Added task '$($task.Title)' with ID '$($task.Id)'"
        return $task
    }
    
    [PmcTask] UpdateTask([PmcTask]$task) {
        if ($null -eq $task) {
            throw [System.ArgumentNullException]::new("task", "Task cannot be null")
        }
        
        if (-not $this._taskIndex.ContainsKey($task.Id)) {
            throw [System.InvalidOperationException]::new("Task with ID '$($task.Id)' not found")
        }
        
        $task.UpdatedAt = [datetime]::Now
        $this._taskIndex[$task.Id] = $task
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Tasks.Changed", @{ Action = "Updated"; Task = $task })
        }
        
        Write-Verbose "DataManager: Updated task '$($task.Title)' with ID '$($task.Id)'"
        return $task
    }
    
    [bool] DeleteTask([string]$taskId) {
        if (-not $this._taskIndex.ContainsKey($taskId)) {
            Write-Verbose "DataManager: Task '$taskId' not found for deletion"
            return $false
        }
        
        $task = $this._taskIndex[$taskId]
        $this._taskIndex.Remove($taskId) | Out-Null
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Tasks.Changed", @{ Action = "Deleted"; TaskId = $taskId })
        }
        
        Write-Verbose "DataManager: Deleted task with ID '$taskId'"
        return $true
    }
    
    # Project management methods
    [PmcProject[]] GetProjects() {
        return @($this._projectIndex.Values)
    }
    
    [PmcProject] GetProject([string]$projectKey) {
        if ($this._projectIndex.ContainsKey($projectKey)) {
            return $this._projectIndex[$projectKey]
        }
        return $null
    }
    
    [PmcProject] AddProject([PmcProject]$project) {
        if ($null -eq $project) {
            throw [System.ArgumentNullException]::new("project", "Project cannot be null")
        }
        
        if ([string]::IsNullOrEmpty($project.Key)) {
            throw [System.ArgumentException]::new("Project Key is required")
        }
        
        if ($this._projectIndex.ContainsKey($project.Key)) {
            throw [System.InvalidOperationException]::new("Project with Key '$($project.Key)' already exists")
        }
        
        $this._projectIndex[$project.Key] = $project
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Projects.Changed", @{ Action = "Created"; Project = $project })
        }
        
        Write-Verbose "DataManager: Added project '$($project.Name)' with Key '$($project.Key)'"
        return $project
    }
    
    [PmcProject] UpdateProject([PmcProject]$project) {
        if ($null -eq $project) {
            throw [System.ArgumentNullException]::new("project", "Project cannot be null")
        }
        
        if (-not $this._projectIndex.ContainsKey($project.Key)) {
            throw [System.InvalidOperationException]::new("Project with Key '$($project.Key)' not found")
        }
        
        $project.UpdatedAt = [datetime]::Now
        $this._projectIndex[$project.Key] = $project
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Projects.Changed", @{ Action = "Updated"; Project = $project })
        }
        
        Write-Verbose "DataManager: Updated project '$($project.Name)' with Key '$($project.Key)'"
        return $project
    }
    
    [bool] DeleteProject([string]$projectKey) {
        if (-not $this._projectIndex.ContainsKey($projectKey)) {
            Write-Verbose "DataManager: Project '$projectKey' not found for deletion"
            return $false
        }
        
        # Delete all tasks associated with this project
        $tasksToDelete = @($this._taskIndex.Values | Where-Object { $_.ProjectKey -eq $projectKey })
        foreach ($task in $tasksToDelete) {
            $this.DeleteTask($task.Id) | Out-Null
        }
        
        $project = $this._projectIndex[$projectKey]
        $this._projectIndex.Remove($projectKey) | Out-Null
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Projects.Changed", @{ 
                Action = "Deleted"
                ProjectKey = $projectKey
                DeletedTaskCount = $tasksToDelete.Count
            })
        }
        
        Write-Verbose "DataManager: Deleted project '$projectKey' and $($tasksToDelete.Count) associated tasks"
        return $true
    }
    
    # Utility methods
    [datetime] GetLastSaveTime() {
        return $this._lastSaveTime
    }
    
    [void] ForceSave() {
        $originalTransactionCount = $this._updateTransactionCount
        $this._updateTransactionCount = 0
        try {
            $this.SaveData()
        }
        finally {
            $this._updateTransactionCount = $originalTransactionCount
        }
    }
    
    # IDisposable implementation
    [void] Dispose() {
        Write-Verbose "DataManager: Disposing - checking for unsaved data"
        
        if ($this._dataModified) {
            $originalTransactionCount = $this._updateTransactionCount
            $this._updateTransactionCount = 0
            try {
                $this.SaveData()
                Write-Verbose "DataManager: Performed final save during dispose"
            }
            catch {
                Write-Warning "DataManager: Failed to save data during dispose: $($_.Exception.Message)"
            }
            finally {
                $this._updateTransactionCount = $originalTransactionCount
            }
        }
    }
    
    # Cleanup method (alias for Dispose)
    [void] Cleanup() {
        $this.Dispose()
    }
}

#endregion
#<!-- END_PAGE: ASE.003 -->

#<!-- PAGE: ASE.004 - NavigationService Class -->
#region NavigationService Class

# ===== CLASS: NavigationService =====
# Module: navigation-service (from axiom)
# Dependencies: EventManager (optional)
# Purpose: Screen navigation and history management
class NavigationService {
    [System.Collections.Generic.Stack[Screen]]$NavigationStack = [System.Collections.Generic.Stack[Screen]]::new() # Explicitly initialize
    [Screen]$CurrentScreen
    [EventManager]$EventManager
    [hashtable]$ScreenRegistry = @{}
    [int]$MaxStackSize = 10
    [hashtable]$Services # Added to store access to all services (for creating screens)

    # Add constructor that takes ServiceContainer (or hashtable of services)
    NavigationService([hashtable]$services) {
        $this.Services = $services
        $this.EventManager = $services.EventManager # Get EventManager if present
    }

    # IMPORTANT: Update NavigateTo method
    [void] NavigateTo([Screen]$screen) {
        if ($null -eq $screen) { throw [System.ArgumentNullException]::new("screen", "Cannot navigate to a null screen.") }
        
        try {
            # Exit current screen if one exists
            if ($this.CurrentScreen) {
                # Write-Log -Level Debug -Message "NavigationService: Exiting screen '$($this.CurrentScreen.Name)'"
                $this.CurrentScreen.OnExit()
                $this.NavigationStack.Push($this.CurrentScreen)
                
                # Limit stack size (optional, complex to trim from bottom of Stack)
                # If MaxStackSize is critical, consider switching NavigationStack to List<Screen> and managing explicitly.
            }
            
            # Enter new screen
            $this.CurrentScreen = $screen
            # Write-Log -Level Debug -Message "NavigationService: Entering screen '$($screen.Name)'"
            
            # Initialize if not already (screens passed via registry should be initialized via factory)
            if (-not $screen._isInitialized) {
                # Write-Log -Level Debug -Message "NavigationService: Initializing screen '$($screen.Name)'"
                $screen.Initialize()
                $screen._isInitialized = $true
            }
            
            # Resize screen to match current console dimensions
            $width = [Math]::Max(80, $global:TuiState.BufferWidth)
            $height = [Math]::Max(24, $global:TuiState.BufferHeight)
            $screen.Resize($width, $height)
            
            $screen.OnEnter() # Call lifecycle method
            
            # Publish navigation event
            if ($this.EventManager) {
                $this.EventManager.Publish("Navigation.ScreenChanged", @{
                    Screen = $screen
                    ScreenName = $screen.Name
                    StackDepth = $this.NavigationStack.Count
                })
            }
            
            # Update global TUI state (CRITICAL FIX)
            $global:TuiState.CurrentScreen = $screen
            $global:TuiState.IsDirty = $true # Force redraw
            $global:TuiState.FocusedComponent = $null # Clear focus, screen OnEnter should set new focus

        }
        catch {
            Write-Error "NavigationService: Failed to navigate to screen '$($screen.Name)': $_"
            throw
        }
    }

    [void] NavigateToByName([string]$screenName) {
        if (-not $this.ScreenRegistry.ContainsKey($screenName)) {
            throw [System.ArgumentException]::new("Screen '$screenName' not found in registry. Registered: $($this.ScreenRegistry.Keys -join ', ').", "screenName")
        }
        
        $this.NavigateTo($this.ScreenRegistry[$screenName])
    }
    
    [bool] CanGoBack() {
        return $this.NavigationStack.Count -gt 0
    }
    
    # IMPORTANT: Update GoBack method
    [void] GoBack() {
        if (-not $this.CanGoBack()) {
            # Write-Log -Level Warning -Message "NavigationService: Cannot go back - navigation stack is empty"
            return
        }
        
        try {
            # Exit current screen
            if ($this.CurrentScreen) {
                # Write-Log -Level Debug -Message "NavigationService: Exiting screen '$($this.CurrentScreen.Name)' (going back)"
                $this.CurrentScreen.OnExit()
                $this.CurrentScreen.Cleanup() # Clean up the screen being exited/popped
            }
            
            # Pop and resume previous screen
            $previousScreen = $this.NavigationStack.Pop()
            $this.CurrentScreen = $previousScreen
            
            # Write-Log -Level Debug -Message "NavigationService: Resuming screen '$($previousScreen.Name)'"
            
            # Resize screen to match current console dimensions
            $previousScreen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)

            $previousScreen.OnResume() # Call lifecycle method
            
            # Publish navigation event
            if ($this.EventManager) {
                $this.EventManager.Publish("Navigation.BackNavigation", @{
                    Screen = $previousScreen
                    ScreenName = $previousScreen.Name
                    StackDepth = $this.NavigationStack.Count
                })
            }
            
            # Update global TUI state (CRITICAL FIX)
            $global:TuiState.CurrentScreen = $previousScreen
            $global:TuiState.IsDirty = $true # Force redraw
            $global:TuiState.FocusedComponent = $null # Clear focus, screen OnResume should set new focus

        }
        catch {
            Write-Error "NavigationService: Failed to go back: $_"
            throw
        }
    }
    
    [void] Reset() {
        # Cleanup all screens in stack and current screen
        while ($this.NavigationStack.Count -gt 0) {
            $screen = $this.NavigationStack.Pop()
            try { $screen.Cleanup() } catch { # Write-Log -Level Warning -Message "NavigationService: Error cleaning up stacked screen '$($screen.Name)': $($_.Exception.Message)" }
            }
        }
        
        if ($this.CurrentScreen) {
            try { 
                $this.CurrentScreen.OnExit()
                $this.CurrentScreen.Cleanup() 
            } catch { # Write-Log -Level Warning -Message "NavigationService: Error cleaning up current screen '$($this.CurrentScreen.Name)': $($_.Exception.Message)" }
            }
            $this.CurrentScreen = $null
        }
        # Write-Log -Level Debug -Message "NavigationService: Reset complete, all screens cleaned up."
    }
}

#endregion
#<!-- END_PAGE: ASE.004 -->

#<!-- PAGE: ASE.005 - ThemeManager Class -->
#region ThemeManager Class

# ===== CLASS: ThemeManager =====
# Module: theme-manager (from axiom)
# Dependencies: None
# Purpose: Visual theming system with consistent hex color output
class ThemeManager {
    [hashtable]$CurrentTheme = @{}
    [string]$ThemeName = "Synthwave"
    [hashtable]$Themes = @{}
    
    ThemeManager() {
        $this.InitializeThemes()
        $this.LoadTheme($this.ThemeName)
    }
    
    [void] InitializeThemes() {
        # Synthwave Theme - Neon cyberpunk aesthetic
        $this.Themes["Synthwave"] = @{
            # Base colors
            "Background" = "#0a0e27"
            "Foreground" = "#f92aad"
            "Subtle" = "#72f1b8"
            "Primary" = "#ff6ac1"
            "Accent" = "#ffcc00"
            "Secondary" = "#5a189a"
            "Error" = "#ff006e"
            "Warning" = "#ffbe0b"
            "Success" = "#3bf4fb"
            "Info" = "#8338ec"
            
            # Component specific
            "component.background" = "#0a0e27"
            "component.border" = "#f92aad"
            "component.title" = "#ffcc00"
            
            # Input
            "input.background" = "#1a1e3a"
            "input.foreground" = "#f92aad"
            "input.placeholder" = "#72f1b8"
            
            # Button states
            "button.normal.fg" = "#0a0e27"
            "button.normal.bg" = "#f92aad"
            "button.focused.fg" = "#0a0e27"
            "button.focused.bg" = "#ff6ac1"
            "button.pressed.fg" = "#0a0e27"
            "button.pressed.bg" = "#ffcc00"
            "button.disabled.fg" = "#555555"
            "button.disabled.bg" = "#2a2e4a"
            
            # List/Table
            "list.header.fg" = "#ffcc00"
            "list.header.bg" = "#1a1e3a"
            "list.item.normal" = "#f92aad"
            "list.item.selected" = "#0a0e27"
            "list.item.selected.background" = "#ff6ac1"
            "list.scrollbar" = "#72f1b8"
        }
        
        # Aurora Theme - Northern lights inspired
        $this.Themes["Aurora"] = @{
            # Base colors
            "Background" = "#011627"
            "Foreground" = "#d6deeb"
            "Subtle" = "#7fdbca"
            "Primary" = "#82aaff"
            "Accent" = "#21c7a8"
            "Secondary" = "#c792ea"
            "Error" = "#ef5350"
            "Warning" = "#ffeb95"
            "Success" = "#22da6e"
            "Info" = "#82aaff"
            
            # Component specific
            "component.background" = "#011627"
            "component.border" = "#5f7e97"
            "component.title" = "#21c7a8"
            
            # Input
            "input.background" = "#0e293f"
            "input.foreground" = "#d6deeb"
            "input.placeholder" = "#637777"
            
            # Button states
            "button.normal.fg" = "#011627"
            "button.normal.bg" = "#82aaff"
            "button.focused.fg" = "#011627"
            "button.focused.bg" = "#21c7a8"
            "button.pressed.fg" = "#011627"
            "button.pressed.bg" = "#c792ea"
            "button.disabled.fg" = "#444444"
            "button.disabled.bg" = "#1d3b53"
            
            # List/Table
            "list.header.fg" = "#21c7a8"
            "list.header.bg" = "#0e293f"
            "list.item.normal" = "#d6deeb"
            "list.item.selected" = "#011627"
            "list.item.selected.background" = "#82aaff"
            "list.scrollbar" = "#5f7e97"
        }
        
        # Ocean Theme - Deep sea aesthetics
        $this.Themes["Ocean"] = @{
            # Base colors
            "Background" = "#0f111a"
            "Foreground" = "#8f93a2"
            "Subtle" = "#4b526d"
            "Primary" = "#00bcd4"
            "Accent" = "#00e676"
            "Secondary" = "#536dfe"
            "Error" = "#ff5252"
            "Warning" = "#ffb74d"
            "Success" = "#00e676"
            "Info" = "#448aff"
            
            # Component specific
            "component.background" = "#0f111a"
            "component.border" = "#1f2937"
            "component.title" = "#00bcd4"
            
            # Input
            "input.background" = "#1a1f2e"
            "input.foreground" = "#8f93a2"
            "input.placeholder" = "#4b526d"
            
            # Button states
            "button.normal.fg" = "#0f111a"
            "button.normal.bg" = "#00bcd4"
            "button.focused.fg" = "#0f111a"
            "button.focused.bg" = "#00e676"
            "button.pressed.fg" = "#0f111a"
            "button.pressed.bg" = "#536dfe"
            "button.disabled.fg" = "#333333"
            "button.disabled.bg" = "#1a1f2e"
            
            # List/Table
            "list.header.fg" = "#00e676"
            "list.header.bg" = "#1a1f2e"
            "list.item.normal" = "#8f93a2"
            "list.item.selected" = "#0f111a"
            "list.item.selected.background" = "#00bcd4"
            "list.scrollbar" = "#4b526d"
        }
        
        # Forest Theme - Nature inspired
        $this.Themes["Forest"] = @{
            # Base colors
            "Background" = "#0d1117"
            "Foreground" = "#c9d1d9"
            "Subtle" = "#8b949e"
            "Primary" = "#58a6ff"
            "Accent" = "#56d364"
            "Secondary" = "#d29922"
            "Error" = "#f85149"
            "Warning" = "#f0883e"
            "Success" = "#56d364"
            "Info" = "#58a6ff"
            
            # Component specific
            "component.background" = "#0d1117"
            "component.border" = "#30363d"
            "component.title" = "#56d364"
            
            # Input
            "input.background" = "#161b22"
            "input.foreground" = "#c9d1d9"
            "input.placeholder" = "#484f58"
            
            # Button states
            "button.normal.fg" = "#0d1117"
            "button.normal.bg" = "#58a6ff"
            "button.focused.fg" = "#0d1117"
            "button.focused.bg" = "#56d364"
            "button.pressed.fg" = "#0d1117"
            "button.pressed.bg" = "#d29922"
            "button.disabled.fg" = "#484f58"
            "button.disabled.bg" = "#21262d"
            
            # List/Table
            "list.header.fg" = "#56d364"
            "list.header.bg" = "#161b22"
            "list.item.normal" = "#c9d1d9"
            "list.item.selected" = "#0d1117"
            "list.item.selected.background" = "#58a6ff"
            "list.scrollbar" = "#8b949e"
        }
    }
    
    [void] LoadTheme([string]$themeName) {
        if ($this.Themes.ContainsKey($themeName)) {
            $this.CurrentTheme = $this.Themes[$themeName].Clone()
            $this.ThemeName = $themeName
        }
    }
    
    [void] LoadDefaultTheme() {
        $this.LoadTheme("Synthwave")
    }
    
    [string] GetColor([string]$colorName) {
        return $this.GetColor($colorName, "#FFFFFF")
    }
    
    [string] GetColor([string]$colorName, [string]$defaultColor) {
        if ($this.CurrentTheme.ContainsKey($colorName)) {
            return $this.CurrentTheme[$colorName]
        }
        return $defaultColor
    }
    
    [void] SetColor([string]$colorName, [string]$colorValue) {
        $this.CurrentTheme[$colorName] = $colorValue
    }
    
    [string[]] GetAvailableThemes() {
        return $this.Themes.Keys | Sort-Object
    }
    
    [void] CycleTheme() {
        $availableThemes = $this.GetAvailableThemes()
        $currentIndex = [array]::IndexOf($availableThemes, $this.ThemeName)
        $nextIndex = ($currentIndex + 1) % $availableThemes.Count
        $this.LoadTheme($availableThemes[$nextIndex])
    }
}

#endregion
#<!-- END_PAGE: ASE.005 -->

#<!-- PAGE: ASE.006 - Logger Class -->
#region Logger Class

# ===== CLASS: Logger =====
# Module: logger (from axiom)
# Dependencies: None
# Purpose: Application-wide logging with multiple outputs
class Logger {
    [string]$LogPath
    [System.Collections.Queue]$LogQueue
    [int]$MaxQueueSize = 1000
    [bool]$EnableFileLogging = $true
    [bool]$EnableConsoleLogging = $false
    [string]$MinimumLevel = "Info"
    [hashtable]$LevelPriority = @{
        'Trace' = 0
        'Debug' = 1
        'Info' = 2
        'Warning' = 3
        'Error' = 4
        'Fatal' = 5
    }
    
    Logger() {
        $this.LogPath = Join-Path $env:APPDATA "AxiomPhoenix\app.log"
        $this._Initialize()
    }
    
    Logger([string]$logPath) {
        $this.LogPath = $logPath
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $this.LogQueue = [System.Collections.Queue]::new()
        
        $logDir = Split-Path -Parent $this.LogPath
        if (-not (Test-Path $logDir)) {
            New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        }
        
        Write-Verbose "Logger: Initialized with log path: $($this.LogPath)"
    }
    
    [void] Log([string]$message, [string]$level = "Info") {
        # Check if we should log this level
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) {
            return
        }
        
        $logEntry = @{
            Timestamp = [DateTime]::Now
            Level = $level
            Message = $message
            ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        }
        
        # Add to queue
        $this.LogQueue.Enqueue($logEntry)
        
        # Flush if queue is getting large
        if ($this.LogQueue.Count -ge $this.MaxQueueSize) {
            $this.Flush()
        }
        
        # Console logging if enabled
        if ($this.EnableConsoleLogging) {
            $this._WriteToConsole($logEntry)
        }
    }
    
    [void] LogException([Exception]$exception, [string]$message = "") {
        $exceptionDetails = @{
            Message = if ($message) { $message } else { "Exception occurred" }
            ExceptionType = $exception.GetType().FullName
            ExceptionMessage = $exception.Message
            StackTrace = $exception.StackTrace
            InnerException = if ($exception.InnerException) { 
                $exception.InnerException.Message 
            } else { 
                $null 
            }
        }
        
        $detailsJson = $exceptionDetails | ConvertTo-Json -Compress -Depth 10 -ErrorAction SilentlyContinue
        if (-not $detailsJson) {
            # If serialization fails, create a simple string representation
            $detailsJson = "ExceptionType: $($exceptionDetails.ExceptionType), Message: $($exceptionDetails.ExceptionMessage)"
        }
        $this.Log($detailsJson, "Error")
    }
    
    [void] Flush() {
        if ($this.LogQueue.Count -eq 0 -or -not $this.EnableFileLogging) {
            return
        }
        
        try {
            $logContent = [System.Text.StringBuilder]::new()
            
            while ($this.LogQueue.Count -gt 0) {
                $entry = $this.LogQueue.Dequeue()
                $logLine = "$($entry.Timestamp.ToString('yyyy-MM-dd HH:mm:ss.fff')) [$($entry.Level.ToUpper().PadRight(7))] [Thread:$($entry.ThreadId)] $($entry.Message)"
                [void]$logContent.AppendLine($logLine)
            }
            
            if ($logContent.Length -gt 0) {
                Add-Content -Path $this.LogPath -Value $logContent.ToString() -NoNewline
            }
        }
        catch {
            Write-Warning "Logger: Failed to flush logs: $_"
        }
    }
    
    hidden [void] _WriteToConsole([hashtable]$logEntry) {
        $color = switch ($logEntry.Level) {
            'Trace' { [ConsoleColor]::DarkGray }
            'Debug' { [ConsoleColor]::Gray }
            'Info' { [ConsoleColor]::White }
            'Warning' { [ConsoleColor]::Yellow }
            'Error' { [ConsoleColor]::Red }
            'Fatal' { [ConsoleColor]::Magenta }
            default { [ConsoleColor]::White }
        }
        
        $timestamp = $logEntry.Timestamp.ToString('HH:mm:ss')
        $prefix = "[$timestamp] [$($logEntry.Level.ToUpper())]"
        
        Write-Host $prefix -ForegroundColor $color -NoNewline
        Write-Host " $($logEntry.Message)" -ForegroundColor White
    }
    
    [void] Cleanup() {
        $this.Flush()
        Write-Verbose "Logger: Cleanup complete"
    }
}

#endregion
#<!-- END_PAGE: ASE.006 -->

#<!-- PAGE: ASE.007 - EventManager Class -->
#region EventManager Class

# ===== CLASS: EventManager =====
# Module: event-system (from axiom)
# Dependencies: None
# Purpose: Pub/sub event system for decoupled communication
class EventManager {
    [hashtable]$EventHandlers = @{}
    [int]$NextHandlerId = 1
    [System.Collections.Generic.List[hashtable]]$EventHistory
    [int]$MaxHistorySize = 100
    [bool]$EnableHistory = $true
    
    EventManager() {
        $this.EventHistory = [System.Collections.Generic.List[hashtable]]::new()
        Write-Verbose "EventManager: Initialized"
    }
    
    [string] Subscribe([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) {
            throw [ArgumentException]::new("Event name cannot be null or empty")
        }
        if (-not $handler) {
            throw [ArgumentNullException]::new("handler")
        }
        
        if (-not $this.EventHandlers.ContainsKey($eventName)) {
            $this.EventHandlers[$eventName] = @{}
        }
        
        $handlerId = "handler_$($this.NextHandlerId)"
        $this.NextHandlerId++
        
        $this.EventHandlers[$eventName][$handlerId] = @{
            Handler = $handler
            SubscribedAt = [DateTime]::Now
            ExecutionCount = 0
        }
        
        Write-Verbose "EventManager: Subscribed handler '$handlerId' to event '$eventName'"
        return $handlerId
    }
    
    [void] Unsubscribe([string]$eventName, [string]$handlerId) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            if ($this.EventHandlers[$eventName].ContainsKey($handlerId)) {
                $this.EventHandlers[$eventName].Remove($handlerId)
                Write-Verbose "EventManager: Unsubscribed handler '$handlerId' from event '$eventName'"
                
                # Clean up empty event entries
                if ($this.EventHandlers[$eventName].Count -eq 0) {
                    $this.EventHandlers.Remove($eventName)
                }
            }
        }
    }
    
    [void] UnsubscribeAll([string]$eventName) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlerCount = $this.EventHandlers[$eventName].Count
            $this.EventHandlers.Remove($eventName)
            Write-Verbose "EventManager: Unsubscribed all $handlerCount handlers from event '$eventName'"
        }
    }
    
    [void] Publish([string]$eventName, [hashtable]$eventData = @{}) {
        Write-Verbose "EventManager: Publishing event '$eventName'"
        
        # Add to history if enabled
        if ($this.EnableHistory) {
            $historyEntry = @{
                EventName = $eventName
                EventData = $eventData.Clone()
                Timestamp = [DateTime]::Now
                HandlerCount = 0
            }
            
            $this.EventHistory.Add($historyEntry)
            
            # Trim history if needed
            if ($this.EventHistory.Count -gt $this.MaxHistorySize) {
                $this.EventHistory.RemoveAt(0)
            }
        }
        
        # Execute handlers
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlers = @($this.EventHandlers[$eventName].GetEnumerator())
            $handlerCount = $handlers.Count
            
            if ($this.EnableHistory) {
                $this.EventHistory[-1].HandlerCount = $handlerCount
            }
            
            foreach ($entry in $handlers) {
                try {
                    $handlerData = $entry.Value
                    $handlerData.ExecutionCount++
                    
                    Write-Verbose "EventManager: Executing handler '$($entry.Key)' for event '$eventName'"
                    & $handlerData.Handler $eventData
                }
                catch {
                    Write-Error "EventManager: Error in handler '$($entry.Key)' for event '$eventName': $_"
                }
            }
            
            Write-Verbose "EventManager: Published event '$eventName' to $handlerCount handlers"
        }
        else {
            Write-Verbose "EventManager: No handlers registered for event '$eventName'"
        }
    }
    
    [hashtable[]] GetEventHistory([string]$eventName = $null) {
        if ($eventName) {
            return $this.EventHistory | Where-Object { $_.EventName -eq $eventName }
        }
        return $this.EventHistory | ForEach-Object { $_ }
    }
    
    [void] ClearHistory() {
        $this.EventHistory.Clear()
        Write-Verbose "EventManager: Cleared event history"
    }
    
    [hashtable] GetEventInfo() {
        $info = @{
            RegisteredEvents = @{}
            TotalHandlers = 0
        }
        
        foreach ($eventName in $this.EventHandlers.Keys) {
            $handlers = $this.EventHandlers[$eventName]
            $info.RegisteredEvents[$eventName] = @{
                HandlerCount = $handlers.Count
                Handlers = $handlers.Keys | ForEach-Object { $_ }
            }
            $info.TotalHandlers += $handlers.Count
        }
        
        return $info
    }
}

#endregion
#<!-- END_PAGE: ASE.007 -->

#<!-- PAGE: ASE.008 - AsyncJobService Class -->
#region AsyncJobService Class

# ===== CLASS: AsyncJobService =====
# Module: async-jobs (from axiom)
# Dependencies: None
# Purpose: Framework utilities and async operations
class AsyncJobService {
    [hashtable]$AsyncJobs = @{}
    [int]$NextJobId = 1
    [bool]$IsRunning = $false
    
    AsyncJobService() {
        Write-Verbose "AsyncJobService: Initialized"
    }
    
    [hashtable] StartAsync([scriptblock]$work, [string]$name = "") {
        try {
            $jobId = $this.NextJobId++
            $jobName = if ($name) { $name } else { "AsyncJob_$jobId" }
            
            # Use ThreadJob for lightweight async operations
            $job = Start-ThreadJob -ScriptBlock $work -Name $jobName
            
            $jobInfo = @{
                Id = $jobId
                Name = $jobName
                Job = $job
                StartedAt = [DateTime]::Now
                Status = "Running"
            }
            
            $this.AsyncJobs[$jobId] = $jobInfo
            
            Write-Verbose "AsyncJobService: Started async job '$jobName' with ID $jobId"
            return $jobInfo
        }
        catch {
            Write-Error "Failed to start async job: $_"
            throw
        }
    }
    
    [object] GetAsyncResults([int]$jobId, [bool]$wait = $false) {
        if (-not $this.AsyncJobs.ContainsKey($jobId)) {
            throw "Async job with ID $jobId not found"
        }
        
        $jobInfo = $this.AsyncJobs[$jobId]
        $job = $jobInfo.Job
        
        if ($wait) {
            Write-Verbose "AsyncJobService: Waiting for job $jobId to complete"
            Wait-Job -Job $job | Out-Null
        }
        
        if ($job.State -eq "Completed") {
            $result = Receive-Job -Job $job -Keep
            $jobInfo.Status = "Completed"
            return $result
        }
        elseif ($job.State -eq "Failed") {
            $jobInfo.Status = "Failed"
            $error = Receive-Job -Job $job -Keep
            throw "Async job $jobId failed: $error"
        }
        else {
            return $null
        }
    }
    
    [void] StopAllAsyncJobs() {
        Write-Verbose "AsyncJobService: Stopping all async jobs"
        
        foreach ($jobInfo in $this.AsyncJobs.Values) {
            try {
                if ($jobInfo.Job.State -eq "Running") {
                    Stop-Job -Job $jobInfo.Job
                    Remove-Job -Job $jobInfo.Job -Force
                }
            }
            catch {
                Write-Warning "Failed to stop job $($jobInfo.Id): $_"
            }
        }
        
        $this.AsyncJobs.Clear()
    }
    
    [hashtable] GetState() {
        return @{
            IsRunning = $this.IsRunning
            AsyncJobCount = $this.AsyncJobs.Count
            ActiveJobs = $this.AsyncJobs.Values | Where-Object { $_.Status -eq "Running" } | Measure-Object | Select-Object -ExpandProperty Count
        }
    }
    
    [bool] IsRunning() {
        return $this.IsRunning
    }
    
    [void] Start() {
        $this.IsRunning = $true
        Write-Verbose "AsyncJobService: Started"
    }
    
    [void] Stop() {
        $this.StopAllAsyncJobs()
        $this.IsRunning = $false
        Write-Verbose "AsyncJobService: Stopped"
    }
    
    [void] Cleanup() {
        $this.Stop()
    }
}

#endregion
#<!-- END_PAGE: ASE.008 -->

#<!-- PAGE: ASE.009 - FocusManager Class -->
#region Additional Service Classes

# ===== CLASS: FocusManager =====
# Module: focus-manager (new service)
# Dependencies: EventManager (optional)
# Purpose: Centralized focus management for UI components
class FocusManager {
    [UIElement]$FocusedComponent = $null
    [EventManager]$EventManager = $null

    FocusManager([EventManager]$eventManager) {
        $this.EventManager = $eventManager
        # Write-Log -Level Debug -Message "FocusManager: Initialized."
    }

    [void] SetFocus([UIElement]$component) {
        if ($this.FocusedComponent -eq $component) {
            # Write-Log -Level Debug -Message "FocusManager: Component '$($component.Name)' already has focus."
            return
        }
        
        if ($null -ne $this.FocusedComponent) {
            $this.FocusedComponent.IsFocused = $false
            $this.FocusedComponent.OnBlur()
            $this.FocusedComponent.RequestRedraw()
            # Write-Log -Level Debug -Message "FocusManager: Blurred '$($this.FocusedComponent.Name)'."
        }

        $this.FocusedComponent = $null # Clear current focus temporarily
        if ($null -ne $component -and $component.IsFocusable -and $component.Enabled -and $component.Visible) {
            $this.FocusedComponent = $component
            $component.IsFocused = $true
            $component.OnFocus()
            $component.RequestRedraw()
            # Write-Log -Level Debug -Message "FocusManager: Focused '$($component.Name)'."
            if ($this.EventManager) {
                $this.EventManager.Publish("Focus.Changed", @{ ComponentName = $component.Name; ComponentType = $component.GetType().Name })
            }
        } else {
            # Write-Log -Level Debug -Message "FocusManager: Attempted to focus non-focusable, disabled, invisible, or null component."
        }
        $global:TuiState.IsDirty = $true # Request global redraw to ensure focus state is reflected.
    }

    [void] MoveFocus([bool]$reverse = $false) {
        if (-not $global:TuiState.CurrentScreen) { return }

        $focusableComponents = [System.Collections.Generic.List[UIElement]]::new()
        
        # Helper to recursively find all focusable components within the current screen
        function Find-Focusable([UIElement]$comp, [System.Collections.Generic.List[UIElement]]$list) {
            if ($comp -and $comp.IsFocusable -and $comp.Visible -and $comp.Enabled) {
                $list.Add($comp)
            }
            foreach ($child in $comp.Children) { Find-Focusable $child $list }
        }
        
        Find-Focusable $global:TuiState.CurrentScreen $focusableComponents
        
        if ($focusableComponents.Count -eq 0) {
            $this.SetFocus($null) # Clear focus if no focusable components
            return
        }
        
        # Sort components by TabIndex, then Y, then X for consistent order
        $sorted = $focusableComponents | Sort-Object { $_.TabIndex * 10000 + $_.Y * 100 + $_.X }

        $currentIndex = -1
        if ($this.FocusedComponent) {
            for ($i = 0; $i -lt $sorted.Count; $i++) {
                if ($sorted[$i] -eq $this.FocusedComponent) {
                    $currentIndex = $i
                    break
                }
            }
        }
        
        $nextIndex = -1
        if ($reverse) {
            $nextIndex = ($currentIndex - 1 + $sorted.Count) % $sorted.Count
        } else {
            $nextIndex = ($currentIndex + 1) % $sorted.Count
        }

        # If no component was focused or current one not found, default to first/last
        if ($currentIndex -eq -1) {
            $nextIndex = if ($reverse) { $sorted.Count - 1 } else { 0 }
        }

        $this.SetFocus($sorted[$nextIndex])
    }

    [void] ReleaseFocus() {
        $this.SetFocus($null)
        # Write-Log -Level Debug -Message "FocusManager: All focus released."
    }

    [void] Cleanup() {
        $this.FocusedComponent = $null
        # Write-Log -Level Debug -Message "FocusManager: Cleanup complete."
    }
}

# ===== CLASS: DialogManager =====
# Module: dialog-manager (new service)
# Dependencies: EventManager, FocusManager
# Purpose: Centralized dialog management
class DialogManager {
    [System.Collections.Generic.List[UIElement]] $_activeDialogs = [System.Collections.Generic.List[UIElement]]::new()
    [EventManager]$EventManager = $null
    [FocusManager]$FocusManager = $null

    DialogManager([EventManager]$eventManager, [FocusManager]$focusManager) {
        $this.EventManager = $eventManager
        $this.FocusManager = $focusManager
        # Write-Log -Level Debug -Message "DialogManager: Initialized."
    }

    [void] ShowDialog([UIElement]$dialog) {
        if ($null -eq $dialog) {
            throw [System.ArgumentException]::new("Provided element is null.", "dialog")
        }
        
        # Calculate center position based on console size
        $consoleWidth = $global:TuiState.BufferWidth
        $consoleHeight = $global:TuiState.BufferHeight

        $dialog.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $dialog.Width) / 2))
        $dialog.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $dialog.Height) / 2))

        # If there's a currently focused component, save it
        if ($this.FocusManager) {
            # Use metadata to store previous focus for restoration
            $dialog.Metadata.PreviousFocus = $this.FocusManager.FocusedComponent
            $this.FocusManager.ReleaseFocus() # Release current focus
        }

        # Add to local tracking list and global overlay stack
        $this._activeDialogs.Add($dialog)
        $dialog.Visible = $true
        $dialog.IsOverlay = $true # Mark as an overlay for rendering

        # Explicitly add to global overlay stack
        $global:TuiState.OverlayStack.Add($dialog)
        
        # Initialize and enter the dialog if it implements these methods
        if ($dialog.PSObject.Methods['Initialize'] -and -not $dialog._isInitialized) {
            $dialog.Initialize()
            $dialog._isInitialized = $true
        }
        if ($dialog.PSObject.Methods['OnEnter']) {
            $dialog.OnEnter()
        }

        $dialog.RequestRedraw()
        # Write-Log -Level Info -Message "DialogManager: Showing dialog '$($dialog.Name)' at X=$($dialog.X), Y=$($dialog.Y)."
        
        # Set focus to the dialog itself or its first focusable child
        if ($this.FocusManager) {
            # Let the dialog class handle finding its first internal focusable
            if ($dialog.PSObject.Methods['SetInitialFocus']) {
                $dialog.SetInitialFocus()
            } else {
                $this.FocusManager.SetFocus($dialog) # Fallback to focusing the dialog container
            }
        }
    }

    [void] HideDialog([UIElement]$dialog) {
        if ($null -eq $dialog) { return }

        if ($this._activeDialogs.Remove($dialog)) {
            $dialog.Visible = $false
            $dialog.IsOverlay = $false

            # Remove from global overlay stack
            if ($global:TuiState.OverlayStack.Contains($dialog)) {
                $global:TuiState.OverlayStack.Remove($dialog)
            }

            # Call Cleanup on the dialog to release its resources
            $dialog.Cleanup()

            # Restore previous focus
            if ($this.FocusManager -and $dialog.Metadata.PreviousFocus -is [UIElement]) {
                $this.FocusManager.SetFocus($dialog.Metadata.PreviousFocus)
            } else {
                $this.FocusManager.ReleaseFocus() # Clear focus if no previous component
            }

            $dialog.RequestRedraw() # Force redraw to remove dialog from screen
            # Write-Log -Level Info -Message "DialogManager: Hiding dialog '$($dialog.Name)'."
        } else {
            # Write-Log -Level Warning -Message "DialogManager: Attempted to hide a dialog '$($dialog.Name)' that was not active."
        }
    }

    [void] Cleanup() {
        foreach ($dialog in $this._activeDialogs.ToArray()) { # Use ToArray to avoid collection modification during iteration
            $this.HideDialog($dialog) # This will also cleanup and remove from overlay stack
        }
        $this._activeDialogs.Clear()
        # Write-Log -Level Debug -Message "DialogManager: Cleanup complete."
    }
}

#endregion
#<!-- END_PAGE: ASE.009 -->

#<!-- PAGE: ASE.010 - TuiFrameworkService Class -->
#region TuiFrameworkService - Framework State Management

# ==============================================================================
# CLASS: TuiFrameworkService
#
# INHERITS: N/A
#
# DEPENDENCIES: None (directly accesses global state)
#
# PURPOSE:
#   Provides a clean service interface for accessing framework state and
#   dimensions instead of components directly accessing $global:TuiState.
#   This encapsulates global state access and provides a more maintainable
#   architecture.
#
# KEY LOGIC:
#   - GetDimensions: Returns current buffer dimensions
#   - GetCurrentScreen: Returns the currently active screen
#   - IsRunning: Returns whether the engine is running
#   - RequestRedraw: Marks the global state as dirty for redraw
#   - GetFrameCount: Returns current frame count for debugging
# ==============================================================================
class TuiFrameworkService {
    [hashtable]$_globalState = $null
    
    TuiFrameworkService() {
        $this._globalState = $global:TuiState
        Write-Log -Level Debug -Message "TuiFrameworkService: Initialized with global state access"
    }
    
    [hashtable] GetDimensions() {
        return @{
            Width = $this._globalState.BufferWidth
            Height = $this._globalState.BufferHeight
        }
    }
    
    [int] GetWidth() {
        return $this._globalState.BufferWidth
    }
    
    [int] GetHeight() {
        return $this._globalState.BufferHeight
    }
    
    [object] GetCurrentScreen() {
        return $this._globalState.CurrentScreen
    }
    
    [bool] IsRunning() {
        return $this._globalState.Running
    }
    
    [void] RequestRedraw() {
        $this._globalState.IsDirty = $true
    }
    
    [int] GetFrameCount() {
        return $this._globalState.FrameCount
    }
    
    [object] GetCompositorBuffer() {
        return $this._globalState.CompositorBuffer
    }
    
    [object] GetFocusedComponent() {
        return $this._globalState.FocusedComponent
    }
    
    [void] SetFocusedComponent([object]$component) {
        $this._globalState.FocusedComponent = $component
    }
    
    [object] GetCommandPalette() {
        return $this._globalState.CommandPalette
    }
    
    [System.Collections.Generic.List[UIElement]] GetOverlayStack() {
        return $this._globalState.OverlayStack
    }
    
    [void] AddOverlay([UIElement]$overlay) {
        $this._globalState.OverlayStack.Add($overlay)
        $this.RequestRedraw()
    }
    
    [bool] RemoveOverlay([UIElement]$overlay) {
        $removed = $this._globalState.OverlayStack.Remove($overlay)
        if ($removed) {
            $this.RequestRedraw()
        }
        return $removed
    }
    
    [hashtable] GetServices() {
        return $this._globalState.Services
    }
    
    [object] GetService([string]$serviceName) {
        return $this._globalState.Services[$serviceName]
    }
    
    [void] Cleanup() {
        Write-Log -Level Debug -Message "TuiFrameworkService: Cleanup completed"
        # No cleanup needed - just reports completion
    }
}

#endregion
#<!-- END_PAGE: ASE.010 -->



####\CommandPalette_Fixed.ps1
# ===== CLASS: CommandPalette =====
# Module: command-palette
# Dependencies: UIElement, Panel, ListBox, TextBoxComponent
# Purpose: Searchable command interface - FINAL FIXED VERSION
class CommandPalette : UIElement {
    hidden [ListBox]$_listBox
    hidden [TextBoxComponent]$_searchBox
    hidden [Panel]$_panel
    hidden [List[object]]$_allActions
    hidden [List[object]]$_filteredActions
    hidden [object]$_actionService
    hidden [scriptblock]$OnCancel
    hidden [scriptblock]$OnSelect

    CommandPalette([string]$name, [object]$actionService) : base($name) {
        $this.IsFocusable = $true
        $this.Visible = $false
        $this.IsOverlay = $true
        $this.Width = 60
        $this.Height = 20
        $this._actionService = $actionService
        
        $this.Initialize()
    }

    hidden [void] Initialize() {
        $this._panel = [Panel]::new("CommandPalette_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.Title = " Command Palette "
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this.AddChild($this._panel)

        $this._searchBox = [TextBoxComponent]::new("CommandPalette_Search")
        $this._searchBox.X = 2
        $this._searchBox.Y = 1
        $this._searchBox.Width = $this.Width - 4
        $this._searchBox.Height = 3
        $this._searchBox.Placeholder = "Type to search commands..."
        
        # Fix: Properly capture $this reference for the closure
        $paletteRef = $this
        $this._searchBox.OnChange = {
            param($sender, $text)
            $paletteRef.FilterActions($text)
        }.GetNewClosure()
        $this._panel.AddChild($this._searchBox)

        $this._listBox = [ListBox]::new("CommandPalette_List")
        $this._listBox.X = 2
        $this._listBox.Y = 4
        $this._listBox.Width = $this.Width - 4
        $this._listBox.Height = $this.Height - 6
        $this._panel.AddChild($this._listBox)

        $this._allActions = [List[object]]::new()
        $this._filteredActions = [List[object]]::new()
    }

    [void] Show() {
        $consoleWidth = $global:TuiState.BufferWidth
        $consoleHeight = $global:TuiState.BufferHeight
        $this.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $this.Width) / 2))
        $this.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $this.Height) / 2))
        
        $this.RefreshActions()
        $this._searchBox.Text = ""
        $this._searchBox.CursorPosition = 0
        $this.FilterActions("")
        $this.Visible = $true
        
        if (-not $global:TuiState.OverlayStack.Contains($this)) {
            $global:TuiState.OverlayStack.Add($this)
        }
        
        $focusManager = $global:TuiState.Services.FocusManager
        if ($focusManager) {
            $focusManager.SetFocus($this._searchBox)
        }
        $global:TuiState.IsDirty = $true
    }

    [void] Hide() {
        $this.Visible = $false
        if ($global:TuiState.OverlayStack.Contains($this)) {
            $global:TuiState.OverlayStack.Remove($this)
        }
        $focusManager = $global:TuiState.Services.FocusManager
        if ($focusManager) {
            $focusManager.ReleaseFocus()
        }
        $global:TuiState.IsDirty = $true
        if ($this.OnCancel) { & $this.OnCancel }
    }

    [void] RefreshActions() {
        $this._allActions.Clear()
        if ($this._actionService) {
            $actions = $this._actionService.GetAllActions()
            if ($actions -and $actions.Values) {
                $sortedActions = $actions.Values | Sort-Object Category, Name
                foreach ($action in $sortedActions) {
                    $this._allActions.Add($action)
                }
            }
        }
    }

    [void] FilterActions([string]$searchText) {
        $this._filteredActions.Clear()
        $this._listBox.ClearItems()
        
        $actionsToDisplay = if ([string]::IsNullOrWhiteSpace($searchText)) { 
            $this._allActions 
        } else {
            $searchLower = $searchText.ToLower()
            $filtered = @()
            foreach ($action in $this._allActions) {
                if ($action.Name.ToLower().Contains($searchLower) -or
                    ($action.Description -and $action.Description.ToLower().Contains($searchLower)) -or
                    ($action.Category -and $action.Category.ToLower().Contains($searchLower))) {
                    $filtered += $action
                }
            }
            $filtered
        }

        foreach ($action in $actionsToDisplay) {
            $this._filteredActions.Add($action)
            $displayText = if ($action.Category) { "[$($action.Category)] $($action.Name)" } else { $action.Name }
            if ($action.Description) {
                $displayText = "$displayText - $($action.Description)"
            }
            $this._listBox.AddItem($displayText)
        }
        
        if ($this._filteredActions.Count -gt 0) { 
            $this._listBox.SelectedIndex = 0 
        }
        $this.RequestRedraw()
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        # Fixed switch statement syntax - use commas for multiple values
        switch ($key.Key) {
            ([ConsoleKey]::Escape) { 
                $this.Hide()
                return $true 
            }
            ([ConsoleKey]::Enter) {
                if ($this._listBox.SelectedIndex -ge 0 -and $this._listBox.SelectedIndex -lt $this._filteredActions.Count) {
                    $selectedAction = $this._filteredActions[$this._listBox.SelectedIndex]
                    if ($selectedAction) {
                        $this.Hide()
                        try {
                            $this._actionService.ExecuteAction($selectedAction.Name, @{})
                        } catch {
                            Write-Log -Level Error -Message "CommandPalette: Error executing action '$($selectedAction.Name)': $_"
                        }
                    }
                }
                return $true
            }
            ([ConsoleKey]::UpArrow) {
                return $this._listBox.HandleInput($key)
            }
            ([ConsoleKey]::DownArrow) {
                return $this._listBox.HandleInput($key)
            }
            ([ConsoleKey]::PageUp) {
                return $this._listBox.HandleInput($key)
            }
            ([ConsoleKey]::PageDown) {
                return $this._listBox.HandleInput($key)
            }
            ([ConsoleKey]::Home) {
                return $this._listBox.HandleInput($key)
            }
            ([ConsoleKey]::End) {
                return $this._listBox.HandleInput($key)
            }
            default { 
                # Let the search box handle text input
                return $false 
            }
        }
    }
}



####\fc2.ps1
#------------------------------------------------------------------------------------------
# SCRIPT:      filecopy-and-concatenate.ps1
#
# DESCRIPTION: Finds specified file types in a given path and its subdirectories.
#              For each file, it can create a .txt copy and/or concatenate all
#              file contents into a single output file.
#
# FEATURES:
#   - Full parameter support for path, file types, and output name.
#   - Safety features: Supports -WhatIf and -Confirm for all file operations.
#   - Verbose output: Use the -Verbose switch to see detailed progress.
#   - Performance: Uses an efficient single-write operation for the concatenated file.
#   - Robustness: Uses idiomatic PowerShell for path manipulation and error handling.
#   - Compatibility: Works on Windows PowerShell 5.1 and newer.
#   - NEW: Can create individual .txt copies of each source file.
#
# USAGE:
#   # Basic run in the current folder for PowerShell files
#   .\filecopy-and-concatenate.ps1 -Verbose
#
#   # Run on a different project, for C# files, with a different output name
#   .\filecopy-and-concatenate.ps1 -Path "C:\Projects\MyWebApp" -Include "*.cs" -OutputFileName "SourceCode.txt"
#
#   # To also create individual .txt copies of each file:
#   .\filecopy-and-concatenate.ps1 -CreateIndividualCopies -Verbose
#
#   # Perform a "dry run" to see what would happen without making any changes
#   .\filecopy-and-concatenate.ps1 -Path "C:\SomethingImportant" -CreateIndividualCopies -WhatIf
#
#------------------------------------------------------------------------------------------

# Enable support for -WhatIf, -Confirm, and advanced parameter binding
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    # The starting directory to search in. Defaults to the current directory.
    [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "The root path to search for files.")]
    [string]
    $Path = (Get-Location).Path,

    # An array of file patterns to include. Defaults to PowerShell script files.
    [Parameter(Mandatory = $false, HelpMessage = "File patterns to include, e.g., '*.ps1', '*.psm1'.")]
    [string[]]
    $Include = @("*.ps1", "*.psm1"),

    # The name of the final concatenated output file.
    [Parameter(Mandatory = $false, HelpMessage = "Name of the concatenated output file.")]
    [string]
    $OutputFileName = "all.txt",

    # Switch to create a .txt copy of each individual file found.
    [Parameter(Mandatory = $false, HelpMessage = "If specified, creates a .txt copy of each found file.")]
    [switch]
    $CreateIndividualCopies
)

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Resolve-Path returns a PathInfo object. We use it for robustness.
    $resolvedPathObject = Resolve-Path -Path $Path
    $basePathString = $resolvedPathObject.Path # Store the string path for reuse
    $outputFilePath = Join-Path -Path $basePathString -ChildPath $OutputFileName

    Write-Verbose "Starting operations in: $basePathString"
    Write-Verbose "Searching for file types: $($Include -join ', ')"
    Write-Verbose "Output file will be: $outputFilePath"
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Individual .txt copies will be created."
    }

    # --- Step 1: Find all specified files recursively ---
    $filesToProcess = Get-ChildItem -Path $basePathString -Recurse -Include $Include -File

    if ($null -eq $filesToProcess) {
        Write-Warning "No files found matching the specified criteria."
        return # Exit gracefully if no files are found
    }

    Write-Verbose "Found $($filesToProcess.Count) files to process."

    # --- Step 2: Clear the existing output file if it exists ---
    # This is part of the concatenation process, so it's good to do it early.
    if ((Test-Path $outputFilePath) -and $PSCmdlet.ShouldProcess($outputFilePath, "Remove existing output file")) {
        Remove-Item $outputFilePath -Force
    }

    # --- Step 3: Process each file for individual copies (if requested) ---
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Processing files to create individual .txt copies..."
        foreach ($file in $filesToProcess) {
            # Create a new filename by changing the extension to .txt
            $txtCopyPath = [System.IO.Path]::ChangeExtension($file.FullName, ".txt")

            # Use ShouldProcess for -WhatIf and -Confirm support
            if ($PSCmdlet.ShouldProcess($txtCopyPath, "Copy from '$($file.Name)'")) {
                Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force
                Write-Verbose "Created copy: '$txtCopyPath'"
            }
        }
    }

    # --- Step 4: Concatenate all files into the output file (Efficiently) ---
    Write-Verbose "Starting concatenation of all files into '$OutputFileName'..."
    if ($PSCmdlet.ShouldProcess($outputFilePath, "Concatenate $($filesToProcess.Count) files")) {
        # Using a subexpression `$(...)` to gather all output before writing to the file once.
        Set-Content -Path $outputFilePath -Encoding UTF8 -Value $(
            foreach ($file in $filesToProcess) {
                # Calculate the relative path for the header
                $relativePath = $file.FullName.Substring($basePathString.Length)
                # Ensure consistent format like '\subdir\file.ps1'
                $relativePath = '\' + $relativePath.TrimStart('\/')

                # Output the header for this file
                "####$relativePath"

                # Output the file's content
                Get-Content -Path $file.FullName -Raw -Encoding Default

                # Output two blank lines for separation
                ""
                ""
            }
        )
        Write-Host "All operations complete. Concatenated content saved to '$outputFilePath'."
    }
}
catch {
    # A global catch block for any unexpected, terminating errors.
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    Write-Error "Script execution halted at line $($_.InvocationInfo.ScriptLineNumber): $($_.InvocationInfo.Line)"
}


####\filecopy.ps1
#------------------------------------------------------------------------------------------
# SCRIPT:      filecopy-and-concatenate.ps1
#
# DESCRIPTION: Finds specified file types in a given path and its subdirectories.
#              For each file, it can create a .txt copy and/or concatenate all
#              file contents into a single output file.
#
# FEATURES:
#   - Full parameter support for path, file types, and output name.
#   - Safety features: Supports -WhatIf and -Confirm for all file operations.
#   - Verbose output: Use the -Verbose switch to see detailed progress.
#   - Performance: Uses an efficient single-write operation for the concatenated file.
#   - Robustness: Uses idiomatic PowerShell for path manipulation and error handling.
#   - Compatibility: Works on Windows PowerShell 5.1 and newer.
#
# USAGE:
#   # Basic run in the current folder for PowerShell files
#   .\filecopy-and-concatenate.ps1 -Verbose
#
#   # Run on a different project, for C# files, with a different output name
#   .\filecopy-and-concatenate.ps1 -Path "C:\Projects\MyWebApp" -Include "*.cs" -OutputFileName "SourceCode.txt"
#
#   # Perform a "dry run" to see what would happen without making any changes
#   .\filecopy-and-concatenate.ps1 -Path "C:\SomethingImportant" -WhatIf
#
#   # To also create individual .txt copies of each file:
#   .\filecopy-and-concatenate.ps1 -CreateIndividualCopies -Verbose
#
#------------------------------------------------------------------------------------------

# Enable support for -WhatIf, -Confirm, and advanced parameter binding
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    # The starting directory to search in. Defaults to the current directory.
    [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "The root path to search for files.")]
    [string]
    $Path = (Get-Location).Path,

    # An array of file patterns to include. Defaults to PowerShell script files.
    [Parameter(Mandatory = $false, HelpMessage = "File patterns to include, e.g., '*.ps1', '*.psm1'.")]
    [string[]]
    $Include = @("*.ps1", "*.psm1"),

    # The name of the final concatenated output file.
    [Parameter(Mandatory = $false, HelpMessage = "Name of the concatenated output file.")]
    [string]
    $OutputFileName = "all.txt",
    
    # Switch to create a .txt copy of each individual file found.
    [Parameter(Mandatory = $false, HelpMessage = "If specified, creates a .txt copy of each found file.")]
    [switch]
    $CreateIndividualCopies
)

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Resolve-Path returns a PathInfo object. We use it for robustness.
    $resolvedPathObject = Resolve-Path -Path $Path
    $outputFilePath = Join-Path -Path $resolvedPathObject.Path -ChildPath $OutputFileName

    Write-Verbose "Starting operations in: $($resolvedPathObject.Path)"
    Write-Verbose "Searching for file types: $($Include -join ', ')"
    Write-Verbose "Output file will be: $outputFilePath"

    # --- Step 1: Find all specified files recursively ---
    $filesToProcess = Get-ChildItem -Path $resolvedPathObject.Path -Recurse -Include $Include -File

    if ($null -eq $filesToProcess) {
        Write-Warning "No files found matching the specified criteria."
        return # Exit gracefully if no files are found
    }

    Write-Verbose "Found $($filesToProcess.Count) files to process."

    # --- Step 2: Clear the existing output file if it exists ---
    if ((Test-Path $outputFilePath) -and $PSCmdlet.ShouldProcess($outputFilePath, "Remove existing output file")) {
        Remove-Item $outputFilePath -Force
    }

    # --- Step 3: Process each file for individual copies (if requested) ---
    if ($CreateIndividualCopies.IsPresent) {
        foreach ($file in $filesToProcess) {
            $txtCopyPath = [System.IO.Path]::ChangeExtension($file.FullName, ".txt")
            if ($PSCmdlet.ShouldProcess($txtCopyPath, "Copy from $($file.Name)")) {
                Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force
                Write-Verbose "Copied '$($file.Name)' to '$($txtCopyPath)'"
            }
        }
    }

    # --- Step 4: Concatenate all files into the output file (Efficiently) ---
    Write-Verbose "Starting concatenation of all files into '$OutputFileName'..."
    if ($PSCmdlet.ShouldProcess($outputFilePath, "Concatenate $($filesToProcess.Count) files")) {
        Set-Content -Path $outputFilePath -Encoding UTF8 -Value $(
            foreach ($file in $filesToProcess) {
                # CORRECTED LINE: Get the length from the .Path property of the PathInfo object.
                $basePathString = $resolvedPathObject.Path
                $relativePath = $file.FullName.Substring($basePathString.Length)
                $relativePath = '\' + $relativePath.TrimStart('\/') # Ensure consistent format like '\subdir\file.ps1'
                
                # Output the header for this file
                "####$relativePath"
                
                # Output the file's content
                Get-Content -Path $file.FullName -Raw -Encoding UTF8
                
                # Output a blank line for separation
                ""
            }
        )
        Write-Host "All operations complete. Concatenated content saved to '$outputFilePath'."
    }

}
catch {
    # A global catch block for any unexpected, terminating errors.
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    Write-Error "Script execution halted at line $($_.InvocationInfo.ScriptLineNumber): $($_.InvocationInfo.Line)"
}


####\Start.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Enhanced Application Startup
# Beautiful splash screen and smooth initialization
# ==============================================================================

param(
    [string]$Theme = "Synthwave",
    [switch]$NoSplash,
    [switch]$Debug
)

# Set error action preference
$ErrorActionPreference = 'Stop'

# Function to display animated splash screen
function Show-SplashScreen {
    param([int]$Duration = 3000)
    
    Clear-Host
    $host.UI.RawUI.CursorSize = 0  # Hide cursor
    
    $width = $host.UI.RawUI.WindowSize.Width
    $height = $host.UI.RawUI.WindowSize.Height
    
    # ASCII Art Logo
    $logo = @"
    
                                                                       
          ___   _  _  _  ___  __  __     ___  _  _  ___  ___  _  _  _ 
         / _ \ | \/ || |/ _ \|  \/  |   | _ \| || |/ _ \| __|| \| || |
        | |_| | >  < | | (_) | |\/| |   |  _/| __ | (_) | _| | .  || |
        |_| |_|/_/\_\|_|\___/|_|  |_|   |_|  |_||_|\___/|___||_|\_||_|
                                                                       
                            v4.0 ENHANCED EDITION                      
                                                                       
    
"@
    
    $tagline = "The Future of Terminal User Interfaces"
    $credits = "Powered by PowerShell 7+ | Built with "
    
    # Calculate positions
    $logoLines = $logo -split "`n"
    $logoWidth = ($logoLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
    $startX = [Math]::Max(0, [Math]::Floor(($width - $logoWidth) / 2))
    $startY = [Math]::Max(0, [Math]::Floor(($height - $logoLines.Count - 4) / 2))
    
    # Synthwave colors for animation
    $colors = @(
        [ConsoleColor]::Magenta,
        [ConsoleColor]::Cyan,
        [ConsoleColor]::Yellow,
        [ConsoleColor]::Green,
        [ConsoleColor]::Blue
    )
    
    # Animate logo appearance
    $steps = 20
    $stepDelay = $Duration / $steps
    
    for ($i = 0; $i -lt $steps; $i++) {
        $colorIndex = $i % $colors.Count
        $host.UI.RawUI.ForegroundColor = $colors[$colorIndex]
        
        # Clear and redraw
        Clear-Host
        
        # Draw logo with fade-in effect
        $y = $startY
        foreach ($line in $logoLines) {
            $host.UI.RawUI.CursorPosition = [System.Management.Automation.Host.Coordinates]::new($startX, $y)
            if ($i -ge $steps / 2 -or $y -eq $startY -or $y -eq ($startY + $logoLines.Count - 1)) {
                Write-Host $line -NoNewline
            }
            $y++
        }
        
        # Draw tagline
        if ($i -ge $steps * 0.6) {
            $taglineX = [Math]::Floor(($width - $tagline.Length) / 2)
            $host.UI.RawUI.CursorPosition = [System.Management.Automation.Host.Coordinates]::new($taglineX, $startY + $logoLines.Count + 1)
            Write-Host $tagline -ForegroundColor Cyan -NoNewline
        }
        
        # Draw credits
        if ($i -ge $steps * 0.8) {
            $creditsX = [Math]::Floor(($width - $credits.Length) / 2)
            $host.UI.RawUI.CursorPosition = [System.Management.Automation.Host.Coordinates]::new($creditsX, $startY + $logoLines.Count + 3)
            Write-Host $credits -ForegroundColor DarkGray -NoNewline
        }
        
        # Progress bar
        $progressY = $height - 3
        $progressWidth = 60
        $progressX = [Math]::Floor(($width - $progressWidth) / 2)
        $progress = [Math]::Floor(($i / $steps) * $progressWidth)
        
        $host.UI.RawUI.CursorPosition = [System.Management.Automation.Host.Coordinates]::new($progressX, $progressY)
        Write-Host "[" -NoNewline -ForegroundColor DarkGray
        Write-Host ("" * $progress) -NoNewline -ForegroundColor Green
        Write-Host ("" * ($progressWidth - $progress)) -NoNewline -ForegroundColor DarkGray
        Write-Host "]" -NoNewline -ForegroundColor DarkGray
        
        # Loading message
        $messages = @(
            "Initializing quantum cores...",
            "Loading neural matrices...",
            "Calibrating photon streams...",
            "Synchronizing time crystals...",
            "Establishing neural link..."
        )
        $messageIndex = [Math]::Floor(($i / $steps) * $messages.Count)
        $message = $messages[$messageIndex]
        $messageX = [Math]::Floor(($width - $message.Length) / 2)
        $host.UI.RawUI.CursorPosition = [System.Management.Automation.Host.Coordinates]::new($messageX, $progressY + 1)
        Write-Host $message -ForegroundColor Yellow
        
        Start-Sleep -Milliseconds $stepDelay
    }
    
    # Final pause
    Start-Sleep -Milliseconds 500
    
    # Reset
    $host.UI.RawUI.ForegroundColor = [ConsoleColor]::Gray
    $host.UI.RawUI.CursorSize = 25  # Restore cursor
    Clear-Host
}

# Main startup sequence
try {
    # Show splash screen unless disabled
    if (-not $NoSplash) {
        Show-SplashScreen -Duration 2000
    }
    
    Write-Host "Loading Axiom-Phoenix v4.0 Enhanced..." -ForegroundColor Cyan
    Write-Host ""
    
    # Verify PowerShell version
    if ($PSVersionTable.PSVersion.Major -lt 7) {
        Write-Host "ERROR: PowerShell 7.0 or higher is required!" -ForegroundColor Red
        Write-Host "Current version: $($PSVersionTable.PSVersion)" -ForegroundColor Yellow
        Write-Host "Download from: https://github.com/PowerShell/PowerShell" -ForegroundColor Cyan
        exit 1
    }
    
    # Get script directory
    $scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
    if ([string]::IsNullOrEmpty($scriptDir)) {
        $scriptDir = Get-Location
    }
    
    # Load framework files in order with progress indication
    $files = @(
        @{ File = "AllBaseClasses.ps1"; Description = "Core Framework" },
        @{ File = "AllModels.ps1"; Description = "Data Models" },
        @{ File = "AllComponents.ps1"; Description = "UI Components" },
        @{ File = "AllScreens.ps1"; Description = "Application Screens" },
        @{ File = "AllFunctions.ps1"; Description = "Utility Functions" },
        @{ File = "AllServices.ps1"; Description = "Business Services" },
        @{ File = "AllRuntime.ps1"; Description = "Runtime Engine" }
    )
    
    $totalFiles = $files.Count
    $currentFile = 0
    
    foreach ($fileInfo in $files) {
        $currentFile++
        $percent = [Math]::Floor(($currentFile / $totalFiles) * 100)
        
        Write-Host "[$percent%] " -NoNewline -ForegroundColor Green
        Write-Host "Loading $($fileInfo.Description)... " -NoNewline -ForegroundColor Gray
        
        $filePath = Join-Path $scriptDir $fileInfo.File
        if (Test-Path $filePath) {
            . $filePath
            Write-Host "" -ForegroundColor Green
        } else {
            Write-Host "" -ForegroundColor Red
            throw "File not found: $filePath"
        }
    }
    
    Write-Host ""
    Write-Host "All framework files loaded successfully!" -ForegroundColor Green
    Write-Host ""
    
    # Create service container
    Write-Host "Initializing services..." -ForegroundColor Cyan
    $container = [ServiceContainer]::new()
    
    # Register services with fancy names
    $services = @(
        @{ Type = "Logger"; Name = "Neural Logger" },
        @{ Type = "EventManager"; Name = "Quantum Event System" },
        @{ Type = "ThemeManager"; Name = "Photon Theme Engine" },
        @{ Type = "DataManager"; Name = "Data Matrix" },
        @{ Type = "ActionService"; Name = "Command Nexus" },
        @{ Type = "KeybindingService"; Name = "Neural Keybinds" },
        @{ Type = "NavigationService"; Name = "Dimensional Navigator" },
        @{ Type = "FocusManager"; Name = "Focus Controller" },
        @{ Type = "DialogManager"; Name = "Dialog Orchestrator" },
        @{ Type = "TuiFrameworkService"; Name = "Framework State Manager" }
    )
    
    # Create a hashtable to store services as we register them
    $servicesHashtable = @{}
    
    foreach ($service in $services) {
        Write-Host "   Initializing $($service.Name)... " -NoNewline -ForegroundColor Gray
        
        $instance = switch ($service.Type) {
            "Logger" { [Logger]::new((Join-Path $env:TEMP "axiom-phoenix.log")) }
            "EventManager" { [EventManager]::new() }
            "ThemeManager" { [ThemeManager]::new() }
            "DataManager" { [DataManager]::new((Join-Path $env:TEMP "axiom-data.json")) }
            "ActionService" { [ActionService]::new() }
            "KeybindingService" { [KeybindingService]::new() }
            "NavigationService" { 
                # NavigationService requires a hashtable of services
                [NavigationService]::new($servicesHashtable) 
            }
            "FocusManager" { 
                # FocusManager requires EventManager
                $eventManager = $servicesHashtable.EventManager
                if ($eventManager) {
                    [FocusManager]::new($eventManager)
                } else {
                    [FocusManager]::new($null)
                }
            }
            "DialogManager" { 
                # DialogManager requires EventManager and FocusManager
                $eventManager = $servicesHashtable.EventManager
                $focusManager = $servicesHashtable.FocusManager
                if ($eventManager -and $focusManager) {
                    [DialogManager]::new($eventManager, $focusManager)
                } else {
                    # Create with nulls if dependencies not available
                    [DialogManager]::new($null, $null)
                }
            }
            "TuiFrameworkService" { [TuiFrameworkService]::new() }
        }
        
        # Store service in hashtable for dependencies
        $servicesHashtable[$service.Type] = $instance
        
        $container.Register($service.Type, $instance)
        Write-Host "" -ForegroundColor Green
    }
    
    # Set the selected theme
    $themeManager = $container.GetService("ThemeManager")
    if ($themeManager -and $Theme) {
        $themeManager.LoadTheme($Theme)
        Write-Host ""
        Write-Host "Theme '$Theme' activated!" -ForegroundColor Magenta
    }
    
    # Register default actions
    $actionService = $container.GetService("ActionService")
    if ($actionService) {
        $actionService.RegisterDefaultActions()
        Write-Host "Default actions registered!" -ForegroundColor Green
    }
    
    # Create sample data with enhanced items
    Write-Host ""
    Write-Host "Generating sample data..." -ForegroundColor Cyan
    $dataManager = $container.GetService("DataManager")
    
    # Enhanced sample tasks
    $sampleTasks = @(
        @{
            Title = " Launch Quantum Core Module"
            Description = "Initialize the quantum processing core for enhanced computational capabilities"
            Priority = "High"
            Progress = 75
        },
        @{
            Title = " Optimize Neural Networks"
            Description = "Fine-tune the AI neural network parameters for improved performance"
            Priority = "Medium"
            Progress = 45
        },
        @{
            Title = " Calibrate Wave Functions"
            Description = "Adjust quantum wave function parameters for stable operation"
            Priority = "High"
            Progress = 90
        },
        @{
            Title = " Crystal Matrix Alignment"
            Description = "Align the photonic crystal matrix for optimal light transmission"
            Priority = "Low"
            Progress = 20
        },
        @{
            Title = " Energy Field Stabilization"
            Description = "Stabilize the plasma energy field generators"
            Priority = "Medium"
            Progress = 60
        }
    )
    
    foreach ($taskData in $sampleTasks) {
        $task = [PmcTask]::new()
        $task.Title = $taskData.Title
        $task.Description = $taskData.Description
        $task.Priority = [TaskPriority]::$($taskData.Priority)
        $task.SetProgress($taskData.Progress)
        $task.ProjectKey = "PHOENIX"
        [void]$dataManager.AddTask($task)
    }
    
    Write-Host "Sample data created!" -ForegroundColor Green
    
    # Start application
    Write-Host ""
    Write-Host "" -ForegroundColor Cyan
    Write-Host " AXIOM-PHOENIX v4.0 ENHANCED - READY TO LAUNCH! " -ForegroundColor Yellow
    Write-Host "" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "Press any key to enter the matrix..." -ForegroundColor Green
    $null = $host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    
    # Create initial screen
    $dashboardScreen = [DashboardScreen]::new($container)
    
    # Launch the application
    Clear-Host
    Start-AxiomPhoenix -ServiceContainer $container -InitialScreen $dashboardScreen
}
catch {
    Write-Host ""
    Write-Host "CRITICAL ERROR!" -ForegroundColor Red -BackgroundColor DarkRed
    Write-Host "Failed to load framework files!" -ForegroundColor Red
    Write-Host ""
    Write-Host "Error Details:" -ForegroundColor Yellow
    Write-Host $_.Exception.Message -ForegroundColor Red
    Write-Host ""
    Write-Host "Stack Trace:" -ForegroundColor Yellow
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkGray
    
    if ($Debug) {
        Write-Host ""
        Write-Host "Full Exception:" -ForegroundColor Yellow
        Write-Host $_ -ForegroundColor DarkGray
    }
    
    Write-Host ""
    Write-Host "Press any key to exit..." -ForegroundColor Gray
    $null = $host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    exit 1
}



####\TaskListScreen_FilterBox_Fixed.ps1
        # Add filter textbox at the top
        $this._filterBox = [TextBoxComponent]::new("FilterBox")
        $this._filterBox.Placeholder = "Type to filter tasks..."
        $this._filterBox.X = 2
        $this._filterBox.Y = 2
        $this._filterBox.Width = [Math]::Floor($this.Width * 0.6) - 4
        $this._filterBox.Height = 1
        
        # Fix: Properly capture $this reference for the closure
        $thisScreen = $this
        $this._filterBox.OnChange = {
            param($sender, $newText)
            $thisScreen._filterText = $newText
            $thisScreen._RefreshTasks()
            $thisScreen._UpdateDisplay()
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._filterBox)



####\Write-Log_Fixed.ps1
function Write-Log {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet('Trace', 'Debug', 'Info', 'Warning', 'Error', 'Fatal')]
        [string]$Level,
        
        [Parameter(Mandatory)]
        [string]$Message,
        
        [object]$Data = $null
    )
    
    # Try to get logger from global state first
    $logger = $null
    try {
        if ($global:TuiState -and 
            $global:TuiState.Services -and 
            $global:TuiState.Services -is [hashtable] -and
            $global:TuiState.Services.ContainsKey('Logger')) {
            $logger = $global:TuiState.Services['Logger']
        }
    }
    catch {
        # Silently ignore any errors accessing global state
        $logger = $null
    }
    
    if ($logger) {
        # Build message without JSON serialization to avoid circular reference warnings
        $finalMessage = $Message
        if ($Data) {
            try {
                # Handle different data types safely without JSON serialization
                if ($Data -is [UIElement]) {
                    # UIElement objects have circular references, so just log basic info
                    $finalMessage = "$Message | Data: [UIElement: Name=$($Data.Name), Type=$($Data.GetType().Name), Visible=$($Data.Visible)]"
                }
                elseif ($Data -is [System.Management.Automation.ErrorRecord]) {
                    # Error records need special handling
                    $finalMessage = "$Message | Error: $($Data.Exception.Message) at $($Data.InvocationInfo.PositionMessage)"
                }
                elseif ($Data -is [System.Collections.IEnumerable] -and -not ($Data -is [string])) {
                    # Handle collections without serialization
                    $count = 0
                    try { $count = @($Data).Count } catch { }
                    $itemTypes = @()
                    foreach ($item in $Data | Select-Object -First 3) {
                        $itemTypes += $item.GetType().Name
                    }
                    $typeInfo = if ($itemTypes.Count -gt 0) { " (Types: $($itemTypes -join ', ')...)" } else { "" }
                    $finalMessage = "$Message | Data: [Collection with $count items$typeInfo]"
                }
                elseif ($Data -is [hashtable]) {
                    # Handle hashtables specially
                    $keys = @($Data.Keys) | Select-Object -First 5
                    $keyList = if ($keys.Count -gt 0) { " (Keys: $($keys -join ', ')...)" } else { "" }
                    $finalMessage = "$Message | Data: [Hashtable with $($Data.Count) entries$keyList]"
                }
                elseif ($Data -is [PSCustomObject] -or $Data.GetType().IsClass) {
                    # For complex objects, list properties instead of serializing
                    $props = @()
                    foreach ($prop in $Data.PSObject.Properties | Select-Object -First 5) {
                        try {
                            $value = $prop.Value
                            if ($value -is [UIElement] -or $value -is [System.Collections.IEnumerable]) {
                                $props += "$($prop.Name)=[Complex]"
                            } else {
                                $props += "$($prop.Name)=$($value -replace '\s+', ' ')"
                            }
                        } catch {
                            $props += "$($prop.Name)=[Error]"
                        }
                    }
                    $propInfo = if ($props.Count -gt 0) { " {$($props -join ', ')...}" } else { "" }
                    $finalMessage = "$Message | Data: [$($Data.GetType().Name)$propInfo]"
                }
                elseif ($Data -is [string] -or $Data -is [int] -or $Data -is [double] -or $Data -is [bool]) {
                    # Simple types can be converted directly
                    $finalMessage = "$Message | Data: $Data"
                }
                else {
                    # Fallback for unknown types
                    $finalMessage = "$Message | Data: [$($Data.GetType().Name): $($Data.ToString())]"
                }
            }
            catch {
                # If all else fails, just log the type
                $typeName = "Unknown"
                try { $typeName = $Data.GetType().Name } catch { }
                $finalMessage = "$Message | Data: [Object of type $typeName]"
            }
        }
        
        # Logger.Log method signature is: Log([string]$message, [string]$level = "Info")
        $logger.Log($finalMessage, $Level)
    }
    else {
        # Fallback to console if logger not available
        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        $prefix = "[$timestamp] [$Level]"
        
        switch ($Level) {
            'Error' { Write-Host "$prefix $Message" -ForegroundColor Red }
            'Warning' { Write-Host "$prefix $Message" -ForegroundColor Yellow }
            'Info' { Write-Host "$prefix $Message" -ForegroundColor Cyan }
            'Debug' { Write-Host "$prefix $Message" -ForegroundColor Gray }
            'Trace' { Write-Host "$prefix $Message" -ForegroundColor DarkGray }
            'Fatal' { Write-Host "$prefix $Message" -ForegroundColor DarkRed }
            default { Write-Host "$prefix $Message" }
        }
    }
}



