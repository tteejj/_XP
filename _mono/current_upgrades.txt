You're right to look for more! The previous upgrades focused on critical stability and performance, but a mature framework always has more areas for refinement. Let's outline additional reasonable upgrades for your `mono` framework, focusing on robustness, developer experience, and architectural consistency.

---

# Additional Upgrade Areas for Axiom-Phoenix v4.0 (`mono` version)

Beyond the previously discussed critical and quality-of-life improvements, here are further recommendations to make your `mono` framework more robust, efficient, and user-friendly.

---

## 1. Centralized Focus Management Service

**Issue:** Focus logic (`Set-ComponentFocus`, `Move-Focus`) is currently implemented as global functions and directly manipulates `global:TuiState.FocusedComponent`. This is less modular and harder to test or extend.

**Upgrade:** Encapsulate focus management within a dedicated `FocusManager` service, registered with the `ServiceContainer`. This service will be responsible for setting, tracking, and moving focus between `UIElement`s.

**Changes:**

*   **`AllServices.ps1`:**
    *   **New Class: `FocusManager`**
        ```powershell
        # ===== CLASS: FocusManager =====
        # Module: focus-manager-service (new)
        # Dependencies: UIElement, EventManager (optional)
        # Purpose: Manages the currently focused UI element
        class FocusManager {
            [UIElement]$FocusedComponent = $null
            [EventManager]$EventManager = $null

            FocusManager() {
                # Write-Log -Level Debug -Message "FocusManager: Initialized."
            }

            FocusManager([EventManager]$eventManager) {
                $this.EventManager = $eventManager
                # Write-Log -Level Debug -Message "FocusManager: Initialized with EventManager."
            }

            [void] SetFocus([UIElement]$component) {
                if ($this.FocusedComponent -eq $component) {
                    # Write-Log -Level Debug -Message "FocusManager: Component '$($component.Name)' already has focus."
                    return
                }
                
                if ($null -ne $this.FocusedComponent) {
                    $this.FocusedComponent.IsFocused = $false
                    $this.FocusedComponent.OnBlur()
                    $this.FocusedComponent.RequestRedraw()
                    # Write-Log -Level Debug -Message "FocusManager: Blurred '$($this.FocusedComponent.Name)'."
                }

                $this.FocusedComponent = $null
                if ($null -ne $component -and $component.IsFocusable -and $component.Enabled -and $component.Visible) {
                    $this.FocusedComponent = $component
                    $component.IsFocused = $true
                    $component.OnFocus()
                    $component.RequestRedraw()
                    # Write-Log -Level Debug -Message "FocusManager: Focused '$($component.Name)'."
                    if ($this.EventManager) {
                        $this.EventManager.Publish("Focus.Changed", @{ Component = $component.Name })
                    }
                } else {
                    # Write-Log -Level Debug -Message "FocusManager: Attempted to focus non-focusable or null component."
                }
            }

            [void] MoveFocus([bool]$reverse = $false) {
                if (-not $global:TuiState.CurrentScreen) { return }

                $focusableComponents = [System.Collections.Generic.List[UIElement]]::new()
                
                # Helper to recursively find all focusable components within the current screen
                function Find-Focusable([UIElement]$comp, [System.Collections.Generic.List[UIElement]]$list) {
                    if ($comp.IsFocusable -and $comp.Visible -and $comp.Enabled) {
                        $list.Add($comp)
                    }
                    foreach ($child in $comp.Children) { Find-Focusable $child $list }
                }
                
                Find-Focusable $global:TuiState.CurrentScreen $focusableComponents
                
                if ($focusableComponents.Count -eq 0) {
                    $this.SetFocus($null) # Clear focus if no focusable components
                    return
                }
                
                # Sort components by TabIndex, then Y, then X for consistent order
                $sorted = $focusableComponents | Sort-Object { $_.TabIndex * 10000 + $_.Y * 100 + $_.X }

                $currentIndex = -1
                if ($this.FocusedComponent) {
                    for ($i = 0; $i -lt $sorted.Count; $i++) {
                        if ($sorted[$i] -eq $this.FocusedComponent) {
                            $currentIndex = $i
                            break
                        }
                    }
                }
                
                $nextIndex = -1
                if ($reverse) {
                    $nextIndex = ($currentIndex - 1 + $sorted.Count) % $sorted.Count
                } else {
                    $nextIndex = ($currentIndex + 1) % $sorted.Count
                }

                # If no component was focused or current one not found, default to first/last
                if ($currentIndex -eq -1) {
                    $nextIndex = if ($reverse) { $sorted.Count - 1 } else { 0 }
                }

                $this.SetFocus($sorted[$nextIndex])
            }

            [void] ReleaseFocus() {
                $this.SetFocus($null)
                # Write-Log -Level Debug -Message "FocusManager: All focus released."
            }

            [void] Cleanup() {
                $this.FocusedComponent = $null
                # Write-Log -Level Debug -Message "FocusManager: Cleanup complete."
            }
        }
        ```
    *   **Register `FocusManager` in `Initialize-Services`:**
        ```powershell
        # In Start.ps1 (or your main app init), within Initialize Services block:
        # Before other services that might need it (e.g., ActionService depends on it for 'Focus.Changed' events)
        $container.Register("FocusManager", [FocusManager]::new($eventManager)) 
        ```
*   **`AllFunctions.ps1`:**
    *   **Remove global functions:** Delete `function Set-ComponentFocus` and `function Get-NextFocusableComponent`, `function Move-Focus`. All logic is now in the service.
*   **`AllComponents.ps1`:**
    *   **Update `TextBox.Focus()`:**
        ```powershell
        # In TextBox class
        [void] Focus() {
            if ($global:TuiState.Services.FocusManager) {
                $global:TuiState.Services.FocusManager.SetFocus($this._textBox) # Pass inner component if it's the one that needs focus
            } else {
                # Fallback if focus manager not available (consider removing this if it's a hard dependency)
                $this._textBox.IsFocused = $true
                $this._textBox.OnFocus()
                $this._textBox.RequestRedraw()
            }
        }
        ```
        *Self-correction:* `TextBox` is a wrapper, so `Focus()` should call `SetFocus` on its internal `_textBox` component.
*   **`AllRuntime.ps1`:**
    *   **Update `Process-SingleKeyInput`:**
        ```powershell
        # In Process-SingleKeyInput function:
        # Old: Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        # New:
        if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
            $focusManager = $global:TuiState.Services.FocusManager
            if ($focusManager) {
                $focusManager.MoveFocus(-Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift))
                $global:TuiState.IsDirty = $true
                return
            }
        }

        # Handle input for focused component (directly use FocusManager.FocusedComponent)
        $focusedComponent = $global:TuiState.Services.FocusManager?.FocusedComponent # Get from service
        if ($focusedComponent -and $focusedComponent.HandleInput($keyInfo)) {
            $global:TuiState.IsDirty = $true
            return # Input handled by focused component.
        }
        ```

---

## 2. Consistent Logger Usage (Post-`Invoke-WithErrorHandling` Integration)

**Issue:** Many `Write-Verbose`, `Write-Warning`, and direct `Write-Host` calls for logging are still present, bypassing the `Logger` service.

**Upgrade:** Replace all direct logging calls with `Write-Log` for centralized, configurable logging.

**Changes:**

*   **`AllBaseClasses.ps1`, `AllComponents.ps1`, `AllScreens.ps1`, `AllServices.ps1`, `AllRuntime.ps1` (and `Start.ps1`, `debug-start.ps1`, `debug-start-detailed.ps1`):**
    *   **Systematic Replacement:** Go through every file and replace `Write-Verbose`, `Write-Warning`, and any `Write-Host` calls that are purely for logging/debugging with `Write-Log`.
    *   **Example (in `TuiBuffer` constructor):**
        ```powershell
        # Old: # Write-Verbose "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
        # New: Write-Log -Level Debug -Message "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
        ```
    *   **Modify `Write-Log` function in `AllFunctions.ps1`:** To automatically use the registered logger.
        ```powershell
        # In AllFunctions.ps1, modify Write-Log:
        function Write-Log {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory)][string]$Message,
                [ValidateSet('Trace', 'Debug', 'Info', 'Warning', 'Error', 'Fatal')] # Add Trace/Fatal levels
                [string]$Level = 'Info',
                [object]$Data = $null # Optional data to log (e.g., specific objects, hashtables)
            )
            
            # Use the Logger service if it's available in global state
            if ($global:TuiState -and $global:TuiState.Services.Logger) {
                $global:TuiState.Services.Logger.Log($Message, $Level, $Data)
            } else {
                # Fallback to standard PowerShell write cmdlets if logger isn't initialized
                # This ensures early messages or errors during logger initialization are still seen
                switch ($Level) {
                    'Error' { Write-Error "$Message" }
                    'Warning' { Write-Warning "$Message" }
                    'Debug' { Write-Debug "$Message" }
                    'Trace' { Write-Host "$Message" -ForegroundColor DarkGray }
                    default { Write-Host "$Message" } # Info/Fatal/etc.
                }
            }
        }
        ```
    *   **Initial Logger Setup in `Start.ps1`:** In `Start.ps1`, for the initial phase before the `ServiceContainer` is fully built, you might still need `Write-Host` or `Write-Output` for messages like "Loading framework files..." but once the logger is registered, switch to `Write-Log`.

---

## 3. Improved Dialog Overlay Management & Positioning

**Issue:** Dialogs (AlertDialog, ConfirmDialog, InputDialog) directly inherit from `UIElement`, manually calculate their position (`X`, `Y`), and are then handled by the `OverlayStack` in `global:TuiState`. This makes managing multiple overlays or precise positioning difficult.

**Upgrade:** Implement a `DialogManager` service responsible for showing, hiding, and positioning dialogs. Dialogs themselves become simpler UI elements.

**Changes:**

*   **`AllServices.ps1`:**
    *   **New Class: `DialogManager`**
        ```powershell
        # ===== CLASS: DialogManager =====
        # Module: dialog-manager-service (new)
        # Dependencies: UIElement, EventManager (optional), FocusManager (optional)
        # Purpose: Manages modal dialogs and their display/positioning
        class DialogManager {
            [System.Collections.Generic.List[UIElement]] $_activeDialogs = [System.Collections.Generic.List[UIElement]]::new()
            [EventManager]$EventManager = $null
            [FocusManager]$FocusManager = $null

            DialogManager([EventManager]$eventManager, [FocusManager]$focusManager) {
                $this.EventManager = $eventManager
                $this.FocusManager = $focusManager
                # Write-Log -Level Debug -Message "DialogManager: Initialized."
            }

            [void] ShowDialog([UIElement]$dialog) {
                if (-not $dialog -or -not ($dialog -is [Dialog])) {
                    throw [System.ArgumentException]::new("Provided element is not a Dialog.", "dialog")
                }
                
                # Calculate center position
                $consoleWidth = $global:TuiState.BufferWidth
                $consoleHeight = $global:TuiState.BufferHeight

                $dialog.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $dialog.Width) / 2))
                $dialog.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $dialog.Height) / 2))

                # If there's a currently focused component, save it
                if ($this.FocusManager) {
                    $dialog.Metadata.PreviousFocus = $this.FocusManager.FocusedComponent
                    $this.FocusManager.ReleaseFocus() # Release current focus
                }

                $this.{_activeDialogs}.Add($dialog)
                $dialog.Visible = $true
                $dialog.IsOverlay = $true # Ensure it's treated as an overlay
                
                # Explicitly manage overlay stack in global state
                $global:TuiState.OverlayStack.Add($dialog)
                
                # Initialize and enter the dialog if it implements these methods
                if ($dialog.PSObject.Methods['Initialize'] -and -not $dialog._isInitialized) {
                    $dialog.Initialize()
                    $dialog._isInitialized = $true
                }
                if ($dialog.PSObject.Methods['OnEnter']) {
                    $dialog.OnEnter()
                }

                $dialog.RequestRedraw()
                # Write-Log -Level Info -Message "DialogManager: Showing dialog '$($dialog.Name)' at X=$($dialog.X), Y=$($dialog.Y)."
                
                # Set focus to the dialog itself or its first focusable child
                if ($this.FocusManager) {
                    $this.FocusManager.SetFocus($dialog) # Set focus to the dialog container first
                    $dialog.SetInitialFocus() # This would be a method on Dialog to find its first focusable child
                }
            }

            [void] HideDialog([UIElement]$dialog) {
                if (-not $dialog) { return }

                if ($this.{_activeDialogs}.Remove($dialog)) {
                    $dialog.Visible = $false
                    $dialog.IsOverlay = $false

                    # Remove from global overlay stack
                    if ($global:TuiState.OverlayStack.Contains($dialog)) {
                        $global:TuiState.OverlayStack.Remove($dialog)
                    }

                    # Cleanup the dialog
                    $dialog.Cleanup()

                    # Restore previous focus
                    if ($this.FocusManager -and $dialog.Metadata.PreviousFocus -is [UIElement]) {
                        $this.FocusManager.SetFocus($dialog.Metadata.PreviousFocus)
                    } else {
                        $this.FocusManager.ReleaseFocus() # Clear focus if no previous component
                    }

                    $dialog.RequestRedraw() # Force redraw to remove dialog from screen
                    # Write-Log -Level Info -Message "DialogManager: Hiding dialog '$($dialog.Name)'."
                } else {
                    # Write-Log -Level Warning -Message "DialogManager: Attempted to hide a dialog '$($dialog.Name)' that was not active."
                }
            }

            [void] Cleanup() {
                foreach ($dialog in $this.{_activeDialogs}.ToArray()) { # Use ToArray to avoid collection modification during iteration
                    $this.HideDialog($dialog) # This will also cleanup and remove from overlay stack
                }
                $this.{_activeDialogs}.Clear()
                # Write-Log -Level Debug -Message "DialogManager: Cleanup complete."
            }
        }
        ```
    *   **Register `DialogManager` in `Initialize-Services`:**
        ```powershell
        # In Start.ps1 (or your main app init), within Initialize Services block:
        $eventManager = $container.GetService("EventManager") # Ensure these are retrieved first
        $focusManager = $container.GetService("FocusManager")
        $container.Register("DialogManager", [DialogManager]::new($eventManager, $focusManager))
        ```
*   **`AllBaseClasses.ps1` (Dialog Class):**
    *   **Modify `Dialog` class:**
        *   Remove `Show`, `Close`, `ShowDialog` methods from `Dialog` base class. These will be handled by `DialogManager`.
        *   Add a new method `SetInitialFocus()` to `Dialog` to find its first focusable child.
        *   Dialogs now become purely structural UI elements that can be `Show`n/`Hide`n by the `DialogManager`.
        ```powershell
        # In Dialog class (inside AllBaseClasses.ps1, or where Dialog is defined):
        class Dialog : UIElement {
            [string]$Title = ""
            [string]$Message = "" # Kept for convenience for simple message dialogs
            hidden [Panel]$_panel
            hidden [object]$Result = $null # Dialogs still set their own result
            hidden [bool]$_isComplete = $false # Indicates dialog has finished
            [scriptblock]$OnClose # Callback for when dialog is closed

            # ... constructors ...

            # Remove original Show, Close, ShowDialog methods from here.
            # Add this new method:
            [void] SetInitialFocus() {
                if ($this.Children.Count -gt 0) {
                    $firstFocusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible -and $_.Enabled } | Sort-Object TabIndex, Y, X | Select-Object -First 1
                    if ($firstFocusable -and $global:TuiState.Services.FocusManager) {
                        $global:TuiState.Services.FocusManager.SetFocus($firstFocusable)
                        # Write-Log -Level Debug -Message "Dialog '$($this.Name)': Set initial focus to '$($firstFocusable.Name)'."
                    }
                }
            }

            # Optional: Add a public Close method for internal use by dialog components
            [void] Close([object]$result) {
                $this.Result = $result
                $this._isComplete = $true # Mark as complete for external handlers
                
                # The actual hiding will be done by DialogManager
                # Write-Log -Level Debug -Message "Dialog '$($this.Name)': Requested close with result: '$result'."
                if ($this.OnClose) {
                    & $this.OnClose $result
                }
                # Publish a general dialog close event for DialogManager to pick up
                if ($global:TuiState.Services.EventManager) {
                    $global:TuiState.Services.EventManager.Publish("Dialog.Closed", @{ Dialog = $this; Result = $result })
                }
            }
        }
        ```
*   **`AllComponents.ps1` (Dialog implementations):**
    *   **Modify `AlertDialog`, `ConfirmDialog`, `InputDialog`:**
        *   Remove their `Show` methods (they are now generic `Dialog` elements managed by `DialogManager`).
        *   Update their internal components' `OnClick` handlers to call `$this.Close($result)` (the `Dialog` base method).
        *   Ensure `HandleInput` methods call `$this.Close()` appropriately.
    *   **Example (in `AlertDialog` constructor):**
        ```powershell
        # In AlertDialog, InitializeAlert method:
        $this._okButton.OnClick = {
            $this.Close($true) # Calls the Dialog base Close method
        }.GetNewClosure()
        ```
*   **`AllRuntime.ps1`:**
    *   **Update `Process-SingleKeyInput`:** Overlays now only include dialogs and command palette.
        ```powershell
        # In Process-SingleKeyInput:
        # If there's an active overlay (like a dialog), give it priority.
        if ($global:TuiState.OverlayStack.Count -gt 0) {
            $topOverlay = $global:TuiState.OverlayStack[-1] # Peek at the top overlay
            # Give focus to the top overlay, then let it handle input
            if ($global:TuiState.Services.FocusManager) {
                $global:TuiState.Services.FocusManager.SetFocus($topOverlay)
            }
            if ($topOverlay.HandleInput($keyInfo)) {
                $global:TuiState.IsDirty = $true
                return # Input handled by overlay.
            }
        }
        # ... rest of Process-SingleKeyInput ...
        ```
    *   **Update `Invoke-TuiRender`:** Remove manual positioning for `CommandPalette` and `OverlayStack` elements. They should set their own `X`/`Y` properties or be positioned by `DialogManager`.
        ```powershell
        # In Invoke-TuiRender:
        # Command palette render:
        if ($global:TuiState.CommandPalette -and $global:TuiState.CommandPalette.Visible) {
            $global:TuiState.CommandPalette.Render()
            $paletteBuffer = $global:TuiState.CommandPalette.GetBuffer()
            if ($paletteBuffer) {
                # CommandPalette should set its own X/Y (e.g. in Show() or OnResize())
                $global:TuiState.CompositorBuffer.BlendBuffer($paletteBuffer, 
                    $global:TuiState.CommandPalette.X, # Use CommandPalette's own X
                    $global:TuiState.CommandPalette.Y  # Use CommandPalette's own Y
                )
            }
        }
        
        # Overlays render:
        if ($global:TuiState.ContainsKey('OverlayStack') -and $global:TuiState.OverlayStack -and $global:TuiState.OverlayStack.Count -gt 0) {
            foreach ($overlay in $global:TuiState.OverlayStack) {
                if ($overlay -and $overlay.Visible) {
                    $overlay.Render()
                    $overlayBuffer = $overlay.GetBuffer()
                    if ($overlayBuffer) {
                        # Overlays should set their own X/Y (e.g. via DialogManager)
                        $global:TuiState.CompositorBuffer.BlendBuffer($overlayBuffer, $overlay.X, $overlay.Y)
                    }
                }
            }
        }
        ```
    *   **Update `CommandPalette.Show()` in `AllComponents.ps1`:**
        ```powershell
        # In CommandPalette class, Show method:
        [void] Show() {
            $this.RefreshActions()
            $this._searchBox.Clear()
            $this.FilterActions("")
            $this.Visible = $true
            $this.IsOverlay = $true # Explicitly set this
            
            # Center the command palette
            $consoleWidth = $global:TuiState.BufferWidth
            $consoleHeight = $global:TuiState.BufferHeight
            $this.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $this.Width) / 2))
            $this.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $this.Height) / 2))

            if ($global:TuiState.Services.FocusManager) {
                $global:TuiState.Services.FocusManager.SetFocus($this._searchBox._textBox) # Focus the inner textbox
            }
            $this.RequestRedraw()
        }
        ```
*   **Update `Show-TuiOverlay` and `Close-TopTuiOverlay` in `AllRuntime.ps1`:** These functions will now primarily interact with the `DialogManager` for `Dialog` types.
    ```powershell
    # In AllRuntime.ps1, modify Show-TuiOverlay:
    function Show-TuiOverlay {
        [CmdletBinding()]
        param(
            [Parameter(Mandatory)]
            [UIElement]$Element
        )
        try {
            if ($Element -is [Dialog]) {
                if ($global:TuiState.Services.DialogManager) {
                    $global:TuiState.Services.DialogManager.ShowDialog($Element)
                    return
                } else {
                    Write-Log -Level Error -Message "DialogManager not available to show dialog '$($Element.Name)'."
                    throw "DialogManager service is not available."
                }
            }
            
            # Keep existing logic for non-Dialog overlays if you need them outside DialogManager
            Write-Log -Level Debug -Message "Showing generic overlay: $($Element.Name)"
            if (-not $global:TuiState.ContainsKey('OverlayStack')) {
                $global:TuiState.OverlayStack = [System.Collections.Generic.List[UIElement]]::new()
            }
            $global:TuiState.OverlayStack.Add($Element)
            $Element.Visible = $true
            $Element.IsOverlay = $true
            # ... Initialize/OnEnter logic ...
            $global:TuiState.IsDirty = $true
        } catch {
            Write-Log -Level Error -Message "Failed to show overlay: $($_.Exception.Message)" -Data $_
            throw
        }
    }

    # In AllRuntime.ps1, modify Close-TopTuiOverlay:
    function Close-TopTuiOverlay {
        [CmdletBinding()]
        param()
        try {
            if (-not $global:TuiState.ContainsKey('OverlayStack') -or $global:TuiState.OverlayStack.Count -eq 0) {
                Write-Log -Level Warning -Message "No overlays to close."
                return
            }
            
            $topOverlay = $global:TuiState.OverlayStack[-1]
            
            if ($topOverlay -is [Dialog]) {
                if ($global:TuiState.Services.DialogManager) {
                    $global:TuiState.Services.DialogManager.HideDialog($topOverlay)
                    return
                } else {
                    Write-Log -Level Error -Message "DialogManager not available to close dialog '$($topOverlay.Name)'."
                    throw "DialogManager service is not available."
                }
            }

            # Existing logic for non-Dialog overlays:
            Write-Log -Level Debug -Message "Closing generic top overlay: $($topOverlay.Name)"
            $global:TuiState.OverlayStack.RemoveAt($global:TuiState.OverlayStack.Count - 1)
            $topOverlay.Visible = $false
            $topOverlay.IsOverlay = $false
            # ... OnExit/Cleanup logic ...
            $global:TuiState.IsDirty = $true
        } catch {
            Write-Log -Level Error -Message "Failed to close top overlay: $($_.Exception.Message)" -Data $_
            throw
        }
    }
    ```

---

## 4. Enhanced Theming Integration

**Issue:** Many components still use hardcoded `ConsoleColor` values or direct `[ConsoleColor]::Cyan` assignments instead of consistently leveraging `Get-ThemeColor`.

**Upgrade:** Fully integrate `ThemeManager.GetColor` (and potentially a new `GetStyle` method) to allow for complete theme customization without modifying component code.

**Changes:**

*   **`AllServices.ps1` (ThemeManager):**
    *   **Review `ThemeManager.GetColor`:** Ensure it correctly handles hex colors and provides sensible fallbacks. (Already covered in previous upgrade, but re-emphasize the need for all color lookups to go through it).
    *   **Optional: Add `GetStyle` method:**
        ```powershell
        # In ThemeManager class, add a GetStyle method to retrieve complex component styles
        [hashtable] GetStyle([string]$componentPath) {
            # Example: "button.normal", "textbox.focus"
            $segments = $componentPath.Split('.')
            $currentStyle = $this.CurrentTheme
            foreach ($segment in $segments) {
                if ($currentStyle -is [hashtable] -and $currentStyle.ContainsKey($segment)) {
                    $currentStyle = $currentStyle[$segment]
                } else {
                    return @{} # Path not found, return empty hashtable
                }
            }
            
            # Create a new hashtable to ensure it's mutable and can be expanded/modified
            $resolvedStyle = [hashtable]::new($currentStyle) # Use a copy

            # Example of how you might resolve nested references or palette values
            # (Requires your theme definition to have a 'Palette' key)
            # if ($resolvedStyle.ContainsKey('FG') -and $resolvedStyle.FG -is [string] -and $resolvedStyle.FG.StartsWith('$')) {
            #     # Assuming '$' indicates a palette reference, e.g., $Accent, $Foreground
            #     $paletteKey = $resolvedStyle.FG.Substring(1)
            #     $resolvedStyle.FG = $this.GetColor($paletteKey)
            # }
            # ... similar for BG, BorderFG, etc. ...

            return $resolvedStyle
        }
        ```
*   **`AllComponents.ps1` (All UI Components):**
    *   **Refactor `OnRender` methods:**
        *   Replace direct `"#HEXCODE"` or `[ConsoleColor]::COLOR` assignments with `Get-ThemeColor("color.name")`.
        *   For complex elements like `ButtonComponent` or `Panel`, consider retrieving a full style hashtable from `ThemeManager.GetStyle` and using that for all `Write-TuiBox`/`Write-TuiText` calls.
    *   **Example (`ButtonComponent` - Simplified approach):**
        ```powershell
        # In ButtonComponent.OnRender
        $buttonBaseFg = Get-ThemeColor("button.normal.foreground")
        $buttonBaseBg = Get-ThemeColor("button.normal.background")
        $buttonBaseBorder = Get-ThemeColor("button.normal.border")

        $buttonFocusFg = Get-ThemeColor("button.focus.foreground")
        $buttonFocusBg = Get-ThemeColor("button.focus.background")
        $buttonFocusBorder = Get-ThemeColor("button.focus.border")

        $buttonPressedFg = Get-ThemeColor("button.pressed.foreground")
        $buttonPressedBg = Get-ThemeColor("button.pressed.background")
        $buttonPressedBorder = Get-ThemeColor("button.pressed.border")

        # Determine current colors based on state
        $currentBg = $buttonBaseBg
        $currentFg = $buttonBaseFg
        $currentBorder = $buttonBaseBorder

        if ($this.IsFocused) {
            $currentFg = $buttonFocusFg
            $currentBg = $buttonFocusBg
            $currentBorder = $buttonFocusBorder
        }
        if ($this.IsPressed) {
            $currentFg = $buttonPressedFg
            $currentBg = $buttonPressedBg
            $currentBorder = $buttonPressedBorder
        }

        $boxStyle = @{ BorderStyle = "Single"; BorderFG = $currentBorder; BG = $currentBg }
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -Style $boxStyle
        
        $textStyle = @{ FG = $currentFg; BG = $currentBg }
        $textX = [Math]::Floor(($this.Width - $this.Text.Length) / 2)
        $textY = [Math]::Floor(($this.Height - 1) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -Style $textStyle
        ```
    *   **Example (`Panel` - Using `GetStyle`):**
        ```powershell
        # In Panel.OnRender
        # Get base panel style
        $panelStyle = $global:TuiState.Services.ThemeManager.GetStyle("panel")
        $panelBg = $panelStyle.BG ?? "#000000"
        $panelFg = $panelStyle.FG ?? "#FFFFFF"
        $panelBorder = $panelStyle.Border ?? "#808080"
        $panelTitle = $panelStyle.Title ?? "#00FFFF"

        $bgCell = [TuiCell]::new(' ', $panelFg, $panelBg)
        $this._private_buffer.Clear($bgCell)

        if ($this.HasBorder) {
            $borderColorToUse = if ($this.IsFocused) { Get-ThemeColor("Accent") } else { $panelBorder }
            $titleColorToUse = if ($this.IsFocused) { Get-ThemeColor("Highlight") } else { $panelTitle } # Focused title can be different
            
            $boxStyle = @{ 
                BorderStyle = $this.BorderStyle; 
                BorderFG = $borderColorToUse; 
                BG = $panelBg; 
                TitleFG = $titleColorToUse 
                TitleStyle = @{ Bold = $true } # Make title bold by default
            }
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -Title $this.Title -Style $boxStyle
        }
        # ... rest of OnRender ...
        ```

---

## 5. UIElement `_private_buffer` Initialization Consistency

**Issue:** The `_private_buffer` in `UIElement` (and subclasses) is sometimes initialized in constructors, sometimes in `Resize`, and sometimes conditionally in `_RenderContent`. This can lead to null-reference issues or incorrect buffer sizing.

**Upgrade:** Ensure `_private_buffer` is always initialized and correctly sized in the constructor, and then consistently managed by the `Resize` method, which is called early in the lifecycle.

**Changes:**

*   **`AllBaseClasses.ps1` (UIElement):**
    ```powershell
    # In UIElement class:
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        # Initialize buffer immediately with default dimensions
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        Write-Log -Level Debug -Message "UIElement 'Unnamed' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([string]$name) {
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        # Initialize buffer immediately with default dimensions
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        Write-Log -Level Debug -Message "UIElement '$($this.Name)' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        # Initialize buffer immediately with provided dimensions
        $this._private_buffer = [TuiBuffer]::new($width, $height, "Unnamed.Buffer")
        Write-Log -Level Debug -Message "UIElement 'Unnamed' created at ($x, $y) with dimensions $($width)x$($height)."
    }

    # In Resize method: Remove the conditional re-initialization
    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        try {
            if ($this.Width -eq $newWidth -and $this.Height -eq $newHeight) {
                Write-Log -Level Debug -Message "Resize: Component '$($this.Name)' already has target dimensions ($($newWidth)x$($newHeight)). No change."
                return
            }
            $this.Width = $newWidth
            $this.Height = $newHeight
            
            # Always resize the existing buffer, it should never be null here.
            $this._private_buffer.Resize($newWidth, $newHeight)
            
            $this.RequestRedraw()
            $this.OnResize($newWidth, $newHeight)
            Write-Log -Level Debug -Message "Component '$($this.Name)' resized to $($newWidth)x$($newHeight)."
        }
        catch {
            Write-Log -Level Error -Message "Failed to resize component '$($this.Name)' to $($newWidth)x$($newHeight): $($_.Exception.Message)" -Data $_
            throw
        }
    }

    # In _RenderContent: Remove redundant buffer checks/re-initialization
    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }
        
        # This check is largely redundant if constructors and Resize are robust
        # but can remain as a final safeguard.
        if ($null -eq $this._private_buffer -or $this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
            $bufferWidth = [Math]::Max(1, $this.Width)
            $bufferHeight = [Math]::Max(1, $this.Height)
            $this._private_buffer = [TuiBuffer]::new($bufferWidth, $bufferHeight, "$($this.Name).Buffer")
            Write-Log -Level Warning -Message "UIElement '$($this.Name)': Buffer was null or mismatched during _RenderContent. Re-initialized. This should ideally not happen."
        }
        
        if ($this._needs_redraw) {
            $this._private_buffer.Clear() # Clear buffer before OnRender
            $this.OnRender()
            $this._needs_redraw = $false
            Write-Log -Level Debug -Message "Rendered own content for '$($this.Name)'."
        }
        # ... rest of _RenderContent ...
    }
    ```

---

## 6. Robust Date and Enum Deserialization in DataManager

**Issue:** The `DataManager.LoadData` method uses direct casting for `DateTime` and `Enum` properties (`[datetime]::Parse($data.CreatedAt)` and `[TaskStatus]::$($taskData.Status)`). This is prone to errors if the JSON data is missing or malformed for these fields.

**Upgrade:** Add more robust parsing with `try/catch` or `TryParse` for `DateTime` and graceful fallback for `Enum` values.

**Changes:**

*   **`AllServices.ps1` (DataManager):**
    ```powershell
    # In DataManager.LoadData, within Task loading loop:
    # ... existing code ...
    foreach ($taskData in $data.Tasks) {
        try {
            # ... existing checks ...

            # Robust DateTime parsing
            $task.CreatedAt = try { [datetime]::Parse($taskData.CreatedAt) } catch { [datetime]::Now }
            $task.UpdatedAt = try { [datetime]::Parse($taskData.UpdatedAt) } catch { [datetime]::Now }
            $task.DueDate = $null # Initialize to null
            if ($taskData.ContainsKey('DueDate') -and $taskData.DueDate -is [string] -and -not [string]::IsNullOrEmpty($taskData.DueDate) -and $taskData.DueDate -ne "N/A") {
                $parsedDate = $null
                if ([DateTime]::TryParse($taskData.DueDate, [ref]$parsedDate)) {
                    $task.DueDate = $parsedDate
                } else {
                    Write-Log -Level Warning -Message "DataManager: Invalid DueDate format for task '$($taskData.Id)': '$($taskData.DueDate)'. Setting to null."
                }
            }

            # Robust Enum parsing
            $task.Status = [TaskStatus]::Pending # Default
            if ($taskData.ContainsKey('Status') -and $taskData.Status -is [string]) {
                $parsedStatus = $null
                if ([Enum]::TryParse([TaskStatus], $taskData.Status, [ref]$parsedStatus)) {
                    $task.Status = $parsedStatus
                } else {
                    Write-Log -Level Warning -Message "DataManager: Invalid TaskStatus for task '$($taskData.Id)': '$($taskData.Status)'. Defaulting to Pending."
                }
            }
            
            $task.Priority = [TaskPriority]::Medium # Default
            if ($taskData.ContainsKey('Priority') -and $taskData.Priority -is [string]) {
                $parsedPriority = $null
                if ([Enum]::TryParse([TaskPriority], $taskData.Priority, [ref]$parsedPriority)) {
                    $task.Priority = $parsedPriority
                } else {
                    Write-Log -Level Warning -Message "DataManager: Invalid TaskPriority for task '$($taskData.Id)': '$($taskData.Priority)'. Defaulting to Medium."
                }
            }

            # ... rest of task property mapping ...

        } catch {
            Write-Log -Level Warning -Message "DataManager: Skipping corrupted or invalid task record: $($_.Exception.Message)" -Data @{ TaskId = $taskData.Id; Data = $taskData }
        }
    }

    # Similar logic for PmcProject properties if they have Dates/Enums
    # Example (PmcProject):
    foreach ($projectData in $data.Projects) {
        try {
            # ... existing checks ...
            $project.CreatedAt = try { [datetime]::Parse($projectData.CreatedAt) } catch { [datetime]::Now }
            $project.UpdatedAt = try { [datetime]::Parse($projectData.UpdatedAt) } catch { [datetime]::Now }
            # ... rest of project property mapping ...
        } catch {
            Write-Log -Level Warning -Message "DataManager: Skipping corrupted or invalid project record: $($_.Exception.Message)" -Data @{ ProjectKey = $projectData.Key; Data = $projectData }
        }
    }
    ```

---

These additional upgrades will significantly improve the internal architecture and resilience of your Axiom-Phoenix framework. Remember to apply these changes incrementally and test thoroughly after each major section. Good luck!, let's focus exclusively on *upgrading `mono`* by incorporating the beneficial changes from `acta`, ignoring any lingering issues in `acta` itself. The goal is to make `mono` more robust, efficient, and feature-ready.

This document will outline the upgrades for your `mono` framework, focusing on addressing the issues we identified previously and incorporating `acta`'s improved architectural patterns and implementations.

---

# Upgrade Guide for Axiom-Phoenix v4.0 (`mono` version)

This guide details recommended changes to your `mono` codebase, leveraging improvements and fixes found in the `acta` version.

**Goal:** Enhance stability, performance, and maintainability of `mono`.

**Important Notes Before You Start:**

*   **Backup `mono`:** Always back up your existing `mono` project before making these changes.
*   **Order Matters:** Follow the steps in the order presented, as many changes are interdependent.
*   **Careful Testing:** After each major section (or all changes), thoroughly test your application.
*   **Hex Colors Transition:** `acta` embraces hex (`#RRGGBB`) colors instead of `[ConsoleColor]`. This guide will lean towards this transition as it's a more powerful and flexible approach. You will need to update where `[ConsoleColor]` is used for `ForegroundColor`/`BackgroundColor` (e.g., in `TuiCell` properties, `TuiBuffer.WriteString`, component `OnRender` methods) to use hex strings.
*   **`_private_buffer` Access:** `acta` consistently uses `$this.{_private_buffer}` syntax (or `(_private_buffer)` for clarity) for accessing private fields, which is good practice. Adopt this where applicable.

---

## High-Priority Upgrades (Addressing Critical/Major Issues from Previous Analysis)

These changes directly resolve significant problems and improve core functionality.

### 1. **Unified and Enhanced TUI Drawing Functions (`AllFunctions.ps1`, `AllBaseClasses.ps1`)**

This addresses:
*   **Critical Issue 1:** Duplicate `Write-TuiBox` function definition.
*   **Critical Issue 2:** `Write-TuiText` style parameters not propagated.
*   **Minor Issue 8:** `TuiBuffer.WriteString` lacks full `TuiCell` parameters.

**Step 1.1: Update `TuiAnsiHelper` for Hex Colors & Simplified ANSI Generation (`AllBaseClasses.ps1`)**

*   **Locate:** `class TuiAnsiHelper` (around line 17)
*   **Change:** Replace the existing `GetForegroundCode`, `GetBackgroundCode`, `Reset`, `Bold`, `Underline`, `Italic` methods with `acta`'s more flexible `HexToRgb`, `GetAnsiSequence`, and a single `Reset` method. Remove `_fgCache` and `_bgCache` as `GetAnsiSequence` generates the full string dynamically.

```powershell
# In AllBaseClasses.ps1, inside TuiAnsiHelper class:

# Remove:
# hidden static [System.Collections.Concurrent.ConcurrentDictionary[string, string]] $_fgCache = [System.Collections.Concurrent.ConcurrentDictionary[string, string]]::new()
# hidden static [System.Collections.Concurrent.ConcurrentDictionary[string, string]] $_bgCache = [System.Collections.Concurrent.ConcurrentDictionary[string, string]]::new()

# Remove methods: ParseHexColor, GetForegroundCode, GetBackgroundCode, GetForegroundSequence, GetBackgroundSequence, Bold, Underline, Italic
# Add these new methods:

    static [hashtable] HexToRgb([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor) -or -not $hexColor.StartsWith("#") -or $hexColor.Length -ne 7) {
            return $null
        }
        try {
            return @{
                R = [System.Convert]::ToInt32($hexColor.Substring(1, 2), 16)
                G = [System.Convert]::ToInt32($hexColor.Substring(3, 2), 16)
                B = [System.Convert]::ToInt32($hexColor.Substring(5, 2), 16)
            }
        } catch {
            # Consider adding a Write-Log call here if logger is available, otherwise silent or Write-Warning
            return $null
        }
    }

    static [string] GetAnsiSequence([string]$fgHex, [string]$bgHex, [hashtable]$attributes) {
        $sequences = [System.Collections.Generic.List[string]]::new()

        # Foreground color (Truecolor - SGR 38;2)
        if ($fgHex) {
            $rgb = [TuiAnsiHelper]::HexToRgb($fgHex)
            if ($rgb) {
                $sequences.Add("38;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Background color (Truecolor - SGR 48;2)
        if ($bgHex) {
            $rgb = [TuiAnsiHelper]::HexToRgb($bgHex)
            if ($rgb) {
                $sequences.Add("48;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Style attributes
        if ($attributes) {
            if ([bool]($attributes.Bold ?? $false)) { $sequences.Add("1") }
            if ([bool]($attributes.Italic ?? $false)) { $sequences.Add("3") }
            if ([bool]($attributes.Underline ?? $false)) { $sequences.Add("4") }
            # Add Strikethrough if you plan to support it, otherwise omit
            if ([bool]($attributes.Strikethrough ?? $false)) { $sequences.Add("9") }
        }

        if ($sequences.Count -eq 0) { return "" }
        return "`e[$($sequences -join ';')m"
    }

    static [string] Reset() {
        return "`e[0m"
    }
```

**Step 1.2: Update `TuiCell` for Hex Colors and All Style Attributes (`AllBaseClasses.ps1`)**

*   **Locate:** `class TuiCell` (around line 63)
*   **Change:**
    *   Change `ForegroundColor` and `BackgroundColor` types to `[string]` (for hex).
    *   Add `[bool] $Strikethrough`.
    *   Update constructors to accept hex colors and all style flags.
    *   Update `DiffersFrom` to compare new attributes.
    *   Crucially, update `ToAnsiString` to use `TuiAnsiHelper.GetAnsiSequence`.

```powershell
# In AllBaseClasses.ps1, inside TuiCell class:

class TuiCell {
    [char] $Char = ' '
    [string] $ForegroundColor = "#FFFFFF" # Default white hex color
    [string] $BackgroundColor = "#000000" # Default black hex color
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [bool] $Strikethrough = $false # NEW Property
    [string] $StyleFlags = "" # Can keep this or remove if not used elsewhere, as individual bools are now primary
    [int] $ZIndex = 0        
    [object] $Metadata = $null 

    TuiCell() { }
    TuiCell([char]$char) { $this.Char = $char }

    # Updated constructor signature for all attributes (removed original third and fourth constructors)
    TuiCell([char]$char, [string]$fg, [string]$bg, [bool]$bold=$false, [bool]$italic=$false, [bool]$underline=$false, [bool]$strikethrough=$false) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold; $this.Italic = $italic; $this.Underline = $underline; $this.Strikethrough = $strikethrough # Assign new properties
    }

    # Copy constructor (update to include Strikethrough)
    TuiCell([object]$other) {
        $this.Char = $other.Char
        $this.ForegroundColor = $other.ForegroundColor
        $this.BackgroundColor = $other.BackgroundColor
        $this.Bold = $other.Bold
        $this.Underline = $other.Underline
        $this.Italic = $other.Italic
        $this.Strikethrough = $other.Strikethrough # NEW
        $this.StyleFlags = $other.StyleFlags
        $this.ZIndex = $other.ZIndex
        $this.Metadata = $other.Metadata
    }

    [TuiCell] WithStyle([string]$fg, [string]$bg) { # Changed types to string
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    [TuiCell] BlendWith([object]$other) {
        # Keep current logic, but ensure 'other' properties are compatible (e.g., other.Strikethrough)
        # If 'other' is also TuiCell and has these properties, it will work.
        # If not, add safety checks if blending arbitrary objects is intended.
        if ($null -eq $other) { return $this }
        
        if ($other.ZIndex -gt $this.ZIndex) { 
            return [TuiCell]::new($other)
        }
        
        if ($other.ZIndex -eq $this.ZIndex) {
            # Consider what happens if $other.Char is not space but other properties are default.
            # The original logic prioritizes char/bold/underline/italic and background change.
            # This logic might need refinement based on exact blending rules.
            # For now, keep original logic.
            if ($other.Char -ne ' ' -or $other.Bold -or $other.Underline -or $other.Italic -or $other.Strikethrough) {
                return [TuiCell]::new($other)
            }
            if ($other.BackgroundColor -ne $this.BackgroundColor) {
                return [TuiCell]::new($other)
            }
        }
        
        return $this
    }

    [bool] DiffersFrom([object]$other) {
        if ($null -eq $other) { return $true }
        
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic -or
                $this.Strikethrough -ne $other.Strikethrough -or # NEW
                $this.ZIndex -ne $other.ZIndex)
    }

    [string] ToAnsiString() {
        # This is the crucial update to use the new TuiAnsiHelper.GetAnsiSequence
        $attributes = @{ 
            Bold=$this.Bold; Italic=$this.Italic; Underline=$this.Underline; Strikethrough=$this.Strikethrough 
        }
        $sequence = [TuiAnsiHelper]::GetAnsiSequence($this.ForegroundColor, $this.BackgroundColor, $attributes)
        return "$sequence$($this.Char)" # Append character directly
    }

    # Keep ToLegacyFormat or remove if no longer needed
    [hashtable] ToLegacyFormat() {
        return @{ Char = $this.Char; FG = $this.ForegroundColor; BG = $this.BackgroundColor }
    }
    
    [string] ToString() {
        return "TuiCell(Char='$($this.Char)', FG='$($this.ForegroundColor)', BG='$($this.BackgroundColor)', Bold=$($this.Bold), Underline=$($this.Underline), Italic=$($this.Italic), Strikethrough=$($this.Strikethrough), ZIndex=$($this.ZIndex))"
    }
}
```

**Step 1.3: Update `TuiBuffer.WriteString` (`AllBaseClasses.ps1`)**

*   **Locate:** `class TuiBuffer`, `WriteString` method (around line 177)
*   **Change:** Update its signature to accept the full style `hashtable` and pass it to `TuiCell` constructor.

```powershell
# In AllBaseClasses.ps1, inside TuiBuffer class:

# Original: [void] WriteString([int]$x, [int]$y, [string]$text, $fg, $bg) {
# Replaced with:
    [void] WriteString([int]$x, [int]$y, [string]$text, [hashtable]$style = @{}) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            return
        }
        
        # Extract properties from the style object, providing safe defaults
        $fg = $style.FG ?? "#FFFFFF" # Default Foreground
        $bg = $style.BG ?? "#000000" # Default Background
        $bold = [bool]($style.Bold ?? $false)
        $italic = [bool]($style.Italic ?? $false)
        $underline = [bool]($style.Underline ?? $false)
        $strikethrough = [bool]($style.Strikethrough ?? $false)
        $zIndex = [int]($style.ZIndex ?? 0)

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break } 
            if ($currentX -ge 0) {
                # Pass all style parameters to TuiCell constructor
                $cell = [TuiCell]::new($char, $fg, $bg, $bold, $italic, $underline, $strikethrough)
                $cell.ZIndex = $zIndex # Assign ZIndex
                $this.SetCell($currentX, $y, $cell)
            }
            $currentX++
        }
        $this.IsDirty = $true
        # Write-Verbose "WriteString: Wrote '$text' to buffer '$($this.Name)' at ($x, $y)."
    }
```

**Step 1.4: Refactor `Write-TuiText` (`AllFunctions.ps1`)**

*   **Locate:** `function Write-TuiText` (around line 89)
*   **Change:** Update its signature and logic to accept a single `[hashtable]$Style` parameter, and use the new `TuiBuffer.WriteString`.

```powershell
# In AllFunctions.ps1, replace existing Write-TuiText with:

function Write-TuiText {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][string]$Text,
        [hashtable]$Style = @{} # Accepts a hashtable for all style properties
    )
    
    try {
        if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { return }
        
        # Now simply pass the style hashtable to TuiBuffer.WriteString
        $Buffer.WriteString($X, $Y, $Text, $Style)
        
        # Write-Verbose "Write-TuiText: Wrote '$Text' to buffer '$($Buffer.Name)' at ($X, $Y)."
    }
    catch {
        Write-Error "Failed to write text to buffer '$($Buffer.Name)' at ($X, $Y): $($_.Exception.Message)"
        throw
    }
}
```

**Step 1.5: Unify `Write-TuiBox` (`AllFunctions.ps1`)**

*   **Locate:** The two existing `function Write-TuiBox` definitions (around lines 14 and 90).
*   **Change:** Delete *both* existing definitions. Replace them with `acta`'s single, more robust, and style-driven `Write-TuiBox`. This function uses the `[hashtable]$Style` parameter for all visual aspects.

```powershell
# In AllFunctions.ps1, replace BOTH existing Write-TuiBox functions with this:

function Write-TuiBox {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [string]$Title = "",
        [hashtable]$Style = @{} # All visual aspects now passed via Style hashtable
    )
    
    try {
        if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) {
            # Write-Warning "Write-TuiBox: Invalid dimensions ($($Width)x$($Height)). Dimensions must be positive."
            return
        }

        # Extract properties from the style object with safe fallbacks.
        # Defaults to a hex gray border and black background, as ConsoleColor will be removed.
        $borderStyleName = $Style.BorderStyle ?? "Single"
        $borderColor = $Style.BorderFG ?? "#808080"
        $bgColor = $Style.BG ?? "#000000"
        $titleColor = $Style.TitleFG ?? $borderColor # Title defaults to border color
        $fillChar = $Style.FillChar ?? ' ' # Optional fill character

        $borders = Get-TuiBorderChars -Style $borderStyleName
        
        # Define style objects for child calls to Write-TuiText.
        $cellStyle = @{ FG = $borderColor; BG = $bgColor }
        $titleTextStyle = @{ FG = $titleColor; BG = $bgColor }
        # Merge any additional title style overrides (e.g., Bold = $true for title)
        if ($Style.TitleStyle) {
            foreach ($key in $Style.TitleStyle.Keys) { $titleTextStyle[$key] = $Style.TitleStyle[$key] }
        }
        $fillCellStyle = @{ FG = $borderColor; BG = $bgColor } # Fill with border color foreground if needed

        # Fill background (use FillRect method if available, or manually)
        # Note: If TuiBuffer.FillRect expects ConsoleColor, you'll need to adapt it.
        # For now, let's adjust the manual fill or ensure FillRect is updated to use hex.
        # Assuming FillRect is updated or we do it manually with Write-TuiText.
        # A simple approach for fill if FillRect is not flexible:
        for ($py = $Y; $py -lt $Y + $Height; $py++) {
            for ($px = $X; $px -lt $X + $Width; $px++) {
                $Buffer.SetCell($px, $py, [TuiCell]::new($fillChar, $fillCellStyle.FG, $fillCellStyle.BG))
            }
        }
        
        # Top border
        Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -Style $cellStyle
        
        # Side borders and fill
        for ($i = 1; $i -lt ($Height - 1); $i++) {
            $currentY = $Y + $i
            if ($currentY -ge 0 -and $currentY -lt $Buffer.Height) {
                Write-TuiText -Buffer $Buffer -X $X -Y $currentY -Text $borders.Vertical -Style $cellStyle
                # If content area needs fill, use $fillChar (often ' ')
                if ($Width -gt 2) {
                    Write-TuiText -Buffer $Buffer -X ($X + 1) -Y $currentY -Text ($fillChar * ($Width - 2)) -Style $fillCellStyle
                }
                Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y $currentY -Text $borders.Vertical -Style $cellStyle
            }
        }
        
        # Bottom border
        if ($Height -gt 1) {
            $bottomY = $Y + $Height - 1
            Write-TuiText -Buffer $Buffer -X $X -Y $bottomY -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -Style $cellStyle
        }

        # Draw title if specified
        if (-not [string]::IsNullOrEmpty($Title) -and $Y -ge 0 -and $Y -lt $Buffer.Height) {
            $titleText = " $Title "
            if ($titleText.Length -le ($Width - 2)) { 
                $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
                Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -Style $titleTextStyle
            }
        }
        
        $Buffer.IsDirty = $true
        # Write-Verbose "Write-TuiBox: Drew '$BorderStyle' box on buffer '$($Buffer.Name)' at ($X, $Y) with dimensions $($Width)x$($Height)."
    }
    catch {
        Write-Error "Failed to draw TUI box on buffer '$($Buffer.Name)' at ($X, $Y), $($Width)x$($Height): $($_.Exception.Message)"
        throw
    }
}
```
**Step 1.6: Update `TuiBuffer.DrawBox` and `FillRect` (`AllBaseClasses.ps1`)**
*   **Locate:** `class TuiBuffer`, `DrawBox` (around line 223) and `FillRect` (around line 258).
*   **Change:** Update them to internally call the new `Write-TuiBox` and `WriteString` functions, respectively, passing a style hashtable.

```powershell
# In AllBaseClasses.ps1, inside TuiBuffer class:

# Replace DrawBox with this:
    [void] DrawBox([int]$x, [int]$y, [int]$width, [int]$height, [hashtable]$style = @{}) {
        # This will now internally call the new Write-TuiBox function
        Write-TuiBox -Buffer $this -X $x -Y $y -Width $width -Height $height -Style $style
    }

# Replace FillRect with this:
    [void] FillRect([int]$x, [int]$y, [int]$width, [int]$height, [char]$char, [hashtable]$style = @{}) {
        # Create a single character string and use WriteString to fill the rectangle
        # This simplifies the logic by leveraging WriteString's styling capabilities.
        $charString = "$char" # Convert char to string
        for ($py = $y; $py -lt $y + $height; $py++) {
            # Write a line of characters
            $this.WriteString($x, $py, $charString * $width, $style)
        }
    }
```

### 2. **Correct `ScrollablePanel` Virtual Scrolling (`AllBaseClasses.ps1`, `AllComponents.ps1`, `AllScreens.ps1`)**

This addresses:
*   **Critical Issue 3:** `ScrollablePanel` virtual scrolling incomplete.

**Step 2.1: Update `ScrollablePanel` in `AllBaseClasses.ps1` (or `AllComponents.ps1` if you split it)**

*   **Locate:** `class ScrollablePanel` (around line 1022 in `mono`).
*   **Change:**
    *   Add `_virtual_buffer` to store the full, unclipped content.
    *   Override `_RenderContent` to draw the virtual buffer onto the private buffer.
    *   Add `UpdateMaxScroll` helper method.

```powershell
# In AllBaseClasses.ps1, inside ScrollablePanel class:

class ScrollablePanel : Panel {
    [int] $ScrollOffsetY = 0
    [int] $MaxScrollY = 0
    [bool] $ShowScrollbar = $true
    hidden [int] $_contentHeight = 0 # This will be the virtual content height
    hidden [TuiBuffer] $_virtual_buffer = $null # NEW: To hold the entire scrollable content

    ScrollablePanel([string]$name) : base($name) {
        $this.IsFocusable = $true
        # Initialize _virtual_buffer with initial dimensions. Will be resized later.
        $this.{_virtual_buffer} = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Virtual")
    }

    # Override OnResize to ensure virtual buffer matches actual content size
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        ([Panel]$this).OnResize($newWidth, $newHeight) # Call base Panel resize
        # Ensure the virtual buffer is always at least the size of the new content area
        $virtualBufferWidth = [Math]::Max($newWidth, $this.{_virtual_buffer}.Width)
        $virtualBufferHeight = [Math]::Max($newHeight, $this.{_virtual_buffer}.Height)
        if ($this.{_virtual_buffer}.Width -ne $virtualBufferWidth -or $this.{_virtual_buffer}.Height -ne $virtualBufferHeight) {
            $this.{_virtual_buffer}.Resize($virtualBufferWidth, $virtualBufferHeight)
        }
        $this.UpdateMaxScroll() # Recalculate max scroll on resize
    }

    # Override _RenderContent to draw the virtual buffer onto the actual private buffer
    hidden [void] _RenderContent() {
        # 1. First, render the base Panel (draws border, clears its _private_buffer)
        ([Panel]$this)._RenderContent() # This calls Panel's OnRender and then its _RenderContent

        # 2. Render content to the _virtual_buffer by calling children's render methods
        #    This is the key change for virtual scrolling: children render to a potentially larger buffer.
        $this.{_virtual_buffer}.Clear([TuiCell]::new(' ', $this.ForegroundColor, $this.BackgroundColor))
        
        $actualContentBottom = 0
        foreach ($child in $this.Children | Sort-Object ZIndex) {
            if ($child.Visible) {
                # Render child to its own private buffer first
                $child.Render() 
                if ($null -ne $child._private_buffer) {
                    # Blend child's buffer onto our _virtual_buffer at its original coordinates
                    # (relative to the panel's content area)
                    $this.{_virtual_buffer}.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                }
                # Track the maximum extent of children to determine virtual height
                $childExtent = $child.Y + $child.Height
                if ($childExtent -gt $actualContentBottom) {
                    $actualContentBottom = $childExtent
                }
            }
        }
        $this._contentHeight = $actualContentBottom # Update actual content height

        # 3. Update MaxScrollY and ensure ScrollOffsetY is clamped
        $this.UpdateMaxScroll()

        # 4. Extract the visible portion from _virtual_buffer and blend it onto _private_buffer
        #    This accounts for the scroll offset.
        $viewportWidth = $this.ContentWidth
        $viewportHeight = $this.ContentHeight
        
        $sourceX = 0 # No horizontal scrolling for now, but easily extendable
        $sourceY = $this.ScrollOffsetY
        
        $visiblePortion = $this.{_virtual_buffer}.GetSubBuffer($sourceX, $sourceY, $viewportWidth, $viewportHeight)
        $this.{_private_buffer}.BlendBuffer($visiblePortion, $this.ContentX, $this.ContentY)

        # 5. Draw scrollbar if needed (uses _private_buffer and current ScrollOffsetY)
        if ($this.ShowScrollbar -and $this.MaxScrollY -gt 0) {
            $this.DrawScrollbar()
        }

        $this._needs_redraw = $false
    }

    # Helper method to calculate MaxScrollY and clamp ScrollOffsetY
    [void] UpdateMaxScroll() {
        $viewportHeight = $this.Height
        if ($this.HasBorder) { $viewportHeight -= 2 } # Account for border

        # Make sure virtual buffer is at least as wide as the viewable area for GetSubBuffer
        $currentVirtualWidth = $this.{_virtual_buffer}.Width
        $currentVirtualHeight = $this.{_virtual_buffer}.Height
        $newVirtualWidth = [Math]::Max($currentVirtualWidth, $this.ContentWidth)
        $newVirtualHeight = [Math]::Max($currentVirtualHeight, $this._contentHeight)

        if ($newVirtualWidth -ne $currentVirtualWidth -or $newVirtualHeight -ne $currentVirtualHeight) {
            $this.{_virtual_buffer}.Resize($newVirtualWidth, $newVirtualHeight)
        }
        
        $this.MaxScrollY = [Math]::Max(0, $this._contentHeight - $viewportHeight)
        $this.ScrollOffsetY = [Math]::Max(0, [Math]::Min($this.ScrollOffsetY, $this.MaxScrollY))
    }

    # Keep DrawScrollbar, HandleInput, ScrollUp/Down/PageUp/Down/ToTop/Bottom methods.
    # Ensure DrawScrollbar uses the correct ScrollOffsetY, MaxScrollY, and _contentHeight for calculations.
    # Update SetCell calls in DrawScrollbar to use hex colors instead of ConsoleColor.
    [void] DrawScrollbar() {
        $scrollbarX = $this.Width - 2 # Assuming border. If no border, adjust.
        $scrollbarY = if ($this.HasBorder) { 1 } else { 0 }
        $scrollbarTrackHeight = $this.Height - (if ($this.HasBorder) { 2 } else { 0 })

        if ($this._contentHeight -le $scrollbarTrackHeight) { return } # No scrollbar needed if content fits

        $scrollFg = Get-ThemeColor("list.scrollbar") # Assumes ThemeManager updated for hex colors
        $scrollBg = Get-ThemeColor("Background")

        # Calculate thumb size and position
        $thumbSize = [Math]::Max(1, [int]($scrollbarTrackHeight * $scrollbarTrackHeight / $this._contentHeight))
        # Ensure scrollbar thumb is at least 1 unit in size
        $thumbSize = [Math]::Max(1, $thumbSize)
        $thumbPos = [int](($scrollbarTrackHeight - $thumbSize) * $this.ScrollOffsetY / $this.MaxScrollY)
        
        for ($i = 0; $i -lt $scrollbarTrackHeight; $i++) {
            $y = $scrollbarY + $i
            $char = '│' # Default track character
            $fg = $scrollFg
            
            if ($i -ge $thumbPos -and $i -lt $thumbPos + $thumbSize) {
                $char = '█' # Thumb character
            }
            $this.SetCell($scrollbarX, $y, [TuiCell]::new($char, $fg, $scrollBg))
        }
    }
}
```

**Step 2.2: Update `TaskListScreen` to use `UpdateMaxScroll` (`AllScreens.ps1`)**

*   **Locate:** `TaskListScreen`, `_UpdateTaskList` method (around line 282).
*   **Change:** After populating the list (or drawing elements to the panel's buffer), call `UpdateMaxScroll()`.

```powershell
# In AllScreens.ps1, inside TaskListScreen, _UpdateTaskList method:

    hidden [void] _UpdateTaskList() {
        # ... existing code ...

        # At the end of the method, after all tasks are "rendered" (or their positions set):
        $panel.UpdateMaxScroll()
    }
```

### 3. **Streamlined Screen Stack Management & Global State (`AllRuntime.ps1`, `AllServices.ps1`)**

This addresses:
*   **Critical Issue 4:** Inconsistent Screen Stack Management & Redundancy.
*   **Minor Issue 11:** `$global:TuiState.ScreenStack` and `OverlayStack` as Plain Arrays.

**Step 3.1: Centralize Navigation in `NavigationService` (`AllServices.ps1`)**

*   **Locate:** `class NavigationService` (around line 2146).
*   **Change:**
    *   Ensure `NavigationStack` is `[System.Collections.Generic.Stack[Screen]]`.
    *   Modify `NavigateTo` and `GoBack` to directly update `$global:TuiState.CurrentScreen` and `Request-TuiRefresh` *without* calling the old `Push-Screen` / `Pop-Screen` global functions.

```powershell
# In AllServices.ps1, inside NavigationService class:

class NavigationService {
    [System.Collections.Generic.Stack[Screen]] $NavigationStack # Already correct type
    [Screen]$CurrentScreen
    [EventManager]$EventManager
    [hashtable]$ScreenRegistry = @{}
    [int]$MaxStackSize = 10
    [hashtable]$Services # Added to store access to all services for CreateScreen

    NavigationService() {
        $this.NavigationStack = [System.Collections.Generic.Stack[Screen]]::new()
    }
    
    NavigationService([EventManager]$eventManager) {
        $this.NavigationStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.EventManager = $eventManager
    }

    # Add this constructor and a ScreenFactory if you want cleaner screen creation
    NavigationService([hashtable]$services) {
        $this.Services = $services
        $this.NavigationStack = [System.Collections.Generic.Stack[Screen]]::new()
        # You would initialize a ScreenFactory here if you add it.
        # $this.ScreenFactory = [ScreenFactory]::new($services) 
    }
    
    # ... RegisterScreen, NavigateToByName, CanGoBack (keep as is) ...

    # IMPORTANT: Update NavigateTo method
    [void] NavigateTo([Screen]$screen) {
        if (-not $screen) { throw [ArgumentNullException]::new("screen") }
        
        try {
            # Exit current screen
            if ($this.CurrentScreen) {
                Write-Verbose "NavigationService: Exiting screen '$($this.CurrentScreen.Name)'"
                $this.CurrentScreen.OnExit()
                $this.NavigationStack.Push($this.CurrentScreen)
                
                # Limit stack size (if desired)
                if ($this.NavigationStack.Count -gt $this.MaxStackSize) {
                    # This trimming logic is complex for Stack. Could convert to List temporarily or just let it grow.
                    # For simplicity of this guide, let's keep it minimal if MaxStackSize is critical.
                    # A better way is to pop elements from the bottom if a List is used for the stack.
                }
            }
            
            # Enter new screen
            $this.CurrentScreen = $screen
            Write-Verbose "NavigationService: Entering screen '$($screen.Name)'"
            
            if (-not $screen._isInitialized) {
                $screen.Initialize()
                $screen._isInitialized = $true
            }
            
            $screen.OnEnter()
            
            # Publish navigation event
            if ($this.EventManager) {
                $this.EventManager.Publish("Navigation.ScreenChanged", @{
                    Screen = $screen
                    ScreenName = $screen.Name
                    StackDepth = $this.NavigationStack.Count
                })
            }
            
            # Update global TUI state directly (CRUCIAL FIX)
            $global:TuiState.CurrentScreen = $screen
            $global:TuiState.IsDirty = $true # Force redraw
            # Ensure screen is resized to console dimensions
            $screen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)

        }
        catch {
            Write-Error "NavigationService: Failed to navigate to screen '$($screen.Name)': $_"
            throw [NavigationException]::new(
                "Failed to navigate to screen '$($screen.Name)'",
                "NavigationService",
                @{ ScreenName = $screen.Name },
                $_
            )
        }
    }

    # IMPORTANT: Update GoBack method
    [void] GoBack() {
        if (-not $this.CanGoBack()) {
            Write-Warning "NavigationService: Cannot go back - navigation stack is empty"
            return
        }
        
        try {
            # Exit current screen
            if ($this.CurrentScreen) {
                Write-Verbose "NavigationService: Exiting screen '$($this.CurrentScreen.Name)' (going back)"
                $this.CurrentScreen.OnExit()
            }
            
            # Pop and resume previous screen
            $previousScreen = $this.NavigationStack.Pop()
            $this.CurrentScreen = $previousScreen
            
            Write-Verbose "NavigationService: Resuming screen '$($previousScreen.Name)'"
            $previousScreen.OnResume()
            
            # Publish navigation event
            if ($this.EventManager) {
                $this.EventManager.Publish("Navigation.BackNavigation", @{
                    Screen = $previousScreen
                    ScreenName = $previousScreen.Name
                    StackDepth = $this.NavigationStack.Count
                })
            }
            
            # Update global TUI state directly (CRUCIAL FIX)
            $global:TuiState.CurrentScreen = $previousScreen
            $global:TuiState.IsDirty = $true # Force redraw
            # Ensure screen is resized to console dimensions
            $previousScreen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)

        }
        catch {
            Write-Error "NavigationService: Failed to go back: $_"
            throw [NavigationException]::new(
                "Failed to navigate back",
                "NavigationService",
                @{ StackDepth = $this.NavigationStack.Count },
                $_
            )
        }
    }

    # Remove Reset method if it's no longer necessary or integrate into Cleanup elsewhere.
    # The `acta` version handles cleanup by having UIElement/Screen implement a `Cleanup` method.
    # This leads to the next major upgrade.
}
```

**Step 3.2: Remove Redundant Screen Functions (`AllRuntime.ps1`)**

*   **Locate:** `function Push-Screen`, `function Pop-Screen`, `function Switch-Screen` (around lines 525, 560, 600).
*   **Change:** **Delete these functions entirely.** All screen navigation should now go through `NavigationService`.

**Step 3.3: Update `$global:TuiState` for Correct Collection Types (`AllRuntime.ps1`)**

*   **Locate:** `$global:TuiState = @{...}` (around line 14).
*   **Change:** Update `ScreenStack` and `OverlayStack` to use `System.Collections.Generic.Stack` and `System.Collections.Generic.List` as intended.

```powershell
# In AllRuntime.ps1, at the top, update global:TuiState
$global:TuiState = @{
    Running = $false
    BufferWidth = 0
    BufferHeight = 0
    CompositorBuffer = $null
    PreviousCompositorBuffer = $null
    ScreenStack = [System.Collections.Generic.Stack[Screen]]::new() # CHANGED TO GENERIC STACK
    CurrentScreen = $null
    IsDirty = $true
    FocusedComponent = $null
    CommandPalette = $null
    Services = @{}
    LastRenderTime = [datetime]::Now
    FrameCount = 0
    InputQueue = New-Object 'System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]'
    OverlayStack = [System.Collections.Generic.List[UIElement]]::new() # CHANGED TO GENERIC LIST
}
```

**Step 3.4: Update `Start-AxiomPhoenix` to use `NavigationService` (`AllRuntime.ps1`)**

*   **Locate:** `function Start-AxiomPhoenix` (around line 700).
*   **Change:** Remove the `Push-Screen` call and instead use the `NavigationService`.

```powershell
# In AllRuntime.ps1, inside Start-AxiomPhoenix:

    try {
        Write-Verbose "Starting Axiom-Phoenix application..."
        
        # ... existing service setup ...

        # Remove this block if it exists (it's redundant with NavigationService now)
        # if ($null -eq $global:TuiState.ScreenStack) {
        #     $global:TuiState.ScreenStack = @()
        # }
        
        # Locate the NavigationService
        $navService = $ServiceContainer.GetService("NavigationService")

        # Set initial screen using NavigationService (CRUCIAL FIX)
        if ($InitialScreen) {
            $navService.NavigateTo($InitialScreen) # Use the service directly
        }
        else {
            Write-Warning "No initial screen provided. Application might not display anything."
        }
        
        # Start main loop
        Start-TuiEngine
    }
    # ... existing catch block ...
```

### 4. **Robust Component Cleanup (`AllBaseClasses.ps1`, `AllRuntime.ps1`, `AllServices.ps1`)**

This addresses:
*   `Pop-Screen` not cleaning up resources.

**Step 4.1: Add Base Cleanup to `UIElement` (`AllBaseClasses.ps1`)**

*   **Locate:** `class UIElement` (around line 335).
*   **Change:** Add a virtual `Cleanup` method that cascades to children, and a virtual `OnCleanup` for custom logic.

```powershell
# In AllBaseClasses.ps1, inside UIElement class:

# Add these virtual methods
    [void] OnResize([int]$newWidth, [int]$newHeight) { /* Override in subclasses */ }
    [void] OnCleanup() { /* Override in subclasses to release resources, unsubscribe events, etc. */ }

# Add the Cleanup method
    [void] Cleanup() {
        # Call the specific cleanup logic for this component first.
        $this.OnCleanup()
        # Then, cascade the cleanup call to all children.
        foreach ($child in $this.Children) {
            try {
                $child.Cleanup()
            } catch {
                Write-Warning "UIElement Cleanup: Error cleaning up child '$($child.Name)': $($_.Exception.Message)"
            }
        }
        $this.Children.Clear() # Clear the child list
        # Remove reference to private buffer to allow garbage collection
        $this._private_buffer = $null 
    }
```

**Step 4.2: Update `Screen.Cleanup` (`AllBaseClasses.ps1`)**

*   **Locate:** `class Screen`, `Cleanup` method (around line 656).
*   **Change:** Ensure it calls `base.Cleanup()` (which will trigger the cascading cleanup for children).

```powershell
# In AllBaseClasses.ps1, inside Screen class, Cleanup method:

    [void] Cleanup() {
        try {
            # Call base UIElement cleanup to handle child cleanup automatically
            ([UIElement]$this).Cleanup() 

            # Unsubscribe screen-specific events
            foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
                try {
                    # Note: HandlerId is the value in $kvp.Value
                    if (Get-Command 'Unsubscribe-Event' -ErrorAction SilentlyContinue) {
                        Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value
                        # Write-Verbose "Unsubscribed event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)'."
                    }
                }
                catch {
                    Write-Warning "Failed to unsubscribe event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)': $($_.Exception.Message)"
                }
            }
            $this.EventSubscriptions.Clear()
            $this.Panels.Clear() # Clear panel list, as children are already cleaned by base.Cleanup()
            # Write-Verbose "Cleaned up resources for screen: $($this.Name)."
        }
        catch {
            Write-Error "Error during Cleanup for screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }
```

**Step 4.3: Update `Pop-Screen` (`AllRuntime.ps1`)**

*   **Locate:** `function Pop-Screen` (around line 560).
*   **Change:** Ensure it explicitly calls `Cleanup()` on the screen being popped.

```powershell
# In AllRuntime.ps1, inside Pop-Screen (if you didn't delete it in Step 3.2, you should delete it.)
# If you keep it as a wrapper (which is less ideal), ensure it calls .Cleanup() on the screen before popping.
# Example if you chose to keep `Pop-Screen` as a wrapper around `NavigationService.GoBack`:

function Pop-Screen {
    [CmdletBinding()]
    param()
    
    try {
        $navService = $global:TuiState.Services.NavigationService # Get NavigationService
        if ($navService) {
            if ($global:TuiState.CurrentScreen) {
                # This ensures cleanup even if navigation service doesn't manage it directly
                $global:TuiState.CurrentScreen.Cleanup() 
            }
            return $navService.GoBack() # Let NavigationService handle the pop logic
        } else {
            Write-Warning "NavigationService not available to pop screen."
            return $false
        }
    }
    catch {
        Write-Error "Failed to pop screen (via wrapper): $_"
        throw
    }
}
```

### 5. **Centralized Focus Management (`AllRuntime.ps1`, `AllBaseClasses.ps1`, `AllComponents.ps1`)**

This addresses:
*   **Major Issue 5:** `TextBox.Focus()` uses undeclared `_focusManager`.

**Step 5.1: Remove `_focusManager` assumption from Components (`AllComponents.ps1`)**

*   **Locate:** `TextBox` class, `Focus` method (around line 1221).
*   **Change:** Modify to directly call the global `Set-ComponentFocus` function, or ideally, have a `FocusManager` service. For now, rely on `Set-ComponentFocus`.

```powershell
# In AllComponents.ps1, inside TextBox class, Focus method:

    [void] Focus() {
        # Changed to call global Set-ComponentFocus directly
        Set-ComponentFocus -Component $this 
    }
```
*   **Review other components:** Ensure no other components make similar assumptions about a `_focusManager` property on their parent. `acta`'s approach moves this logic into the engine's `Set-ComponentFocus` and `Move-Focus` functions.

**Step 5.2: Ensure `Set-ComponentFocus` and `Move-Focus` are robust (`AllFunctions.ps1` or `AllRuntime.ps1`)**

*   **Locate:** `function Set-ComponentFocus` (around line 187).
*   **Change:** It should directly manage `global:TuiState.FocusedComponent`. `acta` moves `Set-ComponentFocus` and `Move-Focus` into `modules\tui-engine\tui-engine.psm1`, which is a better place for runtime-level functions.

```powershell
# If Set-ComponentFocus and Move-Focus are in AllFunctions.ps1:
# In AllFunctions.ps1, update Set-ComponentFocus and Move-Focus

function Set-ComponentFocus { 
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][UIElement]$Component
    )
    if ($null -eq $Component -or (-not $Component.Enabled)) { 
        # Optionally, if setting to null, blur current focus
        $global:TuiState.FocusedComponent?.OnBlur()
        $global:TuiState.FocusedComponent = $null
        Request-Redraw # Global redraw
        return 
    }
    
    $global:TuiState.FocusedComponent?.OnBlur() # Blur the previously focused component
    $global:TuiState.FocusedComponent = $Component # Set new focused component
    $Component.OnFocus() # Call OnFocus on the new component
    
    $Component.RequestRedraw() # Request redraw for the component to show focus state
    # Also request redraw for the old focused component if it changed visual state.
    # The differential renderer should handle this automatically.

    Write-Verbose "Set focus to component: $($Component.Name)"
}

function Get-NextFocusableComponent { 
    [CmdletBinding()]
    param([UIElement]$CurrentComponent, [bool]$Reverse = $false)
    if (-not $global:TuiState.CurrentScreen) { return $null }
    
    $focusableComponents = [System.Collections.Generic.List[UIElement]]::new()
    
    # Helper to recursively find all focusable components
    function Find-Focusable([UIElement]$Comp) {
        if ($Comp.IsFocusable -and $Comp.Visible -and $Comp.Enabled) {
            $focusableComponents.Add($Comp)
        }
        foreach ($child in $Comp.Children) { Find-Focusable $child }
    }
    
    Find-Focusable $global:TuiState.CurrentScreen
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort components by TabIndex, then Y, then X for consistent order
    $sorted = $focusableComponents | Sort-Object { $_.TabIndex * 10000 + $_.Y * 100 + $_.X }
    
    if ($Reverse) { [Array]::Reverse($sorted.ToArray()) } # Use ToArray() before Reverse for List
    
    $currentIndex = -1
    if ($CurrentComponent) {
        for ($i = 0; $i -lt $sorted.Count; $i++) {
            if ($sorted[$i] -eq $CurrentComponent) {
                $currentIndex = $i
                break
            }
        }
    }
    
    if ($currentIndex -ge 0) { 
        return $sorted[($currentIndex + 1) % $sorted.Count] 
    } else { 
        # If no current component, or not found, return the first focusable (or last if reverse)
        return $sorted[0] 
    } 
}

function Move-Focus { 
    [CmdletBinding()]
    param([bool]$Reverse = $false)
    $next = Get-NextFocusableComponent -CurrentComponent $global:TuiState.FocusedComponent -Reverse $Reverse
    if ($next) { 
        Set-ComponentFocus -Component $next 
    } else {
        # If no next focusable component, try to set focus to the first one in the list
        $first = Get-NextFocusableComponent -CurrentComponent $null # Get the very first focusable
        if ($first) { Set-ComponentFocus -Component $first }
    }
}
```

### 6. **Robust `DataManager` JSON Deserialization (`AllServices.ps1`)**

This addresses:
*   **Major Issue 6:** `DataManager` fragile JSON deserialization.

**Step 6.1: Add `try/catch` around individual record deserialization in `DataManager.LoadData`**

*   **Locate:** `class DataManager`, `LoadData` method (around line 2055).
*   **Change:** Wrap the `foreach` loops that iterate over `$loadedData.Tasks`, `$loadedData.Projects`, etc., with `try/catch` blocks for each individual record. Also ensure proper type casting (e.g., `[datetime]::Parse`).

```powershell
# In AllServices.ps1, inside DataManager class, LoadData method:

    hidden [void] LoadData() {
        try {
            if (Test-Path $this.DataPath) {
                $jsonContent = Get-Content -Path $this.DataPath -Raw
                $data = $jsonContent | ConvertFrom-Json -AsHashtable
                
                $this.Tasks.Clear()
                $this.TasksByProject.Clear()
                
                if ($data.ContainsKey('Tasks')) {
                    # --- NEW ROBUSTNESS FOR TASKS ---
                    foreach ($taskData in $data.Tasks) {
                        try {
                            # Add checks if taskData is correct type for casting
                            if ($taskData -isnot [hashtable] -or -not $taskData.ContainsKey('Title')) {
                                throw "Invalid or incomplete task record."
                            }
                            # Use PmcTask's FromLegacyFormat if available, or map properties with checks
                            $task = [PmcTask]::new() # Start with a new instance
                            $task.Id = $taskData.Id ?? [Guid]::NewGuid().ToString()
                            $task.Title = $taskData.Title
                            $task.Description = $taskData.Description
                            $task.Status = if ($taskData.Status) { [TaskStatus]::$($taskData.Status) } else { [TaskStatus]::Pending }
                            $task.Priority = if ($taskData.Priority) { [TaskPriority]::$($taskData.Priority) } else { [TaskPriority]::Medium }
                            $task.ProjectKey = $taskData.ProjectKey ?? $taskData.Category ?? "General"
                            $task.Category = $task.ProjectKey
                            $task.CreatedAt = if ($taskData.CreatedAt) { [datetime]::Parse($taskData.CreatedAt) } else { [datetime]::Now }
                            $task.UpdatedAt = if ($taskData.UpdatedAt) { [datetime]::Parse($taskData.UpdatedAt) } else { [datetime]::Now }
                            $task.DueDate = if ($taskData.DueDate -and $taskData.DueDate -ne "N/A") { try{[datetime]::Parse($taskData.DueDate)}catch{$null} } else {$null}
                            $task.Tags = $taskData.Tags ?? @()
                            $task.Progress = $taskData.Progress ?? 0
                            $task.Completed = $taskData.Completed ?? $false
                            
                            $this.Tasks[$task.Id] = $task
                            if (-not $this.TasksByProject.ContainsKey($task.ProjectKey)) {
                                $this.TasksByProject[$task.ProjectKey] = @()
                            }
                            $this.TasksByProject[$task.ProjectKey] += $task.Id
                        } catch {
                            Write-Warning "DataManager: Skipping corrupted or invalid task record: $($_.Exception.Message)"
                        }
                    }
                    # --- END NEW ROBUSTNESS FOR TASKS ---
                }
                
                $this.Projects.Clear()
                if ($data.ContainsKey('Projects')) {
                    # --- NEW ROBUSTNESS FOR PROJECTS ---
                    foreach ($projectData in $data.Projects) {
                        try {
                            if ($projectData -isnot [hashtable] -or -not $projectData.ContainsKey('Key')) {
                                throw "Invalid or incomplete project record."
                            }
                            # Similar detailed mapping as for Tasks, using PmcProject constructor/properties
                            $project = [PmcProject]::new()
                            $project.Key = $projectData.Key
                            $project.Name = $projectData.Name
                            $project.Description = $projectData.Description
                            $project.CreatedAt = if ($projectData.CreatedAt) { [datetime]::Parse($projectData.CreatedAt) } else { [datetime]::Now }
                            $project.UpdatedAt = if ($projectData.UpdatedAt) { [datetime]::Parse($projectData.UpdatedAt) } else { [datetime]::Now }
                            $project.Owner = $projectData.Owner
                            $project.Tags = $projectData.Tags ?? @()
                            $project.Metadata = $projectData.Metadata ?? @{}
                            $project.IsActive = $projectData.IsActive ?? $true
                            
                            $this.Projects[$project.Key] = $project
                        } catch {
                            Write-Warning "DataManager: Skipping corrupted or invalid project record: $($_.Exception.Message)"
                        }
                    }
                    # --- END NEW ROBUSTNESS FOR PROJECTS ---
                }
                
                if ($data.ContainsKey('Metadata')) {
                    $this.Metadata = $data.Metadata
                }
                
                $this.IsDirty = $false
                # Write-Verbose "DataManager: Loaded $($this.Tasks.Count) tasks and $($this.Projects.Count) projects"
                
                if ($this.EventManager) {
                    $this.EventManager.Publish("Data.Loaded", @{
                        TaskCount = $this.Tasks.Count
                        ProjectCount = $this.Projects.Count
                    })
                }
            }
            else {
                # Write-Verbose "DataManager: No data file found at $($this.DataPath)"
            }
        }
        catch {
            Write-Error "Failed to load data from $($this.DataPath): $_"
            throw [DataLoadException]::new("Failed to load data from $($this.DataPath)", "DataManager", @{}, $_)
        }
    }
```

---

## General Quality of Life & Feature Upgrades

These improvements enhance the framework's robustness, performance, and overall developer experience.

### 7. **Standardized Exception Handling & Enhanced Logging (`AllModels.ps1`, `AllServices.ps1`, `AllRuntime.ps1`, throughout)**

Leverage `acta`'s structured error handling.

**Step 7.1: Define Custom Exception Types (`AllModels.ps1`)**

*   **Locate:** `region Exception Classes` (around line 720).
*   **Change:** Replace the existing simple class definitions with `acta`'s `Add-Type` block for more detailed custom exceptions.

```powershell
# In AllModels.ps1, replace `region Exception Classes` with:

#region Exception Classes
try {
    if (-not ('Helios.HeliosException' -as [type])) { # Check to avoid re-compilation on re-runs
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException) {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
    }
} catch {
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). Application will use generic exceptions."
}
#endregion
```

**Step 7.2: Implement `Invoke-WithErrorHandling` (`AllFunctions.ps1`)**

*   **Locate:** `function Write-Log` (around line 206).
*   **Change:** Add `Invoke-WithErrorHandling` near `Write-Log`. This centralizes error logging and re-throwing of structured exceptions. You'll need to adapt `_Identify-HeliosComponent` and `_Get-DetailedError` helpers as well.

```powershell
# In AllFunctions.ps1, somewhere before functions that use it (e.g. after Get-TuiBorderChars)

# Script-scoped variables for error history (like in acta's exceptions.psm1)
$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100

function _Identify-HeliosComponent {
    param([System.Management.Automation.ErrorRecord]$ErrorRecord)
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName ?? (Get-PSCallStack | Where-Object ScriptName | Select-Object -First 1).ScriptName
        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        # Adapt this map based on your mono's file organization
        $componentMap = @{
            'AllBaseClasses' = 'BaseClasses'; 'AllModels' = 'Models'; 'AllComponents' = 'UIComponents'
            'AllScreens' = 'Screens'; 'AllFunctions' = 'Functions'; 'AllServices' = 'Services'
            'AllRuntime' = 'Runtime'; 'Start' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") { return $componentMap[$pattern] }
        }
        return "Unknown ($fileName)"
    } catch { return "Component Identification Failed" }
}

function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp = Get-Date -Format "o"; Summary = $ErrorRecord.Exception.Message; Type = $ErrorRecord.Exception.GetType().FullName
            Category = $ErrorRecord.CategoryInfo.Category.ToString(); TargetObject = $ErrorRecord.TargetObject
            ScriptName = $ErrorRecord.InvocationInfo.ScriptName; LineNumber = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line = $ErrorRecord.InvocationInfo.Line; PositionMessage = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace = $ErrorRecord.Exception.StackTrace; InnerExceptions = @(); AdditionalContext = $AdditionalContext
            SystemContext = @{
                ProcessId = $PID; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{ Message = $innerEx.Message; Type = $innerEx.GetType().FullName; StackTrace = $innerEx.StackTrace }
            $innerEx = $innerEx.InnerException
        }
        return $errorInfo
    } catch {
        return [PSCustomObject]@{ Timestamp = Get-Date -Format "o"; Summary = "CRITICAL: Error analysis failed."; OriginalError = $ErrorRecord.Exception.Message; AnalysisError = $_.Exception.Message; Type = "ErrorAnalysisFailure" }
    }
}

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$Component,
        [Parameter(Mandatory)] [string]$Context,
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [hashtable]$AdditionalData = @{}
    )

    if (-not $ScriptBlock) { throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null." }
    $Component = [string]::IsNullOrWhiteSpace($Component) ? "Unknown Component" : $Component
    $Context = [string]::IsNullOrWhiteSpace($Context) ? "Unknown Operation" : $Context

    try {
        return (& $ScriptBlock)
    }
    catch {
        $originalErrorRecord = $_
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = ($Component -ne "Unknown Component") ? $Component : $identifiedComponent

        $errorContext = @{ Operation = $Context }
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        # Use the Logger service if available, otherwise fallback to Write-Error
        if ($global:TuiState -and $global:TuiState.Services.Logger) {
            $global:TuiState.Services.Logger.Log("Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)", "Error", $detailedError)
        } else {
            Write-Error "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)"
            Write-Error "Details: $($detailedError | ConvertTo-Json -Compress)"
        }

        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) { $script:ErrorHistory.RemoveAt(0) }

        $contextHashtable = @{
            Operation = $Context; Timestamp = $detailedError.Timestamp; LineNumber = $detailedError.LineNumber
            ScriptName = $detailedError.ScriptName ?? "Unknown"
        }
        
        foreach ($key in $AdditionalData.Keys) {
            $value = $AdditionalData[$key]
            # Only include simple types in the HeliosException context
            if ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) { $contextHashtable[$key] = $value }
        }
        
        # Throw the custom Helios exception
        $heliosException = New-Object Helios.HeliosException($originalErrorRecord.Exception.Message, $finalComponent, $contextHashtable, $originalErrorRecord.Exception)
        throw $heliosException
    }
}
```

**Step 7.3: Replace Direct `Write-Verbose` and `Write-Warning` with `Write-Log` calls**

*   **Locate:** Throughout `AllBaseClasses.ps1`, `AllComponents.ps1`, `AllScreens.ps1`, `AllFunctions.ps1`, `AllServices.ps1`, `AllRuntime.ps1`.
*   **Change:**
    *   **Replace most `Write-Verbose` calls with:** `Write-Log -Level Debug -Message "Your message"` (assuming `Logger` is initialized).
    *   **Replace some `Write-Warning` calls with:** `Write-Log -Level Warning -Message "Your message"`.
    *   **Example (in `TuiBuffer` constructor):**
        ```powershell
        # Old: # Write-Verbose "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
        # New:
        if ($global:TuiState -and $global:TuiState.Services.Logger) {
            $global:TuiState.Services.Logger.Log("TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height).", "Debug")
        }
        ```
        This is a tedious but important step. For simplicity in `mono`, you might consider directly calling `Write-Log -Level Debug` and removing the `if ($global:TuiState.Services.Logger)` check, as the `Write-Log` function itself should handle whether the logger is initialized.

**Step 7.4: Update `Invoke-PanicHandler` (`AllRuntime.ps1`)**

*   **Locate:** `function Invoke-PanicHandler` (around line 635).
*   **Change:** Adapt it to work with the new `HeliosException` and `Logger` service.

```powershell
# In AllRuntime.ps1, inside Invoke-PanicHandler:

function Invoke-PanicHandler {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [object]$Error # This will be an ErrorRecord, potentially wrapping a HeliosException
    )
    
    try {
        # Attempt to log with the full logger first
        $logger = $global:TuiState.Services.Logger
        if ($logger) {
            $logger.LogException($Error.Exception, "A fatal application error occurred. Triggering Panic Handler.")
            $logger.Flush() # Ensure logs are written before crashing
        }

        Write-Host "`n`n=== AXIOM-PHOENIX PANIC HANDLER ===" -ForegroundColor Red
        Write-Host "A critical error has occurred and the application must shut down!" -ForegroundColor Red
        Write-Host ""
        
        # Extract original exception from ErrorRecord
        $originalException = $Error.Exception
        $heliosException = $originalException -as [Helios.HeliosException]

        Write-Host "Error Message:" -ForegroundColor Yellow
        Write-Host "  $($originalException.Message)" -ForegroundColor White
        Write-Host ""
        
        Write-Host "Error Type:" -ForegroundColor Yellow
        Write-Host "  $($originalException.GetType().FullName)" -ForegroundColor White
        Write-Host ""
        
        if ($heliosException) {
            Write-Host "Component: $($heliosException.Component)" -ForegroundColor Yellow
            Write-Host "Operation Context: $($heliosException.DetailedContext.Operation)" -ForegroundColor White
            if ($heliosException.DetailedContext.Count -gt 1) {
                Write-Host "Additional Context:" -ForegroundColor Yellow
                $heliosException.DetailedContext.GetEnumerator() | Where-Object { $_.Name -ne 'Operation' } | ForEach-Object {
                    Write-Host "  $($_.Name): $($_.Value)" -ForegroundColor Gray
                }
            }
            Write-Host ""
        }

        Write-Host "Script Stack Trace:" -ForegroundColor Yellow
        $Error.ScriptStackTrace -split "`n" | ForEach-Object {
            Write-Host "  $_" -ForegroundColor Gray
        }
        Write-Host ""
        
        Write-Host "Managed Stack Trace:" -ForegroundColor Yellow
        $originalException.StackTrace -split "`n" | ForEach-Object {
            Write-Host "  $_" -ForegroundColor DarkGray
        }
        Write-Host ""

        # System info
        Write-Host "System Information:" -ForegroundColor Yellow
        Write-Host "  PowerShell: $($PSVersionTable.PSVersion)" -ForegroundColor Gray
        Write-Host "  OS: $([System.Environment]::OSVersion.VersionString)" -ForegroundColor Gray
        Write-Host "  Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" -ForegroundColor Gray
        Write-Host ""
        
        # Crash report location
        $crashReportPath = Join-Path $env:TEMP "axiom-phoenix-crash-$(Get-Date -Format 'yyyyMMdd-HHmmss').txt"
        
        $crashReport = @"
AXIOM-PHOENIX CRASH REPORT
Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')

ERROR DETAILS:
$($Error | Out-String)

$(if ($heliosException) {"HELIOS EXCEPTION DETAILS:
  Component: $($heliosException.Component)
  Operation: $($heliosException.DetailedContext.Operation)
  Full Context: $($heliosException.DetailedContext | ConvertTo-Json -Depth 3)
"})

SYSTEM INFORMATION:
PowerShell Version: $($PSVersionTable.PSVersion)
OS Version: $([System.Environment]::OSVersion.VersionString)
CLR Version: $($PSVersionTable.CLRVersion)
Host: $($Host.Name)

GLOBAL STATE (partial):
$($global:TuiState | ConvertTo-Json -Depth 3)
"@
        
        $crashReport | Out-File -FilePath $crashReportPath -Force
        
        Write-Host "Crash report saved to:" -ForegroundColor Yellow
        Write-Host "  $crashReportPath" -ForegroundColor Cyan
        Write-Host ""
        
        Write-Host "Press any key to exit..." -ForegroundColor White
        [Console]::ReadKey($true) | Out-Null
    }
    catch {
        Write-Host "FATAL: Panic handler failed! Cannot recover application state." -ForegroundColor Magenta
        Write-Host $_.Exception.Message -ForegroundColor Red
    }
    finally {
        # Try to restore console
        try {
            [Console]::CursorVisible = $true
            [Console]::Clear()
            [Console]::ResetColor()
            [Console]::SetCursorPosition(0, 0)
        }
        catch {}
        
        # Exit application
        exit 1
    }
}
```

### 8. **Non-Blocking Input Thread (`AllRuntime.ps1`)**

This improves UI responsiveness.

**Step 8.1: Implement Input Thread Initialization (`AllRuntime.ps1`)**

*   **Locate:** `function Initialize-TuiEngine` (around line 14).
*   **Change:** Add `Initialize-InputThread` call.

```powershell
# In AllRuntime.ps1, inside Initialize-TuiEngine:

function Initialize-TuiEngine {
    [CmdletBinding()]
    param()
    
    try {
        Write-Log -Level Info -Message "Initializing TUI Engine..." # Use Write-Log
        
        # ... existing code ...
        
        # Add Input Thread Initialization
        Initialize-InputThread

        # Write-Verbose "TUI Engine initialized with buffer size: $($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight)"
        Write-Log -Level Info -Message "TUI Engine initialized with buffer size: $($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight)" # Use Write-Log
    }
    catch {
        Write-Error "Failed to initialize TUI engine: $_"
        throw
    }
}
```

**Step 8.2: Add Input Thread Functions (`AllRuntime.ps1`)**

*   **Locate:** After `Process-TuiInput` (around line 430).
*   **Change:** Add `Initialize-InputThread`, and modify `Process-TuiInput` to just dequeue keys.

```powershell
# In AllRuntime.ps1, after Process-TuiInput:

function Initialize-InputThread {
    try {
        $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
        $token = $global:TuiState.CancellationTokenSource.Token

        $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
        $runspace.Open()
        # Pass the input queue and cancellation token to the runspace
        $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
        $runspace.SessionStateProxy.SetVariable('token', $token)
        
        $ps = [System.Management.Automation.PowerShell]::Create()
        $ps.Runspace = $runspace
        
        $ps.AddScript({
            try {
                # Continuously poll for keys until cancellation is requested
                while (-not $token.IsCancellationRequested) {
                    if ([Console]::KeyAvailable) {
                        # Avoid unbounded growth of queue
                        if ($InputQueue.Count -lt 100) { 
                            $InputQueue.Enqueue([Console]::ReadKey($true)) 
                        }
                    } else {
                        Start-Sleep -Milliseconds 20 # Small delay to prevent busy-looping
                    }
                }
            }
            catch [System.Management.Automation.PipelineStoppedException] { 
                # This exception is expected when EndInvoke is called
                return 
            }
            catch { 
                # Log any unexpected errors in the input thread
                Write-Warning "Input thread error: $_" 
            }
        }) | Out-Null # Suppress job output
        
        $global:TuiState.InputRunspace = $runspace
        $global:TuiState.InputPowerShell = $ps
        $global:TuiState.InputAsyncResult = $ps.BeginInvoke() # Start the thread
        Write-Log -Level Debug -Message "Input thread initialized."
    } catch {
        Write-Error "Failed to initialize input thread: $_"
        throw
    }
}

# Update Process-TuiInput to dequeue and pass to a new Process-SingleKeyInput
# In AllRuntime.ps1, replace existing Process-TuiInput:
function Process-TuiInput {
    [CmdletBinding()]
    param()
    
    $processedAny = $false
    $keyInfo = $null # Declare outside loop
    
    while ($global:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            # Process each key individually with robust error handling
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            # If a critical input error occurs, forcing a refresh might recover
            $global:TuiState.IsDirty = $true
        }
    }
    return $processedAny
}

# New function to process a single key input based on priority
function Process-SingleKeyInput {
    param($keyInfo)
    
    # NEW: Check for global command palette keybind (Ctrl+P) at the highest priority.
    # This requires CommandPalette class to be present.
    if ($keyInfo.Key -eq [ConsoleKey]::P -and ($keyInfo.Modifiers -band [ConsoleModifiers]::Control)) {
        if ($global:TuiState.CommandPalette) {
            $global:TuiState.CommandPalette.Show()
            $global:TuiState.IsDirty = $true
            return # Input is handled.
        }
    }

    # If there's an active overlay (like a dialog), give it priority.
    if ($global:TuiState.OverlayStack.Count -gt 0) {
        $overlay = $global:TuiState.OverlayStack[-1] # Peek at the top overlay
        if ($overlay.HandleInput($keyInfo)) {
            $global:TuiState.IsDirty = $true
            return # Input handled by overlay.
        }
    }

    # Handle Tab for focus navigation (now globally managed)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        $global:TuiState.IsDirty = $true
        return
    }

    # Give the currently focused component a chance to handle the input.
    $focusedComponent = $global:TuiState.FocusedComponent
    if ($focusedComponent -and $focusedComponent.HandleInput($keyInfo)) {
        $global:TuiState.IsDirty = $true
        return
    }

    # Finally, give the current screen a chance to handle the input.
    if ($global:TuiState.CurrentScreen -and $global:TuiState.CurrentScreen.HandleInput($keyInfo)) {
        $global:TuiState.IsDirty = $true
        return
    }
    
    # If not handled, try to resolve via KeybindingService (global hotkeys)
    if ($global:TuiState.Services.KeybindingService) {
        $action = $global:TuiState.Services.KeybindingService.GetAction($keyInfo)
        if ($action) {
            # Execute action via ActionService
            if ($global:TuiState.Services.ActionService) {
                try {
                    $global:TuiState.Services.ActionService.ExecuteAction($action)
                    $global:TuiState.IsDirty = $true
                    return
                } catch {
                    Write-Log -Level Warning -Message "Failed to execute action '$action' via keybinding: $($_.Exception.Message)"
                }
            }
        }
    }
}
```

**Step 8.3: Update `Cleanup-TuiEngine` (`AllRuntime.ps1`)**

*   **Locate:** `function Cleanup-TuiEngine` (around line 500).
*   **Change:** Add cleanup for the input thread.

```powershell
# In AllRuntime.ps1, inside Cleanup-TuiEngine:

function Cleanup-TuiEngine {
    try {
        # Stop and dispose input thread resources
        $global:TuiState.CancellationTokenSource?.Cancel()
        $global:TuiState.InputPowerShell?.EndInvoke($global:TuiState.InputAsyncResult) # Blocks until thread finishes
        $global:TuiState.InputPowerShell?.Dispose()
        $global:TuiState.InputRunspace?.Dispose()
        $global:TuiState.CancellationTokenSource?.Dispose()
        Write-Log -Level Info -Message "Input thread stopped and disposed."

        # Stop any TuiAsyncJobs (if you implement that module)
        # Stop-AllTuiAsyncJobs 
        
        # Unsubscribe TuiEngine's own event handlers
        # This assumes TuiEngine subscribes to TUI.RefreshRequested.
        # Find its HandlerId if it subscribes and unsubscribe. For now, empty.
        # foreach ($handlerId in $global:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        # $global:TuiState.EventHandlers.Clear()
        
        # Restore console state
        if ($Host.Name -ne 'Visual Studio Code Host') { # Avoid resetting VS Code's integrated terminal
            [Console]::Write("`e[0m"); # Reset SGR attributes
            [Console]::CursorVisible = $true; # Show cursor
            [Console]::Clear(); # Clear screen
            [Console]::ResetColor() # Reset colors
            [Console]::SetCursorPosition(0,0) # Move cursor to top-left
        }
        Write-Log -Level Info -Message "TUI Engine cleanup complete."
    } catch { 
        Write-Warning "A secondary error occurred during TUI cleanup: $_" 
        Write-Log -Level Error -Message "Error during TUI Engine cleanup: $_"
    }
}
```

### 9. **Dynamic Window Resize Detection (`AllRuntime.ps1`)**

**Step 9.1: Modify `Start-TuiEngine` Loop (`AllRuntime.ps1`)**

*   **Locate:** `function Start-TuiEngine` (around line 430), the `while ($global:TuiState.Running)` loop.
*   **Change:** Add the resize detection logic.

```powershell
# In AllRuntime.ps1, inside Start-TuiEngine, within the while loop:

    while ($global:TuiState.Running) {
        $frameTimer.Restart()
        
        # --- NEW: Window Resize Detection ---
        $consoleWidth = [Console]::WindowWidth
        $consoleHeight = [Console]::WindowHeight - 1 # Adjust if you want the bottom row for status.
        if (($consoleWidth -ne $global:TuiState.BufferWidth -or $consoleHeight -ne $global:TuiState.BufferHeight) -and $consoleWidth -gt 0 -and $consoleHeight -gt 0) {
            Write-Log -Level Info -Message "Window resized to $($consoleWidth)x$($consoleHeight)."
            # Update global state and core buffers
            $global:TuiState.BufferWidth = $consoleWidth
            $global:TuiState.BufferHeight = $consoleHeight
            $global:TuiState.CompositorBuffer.Resize($consoleWidth, $consoleHeight)
            $global:TuiState.PreviousCompositorBuffer.Resize($consoleWidth, $consoleHeight)
            # Cascade the resize call down the entire UI tree, starting with the screen.
            $global:TuiState.CurrentScreen?.Resize($consoleWidth, $consoleHeight)
            # Force a full, non-differential render to repaint everything correctly.
            $global:TuiState.FrameCount = 1 # Forces a full re-render (hacky way, a dedicated flag is better)
            $global:TuiState.IsDirty = $true # Ensure a redraw
            [Console]::Clear() # Clear screen after resize to prevent artifacts
        }
        # --- END NEW ---
        
        # Process input
        $inputProcessed = Process-TuiInput # Capture if input was processed
        
        # Render if dirty or input was processed
        if ($global:TuiState.IsDirty -or $inputProcessed) { # Render if input was received
            Invoke-TuiRender
            $global:TuiState.IsDirty = $false
        }
        
        # ... rest of loop logic ...
    }
```

### 10. **Refactor and Update Components (`AllComponents.ps1`)**

Many components need their `OnRender` methods updated to use the new `Write-TuiText` and `Write-TuiBox` signatures (passing a `[hashtable]$Style`) and to correctly use hex colors.

*   **Go through each component's `OnRender` method:**
    *   `LabelComponent`:
        ```powershell
        # In LabelComponent.OnRender:
        # Old: Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $this.Text -ForegroundColor $fg
        $fg = $this.ForegroundColor # Assuming this is now a hex string property
        $style = @{ FG = $fg; BG = "#000000" } # Default to black background
        Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $this.Text -Style $style
        ```
    *   `ButtonComponent`:
        ```powershell
        # In ButtonComponent.OnRender:
        # Replace ConsoleColor assignments with hex strings.
        # Example hex colors:
        $borderColor = if ($this.IsFocused) { "#00FFFF" } else { "#808080" } # Cyan/Gray hex
        $bgColor = if ($this.IsPressed) { "#808080" } else { "#000000" } # DarkGray/Black hex
        $fgColor = if ($this.IsPressed) { "#000000" } else { $borderColor } # Black/Border color hex

        $boxStyle = @{ BorderStyle = "Single"; BorderFG = $borderColor; BG = $bgColor }
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -Style $boxStyle
        
        $textStyle = @{ FG = $fgColor; BG = $bgColor }
        Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -Style $textStyle
        ```
    *   `TextBoxComponent`:
        ```powershell
        # In TextBoxComponent.OnRender:
        $borderColor = $this.IsFocused ? "#00FFFF" : "#808080" # Cyan/Gray hex
        $bgColor = "#000000" # Black hex

        $boxStyle = @{ BorderStyle = "Single"; BorderFG = $borderColor; BG = $bgColor }
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -Style $boxStyle

        $textColor = "#FFFFFF" # White hex
        $placeholderColor = "#808080" # DarkGray hex

        # ... logic for display text ...
        $textStyle = @{ FG = $textColor; BG = $bgColor }
        $placeholderStyle = @{ FG = $placeholderColor; BG = $bgColor }

        if ([string]::IsNullOrEmpty($displayText) -and $this.Placeholder) {
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $placeholderText -Style $placeholderStyle
        } else {
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $visibleText -Style $textStyle
        }

        # Cursor
        $cursorStyle = @{ FG = $bgColor; BG = "#FFFF00" } # Yellow background for cursor
        Write-TuiText -Buffer $this._private_buffer -X $cursorX -Y $contentY -Text $cursorChar -Style $cursorStyle
        ```
    *   Apply similar logical updates for `CheckBoxComponent`, `RadioButtonComponent`, `MultilineTextBoxComponent`, `NumericInputComponent`, `DateInputComponent`, `ComboBoxComponent`, `Table`, `ListBox`, `Panel`, `ScrollablePanel`, `GroupPanel`, `CommandPalette`.

### 11. **Refactor `Get-ThemeColor` (`AllFunctions.ps1`)**

Since you're moving to hex colors, `Get-ThemeColor` needs to return hex strings.

*   **Locate:** `function Get-ThemeColor` (around line 265).
*   **Change:**
    *   Modify default theme colors to hex.
    *   Ensure it returns string.

```powershell
# In AllFunctions.ps1, replace Get-ThemeColor with:

function Get-ThemeColor {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$ColorName
    )
    
    # Use the ThemeManager service if available and initialized
    if ($global:TuiState -and $global:TuiState.Services.ThemeManager) {
        return $global:TuiState.Services.ThemeManager.GetColor($ColorName)
    }
    
    # Fallback default theme with hex colors if theme manager not available
    $defaultTheme = @{
        'Foreground' = '#FFFFFF'
        'Background' = '#000000'
        'Accent' = '#00FFFF'
        'Header' = '#00FFFF'
        'Subtle' = '#808080'
        'Highlight' = '#FFFF00'
        'Border' = '#808080'
        'Selection' = '#000080'
        'button.normal.background' = '#000000'
        'button.normal.foreground' = '#FFFFFF'
        'button.normal.border' = '#808080'
        'button.focus.background' = '#000000'
        'button.focus.foreground' = '#FFFFFF'
        'button.focus.border' = '#00FFFF'
        'button.pressed.background' = '#808080'
        'button.pressed.foreground' = '#000000'
        'button.pressed.border' = '#00FFFF'
        'textbox.normal.background' = '#000000'
        'textbox.normal.foreground' = '#FFFFFF'
        'textbox.normal.border' = '#808080'
        'textbox.focus.background' = '#000000'
        'textbox.focus.foreground' = '#FFFFFF'
        'textbox.focus.border' = '#00FFFF'
        'textbox.placeholder' = '#808080'
        'checkbox.normal.foreground' = '#FFFFFF'
        'checkbox.checked.foreground' = '#00FF00'
        'checkbox.focus.foreground' = '#00FFFF'
        'panel.background' = '#000000'
        'panel.foreground' = '#FFFFFF'
        'panel.border' = '#808080'
        'panel.title' = '#00FFFF'
        'list.item.normal' = '#FFFFFF'
        'list.item.selected' = '#000000'
        'list.item.selected.background' = '#00FFFF'
        'list.scrollbar' = '#808080'
        'dialog.background' = '#000000'
        'dialog.foreground' = '#FFFFFF'
        'dialog.border' = '#FFFF00'
        'dialog.title' = '#FFFF00'
        'dialog.shadow' = '#404040' # A darker gray
    }
    
    return $defaultTheme[$ColorName] ?? '#FFFFFF' # Fallback to white if not found
}
```

### 12. **Update `ThemeManager` (`AllServices.ps1`)**

The `ThemeManager` needs to handle hex colors and its `GetColor` method needs to provide styles (potentially via `GetStyle` as in `acta`)

*   **Locate:** `class ThemeManager` (around line 2232).
*   **Change:**
    *   Modify `LoadDefaultTheme` to use hex colors.
    *   Modify `GetColor` to return hex strings.
    *   Consider adding a `GetStyle` method as in `acta` for component-specific styles, which would then be used in `OnRender` methods. This is an optional but powerful upgrade.

```powershell
# In AllServices.ps1, inside ThemeManager class:

# Update LoadDefaultTheme to use hex colors as its base
[void] LoadDefaultTheme() {
    $this.CurrentTheme = @{
        # Base colors (hex)
        'Foreground' = '#FFFFFF'
        'Background' = '#000000'
        'Accent' = '#00FFFF'
        'Header' = '#00FFFF'
        'Subtle' = '#808080'
        'Highlight' = '#FFFF00'
        'Border' = '#808080'
        'Selection' = '#000080'
        'Error' = '#FF0000'
        'Warning' = '#FFFF00'
        'Success' = '#00FF00'
        'Info' = '#00FFFF'
        
        # Component-specific colors (hex)
        'button.normal.background' = '#000000'
        'button.normal.foreground' = '#FFFFFF'
        'button.normal.border' = '#808080'
        'button.focus.background' = '#000000'
        'button.focus.foreground' = '#FFFFFF'
        'button.focus.border' = '#00FFFF'
        'button.pressed.background' = '#808080'
        'button.pressed.foreground' = '#000000'
        'button.pressed.border' = '#00FFFF'
        
        'textbox.normal.background' = '#000000'
        'textbox.normal.foreground' = '#FFFFFF'
        'textbox.normal.border' = '#808080'
        'textbox.focus.background' = '#000000'
        'textbox.focus.foreground' = '#FFFFFF'
        'textbox.focus.border' = '#00FFFF'
        'textbox.placeholder' = '#808080'
        
        'checkbox.normal.foreground' = '#FFFFFF'
        'checkbox.checked.foreground' = '#00FF00'
        'checkbox.focus.foreground' = '#00FFFF'
        
        'panel.background' = '#000000'
        'panel.foreground' = '#FFFFFF'
        'panel.border' = '#808080'
        'panel.title' = '#00FFFF'
        
        'list.item.normal' = '#FFFFFF'
        'list.item.selected' = '#000000'
        'list.item.selected.background' = '#00FFFF'
        'list.scrollbar' = '#808080'
        
        'dialog.background' = '#000000'
        'dialog.foreground' = '#FFFFFF'
        'dialog.border' = '#FFFF00'
        'dialog.title' = '#FFFF00'
        'dialog.shadow' = '#404040' # Darker gray for shadow
    }
    
    $this.ThemeName = "Default"
    # Write-Verbose "ThemeManager: Loaded default theme"
}

# Update GetColor method
[object] GetColor([string]$colorName) {
    if ($this.CurrentTheme.ContainsKey($colorName)) {
        return $this.CurrentTheme[$colorName]
    }
    
    # Fallback to base color if component-specific not found (e.g., 'button.normal.background' -> 'Background')
    if ($colorName -match '\.') {
        $baseColor = $colorName.Split('.')[0]
        if ($this.CurrentTheme.ContainsKey($baseColor)) {
            return $this.CurrentTheme[$baseColor]
        }
    }
    
    # Write-Warning "ThemeManager: Color '$colorName' not found in theme, using White"
    return '#FFFFFF' # Fallback to white hex
}

# Optional: Add GetStyle method if you want advanced nested styles like in acta
[hashtable] GetStyle([string]$componentPath) {
    $pathSegments = $componentPath.Split('.')
    $currentValue = $this.CurrentTheme
    
    foreach($segment in $pathSegments) {
        if ($currentValue -is [hashtable] -and $currentValue.ContainsKey($segment)) {
            $currentValue = $currentValue[$segment]
        } else {
            return @{} # Path not found, return empty style
        }
    }
    
    # Resolve all palette references (e.g., '$Palette.foreground').
    # Assuming 'Palette' is a top-level key in your theme structure.
    $resolvedStyle = @{}
    if ($currentValue -is [hashtable]) {
        foreach ($key in $currentValue.Keys) {
            $val = $currentValue[$key]
            $depth = 0
            while ($val -is [string] -and $val.StartsWith('$Palette.') -and $depth -lt 10) {
                $paletteKey = $val.Substring(9)
                if ($this.CurrentTheme.Palette.ContainsKey($paletteKey)) { # Assuming a 'Palette' hashtable within themes
                    $val = $this.CurrentTheme.Palette[$paletteKey]
                } else {
                    Write-Warning "Theme '$($this.ThemeName)' is missing palette key: '$paletteKey' requested by '$componentPath'"
                    $val = '#FF00FF' # Visible error color
                    break
                }
                $depth++
            }
            if ($val -is [string] -and $val.StartsWith('$Palette.')) {
                Write-Warning "Circular or unresolved palette reference detected at '$componentPath' for value '$val'"
                $val = '#FF00FF'
            }
            $resolvedStyle[$key] = $val
        }
    }
    
    return $resolvedStyle
}
```

---

## Conclusion

These upgrades are substantial and will require careful implementation and testing. They fundamentally improve the rendering pipeline, error handling, focus management, and set the stage for more advanced theming and UI responsiveness.

**Summary of Impact:**

*   **Flicker-Free & Richer UI:** Truecolor support, proper style propagation, and differential rendering will result in a much more professional and smoother TUI experience.
*   **Stability:** Structured error handling and robust data loading will reduce crashes and improve diagnostics.
*   **Maintainability:** Centralized styling, cleanup, and input handling make the codebase cleaner and easier to extend.
*   **Responsiveness:** The non-blocking input thread prevents UI freezes.

Start with the "High-Priority Upgrades" section, testing after each major step. Once those are stable, proceed with the "General Quality of Life" improvements. Good luck!