Excellent. This is a masterful consolidation of the required fixes and a clear, actionable plan. My role now is to synthesize all the provided information—the `critical_issues.txt` plan, the scattered implementation requests from the prompt, and the `stabilize.txt` analysis—into a single, unified, and exhaustive implementation guide.

### **Additional Stability Analysis (Final Review)**

Before creating the implementation plan, I have conducted a final review of the entire codebase against the proposed changes. The `critical_issues.txt` plan is exceptionally thorough and covers almost all critical and major flaws. I have identified **one additional critical issue** and will integrate the user's other immediate implementation requests into the main plan.

**Newly Identified Critical Issue: Mismatched Service Registration in `Start.ps1`**

*   **Concept:** A Dependency Injection (DI) container, like `ServiceContainer`, needs to be aware of all the services it manages. The `NavigationService` constructor was updated to expect a hashtable of all services, but the registration code in `Start.ps1` only gives it the `EventManager`.
*   **Problem:** The `NavigationService` is instantiated with an incomplete list of services. When it later needs to create a new screen (which itself depends on multiple services), it won't be able to pass them, leading to a crash or a non-functional screen.
*   **Location:** `Start.txt` -> `PAGE: STA.002 - Framework Loading & Service Initialization`.
*   **Impact:** High. This will cause failures during navigation to any screen that requires services not manually passed in.
*   **Fix:** The `NavigationService` should be one of the *last* services registered, and it should be passed the `ServiceContainer` instance itself so it can resolve any dependency a screen might need. **This will be integrated into the implementation plan below.**

All other immediate implementation requests from the prompt (`VerticalStackPanel`, C# Fuzzy Search, and improved `Write-TuiBox`) will be treated as **critical stability wins** and integrated directly into the plan.

---

### **Axiom-Phoenix: Comprehensive Implementation Plan**

This document provides the exact code changes required to execute the "Final Stabilization & Integration Plan." Each step includes the file, location, and the code to be added, removed, or replaced.

### **Part 1: Foundational & Blocking Issues**

#### **1.1. Fix Incorrect File Load Order**
*   **Goal:** Ensure functions are defined before classes use them.
*   **File:** `Start.txt`
*   **Location:** `PAGE: STA.002 - Framework Loading & Service Initialization`
*   **Action:** Replace the `$filesToLoad` array definition.

```powershell
# Replace this array in Start.txt
$filesToLoad = @(
    'AllBaseClasses.ps1',   # Foundation types with zero dependencies
    'AllModels.ps1',        # Data models, depends on base classes
    'AllFunctions.ps1',     # << MOVED UP: Helper functions must exist before being used
    'AllComponents.ps1',    # UI components, depends on base + models + functions
    'AllScreens.ps1',       # Screens, depends on all above
    'AllServices.ps1',      # Services, can use everything
    'AllRuntime.ps1'        # Engine and runtime, orchestrates everything
)
```

#### **1.2. Fix Uncallable Function in `TuiBuffer`**
*   **Goal:** Remove the `DrawBox` method that illegally calls a global function.
*   **File:** `allbaseclasses.txt`
*   **Location:** `PAGE: ABC.003 - TuiBuffer Class`
*   **Action:** Delete the entire `DrawBox` method from the `TuiBuffer` class.

```powershell
# DELETE THIS ENTIRE METHOD from the TuiBuffer class in allbaseclasses.txt

[void] DrawBox([int]$x, [int]$y, [int]$width, [int]$height, [hashtable]$style = @{}) {
    # This will now internally call the new Write-TuiBox function in AllFunctions.ps1
    # It's better to delegate complex drawing like boxes to the global functions.
    Write-TuiBox -Buffer $this -X $x -Y $y -Width $width -Height $height -Style $style
}
```

#### **1.3. Fix Dialogs Not Closing**
*   **Goal:** Make `DialogManager` subscribe to the `Dialog.Completed` event so it can hide dialogs.
*   **File:** `AllServices.txt`
*   **Location:** `PAGE: ASE.009` -> `DialogManager` class
*   **Action:** Replace the existing empty `DialogManager` constructor with the following code.

```powershell
# Replace the existing constructor in AllServices.txt
DialogManager([EventManager]$eventManager, [FocusManager]$focusManager) {
    $this.EventManager = $eventManager
    $this.FocusManager = $focusManager
    
    # ADD THIS SUBSCRIPTION
    if ($this.EventManager) {
        $handler = {
            param($eventData)
            $dialogToHide = $eventData.Dialog
            if ($dialogToHide) {
                $this.HideDialog($dialogToHide)
            }
        }.GetNewClosure()
        # The subscription ID is managed by the EventManager, no need to store it here
        # as the DialogManager lives for the lifetime of the app.
        $this.EventManager.Subscribe("Dialog.Completed", $handler)
    }
}
```

#### **1.4. Fix Inconsistent Screen Rendering in `DashboardScreen`**
*   **Goal:** Refactor `DashboardScreen` to create `LabelComponent` children instead of drawing text directly to its panels' buffers.
*   **File:** `AllScreens.txt`
*   **Location:** `PAGE: ASC.001 - DashboardScreen Class`
*   **Action:** Replace the `_UpdateSummaryPanel`, `_UpdateHelpPanel`, and `_UpdateStatusPanel` methods with the following component-based logic.

```powershell
# Replace the _UpdateSummaryPanel method in AllScreens.txt
hidden [void] _UpdateSummaryPanel() {
    $panel = $this._summaryPanel
    if (-not $panel) { return }

    # Clear previous components
    $panel.Children.Clear()

    # Create LabelComponents instead of drawing directly
    $y = 0
    $panel.AddChild(([LabelComponent]::new("SummaryHeader")
        .SetText("Task Overview")
        .SetPosition(1, $y++)
        .SetStyle(@{ FG = Get-ThemeColor "Primary" })))
    
    $panel.AddChild(([LabelComponent]::new("SummarySeparator")
        .SetText('─' * [Math]::Max(0, $panel.ContentWidth - 2))
        .SetPosition(1, $y++)))
    
    $y++ # Spacer

    $panel.AddChild(([LabelComponent]::new("TotalTasksLabel")
        .SetText("Total Tasks:    $($this._totalTasks)")
        .SetPosition(1, $y++)))

    $panel.AddChild(([LabelComponent]::new("CompletedTasksLabel")
        .SetText("Completed:      $($this._completedTasks)")
        .SetPosition(1, $y++)
        .SetStyle(@{ FG = Get-ThemeColor "Success" })))

    $panel.AddChild(([LabelComponent]::new("PendingTasksLabel")
        .SetText("Pending:        $($this._pendingTasks)")
        .SetPosition(1, $y++)
        .SetStyle(@{ FG = Get-ThemeColor "Warning" })))
    
    # Progress Bar would become its own component in a future refactor. For now, keep direct drawing.
    $percentage = if ($this._totalTasks -eq 0) { 0 } else { [Math]::Round(($this._completedTasks / $this._totalTasks) * 100) }
    $this._DrawProgressBar($panel.GetBuffer(), $panel.ContentX + 1, $panel.ContentY + 7, 20, $percentage, "Overall Progress")
    
    $panel.RequestRedraw()
}

# Replace the _UpdateHelpPanel method in AllScreens.txt
hidden [void] _UpdateHelpPanel() {
    $panel = $this._helpPanel
    if (-not $panel) { return }

    $panel.Children.Clear()
    $y = 0

    $panel.AddChild(([LabelComponent]::new("HelpHeader1")
        .SetText("Welcome to Axiom-Phoenix!")
        .SetPosition(1, $y++)
        .SetStyle(@{ FG = Get-ThemeColor "Primary" })))
    
    $panel.AddChild(([LabelComponent]::new("HelpSeparator")
        .SetText('─' * [Math]::Max(0, $panel.ContentWidth - 2))
        .SetPosition(1, $y++)))

    $y++ # Spacer

    # Using multiple labels for mixed styling
    $panel.AddChild(([LabelComponent]::new("HelpLine1a").SetText("Press ").SetPosition(1, $y)))
    $panel.AddChild(([LabelComponent]::new("HelpLine1b").SetText("Ctrl+P").SetPosition(7, $y).SetStyle(@{ FG = Get-ThemeColor "Accent" })))
    $panel.AddChild(([LabelComponent]::new("HelpLine1c").SetText(" to open the").SetPosition(13, $y++)))
    $panel.AddChild(([LabelComponent]::new("HelpLine2").SetText("Command Palette.").SetPosition(1, $y)))
    
    $y+=2 # Spacer

    $panel.AddChild(([LabelComponent]::new("HelpLine3")
        .SetText("All navigation and actions are")
        .SetPosition(1, $y++)
        .SetStyle(@{ FG = Get-ThemeColor "Subtle" })))
    $panel.AddChild(([LabelComponent]::new("HelpLine4")
        .SetText("now available from there.")
        .SetPosition(1, $y)
        .SetStyle(@{ FG = Get-ThemeColor "Subtle" })))

    $panel.RequestRedraw()
}

# Replace the _UpdateStatusPanel method in AllScreens.txt
hidden [void] _UpdateStatusPanel() {
    $panel = $this._statusPanel
    if (-not $panel) { return }

    $panel.Children.Clear()
    $y = 0

    $memoryMB = try { [Math]::Round((Get-Process -Id $global:PID).WorkingSet64 / 1MB, 2) } catch { 0 }
    
    $panel.AddChild(([LabelComponent]::new("StatusHeader")
        .SetText("Environment")
        .SetPosition(1, $y++)
        .SetStyle(@{ FG = Get-ThemeColor "Primary" })))
        
    $panel.AddChild(([LabelComponent]::new("StatusSeparator")
        .SetText('─' * [Math]::Max(0, $panel.ContentWidth - 2))
        .SetPosition(1, $y++)))
    
    $y++ # Spacer

    $panel.AddChild(([LabelComponent]::new("PSVersionLabel")
        .SetText("PowerShell Version: $($global:PSVersionTable.PSVersion)")
        .SetPosition(1, $y++)))
        
    $panel.AddChild(([LabelComponent]::new("MemUsageLabel")
        .SetText("Memory Usage: ${memoryMB} MB")
        .SetPosition(1, $y++)))

    $panel.AddChild(([LabelComponent]::new("HostLabel")
        .SetText("Host: $($global:Host.Name)")
        .SetPosition(1, $y++)))

    $panel.RequestRedraw()
}
```

*(Note: The above refactor requires adding a `.SetPosition()` and `.SetStyle()` method to the `LabelComponent` for fluent configuration. Add these to the `LabelComponent` class in `AllComponents.txt`)*

```powershell
# Add these methods to LabelComponent in AllComponents.txt, PAGE: ACO.001
[LabelComponent] SetPosition([int]$x, [int]$y) {
    $this.X = $x
    $this.Y = $y
    return $this
}

[LabelComponent] SetText([string]$text) {
    $this.Text = $text
    return $this
}

[LabelComponent] SetStyle([hashtable]$style) {
    if ($style.ContainsKey('FG')) { $this.ForegroundColor = $style.FG }
    return $this
}
```

### **Part 2: Major Architectural & Functional Flaws**

#### **2.1. Implement Sophisticated Layout Panels (Immediate Stability Win)**
*   **Goal:** Introduce a `VerticalStackPanel` to automate UI element positioning, making UI code more robust and maintainable.
*   **Action:**
    1.  Add the `VerticalStackPanel` class to `AllComponents.txt`.
    2.  Add the `ApplyLayout` logic to the base `Panel` class in `allbaseclasses.txt`.
    3.  Update the `TableOfContents.md` to include a new component.

**Step 2.1.1: Create the `VerticalStackPanel` Class**
*   **File:** `AllComponents.txt`
*   **Location:** Add a new page marker at the end of the file.
*   **Action:** Add the following code and page markers.

```powershell
#<!-- PAGE: ACO.022 - VerticalStackPanel Class -->
# ===== CLASS: VerticalStackPanel =====
# Module: panels-class
# Dependencies: Panel
# Purpose: Declarative panel that arranges children vertically.
class VerticalStackPanel : Panel {
    [int]$Spacing = 1 # The vertical space between children

    VerticalStackPanel([string]$name) : base($name) {
        # The key change: tell the base Panel class what kind of layout to perform.
        $this.LayoutType = "Vertical"
    }
}
#<!-- END_PAGE: ACO.022 -->
```

**Step 2.1.2: Implement Layout Logic in Base `Panel` Class**
*   **File:** `allbaseclasses.txt`
*   **Location:** `PAGE: ACO.011 - Panel Class` (Typo in original file, should be `ABC.011`, but matching user's prompt which references `ACO.011`. Assuming this is `Panel` class in `AllComponents.txt`. If `Panel` is in `allbaseclasses.txt`, apply it there.)
*   **Action:** Add the `$LayoutType` property and the `ApplyLayout` method to the `Panel` class. Then, modify `OnRender` to call it.

```powershell
# In the Panel class definition in AllComponents.txt (PAGE: ACO.011)

# Add this property to the Panel class
[string]$LayoutType = "Manual"  # Can be "Manual", "Vertical", "Horizontal"

# Add this new method to the Panel class
[void] ApplyLayout() {
    if ($this.LayoutType -eq "Manual") { return }

    # Define the area available for children inside the border and padding
    $contentX = $this.ContentX
    $currentY = $this.ContentY

    # Get only the children that should be part of the layout
    $visibleChildren = @($this.Children | Where-Object { $_.Visible })
    if ($visibleChildren.Count -eq 0) { return }

    switch ($this.LayoutType) {
        "Vertical" {
            # This is the core logic
            foreach ($child in $visibleChildren) {
                # Set the child's position based on the previous child
                $child.X = $contentX
                $child.Y = $currentY
                
                # Advance the Y position for the next child
                $currentY += $child.Height
                
                # Add spacing if the panel has a Spacing property (like VerticalStackPanel)
                if ($this.PSObject.Properties['Spacing']) {
                    $currentY += $this.Spacing
                }
            }
        }
        "Horizontal" {
            # Implement similar logic for the X axis later
        }
    }
}

# Modify the OnRender method in the Panel class
[void] OnRender() {
    if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
    
    try {
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))

        $this.ContentX = if ($this.HasBorder) { 1 } else { 0 }
        $this.ContentY = if ($this.HasBorder) { 1 } else { 0 }
        $this.ContentWidth = [Math]::Max(0, $this.Width - (if ($this.HasBorder) { 2 } else { 0 }))
        $this.ContentHeight = [Math]::Max(0, $this.Height - (if ($this.HasBorder) { 2 } else { 0 }))

        if ($this.HasBorder) {
            $borderColorValue = if ($this.IsFocused) { Get-ThemeColor("Primary") } else { Get-ThemeColor("component.border") }
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = $this.BorderStyle; TitleFG = Get-ThemeColor("component.title") } `
                -Title $this.Title
        }

        # ADD THIS CALL:
        # This automatically positions children before they are rendered.
        $this.ApplyLayout()
    }
    catch {}
}
```

**Step 2.1.3: Update Table of Contents**
*   **File:** `TableOfContents.md`
*   **Action:** Add an entry for the new `VerticalStackPanel`.

```markdown
| ACO.022 | VerticalStackPanel Class | Declarative panel that arranges children vertically. |
```

#### **2.2. Fix Flawed `TaskListScreen` Logic**
*   **Goal:** Replace the manual drawing in `_UpdateTaskList` with the creation of `UIElement` children, letting `ScrollablePanel` manage them.
*   **File:** `AllScreens.txt`
*   **Location:** `PAGE: ASC.002` -> `TaskListScreen` class
*   **Action:** Replace the entire `_UpdateTaskList` method.

```powershell
# Replace the existing _UpdateTaskList method in AllScreens.txt
hidden [void] _UpdateTaskList() {
    $panel = $this._taskListPanel
    if (-not $panel) { return }

    # Clear the panel's CHILDREN, not its buffer.
    $panel.Children.Clear()

    if ($this._tasks.Count -eq 0) {
        $noTasksLabel = [LabelComponent]::new("NoTasksLabel")
            .SetText("No tasks found.")
            .SetPosition(2, 2)
            .SetStyle(@{ FG = Get-ThemeColor "Subtle" })
        $panel.AddChild($noTasksLabel)
    }
    else {
        # Create a UIElement (Panel + Label) for each task
        for ($i = 0; $i -lt $this._tasks.Count; $i++) {
            $task = $this._tasks[$i]
            $is_selected = ($i -eq $this._selectedIndex)

            # Create a Panel for each item to allow background highlighting
            $taskPanel = [Panel]::new("TaskItem_$($task.Id)")
            $taskPanel.X = 0; $taskPanel.Y = $i # Y position is its index
            $taskPanel.Width = $panel.ContentWidth; $taskPanel.Height = 1
            $taskPanel.HasBorder = $false
            $taskPanel.BackgroundColor = if ($is_selected) { Get-ThemeColor "list.item.selected.background" } else { Get-ThemeColor "Background" }

            # Status and Priority
            $statusChar = switch ($task.Status) { 'Pending' {'○'}; 'InProgress' {'◐'}; 'Completed' {'●'}; 'Cancelled' {'✕'}; default {'?'} }
            $priorityChar = switch ($task.Priority) { 'Low' {'↓'}; 'Medium' {'→'}; 'High' {'↑'}; default {'-'} }
            $taskLine = "$statusChar $priorityChar $($task.Title)"
            
            # Create a label for the text
            $taskLabel = [LabelComponent]::new("TaskLabel_$($task.Id)")
            $taskLabel.Text = $taskLine
            $taskLabel.X = 1; $taskLabel.Y = 0
            $taskLabel.ForegroundColor = if ($is_selected) { Get-ThemeColor "list.item.selected" } else { Get-ThemeColor "list.item.normal" }
            
            $taskPanel.AddChild($taskLabel)

            # Add the item's Panel as a CHILD of the scrollable panel
            $panel.AddChild($taskPanel)
        }
    }
    # The ScrollablePanel's Render method will now handle everything else.
    $panel.RequestRedraw()
}
```

#### **2.3. Fix Flawed Dialog Focus System**
*   **Goal:** Remove the manual `_focusIndex` logic from dialogs and use the central `FocusManager`.
*   **File:** `AllComponents.txt`
*   **Location:** `PAGE: ACO.019` (`ConfirmDialog`) and `ACO.020` (`InputDialog`)
*   **Action:** Refactor both dialog classes.

**ConfirmDialog Refactor (`PAGE: ACO.019`)**
```powershell
# Replace the existing ConfirmDialog class
class ConfirmDialog : Dialog {
    hidden [ButtonComponent]$_yesButton
    hidden [ButtonComponent]$_noButton

    ConfirmDialog([string]$name) : base($name) {
        $this.Height = 8
        $this.InitializeConfirm()
    }

    hidden [void] InitializeConfirm() {
        $this._yesButton = [ButtonComponent]::new($this.Name + "_Yes")
        $this._yesButton.Text = "Yes"
        $this._yesButton.Width = 10; $this._yesButton.Height = 3
        $this._yesButton.TabIndex = 0 # Use TabIndex for focus order
        $this._yesButton.OnClick = { $this.Complete($true) }.GetNewClosure()
        $this._panel.AddChild($this._yesButton)

        $this._noButton = [ButtonComponent]::new($this.Name + "_No")
        $this._noButton.Text = "No"
        $this._noButton.Width = 10; $this._noButton.Height = 3
        $this._noButton.TabIndex = 1 # Use TabIndex for focus order
        $this._noButton.OnClick = { $this.Complete($false) }.GetNewClosure()
        $this._panel.AddChild($this._noButton)
    }

    [void] Show([string]$title, [string]$message) {
        ([Dialog]$this).Show($title, $message)
        $buttonY = $this.Height - 4
        $totalWidth = $this._yesButton.Width + $this._noButton.Width + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        $this._yesButton.X = $startX
        $this._yesButton.Y = $buttonY
        $this._noButton.X = $startX + $this._yesButton.Width + 4
        $this._noButton.Y = $buttonY
    }

    [void] OnEnter() {
        # When shown, tell FocusManager to focus the 'Yes' button.
        $global:TuiState.Services.FocusManager?.SetFocus($this._yesButton)
    }
    
    [void] OnRender() { # Keep message rendering
        ([Dialog]$this).OnRender()
        if ($this.Visible -and $this.Message) {
            Write-TuiText -Buffer $this._panel._private_buffer -X 2 -Y 2 -Text $this.Message -Style @{ FG = Get-ThemeColor "dialog.foreground" }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Complete($false)
            return $true
        }
        # Let the global input handler route Tab. Custom arrow key nav is a good addition.
        if ($key.Key -in @([ConsoleKey]::LeftArrow, [ConsoleKey]::RightArrow)) {
            $focusManager = $global:TuiState.Services.FocusManager
            if ($focusManager) {
                if ($focusManager.FocusedComponent -eq $this._yesButton) { $focusManager.SetFocus($this._noButton) }
                else { $focusManager.SetFocus($this._yesButton) }
                return $true
            }
        }
        return $false # All other input is handled by the focused button.
    }
}
```

**InputDialog Refactor (`PAGE: ACO.020`)**
```powershell
# Replace the existing InputDialog class
class InputDialog : Dialog {
    hidden [TextBoxComponent]$_inputBox
    hidden [ButtonComponent]$_okButton
    hidden [ButtonComponent]$_cancelButton
    
    InputDialog([string]$name) : base($name) {
        $this.Height = 10
        $this.InitializeInput()
    }

    hidden [void] InitializeInput() {
        $this._inputBox = [TextBoxComponent]::new($this.Name + "_Input")
        $this._inputBox.Width = $this.Width - 4; $this._inputBox.Height = 3
        $this._inputBox.X = 2; $this._inputBox.Y = 4
        $this._inputBox.TabIndex = 0 # TabIndex for FocusManager
        $this._panel.AddChild($this._inputBox)

        $this._okButton = [ButtonComponent]::new($this.Name + "_OK")
        $this._okButton.Text = "OK"
        $this._okButton.Width = 10; $this._okButton.Height = 3
        $this._okButton.TabIndex = 1 # TabIndex for FocusManager
        $this._okButton.OnClick = { $this.Complete($this._inputBox.Text) }.GetNewClosure()
        $this._panel.AddChild($this._okButton)

        $this._cancelButton = [ButtonComponent]::new($this.Name + "_Cancel")
        $this._cancelButton.Text = "Cancel"
        $this._cancelButton.Width = 10; $this._cancelButton.Height = 3
        $this._cancelButton.TabIndex = 2 # TabIndex for FocusManager
        $this._cancelButton.OnClick = { $this.Complete($null) }.GetNewClosure()
        $this._panel.AddChild($this._cancelButton)
    }

    [void] Show([string]$title, [string]$message, [string]$defaultValue = "") {
        ([Dialog]$this).Show($title, $message)
        $this._inputBox.Text = $defaultValue
        $this._inputBox.CursorPosition = $defaultValue.Length
        
        $buttonY = $this.Height - 4
        $totalWidth = $this._okButton.Width + $this._cancelButton.Width + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        $this._okButton.X = $startX; $this._okButton.Y = $buttonY
        $this._cancelButton.X = $startX + $this._okButton.Width + 4; $this._cancelButton.Y = $buttonY
    }
    
    [void] OnEnter() {
        $global:TuiState.Services.FocusManager?.SetFocus($this._inputBox)
    }

    [void] OnRender() { # Keep message rendering
        ([Dialog]$this).OnRender()
        if ($this.Visible -and $this.Message) {
            Write-TuiText -Buffer $this._panel._private_buffer -X 2 -Y 2 -Text $this.Message -Style @{ FG = Get-ThemeColor "dialog.foreground" }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Complete($null)
            return $true
        }
        # If the focused component is the textbox, and the user presses Enter,
        # it should act like clicking OK.
        $focusManager = $global:TuiState.Services.FocusManager
        if ($key.Key -eq [ConsoleKey]::Enter -and $focusManager -and $focusManager.FocusedComponent -eq $this._inputBox) {
             $this.Complete($this._inputBox.Text)
             return $true
        }
        return $false # All other input handled by focused child or global focus manager (Tab)
    }
}
```

#### **2.4. Fix Lack of UI Updates on Background Data Changes**
*   **Goal:** Force a screen redraw when a background event (like a data change) updates a screen's state.
*   **File:** `AllScreens.txt`
*   **Location:** Event handler scriptblocks in `DashboardScreen` and `TaskListScreen`.
*   **Action:** Add `$global:TuiState.IsDirty = $true` to the end of the event handlers.

**DashboardScreen Fix (`PAGE: ASC.001`)**
```powershell
# Modify the handler scriptblock in DashboardScreen.OnEnter
$handler = {
    param($eventData)
    Write-Verbose "DashboardScreen received data change event. Refreshing..."
    $dataManager = $this.ServiceContainer?.GetService("DataManager")
    $this._RefreshData($dataManager)
    $global:TuiState.IsDirty = $true # ADD THIS LINE
}.GetNewClosure()
```

**TaskListScreen Fix (`PAGE: ASC.002`)**
```powershell
# Modify the handler scriptblock in TaskListScreen.OnEnter
$handler = {
    param($eventData)
    Write-Verbose "TaskListScreen received Tasks.Changed event. Refreshing tasks."
    $this._RefreshTasks()
    # The _UpdateDisplay method already calls RequestRedraw(), which sets the flag on the component.
    # Setting the global dirty flag ensures the main loop re-renders the whole screen.
    $global:TuiState.IsDirty = $true # ADD THIS LINE
}.GetNewClosure()
```

### **Part 3: Hardening, Stability, and Future-Proofing**

#### **3.1. Improve `Write-TuiBox` Drawing Logic**
*   **Goal:** Refactor `Write-TuiBox` to be more robust, readable, and slightly more performant.
*   **File:** `AllFunctions.txt`
*   **Location:** `PAGE: AFU.001`
*   **Action:** Replace the entire `Write-TuiBox` function.

```powershell
# Replace the existing Write-TuiBox function in AllFunctions.txt
function Write-TuiBox {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [string]$Title = "",
        [hashtable]$Style = @{}
    )

    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }

    $borderStyleName = $Style.BorderStyle ?? "Single"
    $borderColor = $Style.BorderFG ?? "#808080"
    $bgColor = $Style.BG ?? "#000000"
    $titleColor = $Style.TitleFG ?? $borderColor
    $fillChar = [char]($Style.FillChar ?? ' ')
    $borders = Get-TuiBorderChars -Style $borderStyleName
    $borderStyle = @{ FG = $borderColor; BG = $bgColor }
    $fillStyle = @{ FG = $borderColor; BG = $bgColor }
    $titleTextStyle = @{ FG = $titleColor; BG = $bgColor }

    # 1. Fill the entire area first. This sets the background color correctly.
    $Buffer.FillRect($X, $Y, $Width, $Height, $fillChar, $fillStyle)

    # 2. Build the border lines in memory first
    $lines = [System.Collections.Generic.List[string]]::new()
    $horizontalBorder = $borders.Horizontal * [Math]::Max(0, $Width - 2)

    if ($Height -ge 1) { # Top Border
        $topLine = if ($Width -gt 1) { "$($borders.TopLeft)$($horizontalBorder)$($borders.TopRight)" } elseif ($Width -eq 1) { $borders.Vertical } else { "" }
        $lines.Add($topLine)
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) { # Middle Section (Sides only)
        if ($Width -gt 1) { $lines.Add("$($borders.Vertical)$(' ' * [Math]::Max(0, $Width - 2))$($borders.Vertical)") }
        elseif ($Width -eq 1) { $lines.Add($borders.Vertical) }
    }
    if ($Height -ge 2) { # Bottom Border
        $bottomLine = if ($Width -gt 1) { "$($borders.BottomLeft)$($horizontalBorder)$($borders.BottomRight)" } elseif ($Width -eq 1) { $borders.Vertical } else { "" }
        $lines.Add($bottomLine)
    }

    # 3. Draw the generated lines over the fill
    for ($i = 0; $i -lt $lines.Count; $i++) {
        if ($lines[$i]) {
            $Buffer.WriteString($X, $Y + $i, $lines[$i], $borderStyle)
        }
    }

    # 4. Draw title (unchanged logic)
    if (-not [string]::IsNullOrEmpty($Title) -and $Y -ge 0 -and $Y -lt $Buffer.Height -and $Width > 2) {
        $titleText = " $Title "
        if ($titleText.Length -le ($Width - 2)) {
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            $Buffer.WriteString($titleX, $Y, $titleText, $titleTextStyle)
        }
    }
    
    $Buffer.IsDirty = $true
}
```

#### **3.2. Implement Resilient Data Loading**
*   **Goal:** Prevent a single corrupted record in a JSON file from crashing the entire application load.
*   **File:** `AllServices.txt`
*   **Location:** `PAGE: ASE.003` -> `DataManager.LoadData` method
*   **Action:** Modify the `foreach` loops in `LoadData` to include `try/catch` blocks.

```powershell
# Modify the DataManager.LoadData method in AllServices.txt
[void] LoadData() {
    try {
        if (-not (Test-Path $this._dataFilePath)) { return }
        $jsonContent = Get-Content -Path $this._dataFilePath -Raw -Encoding UTF8
        if ([string]::IsNullOrWhiteSpace($jsonContent)) { return }
        $data = $jsonContent | ConvertFrom-Json -AsHashtable
        
        $this._taskIndex.Clear()
        $this._projectIndex.Clear()
        
        if ($data.ContainsKey('Tasks')) {
            foreach ($taskData in $data.Tasks) {
                try { # WRAP INDIVIDUAL RECORD
                    $task = [PmcTask]::FromLegacyFormat($taskData)
                    $this._taskIndex[$task.Id] = $task
                }
                catch {
                    Write-Log -Level Warning -Message "Skipped loading a corrupted task record: $($_.Exception.Message)"
                }
            }
        }
        
        if ($data.ContainsKey('Projects')) {
            foreach ($projectData in $data.Projects) {
                try { # WRAP INDIVIDUAL RECORD
                    $project = [PmcProject]::FromLegacyFormat($projectData)
                    $this._projectIndex[$project.Key] = $project
                }
                catch {
                    Write-Log -Level Warning -Message "Skipped loading a corrupted project record: $($_.Exception.Message)"
                }
            }
        }
        
        if ($data.ContainsKey('Metadata')) { $this.Metadata = $data.Metadata.Clone() }
        $this._lastSaveTime = [datetime]::Now
        $this._dataModified = $false
        Write-Log -Level Info -Message "DataManager: Loaded $($this._taskIndex.Count) tasks and $($this._projectIndex.Count) projects"
        $this.EventManager?.Publish("Data.Loaded", @{...})
    }
    catch {
        Write-Log -Level Error -Message "DataManager: Critical failure loading data file '$($this._dataFilePath)': $($_.Exception.Message)"
        throw
    }
}
```

#### **3.3. Implement Cascading Resource Cleanup**
*   **Goal:** Prevent memory leaks from event subscriptions by ensuring screens are cleaned up when navigating back.
*   **Action:**
    1.  Add a virtual `OnCleanup` method to `UIElement`.
    2.  Override `OnCleanup` in screens to unsubscribe from events.
    3.  Call `Cleanup()` in `NavigationService.GoBack`.

**Step 3.3.1: Update `UIElement.Cleanup`**
*   **File:** `allbaseclasses.txt`
*   **Location:** `PAGE: ABC.004 - UIElement Class`
*   **Action:** Add the `OnCleanup` method and modify `Cleanup`.

```powershell
# Add this new (empty virtual) method to UIElement
[void] OnCleanup() {
    # This method is intended to be overridden by child classes
}

# Modify the existing Cleanup method in UIElement
[void] Cleanup() {
    # Call the overrideable cleanup hook first
    $this.OnCleanup()

    # Then, cleanup all children recursively
    foreach ($child in $this.Children) {
        $child.Cleanup()
    }
    
    $this.Children.Clear()
    $this.Parent = $null
    $this._private_buffer = $null
}
```

**Step 3.3.2: Override `OnCleanup` in Screens**
*   **File:** `AllScreens.txt`
*   **Action:** Add the `OnCleanup` method to `DashboardScreen` and `TaskListScreen`. Note that `OnExit` was previously used for this, but `OnCleanup` is more explicit.

```powershell
# In DashboardScreen (PAGE: ASC.001)
[void] OnCleanup() {
    $eventManager = $this.ServiceContainer?.GetService("EventManager")
    if ($eventManager -and $this._dataChangeSubscriptionId) {
        $eventManager.Unsubscribe("Tasks.Changed", $this._dataChangeSubscriptionId)
        $this._dataChangeSubscriptionId = $null
    }
}

# In TaskListScreen (PAGE: ASC.002)
[void] OnCleanup() {
    $eventManager = $this.ServiceContainer?.GetService("EventManager")
    if ($eventManager -and $this._taskChangeSubscriptionId) {
        $eventManager.Unsubscribe("Tasks.Changed", $this._taskChangeSubscriptionId)
        $this._taskChangeSubscriptionId = $null
    }
}
```

**Step 3.3.3: Update `NavigationService.GoBack`**
*   **File:** `AllServices.txt`
*   **Location:** `PAGE: ASE.004 - NavigationService Class`
*   **Action:** Add the call to `Cleanup()` on the screen being closed.

```powershell
# Modify the GoBack method in NavigationService
[void] GoBack() {
    if (-not $this.CanGoBack()) { return }
    
    try {
        if ($this.CurrentScreen) {
            $this.CurrentScreen.OnExit()
            $this.CurrentScreen.Cleanup() # ADD THIS LINE
        }
        # ... rest of the method is correct ...
    }
    catch { # ... }
}
```

#### **3.4. Implement Window Resize Handling**
*   **Goal:** Make the TUI responsive to terminal window resizes.
*   **File:** `AllRuntime.txt`
*   **Location:** `PAGE: ART.002 - Engine Management` -> `Start-TuiEngine` function
*   **Action:** Add a size check to the main loop.

```powershell
# Modify the while loop in Start-TuiEngine
while ($global:TuiState.Running) {
    $frameTimer.Restart()
    
    # ADD THIS RESIZE CHECK
    if ([Console]::WindowWidth -ne $global:TuiState.BufferWidth -or [Console]::WindowHeight -ne $global:TuiState.BufferHeight) {
        Update-TuiEngineSize
    }
    
    Process-TuiInput
    # ... rest of the loop ...
}
```

#### **3.5. Implement C# Fuzzy Search for `CommandPalette`**
*   **Goal:** Replace the basic `.Contains()` search with a high-performance, intelligent fuzzy search.
*   **Action:**
    1.  Add the C# source to `Start.txt`.
    2.  Refactor `CommandPalette.FilterActions` in `AllComponents.txt`.

**Step 3.5.1: Add C# Type Definition**
*   **File:** `Start.txt`
*   **Location:** `PAGE: STA.001 - Script Configuration`
*   **Action:** Add this entire region after the initial `Set-StrictMode` block.

```powershell
# Add this region to Start.txt

#region Add Custom C# Types
Write-Host "Compiling C# helper types..." -ForegroundColor Cyan

$csharpFuzzySearchSource = @"
using System;
public static class FuzzySearcher
{
    public static int GetFuzzyMatchScore(string query, string target)
    {
        if (string.IsNullOrEmpty(query) || string.IsNullOrEmpty(target)) return 0;
        string lowerQuery = query.ToLowerInvariant();
        string lowerTarget = target.ToLowerInvariant();
        if (lowerTarget.Contains(lowerQuery)) return 100 - (lowerTarget.Length - lowerQuery.Length);
        int score = 0, queryIndex = 0, targetIndex = 0, consecutiveMatches = 0;
        while (queryIndex < lowerQuery.Length && targetIndex < lowerTarget.Length) {
            if (lowerQuery[queryIndex] == lowerTarget[targetIndex]) {
                score += 10 + (consecutiveMatches * 5);
                consecutiveMatches++;
                queryIndex++;
            } else {
                consecutiveMatches = 0;
            }
            targetIndex++;
        }
        if (queryIndex == lowerQuery.Length) return Math.Max(0, score - Math.Abs(lowerTarget.Length - lowerQuery.Length));
        return 0;
    }
    public class FuzzySearchResult { public object Item { get; set; } public int Score { get; set; } }
}
"@

try {
    Add-Type -TypeDefinition $csharpFuzzySearchSource -Language CSharp
    Write-Host "C# helper types compiled successfully." -ForegroundColor Green
} catch {
    Write-Error "Failed to compile C# helper types: $_"; throw
}
#endregion
```

**Step 3.5.2: Refactor `CommandPalette.FilterActions`**
*   **File:** `AllComponents.txt`
*   **Location:** `PAGE: ACO.016 - CommandPalette Class`
*   **Action:** Replace the entire `FilterActions` method.

```powershell
# Replace the FilterActions method in the CommandPalette class
[void] FilterActions([string]$searchText) {
    $this._filteredActions.Clear()
    $this._listBox.ClearItems()
    
    $getDisplayText = {
        param($action)
        return if ($action.Category) { "[$($action.Category)] $($action.Name) - $($action.Description)" } 
               else { "$($action.Name) - $($action.Description)" }
    }

    if ([string]::IsNullOrWhiteSpace($searchText)) {
        foreach ($action in $this._allActions) { # Assumes _allActions is pre-sorted
            $this._filteredActions.Add($action)
            $this._listBox.AddItem((& $getDisplayText $action))
        }
    }
    else {
        $results = [System.Collections.Generic.List[object]]::new()
        foreach ($action in $this._allActions) {
            $searchableText = "$($action.Category) $($action.Name) $($action.Description)"
            $score = [FuzzySearcher]::GetFuzzyMatchScore($searchText, $searchableText)
            
            if ($score -gt 20) { # Threshold to filter out poor matches
                $result = [FuzzySearcher+FuzzySearchResult]::new()
                $result.Item = $action
                $result.Score = $score
                $results.Add($result)
            }
        }
        
        $sortedResults = $results | Sort-Object Score -Descending
        foreach ($result in $sortedResults) {
            $action = $result.Item
            $this._filteredActions.Add($action)
            $this._listBox.AddItem((& $getDisplayText $action))
        }
    }

    if ($this._listBox.Items.Count > 0) {
        $this._listBox.SelectedIndex = 0
    }
}
```

#### **3.6. Fix Mismatched Service Registration**
*   **Goal:** Ensure `NavigationService` has access to all other services when it needs to create screens.
*   **File:** `Start.txt`
*   **Location:** `PAGE: STA.002 - Framework Loading & Service Initialization`
*   **Action:** Restructure the service registration block.

```powershell
# Replace the entire "Initialize Services" region in Start.txt

#region Initialize Services
try {
    Write-Host "Initializing services..." -ForegroundColor Cyan
    $global:TuiState = @{ Services = @{} } # Initialize global state
    $container = [ServiceContainer]::new()
    
    # 1. Register services with NO dependencies first
    $container.Register("Logger", ([Logger]::new()))
    $container.Register("EventManager", ([EventManager]::new()))
    $container.Register("ThemeManager", ([ThemeManager]::new()))

    # 2. Register services WITH dependencies using factories
    # The factory scriptblock gets the container ($c) passed to it for resolving dependencies.
    $container.RegisterFactory("ActionService", { param($c) [ActionService]::new($c.GetService('EventManager')) })
    $container.RegisterFactory("DataManager", { 
        param($c) 
        $dataPath = Join-Path $env:APPDATA "AxiomPhoenix\data.json"
        [DataManager]::new($dataPath, $c.GetService('EventManager'))
    })
    $container.RegisterFactory("FocusManager", { param($c) [FocusManager]::new($c.GetService('EventManager')) })
    $container.RegisterFactory("KeybindingService", { param($c) [KeybindingService]::new($c.GetService('ActionService')) })
    $container.RegisterFactory("DialogManager", { param($c) [DialogManager]::new($c.GetService('EventManager'), $c.GetService('FocusManager')) })
    
    # 3. Register NavigationService last, passing the FULL container
    $container.RegisterFactory("NavigationService", { param($c) [NavigationService]::new($c) })

    # 4. Resolve all services now to make them available globally and perform initialization
    $global:TuiState.Services['Logger'] = $container.GetService('Logger')
    $global:TuiState.Services['EventManager'] = $container.GetService('EventManager')
    $global:TuiState.Services['ThemeManager'] = $container.GetService('ThemeManager')
    $actionService = $container.GetService('ActionService')
    $global:TuiState.Services['ActionService'] = $actionService
    $keybindingService = $container.GetService('KeybindingService')
    $global:TuiState.Services['KeybindingService'] = $keybindingService
    $navigationService = $container.GetService('NavigationService')
    $global:TuiState.Services['NavigationService'] = $navigationService
    $dataManager = $container.GetService('DataManager')
    $global:TuiState.Services['DataManager'] = $dataManager
    # Other services get resolved as needed by the container

    # Initialize default actions and bindings
    $actionService.RegisterDefaultActions()
    $keybindingService.SetDefaultBindings()

    # Register navigation actions (use the resolved service variables)
    $actionService.RegisterAction("navigation.dashboard", {
        $dashboard = [DashboardScreen]::new($container)
        $navigationService.NavigateTo($dashboard)
    }, @{ Category = "Navigation"; Description = "Go to Dashboard" })
    
    $actionService.RegisterAction("navigation.taskList", {
        $taskList = [TaskListScreen]::new($container)
        $navigationService.NavigateTo($taskList)
    }, @{ Category = "Navigation"; Description = "Go to Task List" })

    Write-Host "Services initialized successfully!" -ForegroundColor Green
}
catch { # ... (keep existing catch block)
}
#endregion
```
*And update the `NavigationService` constructor to match this new pattern:*
*   **File:** `AllServices.txt`
*   **Location:** `PAGE: ASE.004` -> `NavigationService` constructor
*   **Action:** Replace the constructor.

```powershell
# Replace the constructor in NavigationService
NavigationService([ServiceContainer]$serviceContainer) {
    $this.Services = @{} # This will be populated by the container
    $this.ServiceContainer = $serviceContainer
    $this.EventManager = $serviceContainer.GetService("EventManager")
}
```

This comprehensive plan addresses all known critical, major, and stability-related issues, integrating every request from the user's prompt. Executing these changes will result in a robust, stable, and functionally complete TUI framework.