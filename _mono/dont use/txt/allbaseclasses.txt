# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#region TuiAnsiHelper - ANSI Code Generation with Truecolor Support
class TuiAnsiHelper {
    static [hashtable] HexToRgb([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor) -or -not $hexColor.StartsWith("#") -or $hexColor.Length -ne 7) {
            return $null
        }
        try {
            return @{
                R = [System.Convert]::ToInt32($hexColor.Substring(1, 2), 16)
                G = [System.Convert]::ToInt32($hexColor.Substring(3, 2), 16)
                B = [System.Convert]::ToInt32($hexColor.Substring(5, 2), 16)
            }
        } catch {
            return $null
        }
    }

    static [string] GetAnsiSequence([string]$fgHex, [string]$bgHex, [hashtable]$attributes) {
        $sequences = [System.Collections.Generic.List[string]]::new()

        if (-not [string]::IsNullOrEmpty($fgHex)) {
            $rgb = [TuiAnsiHelper]::HexToRgb($fgHex)
            if ($rgb) {
                $sequences.Add("38;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        if (-not [string]::IsNullOrEmpty($bgHex)) {
            $rgb = [TuiAnsiHelper]::HexToRgb($bgHex)
            if ($rgb) {
                $sequences.Add("48;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        if ($attributes) {
            if ([bool]($attributes.Bold ?? $false)) { $sequences.Add("1") }
            if ([bool]($attributes.Italic ?? $false)) { $sequences.Add("3") }
            if ([bool]($attributes.Underline ?? $false)) { $sequences.Add("4") }
            if ([bool]($attributes.Strikethrough ?? $false)) { $sequences.Add("9") }
        }

        if ($sequences.Count -eq 0) { return "" }
        return "`e[$($sequences -join ';')m"
    }

    static [string] Reset() { return "`e[0m" }
}
#endregion

#region TuiCell Class - Core Compositor Unit with Truecolor Support
class TuiCell {
    [char] $Char = ' '
    [string] $ForegroundColor = "#FFFFFF"
    [string] $BackgroundColor = "#000000"
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [bool] $Strikethrough = $false
    [int] $ZIndex = 0
    [object] $Metadata = $null

    TuiCell() { }
    TuiCell([char]$char) { $this.Char = $char }

    TuiCell([char]$char, [string]$fg, [string]$bg, [bool]$bold=$false, [bool]$italic=$false, [bool]$underline=$false, [bool]$strikethrough=$false) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Italic = $italic
        $this.Underline = $underline
        $this.Strikethrough = $strikethrough
    }

    TuiCell([TuiCell]$other) {
        $this.Char = $other.Char
        $this.ForegroundColor = $other.ForegroundColor
        $this.BackgroundColor = $other.BackgroundColor
        $this.Bold = $other.Bold
        $this.Underline = $other.Underline
        $this.Italic = $other.Italic
        $this.Strikethrough = $other.Strikethrough
        $this.ZIndex = $other.ZIndex
        $this.Metadata = $other.Metadata
    }

    [TuiCell] BlendWith([TuiCell]$other) {
        if ($null -eq $other) { return $this }

        if ($other.ZIndex > $this.ZIndex) {
            return [TuiCell]::new($other)
        }
        if ($other.ZIndex < $this.ZIndex) {
            return $this
        }

        # Z-Indexes are equal, the top cell ('other') always wins.
        # This is simpler and more correct than the previous logic, as it properly
        # handles cells that are 'transparent' (Char=' ') but have a background color.
        return [TuiCell]::new($other)
    }

    [bool] DiffersFrom([TuiCell]$other) {
        if ($null -eq $other) { return $true }

        return ($this.Char -ne $other.Char -or
                $this.ForegroundColor -ne $other.ForegroundColor -or
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic -or
                $this.Strikethrough -ne $other.Strikethrough -or
                $this.ZIndex -ne $other.ZIndex)
    }

    [string] ToAnsiString() {
        $attributes = @{
            Bold=$this.Bold; Italic=$this.Italic; Underline=$this.Underline; Strikethrough=$this.Strikethrough
        }
        $sequence = [TuiAnsiHelper]::GetAnsiSequence($this.ForegroundColor, $this.BackgroundColor, $attributes)
        return "$sequence$($this.Char)"
    }

    [string] ToString() {
        return "TuiCell(Char='$($this.Char)', FG='$($this.ForegroundColor)', BG='$($this.BackgroundColor)', Z=$($this.ZIndex))"
    }
}
#endregion

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    $Cells
    [int] $Width
    [int] $Height
    [string] $Name
    [bool] $IsDirty = $true

    TuiBuffer([int]$width, [int]$height, [string]$name = "Unnamed") {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        $this.InitializeCells()
    }

    # Copy constructor for safe buffer swapping
    TuiBuffer([TuiBuffer]$other) {
        $this.Width = $other.Width
        $this.Height = $other.Height
        $this.Name = "$($other.Name)_Copy"
        $this.IsDirty = $true
        $this.Cells = New-Object 'System.Object[,]' $this.Height, $this.Width
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($other.Cells[$y, $x])
            }
        }
    }

    hidden [void] InitializeCells() {
        $tempArray = New-Object 'System.Object[,]' $this.Height, $this.Width
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $tempArray[$y, $x] = [TuiCell]::new()
            }
        }
        $this.Cells = $tempArray
    }

    [void] Clear() { $this.Clear([TuiCell]::new()) }

    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell)
            }
        }
        $this.IsDirty = $true
    }

    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) { return $null }
        return $this.Cells[$y, $x]
    }

    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        }
    }

    [void] WriteString([int]$x, [int]$y, [string]$text, [hashtable]$style = @{}) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) { return }

        $fg = $style.FG ?? "#FFFFFF"
        $bg = $style.BG ?? "#000000"
        $bold = [bool]($style.Bold ?? $false)
        $italic = [bool]($style.Italic ?? $false)
        $underline = [bool]($style.Underline ?? $false)
        $strikethrough = [bool]($style.Strikethrough ?? $false)
        $zIndex = [int]($style.ZIndex ?? 0)

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break }
            if ($currentX -ge 0) {
                $cell = [TuiCell]::new($char, $fg, $bg, $bold, $italic, $underline, $strikethrough)
                $cell.ZIndex = $zIndex
                $this.SetCell($currentX, $y, $cell)
            }
            $currentX++
        }
        $this.IsDirty = $true
    }

    [void] BlendBuffer([TuiBuffer]$other, [int]$offsetX, [int]$offsetY) {
        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
        $this.IsDirty = $true
    }

    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { return [TuiBuffer]::new(1, 1, "$($this.Name).Sub_Empty") }
        if ($height -le 0) { return [TuiBuffer]::new(1, 1, "$($this.Name).Sub_Empty") }

        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                if ($sourceCell) {
                    $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
                }
            }
        }
        return $subBuffer
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }

        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height
        $this.Width = $newWidth
        $this.Height = $newHeight
        $this.InitializeCells()
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)

        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }
        $this.IsDirty = $true
    }

    [void] FillRect([int]$x, [int]$y, [int]$width, [int]$height, [char]$char, [hashtable]$style = @{}) {
        if ($width -le 0) { return }
        $charString = [string]$char
        $line = $charString * $width
        for ($py = $y; $py -lt ($y + $height); $py++) {
            $this.WriteString($x, $py, $line, $style)
        }
    }

    [string] ToString() {
        return "TuiBuffer(Name='$($this.Name)', W=$($this.Width), H=$($this.Height), Dirty=$($this.IsDirty))"
    }
}
#endregion

#region UIElement - Base Class for all UI Components
class UIElement {
    [string] $Name = "UIElement"
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 10
    [int] $Height = 3
    [bool] $Visible = $true
    [bool] $Enabled = $true
    [bool] $IsFocusable = $false
    [bool] $IsFocused = $false
    [bool] $IsOverlay = $false
    [int] $TabIndex = 0
    [int] $ZIndex = 0
    [UIElement] $Parent = $null
    [System.Collections.Generic.List[UIElement]] $Children
    [hashtable] $Metadata = @{}

    hidden [TuiBuffer] $_private_buffer
    hidden [bool] $_needs_redraw = $true

    UIElement([string]$name) {
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
    }

    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            if ($current -is [ScrollablePanel]) {
                 # Account for parent's content area and scroll offset
                 $absX += $current.ContentX
                 $absY += $current.ContentY
                 $absY -= $current.ScrollOffsetY
            }
            $current = $current.Parent
        }
        return @{ X = $absX; Y = $absY }
    }

    [void] AddChild([UIElement]$child) {
        if ($child.Parent -ne $null) {
            $child.Parent.RemoveChild($child)
        }
        $child.Parent = $this
        $this.Children.Add($child)
        # Call lifecycle hook
        if ($child.PSObject.Methods.Contains('OnAddedToParent')) {
            $child.OnAddedToParent()
        }
        $this.RequestRedraw()
    }

    [void] RemoveChild([UIElement]$child) {
        if ($this.Children.Remove($child)) {
            $child.Parent = $null
            # Call lifecycle hook
            if ($child.PSObject.Methods.Contains('OnRemovedFromParent')) {
                $child.OnRemovedFromParent()
            }
            $this.RequestRedraw()
        }
    }

    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
        $global:TuiState.IsDirty = $true
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { $newWidth = 1 }
        if ($newHeight -le 0) { $newHeight = 1 }

        if ($this.Width -eq $newWidth -and $this.Height -eq $newHeight) { return }

        $this.Width = $newWidth
        $this.Height = $newHeight
        $this._private_buffer.Resize($newWidth, $newHeight)
        $this.OnResize($newWidth, $newHeight) # Call virtual method for children
        $this.RequestRedraw()
    }

    [void] Render() {
        if (-not $this.Visible) { return }
        $this._RenderContent()
    }

    hidden [void] _RenderContent() {
        if (-not $this.Visible) { return }

        if ($this._needs_redraw) {
            if ($this._private_buffer.Width -ne $this.Width -or $this._private_buffer.Height -ne $this.Height) {
                 $this._private_buffer.Resize($this.Width, $this.Height)
            }
            $this.OnRender()
            $this._needs_redraw = $false
        }

        foreach ($child in $this.Children | Sort-Object ZIndex) {
            if ($child.Visible) {
                $child.Render()
                $this._private_buffer.BlendBuffer($child.GetBuffer(), $child.X, $child.Y)
            }
        }
    }

    [TuiBuffer] GetBuffer() {
        return $this._private_buffer
    }

    # Virtual methods for subclasses to override
    [void] OnRender() { $this._private_buffer.Clear() }
    [void] OnResize([int]$newWidth, [int]$newHeight) { }
    [void] OnFocus() { $this.IsFocused = $true; $this.RequestRedraw() }
    [void] OnBlur() { $this.IsFocused = $false; $this.RequestRedraw() }
    [void] OnAddedToParent() { }
    [void] OnRemovedFromParent() { }
    [void] Cleanup() { }
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) { return $false }

    [string] ToString() {
        return "$($this.GetType().Name)(Name='$($this.Name)', W=$($this.Width), H=$($this.Height))"
    }
}
#endregion

#region Component - A generic container component
class Component : UIElement {
    Component([string]$name) : base($name) { }
}
#endregion

#region Screen - Top-level Container for Application Views
class Screen : UIElement {
    [hashtable]$Services
    [object]$ServiceContainer
    [bool]$_isInitialized = $false

    Screen([string]$name, [object]$serviceContainer) : base($name) {
        $this.ServiceContainer = $serviceContainer
        $this.Services = $serviceContainer.GetAllServicesAsHashtable()
    }

    # Virtual methods for subclasses to override
    [void] Initialize() { }
    [void] OnEnter() { }
    [void] OnExit() { }
    [void] OnResume() { }

    [void] Cleanup() {
        # Base implementation calls Cleanup on all children recursively
        foreach ($child in $this.Children) {
            if ($child.PSObject.Methods.Contains('Cleanup')) {
                $child.Cleanup()
            }
        }
        $this.Children.Clear()
    }
}
#endregion

#region ServiceContainer Class
class ServiceContainer {
    hidden [hashtable] $_services = @{}
    hidden [hashtable] $_serviceFactories = @{}

    [void] Register([string]$name, [object]$serviceInstance) {
        if ($this._services.ContainsKey($name)) { throw "Service '$name' is already registered." }
        $this._services[$name] = $serviceInstance
    }

    [void] RegisterFactory([string]$name, [scriptblock]$factory) {
        if ($this._serviceFactories.ContainsKey($name)) { throw "Factory for '$name' is already registered." }
        $this._serviceFactories[$name] = @{ Factory = $factory; Instance = $null }
    }

    [object] GetService([string]$name) {
        if ($this._services.ContainsKey($name)) {
            return $this._services[$name]
        }

        if ($this._serviceFactories.ContainsKey($name)) {
            $factoryInfo = $this._serviceFactories[$name]
            if ($null -eq $factoryInfo.Instance) {
                $factoryInfo.Instance = & $factoryInfo.Factory $this
            }
            return $factoryInfo.Instance
        }
        throw "Service '$name' not found."
    }

    [hashtable] GetAllServicesAsHashtable() {
        $allServices = @{}
        foreach($key in $this._services.Keys) {
            $allServices[$key] = $this.GetService($key)
        }
        foreach($key in $this._serviceFactories.Keys) {
            if(-not $allServices.ContainsKey($key)) {
                $allServices[$key] = $this.GetService($key)
            }
        }
        return $allServices
    }

    [void] Cleanup() {
        $instancesToClean = $this._services.Values + ($this._serviceFactories.Values | Where-Object { $_.Instance } | ForEach-Object { $_.Instance })
        foreach ($service in $instancesToClean) {
            if ($service -is [System.IDisposable]) {
                $service.Dispose()
            }
            elseif ($service.PSObject.Methods.Contains('Cleanup')) {
                $service.Cleanup()
            }
        }
        $this._services.Clear()
        $this._serviceFactories.Clear()
    }
}
#endregion