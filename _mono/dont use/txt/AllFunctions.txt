# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================

#region TUI Drawing Functions

function Write-TuiText {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][string]$Text,
        [hashtable]$Style = @{}
    )

    # No try/catch needed. If $Buffer.WriteString throws an error,
    # it will propagate up the call stack naturally.
    if ($null -ne $Buffer) {
        $Buffer.WriteString($X, $Y, $Text, $Style)
    }
}

function Write-TuiBox {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [string]$Title = "",
        [hashtable]$Style = @{}
    )

    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) { return }

    # Extract style properties with safe, hex-based defaults
    $borderStyleName = $Style.BorderStyle ?? "Single"
    $borderColor = $Style.BorderFG ?? "#808080"
    $bgColor = $Style.BG ?? "#000000"
    $titleColor = $Style.TitleFG ?? $borderColor
    $fillChar = [char]($Style.FillChar ?? ' ')

    $borders = Get-TuiBorderChars -Style $borderStyleName

    # Define style objects for drawing functions
    $borderStyle = @{ FG = $borderColor; BG = $bgColor }
    $fillStyle = @{ FG = $borderColor; BG = $bgColor } # Fill char uses border FG
    $titleTextStyle = @{ FG = $titleColor; BG = $bgColor }

    # 1. Fill the entire background of the box area first.
    $Buffer.FillRect($X, $Y, $Width, $Height, $fillChar, $fillStyle)

    # 2. Draw borders on top of the fill, handling edge cases.
    # Top and Bottom Borders
    if ($Height -gt 0) {
        if ($Width -gt 1) {
            $hBar = $borders.Horizontal * [Math]::Max(0, $Width - 2)
            Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text "$($borders.TopLeft)$hBar$($borders.TopRight)" -Style $borderStyle
            if ($Height -gt 1) {
                Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$hBar$($borders.BottomRight)" -Style $borderStyle
            }
        } elseif ($Width -eq 1) { # 1-wide box is a vertical line
            Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text $borders.TopLeft -Style $borderStyle
            if ($Height -gt 1) {
                Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text $borders.BottomLeft -Style $borderStyle
            }
        }
    }

    # Left and Right Side Borders
    if ($Width -gt 0 -and $Height -gt 2) {
        for ($i = 1; $i -lt ($Height - 1); $i++) {
            Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $i) -Text $borders.Vertical -Style $borderStyle
            if ($Width -gt 1) {
                Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -Style $borderStyle
            }
        }
    }

    # 3. Draw title if specified.
    if (-not [string]::IsNullOrEmpty($Title) -and $Width -gt 2) {
        $titleText = " $Title "
        if ($titleText.Length -lt $Width) {
            $titleX = $X + 1 + [Math]::Floor(($Width - 2 - $titleText.Length) / 2)
            Write-TuiText -Buffer $Buffer -X $titleX -Y $Y -Text $titleText -Style $titleTextStyle
        }
    }
}


function Get-TuiBorderChars {
    [CmdletBinding()]
    param(
        [ValidateSet("Single", "Double", "Rounded", "Thick")]
        [string]$Style = "Single"
    )

    # No try/catch needed, direct return is cleaner.
    $styles = @{
        Single  = @{ TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'; Horizontal = '─'; Vertical = '│' }
        Double  = @{ TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'; Horizontal = '═'; Vertical = '║' }
        Rounded = @{ TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'; Horizontal = '─'; Vertical = '│' }
        Thick   = @{ TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'; Horizontal = '━'; Vertical = '┃' }
    }
    return $styles[$Style]
}
#endregion

#region Factory Functions

function New-TuiLabel {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Text = "",
        [int]$X = 0,
        [int]$Y = 0,
        [string]$ForegroundColor = $null,
        [string]$BackgroundColor = $null
    )
    $label = [LabelComponent]::new($Name)
    $label.Text = $Text
    $label.X = $X
    $label.Y = $Y
    if ($ForegroundColor) { $label.ForegroundColor = $ForegroundColor }
    if ($BackgroundColor) { $label.BackgroundColor = $BackgroundColor }
    return $label
}

function New-TuiButton {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Text = "Button",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 10,
        [int]$Height = 3,
        [scriptblock]$OnClick = $null
    )
    $button = [ButtonComponent]::new($Name)
    $button.Text = $Text
    $button.X = $X
    $button.Y = $Y
    $button.Width = $Width
    $button.Height = $Height
    if ($OnClick) { $button.OnClick = $OnClick }
    return $button
}
#endregion

#region Theme Functions

function Get-ThemeColor {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$ColorName,
        [string]$DefaultColor = "#808080" # A safe gray
    )

    # This function is now a simple, robust wrapper.
    # The ThemeManager service is responsible for handling all logic and fallbacks.
    $themeManager = $global:TuiState.Services.ThemeManager
    if ($themeManager) {
        # The manager is guaranteed to return a hex string or $null.
        $color = $themeManager.GetColor($ColorName)
        if ($color) {
            return $color
        }
    }
    return $DefaultColor
}
#endregion

#region Utility Functions

function Write-Log {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][ValidateSet('Trace', 'Debug', 'Info', 'Warning', 'Error', 'Fatal')][string]$Level,
        [Parameter(Mandatory)][string]$Message,
        [object]$Data = $null
    )

    $logger = $global:TuiState.Services.Logger
    if ($logger) {
        $finalMessage = $Message
        if ($Data) {
            # Append data to the message for better log correlation.
            $dataJson = $Data | ConvertTo-Json -Compress -Depth 4
            $finalMessage = "$Message | Data: $dataJson"
        }
        $logger.Log($finalMessage, $Level)
    }
}
#endregion

#region Event System

function Subscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [Parameter(Mandatory)][scriptblock]$Handler
    )
    if ($global:TuiState.Services.EventManager) {
        return $global:TuiState.Services.EventManager.Subscribe($EventName, $Handler)
    }
}

function Unsubscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [Parameter(Mandatory)][string]$HandlerId
    )
    if ($global:TuiState.Services.EventManager) {
        $global:TuiState.Services.EventManager.Unsubscribe($EventName, $HandlerId)
    }
}

function Publish-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [hashtable]$EventData = @{}
    )
    if ($global:TuiState.Services.EventManager) {
        $global:TuiState.Services.EventManager.Publish($EventName, $EventData)
    }
}
#endregion