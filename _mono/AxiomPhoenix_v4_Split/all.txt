####\Base\ABC.001_TuiAnsiHelper.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ABC.###" to find specific sections.
# Each section ends with "END_PAGE: ABC.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#region TuiAnsiHelper - ANSI Code Generation with Truecolor Support
class TuiAnsiHelper {
    # No caches needed, sequences are generated dynamically now.

    static [hashtable] HexToRgb([string]$hexColor) {
        if ([string]::IsNullOrEmpty($hexColor) -or -not $hexColor.StartsWith("#") -or $hexColor.Length -ne 7) {
            Write-Log -Level Warning -Message "Invalid hex color format: '$hexColor'"
            return $null
        }
        try {
            return @{
                R = [System.Convert]::ToInt32($hexColor.Substring(1, 2), 16)
                G = [System.Convert]::ToInt32($hexColor.Substring(3, 2), 16)
                B = [System.Convert]::ToInt32($hexColor.Substring(5, 2), 16)
            }
        } catch {
            Write-Log -Level Warning -Message "Error parsing hex color '$hexColor': $($_.Exception.Message)"
            return $null
        }
    }

    static [string] GetAnsiSequence([string]$fgHex, [string]$bgHex, [hashtable]$attributes) {
        $sequences = [System.Collections.Generic.List[string]]::new()

        # Foreground color (Truecolor - SGR 38;2)
        if (-not [string]::IsNullOrEmpty($fgHex)) {
            $rgb = [TuiAnsiHelper]::HexToRgb($fgHex)
            if ($rgb) {
                $sequences.Add("38;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Background color (Truecolor - SGR 48;2)
        if (-not [string]::IsNullOrEmpty($bgHex)) {
            $rgb = [TuiAnsiHelper]::HexToRgb($bgHex)
            if ($rgb) {
                $sequences.Add("48;2;$($rgb.R);$($rgb.G);$($rgb.B)")
            }
        }

        # Style attributes
        if ($attributes) {
            if ($attributes.ContainsKey('Bold') -and [bool]$attributes['Bold']) { $sequences.Add("1") }
            if ($attributes.ContainsKey('Italic') -and [bool]$attributes['Italic']) { $sequences.Add("3") }
            if ($attributes.ContainsKey('Underline') -and [bool]$attributes['Underline']) { $sequences.Add("4") }
            if ($attributes.ContainsKey('Strikethrough') -and [bool]$attributes['Strikethrough']) { $sequences.Add("9") }
        }

        if ($sequences.Count -eq 0) { return "" }
        return "`e[$($sequences -join ';')m"
    }

    static [string] Reset() { return "`e[0m" }
}
#endregion
#<!-- END_PAGE: ABC.001 -->



####\Base\ABC.001a_ServiceContainer.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ABC.###" to find specific sections.
# Each section ends with "END_PAGE: ABC.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#region ServiceContainer Class
class ServiceContainer {
    hidden [hashtable] $_services = @{}
    hidden [hashtable] $_serviceFactories = @{}

    ServiceContainer() {
        # Don't use Write-Log during construction - Logger doesn't exist yet
        Write-Verbose "ServiceContainer: Instance constructed."
    }

    [void] Register([string]$name, [object]$serviceInstance) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }
        if ($null -eq $serviceInstance) { throw [System.ArgumentNullException]::new("serviceInstance") }

        if ($this._services.ContainsKey($name) -or $this._serviceFactories.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("A service or factory with the name '$name' is already registered.")
        }

        $this._services[$name] = $serviceInstance
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Registered eager service instance: '$name'."
        }
        Write-Verbose "ServiceContainer: Registered eager instance for '$name' of type '$($serviceInstance.GetType().Name)'."
    }

    [void] RegisterFactory([string]$name, [scriptblock]$factory, [bool]$isSingleton = $true) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }
        if ($null -eq $factory) { throw [System.ArgumentNullException]::new("factory") }

        if ($this._services.ContainsKey($name) -or $this._serviceFactories.ContainsKey($name)) {
            throw [System.InvalidOperationException]::new("A service or factory with the name '$name' is already registered.")
        }
        
        $this._serviceFactories[$name] = @{
            Factory = $factory
            IsSingleton = $isSingleton
            Instance = $null
        }
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Registered service factory: '$name' (Singleton: $isSingleton)."
        }
        Write-Verbose "ServiceContainer: Registered factory for '$name' (Singleton: $isSingleton)."
    }

    [object] GetService([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) { throw [System.ArgumentException]::new("Parameter 'name' cannot be null or empty.") }

        if ($this._services.ContainsKey($name)) {
            Write-Verbose "ServiceContainer: Returning eager-loaded instance of '$name'."
            return $this._services[$name]
        }

        if ($this._serviceFactories.ContainsKey($name)) {
            return $this._InitializeServiceFromFactory($name, [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase))
        }

        $available = $this.GetAllRegisteredServices() | Select-Object -ExpandProperty Name
        throw [System.InvalidOperationException]::new("Service '$name' not found. Available services: $($available -join ', ')")
    }
    
    [object[]] GetAllRegisteredServices() {
        $list = [System.Collections.Generic.List[object]]::new()
        
        foreach ($key in $this._services.Keys) {
            $list.Add([pscustomobject]@{
                Name = $key
                Type = 'Instance'
                Initialized = $true
                Lifestyle = 'Singleton'
            })
        }
        
        foreach ($key in $this._serviceFactories.Keys) {
            $factoryInfo = $this._serviceFactories[$key]
            $list.Add([pscustomobject]@{
                Name = $key
                Type = 'Factory'
                Initialized = ($null -ne $factoryInfo.Instance)
                Lifestyle = if ($factoryInfo.IsSingleton) { 'Singleton' } else { 'Transient' }
            })
        }
        
        return $list.ToArray() | Sort-Object Name
    }

    [void] Cleanup() {
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer cleanup initiated."
        }
        Write-Verbose "ServiceContainer: Initiating cleanup of disposable singleton services."
        
        $instancesToClean = [System.Collections.Generic.List[object]]::new()
        $this._services.Values | ForEach-Object { $instancesToClean.Add($_) }
        $this._serviceFactories.Values | Where-Object { $_.IsSingleton -and $_.Instance } | ForEach-Object { $instancesToClean.Add($_.Instance) }

        foreach ($service in $instancesToClean) {
            if ($service -is [System.IDisposable]) {
                try {
                    Write-Verbose "ServiceContainer: Disposing service of type '$($service.GetType().FullName)'."
                    $service.Dispose()
                } catch {
                    if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                        Write-Log -Level Error -Message "Error disposing service of type '$($service.GetType().FullName)': $($_.Exception.Message)"
                    }
                }
            }
        }
        
        $this._services.Clear()
        $this._serviceFactories.Clear()
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "ServiceContainer cleanup complete."
        }
        Write-Verbose "ServiceContainer: Cleanup complete. All service registries cleared."
    }

    hidden [object] _InitializeServiceFromFactory([string]$name, [System.Collections.Generic.HashSet[string]]$resolutionChain) {
        $factoryInfo = $this._serviceFactories[$name]
        
        if ($factoryInfo.IsSingleton -and $null -ne $factoryInfo.Instance) {
            Write-Verbose "ServiceContainer: Returning cached singleton instance of '$name'."
            return $factoryInfo.Instance
        }

        if ($resolutionChain.Contains($name)) {
            $chain = ($resolutionChain -join ' -> ') + " -> $name"
            throw [System.InvalidOperationException]::new("Circular dependency detected while resolving service '$name'. Chain: $chain")
        }
        [void]$resolutionChain.Add($name)
        
        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Instantiating service '$name' from factory."
        }
        Write-Verbose "ServiceContainer: Invoking factory to create instance of '$name'."
        
        $serviceInstance = & $factoryInfo.Factory $this

        if ($factoryInfo.IsSingleton) {
            $factoryInfo.Instance = $serviceInstance
            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Cached singleton instance of service '$name'."
            }
            Write-Verbose "ServiceContainer: Cached new singleton instance of '$name'."
        }

        [void]$resolutionChain.Remove($name)
        
        return $serviceInstance
    }
}
#endregion
#<!-- END_PAGE: ABC.007 -->



####\Base\ABC.002_TuiCell.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ABC.###" to find specific sections.
# Each section ends with "END_PAGE: ABC.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#region TuiCell Class - Core Compositor Unit with Truecolor Support
class TuiCell {
    [char] $Char = ' '
    [string] $ForegroundColor = "#FFFFFF" # Changed to string for hex color
    [string] $BackgroundColor = "#000000" # Changed to string for hex color
    [bool] $Bold = $false
    [bool] $Underline = $false
    [bool] $Italic = $false
    [bool] $Strikethrough = $false # NEW Property for additional style
    [int] $ZIndex = 0        
    [object] $Metadata = $null 

    TuiCell() { }
    TuiCell([char]$char) { $this.Char = $char }
    
    # Constructor with 3 parameters (char, fg, bg)
    TuiCell([char]$char, [string]$fg, [string]$bg) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
    }
    
    # Constructor with 4 parameters (char, fg, bg, bold)
    TuiCell([char]$char, [string]$fg, [string]$bg, [bool]$bold) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
    }
    
    # Full constructor with all parameters
    TuiCell([char]$char, [string]$fg, [string]$bg, [bool]$bold, [bool]$italic, [bool]$underline, [bool]$strikethrough) {
        $this.Char = $char
        $this.ForegroundColor = $fg
        $this.BackgroundColor = $bg
        $this.Bold = $bold
        $this.Italic = $italic
        $this.Underline = $underline
        $this.Strikethrough = $strikethrough # Assign new property
    }
    
    # Copy Constructor: Ensure it copies all new properties
    TuiCell([object]$other) {
        $this.Char = $other.Char
        $this.ForegroundColor = $other.ForegroundColor
        $this.BackgroundColor = $other.BackgroundColor
        $this.Bold = $other.Bold
        $this.Underline = $other.Underline
        $this.Italic = $other.Italic
        $this.Strikethrough = $other.Strikethrough # Make sure this is copied
        $this.ZIndex = $other.ZIndex
        $this.Metadata = $other.Metadata
    }

    [TuiCell] WithStyle([string]$fg, [string]$bg) { # Parameter types changed
        $copy = [TuiCell]::new($this)
        $copy.ForegroundColor = $fg
        $copy.BackgroundColor = $bg
        return $copy
    }

    [TuiCell] WithChar([char]$char) {
        $copy = [TuiCell]::new($this)
        $copy.Char = $char
        return $copy
    }

    [TuiCell] BlendWith([object]$other) {
        if ($null -eq $other) { return $this }
        
        # If Z-Indexes are different, the higher one wins.
        if ($other.ZIndex -gt $this.ZIndex) { return [TuiCell]::new($other) }
        if ($other.ZIndex -lt $this.ZIndex) { return $this }

        # If Z-Indexes are the same, the 'other' (top) cell wins by default.
        # This is the most common and intuitive blending mode.
        # A more advanced system could check for a special transparent color.
        return [TuiCell]::new($other)
    }

    [bool] DiffersFrom([object]$other) {
        if ($null -eq $other) { return $true }
        
        return ($this.Char -ne $other.Char -or 
                $this.ForegroundColor -ne $other.ForegroundColor -or 
                $this.BackgroundColor -ne $other.BackgroundColor -or
                $this.Bold -ne $other.Bold -or
                $this.Underline -ne $other.Underline -or
                $this.Italic -ne $other.Italic -or
                $this.Strikethrough -ne $other.Strikethrough -or # NEW: Compare Strikethrough
                $this.ZIndex -ne $other.ZIndex)
    }

    [string] ToAnsiString() {
        # This is the crucial update to use the new TuiAnsiHelper.GetAnsiSequence
        $attributes = @{ 
            Bold=$this.Bold; Italic=$this.Italic; Underline=$this.Underline; Strikethrough=$this.Strikethrough 
        }
        $sequence = [TuiAnsiHelper]::GetAnsiSequence($this.ForegroundColor, $this.BackgroundColor, $attributes)
        return "$sequence$($this.Char)" # Append character directly
    }

    [hashtable] ToLegacyFormat() {
        return @{ Char = $this.Char; FG = $this.ForegroundColor; BG = $this.BackgroundColor }
    }
    
    [string] ToString() {
        return "TuiCell(Char='$($this.Char)', FG='$($this.ForegroundColor)', BG='$($this.BackgroundColor)', Bold=$($this.Bold), Underline=$($this.Underline), Italic=$($this.Italic), Strikethrough=$($this.Strikethrough), ZIndex=$($this.ZIndex))"
    }
}
#endregion
#<!-- END_PAGE: ABC.002 -->



####\Base\ABC.003_TuiBuffer.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ABC.###" to find specific sections.
# Each section ends with "END_PAGE: ABC.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#region TuiBuffer Class - 2D Array of TuiCells
class TuiBuffer {
    $Cells       # 2D array of TuiCells - no type constraint to avoid assignment issues
    [int] $Width             
    [int] $Height            
    [string] $Name            
    [bool] $IsDirty = $true  

    # Constructor with 2 parameters
    TuiBuffer([int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.Width = $width
        $this.Height = $height
        $this.Name = "Unnamed"
        # Initialize cells in a simple way
        $this.InitializeCells()
        # Write-Verbose "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
    }

    # Constructor with 3 parameters
    TuiBuffer([int]$width, [int]$height, [string]$name) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.Width = $width
        $this.Height = $height
        $this.Name = $name
        # Initialize cells in a simple way
        $this.InitializeCells()
        # Write-Verbose "TuiBuffer '$($this.Name)' initialized with dimensions: $($this.Width)x$($this.Height)."
    }

    hidden [void] InitializeCells() {
        # Create 2D array step by step to avoid assignment issues
        $tempArray = New-Object 'System.Object[,]' $this.Height,$this.Width
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $tempArray[$y,$x] = [TuiCell]::new()
            }
        }
        $this.Cells = $tempArray
    }

    [void] Clear() { $this.Clear([TuiCell]::new()) }

    [void] Clear([TuiCell]$fillCell) {
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this.Cells[$y, $x] = [TuiCell]::new($fillCell) 
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "TuiBuffer '$($this.Name)' cleared with specified cell."
    }

    [TuiCell] GetCell([int]$x, [int]$y) {
        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) { return [TuiCell]::new() }
        return $this.Cells[$y, $x]
    }

    [void] SetCell([int]$x, [int]$y, [TuiCell]$cell) {
        if ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height) {
            $this.Cells[$y, $x] = $cell
            $this.IsDirty = $true
        } else {
            Write-Log -Level Warning -Message "Attempted to set cell out of bounds in TuiBuffer '$($this.Name)': ($x, $y) is outside 0..$($this.Width-1), 0..$($this.Height-1). Cell: '$($cell.Char)'."
        }
    }

    [void] WriteString([int]$x, [int]$y, [string]$text, [hashtable]$style = @{}) {
        if ([string]::IsNullOrEmpty($text) -or $y -lt 0 -or $y -ge $this.Height) {
            Write-Log -Level Debug -Message "WriteString: Skipped for buffer '$($this.Name)' due to empty text or out-of-bounds Y."
            return
        }
        
        # Extract properties from the style object, providing safe defaults (now expecting hex colors)
        # Use hashtable indexing syntax to avoid "property not found" errors
        $fg = if ($style.ContainsKey('FG')) { $style['FG'] } else { "#FFFFFF" } # Default Foreground hex
        $bg = if ($style.ContainsKey('BG')) { $style['BG'] } else { "#000000" } # Default Background hex
        $bold = if ($style.ContainsKey('Bold')) { [bool]$style['Bold'] } else { $false }
        $italic = if ($style.ContainsKey('Italic')) { [bool]$style['Italic'] } else { $false }
        $underline = if ($style.ContainsKey('Underline')) { [bool]$style['Underline'] } else { $false }
        $strikethrough = if ($style.ContainsKey('Strikethrough')) { [bool]$style['Strikethrough'] } else { $false }
        $zIndex = if ($style.ContainsKey('ZIndex')) { [int]$style['ZIndex'] } else { 0 }

        $currentX = $x
        foreach ($char in $text.ToCharArray()) {
            if ($currentX -ge $this.Width) { break } 
            if ($currentX -ge 0) {
                # Pass all style parameters to TuiCell constructor
                $cell = [TuiCell]::new($char, $fg, $bg, $bold, $italic, $underline, $strikethrough)
                $cell.ZIndex = $zIndex # Assign ZIndex
                $this.SetCell($currentX, $y, $cell)
            }
            $currentX++
        }
        $this.IsDirty = $true
        Write-Log -Level Debug -Message "WriteString: Wrote '$text' to buffer '$($this.Name)' at ($x, $y)."
    }

    [void] BlendBuffer([object]$other, [int]$offsetX, [int]$offsetY) {
        for ($y = 0; $y -lt $other.Height; $y++) {
            for ($x = 0; $x -lt $other.Width; $x++) {
                $targetX = $offsetX + $x
                $targetY = $offsetY + $y
                if ($targetX -ge 0 -and $targetX -lt $this.Width -and $targetY -ge 0 -and $targetY -lt $this.Height) {
                    $sourceCell = $other.GetCell($x, $y)
                    $targetCell = $this.GetCell($targetX, $targetY)
                    $blendedCell = $targetCell.BlendWith($sourceCell)
                    $this.SetCell($targetX, $targetY, $blendedCell)
                }
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "BlendBuffer: Blended buffer '$($other.Name)' onto '$($this.Name)' at ($offsetX, $offsetY)."
    }

    [TuiBuffer] GetSubBuffer([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $subBuffer = [TuiBuffer]::new($width, $height, "$($this.Name).Sub")
        for ($sy = 0; $sy -lt $height; $sy++) {
            for ($sx = 0; $sx -lt $width; $sx++) {
                $sourceCell = $this.GetCell($x + $sx, $y + $sy)
                $subBuffer.SetCell($sx, $sy, [TuiCell]::new($sourceCell))
            }
        }
        # Write-Verbose "GetSubBuffer: Created sub-buffer '$($subBuffer.Name)' from '$($this.Name)' at ($x, $y) with dimensions $($width)x$($height)."
        return $subBuffer
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        $oldCells = $this.Cells
        $oldWidth = $this.Width
        $oldHeight = $this.Height
        $this.Width = $newWidth
        $this.Height = $newHeight
        # Create new 2D array using helper method
        $this.InitializeCells()
        $copyWidth = [Math]::Min($oldWidth, $newWidth)
        $copyHeight = [Math]::Min($oldHeight, $newHeight)
        for ($y = 0; $y -lt $copyHeight; $y++) {
            for ($x = 0; $x -lt $copyWidth; $x++) {
                $this.Cells[$y, $x] = $oldCells[$y, $x]
            }
        }
        $this.IsDirty = $true
        # Write-Verbose "TuiBuffer '$($this.Name)' resized from $($oldWidth)x$($oldHeight) to $($newWidth)x$($newHeight)."
    }

    [string] ToString() {
        return "TuiBuffer(Name='$($this.Name)', Width=$($this.Width), Height=$($this.Height), IsDirty=$($this.IsDirty))"
    }

    # Additional helper methods needed by rendering pipeline
    [void] DrawText([int]$x, [int]$y, [string]$text, [hashtable]$style = @{}) {
        $this.WriteString($x, $y, $text, $style)
    }
    
    [void] DrawBox([int]$x, [int]$y, [int]$width, [int]$height, [hashtable]$style = @{}) {
        # This will now internally call the new Write-TuiBox function in AllFunctions.ps1
        # It's better to delegate complex drawing like boxes to the global functions.
        Write-TuiBox -Buffer $this -X $x -Y $y -Width $width -Height $height -Style $style
    }
    
    [void] FillRect([int]$x, [int]$y, [int]$width, [int]$height, [char]$char, [hashtable]$style = @{}) {
        # Create a single character string and use WriteString to fill the rectangle
        # This simplifies the logic by leveraging WriteString's styling capabilities.
        $charString = "$char" # Convert char to string
        for ($py = $y; $py -lt $y + $height; $py++) {
            # Write a line of characters
            $this.WriteString($x, $py, $charString * $width, $style)
        }
    }
    
    [TuiBuffer] Clone() {
        $clone = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name)_Clone")
        for ($y = 0; $y -lt $this.Height; $y++) {
            for ($x = 0; $x -lt $this.Width; $x++) {
                $clone.Cells[$y, $x] = [TuiCell]::new($this.Cells[$y, $x])
            }
        }
        return $clone
    }
}
#endregion
#<!-- END_PAGE: ABC.003 -->



####\Base\ABC.004_UIElement.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ABC.###" to find specific sections.
# Each section ends with "END_PAGE: ABC.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#region UIElement - Base Class for all UI Components

# ==============================================================================
# CLASS: UIElement
#
# INHERITS:
#   - None (base class)
#
# DEPENDENCIES:
#   Classes:
#     - TuiBuffer (ABC.003)
#     - TuiCell (ABC.002)
#   Services:
#     - TuiFrameworkService (ASE.010) - for dimension access
#
# PURPOSE:
#   Foundation class for all UI components in the framework. Provides core
#   functionality for positioning, sizing, visibility, focus management,
#   hierarchical parent-child relationships, and the rendering lifecycle.
#
# KEY LOGIC:
#   - OnRender: Override to define component-specific rendering
#   - _RenderContent: Core rendering pipeline with optimization
#   - HandleInput: Process keyboard/mouse input
#   - AddChild/RemoveChild: Manage component hierarchy
#   - RequestRedraw: Mark component as needing redraw
#   - Lifecycle: Initialize → OnRender → HandleInput → Cleanup
# ==============================================================================
class UIElement {
    [string] $Name = "UIElement" 
    [int] $X = 0               
    [int] $Y = 0               
    [int] $Width = 30          
    [int] $Height = 10          
    [bool] $Visible = $true    
    [bool] $Enabled = $true    
    [bool] $IsFocusable = $false 
    [bool] $IsFocused = $false  
    [bool] $IsOverlay = $false
    [int] $TabIndex = 0        
    [int] $ZIndex = 0          
    [UIElement] $Parent = $null 
    [System.Collections.Generic.List[UIElement]] $Children 
    
    hidden [object] $_private_buffer = $null
    hidden [bool] $_needs_redraw = $true
    
    [hashtable] $Metadata = @{} 

    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        # Write-Verbose "UIElement 'Unnamed' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([string]$name) {
        $this.Name = $name
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($this.Width, $this.Height, "$($this.Name).Buffer")
        # Write-Verbose "UIElement '$($this.Name)' created with default size ($($this.Width)x$($this.Height))."
    }

    UIElement([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($width -le 0) { throw [System.ArgumentOutOfRangeException]::new("width", "Width must be positive.") }
        if ($height -le 0) { throw [System.ArgumentOutOfRangeException]::new("height", "Height must be positive.") }
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
        $this._private_buffer = [TuiBuffer]::new($width, $height, "Unnamed.Buffer")
        # Write-Verbose "UIElement 'Unnamed' created at ($x, $y) with dimensions $($width)x$($height)."
    }

    [hashtable] GetAbsolutePosition() {
        $absX = $this.X
        $absY = $this.Y
        $current = $this.Parent
        while ($null -ne $current) {
            $absX += $current.X
            $absY += $current.Y
            $current = $current.Parent
        }
        return @{ X = $absX; Y = $absY }
    }

    [void] AddChild([object]$child) {
        try {
            if ($child -eq $this) { throw [System.ArgumentException]::new("Cannot add an element as its own child.") }
            if ($this.Children.Contains($child)) {
                Write-Warning "Child '$($child.Name)' is already a child of '$($this.Name)'. Skipping addition."
                return
            }
            if ($child.Parent -ne $null) {
                Write-Warning "Child '$($child.Name)' already has a parent ('$($child.Parent.Name)'). Consider removing it from its current parent first."
            }
            $child.Parent = $this
            $this.Children.Add($child)
            
            # Call the lifecycle hook if the child has it defined
            if ($child.PSObject.Methods['AddedToParent']) {
                try {
                    $child.AddedToParent()
                }
                catch {
                    Write-Warning "Error calling AddedToParent on child '$($child.Name)': $($_.Exception.Message)"
                }
            }
            
            $this.RequestRedraw()
            # Write-Verbose "Added child '$($child.Name)' to parent '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add child '$($child.Name)' to '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] RemoveChild([object]$child) {
        try {
            if ($this.Children.Remove($child)) {
                $child.Parent = $null
                
                # Call the lifecycle hook if the child has it defined
                if ($child.PSObject.Methods['RemovedFromParent']) {
                    try {
                        $child.RemovedFromParent()
                    }
                    catch {
                        Write-Warning "Error calling RemovedFromParent on child '$($child.Name)': $($_.Exception.Message)"
                    }
                }
                
                $this.RequestRedraw()
                # Write-Verbose "Removed child '$($child.Name)' from parent '$($this.Name)'."
            } else {
                Write-Warning "Child '$($child.Name)' not found in parent '$($this.Name)' for removal. No action taken."
            }
        }
        catch {
            Write-Error "Failed to remove child '$($child.Name)' from '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] RequestRedraw() {
        $this._needs_redraw = $true
        if ($null -ne $this.Parent) {
            $this.Parent.RequestRedraw()
        }
        # Write-Verbose "Redraw requested for '$($this.Name)'."
    }

    [void] Resize([int]$newWidth, [int]$newHeight) {
        if ($newWidth -le 0) { throw [System.ArgumentOutOfRangeException]::new("newWidth", "New width must be positive.") }
        if ($newHeight -le 0) { throw [System.ArgumentOutOfRangeException]::new("newHeight", "New height must be positive.") }
        try {
            if ($this.Width -eq $newWidth -and $this.Height -eq $newHeight) {
                Write-Verbose "Resize: Component '$($this.Name)' already has target dimensions ($($newWidth)x$($newHeight)). No change."
                return
            }
            $this.Width = $newWidth
            $this.Height = $newHeight
            if ($null -ne $this._private_buffer) {
                $this._private_buffer.Resize($newWidth, $newHeight)
            } else {
                $this._private_buffer = [TuiBuffer]::new($newWidth, $newHeight, "$($this.Name).Buffer")
                # Write-Verbose "Re-initialized buffer for '$($this.Name)' due to null buffer."
            }
            $this.RequestRedraw()
            $this.OnResize($newWidth, $newHeight)
            # Write-Verbose "Component '$($this.Name)' resized to $($newWidth)x$($newHeight)."
        }
        catch {
            Write-Error "Failed to resize component '$($this.Name)' to $($newWidth)x$($newHeight): $($_.Exception.Message)"
            throw
        }
    }

    [void] Move([int]$newX, [int]$newY) {
        if ($this.X -eq $newX -and $this.Y -eq $newY) {
            # Write-Verbose "Move: Component '$($this.Name)' already at target position ($($newX), $($newY)). No change."
            return
        }
        $this.X = $newX
        $this.Y = $newY
        $this.RequestRedraw()
        $this.OnMove($newX, $newY)
        # Write-Verbose "Component '$($this.Name)' moved to ($newX, $newY)."
    }

    [bool] ContainsPoint([int]$x, [int]$y) {
        return ($x -ge 0 -and $x -lt $this.Width -and $y -ge 0 -and $y -lt $this.Height)
    }

    [object] GetChildAtPoint([int]$x, [int]$y) {
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible -and $child.ContainsPoint($x - $child.X, $y - $child.Y)) {
                return $child
            }
        }
        return $null
    }

    [void] OnRender() 
    {
        if ($null -ne $this._private_buffer) {
            $this._private_buffer.Clear()
        }
        # Write-Verbose "OnRender called for '$($this.Name)': Default buffer clear."
    }

    [void] OnResize([int]$newWidth, [int]$newHeight) 
    {
        # Write-Verbose "OnResize called for '$($this.Name)': No custom resize logic."
    }

    [void] OnMove([int]$newX, [int]$newY) 
    {
        # Write-Verbose "OnMove called for '$($this.Name)': No custom move logic."
    }

    [void] OnFocus() 
    { 
        # Write-Verbose "OnFocus called for '$($this.Name)'." 
    }
    
    [void] OnBlur() 
    { 
        # Write-Verbose "OnBlur called for '$($this.Name)'." 
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) 
    {
        # Write-Verbose "HandleInput called for '$($this.Name)': Key: $($keyInfo.Key)."
        return $false
    }

    [void] Cleanup()
    {
        # Cleanup all children recursively
        foreach ($child in $this.Children) {
            if ($child.PSObject.Methods['Cleanup']) {
                try { 
                    $child.Cleanup() 
                } 
                catch { 
                    Write-Warning "Failed to cleanup child '$($child.Name)': $($_.Exception.Message)" 
                }
            }
        }
        
        # Clear references
        $this.Children.Clear()
        $this.Parent = $null
        $this._private_buffer = $null
        
        # Write-Verbose "Cleanup completed for UIElement '$($this.Name)'."
    }

    [void] Render() 
    {
        if (-not $this.Visible) { 
            # Write-Verbose "Skipping Render for '$($this.Name)': Not visible."
            return 
        }
        $this._RenderContent() 
    }

    hidden [void] _RenderContent() 
    {
        if (-not $this.Visible) { return }
        
        # Phase 1: Render Self (if needed)
        $parentDidRedraw = $false
        if ($this._needs_redraw -or ($null -eq $this._private_buffer) -or 
            ($this._private_buffer.Width -ne $this.Width) -or 
            ($this._private_buffer.Height -ne $this.Height)) {
            
            try {
                # Ensure buffer exists and is correct size
                if ($null -eq $this._private_buffer -or 
                    $this._private_buffer.Width -ne $this.Width -or 
                    $this._private_buffer.Height -ne $this.Height) {
                    
                    $bufferWidth = [Math]::Max(1, $this.Width)
                    $bufferHeight = [Math]::Max(1, $this.Height)
                    $this._private_buffer = [TuiBuffer]::new($bufferWidth, $bufferHeight, "$($this.Name).Buffer")
                    
                    if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                        Write-Log -Level Debug -Message "UIElement '$($this.Name)': Buffer resized to ${bufferWidth}x${bufferHeight}"
                    }
                }
                
                # Render component content
                $this.OnRender()
                $parentDidRedraw = $true
                
                if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                    Write-Log -Level Debug -Message "UIElement '$($this.Name)': Rendered own content"
                }
            }
            catch {
                if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                    Write-Log -Level Error -Message "UIElement '$($this.Name)': OnRender() failed: $($_.Exception.Message)"
                }
                throw
            }
        }
        
        # Phase 2: Render and Blend Children (with optimization)
        foreach ($child in $this.Children | Sort-Object ZIndex) {
            if ($child.Visible) {
                try {
                    # Always recurse to allow children to render if they need to
                    $child._RenderContent()
                    
                    # OPTIMIZATION: Only blend if parent redrew OR child redrew
                    $childNeedsBlending = $parentDidRedraw -or $child._needs_redraw
                    
                    if ($childNeedsBlending -and $null -ne $child._private_buffer) {
                        # Bounds checking for child position
                        if ($child.X -lt $this.Width -and $child.Y -lt $this.Height -and 
                            $child.X + $child.Width -gt 0 -and $child.Y + $child.Height -gt 0) {
                            
                            $this._private_buffer.BlendBuffer($child._private_buffer, $child.X, $child.Y)
                            
                            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                                Write-Log -Level Debug -Message "UIElement '$($this.Name)': Blended child '$($child.Name)' at ($($child.X), $($child.Y))"
                            }
                        }
                        else {
                            if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                                Write-Log -Level Debug -Message "UIElement '$($this.Name)': Child '$($child.Name)' is out of bounds, skipping blend"
                            }
                        }
                    }
                }
                catch {
                    if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                        Write-Log -Level Error -Message "UIElement '$($this.Name)': Error rendering child '$($child.Name)': $($_.Exception.Message)"
                    }
                    # Continue with other children even if one fails
                }
            }
        }
        
        # Phase 3: Reset redraw flag for next frame
        $this._needs_redraw = $false
    }

    [object] GetBuffer() 
    { 
        return $this._private_buffer 
    }
    
    [string] ToString() 
    {
        return "$($this.GetType().Name)(Name='$($this.Name)', X=$($this.X), Y=$($this.Y), Width=$($this.Width), Height=$($this.Height), Visible=$($this.Visible))"
    }
}
#endregion
#<!-- END_PAGE: ABC.004 -->



####\Base\ABC.005_Component.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ABC.###" to find specific sections.
# Each section ends with "END_PAGE: ABC.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#region Component - A generic container component
class Component : UIElement {
    Component([string]$name) : base($name) {
        $this.Name = $name
        # Write-Verbose "Component '$($this.Name)' created."
    }

    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent()
        # Write-Verbose "_RenderContent called for Component '$($this.Name)' (delegating to base UIElement)."
    }

    [string] ToString() {
        return "Component(Name='$($this.Name)', Children=$($this.Children.Count))"
    }
}
#endregion
#<!-- END_PAGE: ABC.005 -->



####\Base\ABC.006_Screen.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Base Classes (Load First)
# Core framework classes with NO external dependencies
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ABC.###" to find specific sections.
# Each section ends with "END_PAGE: ABC.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

# Disable verbose output during TUI rendering
$script:TuiVerbosePreference = 'SilentlyContinue'

#region Screen - Top-level Container for Application Views

# ==============================================================================
# CLASS: Screen
#
# INHERITS:
#   - UIElement (ABC.004)
#
# DEPENDENCIES:
#   Classes:
#     - UIElement (ABC.004)
#     - ServiceContainer (ABC.007)
#   Services:
#     - All registered services via ServiceContainer
#
# PURPOSE:
#   Top-level container for application views. Screens represent complete
#   UI states (like Dashboard, Task List, Settings) and integrate with the
#   service container for dependency injection.
#
# KEY LOGIC:
#   - Initialize: Set up screen resources and state
#   - OnEnter: Called when navigating to this screen
#   - OnExit: Called when leaving this screen
#   - HandleInput: Process screen-level input
#   - SubscribeToEvent: Register for application events
#   - Cleanup: Unsubscribe from events and release resources
# ==============================================================================
class Screen : UIElement {
    [object]$ServiceContainer # Changed to object to avoid type conversion issues
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[UIElement]] $Panels
    [bool]$IsOverlay = $false  # NEW: Indicates if this screen renders as an overlay
    
    $LastFocusedComponent
    
    hidden [bool] $_isInitialized = $false
    hidden [System.Collections.Generic.Dictionary[string, string]] $EventSubscriptions 

    # Primary constructor - takes ServiceContainer directly
    Screen([string]$name, [object]$serviceContainer) : base($name) {
        if ($null -eq $serviceContainer) {
            throw [System.ArgumentNullException]::new("serviceContainer")
        }
        # Verify it's actually a ServiceContainer at runtime
        if ($serviceContainer.GetType().Name -ne 'ServiceContainer') {
            throw [System.ArgumentException]::new("Expected ServiceContainer but got $($serviceContainer.GetType().Name)")
        }
        $this.ServiceContainer = $serviceContainer
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        # Set initial screen dimensions to console size
        $this.Width = [Math]::Max(80, [Console]::WindowWidth)
        $this.Height = [Math]::Max(24, [Console]::WindowHeight)
        # Write-Verbose "Screen '$($this.Name)' created with ServiceContainer."
    }

    # Legacy constructor for backward compatibility (deprecated)
    Screen([string]$name, [hashtable]$services) : base($name) {
        Write-Warning "Screen '$($this.Name)': Using deprecated hashtable constructor. Please update to use ServiceContainer."
        # This constructor is kept for backward compatibility but should be removed in future versions
        $this.ServiceContainer = $null
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[UIElement]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
        # Set initial screen dimensions to console size
        $this.Width = [Math]::Max(80, [Console]::WindowWidth)
        $this.Height = [Math]::Max(24, [Console]::WindowHeight)
    }

    [void] Initialize() { 
        # Write-Verbose "Initialize called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnEnter() { 
        # Write-Verbose "OnEnter called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnExit() { 
        # Write-Verbose "OnExit called for Screen '$($this.Name)': Default (no-op)." 
    }
    [void] OnResume() { 
        # Write-Verbose "OnResume called for Screen '$($this.Name)': Default (no-op)." 
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Base implementation - screens should override this
        return $false
    }

    [void] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo) {
        $this.HandleInput($keyInfo)
    }

    [void] HandleResize([int]$newWidth, [int]$newHeight) {
        $this.Resize($newWidth, $newHeight)
    }

    [void] Cleanup() {
        try {
            # Write-Verbose "Cleanup called for Screen '$($this.Name)'."
            
            # Screen-specific cleanup: Unsubscribe from events
            foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
                try {
                    if (Get-Command 'Unsubscribe-Event' -ErrorAction SilentlyContinue) {
                        Unsubscribe-Event -EventName $kvp.Key -HandlerId $kvp.Value
                        Write-Verbose "Unsubscribed event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)'."
                    }
                }
                catch {
                    Write-Warning "Failed to unsubscribe event '$($kvp.Key)' (HandlerId: $($kvp.Value)) for screen '$($this.Name)': $($_.Exception.Message)"
                }
            }
            $this.EventSubscriptions.Clear()
            
            # Clear screen-specific collections
            $this.Panels.Clear()
            $this.State.Clear()
            
            # Call base UIElement cleanup (handles children recursively)
            ([UIElement]$this).Cleanup()
            
            Write-Verbose "Cleaned up resources for screen: $($this.Name)."
        }
        catch {
            Write-Error "Error during Cleanup for screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] AddPanel([object]$panel) {
        try {
            $this.Panels.Add($panel)
            $this.AddChild($panel) 
            Write-Verbose "Added panel '$($panel.Name)' to screen '$($this.Name)'."
        }
        catch {
            Write-Error "Failed to add panel '$($panel.Name)' to screen '$($this.Name)': $($_.Exception.Message)"
            throw
        }
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        try {
            if (Get-Command 'Subscribe-Event' -ErrorAction SilentlyContinue) {
                $subscriptionId = Subscribe-Event -EventName $eventName -Handler $action -Source $this.Name
                $this.EventSubscriptions[$eventName] = $subscriptionId
                Write-Verbose "Screen '$($this.Name)' subscribed to event '$eventName' with HandlerId: $subscriptionId."
            } else {
                Write-Warning "Subscribe-Event function not available. Event subscription for '$eventName' failed."
            }
        }
        catch {
            Write-Error "Failed for screen '$($this.Name)' to subscribe to event '$eventName': $($_.Exception.Message)"
            throw
        }
    }
    
    hidden [void] _RenderContent() {
        ([UIElement]$this)._RenderContent()
        Write-Verbose "_RenderContent called for Screen '$($this.Name)' (rendering UIElement children, including panels)."
    }

    [string] ToString() {
        $panelCount = if ($this.Panels) { $this.Panels.Count } else { 0 }
        return "Screen(Name='$($this.Name)', Panels=$panelCount, Visible=$($this.Visible))"
    }

    [void] Render([TuiBuffer]$buffer) {
        # First render self
        $this._RenderContent()
        
        # Then blend our buffer onto the target
        if ($null -ne $this._private_buffer) {
            $buffer.BlendBuffer($this._private_buffer, 0, 0)
        }
    }
}
#endregion
#<!-- END_PAGE: ABC.006 -->



####\Components\ACO.001_LabelComponent.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

#region Core UI Components

# ===== CLASS: LabelComponent =====
# Module: tui-components
# Dependencies: UIElement
# Purpose: Static text display
class LabelComponent : UIElement {
    [string]$Text = ""
    [object]$ForegroundColor
    [object]$BackgroundColor = $null

    LabelComponent([string]$name) : base($name) {
        $this.IsFocusable = $false
        $this.Width = 30  # Increased default width
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Get background color
        if ($this.BackgroundColor) {
            if ($this.BackgroundColor -is [ConsoleColor]) {
                $bgColor = Get-ThemeColor("component.background") # Use theme default instead
            } else {
                $bgColor = $this.BackgroundColor # Assume it's already hex
            }
        } else {
            $bgColor = Get-ThemeColor("component.background")
        }
        
        # Clear buffer with background color
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Skip rendering if text is empty
        if ([string]::IsNullOrEmpty($this.Text)) {
            $this._needs_redraw = $false
            return
        }
        
        # Get foreground color
        if ($this.ForegroundColor) {
            if ($this.ForegroundColor -is [ConsoleColor]) {
                # Convert ConsoleColor to hex if needed
                $fg = Get-ThemeColor("Foreground") # Use theme default instead
            } else {
                $fg = $this.ForegroundColor # Assume it's already hex
            }
        } else {
            $fg = Get-ThemeColor("Foreground")
        }
        
        # Draw text
        Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $this.Text -Style @{ FG = $fg; BG = $bgColor }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}
#<!-- END_PAGE: ACO.001 -->



####\Components\ACO.002_ButtonComponent.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: ButtonComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Interactive button with click events
class ButtonComponent : UIElement {
    [string]$Text = "Button"
    [bool]$IsPressed = $false
    [scriptblock]$OnClick

    ButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 10
        $this.Height = 3
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Clear buffer with theme background
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Determine colors based on state
        $fgColor = "#FFFFFF"
        $bgColor = "#333333"
        
        if ($this.IsPressed) {
            $fgColor = Get-ThemeColor("button.pressed.fg")
            $bgColor = Get-ThemeColor("button.pressed.bg")
        }
        elseif ($this.IsFocused) {
            $fgColor = Get-ThemeColor("button.focused.fg") 
            $bgColor = Get-ThemeColor("button.focused.bg")
        }
        elseif (-not $this.Enabled) {
            $fgColor = Get-ThemeColor("button.disabled.fg")
            $bgColor = Get-ThemeColor("button.disabled.bg")
        }
        else {
            $fgColor = Get-ThemeColor("button.normal.fg")
            $bgColor = Get-ThemeColor("button.normal.bg")
        }
        
        # Draw button background
        $style = @{ FG = $fgColor; BG = $bgColor }
        $this._private_buffer.FillRect(0, 0, $this.Width, $this.Height, ' ', $style)
        
        # Draw button text centered
        if (-not [string]::IsNullOrEmpty($this.Text)) {
            $textX = [Math]::Max(0, [Math]::Floor(($this.Width - $this.Text.Length) / 2))
            $textY = [Math]::Floor($this.Height / 2)
            
            Write-TuiText -Buffer $this._private_buffer -X $textX -Y $textY -Text $this.Text -Style $style
        }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        if ($key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
            try {
                $this.IsPressed = $true
                $this.RequestRedraw()
                
                if ($this.OnClick) {
                    & $this.OnClick
                }
                
                Start-Sleep -Milliseconds 50
                $this.IsPressed = $false
                $this.RequestRedraw()
                
                return $true
            }
            catch {
                $this.IsPressed = $false
                $this.RequestRedraw()
            }
        }
        return $false
    }
}

#<!-- END_PAGE: ACO.002 -->



####\Components\ACO.003_TextBoxComponent.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: TextBoxComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Text input with viewport scrolling, non-destructive cursor
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [ValidateRange(1, [int]::MaxValue)][int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    hidden [int]$_scrollOffset = 0
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    [string]$PlaceholderColor = "#808080"

    TextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Clear buffer with theme background
        $bgColor = Get-ThemeColor("input.background")
        if (-not $bgColor) { $bgColor = "#1E1E1E" }
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Determine colors
        $fgColor = if ($this.IsFocused) { Get-ThemeColor("input.foreground") } else { Get-ThemeColor("Subtle") }
        $bgColor = Get-ThemeColor("input.background")
        $borderColorValue = if ($this.IsFocused) { Get-ThemeColor("Primary") } else { Get-ThemeColor("component.border") }
        
        # Ensure we have valid colors
        if (-not $fgColor) { $fgColor = "#FFFFFF" }
        if (-not $bgColor) { $bgColor = "#000000" }
        if (-not $borderColorValue) { $borderColorValue = "#808080" }
        
        # Draw border
        Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
            -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
        # Draw text or placeholder
        $contentY = 1
        $contentStartX = 1
        $contentWidth = $this.Width - 2
        
        if ($this.Text.Length -eq 0 -and $this.Placeholder) {
            # Draw placeholder
            $placeholderText = if ($this.Placeholder.Length -gt $contentWidth) {
                $this.Placeholder.Substring(0, $contentWidth)
            } else { $this.Placeholder }
            
            $textStyle = @{ FG = Get-ThemeColor("input.placeholder"); BG = $bgColor }
            Write-TuiText -Buffer $this._private_buffer -X $contentStartX -Y $contentY -Text $placeholderText -Style $textStyle
        }
        else {
            # Calculate scroll offset
            if ($this.CursorPosition -lt $this._scrollOffset) {
                $this._scrollOffset = $this.CursorPosition
            }
            elseif ($this.CursorPosition -ge ($this._scrollOffset + $contentWidth)) {
                $this._scrollOffset = $this.CursorPosition - $contentWidth + 1
            }
            
            # Draw visible portion of text
            $visibleText = ""
            if ($this.Text.Length -gt 0) {
                $endPos = [Math]::Min($this._scrollOffset + $contentWidth, $this.Text.Length)
                if ($this._scrollOffset -lt $this.Text.Length) {
                    $visibleText = $this.Text.Substring($this._scrollOffset, $endPos - $this._scrollOffset)
                }
            }
            
            if ($visibleText) {
                $textStyle = @{ FG = $fgColor; BG = $bgColor }
                Write-TuiText -Buffer $this._private_buffer -X $contentStartX -Y $contentY -Text $visibleText -Style $textStyle
            }
            
            # Draw cursor if focused (non-destructive - inverts colors)
            if ($this.IsFocused) {
                $cursorScreenPos = $this.CursorPosition - $this._scrollOffset
                if ($cursorScreenPos -ge 0 -and $cursorScreenPos -lt $contentWidth) {
                    $cursorX = $contentStartX + $cursorScreenPos
                    
                    # Get the cell at cursor position
                    $cellUnderCursor = $this._private_buffer.GetCell($cursorX, $contentY)
                    
                    # Invert its colors to represent the cursor
                    $cursorFg = $cellUnderCursor.BackgroundColor
                    $cursorBg = $cellUnderCursor.ForegroundColor
                    # Use the 4-parameter constructor for bold cursor
                    $newCell = [TuiCell]::new($cellUnderCursor.Char, $cursorBg, $cursorFg, $true)
                    $this._private_buffer.SetCell($cursorX, $contentY, $newCell)
                }
            }
        }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldText = $this.Text
        
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.CursorPosition++
                }
            }
            ([ConsoleKey]::Home) {
                $this.CursorPosition = 0
            }
            ([ConsoleKey]::End) {
                $this.CursorPosition = $this.Text.Length
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPosition, 1)
                }
            }
            default {
                if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                    if ($this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    }
                }
                else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            if ($oldText -ne $this.Text) {
                if ($this.OnChange) {
                    try { 
                        & $this.OnChange $this $this.Text 
                    } catch {
                        Write-Log -Level Error -Message "TextBox '$($this.Name)': Error in OnChange handler: $_"
                    }
                }
            }
            $this.RequestRedraw()
            $global:TuiState.IsDirty = $true
        }
        
        return $handled
    }
}

#<!-- END_PAGE: ACO.003 -->



####\Components\ACO.004_CheckBoxComponent.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: CheckBoxComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Boolean checkbox input
class CheckBoxComponent : UIElement {
    [string]$Text = ""
    [bool]$Checked = $false
    [scriptblock]$OnChange

    CheckBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        if ($this.IsFocused) { 
            $fgColor = Get-ThemeColor("Primary") 
        } else { 
            $fgColor = Get-ThemeColor("Foreground") 
        }
        if ($this.Checked) { 
            $checkMark = "[X]" 
        } else { 
            $checkMark = "[ ]" 
        }
        $fullText = "$checkMark $($this.Text)"
        
        Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $fullText -Style @{ FG = $fgColor; BG = $bgColor }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar) {
            $this.Checked = -not $this.Checked
            if ($this.OnChange) {
                try { 
                    & $this.OnChange $this $this.Checked 
                } catch {
                    # Ignore errors in onChange handler
                }
            }
            $this.RequestRedraw()
            return $true
        }
        
        return $false
    }
}

#<!-- END_PAGE: ACO.004 -->



####\Components\ACO.005_RadioButtonComponent.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: RadioButtonComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Exclusive selection with group management
class RadioButtonComponent : UIElement {
    [string]$Text = ""
    [bool]$Selected = $false
    [string]$GroupName = "default"
    [scriptblock]$OnChange
    static [hashtable]$_groups = @{}

    RadioButtonComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 1
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        if ($this.IsFocused) { 
            $fgColor = Get-ThemeColor("Primary") 
        } else { 
            $fgColor = Get-ThemeColor("Foreground") 
        }
        if ($this.Selected) { 
            $radioMark = "(o)" 
        } else { 
            $radioMark = "( )" 
        }
        $fullText = "$radioMark $($this.Text)"
        
        Write-TuiText -Buffer $this._private_buffer -X 0 -Y 0 -Text $fullText -Style @{ FG = $fgColor; BG = $bgColor }
        
        $this._needs_redraw = $false
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar -and -not $this.Selected) {
            $this.Select()
            return $true
        }
        
        return $false
    }

    [void] Select() {
        # Deselect all others in group
        if ([RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            foreach ($radio in [RadioButtonComponent]::_groups[$this.GroupName]) {
                if ($radio -ne $this -and $radio.Selected) {
                    $radio.Selected = $false
                    $radio.RequestRedraw()
                    if ($radio.OnChange) {
                        try { 
                            & $radio.OnChange $radio $false 
                        } catch {
                            # Ignore errors in onChange handler
                        }
                    }
                }
            }
        }
        
        $this.Selected = $true
        $this.RequestRedraw()
        if ($this.OnChange) {
            try { 
                & $this.OnChange $this $true 
            } catch {
                # Ignore errors in onChange handler
            }
        }
    }

    [void] AddedToParent() {
        if (-not [RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            [RadioButtonComponent]::_groups[$this.GroupName] = [List[RadioButtonComponent]]::new()
        }
        [RadioButtonComponent]::_groups[$this.GroupName].Add($this)
    }

    [void] RemovedFromParent() {
        if ([RadioButtonComponent]::_groups.ContainsKey($this.GroupName)) {
            [RadioButtonComponent]::_groups[$this.GroupName].Remove($this)
        }
    }
}

#endregion Core UI Components

#region Advanced Components

#<!-- END_PAGE: ACO.005 -->



####\Components\ACO.006_MultilineTextBoxComponent.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: MultilineTextBoxComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Full text editor with scrolling
class MultilineTextBoxComponent : UIElement {
    [List[string]]$Lines
    [int]$CursorLine = 0
    [int]$CursorColumn = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [bool]$ReadOnly = $false
    [scriptblock]$OnChange
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    
    MultilineTextBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Lines = [List[string]]::new()
        $this.Lines.Add("")
        $this.Width = 40
        $this.Height = 10
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor -ColorName "input.background" -DefaultColor $this.BackgroundColor
            $fgColor = Get-ThemeColor -ColorName "input.foreground" -DefaultColor $this.ForegroundColor
            $borderColorValue = if ($this.IsFocused) { Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF" } else { Get-ThemeColor -ColorName "component.border" -DefaultColor $this.BorderColor }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            # Calculate visible area
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
            
            # Adjust scroll to keep cursor visible
            if ($this.CursorLine -lt $this.ScrollOffsetY) {
                $this.ScrollOffsetY = $this.CursorLine
            }
            elseif ($this.CursorLine -ge $this.ScrollOffsetY + $contentHeight) {
                $this.ScrollOffsetY = $this.CursorLine - $contentHeight + 1
            }
            
            if ($this.CursorColumn -lt $this.ScrollOffsetX) {
                $this.ScrollOffsetX = $this.CursorColumn
            }
            elseif ($this.CursorColumn -ge $this.ScrollOffsetX + $contentWidth) {
                $this.ScrollOffsetX = $this.CursorColumn - $contentWidth + 1
            }
            
            # Draw visible lines
            for ($y = 0; $y -lt $contentHeight; $y++) {
                $lineIndex = $y + $this.ScrollOffsetY
                if ($lineIndex -lt $this.Lines.Count) {
                    $line = $this.Lines[$lineIndex]
                    $visiblePart = ""
                    
                    if ($line.Length -gt $this.ScrollOffsetX) {
                        $endPos = [Math]::Min($this.ScrollOffsetX + $contentWidth, $line.Length)
                        $visiblePart = $line.Substring($this.ScrollOffsetX, $endPos - $this.ScrollOffsetX)
                    }
                    
                    if ($visiblePart) {
                        Write-TuiText -Buffer $this._private_buffer -X 1 -Y ($y + 1) -Text $visiblePart -Style @{ FG = $fgColor; BG = $bgColor }
                    }
                }
            }
            
            # Draw cursor if focused
            if ($this.IsFocused -and -not $this.ReadOnly) {
                $cursorScreenY = $this.CursorLine - $this.ScrollOffsetY + 1
                $cursorScreenX = $this.CursorColumn - $this.ScrollOffsetX + 1
                
                if ($cursorScreenY -ge 1 -and $cursorScreenY -lt $this.Height - 1 -and
                    $cursorScreenX -ge 1 -and $cursorScreenX -lt $this.Width - 1) {
                    
                    $currentLine = $this.Lines[$this.CursorLine]
                    $cursorChar = ' '
                    if ($this.CursorColumn -lt $currentLine.Length) {
                        $cursorChar = $currentLine[$this.CursorColumn]
                    }
                    
                    $this._private_buffer.SetCell($cursorScreenX, $cursorScreenY,
                        [TuiCell]::new($cursorChar, $bgColor, $fgColor))
                }
            }
        }
        catch {}
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.ReadOnly) { return $false }
        
        $handled = $true
        $changed = $false
        
        switch ($key.Key) {
            ([ConsoleKey]::LeftArrow) {
                if ($this.CursorColumn -gt 0) {
                    $this.CursorColumn--
                }
                elseif ($this.CursorLine -gt 0) {
                    $this.CursorLine--
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
            }
            ([ConsoleKey]::RightArrow) {
                $currentLine = $this.Lines[$this.CursorLine]
                if ($this.CursorColumn -lt $currentLine.Length) {
                    $this.CursorColumn++
                }
                elseif ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.CursorLine++
                    $this.CursorColumn = 0
                }
            }
            ([ConsoleKey]::UpArrow) {
                if ($this.CursorLine -gt 0) {
                    $this.CursorLine--
                    $newLineLength = $this.Lines[$this.CursorLine].Length
                    if ($this.CursorColumn -gt $newLineLength) {
                        $this.CursorColumn = $newLineLength
                    }
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $this.CursorLine++
                    $newLineLength = $this.Lines[$this.CursorLine].Length
                    if ($this.CursorColumn -gt $newLineLength) {
                        $this.CursorColumn = $newLineLength
                    }
                }
            }
            ([ConsoleKey]::Home) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.CursorLine = 0
                    $this.CursorColumn = 0
                }
                else {
                    $this.CursorColumn = 0
                }
            }
            ([ConsoleKey]::End) {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.CursorLine = $this.Lines.Count - 1
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
                else {
                    $this.CursorColumn = $this.Lines[$this.CursorLine].Length
                }
            }
            ([ConsoleKey]::Enter) {
                $currentLine = $this.Lines[$this.CursorLine]
                $beforeCursor = $currentLine.Substring(0, $this.CursorColumn)
                $afterCursor = $currentLine.Substring($this.CursorColumn)
                
                $this.Lines[$this.CursorLine] = $beforeCursor
                $this.Lines.Insert($this.CursorLine + 1, $afterCursor)
                
                $this.CursorLine++
                $this.CursorColumn = 0
                $changed = $true
            }
            ([ConsoleKey]::Backspace) {
                if ($this.CursorColumn -gt 0) {
                    $currentLine = $this.Lines[$this.CursorLine]
                    $this.Lines[$this.CursorLine] = $currentLine.Remove($this.CursorColumn - 1, 1)
                    $this.CursorColumn--
                    $changed = $true
                }
                elseif ($this.CursorLine -gt 0) {
                    $currentLine = $this.Lines[$this.CursorLine]
                    $previousLine = $this.Lines[$this.CursorLine - 1]
                    $this.CursorColumn = $previousLine.Length
                    $this.Lines[$this.CursorLine - 1] = $previousLine + $currentLine
                    $this.Lines.RemoveAt($this.CursorLine)
                    $this.CursorLine--
                    $changed = $true
                }
            }
            ([ConsoleKey]::Delete) {
                $currentLine = $this.Lines[$this.CursorLine]
                if ($this.CursorColumn -lt $currentLine.Length) {
                    $this.Lines[$this.CursorLine] = $currentLine.Remove($this.CursorColumn, 1)
                    $changed = $true
                }
                elseif ($this.CursorLine -lt $this.Lines.Count - 1) {
                    $nextLine = $this.Lines[$this.CursorLine + 1]
                    $this.Lines[$this.CursorLine] = $currentLine + $nextLine
                    $this.Lines.RemoveAt($this.CursorLine + 1)
                    $changed = $true
                }
            }
            default {
                if ($key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                    $currentLine = $this.Lines[$this.CursorLine]
                    $this.Lines[$this.CursorLine] = $currentLine.Insert($this.CursorColumn, $key.KeyChar)
                    $this.CursorColumn++
                    $changed = $true
                }
                else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            if ($changed -and $this.OnChange) {
                try { & $this.OnChange $this $this.GetText() } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    [string] GetText() {
        return ($this.Lines -join "`n")
    }
    
    [void] SetText([string]$text) {
        $this.Lines.Clear()
        $splitLines = $text -split "`n"
        foreach ($line in $splitLines) {
            $this.Lines.Add($line)
        }
        if ($this.Lines.Count -eq 0) {
            $this.Lines.Add("")
        }
        $this.CursorLine = 0
        $this.CursorColumn = 0
        $this.ScrollOffsetY = 0
        $this.ScrollOffsetX = 0
        $this.RequestRedraw()
    }
}

#<!-- END_PAGE: ACO.006 -->



####\Components\ACO.007_NumericInputComponent.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: NumericInputComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Numeric input with spinners and validation
class NumericInputComponent : UIElement {
    [double]$Value = 0
    [double]$Minimum = [double]::MinValue
    [double]$Maximum = [double]::MaxValue
    [double]$Step = 1
    [int]$DecimalPlaces = 0
    [scriptblock]$OnChange
    hidden [string]$_textValue = "0"
    hidden [int]$_cursorPosition = 1
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    
    NumericInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 15
        $this.Height = 3
        $this._textValue = $this.FormatValue($this.Value)
        $this._cursorPosition = $this._textValue.Length
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor -ColorName "input.background" -DefaultColor $this.BackgroundColor
            $fgColor = Get-ThemeColor -ColorName "input.foreground" -DefaultColor $this.ForegroundColor
            $borderColorValue = if ($this.IsFocused) { Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF" } else { Get-ThemeColor -ColorName "component.border" -DefaultColor $this.BorderColor }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw border
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            # Draw spinners
            $spinnerColor = if ($this.IsFocused) { "#FFFF00" } else { "#808080" }
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new('▲', $spinnerColor, $bgColor))
            $this._private_buffer.SetCell($this.Width - 2, $this.Height - 2, [TuiCell]::new('▼', $spinnerColor, $bgColor))
            
            # Draw value
            $displayValue = $this._textValue
            $maxTextWidth = $this.Width - 4  # Border + spinner
            if ($displayValue.Length -gt $maxTextWidth) {
                $displayValue = $displayValue.Substring(0, $maxTextWidth)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayValue -Style @{ FG = $fgColor; BG = $bgColor }
            
            # Draw cursor if focused
            if ($this.IsFocused -and $this._cursorPosition -le $displayValue.Length) {
                $cursorX = 1 + $this._cursorPosition
                if ($cursorX -lt $this.Width - 2) {
                    if ($this._cursorPosition -lt $this._textValue.Length) {
                        $cursorChar = $this._textValue[$this._cursorPosition]
                    } else { 
                        $cursorChar = ' ' 
                    }
                    
                    $this._private_buffer.SetCell($cursorX, 1, 
                        [TuiCell]::new($cursorChar, $bgColor, $fgColor))
                }
            }
        }
        catch {}
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldValue = $this.Value
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                $this.IncrementValue()
            }
            ([ConsoleKey]::DownArrow) {
                $this.DecrementValue()
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this._cursorPosition -gt 0) {
                    $this._cursorPosition--
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($this._cursorPosition -lt $this._textValue.Length) {
                    $this._cursorPosition++
                }
            }
            ([ConsoleKey]::Home) {
                $this._cursorPosition = 0
            }
            ([ConsoleKey]::End) {
                $this._cursorPosition = $this._textValue.Length
            }
            ([ConsoleKey]::Backspace) {
                if ($this._cursorPosition -gt 0) {
                    $this._textValue = $this._textValue.Remove($this._cursorPosition - 1, 1)
                    $this._cursorPosition--
                    $this.ParseAndValidate()
                }
            }
            ([ConsoleKey]::Delete) {
                if ($this._cursorPosition -lt $this._textValue.Length) {
                    $this._textValue = $this._textValue.Remove($this._cursorPosition, 1)
                    $this.ParseAndValidate()
                }
            }
            ([ConsoleKey]::Enter) {
                $this.ParseAndValidate()
            }
            default {
                if ($key.KeyChar -and ($key.KeyChar -match '[0-9.\-]')) {
                    # Allow only valid numeric characters
                    if ($key.KeyChar -eq '.' -and $this._textValue.Contains('.')) {
                        # Only one decimal point allowed
                        $handled = $false
                    }
                    elseif ($key.KeyChar -eq '-' -and ($this._cursorPosition -ne 0 -or $this._textValue.Contains('-'))) {
                        # Minus only at beginning
                        $handled = $false
                    }
                    else {
                        $this._textValue = $this._textValue.Insert($this._cursorPosition, $key.KeyChar)
                        $this._cursorPosition++
                        $this.ParseAndValidate()
                    }
                }
                else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            if ($oldValue -ne $this.Value -and $this.OnChange) {
                try { & $this.OnChange $this $this.Value } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    hidden [void] IncrementValue() {
        $newValue = $this.Value + $this.Step
        if ($newValue -le $this.Maximum) {
            $this.Value = $newValue
            $this._textValue = $this.FormatValue($this.Value)
            $this._cursorPosition = $this._textValue.Length
        }
    }
    
    hidden [void] DecrementValue() {
        $newValue = $this.Value - $this.Step
        if ($newValue -ge $this.Minimum) {
            $this.Value = $newValue
            $this._textValue = $this.FormatValue($this.Value)
            $this._cursorPosition = $this._textValue.Length
        }
    }
    
    hidden [void] ParseAndValidate() {
        try {
            $parsedValue = [double]::Parse($this._textValue)
            $parsedValue = [Math]::Max($this.Minimum, [Math]::Min($this.Maximum, $parsedValue))
            $this.Value = $parsedValue
        }
        catch {
            # Keep current value if parse fails
        }
    }
    
    hidden [string] FormatValue([double]$value) {
        if ($this.DecimalPlaces -eq 0) {
            return [Math]::Truncate($value).ToString()
        }
        else {
            return $value.ToString("F$($this.DecimalPlaces)")
        }
    }
}

#<!-- END_PAGE: ACO.007 -->



####\Components\ACO.008_DateInputComponent.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: DateInputComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Date picker with calendar interface
class DateInputComponent : UIElement {
    [DateTime]$Value = [DateTime]::Today
    [DateTime]$MinDate = [DateTime]::MinValue
    [DateTime]$MaxDate = [DateTime]::MaxValue
    [scriptblock]$OnChange
    hidden [bool]$_showCalendar = $false
    hidden [DateTime]$_viewMonth
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$BorderColor = "#808080"
    
    DateInputComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 1  # Expands to 10 when calendar shown
        $this._viewMonth = $this.Value
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor -ColorName "input.background" -DefaultColor $this.BackgroundColor
            $fgColor = Get-ThemeColor -ColorName "input.foreground" -DefaultColor $this.ForegroundColor
            if ($this.IsFocused) { 
                $borderColorValue = Get-ThemeColor -ColorName "Primary" -DefaultColor "#00FFFF" 
            } else { 
                $borderColorValue = Get-ThemeColor -ColorName "component.border" -DefaultColor $this.BorderColor 
            }
            
            # Adjust height based on calendar visibility
            if ($this._showCalendar) { 
                $renderHeight = 10 
            } else { 
                $renderHeight = 3 
            }
            if ($this.Height -ne $renderHeight) {
                $this.Height = $renderHeight
                $this.RequestRedraw()
                return
            }
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw text box
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                -Width $this.Width -Height 3 `
                -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = "Single" }
            
            # Draw date value
            $dateStr = $this.Value.ToString("yyyy-MM-dd")
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $dateStr -Style @{ FG = $fgColor; BG = $bgColor }
            
            # Draw calendar icon
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new('📅', $borderColorValue, $bgColor))
            
            # Draw calendar if shown
            if ($this._showCalendar) {
                $this.DrawCalendar(0, 3)
            }
        }
        catch {}
    }
    
    hidden [void] DrawCalendar([int]$startX, [int]$startY) {
        $bgColor = "#000000"
        $fgColor = "#FFFFFF"
        $headerColor = "#FFFF00"
        $selectedColor = "#00FFFF"
        $todayColor = "#00FF00"
        
        # Calendar border
        Write-TuiBox -Buffer $this._private_buffer -X $startX -Y $startY `
            -Width $this.Width -Height 7 `
            -Style @{ BorderFG = "#808080"; BG = $bgColor; BorderStyle = "Single" }
        
        # Month/Year header
        $monthYearStr = $this._viewMonth.ToString("MMMM yyyy")
        $headerX = $startX + [Math]::Floor(($this.Width - $monthYearStr.Length) / 2)
        Write-TuiText -Buffer $this._private_buffer -X $headerX -Y ($startY + 1) -Text $monthYearStr -Style @{ FG = $headerColor; BG = $bgColor }
        
        # Navigation arrows
        $this._private_buffer.SetCell($startX + 1, $startY + 1, [TuiCell]::new('<', $headerColor, $bgColor))
        $this._private_buffer.SetCell($startX + $this.Width - 2, $startY + 1, [TuiCell]::new('>', $headerColor, $bgColor))
        
        # Day headers
        $dayHeaders = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
        $dayX = $startX + 2
        foreach ($day in $dayHeaders) {
            Write-TuiText -Buffer $this._private_buffer -X $dayX -Y ($startY + 2) -Text $day -Style @{ FG = "#808080"; BG = $bgColor }
            $dayX += 3
        }
        
        # Calendar days
        $firstDay = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, 1)
        $startDayOfWeek = [int]$firstDay.DayOfWeek
        $daysInMonth = [DateTime]::DaysInMonth($this._viewMonth.Year, $this._viewMonth.Month)
        
        $currentDay = 1
        $today = [DateTime]::Today
        
        for ($week = 0; $week -lt 6; $week++) {
            if ($currentDay -gt $daysInMonth) { break }
            
            for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                if ($currentDay -gt $daysInMonth) { break }
                
                $dayX = $startX + 2 + ($dayOfWeek * 3)
                $dayY = $startY + 3 + $week
                
                $currentDate = [DateTime]::new($this._viewMonth.Year, $this._viewMonth.Month, $currentDay)
                $dayStr = $currentDay.ToString().PadLeft(2)
                
                # Determine color
                $dayColor = $fgColor
                if ($currentDate -eq $this.Value) {
                    $dayColor = $selectedColor
                }
                elseif ($currentDate -eq $today) {
                    $dayColor = $todayColor
                }
                
                Write-TuiText -Buffer $this._private_buffer -X $dayX -Y $dayY -Text $dayStr -Style @{ FG = $dayColor; BG = $bgColor }
                $currentDay++
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        $oldValue = $this.Value
        
        if (-not $this._showCalendar) {
            switch ($key.Key) {
                ([ConsoleKey]::Enter) { $this._showCalendar = $true }
                ([ConsoleKey]::Spacebar) { $this._showCalendar = $true }
                ([ConsoleKey]::DownArrow) { $this._showCalendar = $true }
                default { $handled = $false }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) { 
                    $this._showCalendar = $false 
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Previous month
                        $this._viewMonth = $this._viewMonth.AddMonths(-1)
                    }
                    else {
                        # Previous day
                        $newDate = $this.Value.AddDays(-1)
                        if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                            $this.Value = $newDate
                            $this._viewMonth = $newDate
                        }
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Next month
                        $this._viewMonth = $this._viewMonth.AddMonths(1)
                    }
                    else {
                        # Next day
                        $newDate = $this.Value.AddDays(1)
                        if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                            $this.Value = $newDate
                            $this._viewMonth = $newDate
                        }
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    # Previous week
                    $newDate = $this.Value.AddDays(-7)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._viewMonth = $newDate
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    # Next week
                    $newDate = $this.Value.AddDays(7)
                    if ($newDate -ge $this.MinDate -and $newDate -le $this.MaxDate) {
                        $this.Value = $newDate
                        $this._viewMonth = $newDate
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this._showCalendar = $false
                }
                ([ConsoleKey]::T) {
                    # Today
                    $today = [DateTime]::Today
                    if ($today -ge $this.MinDate -and $today -le $this.MaxDate) {
                        $this.Value = $today
                        $this._viewMonth = $today
                    }
                }
                default { $handled = $false }
            }
        }
        
        if ($handled) {
            if ($oldValue -ne $this.Value -and $this.OnChange) {
                try { & $this.OnChange $this $this.Value } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

#<!-- END_PAGE: ACO.008 -->



####\Components\ACO.009_ComboBoxComponent.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: ComboBoxComponent =====
# Module: advanced-input-components
# Dependencies: UIElement, TuiCell
# Purpose: Dropdown with search and overlay rendering
class ComboBoxComponent : UIElement {
    [List[object]]$Items
    [int]$SelectedIndex = -1
    [string]$DisplayMember = ""
    [string]$ValueMember = ""
    [bool]$IsEditable = $false
    [string]$Text = ""
    [scriptblock]$OnSelectionChanged
    hidden [bool]$_isDropdownOpen = $false
    hidden [int]$_highlightedIndex = -1
    hidden [string]$_searchText = ""
    hidden [List[int]]$_filteredIndices
    
    ComboBoxComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 25
        $this.Height = 3
        $this.Items = [List[object]]::new()
        $this._filteredIndices = [List[int]]::new()
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor("input.background")
            $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
            
            # Draw main box
            if ($this.IsFocused) { 
                $borderColor = Get-ThemeColor("Primary") 
            } else { 
                $borderColor = Get-ThemeColor("component.border") 
            }
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = $borderColor; BG = $bgColor; BorderStyle = "Single" }
            
            # Draw selected text or placeholder
            $displayText = ""
            if ($this.IsEditable) {
                $displayText = $this._searchText
            }
            elseif ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
                $item = $this.Items[$this.SelectedIndex]
                $displayText = $this.GetDisplayText($item)
            }
            
            if ($displayText) { 
                $textColor = Get-ThemeColor("input.foreground") 
            } else { 
                $textColor = Get-ThemeColor("input.placeholder") 
            }
            
            $maxTextWidth = $this.Width - 4  # Border + dropdown arrow
            if ($displayText.Length -gt $maxTextWidth) {
                $displayText = $displayText.Substring(0, $maxTextWidth)
            }
            
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y 1 -Text $displayText `
                -Style @{ FG = $textColor; BG = $bgColor }
            
            # Draw dropdown arrow
            if ($this._isDropdownOpen) { 
                $arrowChar = '▲' 
            } else { 
                $arrowChar = '▼' 
            }
            if ($this.IsFocused) { 
                $arrowColor = Get-ThemeColor("Accent") 
            } else { 
                $arrowColor = Get-ThemeColor("Subtle") 
            }
            $this._private_buffer.SetCell($this.Width - 2, 1, [TuiCell]::new($arrowChar, $arrowColor, $bgColor))
            
            # Draw dropdown if open (as overlay)
            if ($this._isDropdownOpen) {
                $this.IsOverlay = $true
                $this.DrawDropdown()
            }
            else {
                $this.IsOverlay = $false
            }
        }
        catch {}
    }
    
    hidden [void] DrawDropdown() {
        $dropdownY = $this.Height
        $maxDropdownHeight = 10
        $dropdownHeight = [Math]::Min($this._filteredIndices.Count + 2, $maxDropdownHeight)
        
        if ($dropdownHeight -lt 3) { $dropdownHeight = 3 }  # Minimum height
        
        # Create dropdown buffer
        $dropdownBuffer = [TuiBuffer]::new($this.Width, $dropdownHeight)
        $dropdownBuffer.Name = "ComboDropdown"
        
        # Draw dropdown border
        Write-TuiBox -Buffer $dropdownBuffer -X 0 -Y 0 `
            -Width $this.Width -Height $dropdownHeight `
            -Style @{ BorderFG = Get-ThemeColor("component.border"); BG = Get-ThemeColor("input.background"); BorderStyle = "Single" }
        
        # Draw items
        $itemY = 1
        $maxItems = $dropdownHeight - 2
        $scrollOffset = 0
        
        if ($this._highlightedIndex -ge $maxItems) {
            $scrollOffset = $this._highlightedIndex - $maxItems + 1
        }
        
        for ($i = $scrollOffset; $i -lt $this._filteredIndices.Count -and $itemY -lt $dropdownHeight - 1; $i++) {
            $itemIndex = $this._filteredIndices[$i]
            $item = $this.Items[$itemIndex]
            $itemText = $this.GetDisplayText($item)
            
            $itemFg = Get-ThemeColor("list.item.normal")
            $itemBg = Get-ThemeColor("input.background")
            
            if ($i -eq $this._highlightedIndex) {
                $itemFg = Get-ThemeColor("list.item.selected")
                $itemBg = Get-ThemeColor("list.item.selected.background")
            }
            elseif ($itemIndex -eq $this.SelectedIndex) {
                $itemFg = Get-ThemeColor("Accent")
            }
            
            # Clear line and draw item
            for ($x = 1; $x -lt $this.Width - 1; $x++) {
                $dropdownBuffer.SetCell($x, $itemY, [TuiCell]::new(' ', $itemFg, $itemBg))
            }
            
            $maxTextWidth = $this.Width - 2
            if ($itemText.Length -gt $maxTextWidth) {
                $itemText = $itemText.Substring(0, $maxTextWidth - 3) + "..."
            }
            
            Write-TuiText -Buffer $dropdownBuffer -X 1 -Y $itemY -Text $itemText -Style @{ FG = $itemFg; BG = $itemBg }
            $itemY++
        }
        
        # Blend dropdown buffer with main buffer at dropdown position
        $absPos = $this.GetAbsolutePosition()
        $dropX = 0
        $dropY = $dropdownY
        
        for ($y = 0; $y -lt $dropdownBuffer.Height; $y++) {
            for ($x = 0; $x -lt $dropdownBuffer.Width; $x++) {
                $cell = $dropdownBuffer.GetCell($x, $y)
                if ($cell) {
                    $this._private_buffer.SetCell($dropX + $x, $dropY + $y, $cell)
                }
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        
        if (-not $this._isDropdownOpen) {
            switch ($key.Key) {
                ([ConsoleKey]::Enter) { 
                    $this.OpenDropdown()
                }
                ([ConsoleKey]::Spacebar) {
                    if (-not $this.IsEditable) {
                        $this.OpenDropdown()
                    }
                    else {
                        $handled = $false
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    $this.OpenDropdown()
                }
                default {
                    if ($this.IsEditable -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                        $this._searchText += $key.KeyChar
                        $this.OpenDropdown()
                        $this.FilterItems()
                    }
                    else {
                        $handled = $false
                    }
                }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.CloseDropdown()
                }
                ([ConsoleKey]::Enter) {
                    if ($this._highlightedIndex -ge 0 -and $this._highlightedIndex -lt $this._filteredIndices.Count) {
                        $this.SelectItem($this._filteredIndices[$this._highlightedIndex])
                        $this.CloseDropdown()
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    if ($this._highlightedIndex -gt 0) {
                        $this._highlightedIndex--
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this._highlightedIndex -lt $this._filteredIndices.Count - 1) {
                        $this._highlightedIndex++
                    }
                }
                ([ConsoleKey]::Home) {
                    $this._highlightedIndex = 0
                }
                ([ConsoleKey]::End) {
                    $this._highlightedIndex = $this._filteredIndices.Count - 1
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.IsEditable -and $this._searchText.Length -gt 0) {
                        $this._searchText = $this._searchText.Substring(0, $this._searchText.Length - 1)
                        $this.FilterItems()
                    }
                }
                default {
                    if ($this.IsEditable -and $key.KeyChar -and [char]::IsControl($key.KeyChar) -eq $false) {
                        $this._searchText += $key.KeyChar
                        $this.FilterItems()
                    }
                    else {
                        $handled = $false
                    }
                }
            }
        }
        
        if ($handled) {
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    hidden [void] OpenDropdown() {
        $this._isDropdownOpen = $true
        $this.FilterItems()
        
        # Set highlighted index to selected item
        if ($this.SelectedIndex -ge 0) {
            for ($i = 0; $i -lt $this._filteredIndices.Count; $i++) {
                if ($this._filteredIndices[$i] -eq $this.SelectedIndex) {
                    $this._highlightedIndex = $i
                    break
                }
            }
        }
        
        if ($this._highlightedIndex -eq -1 -and $this._filteredIndices.Count -gt 0) {
            $this._highlightedIndex = 0
        }
    }
    
    hidden [void] CloseDropdown() {
        $this._isDropdownOpen = $false
        $this.IsOverlay = $false
        if (-not $this.IsEditable) {
            $this._searchText = ""
        }
    }
    
    hidden [void] FilterItems() {
        $this._filteredIndices.Clear()
        
        if ($this._searchText -eq "") {
            # Show all items
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                $this._filteredIndices.Add($i)
            }
        }
        else {
            # Filter items based on search text
            $searchLower = $this._searchText.ToLower()
            for ($i = 0; $i -lt $this.Items.Count; $i++) {
                $itemText = $this.GetDisplayText($this.Items[$i]).ToLower()
                if ($itemText.Contains($searchLower)) {
                    $this._filteredIndices.Add($i)
                }
            }
        }
        
        # Reset highlighted index
        if ($this._highlightedIndex -ge $this._filteredIndices.Count) {
            $this._highlightedIndex = $this._filteredIndices.Count - 1
        }
        if ($this._highlightedIndex -lt 0 -and $this._filteredIndices.Count -gt 0) {
            $this._highlightedIndex = 0
        }
    }
    
    hidden [void] SelectItem([int]$index) {
        $oldIndex = $this.SelectedIndex
        $this.SelectedIndex = $index
        
        if (-not $this.IsEditable) {
            $this.Text = $this.GetDisplayText($this.Items[$index])
        }
        
        if ($oldIndex -ne $index -and $this.OnSelectionChanged) {
            try { & $this.OnSelectionChanged $this $index } catch {}
        }
    }
    
    hidden [string] GetDisplayText([object]$item) {
        if ($null -eq $item) { return "" }
        
        if ($this.DisplayMember -and $item.PSObject.Properties[$this.DisplayMember]) {
            return $item.$($this.DisplayMember).ToString()
        }
        
        return $item.ToString()
    }
}

#<!-- END_PAGE: ACO.009 -->



####\Components\ACO.010_Table.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: Table =====
# Module: advanced-data-components
# Dependencies: UIElement, TuiCell
# Purpose: High-performance data grid with virtual scrolling
class Table : UIElement {
    [List[PSObject]]$Items
    [List[string]]$Columns
    [hashtable]$ColumnWidths
    [int]$SelectedIndex = -1
    [bool]$ShowHeader = $true
    [bool]$ShowBorder = $true
    [bool]$AllowSelection = $true
    [scriptblock]$OnSelectionChanged
    hidden [int]$_scrollOffset = 0
    hidden [int]$_horizontalScroll = 0
    
    Table([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[PSObject]]::new()
        $this.Columns = [List[string]]::new()
        $this.ColumnWidths = @{}
        $this.Width = 80
        $this.Height = 20
    }
    
    [void] SetColumns([string[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
            if (-not $this.ColumnWidths.ContainsKey($col)) {
                $this.ColumnWidths[$col] = 15  # Default width
            }
        }
    }
    
    [void] AutoSizeColumns() {
        foreach ($col in $this.Columns) {
            $maxWidth = $col.Length
            
            foreach ($item in $this.Items) {
                if ($item.PSObject.Properties[$col]) {
                    $val = $item.$col
                    if ($null -ne $val) {
                        $len = $val.ToString().Length
                        if ($len -gt $maxWidth) {
                            $maxWidth = $len
                        }
                    }
                }
            }
            
            $this.ColumnWidths[$col] = [Math]::Min($maxWidth + 2, 30)  # Cap at 30
        }
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor("component.background")
            $fgColor = Get-ThemeColor("Foreground")
            if ($this.IsFocused) { 
                $borderColor = Get-ThemeColor("Primary") 
            } else { 
                $borderColor = Get-ThemeColor("component.border") 
            }
            $headerBg = Get-ThemeColor("list.header.bg")
            $selectedBg = Get-ThemeColor("list.item.selected.background")
            
            $this._private_buffer.Clear([TuiCell]::new(' ', $fgColor, $bgColor))
            
            $contentX = 0
            $contentY = 0
            $contentWidth = $this.Width
            $contentHeight = $this.Height
            
            # Draw border if enabled
            if ($this.ShowBorder) {
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                    -Width $this.Width -Height $this.Height `
                    -Style @{ BorderFG = $borderColor; BG = $bgColor; BorderStyle = "Single" }
                
                $contentX = 1
                $contentY = 1
                $contentWidth = $this.Width - 2
                $contentHeight = $this.Height - 2
            }
            
            $currentY = $contentY
            $dataStartY = $contentY
            
            # Draw header if enabled
            if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
                $this.DrawHeader($contentX, $currentY, $contentWidth, $headerBg)
                $currentY++
                $dataStartY++
                
                # Draw separator line
                for ($x = $contentX; $x -lt $contentX + $contentWidth; $x++) {
                    $this._private_buffer.SetCell($x, $currentY, [TuiCell]::new('-', $borderColor, $bgColor))
                }
                $currentY++
                $dataStartY++
            }
            
            # Calculate visible rows
            $visibleRows = $contentHeight - ($dataStartY - $contentY)
            if ($visibleRows -le 0) { return }
            
            # Adjust scroll offset to keep selection visible
            if ($this.AllowSelection -and $this.SelectedIndex -ge 0) {
                if ($this.SelectedIndex -lt $this._scrollOffset) {
                    $this._scrollOffset = $this.SelectedIndex
                }
                elseif ($this.SelectedIndex -ge $this._scrollOffset + $visibleRows) {
                    $this._scrollOffset = $this.SelectedIndex - $visibleRows + 1
                }
            }
            
            # Draw data rows
            for ($i = 0; $i -lt $visibleRows; $i++) {
                $itemIndex = $i + $this._scrollOffset
                if ($itemIndex -ge $this.Items.Count) { break }
                
                $item = $this.Items[$itemIndex]
                $rowBg = $bgColor
                $rowFg = $fgColor
                
                if ($this.AllowSelection -and $itemIndex -eq $this.SelectedIndex) {
                    $rowBg = $selectedBg
                    $rowFg = Get-ThemeColor("list.item.selected")
                }
                
                $this.DrawRow($item, $contentX, $currentY, $contentWidth, $rowFg, $rowBg)
                $currentY++
            }
            
            # Draw scrollbar if needed
            if ($this.Items.Count -gt $visibleRows) {
                $this.DrawScrollbar($contentX + $contentWidth - 1, $dataStartY, $visibleRows)
            }
        }
        catch {}
    }
    
    hidden [void] DrawHeader([int]$x, [int]$y, [int]$maxWidth, [string]$headerBg) {
        $currentX = $x - $this._horizontalScroll
        
        foreach ($col in $this.Columns) {
            $colWidth = $this.ColumnWidths[$col]
            
            if ($currentX + $colWidth -gt $x) {
                $visibleStart = [Math]::Max(0, $x - $currentX)
                $visibleWidth = [Math]::Min($colWidth - $visibleStart, $maxWidth - ($currentX - $x))
                
                if ($visibleWidth -gt 0) {
                    $headerText = $col
                    if ($headerText.Length -gt $visibleWidth) {
                        $headerText = $headerText.Substring(0, $visibleWidth - 1) + ">"
                    }
                    else {
                        $headerText = $headerText.PadRight($visibleWidth)
                    }
                    
                    $drawX = [Math]::Max($x, $currentX)
                    Write-TuiText -Buffer $this._private_buffer -X $drawX -Y $y -Text $headerText -Style @{ FG = Get-ThemeColor("list.header.fg"); BG = $headerBg }
                }
            }
            
            $currentX += $colWidth
            if ($currentX -ge $x + $maxWidth) { break }
        }
    }
    
    hidden [void] DrawRow([PSObject]$item, [int]$x, [int]$y, [int]$maxWidth, [string]$fg, [string]$bg) {
        # Clear row first
        for ($i = 0; $i -lt $maxWidth; $i++) {
            $this._private_buffer.SetCell($x + $i, $y, [TuiCell]::new(' ', $fg, $bg))
        }
        
        $currentX = $x - $this._horizontalScroll
        
        foreach ($col in $this.Columns) {
            $colWidth = $this.ColumnWidths[$col]
            
            if ($currentX + $colWidth -gt $x) {
                $value = ""
                if ($item.PSObject.Properties[$col]) {
                    $val = $item.$col
                    if ($null -ne $val) {
                        $value = $val.ToString()
                    }
                }
                
                $visibleStart = [Math]::Max(0, $x - $currentX)
                $visibleWidth = [Math]::Min($colWidth - $visibleStart, $maxWidth - ($currentX - $x))
                
                if ($visibleWidth -gt 0) {
                    if ($value.Length -gt $visibleWidth - 1) {
                        $value = $value.Substring(0, $visibleWidth - 2) + ".."
                    }
                    
                    $drawX = [Math]::Max($x, $currentX)
                    Write-TuiText -Buffer $this._private_buffer -X $drawX -Y $y -Text $value -Style @{ FG = $fg; BG = $bg }
                }
            }
            
            $currentX += $colWidth
            if ($currentX -ge $x + $maxWidth) { break }
        }
    }
    
    hidden [void] DrawScrollbar([int]$x, [int]$y, [int]$height) {
        $scrollbarHeight = [Math]::Max(1, [int]($height * $height / $this.Items.Count))
        $scrollbarPos = [int](($height - $scrollbarHeight) * $this._scrollOffset / ($this.Items.Count - $height))
        
        $scrollbarColor = Get-ThemeColor("list.scrollbar")
        $bgColor = Get-ThemeColor("component.background")
        
        for ($i = 0; $i -lt $height; $i++) {
            $char = if ($i -ge $scrollbarPos -and $i -lt $scrollbarPos + $scrollbarHeight) { '█' } else { '│' }
            $this._private_buffer.SetCell($x, $y + $i, [TuiCell]::new($char, $scrollbarColor, $bgColor))
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or -not $this.AllowSelection) { return $false }
        
        $handled = $true
        $oldSelection = $this.SelectedIndex
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                }
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
            }
            ([ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 4  # Account for border and header
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
            }
            ([ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 4
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
            }
            ([ConsoleKey]::LeftArrow) {
                if ($this._horizontalScroll -gt 0) {
                    $this._horizontalScroll = [Math]::Max(0, $this._horizontalScroll - 5)
                }
            }
            ([ConsoleKey]::RightArrow) {
                $totalWidth = 0
                foreach ($col in $this.Columns) {
                    $totalWidth += $this.ColumnWidths[$col]
                }
                $maxScroll = [Math]::Max(0, $totalWidth - $this.Width + 2)
                $this._horizontalScroll = [Math]::Min($maxScroll, $this._horizontalScroll + 5)
            }
            default {
                $handled = $false
            }
        }
        
        if ($handled) {
            if ($oldSelection -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                try { & $this.OnSelectionChanged $this $this.SelectedIndex } catch {}
            }
            $this.RequestRedraw()
        }
        
        return $handled
    }
}

#endregion Advanced Components

#region Panel Components

#<!-- END_PAGE: ACO.010 -->



####\Components\ACO.011_Panel.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: Panel =====
# Module: panels-class
# Dependencies: UIElement, TuiCell
# Purpose: Container with layout management
class Panel : UIElement {
    [string]$Title = ""
    [string]$BorderStyle = "Single"
    [string]$BorderColor = "#808080"     # FIXED: Changed from ConsoleColor to hex string
    [string]$BackgroundColor = "#000000" # FIXED: Changed from ConsoleColor to hex string
    [bool]$HasBorder = $true
    [string]$LayoutType = "Manual"  # Manual, Vertical, Horizontal, Grid
    [int]$Padding = 0
    [int]$Spacing = 1
    
    # Content area properties
    [int]$ContentX = 1
    [int]$ContentY = 1
    [int]$ContentWidth = 0
    [int]$ContentHeight = 0

    Panel([string]$name) : base($name) {
        $this.IsFocusable = $false
        # Set reasonable defaults
        if ($this.Width -eq 0) { $this.Width = 30 }
        if ($this.Height -eq 0) { $this.Height = 10 }
        # Calculate initial content dimensions
        $this.UpdateContentDimensions()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $bgColor = Get-ThemeColor("component.background")
            $bgCell = [TuiCell]::new(' ', $bgColor, $bgColor)
            $this._private_buffer.Clear($bgCell)

            # Update content area dimensions
            $this.UpdateContentDimensions()

            if ($this.HasBorder) {
                if ($this.IsFocused) { 
                    $borderColorValue = Get-ThemeColor("Primary") 
                } else { 
                    $borderColorValue = Get-ThemeColor("component.border") 
                }
                
                Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 `
                    -Width $this.Width -Height $this.Height `
                    -Style @{ BorderFG = $borderColorValue; BG = $bgColor; BorderStyle = $this.BorderStyle; TitleFG = Get-ThemeColor("component.title") } `
                    -Title $this.Title
            }

            # Apply layout to children
            $this.ApplyLayout()
        }
        catch {}
    }

    [void] ApplyLayout() {
        if ($this.LayoutType -eq "Manual") { return }

        if ($this.HasBorder) { 
            $layoutX = 1 + $this.Padding 
        } else { 
            $layoutX = $this.Padding 
        }
        if ($this.HasBorder) { 
            $layoutY = 1 + $this.Padding 
        } else { 
            $layoutY = $this.Padding 
        }
        $layoutWidth = [Math]::Max(0, $this.Width - (2 * $layoutX))
        $layoutHeight = [Math]::Max(0, $this.Height - (2 * $layoutY))

        $visibleChildren = @($this.Children | Where-Object { $_.Visible })
        if ($visibleChildren.Count -eq 0) { return }

        switch ($this.LayoutType) {
            "Vertical" {
                $currentY = $layoutY
                foreach ($child in $visibleChildren) {
                    $child.X = $layoutX
                    $child.Y = $currentY
                    $child.Width = [Math]::Min($child.Width, $layoutWidth)
                    $currentY += $child.Height + $this.Spacing
                }
            }
            "Horizontal" {
                $currentX = $layoutX
                foreach ($child in $visibleChildren) {
                    $child.X = $currentX
                    $child.Y = $layoutY
                    $child.Height = [Math]::Min($child.Height, $layoutHeight)
                    $currentX += $child.Width + $this.Spacing
                }
            }
            "Grid" {
                # Simple grid layout - arrange in rows
                $cols = [Math]::Max(1, [Math]::Floor($layoutWidth / 20))  # Assume 20 char min width
                $col = 0
                $row = 0
                $cellWidth = [Math]::Max(1, [Math]::Floor($layoutWidth / $cols))
                $cellHeight = 3  # Default height
                
                foreach ($child in $visibleChildren) {
                    $child.X = $layoutX + ($col * $cellWidth)
                    $child.Y = $layoutY + ($row * ($cellHeight + $this.Spacing))
                    $child.Width = [Math]::Max(1, $cellWidth - $this.Spacing)
                    $child.Height = $cellHeight
                    
                    $col++
                    if ($col -ge $cols) {
                        $col = 0
                        $row++
                    }
                }
            }
        }
    }

    [hashtable] GetContentArea() {
        $area = @{
            X = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
            Y = if ($this.HasBorder) { 1 + $this.Padding } else { $this.Padding }
        }
        $area.Width = [Math]::Max(0, $this.Width - (2 * $area.X))
        $area.Height = [Math]::Max(0, $this.Height - (2 * $area.Y))
        return $area
    }
    
    # New method to update content dimensions
    [void] UpdateContentDimensions() {
        $this.ContentX = if ($this.HasBorder) { 1 } else { 0 }
        $this.ContentY = if ($this.HasBorder) { 1 } else { 0 }
        $borderOffset = if ($this.HasBorder) { 2 } else { 0 }
        $this.ContentWidth = [Math]::Max(0, $this.Width - $borderOffset)
        $this.ContentHeight = [Math]::Max(0, $this.Height - $borderOffset)
    }
    
    # Override Resize to update content dimensions
    [void] OnResize() {
        $this.UpdateContentDimensions()
        ([UIElement]$this).OnResize()
    }
}

#<!-- END_PAGE: ACO.011 -->



####\Components\ACO.012_ScrollablePanel.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: ScrollablePanel =====
# Module: panels-class
# Dependencies: Panel, TuiCell
# Purpose: Panel with scrolling capabilities
class ScrollablePanel : Panel {
    [int]$ScrollOffsetY = 0
    [int]$MaxScrollY = 0
    [bool]$ShowScrollbar = $true
    hidden [int]$_contentHeight = 0 # Total height of all content

    ScrollablePanel([string]$name) : base($name) {
        $this.IsFocusable = $true
    }

    # Override OnResize to recalculate scroll limits
    [void] OnResize([int]$newWidth, [int]$newHeight) {
        # Call base Panel resize, which updates Width, Height, and _private_buffer
        ([Panel]$this).Resize($newWidth, $newHeight) 
        
        $this.UpdateMaxScroll() # Recalculate max scroll on resize
        $this.RequestRedraw()
    }

    # Override _RenderContent to implement virtual scrolling logic
    hidden [void] _RenderContent() {
        # 1. First, render the base Panel. This clears its own _private_buffer and draws borders/title.
        ([Panel]$this)._RenderContent()

        # 2. Calculate content height and update scroll limits
        $actualContentBottom = 0
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $childBottom = ($child.Y - $this.ContentY) + $child.Height
                if ($childBottom -gt $actualContentBottom) {
                    $actualContentBottom = $childBottom
                }
            }
        }
        $this._contentHeight = $actualContentBottom
        $this.UpdateMaxScroll()

        # 3. Render visible children directly with viewport clipping
        $viewportTop = $this.ScrollOffsetY
        $viewportBottom = $this.ScrollOffsetY + $this.ContentHeight
        
        foreach ($child in $this.Children | Sort-Object ZIndex) {
            if (-not $child.Visible) { continue }
            
            # Calculate child position relative to content area
            $childRelY = $child.Y - $this.ContentY
            $childTop = $childRelY
            $childBottom = $childRelY + $child.Height
            
            # Skip if completely outside viewport
            if ($childBottom -lt $viewportTop -or $childTop -ge $viewportBottom) {
                continue
            }
            
            # Render child
            $child.Render()
            
            if ($null -ne $child._private_buffer) {
                # Calculate where to place the child in our buffer
                $destX = $child.X
                $destY = $this.ContentY + ($childRelY - $this.ScrollOffsetY)
                
                # Clip the child buffer if it extends beyond viewport
                $sourceY = 0
                $sourceHeight = $child.Height
                
                # Adjust if child is partially above viewport
                if ($childTop -lt $viewportTop) {
                    $clipTop = $viewportTop - $childTop
                    $sourceY = $clipTop
                    $sourceHeight -= $clipTop
                    $destY = $this.ContentY
                }
                
                # Adjust if child is partially below viewport
                if ($childBottom -gt $viewportBottom) {
                    $clipBottom = $childBottom - $viewportBottom
                    $sourceHeight -= $clipBottom
                }
                
                # Blend the visible portion
                if ($sourceHeight -gt 0) {
                    # Create a sub-buffer for the visible portion of the child
                    $visiblePortion = $child._private_buffer.GetSubBuffer(0, $sourceY, $child.Width, $sourceHeight)
                    $this._private_buffer.BlendBuffer($visiblePortion, $destX, $destY)
                }
            }
        }

        # 4. Draw scrollbar if needed
        if ($this.ShowScrollbar -and $this.MaxScrollY -gt 0) {
            $this.DrawScrollbar()
        }

        $this._needs_redraw = $false
    }

    # Helper method to calculate MaxScrollY and clamp ScrollOffsetY
    [void] UpdateMaxScroll() {
        $viewportHeight = $this.ContentHeight # Use ContentHeight as the available rendering area
        
        $this.MaxScrollY = [Math]::Max(0, $this._contentHeight - $viewportHeight)
        $this.ScrollOffsetY = [Math]::Max(0, [Math]::Min($this.ScrollOffsetY, $this.MaxScrollY))
        # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': ContentHeight=$($this._contentHeight), ViewportHeight=$($viewportHeight), MaxScrollY=$($this.MaxScrollY), ScrollOffsetY=$($this.ScrollOffsetY)."
    }

    # Keep DrawScrollbar, HandleInput, ScrollUp/Down/PageUp/Down/ToTop/Bottom methods.
    # Ensure DrawScrollbar uses the correct ScrollOffsetY, MaxScrollY, and _contentHeight for calculations.
    # Update SetCell calls in DrawScrollbar to use hex colors.
    [void] DrawScrollbar() {
        $scrollbarX = $this.Width - 1
        if ($this.HasBorder) { 
            $scrollbarY = 1 
        } else { 
            $scrollbarY = 0 
        }
        if ($this.HasBorder) { 
            $scrollbarTrackHeight = $this.Height - 2 
        } else { 
            $scrollbarTrackHeight = $this.Height - 0 
        }

        if ($this._contentHeight -le $scrollbarTrackHeight) { 
            # If content fits, clear any previous scrollbar
            $bgColor = Get-ThemeColor "Background"
            for ($i = 0; $i -lt $scrollbarTrackHeight; $i++) {
                $this._private_buffer.SetCell($scrollbarX, $scrollbarY + $i, [TuiCell]::new(' ', $bgColor, $bgColor))
            }
            return 
        } 

        $scrollFg = Get-ThemeColor "list.scrollbar"
        $scrollBg = Get-ThemeColor "Background"

        # Calculate thumb size and position
        $thumbSize = [Math]::Max(1, [int]($scrollbarTrackHeight * $scrollbarTrackHeight / $this._contentHeight))
        $thumbPos = [int](($scrollbarTrackHeight - $thumbSize) * $this.ScrollOffsetY / $this.MaxScrollY)
        
        for ($i = 0; $i -lt $scrollbarTrackHeight; $i++) {
            $y = $scrollbarY + $i
            $char = '│' # Default track character
            
            if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) {
                $char = '█' # Thumb character
            }
            $this._private_buffer.SetCell($scrollbarX, $y, [TuiCell]::new($char, $scrollFg, $scrollBg))
        }
    }

    # Ensure other scrolling methods call RequestRedraw and UpdateMaxScroll
    [void] ScrollUp([int]$lines = 1) {
        $oldScroll = $this.ScrollOffsetY
        $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY - $lines)
        if ($this.ScrollOffsetY -ne $oldScroll) {
            $this.RequestRedraw()
            # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': Scrolled up to $($this.ScrollOffsetY)."
        }
    }

    [void] ScrollDown([int]$lines = 1) {
        $oldScroll = $this.ScrollOffsetY
        $this.ScrollOffsetY = [Math]::Min($this.MaxScrollY, $this.ScrollOffsetY + $lines)
        if ($this.ScrollOffsetY -ne $oldScroll) {
            $this.RequestRedraw()
            # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': Scrolled down to $($this.ScrollOffsetY)."
        }
    }

    [void] ScrollPageUp() {
        $pageSize = $this.ContentHeight
        $this.ScrollUp($pageSize)
    }

    [void] ScrollPageDown() {
        $pageSize = $this.ContentHeight
        $this.ScrollDown($pageSize)
    }

    [void] ScrollToTop() {
        $oldScroll = $this.ScrollOffsetY
        $this.ScrollOffsetY = 0
        if ($this.ScrollOffsetY -ne $oldScroll) {
            $this.RequestRedraw()
            # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': Scrolled to top."
        }
    }

    [void] ScrollToBottom() {
        $oldScroll = $this.ScrollOffsetY
        $this.ScrollOffsetY = $this.MaxScrollY
        if ($this.ScrollOffsetY -ne $oldScroll) {
            $this.RequestRedraw()
            # Write-Log -Level Debug -Message "ScrollablePanel '$($this.Name)': Scrolled to bottom."
        }
    }
}

#<!-- END_PAGE: ACO.012 -->



####\Components\ACO.013_GroupPanel.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: GroupPanel =====
# Module: panels-class
# Dependencies: Panel
# Purpose: Themed panel for grouping
class GroupPanel : Panel {
    [bool]$IsExpanded = $true
    [bool]$CanCollapse = $true

    GroupPanel([string]$name) : base($name) {
        $this.BorderStyle = "Double"
        $this.BorderColor = "#008B8B"     # FIXED: DarkCyan in hex
        $this.BackgroundColor = "#000000" # FIXED: Black in hex
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Show children only if expanded
        foreach ($child in $this.Children) {
            $child.Visible = $this.IsExpanded
        }

        # Adjust height if collapsed
        if (-not $this.IsExpanded -and $this.CanCollapse) {
            $this._originalHeight = $this.Height
            $this.Height = 3  # Just title bar
        }
        elseif ($this.IsExpanded -and $this._originalHeight) {
            $this.Height = $this._originalHeight
        }

        # Add expand/collapse indicator to title
        if ($this.CanCollapse -and $this.Title) {
            $indicator = if ($this.IsExpanded) { "[-]" } else { "[+]" }
            $this.Title = "$indicator $($this.Title.TrimStart('[+]', '[-]').Trim())"
        }

        ([Panel]$this).OnRender()
    }

    hidden [int]$_originalHeight = 0

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or -not $this.CanCollapse) { return $false }
        
        if ($key.Key -eq [ConsoleKey]::Spacebar) {
            $this.Toggle()
            return $true
        }
        
        return $false
    }

    [void] Toggle() {
        $this.IsExpanded = -not $this.IsExpanded
        $this.RequestRedraw()
    }
}

#endregion Panel Components

#region Composite Components

#<!-- END_PAGE: ACO.013 -->



####\Components\ACO.014_ListBox.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: ListBox =====
# Module: tui-components (wrapper)
# Dependencies: UIElement, TuiCell
# Purpose: Scrollable item list with selection
class ListBox : UIElement {
    [List[object]]$Items
    [int]$SelectedIndex = -1
    [string]$ForegroundColor = "#FFFFFF" # Changed from ConsoleColor to hex string
    [string]$BackgroundColor = "#000000" # Changed from ConsoleColor to hex string
    [string]$SelectedForegroundColor = "#000000" # Changed from ConsoleColor to hex string
    [string]$SelectedBackgroundColor = "#00FFFF" # Changed from ConsoleColor to hex string
    [string]$BorderColor = "#808080" # Changed from ConsoleColor to hex string
    [bool]$HasBorder = $true
    [string]$BorderStyle = "Single"
    [string]$Title = ""
    [scriptblock]$SelectedIndexChanged = $null
    [string]$ItemForegroundColor = "#E0E0E0" # Default item text color
    hidden [int]$ScrollOffset = 0

    ListBox([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[object]]::new()
        $this.Width = 30
        $this.Height = 10
    }

    [void] AddItem([object]$item) {
        $this.Items.Add($item)
        if ($this.SelectedIndex -eq -1 -and $this.Items.Count -eq 1) {
            $this.SelectedIndex = 0
        }
        $this.RequestRedraw()
    }

    [void] ClearItems() {
        $this.Items.Clear()
        $this.SelectedIndex = -1
        $this.ScrollOffset = 0
        $this.RequestRedraw()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Draw border if enabled
        if ($this.HasBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height `
                -Style @{ BorderFG = Get-ThemeColor("component.border"); BG = $bgColor; BorderStyle = $this.BorderStyle; Title = $this.Title }
        }
            
        # Calculate visible area
        $contentY = if ($this.HasBorder) { 1 } else { 0 }
        $contentHeight = if ($this.HasBorder) { $this.Height - 2 } else { $this.Height }
        $contentX = if ($this.HasBorder) { 1 } else { 0 }
        $contentWidth = if ($this.HasBorder) { $this.Width - 2 } else { $this.Width }
            
            # Ensure selected item is visible
            $this.EnsureVisible($this.SelectedIndex)
            
            # Draw items
            for ($i = 0; $i -lt $contentHeight -and ($i + $this.ScrollOffset) -lt $this.Items.Count; $i++) {
                $itemIndex = $i + $this.ScrollOffset
                $item = $this.Items[$itemIndex]
                if ($item -is [string]) { 
                    $itemText = $item 
                } else { 
                    $itemText = $item.ToString() 
                }
                
                if ($itemText.Length -gt $contentWidth) {
                    $itemText = $itemText.Substring(0, $contentWidth - 3) + "..."
                }
                
                $isSelected = ($itemIndex -eq $this.SelectedIndex)
                if ($isSelected) { 
                    $fgColor = $this.SelectedForegroundColor
                } else { 
                    $fgColor = $this.ItemForegroundColor
                }
                if ($isSelected) { 
                    $itemBgColor = $this.SelectedBackgroundColor
                } else { 
                    $itemBgColor = $bgColor 
                }
                
                # Draw item background
                $this._private_buffer.FillRect(1, $contentY + $i, $this.Width - 2, 1, ' ', @{ BG = $itemBgColor })
                
                # Draw item text
                Write-TuiText -Buffer $this._private_buffer -X $contentX -Y ($contentY + $i) -Text $itemText `
                    -Style @{ FG = $fgColor; BG = $itemBgColor }
            }
            
            # Draw scrollbar if needed
            if ($this.Items.Count -gt $contentHeight) {
                $scrollbarX = $this.Width - 2
                $scrollbarHeight = $contentHeight
                $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $scrollbarHeight / $this.Items.Count))
                $thumbPos = if ($this.Items.Count -gt $scrollbarHeight) {
                    [int](($scrollbarHeight - $thumbSize) * $this.ScrollOffset / ($this.Items.Count - $scrollbarHeight))
                } else { 0 }
                
                $scrollbarColor = Get-ThemeColor "list.scrollbar"
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { '█' } else { '│' }
                    $this._private_buffer.SetCell($scrollbarX, $contentY + $i, 
                        [TuiCell]::new($char, $scrollbarColor, $bgColor))
                }
            }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $true
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                }
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
            }
            ([ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 2
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
            }
            ([ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 2
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
            }
            default {
                $handled = $false
            }
        }
        
        if ($handled) {
            $this.RequestRedraw()
            
            # Trigger SelectedIndexChanged event if index changed
            if ($oldIndex -ne $this.SelectedIndex -and $this.SelectedIndexChanged) {
                & $this.SelectedIndexChanged $this $this.SelectedIndex
            }
        }
        
        return $handled
    }

    [void] EnsureVisible([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Items.Count) { return }
        
        $visibleHeight = $this.Height - 2
        
        if ($index -lt $this.ScrollOffset) {
            $this.ScrollOffset = $index
        }
        elseif ($index -ge $this.ScrollOffset + $visibleHeight) {
            $this.ScrollOffset = $index - $visibleHeight + 1
        }
    }
}

#<!-- END_PAGE: ACO.014 -->



####\Components\ACO.014a_Dialog.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: Dialog =====
# Module: dialog-system-class
# Dependencies: Screen, Panel
# Purpose: Base class for modal dialogs - NOW A WINDOW TYPE
# FIXED: Dialog now inherits from Screen for proper window-based input
class Dialog : Screen {
    [string]$Title = ""
    [string]$Message = ""
    hidden [Panel]$_panel
    hidden [object]$Result = $null
    hidden [bool]$_isComplete = $false
    [scriptblock]$OnClose
    [DialogResult]$DialogResult = [DialogResult]::None
    
    # Store the screen we came from
    hidden [object]$_previousScreen = $null

    Dialog([string]$name, [object]$serviceContainer) : base($name, $serviceContainer) {
        $this.IsOverlay = $true
        $this.Width = 50
        $this.Height = 10
        
        $this.InitializeDialog()
    }

    hidden [void] InitializeDialog() {
        $this._panel = [Panel]::new($this.Name + "_Panel")
        $this._panel.HasBorder = $true
        $this._panel.BorderStyle = "Double"
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height
        $this.AddChild($this._panel)
    }

    [void] Show([string]$title, [string]$message) {
        $this.Title = $title
        $this.Message = $message
        $this._panel.Title = " $title "
        $this._isComplete = $false
        $this.Result = $null
        $this.Visible = $true
        $this.RequestRedraw()
    }

    [void] Complete([object]$result) {
        Write-Log -Level Debug -Message "Dialog.Complete called on '$($this.Name)' with result: $(if ($null -ne $result) { $result | ConvertTo-Json -Compress } else { 'null' })"
        Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] Dialog.Complete called for '$($this.Name)'"
        
        $this.Result = $result
        $this._isComplete = $true
        
        # Make dialog invisible immediately
        $this.Visible = $false
        $this.RequestRedraw()
        $global:TuiState.IsDirty = $true
        
        # Call the OnClose scriptblock if provided
        if ($this.OnClose) {
            Write-Log -Level Debug -Message "Dialog '$($this.Name)': Calling OnClose callback"
            Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] Dialog calling OnClose callback..."
            try { 
                & $this.OnClose $result 
                Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] OnClose callback completed"
            } catch { 
                Write-Log -Level Warning -Message "Dialog '$($this.Name)': Error in OnClose callback: $($_.Exception.Message)" 
                Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] ERROR in OnClose: $_"
            }
        } else {
            Write-Log -Level Debug -Message "Dialog '$($this.Name)': No OnClose callback set"
            Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] No OnClose callback set"
        }
        
        # Navigate back to previous screen
        $navService = $null
        if ($null -ne $this.ServiceContainer) {
            $navService = $this.ServiceContainer.GetService("NavigationService")
        }
        if ($navService) {
            if ($navService.CanGoBack()) {
                $navService.GoBack()
            } else {
                Write-Log -Level Warning -Message "Dialog '$($this.Name)': Cannot go back, no previous screen"
            }
        }
    }

    # Legacy method for compatibility
    [void] Close([object]$result) {
        $this.Complete($result)
    }

    # Override Screen's OnEnter to set focus
    [void] OnEnter() {
        ([Screen]$this).OnEnter()
        $this.SetInitialFocus()
    }

    # Override HandleInput to provide Dialog-specific behavior
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        # Check for Escape at dialog level
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Complete($null)
            return $true
        }
        
        # Otherwise use default Screen behavior
        return ([Screen]$this).HandleInput($key)
    }

    [void] SetInitialFocus() {
        # Find first focusable child
        $firstFocusable = $null
        $this.FindFocusableChild($this._panel, [ref]$firstFocusable)
        
        if ($firstFocusable) {
            $focusManager = $null
            if ($null -ne $this.ServiceContainer) {
                $focusManager = $this.ServiceContainer.GetService("FocusManager")
            }
            if ($focusManager) {
                $focusManager.SetFocus($firstFocusable)
                Write-Log -Level Debug -Message "Dialog '$($this.Name)': Set initial focus to '$($firstFocusable.Name)'."
            }
        }
    }
    
    hidden [void] FindFocusableChild([UIElement]$parent, [ref]$result) {
        if ($result.Value) { return }
        
        foreach ($child in $parent.Children) {
            if ($child.IsFocusable -and $child.Visible -and $child.Enabled) {
                $result.Value = $child
                return
            }
            if ($child.Children.Count -gt 0) {
                $this.FindFocusableChild($child, $result)
            }
        }
    }

    # Override render to center the dialog
    [void] OnRender() {
        # Center the panel
        $this._panel.X = [Math]::Floor(($this.Width - $this._panel.Width) / 2)
        $this._panel.Y = [Math]::Floor(($this.Height - $this._panel.Height) / 2)
        
        # Update panel title
        $this._panel.Title = " $this.Title "
        
        # Clear background with semi-transparent effect (simulate with darker color)
        $bgColor = Get-ThemeColor("overlay.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
    }

    [object] ShowDialog([string]$title, [string]$message) {
        $this.Show($title, $message)
        
        # Navigate to this dialog
        $navService = $null
        if ($null -ne $this.ServiceContainer) {
            $navService = $this.ServiceContainer.GetService("NavigationService")
        }
        if ($navService) {
            $navService.NavigateTo($this)
        }
        
        return $this.Result
    }
}

#<!-- END_PAGE: ACO.014a -->



####\Components\ACO.015_TextBox.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: TextBox =====
# Module: tui-components (wrapper)
# Dependencies: TextBoxComponent
# Purpose: Enhanced wrapper around TextBoxComponent

class TextBox : UIElement {
    hidden [TextBoxComponent]$_textBox

    TextBox([string]$name) : base($name) {
        $this._textBox = [TextBoxComponent]::new($name + "_inner")
        # CRITICAL FIX: Immediately size the inner component to match the wrapper's current size.
        $this._textBox.Resize($this.Width, $this.Height)
        $this.AddChild($this._textBox)
        $this.IsFocusable = $true
    }

    [string] GetText() { return $this._textBox.Text }
    [void] SetText([string]$value) { $this._textBox.Text = $value }
    
    [void] Clear() {
        $this._textBox.Text = ""
        $this._textBox.CursorPosition = 0
        $this._textBox.RequestRedraw()
    }

    [void] Focus() {
        $focusManager = $global:TuiState.Services.FocusManager
        if ($focusManager) {
            $focusManager.SetFocus($this)
        }
    }

    [void] OnFocus() {
        ([UIElement]$this).OnFocus()
        if ($this._textBox) {
            $this._textBox.IsFocused = $true
            $this._textBox.OnFocus()
            $this._textBox.RequestRedraw()
        }
    }

    [void] OnBlur() {
        ([UIElement]$this).OnBlur()
        if ($this._textBox) {
            $this._textBox.IsFocused = $false
            $this._textBox.OnBlur()
            $this._textBox.RequestRedraw()
        }
    }

    [void] OnResize() {
        if ($this._textBox) {
            $this._textBox.Width = $this.Width
            $this._textBox.Height = $this.Height
            $this._textBox.X = 0
            $this._textBox.Y = 0
            # Ensure the inner component's buffer is also resized.
            $this._textBox.Resize($this.Width, $this.Height)
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $this._textBox.HandleInput($key)
    }
}

#<!-- END_PAGE: ACO.015 -->



####\Components\ACO.016_CommandPalette.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: CommandPalette =====
# Module: command-palette
# Dependencies: Dialog, Panel, ListBox, TextBoxComponent
# Purpose: Searchable command interface
class CommandPalette : Dialog {
    hidden [ListBox]$_listBox
    hidden [TextBoxComponent]$_searchBox
    hidden [List[object]]$_allActions
    hidden [List[object]]$_filteredActions
    [scriptblock]$OnExecute
    [scriptblock]$OnCancel

    CommandPalette([string]$name, [object]$serviceContainer) : base($name, $serviceContainer) {
        $this.Width = 60
        $this.Height = 20
        
        $this._allActions = [List[object]]::new()
        $this._filteredActions = [List[object]]::new()
        
        $this.InitializeControls()
    }

    hidden [void] InitializeControls() {
        # Dialog base class already provides _panel with border
        $this._panel.Title = " Command Palette "
        $this._panel.Width = $this.Width
        $this._panel.Height = $this.Height

        # Create search box
        $this._searchBox = [TextBoxComponent]::new("CommandPalette_Search")
        $this._searchBox.X = 2
        $this._searchBox.Y = 1
        $this._searchBox.Width = $this.Width - 4
        $this._searchBox.Height = 3
        $this._searchBox.Placeholder = "Type to search commands..."
        $this._searchBox.Visible = $true
        $this._searchBox.Enabled = $true
        $this._searchBox.IsFocusable = $true
        
        # Connect search box to filtering
        $paletteRef = $this
        $this._searchBox.OnChange = { 
            param($sender, $text) 
            $paletteRef.FilterActions($text) 
        }.GetNewClosure()
        $this._panel.AddChild($this._searchBox)

        # Create list box for results
        $this._listBox = [ListBox]::new("CommandPalette_List")
        $this._listBox.X = 2
        $this._listBox.Y = 4
        $this._listBox.Width = $this.Width - 4
        $this._listBox.Height = $this.Height - 6
        $this._panel.AddChild($this._listBox)
    }

    [void] SetActions([object[]]$actionList) {
        $this._allActions.Clear()
        foreach ($action in $actionList) {
            $this._allActions.Add($action)
        }
        $this.FilterActions("")  # Show all actions initially
    }

    [void] FilterActions([string]$searchText) {
        $this._filteredActions.Clear()
        $this._listBox.ClearItems()
        
        $actionsToDisplay = if ([string]::IsNullOrWhiteSpace($searchText)) { 
            $this._allActions 
        } else {
            $searchLower = $searchText.ToLower()
            @($this._allActions | Where-Object {
                $_.Name.ToLower().Contains($searchLower) -or
                ($_.Description -and $_.Description.ToLower().Contains($searchLower)) -or
                ($_.Category -and $_.Category.ToLower().Contains($searchLower))
            })
        }

        foreach ($action in $actionsToDisplay) {
            $this._filteredActions.Add($action)
            $displayText = if ($action.Category) { 
                "[$($action.Category)] $($action.Name)" 
            } else { 
                $action.Name 
            }
            $this._listBox.AddItem("$displayText - $($action.Description)")
        }
        
        if ($this._filteredActions.Count -gt 0) { 
            $this._listBox.SelectedIndex = 0 
        }
        $this.RequestRedraw()
    }

    [void] SetInitialFocus() {
        if ($this._searchBox) {
            # Clear any previous search text
            $this._searchBox.Text = ""
            $this._searchBox.CursorPosition = 0
            
            # Use FocusManager to properly set focus
            $focusManager = $global:TuiState.Services.FocusManager
            if ($focusManager) {
                $focusManager.SetFocus($this._searchBox)
            }
            $this.RequestRedraw()
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $focusManager = $global:TuiState.Services.FocusManager
        $focusedComponent = if ($focusManager) { $focusManager.FocusedComponent } else { $null }
        
        # Only handle container-level actions
        switch ($key.Key) {
            ([ConsoleKey]::Escape) { 
                $this.Complete($null)  # Signal cancellation
                return $true 
            }
            ([ConsoleKey]::Enter) {
                $focusedName = if ($null -ne $focusedComponent) { $focusedComponent.Name } else { 'null' }
                Write-Log -Level Debug -Message "CommandPalette: Enter key pressed, focused component: $focusedName"
                
                # Execute the currently selected action in the list, regardless of which component has focus
                if ($this._filteredActions.Count -gt 0 -and $this._listBox.SelectedIndex -ge 0 -and $this._listBox.SelectedIndex -lt $this._filteredActions.Count) {
                    $selectedAction = $this._filteredActions[$this._listBox.SelectedIndex]
                    if ($selectedAction) {
                        Write-Log -Level Debug -Message "CommandPalette: Executing selected action at index $($this._listBox.SelectedIndex): $($selectedAction.Name)"
                        Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] CommandPalette calling Complete() with action: $($selectedAction.Name)"
                        $this.Complete($selectedAction)
                        return $true
                    }
                }
                
                Write-Log -Level Debug -Message "CommandPalette: No valid selection to execute"
                return $false
            }
            ([ConsoleKey]::Tab) {
                # Toggle focus between search box and list
                if ($focusManager) {
                    if ($focusedComponent -eq $this._searchBox) {
                        $focusManager.SetFocus($this._listBox)
                    } else {
                        $focusManager.SetFocus($this._searchBox)
                    }
                }
                return $true
            }
            ([ConsoleKey]::UpArrow) {
                # If search box has focus, handle selection movement directly
                if ($focusedComponent -eq $this._searchBox -and $this._filteredActions.Count -gt 0) {
                    # Move selection up in the list (without changing focus)
                    if ($this._listBox.SelectedIndex -gt 0) {
                        $this._listBox.SelectedIndex--
                        $this._listBox.EnsureVisible($this._listBox.SelectedIndex)
                        $this._listBox.RequestRedraw()
                        $this.RequestRedraw()
                    }
                    return $true
                }
                return $false  # Let the list handle it if it has focus
            }
            ([ConsoleKey]::DownArrow) {
                # If search box has focus, handle selection movement directly
                if ($focusedComponent -eq $this._searchBox -and $this._filteredActions.Count -gt 0) {
                    # Move selection down in the list (without changing focus)
                    if ($this._listBox.SelectedIndex -lt $this._filteredActions.Count - 1) {
                        $this._listBox.SelectedIndex++
                        $this._listBox.EnsureVisible($this._listBox.SelectedIndex)
                        $this._listBox.RequestRedraw()
                        $this.RequestRedraw()
                    }
                    return $true
                }
                return $false  # Let the list handle it if it has focus
            }
            ([ConsoleKey]::PageUp) {
                # Move selection up by a page
                if ($this._filteredActions.Count -gt 0) {
                    $pageSize = [Math]::Max(1, $this._listBox.Height - 2)
                    $newIndex = [Math]::Max(0, $this._listBox.SelectedIndex - $pageSize)
                    $this._listBox.SelectedIndex = $newIndex
                    $this._listBox.EnsureVisible($this._listBox.SelectedIndex)
                    $this._listBox.RequestRedraw()
                    $this.RequestRedraw()
                    return $true
                }
                return $false
            }
            ([ConsoleKey]::PageDown) {
                # Move selection down by a page
                if ($this._filteredActions.Count -gt 0) {
                    $pageSize = [Math]::Max(1, $this._listBox.Height - 2)
                    $newIndex = [Math]::Min($this._filteredActions.Count - 1, $this._listBox.SelectedIndex + $pageSize)
                    $this._listBox.SelectedIndex = $newIndex
                    $this._listBox.EnsureVisible($this._listBox.SelectedIndex)
                    $this._listBox.RequestRedraw()
                    $this.RequestRedraw()
                    return $true
                }
                return $false
            }
            ([ConsoleKey]::Home) {
                # Move to first item
                if ($this._filteredActions.Count -gt 0) {
                    $this._listBox.SelectedIndex = 0
                    $this._listBox.EnsureVisible(0)
                    $this._listBox.RequestRedraw()
                    $this.RequestRedraw()
                    return $true
                }
                return $false
            }
            ([ConsoleKey]::End) {
                # Move to last item
                if ($this._filteredActions.Count -gt 0) {
                    $this._listBox.SelectedIndex = $this._filteredActions.Count - 1
                    $this._listBox.EnsureVisible($this._listBox.SelectedIndex)
                    $this._listBox.RequestRedraw()
                    $this.RequestRedraw()
                    return $true
                }
                return $false
            }
            default {
                # Let the input routing system handle everything else
                return $false
            }
        }
        
        # Add explicit return false at end to satisfy all code paths
        return $false
    }

    [void] Cleanup() {
        if ($this._searchBox) {
            $this._searchBox.Text = ""
            $this._searchBox.CursorPosition = 0
        }
        if ($this._listBox) {
            $this._listBox.ClearItems()
            $this._listBox.SelectedIndex = -1
        }
        $this._allActions.Clear()
        $this._filteredActions.Clear()
    }
    
    # Override Complete to ensure proper cleanup
    [void] Complete([object]$result) {
        Write-Log -Level Debug -Message "CommandPalette.Complete called with result: $(if ($null -ne $result) { $result | ConvertTo-Json -Compress } else { 'null' })"
        
        # Clean up our state first
        $this.Cleanup()
        
        # Force a redraw to clear the screen before navigation
        $this.RequestRedraw()
        $global:TuiState.IsDirty = $true
        
        # Call parent Complete which handles navigation and OnClose callback
        ([Dialog]$this).Complete($result)
    }
}

#<!-- END_PAGE: ACO.016 -->

#endregion Composite Components

#region Dialog Components



####\Components\ACO.018_AlertDialog.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: AlertDialog =====
# Module: dialog-system-class
# Dependencies: Dialog, ButtonComponent
# Purpose: Simple message dialog
class AlertDialog : Dialog {
    hidden [ButtonComponent]$_okButton

    AlertDialog([string]$name) : base($name) {
        $this.Height = 8
        $this.InitializeAlert()
    }

    hidden [void] InitializeAlert() {
        # OK button
        $this._okButton = [ButtonComponent]::new($this.Name + "_OK")
        $this._okButton.Text = "OK"
        $this._okButton.Width = 10
        $this._okButton.Height = 3
        $this._okButton.OnClick = {
            $this.Complete($true)
        }.GetNewClosure()
        $this._panel.AddChild($this._okButton)
    }

    [void] Show([string]$title, [string]$message) {
        ([Dialog]$this).Show($title, $message)
        
        # Position OK button
        $this._okButton.X = [Math]::Floor(($this.Width - $this._okButton.Width) / 2)
        $this._okButton.Y = $this.Height - 4
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            # Draw message within the dialog's panel content area
            $panelContentX = $this._panel.ContentX
            $panelContentY = $this._panel.ContentY
            $maxWidth = $this.Width - 4 # Panel width - 2*border - 2*padding

            # Simple word wrap (use Write-TuiText)
            $words = $this.Message -split ' '
            $currentLine = ""
            $currentY = $panelContentY + 1 # Start drawing message below title

            foreach ($word in $words) {
                if (($currentLine + " " + $word).Length -gt $maxWidth) {
                    if ($currentLine) {
                        Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
                        $currentY++
                    }
                    $currentLine = $word
                }
                else {
                    $currentLine = if ($currentLine) { "$currentLine $word" } else { $word }
                }
            }
            if ($currentLine) {
                Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }

        # Let OK button handle input first
        if ($this._okButton.HandleInput($key)) { return $true }
        
        if ($key.Key -eq [ConsoleKey]::Escape -or $key.Key -eq [ConsoleKey]::Enter) {
            $this.Complete($true) # Complete dialog
            return $true
        }
        return $false
    }

    [void] OnEnter() {
        # Set focus to the OK button when dialog appears
        $global:TuiState.Services.FocusManager?.SetFocus($this._okButton)
    }
}

#<!-- END_PAGE: ACO.018 -->



####\Components\ACO.019_ConfirmDialog.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: ConfirmDialog =====
# Module: dialog-system-class
# Dependencies: Dialog, ButtonComponent
# Purpose: Yes/No confirmation dialog
class ConfirmDialog : Dialog {
    hidden [ButtonComponent]$_yesButton
    hidden [ButtonComponent]$_noButton
    # Removed manual focus tracking - will use FocusManager instead

    ConfirmDialog([string]$name) : base($name) {
        $this.Height = 8
        $this.InitializeConfirm()
    }

    hidden [void] InitializeConfirm() {
        # Yes button
        $this._yesButton = [ButtonComponent]::new($this.Name + "_Yes")
        $this._yesButton.Text = "Yes"
        $this._yesButton.Width = 10
        $this._yesButton.Height = 3
        $this._yesButton.TabIndex = 1 # Explicitly set tab order
        $this._yesButton.OnClick = {
            $this.Complete($true)
        }.GetNewClosure()
        $this._panel.AddChild($this._yesButton)

        # No button
        $this._noButton = [ButtonComponent]::new($this.Name + "_No")
        $this._noButton.Text = "No"
        $this._noButton.Width = 10
        $this._noButton.Height = 3
        $this._noButton.TabIndex = 2 # Explicitly set tab order
        $this._noButton.OnClick = {
            $this.Complete($false)
        }.GetNewClosure()
        $this._panel.AddChild($this._noButton)
    }

    [void] Show([string]$title, [string]$message) {
        ([Dialog]$this).Show($title, $message)
        
        # Position buttons
        $buttonY = $this.Height - 4
        $totalWidth = $this._yesButton.Width + $this._noButton.Width + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        $this._yesButton.X = $startX
        $this._yesButton.Y = $buttonY
        
        $this._noButton.X = $startX + $this._yesButton.Width + 4
        $this._noButton.Y = $buttonY
        
    }

    [void] OnEnter() {
        # When the dialog is shown, tell the FocusManager to focus the first element (Yes button)
        $global:TuiState.Services.FocusManager?.SetFocus($this._yesButton)
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            # Draw message (same as AlertDialog)
            $panelContentX = $this._panel.ContentX
            $panelContentY = $this._panel.ContentY
            $maxWidth = $this.Width - 4
            
            $words = $this.Message -split ' '
            $currentLine = ""
            $currentY = $panelContentY + 1
            
            foreach ($word in $words) {
                if (($currentLine + " " + $word).Length -gt $maxWidth) {
                    if ($currentLine) {
                        Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
                        $currentY++
                    }
                    $currentLine = $word
                }
                else {
                    $currentLine = if ($currentLine) { "$currentLine $word" } else { $word }
                }
            }
            
            if ($currentLine) {
                Write-TuiText -Buffer $this._panel._private_buffer -X $panelContentX -Y $currentY -Text $currentLine -Style @{ FG = Get-ThemeColor("dialog.foreground"); BG = Get-ThemeColor("dialog.background") }
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }

        # Handle Escape to cancel
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Complete($false) # Using new Complete method
            return $true
        }

        # The global input handler will route Tab/Shift+Tab to the FocusManager.
        # Left/Right arrow keys can be used to switch between Yes/No buttons
        if ($key.Key -eq [ConsoleKey]::LeftArrow -or $key.Key -eq [ConsoleKey]::RightArrow) {
            $focusManager = $global:TuiState.Services.FocusManager
            if ($focusManager) {
                # Toggle focus between the two buttons
                if ($focusManager.FocusedComponent -eq $this._yesButton) {
                    $focusManager.SetFocus($this._noButton)
                } else {
                    $focusManager.SetFocus($this._yesButton)
                }
                return $true
            }
        }
        
        # Let the focused child handle the input
        # The FocusManager will have already routed input to the focused button
        return $false
    }
}

#<!-- END_PAGE: ACO.019 -->



####\Components\ACO.020_InputDialog.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: InputDialog =====
# Module: dialog-system-class
# Dependencies: Dialog, TextBoxComponent, ButtonComponent
# Purpose: Text input dialog
class InputDialog : Dialog {
    hidden [TextBoxComponent]$_inputBox
    hidden [ButtonComponent]$_okButton
    hidden [ButtonComponent]$_cancelButton
    hidden [bool]$_focusOnInput = $true
    hidden [int]$_focusIndex = 0  # 0=input, 1=ok, 2=cancel

    InputDialog([string]$name) : base($name) {
        $this.Height = 10
        $this.InitializeInput()
    }

    hidden [void] InitializeInput() {
        # Input box
        $this._inputBox = [TextBoxComponent]::new($this.Name + "_Input")
        $this._inputBox.Width = $this.Width - 4
        $this._inputBox.Height = 3
        $this._inputBox.X = 2
        $this._inputBox.Y = 4
        $this._panel.AddChild($this._inputBox)

        # OK button
        $this._okButton = [ButtonComponent]::new($this.Name + "_OK")
        $this._okButton.Text = "OK"
        $this._okButton.Width = 10
        $this._okButton.Height = 3
        $this._okButton.OnClick = {
            $this.Close($this._inputBox.Text)
        }.GetNewClosure()
        $this._panel.AddChild($this._okButton)

        # Cancel button
        $this._cancelButton = [ButtonComponent]::new($this.Name + "_Cancel")
        $this._cancelButton.Text = "Cancel"
        $this._cancelButton.Width = 10
        $this._cancelButton.Height = 3
        $this._cancelButton.OnClick = {
            $this.Close($null)
        }.GetNewClosure()
        $this._panel.AddChild($this._cancelButton)
    }

    [void] Show([string]$title, [string]$message, [string]$defaultValue = "") {
        ([Dialog]$this).Show($title, $message)
        
        $this._inputBox.Text = $defaultValue
        $this._inputBox.CursorPosition = $defaultValue.Length
        
        # Position buttons
        $buttonY = $this.Height - 4
        $totalWidth = $this._okButton.Width + $this._cancelButton.Width + 4
        $startX = [Math]::Floor(($this.Width - $totalWidth) / 2)
        
        $this._okButton.X = $startX
        $this._okButton.Y = $buttonY
        
        $this._cancelButton.X = $startX + $this._okButton.Width + 4
        $this._cancelButton.Y = $buttonY
        
        # Set initial focus
        $this._focusIndex = 0
        $this.UpdateFocus()
    }

    hidden [void] UpdateFocus() {
        $this._inputBox.IsFocused = ($this._focusIndex -eq 0)
        $this._okButton.IsFocused = ($this._focusIndex -eq 1)
        $this._cancelButton.IsFocused = ($this._focusIndex -eq 2)
    }

    [void] OnRender() {
        ([Dialog]$this).OnRender()
        
        if ($this.Visible -and $this.Message) {
            # Draw message
            $this._panel._private_buffer.WriteString(2, 2, 
                $this.Message, [ConsoleColor]::White, [ConsoleColor]::Black)
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [ConsoleKey]::Escape) {
            $this.Close($null)
            return $true
        }
        
        if ($key.Key -eq [ConsoleKey]::Tab) {
            $this._focusIndex = ($this._focusIndex + 1) % 3
            $this.UpdateFocus()
            $this.RequestRedraw()
            return $true
        }
        
        switch ($this._focusIndex) {
            0 { return $this._inputBox.HandleInput($key) }
            1 { return $this._okButton.HandleInput($key) }
            2 { return $this._cancelButton.HandleInput($key) }
        }
        
        return $false
    }
}

# Task Create/Edit Dialog
class TaskDialog : Dialog {
    hidden [TextBoxComponent] $_titleBox
    hidden [MultilineTextBoxComponent] $_descriptionBox
    hidden [ComboBoxComponent] $_statusCombo
    hidden [ComboBoxComponent] $_priorityCombo
    hidden [NumericInputComponent] $_progressInput
    hidden [ButtonComponent] $_saveButton
    hidden [ButtonComponent] $_cancelButton
    hidden [PmcTask] $_task
    hidden [bool] $_isNewTask
    
    TaskDialog([string]$title, [PmcTask]$task) : base($title) {
        $this._task = if ($task) { $task } else { [PmcTask]::new() }
        $this._isNewTask = ($null -eq $task)
        $this.Width = 60
        $this.Height = 20
    }
    
    [void] Initialize() {
        ([Dialog]$this).Initialize()
        
        $contentY = 2
        $labelWidth = 12
        $inputX = $labelWidth + 2
        $inputWidth = $this.ContentWidth - $inputX - 2
        
        # Title
        $titleLabel = [LabelComponent]::new("TitleLabel")
        $titleLabel.Text = "Title:"
        $titleLabel.X = 2
        $titleLabel.Y = $contentY
        $this._panel.AddChild($titleLabel)
        
        $this._titleBox = [TextBoxComponent]::new("TitleBox")
        $this._titleBox.X = $inputX
        $this._titleBox.Y = $contentY
        $this._titleBox.Width = $inputWidth
        $this._titleBox.Height = 1
        $this._titleBox.Text = $this._task.Title
        $this._panel.AddChild($this._titleBox)
        $contentY += 2
        
        # Description
        $descLabel = [LabelComponent]::new("DescLabel")
        $descLabel.Text = "Description:"
        $descLabel.X = 2
        $descLabel.Y = $contentY
        $this._panel.AddChild($descLabel)
        
        $this._descriptionBox = [MultilineTextBoxComponent]::new("DescBox")
        $this._descriptionBox.X = $inputX
        $this._descriptionBox.Y = $contentY
        $this._descriptionBox.Width = $inputWidth
        $this._descriptionBox.Height = 3
        $this._descriptionBox.Text = $this._task.Description
        $this._panel.AddChild($this._descriptionBox)
        $contentY += 4
        
        # Status
        $statusLabel = [LabelComponent]::new("StatusLabel")
        $statusLabel.Text = "Status:"
        $statusLabel.X = 2
        $statusLabel.Y = $contentY
        $this._panel.AddChild($statusLabel)
        
        $this._statusCombo = [ComboBoxComponent]::new("StatusCombo")
        $this._statusCombo.X = $inputX
        $this._statusCombo.Y = $contentY
        $this._statusCombo.Width = $inputWidth
        $this._statusCombo.Height = 1
        $this._statusCombo.Items = @([TaskStatus]::GetEnumNames())
        $this._statusCombo.SelectedIndex = [Array]::IndexOf($this._statusCombo.Items, $this._task.Status.ToString())
        $this._panel.AddChild($this._statusCombo)
        $contentY += 2
        
        # Priority
        $priorityLabel = [LabelComponent]::new("PriorityLabel")
        $priorityLabel.Text = "Priority:"
        $priorityLabel.X = 2
        $priorityLabel.Y = $contentY
        $this._panel.AddChild($priorityLabel)
        
        $this._priorityCombo = [ComboBoxComponent]::new("PriorityCombo")
        $this._priorityCombo.X = $inputX
        $this._priorityCombo.Y = $contentY
        $this._priorityCombo.Width = $inputWidth
        $this._priorityCombo.Height = 1
        $this._priorityCombo.Items = @([TaskPriority]::GetEnumNames())
        $this._priorityCombo.SelectedIndex = [Array]::IndexOf($this._priorityCombo.Items, $this._task.Priority.ToString())
        $this._panel.AddChild($this._priorityCombo)
        $contentY += 2
        
        # Progress
        $progressLabel = [LabelComponent]::new("ProgressLabel")
        $progressLabel.Text = "Progress %:"
        $progressLabel.X = 2
        $progressLabel.Y = $contentY
        $this._panel.AddChild($progressLabel)
        
        $this._progressInput = [NumericInputComponent]::new("ProgressInput")
        $this._progressInput.X = $inputX
        $this._progressInput.Y = $contentY
        $this._progressInput.Width = 10
        $this._progressInput.Height = 1
        $this._progressInput.MinValue = 0
        $this._progressInput.MaxValue = 100
        $this._progressInput.Value = $this._task.Progress
        $this._panel.AddChild($this._progressInput)
        $contentY += 3
        
        # Buttons
        $buttonY = $this.ContentHeight - 3
        $buttonWidth = 12
        $spacing = 2
        $totalButtonWidth = ($buttonWidth * 2) + $spacing
        $startX = [Math]::Floor(($this.ContentWidth - $totalButtonWidth) / 2)
        
        $this._saveButton = [ButtonComponent]::new("SaveButton")
        $this._saveButton.Text = "Save"
        $this._saveButton.X = $startX
        $this._saveButton.Y = $buttonY
        $this._saveButton.Width = $buttonWidth
        $this._saveButton.Height = 1
        $thisDialog = $this
        $this._saveButton.OnClick = {
            $thisDialog.DialogResult = [DialogResult]::OK
            $thisDialog.Complete($thisDialog.DialogResult)
        }.GetNewClosure()
        $this._panel.AddChild($this._saveButton)
        
        $this._cancelButton = [ButtonComponent]::new("CancelButton")
        $this._cancelButton.Text = "Cancel"
        $this._cancelButton.X = $startX + $buttonWidth + $spacing
        $this._cancelButton.Y = $buttonY
        $this._cancelButton.Width = $buttonWidth
        $this._cancelButton.Height = 1
        $this._cancelButton.OnClick = {
            $thisDialog.DialogResult = [DialogResult]::Cancel
            $thisDialog.Complete($thisDialog.DialogResult)
        }.GetNewClosure()
        $this._panel.AddChild($this._cancelButton)
        
        # Set initial focus
        Set-ComponentFocus -Component $this._titleBox
    }
    
    [PmcTask] GetTask() {
        if ($this.DialogResult -eq [DialogResult]::OK) {
            # Update task with form values
            $this._task.Title = $this._titleBox.Text
            $this._task.Description = $this._descriptionBox.Text
            $this._task.Status = [TaskStatus]::($this._statusCombo.Items[$this._statusCombo.SelectedIndex])
            $this._task.Priority = [TaskPriority]::($this._priorityCombo.Items[$this._priorityCombo.SelectedIndex])
            $this._task.SetProgress($this._progressInput.Value)
            $this._task.UpdatedAt = [DateTime]::Now
        }
        return $this._task
    }
}

# Task Delete Confirmation Dialog
class TaskDeleteDialog : ConfirmDialog { 
    hidden [PmcTask] $_task
    
    TaskDeleteDialog([PmcTask]$task) : base("Confirm Delete", "Are you sure you want to delete this task?") {
        $this._task = $task
    }
    
    [void] Initialize() {
        ([ConfirmDialog]$this).Initialize()
        
        # Add task details to the message
        if ($this._task) {
            $detailsLabel = [LabelComponent]::new("TaskDetails")
            $detailsLabel.Text = "Task: $($this._task.Title)"
            $detailsLabel.X = 2
            $detailsLabel.Y = 4
            $detailsLabel.ForegroundColor = Get-ThemeColor -ColorName "Warning" -DefaultColor "#FFA500"
            $this._panel.AddChild($detailsLabel)
        }
    }
}

#endregion Dialog Components

#region Navigation Components

#<!-- END_PAGE: ACO.020 -->



####\Components\ACO.021_NavigationMenu.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: NavigationMenu =====
# Module: navigation-class
# Dependencies: UIElement, NavigationItem
# Purpose: Local menu component
class NavigationMenu : UIElement {
    [List[NavigationItem]]$Items
    [int]$SelectedIndex = 0
    [string]$Orientation = "Horizontal"  # Horizontal or Vertical
    [string]$BackgroundColor = "#000000"
    [string]$ForegroundColor = "#FFFFFF"
    [string]$SelectedBackgroundColor = "#0078D4"
    [string]$SelectedForegroundColor = "#FFFF00"

    NavigationMenu([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Items = [List[NavigationItem]]::new()
        $this.Height = 1
    }

    [void] AddItem([NavigationItem]$item) {
        $this.Items.Add($item)
        $this.RequestRedraw()
    }

    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        try {
            $this._private_buffer.Clear([TuiCell]::new(' ', $this.ForegroundColor, $this.BackgroundColor))
            
            if ($this.Orientation -eq "Horizontal") {
                $this.RenderHorizontal()
            }
            else {
                $this.RenderVertical()
            }
        }
        catch {}
    }

    hidden [void] RenderHorizontal() {
        $currentX = 0
        
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex -and $this.IsFocused)
            
            $fg = if ($isSelected) { $this.SelectedForegroundColor } else { $this.ForegroundColor }
            $bg = if ($isSelected) { $this.SelectedBackgroundColor } else { $this.BackgroundColor }
            
            # Draw item
            $text = " $($item.Label) "
            if ($item.Key) {
                $text = " $($item.Label) ($($item.Key)) "
            }
            
            if ($currentX + $text.Length -le $this.Width) {
                for ($x = 0; $x -lt $text.Length; $x++) {
                    $this._private_buffer.SetCell($currentX + $x, 0, 
                        [TuiCell]::new($text[$x], $fg, $bg))
                }
            }
            
            $currentX += $text.Length + 1
        }
    }

    hidden [void] RenderVertical() {
        # Ensure height matches item count
        if ($this.Height -ne $this.Items.Count -and $this.Items.Count -gt 0) {
            $this.Height = $this.Items.Count
            # Resize the buffer to match new height
            if ($this._private_buffer) {
                $this._private_buffer.Resize($this.Width, $this.Height)
            }
        }
        
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex -and $this.IsFocused)
            
            $fg = if ($isSelected) { $this.SelectedForegroundColor } else { $this.ForegroundColor }
            $bg = if ($isSelected) { $this.SelectedBackgroundColor } else { $this.BackgroundColor }
            
            # Clear line
            for ($x = 0; $x -lt $this.Width; $x++) {
                $this._private_buffer.SetCell($x, $i, [TuiCell]::new(' ', $fg, $bg))
            }
            
            # Draw item
            $text = $item.Label
            if ($item.Key) {
                $text = "$($item.Label) ($($item.Key))"
            }
            
            if ($text.Length -gt $this.Width) {
                $text = $text.Substring(0, $this.Width - 3) + "..."
            }
            
            $this._private_buffer.WriteString(0, $i, $text, @{ FG = $fg; BG = $bg })
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $true
        
        if ($this.Orientation -eq "Horizontal") {
            switch ($key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                        $this.SelectedIndex++
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this.ExecuteItem($this.SelectedIndex)
                }
                default {
                    # Check hotkeys
                    $handled = $this.CheckHotkey($key)
                }
            }
        }
        else {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                        $this.SelectedIndex++
                    }
                }
                ([ConsoleKey]::Enter) {
                    $this.ExecuteItem($this.SelectedIndex)
                }
                default {
                    $handled = $this.CheckHotkey($key)
                }
            }
        }
        
        if ($handled) {
            $this.RequestRedraw()
        }
        
        return $handled
    }

    hidden [bool] CheckHotkey([System.ConsoleKeyInfo]$key) {
        foreach ($i in 0..($this.Items.Count - 1)) {
            $item = $this.Items[$i]
            if ($item.Key -and $item.Key.ToUpper() -eq $key.KeyChar.ToString().ToUpper()) {
                $this.SelectedIndex = $i
                $this.ExecuteItem($i)
                return $true
            }
        }
        return $false
    }

    hidden [void] ExecuteItem([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $item = $this.Items[$index]
            if ($item.Action) {
                try {
                    & $item.Action
                }
                catch {}
            }
        }
    }
}

#<!-- END_PAGE: ACO.021 -->



####\Components\ACO.022_DataGridComponent.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Components
# UI components that extend UIElement - full implementations from axiom
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ACO.###" to find specific sections.
# Each section ends with "END_PAGE: ACO.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Management.Automation

#

# ===== CLASS: DataGridComponent =====
# Module: data-grid-component
# Dependencies: UIElement, TuiCell
# Purpose: Generic data grid for displaying tabular data with scrolling and selection
class DataGridComponent : UIElement {
    [hashtable[]]$Columns = @()
    [hashtable[]]$Items = @()
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowHeaders = $true
    [string]$HeaderBackgroundColor = "#333333"
    [string]$HeaderForegroundColor = "#FFFFFF"
    [string]$SelectedBackgroundColor = "#0078D4"
    [string]$SelectedForegroundColor = "#FFFFFF"
    [string]$NormalBackgroundColor = "#000000"
    [string]$NormalForegroundColor = "#C0C0C0"
    [scriptblock]$OnSelectionChanged
    
    DataGridComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
        $this.Width = 60
        $this.Height = 20
    }
    
    [void] OnRender() {
        if (-not $this.Visible -or $null -eq $this._private_buffer) { return }
        
        # Clear buffer
        $bgColor = Get-ThemeColor("component.background")
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        $y = 0
        
        # Render headers if enabled
        if ($this.ShowHeaders -and $this.Columns.Count -gt 0) {
            $x = 0
            foreach ($column in $this.Columns) {
                $header = if ($column.Header) { $column.Header } else { $column.Name }
                $width = if ($column.Width) { $column.Width } else { 10 }
                
                # Truncate header if needed
                if ($header.Length -gt $width) {
                    $header = $header.Substring(0, [Math]::Max(1, $width - 2)) + ".."
                }
                
                # Pad header to column width
                $header = $header.PadRight($width)
                
                Write-TuiText -Buffer $this._private_buffer -X $x -Y $y -Text $header -Style @{
                    FG = $this.HeaderForegroundColor
                    BG = $this.HeaderBackgroundColor
                }
                
                $x += $width + 1  # +1 for separator
            }
            $y++
        }
        
        # Calculate visible items
        $visibleHeight = $this.Height - $(if ($this.ShowHeaders) { 1 } else { 0 })
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($this.Items.Count - 1, $startIndex + $visibleHeight - 1)
        
        # Render data rows
        for ($i = $startIndex; $i -le $endIndex; $i++) {
            if ($i -ge $this.Items.Count) { break }
            
            $item = $this.Items[$i]
            $isSelected = ($i -eq $this.SelectedIndex)
            
            $x = 0
            foreach ($column in $this.Columns) {
                $value = if ($item.ContainsKey($column.Name)) { $item[$column.Name] } else { "" }
                $width = if ($column.Width) { $column.Width } else { 10 }
                
                # Convert value to string and truncate if needed
                $text = $value.ToString()
                if ($text.Length -gt $width) {
                    $text = $text.Substring(0, [Math]::Max(1, $width - 2)) + ".."
                }
                
                # Pad text to column width
                $text = $text.PadRight($width)
                
                # Set colors based on selection
                $fgColor = if ($isSelected) { $this.SelectedForegroundColor } else { $this.NormalForegroundColor }
                $bgColor = if ($isSelected) { $this.SelectedBackgroundColor } else { $this.NormalBackgroundColor }
                
                Write-TuiText -Buffer $this._private_buffer -X $x -Y $y -Text $text -Style @{
                    FG = $fgColor
                    BG = $bgColor
                }
                
                $x += $width + 1  # +1 for separator
            }
            $y++
        }
        
        $this._needs_redraw = $false
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.Enabled -or -not $this.IsFocused) { return $false }
        
        $handled = $false
        $oldSelectedIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $this._EnsureVisible()
                    $handled = $true
                }
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                    $this.SelectedIndex++
                    $this._EnsureVisible()
                    $handled = $true
                }
            }
            ([ConsoleKey]::PageUp) {
                $visibleHeight = $this.Height - $(if ($this.ShowHeaders) { 1 } else { 0 })
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $visibleHeight)
                $this._EnsureVisible()
                $handled = $true
            }
            ([ConsoleKey]::PageDown) {
                $visibleHeight = $this.Height - $(if ($this.ShowHeaders) { 1 } else { 0 })
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $visibleHeight)
                $this._EnsureVisible()
                $handled = $true
            }
            ([ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this._EnsureVisible()
                $handled = $true
            }
            ([ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
                $this._EnsureVisible()
                $handled = $true
            }
        }
        
        # Fire selection changed event if selection changed
        if ($handled -and $oldSelectedIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
            & $this.OnSelectionChanged $this $this.SelectedIndex
        }
        
        if ($handled) {
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    hidden [void] _EnsureVisible() {
        if ($this.Items.Count -eq 0) { return }
        
        $visibleHeight = $this.Height - $(if ($this.ShowHeaders) { 1 } else { 0 })
        
        # Scroll up if selected item is above visible area
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        }
        # Scroll down if selected item is below visible area
        elseif ($this.SelectedIndex -gt ($this.ScrollOffset + $visibleHeight - 1)) {
            $this.ScrollOffset = $this.SelectedIndex - $visibleHeight + 1
        }
        
        # Ensure scroll offset is within bounds
        $this.ScrollOffset = [Math]::Max(0, [Math]::Min($this.ScrollOffset, $this.Items.Count - $visibleHeight))
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SetItems([hashtable[]]$items) {
        $this.Items = $items
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this.RequestRedraw()
    }
    
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this.RequestRedraw()
    }
}
#<!-- END_PAGE: ACO.022 -->



####\Components\ACO.023_SidebarMenu.ps1
# ===== CLASS: SidebarMenu =====
# Purpose: Simple vertical menu for navigation
class SidebarMenu : UIElement {
    [System.Collections.ArrayList]$MenuItems = [System.Collections.ArrayList]::new()
    [hashtable]$KeyMap = @{}
    [string]$Title = "Menu"
    [bool]$ShowBorder = $true
    
    SidebarMenu([string]$name) : base($name) {
        $this.IsFocusable = $false  # Menu is not focusable, responds to keys directly
        $this.Width = 20
    }
    
    [void] AddMenuItem([string]$key, [string]$label, [string]$action) {
        $menuItem = @{
            Key = $key
            Label = $label  
            Action = $action
        }
        $this.MenuItems.Add($menuItem) | Out-Null
        $this.KeyMap[$key.ToUpper()] = $action
    }
    
    [void] ClearItems() {
        $this.MenuItems.Clear()
        $this.KeyMap.Clear()
    }
    
    [void] OnRender() {
        if (-not $this._private_buffer) { return }
        
        # Clear buffer with background color
        $bgColor = Get-ThemeColor -ColorName "panel.background" -DefaultColor "#1E1E1E"
        $this._private_buffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            Write-TuiBox -Buffer $this._private_buffer -X 0 -Y 0 -Width $this.Width -Height $this.Height -Style @{
                BorderStyle = "Single"
                BorderFG = Get-ThemeColor "component.border"
                BorderBG = $bgColor
                FillBackground = $true
                FillBG = $bgColor
            }
        }
        
        $y = 1  # Start at 1 to avoid border
        $maxTextWidth = $this.Width - 6  # Reserve space for key display and margins
        
        # Draw title
        if ($this.Title) {
            $titleColor = Get-ThemeColor -ColorName "component.title" -DefaultColor "#FFFFFF"
            Write-TuiText -Buffer $this._private_buffer -X 1 -Y $y -Text $this.Title -Style @{
                FG = $titleColor
                BG = $bgColor
            }
            $y += 2
        }
        
        # Draw menu items
        foreach ($item in $this.MenuItems) {
            if ($item.Key -eq "-") {
                # Separator
                $sepColor = Get-ThemeColor -ColorName "component.border" -DefaultColor "#606060"
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y $y -Text ("─" * ($this.Width - 2)) -Style @{
                    FG = $sepColor
                    BG = $bgColor
                }
            } else {
                # Menu item
                $keyDisplay = "[$($item.Key)]"
                $label = $item.Label
                
                # Truncate label if too long
                if ($label.Length -gt $maxTextWidth) {
                    $label = $label.Substring(0, $maxTextWidth - 2) + ".."
                }
                
                $accentColor = Get-ThemeColor -ColorName "Accent" -DefaultColor "#0078D4"
                $fgColor = Get-ThemeColor -ColorName "Foreground" -DefaultColor "#FFFFFF"
                
                Write-TuiText -Buffer $this._private_buffer -X 1 -Y $y -Text $keyDisplay -Style @{
                    FG = $accentColor
                    BG = $bgColor
                }
                Write-TuiText -Buffer $this._private_buffer -X 5 -Y $y -Text $label -Style @{
                    FG = $fgColor
                    BG = $bgColor
                }
            }
            $y++
        }
    }
    
    [string] GetAction([string]$key) {
        $upperKey = $key.ToUpper()
        if ($this.KeyMap.ContainsKey($upperKey)) {
            return $this.KeyMap[$upperKey]
        }
        return $null
    }
    
    [bool] HandleKey([System.ConsoleKeyInfo]$keyInfo) {
        # Handle direct key presses for menu navigation
        $key = $keyInfo.KeyChar.ToString().ToUpper()
        
        # Debug logging
        Write-Log -Level Debug -Message "SidebarMenu.HandleKey: Received key '$key' (KeyChar: '$($keyInfo.KeyChar)', Key: '$($keyInfo.Key)')"
        
        $action = $this.GetAction($key)
        
        if ($action) {
            Write-Log -Level Debug -Message "SidebarMenu.HandleKey: Found action '$action' for key '$key'"
            $actionService = $global:TuiState.Services.ActionService
            if ($actionService) {
                try {
                    $actionService.ExecuteAction($action, @{})
                    return $true
                } catch {
                    Write-Log -Level Error -Message "Failed to execute menu action '$action': $_"
                }
            } else {
                Write-Log -Level Error -Message "SidebarMenu.HandleKey: ActionService is null!"
            }
        } else {
            Write-Log -Level Debug -Message "SidebarMenu.HandleKey: No action found for key '$key'"
        }
        
        return $false
    }
}



####\Components\ACO.100_TextEngine.ps1
# ==============================================================================
# High-Performance Text Buffer Engine for Axiom-Phoenix
# Implements gap buffer with line indexing for optimal editing performance
# ==============================================================================

using namespace System.Collections.Generic

# Interface for edit commands (for undo/redo)
class IEditCommand {
    [void] Execute([TextBuffer]$buffer) { throw "Must override Execute" }
    [void] Undo([TextBuffer]$buffer) { throw "Must override Undo" }
    [string] ToString() { return "EditCommand" }
}

# Insert text command
class InsertCommand : IEditCommand {
    [int]$Position
    [string]$Text
    [int]$CursorBefore
    [int]$CursorAfter
    
    InsertCommand([int]$position, [string]$text, [int]$cursorBefore) {
        $this.Position = $position
        $this.Text = $text
        $this.CursorBefore = $cursorBefore
        $this.CursorAfter = $position + $text.Length
    }
    
    [void] Execute([TextBuffer]$buffer) {
        $buffer.InsertAt($this.Position, $this.Text)
    }
    
    [void] Undo([TextBuffer]$buffer) {
        $buffer.DeleteRange($this.Position, $this.Text.Length)
    }
}

# Delete text command
class DeleteCommand : IEditCommand {
    [int]$Position
    [string]$DeletedText
    [int]$CursorBefore
    [int]$CursorAfter
    
    DeleteCommand([int]$position, [int]$length, [string]$deletedText, [int]$cursorBefore) {
        $this.Position = $position
        $this.DeletedText = $deletedText
        $this.CursorBefore = $cursorBefore
        $this.CursorAfter = $position
    }
    
    [void] Execute([TextBuffer]$buffer) {
        $buffer.DeleteRange($this.Position, $this.DeletedText.Length)
    }
    
    [void] Undo([TextBuffer]$buffer) {
        $buffer.InsertAt($this.Position, $this.DeletedText)
    }
}

# High-performance text buffer using gap buffer algorithm
class TextBuffer {
    # Gap buffer arrays
    hidden [List[char]]$_preGap
    hidden [List[char]]$_postGap
    hidden [int]$_gapSize = 1024
    
    # Line tracking for O(1) line access
    hidden [List[int]]$_lineStarts  # Starting position of each line
    hidden [Dictionary[int,int]]$_lineLengths  # Cache of line lengths
    
    # Change tracking
    hidden [HashSet[int]]$_dirtyLines
    hidden [int]$_version = 0
    hidden [bool]$_linesCacheValid = $false
    
    # Properties
    [int]$Length = 0
    [int]$LineCount = 1
    
    TextBuffer() {
        $this._preGap = [List[char]]::new()
        $this._postGap = [List[char]]::new()
        $this._lineStarts = [List[int]]::new()
        $this._lineStarts.Add(0)  # First line starts at 0
        $this._lineLengths = [Dictionary[int,int]]::new()
        $this._dirtyLines = [HashSet[int]]::new()
    }
    
    # Get cursor position (gap position)
    [int] GetCursorPosition() {
        return $this._preGap.Count
    }
    
    # Move cursor to position (move gap)
    [void] SetCursorPosition([int]$position) {
        if ($position -lt 0) { $position = 0 }
        if ($position -gt $this.Length) { $position = $this.Length }
        
        $currentPos = $this._preGap.Count
        if ($position -eq $currentPos) { return }
        
        if ($position -lt $currentPos) {
            # Move gap left
            $moveCount = $currentPos - $position
            for ($i = 0; $i -lt $moveCount; $i++) {
                if ($this._preGap.Count -gt 0) {
                    $char = $this._preGap[$this._preGap.Count - 1]
                    $this._preGap.RemoveAt($this._preGap.Count - 1)
                    $this._postGap.Insert(0, $char)
                }
            }
        } else {
            # Move gap right
            $moveCount = $position - $currentPos
            for ($i = 0; $i -lt $moveCount; $i++) {
                if ($this._postGap.Count -gt 0) {
                    $char = $this._postGap[0]
                    $this._postGap.RemoveAt(0)
                    $this._preGap.Add($char)
                }
            }
        }
    }
    
    # Insert character at cursor
    [void] InsertChar([char]$char) {
        $this._preGap.Add($char)
        $this.Length++
        $this._version++
        
        if ($char -eq "`n") {
            $this._linesCacheValid = $false
            $this.InvalidateLinesFrom($this.GetLineFromPosition($this._preGap.Count - 1))
        } else {
            $line = $this.GetLineFromPosition($this._preGap.Count - 1)
            $this._dirtyLines.Add($line) | Out-Null
        }
    }
    
    # Insert string at cursor
    [void] Insert([string]$text) {
        if ([string]::IsNullOrEmpty($text)) { return }
        
        foreach ($char in $text.ToCharArray()) {
            $this._preGap.Add($char)
            $this.Length++
        }
        
        $this._version++
        $this._linesCacheValid = $false
        $this.InvalidateLinesFrom($this.GetLineFromPosition($this._preGap.Count - $text.Length))
    }
    
    # Insert at specific position
    [void] InsertAt([int]$position, [string]$text) {
        $oldPos = $this.GetCursorPosition()
        $this.SetCursorPosition($position)
        $this.Insert($text)
        $this.SetCursorPosition($oldPos + $text.Length)
    }
    
    # Delete character before cursor (backspace)
    [bool] DeleteBackward() {
        if ($this._preGap.Count -eq 0) { return $false }
        
        $deletedChar = $this._preGap[$this._preGap.Count - 1]
        $this._preGap.RemoveAt($this._preGap.Count - 1)
        $this.Length--
        $this._version++
        
        if ($deletedChar -eq "`n") {
            $this._linesCacheValid = $false
            $this.InvalidateLinesFrom($this.GetLineFromPosition($this._preGap.Count))
        } else {
            $line = $this.GetLineFromPosition($this._preGap.Count)
            $this._dirtyLines.Add($line) | Out-Null
        }
        
        return $true
    }
    
    # Delete character at cursor (delete)
    [bool] DeleteForward() {
        if ($this._postGap.Count -eq 0) { return $false }
        
        $deletedChar = $this._postGap[0]
        $this._postGap.RemoveAt(0)
        $this.Length--
        $this._version++
        
        if ($deletedChar -eq "`n") {
            $this._linesCacheValid = $false
            $this.InvalidateLinesFrom($this.GetLineFromPosition($this._preGap.Count))
        } else {
            $line = $this.GetLineFromPosition($this._preGap.Count)
            $this._dirtyLines.Add($line) | Out-Null
        }
        
        return $true
    }
    
    # Delete range of text
    [string] DeleteRange([int]$start, [int]$length) {
        if ($length -le 0) { return "" }
        
        $oldPos = $this.GetCursorPosition()
        $this.SetCursorPosition($start)
        
        $deleted = [System.Text.StringBuilder]::new()
        for ($i = 0; $i -lt $length -and $this._postGap.Count -gt 0; $i++) {
            $deleted.Append($this._postGap[0]) | Out-Null
            $this._postGap.RemoveAt(0)
            $this.Length--
        }
        
        $this._version++
        $this._linesCacheValid = $false
        $this.InvalidateLinesFrom($this.GetLineFromPosition($start))
        
        return $deleted.ToString()
    }
    
    # Get character at position
    [char] GetChar([int]$position) {
        if ($position -lt 0 -or $position -ge $this.Length) {
            throw "Position out of range"
        }
        
        if ($position -lt $this._preGap.Count) {
            return $this._preGap[$position]
        } else {
            return $this._postGap[$position - $this._preGap.Count]
        }
    }
    
    # Get substring
    [string] GetText([int]$start, [int]$length) {
        if ($start -lt 0) { $start = 0 }
        if ($start + $length -gt $this.Length) { $length = $this.Length - $start }
        if ($length -le 0) { return "" }
        
        $sb = [System.Text.StringBuilder]::new($length)
        $end = $start + $length
        
        for ($i = $start; $i -lt $end; $i++) {
            if ($i -lt $this._preGap.Count) {
                $sb.Append($this._preGap[$i]) | Out-Null
            } else {
                $sb.Append($this._postGap[$i - $this._preGap.Count]) | Out-Null
            }
        }
        
        return $sb.ToString()
    }
    
    # Get all text
    [string] GetAllText() {
        return $this.GetText(0, $this.Length)
    }
    
    # Get line from position
    [int] GetLineFromPosition([int]$position) {
        if (-not $this._linesCacheValid) {
            $this.RebuildLineCache()
        }
        
        # Binary search for line
        $left = 0
        $right = $this._lineStarts.Count - 1
        
        while ($left -le $right) {
            $mid = ($left + $right) / 2
            $lineStart = $this._lineStarts[$mid]
            
            if ($position -lt $lineStart) {
                $right = $mid - 1
            } elseif ($mid -eq $this._lineStarts.Count - 1 -or $position -lt $this._lineStarts[$mid + 1]) {
                return $mid
            } else {
                $left = $mid + 1
            }
        }
        
        return [Math]::Max(0, $this._lineStarts.Count - 1)
    }
    
    # Get line start position
    [int] GetLineStart([int]$line) {
        if (-not $this._linesCacheValid) {
            $this.RebuildLineCache()
        }
        
        if ($line -lt 0) { return 0 }
        if ($line -ge $this._lineStarts.Count) { return $this.Length }
        
        return $this._lineStarts[$line]
    }
    
    # Get line end position
    [int] GetLineEnd([int]$line) {
        if (-not $this._linesCacheValid) {
            $this.RebuildLineCache()
        }
        
        if ($line -lt 0) { return 0 }
        if ($line -ge $this._lineStarts.Count - 1) { return $this.Length }
        
        return $this._lineStarts[$line + 1] - 1  # Exclude newline
    }
    
    # Get line text
    [string] GetLineText([int]$line) {
        $start = $this.GetLineStart($line)
        $end = $this.GetLineEnd($line)
        
        if ($end -gt $start -and $this.GetChar($end - 1) -eq "`n") {
            $end--
        }
        
        return $this.GetText($start, $end - $start)
    }
    
    # Rebuild line cache
    hidden [void] RebuildLineCache() {
        $this._lineStarts.Clear()
        $this._lineStarts.Add(0)
        
        for ($i = 0; $i -lt $this.Length; $i++) {
            if ($this.GetChar($i) -eq "`n") {
                $this._lineStarts.Add($i + 1)
            }
        }
        
        $this.LineCount = $this._lineStarts.Count
        $this._linesCacheValid = $true
        $this._dirtyLines.Clear()
        
        # Mark all lines as dirty after rebuild
        for ($i = 0; $i -lt $this.LineCount; $i++) {
            $this._dirtyLines.Add($i) | Out-Null
        }
    }
    
    # Invalidate lines from a specific line
    hidden [void] InvalidateLinesFrom([int]$startLine) {
        if (-not $this._linesCacheValid) { return }
        
        for ($i = $startLine; $i -lt $this.LineCount; $i++) {
            $this._dirtyLines.Add($i) | Out-Null
        }
    }
    
    # Get dirty lines and clear
    [int[]] GetAndClearDirtyLines() {
        $dirty = @($this._dirtyLines)
        $this._dirtyLines.Clear()
        return $dirty
    }
    
    # Word boundary detection
    [bool] IsWordChar([char]$char) {
        return [char]::IsLetterOrDigit($char) -or $char -eq '_'
    }
    
    # Find next word boundary
    [int] FindNextWordBoundary([int]$position, [bool]$forward = $true) {
        if ($position -lt 0) { $position = 0 }
        if ($position -gt $this.Length) { $position = $this.Length }
        
        if ($forward) {
            # Skip current word
            while ($position -lt $this.Length -and $this.IsWordChar($this.GetChar($position))) {
                $position++
            }
            # Skip whitespace
            while ($position -lt $this.Length -and [char]::IsWhiteSpace($this.GetChar($position))) {
                $position++
            }
        } else {
            if ($position -gt 0) { $position-- }
            # Skip whitespace
            while ($position -gt 0 -and [char]::IsWhiteSpace($this.GetChar($position))) {
                $position--
            }
            # Skip to word start
            while ($position -gt 0 -and $this.IsWordChar($this.GetChar($position - 1))) {
                $position--
            }
        }
        
        return $position
    }
    
    # Find matching bracket
    [int] FindMatchingBracket([int]$position) {
        if ($position -lt 0 -or $position -ge $this.Length) { return -1 }
        
        $char = $this.GetChar($position)
        $openBrackets = '([{'
        $closeBrackets = ')]}'
        
        $openIndex = $openBrackets.IndexOf($char)
        $closeIndex = $closeBrackets.IndexOf($char)
        
        if ($openIndex -ge 0) {
            # Forward search
            $match = $closeBrackets[$openIndex]
            $depth = 1
            $pos = $position + 1
            
            while ($pos -lt $this.Length -and $depth -gt 0) {
                $c = $this.GetChar($pos)
                if ($c -eq $char) { $depth++ }
                elseif ($c -eq $match) { $depth-- }
                $pos++
            }
            
            return if ($depth -eq 0) { $pos - 1 } else { -1 }
        }
        elseif ($closeIndex -ge 0) {
            # Backward search
            $match = $openBrackets[$closeIndex]
            $depth = 1
            $pos = $position - 1
            
            while ($pos -ge 0 -and $depth -gt 0) {
                $c = $this.GetChar($pos)
                if ($c -eq $char) { $depth++ }
                elseif ($c -eq $match) { $depth-- }
                $pos--
            }
            
            return if ($depth -eq 0) { $pos + 1 } else { -1 }
        }
        
        return -1
    }
}

# Search result
class SearchResult {
    [int]$Start
    [int]$Length
    [int]$Line
    [string]$LineText
    
    SearchResult([int]$start, [int]$length, [int]$line, [string]$lineText) {
        $this.Start = $start
        $this.Length = $length
        $this.Line = $line
        $this.LineText = $lineText
    }
}

# Search engine for incremental search
class SearchEngine {
    hidden [TextBuffer]$_buffer
    hidden [string]$_lastPattern = ""
    hidden [List[SearchResult]]$_results
    hidden [int]$_currentResultIndex = -1
    hidden [bool]$_caseSensitive = $false
    hidden [bool]$_wholeWord = $false
    hidden [bool]$_useRegex = $false
    
    SearchEngine([TextBuffer]$buffer) {
        $this._buffer = $buffer
        $this._results = [List[SearchResult]]::new()
    }
    
    # Perform search
    [SearchResult[]] Search([string]$pattern, [bool]$caseSensitive = $false, [bool]$wholeWord = $false) {
        if ([string]::IsNullOrEmpty($pattern)) {
            $this._results.Clear()
            $this._currentResultIndex = -1
            return @()
        }
        
        $this._lastPattern = $pattern
        $this._caseSensitive = $caseSensitive
        $this._wholeWord = $wholeWord
        $this._results.Clear()
        
        $text = $this._buffer.GetAllText()
        $searchPattern = if ($caseSensitive) { $pattern } else { $pattern.ToLower() }
        $searchText = if ($caseSensitive) { $text } else { $text.ToLower() }
        
        $index = 0
        while ($index -lt $searchText.Length) {
            $foundIndex = $searchText.IndexOf($searchPattern, $index)
            if ($foundIndex -eq -1) { break }
            
            # Check whole word
            if ($wholeWord) {
                $isWordStart = $foundIndex -eq 0 -or -not $this._buffer.IsWordChar($text[$foundIndex - 1])
                $isWordEnd = $foundIndex + $pattern.Length -ge $text.Length -or -not $this._buffer.IsWordChar($text[$foundIndex + $pattern.Length])
                
                if (-not ($isWordStart -and $isWordEnd)) {
                    $index = $foundIndex + 1
                    continue
                }
            }
            
            $line = $this._buffer.GetLineFromPosition($foundIndex)
            $lineText = $this._buffer.GetLineText($line)
            
            $result = [SearchResult]::new($foundIndex, $pattern.Length, $line, $lineText)
            $this._results.Add($result)
            
            $index = $foundIndex + 1
        }
        
        if ($this._results.Count -gt 0) {
            $this._currentResultIndex = 0
        }
        
        return $this._results.ToArray()
    }
    
    # Get current result
    [SearchResult] GetCurrentResult() {
        if ($this._currentResultIndex -ge 0 -and $this._currentResultIndex -lt $this._results.Count) {
            return $this._results[$this._currentResultIndex]
        }
        return $null
    }
    
    # Move to next result
    [SearchResult] NextResult() {
        if ($this._results.Count -eq 0) { return $null }
        
        $this._currentResultIndex = ($this._currentResultIndex + 1) % $this._results.Count
        return $this._results[$this._currentResultIndex]
    }
    
    # Move to previous result
    [SearchResult] PreviousResult() {
        if ($this._results.Count -eq 0) { return $null }
        
        $this._currentResultIndex = ($this._currentResultIndex - 1 + $this._results.Count) % $this._results.Count
        return $this._results[$this._currentResultIndex]
    }
    
    # Replace current occurrence
    [bool] ReplaceCurrent([string]$replacement) {
        $current = $this.GetCurrentResult()
        if (-not $current) { return $false }
        
        $oldPos = $this._buffer.GetCursorPosition()
        $this._buffer.SetCursorPosition($current.Start)
        $this._buffer.DeleteRange($current.Start, $current.Length)
        $this._buffer.Insert($replacement)
        $this._buffer.SetCursorPosition($oldPos)
        
        # Re-search after replacement
        $this.Search($this._lastPattern, $this._caseSensitive, $this._wholeWord)
        
        return $true
    }
    
    # Replace all occurrences
    [int] ReplaceAll([string]$replacement) {
        if ($this._results.Count -eq 0) { return 0 }
        
        $count = 0
        $oldPos = $this._buffer.GetCursorPosition()
        
        # Replace from end to start to maintain positions
        for ($i = $this._results.Count - 1; $i -ge 0; $i--) {
            $result = $this._results[$i]
            $this._buffer.SetCursorPosition($result.Start)
            $this._buffer.DeleteRange($result.Start, $result.Length)
            $this._buffer.Insert($replacement)
            $count++
        }
        
        $this._buffer.SetCursorPosition($oldPos)
        $this._results.Clear()
        $this._currentResultIndex = -1
        
        return $count
    }
}

# Text selection
class TextSelection {
    [int]$Start = -1
    [int]$End = -1
    [bool]$IsActive = $false
    
    [void] StartSelection([int]$position) {
        $this.Start = $position
        $this.End = $position
        $this.IsActive = $true
    }
    
    [void] UpdateSelection([int]$position) {
        if ($this.IsActive) {
            $this.End = $position
        }
    }
    
    [void] ClearSelection() {
        $this.Start = -1
        $this.End = -1
        $this.IsActive = $false
    }
    
    [int] GetNormalizedStart() {
        if (-not $this.IsActive) { return -1 }
        return [Math]::Min($this.Start, $this.End)
    }
    
    [int] GetNormalizedEnd() {
        if (-not $this.IsActive) { return -1 }
        return [Math]::Max($this.Start, $this.End)
    }
    
    [int] GetLength() {
        if (-not $this.IsActive) { return 0 }
        return [Math]::Abs($this.End - $this.Start)
    }
    
    [bool] ContainsPosition([int]$position) {
        if (-not $this.IsActive) { return $false }
        $start = $this.GetNormalizedStart()
        $end = $this.GetNormalizedEnd()
        return $position -ge $start -and $position -lt $end
    }
}



####\Functions\AFU.001_TUIDrawingFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#region TUI Drawing Functions

function Write-TuiText {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][string]$Text,
        [hashtable]$Style = @{} # Accepts a hashtable for all style properties
    )
    
    if ($null -eq $Buffer -or [string]::IsNullOrEmpty($Text)) { 
        # Write-Log -Level Debug -Message "Write-TuiText: Skipped for buffer '$($Buffer.Name)' due to empty text."
        return 
    }
    
    # Now simply pass the style hashtable to TuiBuffer.WriteString
    $Buffer.WriteString($X, $Y, $Text, $Style)
    
    # Write-Log -Level Debug -Message "Write-TuiText: Wrote '$Text' to buffer '$($Buffer.Name)' at ($X, $Y)."
}

function Write-TuiBox {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][TuiBuffer]$Buffer,
        [Parameter(Mandatory)][int]$X,
        [Parameter(Mandatory)][int]$Y,
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [string]$Title = "",
        [hashtable]$Style = @{} # All visual aspects now passed via Style hashtable
    )
    
    if ($null -eq $Buffer -or $Width -le 0 -or $Height -le 0) {
        # Write-Log -Level Warning -Message "Write-TuiBox: Invalid dimensions ($($Width)x$($Height)). Dimensions must be positive."
        return
    }

    # Extract properties from the style object with safe fallbacks.
    $borderStyleName = if ($Style.ContainsKey('BorderStyle')) { $Style['BorderStyle'] } else { "Single" }
    $borderColor = if ($Style.ContainsKey('BorderFG')) { $Style['BorderFG'] } else { "#808080" } # Default border color (gray hex)
    $bgColor = if ($Style.ContainsKey('BG')) { $Style['BG'] } else { "#000000" }           # Default background color (black hex)
    $titleColor = if ($Style.ContainsKey('TitleFG')) { $Style['TitleFG'] } else { $borderColor } # Title defaults to border color
    $fillChar = if ($Style.ContainsKey('FillChar')) { [char]$Style['FillChar'] } else { ' ' }   # Optional fill character

    $borders = Get-TuiBorderChars -Style $borderStyleName
    
    # Define style objects for child calls to Write-TuiText.
    $generalStyle = @{ FG = $borderColor; BG = $bgColor } # For borders
    $fillStyle = @{ FG = $borderColor; BG = $bgColor }    # For fill area (fill char uses border fg)
    
    $titleTextStyle = @{ FG = $titleColor; BG = $bgColor }
    # Merge any additional title style overrides (e.g., Bold = $true for title)
    if ($Style.ContainsKey('TitleStyle') -and $Style['TitleStyle']) {
        foreach ($key in $Style['TitleStyle'].Keys) { $titleTextStyle[$key] = $Style['TitleStyle'][$key] }
    }

    # Fill background of the entire box area first
    $Buffer.FillRect($X, $Y, $Width, $Height, $fillChar, $fillStyle)
    
    # Top border - handle edge cases for small dimensions
    if ($Height -gt 0) {
        if ($Width -gt 2) {
            # Normal case: Width >= 3
            $middlePart = $borders.Horizontal * ($Width - 2)
            Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text "$($borders.TopLeft)$middlePart$($borders.TopRight)" -Style $generalStyle
        } elseif ($Width -eq 2) {
            # Special case: Width = 2 (just corners)
            Write-TuiText -Buffer $Buffer -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.TopRight)" -Style $generalStyle
        } elseif ($Width -eq 1) {
            # Special case: Width = 1 (just a vertical line segment)
            $Buffer.SetCell($X, $Y, [TuiCell]::new($borders.Vertical, $generalStyle.FG, $generalStyle.BG))
        }
    }

    # Side borders
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $i) -Text $borders.Vertical -Style $generalStyle
        if ($Width -gt 1) {
            Write-TuiText -Buffer $Buffer -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -Style $generalStyle
        }
    }
    
    # Bottom border - handle edge cases for small dimensions
    if ($Height -gt 1) {
        if ($Width -gt 2) {
            # Normal case: Width >= 3
            $middlePart = $borders.Horizontal * ($Width - 2)
            Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$middlePart$($borders.BottomRight)" -Style $generalStyle
        } elseif ($Width -eq 2) {
            # Special case: Width = 2 (just corners)
            Write-TuiText -Buffer $Buffer -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.BottomRight)" -Style $generalStyle
        } elseif ($Width -eq 1) {
            # Special case: Width = 1 (just a vertical line segment)
            $Buffer.SetCell($X, $Y + $Height - 1, [TuiCell]::new($borders.Vertical, $generalStyle.FG, $generalStyle.BG))
        }
    }

    # Draw title if specified
    if (-not [string]::IsNullOrEmpty($Title) -and $Y -ge 0 -and $Y -lt $Buffer.Height) {
        $titleText = " $Title "
        
        # Truncate title if too long
        $maxTitleLength = $Width - 2
        if ($titleText.Length -gt $maxTitleLength -and $maxTitleLength -gt 3) {
            $titleText = $titleText.Substring(0, $maxTitleLength - 3) + "..."
        }
        
        if ($titleText.Length -le ($Width - 2) -and $Width -gt 2) {
            $titleAlignment = $Style.TitleAlignment ?? "TopBorder" # Default to current behavior
            $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
            
            # Calculate title Y position based on alignment
            $titleY = $Y # Default to top border
            switch ($titleAlignment) {
                "TopBorder" { $titleY = $Y }  # Default - on the top border
                "Top" { $titleY = $Y + 1 }    # Just inside the top border
                "Center" { $titleY = $Y + [Math]::Floor($Height / 2) }  # Vertically centered
                "Bottom" { $titleY = $Y + $Height - 2 }  # Just inside the bottom border
                default { $titleY = $Y }      # Fallback to top border
            }
            
            # Ensure title Y is within buffer bounds
            if ($titleY -ge 0 -and $titleY -lt $Buffer.Height) {
                Write-TuiText -Buffer $Buffer -X $titleX -Y $titleY -Text $titleText -Style $titleTextStyle
            }
        }
    }
    
    $Buffer.IsDirty = $true
    # Write-Log -Level Debug -Message "Write-TuiBox: Drew '$borderStyleName' box on buffer '$($Buffer.Name)' at ($X, $Y) with dimensions $($Width)x$($Height)."
}

#endregion
#<!-- END_PAGE: AFU.001 -->



####\Functions\AFU.002_BorderFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#region Border Functions

function Get-TuiBorderChars {
    [CmdletBinding()]
    param(
        [ValidateSet("Single", "Double", "Rounded", "Thick")][string]$Style = "Single"
    )
    
    $styles = @{
        Single = @{ 
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'; 
            Horizontal = '─'; Vertical = '│' 
        }
        Double = @{ 
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'; 
            Horizontal = '═'; Vertical = '║' 
        }
        Rounded = @{ 
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'; 
            Horizontal = '─'; Vertical = '│' 
        }
        Thick = @{ 
            TopLeft = '┏'; TopRight = '┓'; BottomLeft = '┗'; BottomRight = '┛'; 
            Horizontal = '━'; Vertical = '┃' 
        }
    }
    
    $selectedStyle = $styles[$Style]
    if ($null -eq $selectedStyle) {
        Write-Warning "Get-TuiBorderChars: Border style '$Style' not found. Returning 'Single' style."
        return $styles.Single
    }
    
    Write-Verbose "Get-TuiBorderChars: Retrieved TUI border characters for style: $Style."
    return $selectedStyle
}

#endregion
#<!-- END_PAGE: AFU.002 -->



####\Functions\AFU.003_FactoryFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#region Factory Functions

function New-TuiBuffer {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][int]$Width,
        [Parameter(Mandatory)][int]$Height,
        [string]$Name = "Unnamed"
    )
    return [TuiBuffer]::new($Width, $Height, $Name)
}

function New-TuiLabel {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Text = "",
        [int]$X = 0,
        [int]$Y = 0,
        [string]$ForegroundColor = $null
    )
    
    $label = [LabelComponent]::new($Name)
    $label.Text = $Text
    $label.X = $X
    $label.Y = $Y
    if ($ForegroundColor) {
        $label.ForegroundColor = $ForegroundColor
    }
    return $label
}

function New-TuiButton {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Text = "Button",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 10,
        [int]$Height = 3,
        [scriptblock]$OnClick = $null
    )
    
    $button = [ButtonComponent]::new($Name)
    $button.Text = $Text
    $button.X = $X
    $button.Y = $Y
    $button.Width = $Width
    $button.Height = $Height
    if ($OnClick) {
        $button.OnClick = $OnClick
    }
    return $button
}

function New-TuiTextBox {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Placeholder = "",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 20,
        [int]$Height = 3,
        [int]$MaxLength = 100,
        [scriptblock]$OnChange = $null
    )
    
    $textBox = [TextBoxComponent]::new($Name)
    $textBox.Placeholder = $Placeholder
    $textBox.X = $X
    $textBox.Y = $Y
    $textBox.Width = $Width
    $textBox.Height = $Height
    $textBox.MaxLength = $MaxLength
    if ($OnChange) {
        $textBox.OnChange = $OnChange
    }
    return $textBox
}

function New-TuiCheckBox {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Text = "Checkbox",
        [int]$X = 0,
        [int]$Y = 0,
        [bool]$Checked = $false,
        [scriptblock]$OnChange = $null
    )
    
    $checkBox = [CheckBoxComponent]::new($Name)
    $checkBox.Text = $Text
    $checkBox.X = $X
    $checkBox.Y = $Y
    $checkBox.Checked = $Checked
    if ($OnChange) {
        $checkBox.OnChange = $OnChange
    }
    return $checkBox
}

function New-TuiRadioButton {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$Text = "Radio",
        [string]$GroupName = "default",
        [int]$X = 0,
        [int]$Y = 0,
        [bool]$Selected = $false,
        [scriptblock]$OnChange = $null
    )
    
    $radioButton = [RadioButtonComponent]::new($Name)
    $radioButton.Text = $Text
    $radioButton.GroupName = $GroupName
    $radioButton.X = $X
    $radioButton.Y = $Y
    $radioButton.Selected = $Selected
    if ($OnChange) {
        $radioButton.OnChange = $OnChange
    }
    return $radioButton
}

#endregion
#<!-- END_PAGE: AFU.003 -->



####\Functions\AFU.004_ThemeFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#region Theme Functions

function Get-ThemeColor {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ColorName,
        
        [string]$DefaultColor = "#808080"
    )
    
    $themeManager = $global:TuiState.Services.ThemeManager
    if ($themeManager) {
        # ThemeManager.GetColor already guarantees hex format
        $color = $themeManager.GetColor($ColorName)
        if ($color) {
            return $color
        }
    }
    
    # Write-Log -Level Debug -Message "Get-ThemeColor: Color '$ColorName' not found, using default '$DefaultColor'"
    return $DefaultColor
}

#endregion
#<!-- END_PAGE: AFU.004 -->



####\Functions\AFU.005_FocusManagement.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#region Focus Management Functions

function Set-ComponentFocus {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][UIElement]$Component
    )
    
    # This function is now obsolete - use FocusManager service instead
    $focusManager = $global:TuiState.Services.FocusManager
    if ($focusManager) {
        $focusManager.SetFocus($Component)
    } else {
        Write-Warning "Set-ComponentFocus is deprecated. FocusManager service not available."
    }
}

#endregion
#<!-- END_PAGE: AFU.005 -->



####\Functions\AFU.006_LoggingFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#region Logging Functions

function Write-Log {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet('Trace', 'Debug', 'Info', 'Warning', 'Error', 'Fatal')]
        [string]$Level,
        
        [Parameter(Mandatory)]
        [string]$Message,
        
        [object]$Data = $null
    )
    
    # Try to get logger from global state first
    $logger = $null
    try {
        if ($global:TuiState -and 
            $global:TuiState.Services -and 
            $global:TuiState.Services -is [hashtable] -and
            $global:TuiState.Services.ContainsKey('Logger')) {
            $logger = $global:TuiState.Services['Logger']
        }
    }
    catch {
        # Silently ignore any errors accessing global state
        $logger = $null
    }
    
    if ($logger) {
        # Combine message and data into a single log entry for better correlation
        $finalMessage = $Message
        if ($Data) {
            try {
                # Handle UIElement objects specially to avoid circular reference issues
                if ($Data -is [UIElement]) {
                    $finalMessage = "$Message | Data: [UIElement: Name=$($Data.Name), Type=$($Data.GetType().Name)]"
                }
                elseif ($Data -is [System.Collections.IEnumerable] -and -not ($Data -is [string])) {
                    # Handle collections
                    $count = 0
                    try { $count = @($Data).Count } catch { }
                    $finalMessage = "$Message | Data: [Collection with $count items]"
                }
                else {
                    # For other objects, try to serialize but catch any errors
                    $dataJson = $null
                    try {
                        $dataJson = $Data | ConvertTo-Json -Compress -Depth 10 -ErrorAction Stop
                    } catch {
                        # Serialization failed, use simple representation
                    }
                    
                    if ($dataJson) {
                        $finalMessage = "$Message | Data: $dataJson"
                    } else {
                        $finalMessage = "$Message | Data: $($Data.ToString())"
                    }
                }
            }
            catch {
                # If all else fails, just use type name
                $finalMessage = "$Message | Data: [Object of type $($Data.GetType().Name)]"
            }
        }
        # Logger.Log method signature is: Log([string]$message, [string]$level = "Info")
        $logger.Log($finalMessage, $Level)
    }
    else {
        # Fallback to console if logger not available
        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        $prefix = "[$timestamp] [$Level]"
        
        switch ($Level) {
            'Error' { Write-Host "$prefix $Message" -ForegroundColor Red }
            'Warning' { Write-Host "$prefix $Message" -ForegroundColor Yellow }
            'Info' { Write-Host "$prefix $Message" -ForegroundColor Cyan }
            'Debug' { Write-Host "$prefix $Message" -ForegroundColor Gray }
            default { Write-Host "$prefix $Message" }
        }
    }
}

#endregion
#<!-- END_PAGE: AFU.006 -->



####\Functions\AFU.007_EventFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#region Event System

function Subscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [Parameter(Mandatory)][scriptblock]$Handler,
        [string]$Source = ""
    )
    
    if ($global:TuiState.Services.EventManager) {
        return $global:TuiState.Services.EventManager.Subscribe($EventName, $Handler)
    }
    
    # Fallback
    $subscriptionId = [Guid]::NewGuid().ToString()
    Write-Verbose "Subscribed to event '$EventName' with handler ID: $subscriptionId"
    return $subscriptionId
}

function Unsubscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [Parameter(Mandatory)][string]$HandlerId
    )
    
    if ($global:TuiState.Services.EventManager) {
        $global:TuiState.Services.EventManager.Unsubscribe($EventName, $HandlerId)
    }
    Write-Verbose "Unsubscribed from event '$EventName' (Handler ID: $HandlerId)"
}

function Publish-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EventName,
        [hashtable]$EventData = @{}
    )
    
    if ($global:TuiState.Services.EventManager) {
        $global:TuiState.Services.EventManager.Publish($EventName, $EventData)
    }
    Write-Verbose "Published event '$EventName'"
}

#endregion
#<!-- END_PAGE: AFU.007 -->



####\Functions\AFU.008_ErrorHandling.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#region Error Handling Functions

# No specific error handling functions currently implemented
# This section reserved for future error management utilities

#endregion
#<!-- END_PAGE: AFU.008 -->



####\Functions\AFU.009_InputProcessing.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#region Input Processing Functions

# No specific input processing functions currently implemented
# This section reserved for future input handling utilities

#endregion
#<!-- END_PAGE: AFU.009 -->



####\Functions\AFU.010_UtilityFunctions.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Functions (Load After Classes)
# Standalone functions for TUI operations and utilities
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AFU.###" to find specific sections.
# Each section ends with "END_PAGE: AFU.###"
# ==============================================================================

#region Utility Functions

# Initialize functions removed - Start.ps1 now uses direct service instantiation

# ===== FUNCTION: Show-CommandPalette (Temporary Workaround) =====
# Module: command-palette-workaround
# Dependencies: Global TUI state
# Purpose: Alternative command palette implementation
function Show-CommandPalette {
    # Direct command palette implementation
    $actionService = $global:TuiState.Services.ActionService
    $focusManager = $global:TuiState.Services.FocusManager
    
    if (-not $actionService) {
        Write-Host "ActionService not available!" -ForegroundColor Red
        return
    }
    
    # Create a simple selection menu
    $actions = @()
    foreach ($entry in $actionService.ActionRegistry.GetEnumerator()) {
        $actions += [PSCustomObject]@{
            Key = $entry.Key
            Name = $entry.Value.Name
            Description = $entry.Value.Description
            Category = $entry.Value.Category
        }
    }
    
    # Sort by category and name
    $actions = $actions | Sort-Object Category, Name
    
    # Display in console (temporary)
    Clear-Host
    Write-Host "=== COMMAND PALETTE ===" -ForegroundColor Cyan
    Write-Host "Press number to select action, ESC to cancel" -ForegroundColor Yellow
    Write-Host ""
    
    $index = 1
    $actionMap = @{}
    foreach ($action in $actions) {
        Write-Host "[$index] [$($action.Category)] $($action.Name) - $($action.Description)"
        $actionMap[$index] = $action.Key
        $index++
    }
    
    # Get selection
    $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    if ($key.VirtualKeyCode -eq 27) { # ESC
        Clear-Host
        return
    }
    
    $selection = [int]$key.Character - 48  # Convert char to number
    if ($actionMap.ContainsKey($selection)) {
        Clear-Host
        $actionService.ExecuteAction($actionMap[$selection], @{})
    } else {
        Clear-Host
    }
}

# ===== FUNCTION: Register-CommandPaletteWorkaround =====
#UNCOMMENT **ONLY** IF OTHER METHODS FAIL**
# Module: command-palette-workaround
# Dependencies: ActionService
# Purpose: Override the command palette action with temporary fix
#function Register-CommandPaletteWorkaround {
#    # Override the command palette action
#    $actionService = $global:TuiState.Services.ActionService
#    if ($actionService) {
#        $actionService.RegisterAction("app.commandPalette", {
#            Show-CommandPalette
#        }, @{
#            Category = "Application"
#            Description = "Show command palette (temporary fix)"
#            Hotkey = "Ctrl+P"
#        })
#        Write-Host "Command Palette workaround registered. Use Ctrl+P to test." -ForegroundColor Green
#    }
#}

#endregion
#<!-- END_PAGE: AFU.010 -->



####\Models\AMO.001_Enums.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Models (No UI Dependencies) - UPDATED
# Data models, enums, and validation classes
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AMO.###" to find specific sections.
# Each section ends with "END_PAGE: AMO.###"
# ==============================================================================

#region Enums

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

enum BillingType {
    Billable
    NonBillable
}

enum DialogResult {
    None
    OK
    Cancel
    Yes
    No
    Abort
    Retry
    Ignore
}

#endregion
#<!-- END_PAGE: AMO.001 -->



####\Models\AMO.002_ValidationBase.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Models (No UI Dependencies) - UPDATED
# Data models, enums, and validation classes
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AMO.###" to find specific sections.
# Each section ends with "END_PAGE: AMO.###"
# ==============================================================================

#region Base Validation Class

# ===== CLASS: ValidationBase =====
# Module: models (from axiom)
# Dependencies: None
# Purpose: Provides common validation methods used across model classes
class ValidationBase {
    # Validates that a string value is not null, empty, or whitespace.
    # Throws an ArgumentException if the validation fails.
    static [void] ValidateNotEmpty(
        [string]$value,
        [string]$parameterName
    ) {
        try {
            if ([string]::IsNullOrWhiteSpace($value)) {
                $errorMessage = "Parameter '$($parameterName)' cannot be null or empty."
                throw [System.ArgumentException]::new($errorMessage, $parameterName)
            }
        }
        catch {
            # Re-throw to ensure calling context handles the exception
            throw
        }
    }
}

#endregion
#<!-- END_PAGE: AMO.002 -->



####\Models\AMO.003_CoreModelClasses.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Models (No UI Dependencies) - UPDATED
# Data models, enums, and validation classes
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AMO.###" to find specific sections.
# Each section ends with "END_PAGE: AMO.###"
# ==============================================================================

#region Core Model Classes

# ===== CLASS: PmcTask =====
# Module: models (from axiom)
# Dependencies: ValidationBase, TaskStatus, TaskPriority enums
# Purpose: Represents a single task with lifecycle methods
class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString() # Unique identifier for the task
    [string]$Title                            # Short descriptive title
    [string]$Description                      # Detailed description
    [TaskStatus]$Status = [TaskStatus]::Pending # Current status of the task
    [TaskPriority]$Priority = [TaskPriority]::Medium # Importance level
    [string]$ProjectKey = "General"           # Associated project (key)
    [string]$Category                         # Alias for ProjectKey, for broader use
    [datetime]$CreatedAt = [datetime]::Now   # Timestamp of creation
    [datetime]$UpdatedAt = [datetime]::Now   # Last update timestamp
    [Nullable[datetime]]$DueDate             # Optional due date
    [string[]]$Tags = @()                     # Array of tags
    [int]$Progress = 0                        # Progress percentage (0-100)
    [bool]$Completed = $false                 # Convenience flag for completed status

    # Default constructor: Initializes a new task with default values.
    PmcTask() {}
    
    # Constructor: Initializes a new task with a title.
    PmcTask([string]$title) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title
    }
    
    # Constructor: Initializes a new task with common detailed properties.
    PmcTask(
        [string]$title,
        [string]$description,
        [TaskPriority]$priority,
        [string]$projectKey
    ) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")

        $this.Title = $title
        $this.Description = $description
        $this.Priority = $priority
        $this.ProjectKey = $projectKey
        $this.Category = $projectKey # Category is often an alias for ProjectKey
    }

    # Complete: Marks the task as completed, setting progress to 100% and updating timestamp.
    [void] Complete() {
        $this.Status = [TaskStatus]::Completed
        $this.Progress = 100
        $this.Completed = $true
        $this.UpdatedAt = [datetime]::Now
    }
    
    # Cancel: Marks the task as cancelled and updates timestamp.
    [void] Cancel() {
        $this.Status = [TaskStatus]::Cancelled
        $this.UpdatedAt = [datetime]::Now
    }
    
    # SetProgress: Updates the progress percentage and adjusts status accordingly.
    [void] SetProgress([int]$progress) {
        if ($progress -lt 0 -or $progress -gt 100) {
            throw [System.ArgumentOutOfRangeException]::new("progress", "Progress must be between 0 and 100.")
        }
        
        $this.Progress = $progress
        
        # Auto-update status based on progress
        if ($progress -eq 0 -and $this.Status -eq [TaskStatus]::InProgress) {
            $this.Status = [TaskStatus]::Pending
        }
        elseif ($progress -gt 0 -and $progress -lt 100) {
            $this.Status = [TaskStatus]::InProgress
        }
        elseif ($progress -eq 100) {
            $this.Complete()
        }
        
        $this.UpdatedAt = [datetime]::Now
    }
    
    # AddTag: Adds a tag to the task if not already present.
    [void] AddTag([string]$tag) {
        [ValidationBase]::ValidateNotEmpty($tag, "Tag")
        if ($this.Tags -notcontains $tag) {
            $this.Tags += $tag
            $this.UpdatedAt = [datetime]::Now
        }
    }
    
    # RemoveTag: Removes a tag from the task.
    [void] RemoveTag([string]$tag) {
        $this.Tags = $this.Tags | Where-Object { $_ -ne $tag }
        $this.UpdatedAt = [datetime]::Now
    }
    
    # GetAge: Returns the age of the task as a TimeSpan.
    [TimeSpan] GetAge() {
        return [datetime]::Now - $this.CreatedAt
    }
    
    # IsOverdue: Checks if the task is overdue based on DueDate.
    [bool] IsOverdue() {
        if ($null -eq $this.DueDate) { return $false }
        if ($this.Status -in @([TaskStatus]::Completed, [TaskStatus]::Cancelled)) { return $false }
        return [datetime]::Now -gt $this.DueDate
    }
    
    # Clone: Creates a deep copy of the task with a new ID.
    [PmcTask] Clone() {
        $clone = [PmcTask]::new()
        $clone.Title = $this.Title
        $clone.Description = $this.Description
        $clone.Status = $this.Status
        $clone.Priority = $this.Priority
        $clone.ProjectKey = $this.ProjectKey
        $clone.Category = $this.Category
        $clone.DueDate = $this.DueDate
        $clone.Tags = $this.Tags.Clone()
        $clone.Progress = $this.Progress
        $clone.Completed = $this.Completed
        # New task gets new timestamps and ID
        $clone.CreatedAt = [datetime]::Now
        $clone.UpdatedAt = [datetime]::Now
        return $clone
    }
    
    # ToLegacyFormat: Converts task to hashtable for JSON serialization
    [hashtable] ToLegacyFormat() {
        return @{
            Id = $this.Id
            Title = $this.Title
            Description = $this.Description
            Status = $this.Status.ToString()
            Priority = $this.Priority.ToString()
            ProjectKey = $this.ProjectKey
            Category = $this.Category
            CreatedAt = $this.CreatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
            UpdatedAt = $this.UpdatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
            DueDate = if ($this.DueDate) { $this.DueDate.ToString("yyyy-MM-ddTHH:mm:ss") } else { $null }
            Tags = $this.Tags
            Progress = $this.Progress
            Completed = $this.Completed
        }
    }
    
    # FromLegacyFormat: Creates task from hashtable (JSON deserialization)
    static [PmcTask] FromLegacyFormat([hashtable]$data) {
        $task = [PmcTask]::new()
        
        if ($data.ContainsKey('Id')) { $task.Id = $data.Id }
        if ($data.ContainsKey('Title')) { $task.Title = $data.Title }
        if ($data.ContainsKey('Description')) { $task.Description = $data.Description }
        if ($data.ContainsKey('Status')) { 
            $task.Status = [System.Enum]::Parse([TaskStatus], $data.Status, $true)
        }
        if ($data.ContainsKey('Priority')) { 
            $task.Priority = [System.Enum]::Parse([TaskPriority], $data.Priority, $true)
        }
        if ($data.ContainsKey('ProjectKey')) { $task.ProjectKey = $data.ProjectKey }
        if ($data.ContainsKey('Category')) { $task.Category = $data.Category }
        if ($data.ContainsKey('CreatedAt')) { 
            $task.CreatedAt = [DateTime]::Parse($data.CreatedAt)
        }
        if ($data.ContainsKey('UpdatedAt')) { 
            $task.UpdatedAt = [DateTime]::Parse($data.UpdatedAt)
        }
        if ($data.ContainsKey('DueDate') -and $data.DueDate) { 
            $task.DueDate = [DateTime]::Parse($data.DueDate)
        }
        if ($data.ContainsKey('Tags')) { $task.Tags = @($data.Tags) }
        if ($data.ContainsKey('Progress')) { $task.Progress = [int]$data.Progress }
        if ($data.ContainsKey('Completed')) { $task.Completed = [bool]$data.Completed }
        
        return $task
    }
    
    # ToString: Returns a string representation of the task.
    [string] ToString() {
        $statusSymbol = switch ($this.Status) {
            ([TaskStatus]::Pending) { "○" }
            ([TaskStatus]::InProgress) { "◐" }
            ([TaskStatus]::Completed) { "●" }
            ([TaskStatus]::Cancelled) { "✕" }
            default { "?" }
        }
        
        $prioritySymbol = switch ($this.Priority) {
            ([TaskPriority]::Low) { "↓" }
            ([TaskPriority]::Medium) { "→" }
            ([TaskPriority]::High) { "↑" }
            default { "-" }
        }
        
        $overdueFlag = if ($this.IsOverdue()) { " [OVERDUE]" } else { "" }
        
        return "$statusSymbol $prioritySymbol $($this.Title) ($($this.Progress)%)$overdueFlag"
    }
}

# ===== CLASS: PmcProject =====
# Module: models (from axiom)
# Dependencies: ValidationBase
# Purpose: Represents a project that contains multiple tasks
class PmcProject : ValidationBase {
    [string]$Key                              # Unique project key (e.g., "PROJ-001")
    [string]$Name                             # Project name
    [string]$Description                      # Project description
    [DateTime]$CreatedAt = [DateTime]::Now  # Creation timestamp
    [DateTime]$UpdatedAt = [DateTime]::Now  # Last update timestamp
    [string]$Owner                           # Project owner
    [string[]]$Tags = @()                    # Project tags
    [hashtable]$Metadata = @{}               # Additional project metadata
    [bool]$IsActive = $true                  # Whether project is active
    
    # Enhanced properties from reference implementation
    [string]$ID1                             # Optional secondary identifier
    [Nullable[datetime]]$BFDate              # Bring-Forward date for follow-ups
    [string]$ProjectFolderPath               # Full path to the project's root folder on disk
    [string]$CaaFileName                     # Relative name of the associated CAA file
    [string]$RequestFileName                 # Relative name of the associated Request file
    [string]$T2020FileName                   # Relative name of the associated T2020 file

    # Default constructor
    PmcProject() {}

    # Constructor with key and name
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key
        $this.Name = $name
    }

    # Constructor with full details
    PmcProject([string]$key, [string]$name, [string]$description, [string]$owner) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        [ValidationBase]::ValidateNotEmpty($owner, "Owner")
        
        $this.Key = $key
        $this.Name = $name
        $this.Description = $description
        $this.Owner = $owner
    }

    # Archive: Marks the project as inactive
    [void] Archive() {
        $this.IsActive = $false
        $this.UpdatedAt = [DateTime]::Now
    }

    # Activate: Marks the project as active
    [void] Activate() {
        $this.IsActive = $true
        $this.UpdatedAt = [DateTime]::Now
    }

    # AddTag: Adds a tag to the project if not already present
    [void] AddTag([string]$tag) {
        [ValidationBase]::ValidateNotEmpty($tag, "Tag")
        if ($this.Tags -notcontains $tag) {
            $this.Tags += $tag
            $this.UpdatedAt = [DateTime]::Now
        }
    }

    # RemoveTag: Removes a tag from the project
    [void] RemoveTag([string]$tag) {
        $this.Tags = $this.Tags | Where-Object { $_ -ne $tag }
        $this.UpdatedAt = [DateTime]::Now
    }

    # SetMetadata: Sets a metadata key-value pair
    [void] SetMetadata([string]$key, $value) {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        $this.Metadata[$key] = $value
        $this.UpdatedAt = [DateTime]::Now
    }

    # GetMetadata: Gets a metadata value by key
    [object] GetMetadata([string]$key) {
        return $this.Metadata[$key]
    }
    
    # ToLegacyFormat: Converts project to hashtable for JSON serialization
    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key
            Name = $this.Name
            Description = $this.Description
            CreatedAt = $this.CreatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
            UpdatedAt = $this.UpdatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
            Owner = $this.Owner
            Tags = $this.Tags
            Metadata = $this.Metadata.Clone()
            IsActive = $this.IsActive
        }
    }
    
    # FromLegacyFormat: Creates project from hashtable (JSON deserialization)
    static [PmcProject] FromLegacyFormat([hashtable]$data) {
        $project = [PmcProject]::new()
        
        if ($data.ContainsKey('Key')) { $project.Key = $data.Key }
        if ($data.ContainsKey('Name')) { $project.Name = $data.Name }
        if ($data.ContainsKey('Description')) { $project.Description = $data.Description }
        if ($data.ContainsKey('CreatedAt')) { 
            $project.CreatedAt = [DateTime]::Parse($data.CreatedAt)
        }
        if ($data.ContainsKey('UpdatedAt')) { 
            $project.UpdatedAt = [DateTime]::Parse($data.UpdatedAt)
        }
        if ($data.ContainsKey('Owner')) { $project.Owner = $data.Owner }
        if ($data.ContainsKey('Tags')) { $project.Tags = @($data.Tags) }
        if ($data.ContainsKey('Metadata')) { $project.Metadata = $data.Metadata.Clone() }
        if ($data.ContainsKey('IsActive')) { $project.IsActive = [bool]$data.IsActive }
        
        return $project
    }

    # ToString: Returns a string representation of the project
    [string] ToString() {
        $status = if ($this.IsActive) { "Active" } else { "Archived" }
        return "[$($this.Key)] $($this.Name) - $status"
    }
}

# ===== CLASS: TimeEntry =====
# Module: models (from axiom)
# Dependencies: ValidationBase, BillingType enum
# Purpose: Represents a time entry for a task
class TimeEntry : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()  # Unique identifier
    [string]$TaskId                              # Associated task ID
    [string]$ProjectKey                          # Associated project key
    [DateTime]$StartTime                         # When work started
    [Nullable[DateTime]]$EndTime                 # When work ended (null if ongoing)
    [string]$Description                         # What was done
    [BillingType]$BillingType = [BillingType]::Billable # Billing classification
    [string]$UserId                              # Who logged the time
    [decimal]$HourlyRate = 0                    # Rate per hour (if applicable)
    [hashtable]$Metadata = @{}                   # Additional metadata

    # Default constructor
    TimeEntry() {}

    # Constructor with basic details
    TimeEntry([string]$taskId, [string]$projectKey, [DateTime]$startTime) {
        [ValidationBase]::ValidateNotEmpty($taskId, "TaskId")
        [ValidationBase]::ValidateNotEmpty($projectKey, "ProjectKey")
        
        $this.TaskId = $taskId
        $this.ProjectKey = $projectKey
        $this.StartTime = $startTime
    }

    # GetDuration: Returns the duration of the time entry
    [TimeSpan] GetDuration() {
        if ($null -eq $this.EndTime) {
            return [DateTime]::Now - $this.StartTime
        }
        return $this.EndTime - $this.StartTime
    }

    # GetHours: Returns the duration in decimal hours
    [decimal] GetHours() {
        return [decimal]($this.GetDuration().TotalHours)
    }

    # GetTotalValue: Returns the monetary value of the time entry
    [decimal] GetTotalValue() {
        if ($this.BillingType -eq [BillingType]::NonBillable) {
            return 0
        }
        return $this.GetHours() * $this.HourlyRate
    }

    # Stop: Stops the timer on this entry
    [void] Stop() {
        if ($null -eq $this.EndTime) {
            $this.EndTime = [DateTime]::Now
        }
    }

    # IsRunning: Checks if the time entry is still running
    [bool] IsRunning() {
        return $null -eq $this.EndTime
    }

    # ToString: Returns a string representation of the time entry
    [string] ToString() {
        $duration = $this.GetDuration()
        $status = if ($this.IsRunning()) { "Running" } else { "Completed" }
        return "$($this.ProjectKey) - $($duration.ToString('hh\:mm\:ss')) [$status]"
    }
}

#endregion
#<!-- END_PAGE: AMO.003 -->



####\Models\AMO.004_ExceptionClasses.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Models (No UI Dependencies) - UPDATED
# Data models, enums, and validation classes
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AMO.###" to find specific sections.
# Each section ends with "END_PAGE: AMO.###"
# ==============================================================================

#region Exception Classes

# ===== CLASS: HeliosException =====
# Module: exceptions (from axiom)
# Dependencies: None (inherits from System.Exception)
# Purpose: Base exception for all framework exceptions
class HeliosException : System.Exception {
    [string]$ErrorCode
    [hashtable]$Context = @{}
    [string]$Component
    [DateTime]$Timestamp
    
    HeliosException([string]$message) : base($message) {
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component) : base($message) {
        $this.Component = $component
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component, [hashtable]$context) : base($message) {
        $this.Component = $component
        $this.Context = $context
        $this.Timestamp = [DateTime]::Now
    }
    
    HeliosException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $innerException) {
        $this.Component = $component
        $this.Context = $context
        $this.Timestamp = [DateTime]::Now
    }
}

# ===== CLASS: NavigationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for navigation-related errors
class NavigationException : HeliosException {
    NavigationException([string]$message) : base($message) {}
    NavigationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: ServiceInitializationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for service initialization failures
class ServiceInitializationException : HeliosException {
    ServiceInitializationException([string]$message) : base($message) {}
    ServiceInitializationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: ComponentRenderException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for component rendering failures
class ComponentRenderException : HeliosException {
    ComponentRenderException([string]$message) : base($message) {}
    ComponentRenderException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: StateMutationException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for state mutation errors
class StateMutationException : HeliosException {
    StateMutationException([string]$message) : base($message) {}
    StateMutationException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: InputHandlingException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for input handling errors
class InputHandlingException : HeliosException {
    InputHandlingException([string]$message) : base($message) {}
    InputHandlingException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

# ===== CLASS: DataLoadException =====
# Module: exceptions (from axiom)
# Dependencies: HeliosException
# Purpose: Exception for data loading errors
class DataLoadException : HeliosException {
    DataLoadException([string]$message) : base($message) {}
    DataLoadException([string]$message, [string]$component, [hashtable]$context, [Exception]$innerException) : base($message, $component, $context, $innerException) {}
}

#endregion
#<!-- END_PAGE: AMO.004 -->



####\Models\AMO.005_NavigationClasses.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Models (No UI Dependencies) - UPDATED
# Data models, enums, and validation classes
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: AMO.###" to find specific sections.
# Each section ends with "END_PAGE: AMO.###"
# ==============================================================================

#region Navigation Classes

# ===== CLASS: NavigationItem =====
# Module: navigation-class (from axiom)
# Dependencies: None
# Purpose: Represents a menu item for local/contextual navigation
class NavigationItem {
    [string]$Key
    [string]$Label
    [scriptblock]$Action
    [bool]$Enabled = $true
    [bool]$Visible = $true
    [string]$Description = ""

    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key)) {
            throw [System.ArgumentException]::new("Navigation key cannot be null or empty")
        }
        if ([string]::IsNullOrWhiteSpace($label)) {
            throw [System.ArgumentException]::new("Navigation label cannot be null or empty")
        }
        if (-not $action) {
            throw [System.ArgumentNullException]::new("action", "Navigation action cannot be null")
        }

        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }

    [void] Execute() {
        try {
            if (-not $this.Enabled) {
                return
            }
            
            & $this.Action
        }
        catch {
            throw
        }
    }

    [string] ToString() {
        return "NavigationItem(Key='$($this.Key)', Label='$($this.Label)', Enabled=$($this.Enabled))"
    }
}

#endregion
#<!-- END_PAGE: AMO.005 -->



####\Runtime\ART.001_GlobalState.ps1
####\AllRuntime.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Runtime (Load Last)
# TUI engine, screen management, and main application loop
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ART.###" to find specific sections.
# Each section ends with "END_PAGE: ART.###"
# ==============================================================================

#region Global State

# Initialize global TUI state
$global:TuiState = @{
    Running = $false
    BufferWidth = 80
    BufferHeight = 24
    CompositorBuffer = $null
    PreviousCompositorBuffer = $null
    # REMOVED: ScreenStack - NavigationService handles this
    CurrentScreen = $null  # The active window (Screen or Dialog)
    IsDirty = $true
    FocusedComponent = $null
    # REMOVED: OverlayStack - using window-based model
    Services = @{}
    LastRenderTime = [datetime]::Now
    FrameCount = 0
    InputQueue = New-Object 'System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]'
    # Added for input thread management
    CancellationTokenSource = $null
    InputRunspace = $null
    InputPowerShell = $null
    InputAsyncResult = $null
}

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Component,
        
        [Parameter(Mandatory)]
        [string]$Context,
        
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock,
        
        [hashtable]$AdditionalData = @{}
    )
    
    try {
        & $ScriptBlock
    }
    catch {
        $errorDetails = @{
            Component = $Component
            Context = $Context
            ErrorMessage = $_.Exception.Message
            ErrorType = $_.Exception.GetType().FullName
            StackTrace = $_.ScriptStackTrace
            Timestamp = [datetime]::Now
        }
        
        foreach ($key in $AdditionalData.Keys) {
            $errorDetails[$key] = $AdditionalData[$key]
        }
        
        $logger = $global:TuiState.Services.Logger
        if ($logger) {
            $logger.Log("Error", "Error in $Component during $Context : $($_.Exception.Message)")
            # Simple error logging without JSON serialization
            $logger.Log("Debug", "Error type: $($_.Exception.GetType().FullName)")
        }
        
        # Re-throw for caller to handle if needed
        throw
    }
}
#endregion
#<!-- END_PAGE: ART.001 -->



####\Runtime\ART.002_EngineManagement.ps1
####\AllRuntime.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Runtime (Load Last)
# TUI engine, screen management, and main application loop
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ART.###" to find specific sections.
# Each section ends with "END_PAGE: ART.###"
# ==============================================================================

#region Engine Management

function Initialize-TuiEngine {
    [CmdletBinding()]
    param()
    
    try {
        Write-Log -Level Info -Message "Initializing TUI engine..."
        
        # Store original console state
        $global:TuiState.OriginalWindowTitle = $Host.UI.RawUI.WindowTitle
        $global:TuiState.OriginalCursorVisible = [Console]::CursorVisible
        
        # Configure console
        [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        [Console]::InputEncoding = [System.Text.Encoding]::UTF8  # ADDED: Set input encoding
        $env:PYTHONIOENCODING = "utf-8"
        [Console]::CursorVisible = $false
        $Host.UI.RawUI.WindowTitle = "Axiom-Phoenix v4.0 TUI Framework"
        
        # Clear screen and hide cursor
        Clear-Host
        [Console]::SetCursorPosition(0, 0)
        
        # Get initial size
        Update-TuiEngineSize
        
        # Create compositor buffers
        $width = $global:TuiState.BufferWidth
        $height = $global:TuiState.BufferHeight
        $global:TuiState.CompositorBuffer = [TuiBuffer]::new($width, $height, "Compositor")
        $global:TuiState.PreviousCompositorBuffer = [TuiBuffer]::new($width, $height, "PreviousCompositor")
        
        # Clear with theme background
        $bgColor = Get-ThemeColor -ColorName "Background" -DefaultColor "#000000"
        $global:TuiState.CompositorBuffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        $global:TuiState.PreviousCompositorBuffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        Write-Log -Level Info -Message "TUI engine initialized. Buffer size: ${width}x${height}"
    }
    catch {
        Invoke-WithErrorHandling -Component "TuiEngine" -Context "Initialization" -ScriptBlock { throw } `
            -AdditionalData @{ Phase = "EngineInit" }
    }
}

function Start-TuiEngine {
    [CmdletBinding()]
    param(
        [int]$TargetFPS = 30,
        [switch]$EnablePerformanceMonitoring,
        [int]$PerformanceReportInterval = 300  # frames
    )
    
    try {
        Write-Log -Level Info -Message "Starting TUI Engine with target FPS: $TargetFPS"
        
        # Clear debug trace log at start
        $debugLog = Join-Path (Split-Path $PSScriptRoot -Parent) "debug-trace.log"
        Add-Content -Path $debugLog -Value "`n=== ENGINE START - $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff') ===" -ErrorAction SilentlyContinue
        
        # Calculate frame timing
        $targetFrameTime = [timespan]::FromSeconds(1.0 / $TargetFPS)
        $frameStopwatch = [System.Diagnostics.Stopwatch]::new()
        $performanceStopwatch = [System.Diagnostics.Stopwatch]::new()
        
        # Performance monitoring variables
        $frameTimeHistory = [System.Collections.Generic.Queue[double]]::new()
        $maxHistorySize = 60  # Keep last 60 frame times
        $slowFrameCount = 0
        $skippedFrameCount = 0
        
        $global:TuiState.Running = $true
        $global:TuiState.FrameCount = 0
        
        # Setup deferred action handler for window-based navigation
        Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] Setting up DeferredActions queue..."
        $global:TuiState.DeferredActions = New-Object 'System.Collections.Concurrent.ConcurrentQueue[hashtable]'
        Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] DeferredActions queue created: $($null -ne $global:TuiState.DeferredActions)"
        
        $eventManager = $global:TuiState.Services.EventManager
        if ($eventManager) {
            Write-Log -Level Debug -Message "Engine: Setting up DeferredAction handler"
            Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] EventManager found, registering DeferredAction handler..."
            $deferredHandler = $eventManager.Subscribe("DeferredAction", {
                param($sender, $data)
                Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] DeferredAction handler called with sender: $($sender.GetType().Name), data: $($data | ConvertTo-Json -Compress)"
                if ($data -and $data.ActionName) {
                    Write-Log -Level Debug -Message "Engine: DeferredAction event received - ActionName: $($data.ActionName)"
                    Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] DeferredAction received: $($data.ActionName)"
                    $global:TuiState.DeferredActions.Enqueue($data)
                    Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] DeferredAction enqueued successfully"
                }
            })
            Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] DeferredAction handler registered!"
        } else {
            Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] WARNING: EventManager not found!"
        }
        
        if ($EnablePerformanceMonitoring) {
            $performanceStopwatch.Start()
        }
        
        while ($global:TuiState.Running) {
            $frameStopwatch.Restart()
            
            try {
                # Phase 1: Handle console resize
                if ([Console]::WindowWidth -ne $global:TuiState.BufferWidth -or 
                    [Console]::WindowHeight -ne $global:TuiState.BufferHeight) {
                    
                    Invoke-WithErrorHandling -Component "TuiEngine" -Context "Resize" -ScriptBlock {
                        Update-TuiEngineSize
                    }
                }
                
                # Phase 2: Process input (always process input for responsiveness)
                Invoke-WithErrorHandling -Component "TuiEngine" -Context "Input" -ScriptBlock {
                    Process-TuiInput
                }
                
                # Phase 3: Process deferred actions (execute AFTER navigation completes)
                if ($global:TuiState.DeferredActions -and $global:TuiState.DeferredActions.Count -gt 0) {
                    Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] Found $($global:TuiState.DeferredActions.Count) deferred actions"
                    # Add a frame delay to ensure dialog is fully cleared from screen
                    if (-not $global:TuiState.DeferredActionDelay) {
                        $global:TuiState.DeferredActionDelay = 2  # Wait 2 frames
                    }
                    
                    $global:TuiState.DeferredActionDelay--
                    
                    if ($global:TuiState.DeferredActionDelay -le 0) {
                        $deferredAction = $null
                        if ($global:TuiState.DeferredActions.TryDequeue([ref]$deferredAction)) {
                            if ($deferredAction -and $deferredAction.ActionName) {
                                Write-Log -Level Debug -Message "Engine: Processing deferred action: $($deferredAction.ActionName)"
                                Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] Processing deferred action: $($deferredAction.ActionName)"
                                Invoke-WithErrorHandling -Component "TuiEngine" -Context "DeferredAction" -ScriptBlock {
                                    $actionService = $global:TuiState.Services.ActionService
                                    if ($actionService) {
                                        Write-Log -Level Debug -Message "Engine: Executing deferred action: $($deferredAction.ActionName)"
                                        Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] Executing action: $($deferredAction.ActionName)"
                                        $actionService.ExecuteAction($deferredAction.ActionName, @{})
                                    }
                                }
                            }
                        }
                        $global:TuiState.DeferredActionDelay = $null
                    }
                }
                
                # Phase 4: Render frame
                # Always render to maintain consistent frame rate and handle animations
                Invoke-WithErrorHandling -Component "TuiEngine" -Context "Render" -ScriptBlock {
                    Invoke-TuiRender
                }
                
                $global:TuiState.FrameCount++
                
                # Phase 5: Performance monitoring
                if ($EnablePerformanceMonitoring) {
                    $frameTime = $frameStopwatch.ElapsedMilliseconds
                    
                    # Track frame times
                    $frameTimeHistory.Enqueue($frameTime)
                    if ($frameTimeHistory.Count -gt $maxHistorySize) {
                        $frameTimeHistory.Dequeue()
                    }
                    
                    # Count slow frames
                    if ($frameTime -gt $targetFrameTime.TotalMilliseconds) {
                        $slowFrameCount++
                    }
                    
                    # Report performance every N frames
                    if ($global:TuiState.FrameCount % $PerformanceReportInterval -eq 0) {
                        $avgFrameTime = ($frameTimeHistory | Measure-Object -Average).Average
                        $maxFrameTime = ($frameTimeHistory | Measure-Object -Maximum).Maximum
                        $currentFPS = if ($avgFrameTime -gt 0) { 1000.0 / $avgFrameTime } else { 0 }
                        
                        Write-Log -Level Info -Message "TUI Performance Report - Frame: $($global:TuiState.FrameCount), Avg FPS: $([Math]::Round($currentFPS, 1)), Avg Frame Time: $([Math]::Round($avgFrameTime, 1))ms, Max Frame Time: $([Math]::Round($maxFrameTime, 1))ms, Slow Frames: $slowFrameCount, Skipped: $skippedFrameCount"
                        
                        # Reset counters
                        $slowFrameCount = 0
                        $skippedFrameCount = 0
                    }
                }
                
                # Phase 6: Frame rate throttling
                $frameStopwatch.Stop()
                $elapsedTime = $frameStopwatch.Elapsed
                
                if ($elapsedTime -lt $targetFrameTime) {
                    # We have time to spare - sleep for the remainder
                    $sleepTime = $targetFrameTime - $elapsedTime
                    if ($sleepTime.TotalMilliseconds -gt 0) {
                        Start-Sleep -Milliseconds $sleepTime.TotalMilliseconds
                    }
                }
                else {
                    # Frame took longer than target - log but continue
                    # Never skip input processing or rendering
                    $slowFrameCount++
                    
                    if ($EnablePerformanceMonitoring -and $elapsedTime.TotalMilliseconds -gt ($targetFrameTime.TotalMilliseconds * 2)) {
                        if (Get-Command 'Write-Log' -ErrorAction SilentlyContinue) {
                            $targetMs = [Math]::Round($targetFrameTime.TotalMilliseconds, 1)
                            $actualMs = [Math]::Round($elapsedTime.TotalMilliseconds, 1)
                            Write-Log -Level Warning -Message "TUI Engine: Frame $($global:TuiState.FrameCount) took ${actualMs}ms (target: ${targetMs}ms)"
                        }
                    }
                }
            }
            catch {
                Write-Log -Level Error -Message "TUI Engine: Frame $($global:TuiState.FrameCount) error: $($_.Exception.Message)"
                
                # Don't exit on frame errors - try to continue
                Start-Sleep -Milliseconds 50  # Brief pause to prevent tight error loop
            }
        }
        
        # Final performance report
        if ($EnablePerformanceMonitoring -and $performanceStopwatch.IsRunning) {
            $performanceStopwatch.Stop()
            $totalSeconds = $performanceStopwatch.Elapsed.TotalSeconds
            $avgFPS = if ($totalSeconds -gt 0) { $global:TuiState.FrameCount / $totalSeconds } else { 0 }
            
            Write-Log -Level Info -Message "TUI Engine stopped after $($global:TuiState.FrameCount) frames in $([Math]::Round($totalSeconds, 1))s. Average FPS: $([Math]::Round($avgFPS, 1))"
        }
        else {
            Write-Log -Level Info -Message "TUI Engine stopped after $($global:TuiState.FrameCount) frames"
        }
    }
    catch {
        Write-Log -Level Error -Message "TUI Engine critical error: $($_.Exception.Message)"
        Invoke-PanicHandler $_
    }
    finally {
        Stop-TuiEngine
    }
}

function Stop-TuiEngine {
    [CmdletBinding()]
    param(
        [switch]$Force
    )
    
    try {
        # Write-Verbose "Stopping TUI Engine..."
        
        $global:TuiState.Running = $false
        
        # Cleanup current screen via NavigationService
        $navService = $global:TuiState.Services.NavigationService
        if ($navService -and $navService.CurrentScreen) {
            try {
                $navService.CurrentScreen.OnExit()
                $navService.CurrentScreen.Cleanup()
            }
            catch {
                # Write-Verbose "Error cleaning up current screen: $_"
            }
        }
        
        # Cleanup services
        foreach ($service in $global:TuiState.Services.Values) {
            if ($service -and $service.PSObject -and $service.PSObject.Methods -and 
                $service.PSObject.Methods.Name -contains 'Cleanup') {
                try {
                    $service.Cleanup()
                }
                catch {
                    # Write-Verbose "Error cleaning up service: $_"
                }
            }
        }
        
        # Restore console
        [Console]::CursorVisible = $true
        [Console]::Clear()
        [Console]::SetCursorPosition(0, 0)
        
        # Write-Verbose "TUI Engine stopped and cleaned up"
    }
    catch {
        Write-Error "Error stopping TUI engine: $_"
    }
}

function Update-TuiEngineSize {
    [CmdletBinding()]
    param()
    
    try {
        # Try multiple methods to get console size
        $newWidth = $null
        $newHeight = $null
        
        # Method 1: Host.UI.RawUI
        try {
            $newWidth = $Host.UI.RawUI.WindowSize.Width
            $newHeight = $Host.UI.RawUI.WindowSize.Height
        } catch {}
        
        # Method 2: Console class
        if ($null -eq $newWidth -or $newWidth -le 0) {
            try {
                $newWidth = [Console]::WindowWidth
                $newHeight = [Console]::WindowHeight
            } catch {}
        }
        
        # FIXED: Correct stderr redirection syntax
        # Method 3: Mode command (Windows)
        if ($null -eq $newWidth -or $newWidth -le 0) {
            try {
                $modeOutput = cmd /c mode con 2>&1 | Where-Object { $_ -match "Columns:" }
                if ($modeOutput) {
                    $newWidth = [int]($modeOutput -replace '.*Columns:\s*', '')
                }
                $modeOutput = cmd /c mode con 2>&1 | Where-Object { $_ -match "Lines:" }
                if ($modeOutput) {
                    $newHeight = [int]($modeOutput -replace '.*Lines:\s*', '')
                }
            } catch {}
        }
        
        # Fallback
        if ($null -eq $newWidth -or $newWidth -le 0 -or $null -eq $newHeight -or $newHeight -le 0) {
            $newWidth = 120
            $newHeight = 30
            Write-Log -Level Warning -Message "Invalid console size detected. Using fallback: ${newWidth}x${newHeight}"
        }
        
        # Write-Verbose "Console resized from $($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight) to ${newWidth}x${newHeight}"
        
        # Update state
        $global:TuiState.BufferWidth = $newWidth
        $global:TuiState.BufferHeight = $newHeight
        
        # Resize compositor buffers only if they exist
        if ($null -ne $global:TuiState.CompositorBuffer) {
            $global:TuiState.CompositorBuffer.Resize($newWidth, $newHeight)
        }
        if ($null -ne $global:TuiState.PreviousCompositorBuffer) {
            $global:TuiState.PreviousCompositorBuffer.Resize($newWidth, $newHeight)
        }
        
        # Resize current screen
        $navService = $global:TuiState.Services.NavigationService
        if ($navService -and $navService.CurrentScreen) {
            $navService.CurrentScreen.Resize($newWidth, $newHeight)
        }
        
        # Force full redraw
        $global:TuiState.IsDirty = $true
        if ($null -ne $global:TuiState.CompositorBuffer) {
            [Console]::Clear()
        }
    }
    catch {
        Write-Error "Failed to update engine size: $_"
    }
}

#endregion
#<!-- END_PAGE: ART.002 -->



####\Runtime\ART.003_RenderingSystem.ps1
####\AllRuntime.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Runtime (Load Last)
# TUI engine, screen management, and main application loop
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ART.###" to find specific sections.
# Each section ends with "END_PAGE: ART.###"
# ==============================================================================

#region Rendering System

function Invoke-TuiRender {
    [CmdletBinding()]
    param()
    
    try {
        $renderTimer = [System.Diagnostics.Stopwatch]::StartNew()
        
        # Ensure compositor buffer exists
        if ($null -eq $global:TuiState.CompositorBuffer) {
            # Write-Verbose "Compositor buffer is null, skipping render"
            return
        }
        
        # Clear compositor buffer
        $global:TuiState.CompositorBuffer.Clear()
        
        # Write-Verbose "Starting render frame $($global:TuiState.FrameCount)"
        
        # WINDOW-BASED MODEL: Render all windows in the stack
        $navService = $global:TuiState.Services.NavigationService
        if ($navService) {
            $windows = $navService.GetWindows()
            
            # Render each window from bottom to top
            foreach ($window in $windows) {
                if ($null -eq $window) { continue }
                
                try {
                    # Render the window which will update its internal buffer
                    $window.Render()
                    
                    # Get the window's buffer
                    $windowBuffer = $window.GetBuffer()
                    
                    if ($windowBuffer) {
                        # For overlays, render with transparency effect
                        if ($window.IsOverlay -and $window -ne $windows[0]) {
                            # Dim the background for overlay effect
                            # This is a simple approach - could be enhanced with alpha blending
                            $global:TuiState.CompositorBuffer.BlendBuffer($windowBuffer, 0, 0)
                        }
                        else {
                            # Normal window - full opaque blend
                            $global:TuiState.CompositorBuffer.BlendBuffer($windowBuffer, 0, 0)
                        }
                    }
                    else {
                        Write-Log -Level Debug -Message "Window buffer is null for $($window.Name)"
                    }
                }
                catch {
                    Write-Error "Error rendering window '$($window.Name)': $_"
                    throw
                }
            }
        }
        
        # Force full redraw on first frame by making previous buffer different
        if ($global:TuiState.FrameCount -eq 0) {
            # Write-Verbose "First frame - initializing previous buffer for differential rendering"
            # Fill previous buffer with different content to force full redraw
            for ($y = 0; $y -lt $global:TuiState.PreviousCompositorBuffer.Height; $y++) {
                for ($x = 0; $x -lt $global:TuiState.PreviousCompositorBuffer.Width; $x++) {
                    $global:TuiState.PreviousCompositorBuffer.SetCell($x, $y, 
                        [TuiCell]::new('?', "#404040", "#404040"))
                }
            }
        }
        
        # Differential rendering - compare current compositor to previous
        Render-DifferentialBuffer
        
        # Swap buffers for next frame - MUST happen AFTER rendering
        # Use the efficient Clone() method instead of manual copying
        $global:TuiState.PreviousCompositorBuffer = $global:TuiState.CompositorBuffer.Clone()
        
        # Clear compositor for next frame
        $bgColor = Get-ThemeColor -ColorName "Background" -DefaultColor "#000000"
        $global:TuiState.CompositorBuffer.Clear([TuiCell]::new(' ', $bgColor, $bgColor))
        
        $renderTimer.Stop()
        
        if ($renderTimer.ElapsedMilliseconds -gt 16) {
            # Write-Verbose "Slow frame: $($renderTimer.ElapsedMilliseconds)ms"
        }
    }
    catch {
        Write-Error "Render error: $_"
        throw
    }
}

function Render-DifferentialBuffer {
    [CmdletBinding()]
    param()
    
    try {
        $current = $global:TuiState.CompositorBuffer
        $previous = $global:TuiState.PreviousCompositorBuffer
        
        # Ensure both buffers exist
        if ($null -eq $current -or $null -eq $previous) {
            # Write-Verbose "Compositor buffers not initialized, skipping differential render"
            return
        }
        
        $ansiBuilder = [System.Text.StringBuilder]::new()
        $currentX = -1
        $currentY = -1
        $changeCount = 0
        
        for ($y = 0; $y -lt $current.Height; $y++) {
            for ($x = 0; $x -lt $current.Width; $x++) {
                $currentCell = $current.GetCell($x, $y)
                $previousCell = $previous.GetCell($x, $y)
                
                if ($currentCell.DiffersFrom($previousCell)) {
                    $changeCount++
                    
                    # Move cursor if needed
                    if ($currentX -ne $x -or $currentY -ne $y) {
                        [void]$ansiBuilder.Append("`e[$($y + 1);$($x + 1)H")
                        $currentX = $x
                        $currentY = $y
                    }
                    
                    # Use cell's ToAnsiString method which handles all styling
                    [void]$ansiBuilder.Append($currentCell.ToAnsiString())
                    $currentX++
                }
            }
        }
        
        # Log changes on first few frames
        if ($global:TuiState.FrameCount -lt 5) {
            # Write-Verbose "Frame $($global:TuiState.FrameCount): $changeCount cells changed"
        }
        
        # Reset styling at end
        if ($ansiBuilder.Length -gt 0) {
            [void]$ansiBuilder.Append("`e[0m")
            [Console]::Write($ansiBuilder.ToString())
        }
    }
    catch {
        Write-Error "Differential rendering error: $_"
        throw
    }
}

#endregion
#<!-- END_PAGE: ART.003 -->



####\Runtime\ART.004_InputProcessing.ps1
####\AllRuntime.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Runtime (Load Last)
# TUI engine, screen management, and main application loop
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ART.###" to find specific sections.
# Each section ends with "END_PAGE: ART.###"
# ==============================================================================

#region Input Processing

# PURPOSE:
#   SIMPLIFIED WINDOW-BASED INPUT MODEL
#   Only the active window (screen) gets input. Period.
#   No complex routing, no overlays, no confusion.
#
function Process-TuiInput {
    [CmdletBinding()]
    param()
    
    try {
        while ([Console]::KeyAvailable) {
            $keyInfo = [Console]::ReadKey($true)
            
            # Emergency exit - Ctrl+C always works
            if ($keyInfo.Key -eq [ConsoleKey]::C -and ($keyInfo.Modifiers -band [ConsoleModifiers]::Control)) {
                $global:TuiState.Running = $false
                return
            }
            
            # Log the key for debugging
            if ($keyInfo.Key -or $keyInfo.KeyChar) {
                Write-Log -Level Debug -Message "Process-TuiInput: Key pressed - Key: $($keyInfo.Key), KeyChar: '$($keyInfo.KeyChar)', Modifiers: $($keyInfo.Modifiers)"
            }
            
            # Get the active window from NavigationService
            $navService = $global:TuiState.Services.NavigationService
            $activeWindow = if ($navService) { $navService.CurrentScreen } else { $null }
            
            if (-not $activeWindow) {
                Write-Log -Level Warning -Message "Process-TuiInput: No active window"
                continue
            }
            
            Write-Log -Level Debug -Message "Process-TuiInput: Routing to active window: $($activeWindow.Name)"
            
            # WINDOW-BASED MODEL: Active window handles ALL input
            # Step 1: Let focused component within the window handle it first
            $focusManager = $global:TuiState.Services.FocusManager
            $focusedComponent = if ($focusManager) { $focusManager.FocusedComponent } else { $null }
            
            $handled = $false
            
            # If there's a focused component IN THIS WINDOW, let it try first
            if ($focusedComponent -and $focusedComponent.IsFocused -and $focusedComponent.Enabled) {
                # Verify the focused component belongs to the active window
                $parent = $focusedComponent.Parent
                while ($parent -and $parent -ne $activeWindow) {
                    $parent = $parent.Parent
                }
                
                if ($parent -eq $activeWindow) {
                    Write-Log -Level Debug -Message "  - Trying focused component: $($focusedComponent.Name)"
                    $handled = $focusedComponent.HandleInput($keyInfo)
                    if ($handled) {
                        Write-Log -Level Debug -Message "  - Handled by focused component"
                        $global:TuiState.IsDirty = $true
                        continue
                    }
                }
            }
            
            # Step 2: Let the window handle it (includes global keybindings, window-level actions)
            if (-not $handled) {
                Write-Log -Level Debug -Message "  - Trying window: $($activeWindow.Name)"
                $handled = $activeWindow.HandleInput($keyInfo)
                if ($handled) {
                    Write-Log -Level Debug -Message "  - Handled by window"
                    $global:TuiState.IsDirty = $true
                    continue
                }
            }
            
            # Step 3: Check global keybindings as fallback
            if (-not $handled) {
                $keybindingService = $global:TuiState.Services.KeybindingService
                if ($keybindingService) {
                    $action = $keybindingService.GetAction($keyInfo)
                    if ($action) {
                        Write-Log -Level Debug -Message "  - Executing global action: $action"
                        $actionService = $global:TuiState.Services.ActionService
                        if ($actionService) {
                            try {
                                $actionService.ExecuteAction($action, @{})
                                $global:TuiState.IsDirty = $true
                                $handled = $true
                            }
                            catch {
                                Write-Log -Level Error -Message "  - Failed to execute action '$action': $($_.Exception.Message)"
                            }
                        }
                    }
                }
            }
            
            if (-not $handled) {
                Write-Log -Level Debug -Message "  - Key not handled by any component"
            }
        }
    }
    catch {
        Write-Log -Level Error -Message "Input processing error: $($_.Exception.Message)"
    }
}

#endregion
#<!-- END_PAGE: ART.004 -->



####\Runtime\ART.005_ScreenManagement.ps1
####\AllRuntime.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Runtime (Load Last)
# TUI engine, screen management, and main application loop
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ART.###" to find specific sections.
# Each section ends with "END_PAGE: ART.###"
# ==============================================================================

#region Overlay Management

function Show-TuiOverlay {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [UIElement]$Overlay
    )
    
    Write-Warning "Show-TuiOverlay is deprecated. Use DialogManager.ShowDialog() for dialogs or manage overlays directly."
    
    # Use DialogManager if the overlay is a Dialog
    if ($Overlay.GetType().Name -match "Dialog") {
        $dialogManager = $global:TuiState.Services.DialogManager
        if ($dialogManager) {
            $dialogManager.ShowDialog($Overlay)
            return
        }
    }
    
    # For non-dialog overlays, handle manually (deprecated path)
    if (-not $global:TuiState.OverlayStack) {
        $global:TuiState.OverlayStack = [System.Collections.Generic.List[UIElement]]::new()
    }
    
    # Position overlay at center
    $consoleWidth = $global:TuiState.BufferWidth
    $consoleHeight = $global:TuiState.BufferHeight
    $Overlay.X = [Math]::Max(0, [Math]::Floor(($consoleWidth - $Overlay.Width) / 2))
    $Overlay.Y = [Math]::Max(0, [Math]::Floor(($consoleHeight - $Overlay.Height) / 2))
    
    $Overlay.Visible = $true
    $Overlay.IsOverlay = $true
    $global:TuiState.OverlayStack.Add($Overlay)
    $global:TuiState.IsDirty = $true
    
    # Write-Log -Level Debug -Message "Show-TuiOverlay: Displayed overlay '$($Overlay.Name)' at X=$($Overlay.X), Y=$($Overlay.Y)"
}

function Close-TopTuiOverlay {
    [CmdletBinding()]
    param()
    
    Write-Warning "Close-TopTuiOverlay is deprecated. Use DialogManager.HideDialog() for dialogs or manage overlays directly."
    
    if ($global:TuiState.OverlayStack.Count -eq 0) {
        # Write-Log -Level Warning -Message "Close-TopTuiOverlay: No overlays to close"
        return
    }
    
    $topOverlay = $global:TuiState.OverlayStack[-1]
    
    # Use DialogManager if it's a Dialog
    if ($topOverlay.GetType().Name -match "Dialog") {
        $dialogManager = $global:TuiState.Services.DialogManager
        if ($dialogManager) {
            $dialogManager.HideDialog($topOverlay)
            return
        }
    }
    
    # Manual removal for non-dialog overlays (deprecated path)
    $global:TuiState.OverlayStack.RemoveAt($global:TuiState.OverlayStack.Count - 1)
    $topOverlay.Visible = $false
    $topOverlay.IsOverlay = $false
    $topOverlay.Cleanup()
    $global:TuiState.IsDirty = $true
    
    # Write-Log -Level Debug -Message "Close-TopTuiOverlay: Closed overlay '$($topOverlay.Name)'"
}

#endregion
#<!-- END_PAGE: ART.005 -->



####\Runtime\ART.006_ErrorHandling.ps1
####\AllRuntime.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Runtime (Load Last)
# TUI engine, screen management, and main application loop
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ART.###" to find specific sections.
# Each section ends with "END_PAGE: ART.###"
# ==============================================================================

#region Panic Handler

function Invoke-PanicHandler {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [object]$ErrorRecord
    )
    
    # Ensure we're in a safe state to write to console
    try {
        [Console]::ResetColor()
        [Console]::CursorVisible = $true
        Clear-Host
    } catch { }
    
    Write-Host "`n`n" -NoNewline
    Write-Host "================================ PANIC HANDLER ================================" -ForegroundColor Red
    Write-Host ""
    Write-Host "An unrecoverable error has occurred:" -ForegroundColor Yellow
    Write-Host ""
    
    # Error details
    Write-Host "ERROR: " -ForegroundColor Red -NoNewline
    Write-Host $ErrorRecord.Exception.Message
    Write-Host ""
    Write-Host "TYPE: " -ForegroundColor Yellow -NoNewline
    Write-Host $ErrorRecord.Exception.GetType().FullName
    Write-Host ""
    
    # Stack trace
    Write-Host "STACK TRACE:" -ForegroundColor Yellow
    $stackLines = $ErrorRecord.ScriptStackTrace -split "`n"
    foreach ($line in $stackLines) {
        Write-Host "  $line" -ForegroundColor DarkGray
    }
    Write-Host ""
    
    # System info
    Write-Host "SYSTEM INFO:" -ForegroundColor Yellow
    Write-Host "  PowerShell: $($PSVersionTable.PSVersion)" -ForegroundColor DarkGray
    Write-Host "  Platform: $($PSVersionTable.Platform)" -ForegroundColor DarkGray
    Write-Host "  OS: $($PSVersionTable.OS)" -ForegroundColor DarkGray
    Write-Host "  Host: $($Host.Name) v$($Host.Version)" -ForegroundColor DarkGray
    Write-Host ""
    
    # Save crash report
    $crashDir = Join-Path $env:TEMP "AxiomPhoenix\Crashes"
    if (-not (Test-Path $crashDir)) {
        New-Item -ItemType Directory -Path $crashDir -Force | Out-Null
    }
    
    $crashFile = Join-Path $crashDir "crash_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
    $crashReport = @{
        Timestamp = [datetime]::Now
        Error = @{
            Message = $ErrorRecord.Exception.Message
            Type = $ErrorRecord.Exception.GetType().FullName
            StackTrace = $ErrorRecord.ScriptStackTrace
            InnerException = if ($ErrorRecord.Exception.InnerException) { $ErrorRecord.Exception.InnerException.Message } else { $null }
        }
        System = @{
            PowerShell = $PSVersionTable.PSVersion.ToString()
            Platform = $PSVersionTable.Platform
            OS = $PSVersionTable.OS
            Host = "$($Host.Name) v$($Host.Version)"
        }
        GlobalState = @{
            Running = $global:TuiState.Running
            BufferSize = "$($global:TuiState.BufferWidth)x$($global:TuiState.BufferHeight)"
            CurrentScreen = if ($global:TuiState.CurrentScreen) { $global:TuiState.CurrentScreen.Name } else { "None" }
            OverlayCount = if ($global:TuiState.OverlayStack) { $global:TuiState.OverlayStack.Count } else { 0 }
        }
    }
    
    try {
        # Sanitize crash report data to avoid circular references
        $sanitizedReport = @{
            Timestamp = $crashReport.Timestamp
            ErrorMessage = $crashReport.ErrorMessage
            ErrorType = $crashReport.ErrorType
            ScriptStackTrace = $crashReport.ScriptStackTrace
            GlobalState = @{
                Running = $crashReport.GlobalState.Running
                BufferSize = $crashReport.GlobalState.BufferSize
                CurrentScreen = $crashReport.GlobalState.CurrentScreen
                OverlayCount = $crashReport.GlobalState.OverlayCount
            }
        }
        $sanitizedReport | ConvertTo-Json -Depth 5 | Out-File -FilePath $crashFile -Encoding UTF8
        Write-Host "Crash report saved to: $crashFile" -ForegroundColor Green
    } catch {
        Write-Host "Failed to save crash report: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    Write-Host ""
    Write-Host "=============================================================================" -ForegroundColor Red
    Write-Host ""
    Write-Host "Press any key to exit..." -ForegroundColor Yellow
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    
    # Final cleanup
    try {
        Stop-TuiEngine -Force
    } catch { }
    
    exit 1
}

function Start-AxiomPhoenix {
    [CmdletBinding()]
    param(
        [object]$ServiceContainer,  # Changed from [ServiceContainer] to [object]
        [object]$InitialScreen      # Changed from [Screen] to [object]
    )
    
    try {
        # Write-Log -Level Info -Message "Starting Axiom-Phoenix application..."
        
        # Validate ServiceContainer
        if ($null -eq $ServiceContainer) {
            throw [System.ArgumentNullException]::new("ServiceContainer")
        }
        if ($ServiceContainer.GetType().Name -ne 'ServiceContainer') {
            throw [System.ArgumentException]::new("Expected ServiceContainer but got $($ServiceContainer.GetType().Name)")
        }
        
        # Validate InitialScreen if provided
        if ($null -ne $InitialScreen) {
            # Check if it's a Screen-derived type by looking for expected properties/methods
            if (-not ($InitialScreen.PSObject.Properties['ServiceContainer'] -and 
                      $InitialScreen.PSObject.Methods['Initialize'] -and
                      $InitialScreen.PSObject.Methods['OnEnter'])) {
                throw [System.ArgumentException]::new("Expected Screen-derived object but got $($InitialScreen.GetType().Name)")
            }
        }
        
        # Store services
        $global:TuiState.Services = @{
            ServiceContainer = $ServiceContainer
        }
        
        # Extract key services for quick access
        $serviceNames = @(
            'ActionService', 'KeybindingService', 'NavigationService', 
            'DataManager', 'ThemeManager', 'EventManager', 'Logger', 'FocusManager', 'DialogManager', 
            'TuiFrameworkService', 'CommandPaletteManager' # Add new services
        )
        
        foreach ($serviceName in $serviceNames) {
            try {
                $service = $ServiceContainer.GetService($serviceName)
                if ($service) {
                    $global:TuiState.Services[$serviceName] = $service
                }
            }
            catch {
                # Write-Log -Level Warning -Message "Failed to get service '$serviceName': $($_.Exception.Message)" -Data $_
            }
        }
        
        # CommandPalette is now managed by the CommandPaletteManager service
        
        # Initialize engine
        Initialize-TuiEngine
        
        # Get the NavigationService instance directly from global state
        $navService = $global:TuiState.Services.NavigationService

        # Set initial screen using NavigationService (CRUCIAL FIX)
        if ($InitialScreen) {
            Write-Log -Level Debug -Message "Start-AxiomPhoenix: Navigating to initial screen: $($InitialScreen.Name)"
            $navService.NavigateTo($InitialScreen) # Use the service directly
            Write-Log -Level Debug -Message "Start-AxiomPhoenix: Navigation complete. CurrentScreen: $($navService.CurrentScreen?.Name)"
        }
        else {
            Write-Log -Level Warning -Message "No initial screen provided. Application might not display anything."
        }
        
        # Start main loop
        Start-TuiEngine
    }
    catch {
        # Use Invoke-PanicHandler for critical startup errors
        Invoke-PanicHandler $_
    }
    finally {
        Stop-TuiEngine # Ensure cleanup even if startup fails
    }
}

#endregion
#<!-- END_PAGE: ART.006 -->



####\Screens\ASC.001_DashboardScreen.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Screens (Load After Components)
# Application screens that extend Screen base class
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASC.###" to find specific sections.
# Each section ends with "END_PAGE: ASC.###"
# ==============================================================================

using namespace System.Collections.Generic

#region Screen Classes

# ==============================================================================
# CLASS: DashboardScreen (Data-Driven Dashboard with DataGridComponent)
#
# INHERITS:
#   - Screen (ABC.006)
#
# DEPENDENCIES:
#   Services:
#     - NavigationService (ASE.004)
#     - FocusManager (ASE.009)
#     - DataManager (ASE.003)
#     - ViewDefinitionService (ASE.011)
#   Components:
#     - Panel (ACO.011)
#     - DataGridComponent (ACO.022)
#     - LabelComponent (ACO.001)
#
# PURPOSE:
#   Data-driven dashboard showing task statistics, recent tasks, and quick actions
#   using the ViewDefinitionService pattern for consistent formatting.
# ==============================================================================
class DashboardScreen : Screen {
    hidden [Panel] $_mainPanel
    hidden [Panel] $_menuPanel
    hidden [List[LabelComponent]] $_menuItems
    hidden [int] $_selectedIndex = 0
    
    DashboardScreen([object]$serviceContainer) : base("DashboardScreen", $serviceContainer) {}

    [void] Initialize() {
        Write-Log -Level Debug -Message "DashboardScreen.Initialize: Starting initialization"
        if (-not $this.ServiceContainer) { 
            Write-Log -Level Error -Message "DashboardScreen.Initialize: ServiceContainer is null!"
            return 
        }

        # Main panel takes full screen
        $this._mainPanel = [Panel]::new("MainPanel")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = " Axiom-Phoenix v4.0 - Main Menu "
        $this._mainPanel.HasBorder = $true
        $this._mainPanel.BorderStyle = "Double"
        $this.AddChild($this._mainPanel)

        # Menu panel
        $this._menuPanel = [Panel]::new("MenuPanel")
        $this._menuPanel.X = [Math]::Floor(($this.Width - 40) / 2)
        $this._menuPanel.Y = 5
        $this._menuPanel.Width = 40
        $this._menuPanel.Height = 10
        $this._menuPanel.HasBorder = $true
        $this._menuPanel.BorderStyle = "Double"
        $this._menuPanel.Title = " Navigation "
        $this._mainPanel.AddChild($this._menuPanel)
        
        # Create menu items as labels
        $this._menuItems = [List[LabelComponent]]::new()
        $menuTexts = @(
            "[1] Dashboard (Current)",
            "[2] Task List",
            "[3] Theme Picker", 
            "[4] Command Palette (Ctrl+P)",
            "",
            "[Q] Quit"
        )
        
        $yPos = 1
        foreach ($text in $menuTexts) {
            $label = [LabelComponent]::new("MenuItem_$yPos")
            $label.Text = $text
            $label.X = 2
            $label.Y = $yPos
            $label.ForegroundColor = Get-ThemeColor("component.text")
            $this._menuPanel.AddChild($label)
            $this._menuItems.Add($label)
            $yPos++
        }
        
        # Highlight first item
        if ($this._menuItems.Count -gt 0) {
            $this._menuItems[0].ForegroundColor = Get-ThemeColor("Primary")
        }
        
        # Instructions
        $instructions = [LabelComponent]::new("Instructions")
        $instructions.Text = "Press the number/letter key to select an option"
        $instructions.X = [Math]::Floor(($this.Width - 42) / 2)
        $instructions.Y = 17
        $instructions.ForegroundColor = Get-ThemeColor("Subtle")
        $this._mainPanel.AddChild($instructions)
    }

    [void] OnEnter() {
        Write-Log -Level Debug -Message "DashboardScreen.OnEnter: Screen activated"
        $this.RequestRedraw()
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        Write-Log -Level Debug -Message "DashboardScreen.HandleInput: Received key - Key: $($keyInfo.Key), KeyChar: '$($keyInfo.KeyChar)', Modifiers: $($keyInfo.Modifiers)"
        
        $actionService = $this.ServiceContainer?.GetService("ActionService")
        if (-not $actionService) { 
            Write-Log -Level Error -Message "DashboardScreen: ActionService not found!"
            return $false 
        }
        
        $handled = $false
        
        # Check both KeyChar and Key enum for number keys
        $char = $keyInfo.KeyChar
        $key = $keyInfo.Key
        
        # Direct character check
        switch ($char) {
            '1' { $handled = $true }
            '2' { $actionService.ExecuteAction("navigation.taskList", @{}); $handled = $true }
            '3' { $actionService.ExecuteAction("navigation.themePicker", @{}); $handled = $true }
            '4' { $actionService.ExecuteAction("app.commandPalette", @{}); $handled = $true }
            'q' { $actionService.ExecuteAction("app.exit", @{}); $handled = $true }
            'Q' { $actionService.ExecuteAction("app.exit", @{}); $handled = $true }
        }
        
        # If not handled by character, try Key enum
        if (-not $handled) {
            switch ($key) {
                ([ConsoleKey]::D1) { $handled = $true }
                ([ConsoleKey]::D2) { $actionService.ExecuteAction("navigation.taskList", @{}); $handled = $true }
                ([ConsoleKey]::D3) { $actionService.ExecuteAction("navigation.themePicker", @{}); $handled = $true }
                ([ConsoleKey]::D4) { $actionService.ExecuteAction("app.commandPalette", @{}); $handled = $true }
                ([ConsoleKey]::Q) { $actionService.ExecuteAction("app.exit", @{}); $handled = $true }
            }
        }
        
        # Arrow key navigation
        switch ($key) {
            ([ConsoleKey]::UpArrow) {
                if ($this._selectedIndex -gt 0) {
                    # Reset previous item color
                    $this._menuItems[$this._selectedIndex].ForegroundColor = Get-ThemeColor("component.text")
                    $this._selectedIndex--
                    # Skip empty items
                    while ($this._selectedIndex -gt 0 -and [string]::IsNullOrWhiteSpace($this._menuItems[$this._selectedIndex].Text)) {
                        $this._selectedIndex--
                    }
                    # Highlight new item
                    $this._menuItems[$this._selectedIndex].ForegroundColor = Get-ThemeColor("Primary")
                    $this.RequestRedraw()
                }
                $handled = $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this._selectedIndex -lt $this._menuItems.Count - 1) {
                    # Reset previous item color
                    $this._menuItems[$this._selectedIndex].ForegroundColor = Get-ThemeColor("component.text")
                    $this._selectedIndex++
                    # Skip empty items
                    while ($this._selectedIndex -lt $this._menuItems.Count - 1 -and [string]::IsNullOrWhiteSpace($this._menuItems[$this._selectedIndex].Text)) {
                        $this._selectedIndex++
                    }
                    # Highlight new item
                    $this._menuItems[$this._selectedIndex].ForegroundColor = Get-ThemeColor("Primary")
                    $this.RequestRedraw()
                }
                $handled = $true
            }
            ([ConsoleKey]::Enter) {
                # Execute selected item
                switch ($this._selectedIndex) {
                    0 { $handled = $true } # Already on dashboard
                    1 { $actionService.ExecuteAction("navigation.taskList", @{}); $handled = $true }
                    2 { $actionService.ExecuteAction("navigation.themePicker", @{}); $handled = $true }
                    3 { $actionService.ExecuteAction("app.commandPalette", @{}); $handled = $true }
                    5 { $actionService.ExecuteAction("app.exit", @{}); $handled = $true }
                }
            }
        }
        
        return $handled
    }
}

#endregion
#<!-- END_PAGE: ASC.001 -->



####\Screens\ASC.002_TaskListScreen.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Screens (Load After Components)
# Application screens that extend Screen base class
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASC.###" to find specific sections.
# Each section ends with "END_PAGE: ASC.###"
# ==============================================================================

using namespace System.Collections.Generic

#region TaskListScreen Class

class TaskListScreen : Screen { 
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [Panel] $_listPanel          # Left panel for task list
    hidden [Panel] $_contextPanel       # Top-right panel for filters
    hidden [Panel] $_detailPanel        # Main-right panel for details
    hidden [Panel] $_statusBar          # Bottom status bar
    hidden [ListBox] $_taskListBox      # Simplified task list
    hidden [TextBoxComponent] $_filterBox
    hidden [LabelComponent] $_sortLabel
    hidden [LabelComponent] $_helpLabel
    hidden [ButtonComponent] $_projectButton
    #endregion

    #region State
    hidden [System.Collections.Generic.List[PmcTask]] $_tasks
    hidden [System.Collections.Generic.List[PmcTask]] $_filteredTasks
    hidden [int] $_selectedIndex = 0
    hidden [PmcTask] $_selectedTask
    hidden [string] $_filterText = ""
    hidden [string] $_currentProject = "All Projects"
    hidden [string] $_sortBy = "Priority"
    hidden [bool] $_sortDescending = $true
    hidden [string] $_taskChangeSubscriptionId = $null
    #endregion

    TaskListScreen([object]$serviceContainer) : base("TaskListScreen", $serviceContainer) {}

    [void] Initialize() {
        if (-not $this.ServiceContainer) { return }
        
        # Ensure minimum size
        if ($this.Width -lt 120) { $this.Width = 120 }
        if ($this.Height -lt 30) { $this.Height = 30 }
        
        # Main panel with sophisticated styling
        $this._mainPanel = [Panel]::new("TaskListMain")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = " ╔═ Task Management System ═╗ "
        $this._mainPanel.BorderStyle = "Double"
        $this._mainPanel.BorderColor = Get-ThemeColor "primary.accent" "#00D4FF"
        $this._mainPanel.BackgroundColor = Get-ThemeColor "background" "#0A0A0A"
        $this.AddChild($this._mainPanel)

        # Calculate panel dimensions
        $listWidth = [Math]::Floor($this.Width * 0.35)  # 35% for list
        $detailWidth = $this.Width - $listWidth - 3     # Rest for details
        $contextHeight = 6                              # Fixed height for context

        # === LEFT PANEL: Clean Task List ===
        $this._listPanel = [Panel]::new("TaskList")
        $this._listPanel.X = 1
        $this._listPanel.Y = 1
        $this._listPanel.Width = $listWidth
        $this._listPanel.Height = $this.Height - 5  # Leave room for status bar
        $this._listPanel.Title = " Tasks "
        $this._listPanel.BorderStyle = "Single"
        $this._listPanel.BorderColor = Get-ThemeColor "border" "#333333"
        $this._mainPanel.AddChild($this._listPanel)

        # Project selector button at top of list
        $this._projectButton = [ButtonComponent]::new("ProjectSelector")
        $this._projectButton.Text = "▼ $($this._currentProject)"
        $this._projectButton.X = 2
        $this._projectButton.Y = 1
        $this._projectButton.Width = $listWidth - 4
        $this._projectButton.Height = 1
        $thisScreen = $this
        $this._projectButton.OnClick = {
            # TODO: Show project picker dialog
            Write-Host "Project picker coming soon!" -ForegroundColor Yellow
        }.GetNewClosure()
        $this._listPanel.AddChild($this._projectButton)

        # Task list with elegant styling
        $this._taskListBox = [ListBox]::new("TaskList")
        $this._taskListBox.X = 1
        $this._taskListBox.Y = 3
        $this._taskListBox.Width = $listWidth - 2
        $this._taskListBox.Height = $this._listPanel.Height - 5
        $this._taskListBox.HasBorder = $false
        $this._taskListBox.SelectedBackgroundColor = Get-ThemeColor "list.selected.bg" "#1E3A8A"
        $this._taskListBox.SelectedForegroundColor = Get-ThemeColor "list.selected.fg" "#FFFFFF"
        $this._taskListBox.ItemForegroundColor = Get-ThemeColor "list.item.fg" "#E0E0E0"
        $thisScreen = $this
        $this._taskListBox.SelectedIndexChanged = {
            param($sender, $index)
            $thisScreen._selectedIndex = $index
            if ($index -ge 0 -and $index -lt $thisScreen._filteredTasks.Count) {
                $thisScreen._selectedTask = $thisScreen._filteredTasks[$index]
            } else {
                $thisScreen._selectedTask = $null
            }
            $thisScreen._UpdateDetailPanel()
        }.GetNewClosure()
        $this._listPanel.AddChild($this._taskListBox)

        # === TOP-RIGHT PANEL: Context & Filters ===
        $this._contextPanel = [Panel]::new("Context")
        $this._contextPanel.X = $listWidth + 2
        $this._contextPanel.Y = 1
        $this._contextPanel.Width = $detailWidth
        $this._contextPanel.Height = $contextHeight
        $this._contextPanel.BorderStyle = "Single"
        $this._contextPanel.BorderColor = Get-ThemeColor "border" "#333333"
        $this._contextPanel.BackgroundColor = Get-ThemeColor "panel.bg" "#0F0F0F"
        $this._mainPanel.AddChild($this._contextPanel)

        # Filter box with icon
        $filterLabel = [LabelComponent]::new("FilterIcon")
        $filterLabel.Text = "🔍"
        $filterLabel.X = 2
        $filterLabel.Y = 1
        $filterLabel.ForegroundColor = Get-ThemeColor "icon" "#FFD700"
        $this._contextPanel.AddChild($filterLabel)

        $this._filterBox = [TextBoxComponent]::new("FilterBox")
        $this._filterBox.Placeholder = "Type to filter tasks..."
        $this._filterBox.X = 5
        $this._filterBox.Y = 1
        $this._filterBox.Width = [Math]::Floor($detailWidth * 0.5)
        $this._filterBox.Height = 3
        $thisScreen = $this
        $this._filterBox.IsFocusable = $true  # Make sure filter box is focusable
        $this._filterBox.OnChange = {
            param($sender, $newText)
            $thisScreen._filterText = $newText
            $thisScreen._RefreshTasks()
        }.GetNewClosure()
        $this._contextPanel.AddChild($this._filterBox)

        # Sort indicator
        $this._sortLabel = [LabelComponent]::new("SortLabel")
        $this._sortLabel.X = $this._filterBox.X + $this._filterBox.Width + 3
        $this._sortLabel.Y = 1
        $this._sortLabel.Text = "Sort: $($this._sortBy) ↓"
        $this._sortLabel.ForegroundColor = Get-ThemeColor "muted" "#888888"
        $this._contextPanel.AddChild($this._sortLabel)

        # Help text - with full text, no truncation
        $this._helpLabel = [LabelComponent]::new("HelpLabel")
        $this._helpLabel.X = 2
        $this._helpLabel.Y = 4
        $this._helpLabel.Text = "↑↓ Navigate | Enter: Edit | Space: Toggle | N: New | D: Delete"
        $this._helpLabel.ForegroundColor = Get-ThemeColor "help" "#666666"
        $this._contextPanel.AddChild($this._helpLabel)

        # === MAIN-RIGHT PANEL: Rich Task Details ===
        $this._detailPanel = [Panel]::new("TaskDetails")
        $this._detailPanel.X = $listWidth + 2
        $this._detailPanel.Y = $contextHeight + 2
        $this._detailPanel.Width = $detailWidth
        $this._detailPanel.Height = $this.Height - $contextHeight - 6
        $this._detailPanel.BorderStyle = "Single"
        $this._detailPanel.BorderColor = Get-ThemeColor "border" "#333333"
        $this._detailPanel.BackgroundColor = Get-ThemeColor "detail.bg" "#0A0A0A"
        $this._mainPanel.AddChild($this._detailPanel)

        # === BOTTOM STATUS BAR ===
        $this._CreateStatusBar()
        
        # Initialize empty task lists
        $this._tasks = [System.Collections.Generic.List[PmcTask]]::new()
        $this._filteredTasks = [System.Collections.Generic.List[PmcTask]]::new()
    }

    hidden [void] _CreateStatusBar() {
        $this._statusBar = [Panel]::new("StatusBar")
        $this._statusBar.X = 1
        $this._statusBar.Y = $this.Height - 3
        $this._statusBar.Width = $this.Width - 2
        $this._statusBar.Height = 2
        $this._statusBar.HasBorder = $false
        $this._statusBar.BackgroundColor = Get-ThemeColor "status.bg" "#1A1A1A"
        $this._mainPanel.AddChild($this._statusBar)

        # Separator line
        $separator = [LabelComponent]::new("StatusSep")
        $separator.X = 0
        $separator.Y = 0
        $separator.Text = "─" * ($this._statusBar.Width)
        $separator.ForegroundColor = Get-ThemeColor "border" "#333333"
        $this._statusBar.AddChild($separator)

        # Action buttons with modern styling
        $buttonY = 1
        $actions = @(
            @{ Text = "[N]ew"; Key = "N"; Color = "#00FF88"; Action = { $this._ShowNewTaskDialog() } },
            @{ Text = "[E]dit"; Key = "E"; Color = "#00BFFF"; Action = { $this._ShowEditTaskDialog() } },
            @{ Text = "[D]elete"; Key = "D"; Color = "#FF4444"; Action = { $this._DeleteTask() } },
            @{ Text = "[C]omplete"; Key = "C"; Color = "#FFD700"; Action = { $this._CompleteTask() } },
            @{ Text = "[T]ags"; Key = "T"; Color = "#FF69B4"; Action = { $this._ShowTagsDialog() } },
            @{ Text = "[S]ort"; Key = "S"; Color = "#8A2BE2"; Action = { $this._CycleSortMode() } },
            @{ Text = "[Ctrl+Q]uit"; Key = "Q"; Color = "#666666"; Action = { $this._Exit() } }
        )

        $x = 2
        foreach ($action in $actions) {
            $button = [LabelComponent]::new("Action_$($action.Key)")
            $button.X = $x
            $button.Y = $buttonY
            $button.Text = $action.Text
            $button.ForegroundColor = $action.Color
            $this._statusBar.AddChild($button)
            $x += $action.Text.Length + 3
        }
    }

    [void] OnEnter() {
        # Following Rule 2.3: OnEnter() Checklist
        
        # Step 1: Fetch initial data from services  
        $this._RefreshTasks()
        
        # Step 2: Set initial focus via FocusManager (CRITICAL for input to work)
        $focusManager = $this.ServiceContainer?.GetService("FocusManager")
        if ($focusManager -and $this._taskListBox) {
            $focusManager.SetFocus($this._taskListBox)
        }
        
        # Step 3: Subscribe to EventManager events
        $eventManager = $this.ServiceContainer?.GetService("EventManager")
        if ($eventManager) {
            # Create handler that properly captures $this
            $thisScreen = $this
            $handler = {
                param($eventData)
                $thisScreen._RefreshTasks()
            }.GetNewClosure()
            
            # Store subscription ID for later cleanup
            $this._taskChangeSubscriptionId = $eventManager.Subscribe("Tasks.Changed", $handler)
        }
        
        $this.RequestRedraw()
    }
    
    [void] OnExit() {
        # Unsubscribe from data change events
        $eventManager = $this.ServiceContainer?.GetService("EventManager")
        if ($eventManager -and $this._taskChangeSubscriptionId) {
            $eventManager.Unsubscribe("Tasks.Changed", $this._taskChangeSubscriptionId)
            $this._taskChangeSubscriptionId = $null
            # Write-Verbose "TaskListScreen unsubscribed from Tasks.Changed events"
        }
        
        # Call base OnExit if needed
        ([Screen]$this).OnExit()
    }

    hidden [void] _RefreshTasks() {
        $dataManager = $this.ServiceContainer?.GetService("DataManager")
        if ($dataManager) {
            $allTasks = $dataManager.GetTasks()
            
            # Clear filtered tasks
            $this._filteredTasks.Clear()
            
            # Apply filters
            foreach ($task in $allTasks) {
                # Skip if not matching project filter
                if ($this._currentProject -ne "All Projects" -and $task.ProjectKey -ne $this._currentProject) {
                    continue
                }
                
                # Skip if not matching text filter
                if (![string]::IsNullOrWhiteSpace($this._filterText)) {
                    $filterLower = $this._filterText.ToLower()
                    if (-not ($task.Title.ToLower().Contains($filterLower) -or
                             ($task.Description -and $task.Description.ToLower().Contains($filterLower)) -or
                             ($task.Tags -join " ").ToLower().Contains($filterLower))) {
                        continue
                    }
                }
                
                $this._filteredTasks.Add($task)
            }
            
            # Apply sorting
            $this._SortTasks()
            
            $this._tasks = [System.Collections.Generic.List[PmcTask]]::new($allTasks)
        } else {
            $this._tasks = [System.Collections.Generic.List[PmcTask]]::new()
            $this._filteredTasks = [System.Collections.Generic.List[PmcTask]]::new()
        }
        
        # Reset selection if needed
        if ($this._selectedIndex -ge $this._filteredTasks.Count) {
            $this._selectedIndex = [Math]::Max(0, $this._filteredTasks.Count - 1)
        }
        
        if ($this._filteredTasks.Count -gt 0) {
            $this._selectedTask = $this._filteredTasks[$this._selectedIndex]
        } else {
            $this._selectedTask = $null
        }
        
        $this._UpdateDisplay()
    }

    hidden [void] _SortTasks() {
        if ($this._filteredTasks.Count -eq 0) { return }
        
        $sorted = switch ($this._sortBy) {
            "Priority" {
                if ($this._sortDescending) {
                    $this._filteredTasks | Sort-Object -Property Priority -Descending | Sort-Object -Property Status
                } else {
                    $this._filteredTasks | Sort-Object -Property Priority | Sort-Object -Property Status
                }
            }
            "Title" {
                if ($this._sortDescending) {
                    $this._filteredTasks | Sort-Object -Property Title -Descending
                } else {
                    $this._filteredTasks | Sort-Object -Property Title
                }
            }
            "DueDate" {
                if ($this._sortDescending) {
                    $this._filteredTasks | Sort-Object -Property DueDate -Descending
                } else {
                    $this._filteredTasks | Sort-Object -Property DueDate
                }
            }
            "Status" {
                if ($this._sortDescending) {
                    $this._filteredTasks | Sort-Object -Property Status -Descending | Sort-Object -Property Priority -Descending
                } else {
                    $this._filteredTasks | Sort-Object -Property Status | Sort-Object -Property Priority -Descending
                }
            }
            default {
                $this._filteredTasks
            }
        }
        
        $this._filteredTasks.Clear()
        foreach ($task in $sorted) {
            $this._filteredTasks.Add($task)
        }
    }

    hidden [void] _UpdateDisplay() {
        $this._UpdateTaskList()
        $this._UpdateDetailPanel()
        $this._UpdateContextPanel()
        $this.RequestRedraw()
    }

    hidden [void] _UpdateTaskList() {
        if (-not $this._taskListBox) { return }
        
        $this._taskListBox.ClearItems()
        
        if ($this._filteredTasks.Count -eq 0) {
            if ($this._tasks.Count -eq 0) {
                $this._taskListBox.AddItem("  No tasks found. Press [N] to create one.")
            } else {
                $this._taskListBox.AddItem("  No tasks match your filter.")
            }
            return
        }
        
        # Add tasks with visual indicators
        foreach ($task in $this._filteredTasks) {
            # Status indicator
            $statusIcon = switch ($task.Status) {
                ([TaskStatus]::Pending) { "○" }
                ([TaskStatus]::InProgress) { "◐" }
                ([TaskStatus]::Completed) { "●" }
                ([TaskStatus]::Cancelled) { "✕" }
                default { "?" }
            }
            
            # Priority indicator
            $priorityIcon = switch ($task.Priority) {
                ([TaskPriority]::Low) { "↓" }
                ([TaskPriority]::Medium) { "-" }
                ([TaskPriority]::High) { "!" }
                default { " " }
            }
            
            # Truncate title to fit
            $maxTitleLength = $this._taskListBox.Width - 8
            $title = if ($task.Title.Length -gt $maxTitleLength) {
                $task.Title.Substring(0, $maxTitleLength - 3) + "..."
            } else {
                $task.Title
            }
            
            # Format: "○ ! Task Title"
            $displayText = "$statusIcon $priorityIcon $title"
            $this._taskListBox.AddItem($displayText)
        }
        
        # Preserve selection
        if ($this._selectedIndex -lt $this._filteredTasks.Count) {
            $this._taskListBox.SelectedIndex = $this._selectedIndex
        }
    }

    hidden [void] _UpdateDetailPanel() {
        $panel = $this._detailPanel
        if (-not $panel) { return }
        
        # Clear children
        $panel.Children.Clear()
        $panel.UpdateContentDimensions()
        
        if (-not $this._selectedTask) {
            # Show empty state
            $emptyLabel = [LabelComponent]::new("EmptyState")
            $emptyLabel.X = [Math]::Floor($panel.ContentWidth / 2) - 10
            $emptyLabel.Y = [Math]::Floor($panel.ContentHeight / 2)
            $emptyLabel.Text = "Select a task to view details"
            $emptyLabel.ForegroundColor = Get-ThemeColor "muted" "#666666"
            $panel.AddChild($emptyLabel)
            return
        }
        
        $task = $this._selectedTask
        $y = 2
        
        # === TASK TITLE HEADER ===
        $titlePanel = [Panel]::new("TitleHeader")
        $titlePanel.X = 2
        $titlePanel.Y = $y
        $titlePanel.Width = $panel.ContentWidth - 4
        $titlePanel.Height = 3
        $titlePanel.BorderStyle = "Double"
        $titlePanel.BorderColor = Get-ThemeColor "primary.accent" "#00D4FF"
        $titlePanel.BackgroundColor = Get-ThemeColor "header.bg" "#0D1929"
        $panel.AddChild($titlePanel)
        
        $titleLabel = [LabelComponent]::new("TaskTitle")
        $titleLabel.X = 2
        $titleLabel.Y = 1
        $titleLabel.Text = $task.Title
        $titleLabel.ForegroundColor = Get-ThemeColor "title" "#FFFFFF"
        $titlePanel.AddChild($titleLabel)
        
        $y += 4
        
        # === STATUS AND PRIORITY ROW ===
        $statusRow = [Panel]::new("StatusRow")
        $statusRow.X = 2
        $statusRow.Y = $y
        $statusRow.Width = $panel.ContentWidth - 4
        $statusRow.Height = 3
        $statusRow.HasBorder = $false
        $panel.AddChild($statusRow)
        
        # Status badge
        $statusBg = switch ($task.Status) {
            ([TaskStatus]::Pending) { "#FFA500" }
            ([TaskStatus]::InProgress) { "#00BFFF" }
            ([TaskStatus]::Completed) { "#00FF88" }
            ([TaskStatus]::Cancelled) { "#FF4444" }
            default { "#808080" }
        }
        
        $statusLabel = [LabelComponent]::new("StatusBadge")
        $statusLabel.X = 0
        $statusLabel.Y = 0
        $statusLabel.Text = " $($task.Status) "
        $statusLabel.BackgroundColor = $statusBg
        $statusLabel.ForegroundColor = "#000000"
        $statusRow.AddChild($statusLabel)
        
        # Priority badge
        $priorityX = $statusLabel.Text.Length + 2
        $priorityBg = switch ($task.Priority) {
            ([TaskPriority]::Low) { "#2E7D32" }
            ([TaskPriority]::Medium) { "#ED6C02" }
            ([TaskPriority]::High) { "#D32F2F" }
            default { "#808080" }
        }
        
        $priorityLabel = [LabelComponent]::new("PriorityBadge")
        $priorityLabel.X = $priorityX
        $priorityLabel.Y = 0
        $priorityLabel.Text = " $($task.Priority) Priority "
        $priorityLabel.BackgroundColor = $priorityBg
        $priorityLabel.ForegroundColor = "#FFFFFF"
        $statusRow.AddChild($priorityLabel)
        
        # Progress bar
        $progressX = $priorityX + $priorityLabel.Text.Length + 2
        $progressLabel = [LabelComponent]::new("ProgressLabel")
        $progressLabel.X = $progressX
        $progressLabel.Y = 0
        $progressLabel.Text = "Progress:"
        $progressLabel.ForegroundColor = Get-ThemeColor "label" "#B0B0B0"
        $statusRow.AddChild($progressLabel)
        
        $barX = $progressX + 10
        $barWidth = 20
        $filledWidth = [Math]::Floor($barWidth * $task.Progress / 100)
        $progressBar = [LabelComponent]::new("ProgressBar")
        $progressBar.X = $barX
        $progressBar.Y = 0
        $progressBar.Text = "█" * $filledWidth + "░" * ($barWidth - $filledWidth) + " $($task.Progress)%"
        $progressBar.ForegroundColor = if ($task.Progress -eq 100) { "#00FF88" } else { "#00BFFF" }
        $statusRow.AddChild($progressBar)
        
        $y += 4
        
        # === PROJECT AND DUE DATE ===
        $metaPanel = [Panel]::new("MetaInfo")
        $metaPanel.X = 2
        $metaPanel.Y = $y
        $metaPanel.Width = $panel.ContentWidth - 4
        $metaPanel.Height = 4
        $metaPanel.BorderStyle = "Single"
        $metaPanel.BorderColor = Get-ThemeColor "border" "#333333"
        $metaPanel.BackgroundColor = Get-ThemeColor "meta.bg" "#111111"
        $panel.AddChild($metaPanel)
        
        # Project
        $projectLabel = [LabelComponent]::new("ProjectLabel")
        $projectLabel.X = 2
        $projectLabel.Y = 1
        $projectLabel.Text = "Project: $($task.ProjectKey)"
        $projectLabel.ForegroundColor = Get-ThemeColor "project" "#FFD700"
        $metaPanel.AddChild($projectLabel)
        
        # Due date with conditional formatting
        if ($task.DueDate) {
            $dueLabel = [LabelComponent]::new("DueLabel")
            $dueLabel.X = $projectLabel.Text.Length + 5
            $dueLabel.Y = 1
            $daysUntil = ($task.DueDate - [DateTime]::Now).Days
            $dueText = "Due: $($task.DueDate.ToString('MMM dd, yyyy'))"
            
            if ($daysUntil -lt 0) {
                $dueText += " (OVERDUE)"
                $dueLabel.ForegroundColor = "#FF4444"
            } elseif ($daysUntil -eq 0) {
                $dueText += " (TODAY)"
                $dueLabel.ForegroundColor = "#FFA500"
            } elseif ($daysUntil -le 3) {
                $dueText += " ($daysUntil days)"
                $dueLabel.ForegroundColor = "#FFD700"
            } else {
                $dueLabel.ForegroundColor = Get-ThemeColor "due" "#00FF88"
            }
            
            $dueLabel.Text = $dueText
            $metaPanel.AddChild($dueLabel)
        }
        
        # Created date
        $createdLabel = [LabelComponent]::new("CreatedLabel")
        $createdLabel.X = 2
        $createdLabel.Y = 2
        $age = $task.GetAge()
        $ageText = if ($age.Days -gt 0) { "$($age.Days)d" } elseif ($age.Hours -gt 0) { "$($age.Hours)h" } else { "$($age.Minutes)m" }
        $createdLabel.Text = "Created: $($task.CreatedAt.ToString('MMM dd, yyyy')) ($ageText ago)"
        $createdLabel.ForegroundColor = Get-ThemeColor "muted" "#808080"
        $metaPanel.AddChild($createdLabel)
        
        $y += 5
        
        # === DESCRIPTION SECTION ===
        if (-not [string]::IsNullOrEmpty($task.Description)) {
            $descPanel = [Panel]::new("DescriptionPanel")
            $descPanel.X = 2
            $descPanel.Y = $y
            $descPanel.Width = $panel.ContentWidth - 4
            $descPanel.Height = [Math]::Min(8, $panel.ContentHeight - $y - 4)
            $descPanel.Title = " Description "
            $descPanel.BorderStyle = "Single"
            $descPanel.BorderColor = Get-ThemeColor "border" "#333333"
            $panel.AddChild($descPanel)
            
            # Word wrap description
            $words = $task.Description -split '\s+'
            $line = ""
            $maxLineLength = $descPanel.ContentWidth - 2
            $lineY = 1
            
            foreach ($word in $words) {
                if (($line + " " + $word).Length -gt $maxLineLength) {
                    if ($line -and $lineY -lt $descPanel.ContentHeight - 1) {
                        $descLine = [LabelComponent]::new("DescLine$lineY")
                        $descLine.X = 1
                        $descLine.Y = $lineY
                        $descLine.Text = $line
                        $descLine.ForegroundColor = Get-ThemeColor "text" "#E0E0E0"
                        $descPanel.AddChild($descLine)
                        $lineY++
                    }
                    $line = $word
                } else {
                    $line = if ($line) { "$line $word" } else { $word }
                }
            }
            
            if ($line -and $lineY -lt $descPanel.ContentHeight - 1) {
                $descLine = [LabelComponent]::new("DescLineLast")
                $descLine.X = 1
                $descLine.Y = $lineY
                $descLine.Text = $line
                $descLine.ForegroundColor = Get-ThemeColor "text" "#E0E0E0"
                $descPanel.AddChild($descLine)
            }
            
            $y += $descPanel.Height + 1
        }
        
        # === TAGS SECTION ===
        if ($task.Tags.Count -gt 0) {
            $tagsY = if ($task.Description) { $y } else { $y + 1 }
            $tagsLabel = [LabelComponent]::new("TagsLabel")
            $tagsLabel.X = 2
            $tagsLabel.Y = $tagsY
            $tagsLabel.Text = "Tags: "
            $tagsLabel.ForegroundColor = Get-ThemeColor "label" "#B0B0B0"
            $panel.AddChild($tagsLabel)
            
            $tagX = $tagsLabel.X + $tagsLabel.Text.Length
            foreach ($tag in $task.Tags) {
                $tagBadge = [LabelComponent]::new("Tag_$tag")
                $tagBadge.X = $tagX
                $tagBadge.Y = $tagsY
                $tagBadge.Text = " #$tag "
                $tagBadge.BackgroundColor = Get-ThemeColor "tag.bg" "#FF69B4"
                $tagBadge.ForegroundColor = Get-ThemeColor "tag.fg" "#000000"
                $panel.AddChild($tagBadge)
                $tagX += $tagBadge.Text.Length + 1
            }
        }
        
        $panel.RequestRedraw()
    }

    hidden [void] _UpdateContextPanel() {
        if (-not $this._sortLabel) { return }
        
        # Update sort indicator
        $arrow = if ($this._sortDescending) { "↓" } else { "↑" }
        $this._sortLabel.Text = "Sort: $($this._sortBy) $arrow"
        
        # Update help text based on context
        if ($this._selectedTask) {
            $this._helpLabel.Text = "↑↓ Navigate │ Enter Edit │ Space Toggle │ N New │ D Delete │ C Complete"
        } else {
            $this._helpLabel.Text = "Press N to create your first task │ Ctrl+Q to quit"
        }
    }

    #region CRUD Operations

    hidden [void] _ShowNewTaskDialog() {
        $navService = $this.ServiceContainer?.GetService("NavigationService")
        if (-not $navService) { return }
        
        # Create simple input dialog instead of complex TaskEditDialog
        $dialog = [SimpleTaskDialog]::new($this.ServiceContainer, $null)
        $thisScreen = $this
        $dialog.OnSave = {
            param($task)
            $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
            if ($dataManager) {
                $dataManager.AddTask($task)
                $thisScreen._RefreshTasks()
            }
        }.GetNewClosure()
        
        $navService.NavigateTo($dialog)
    }
    
    hidden [void] _ShowEditTaskDialog() {
        if (-not $this._selectedTask) { return }
        
        $navService = $this.ServiceContainer?.GetService("NavigationService")
        if (-not $navService) { return }
        
        # Create simple input dialog with existing task
        $dialog = [SimpleTaskDialog]::new($this.ServiceContainer, $this._selectedTask.Clone())
        $thisScreen = $this
        $dialog.OnSave = {
            param($task)
            $dataManager = $thisScreen.ServiceContainer?.GetService("DataManager")
            if ($dataManager) {
                # Update the original task with edited values
                $original = $thisScreen._selectedTask
                $original.Title = $task.Title
                $original.Description = $task.Description
                $original.Priority = $task.Priority
                $original.ProjectKey = $task.ProjectKey
                $original.DueDate = $task.DueDate
                $original.UpdatedAt = [DateTime]::Now
                
                $dataManager.UpdateTask($original)
                $thisScreen._RefreshTasks()
            }
        }.GetNewClosure()
        
        $navService.NavigateTo($dialog)
    }
    
    hidden [void] _DeleteTask() {
        if (-not $this._selectedTask) { return }
        
        $navService = $this.ServiceContainer?.GetService("NavigationService")
        if (-not $navService) { return }
        
        # Create confirmation dialog
        $dialog = [ConfirmDialog]::new($this.ServiceContainer)
        $dialog.Title = "Delete Task"
        $dialog.Message = "Are you sure you want to delete:`n`n'$($this._selectedTask.Title)'`n`nThis action cannot be undone."
        $dialog.OnConfirm = {
            $dataManager = $this.ServiceContainer?.GetService("DataManager")
            if ($dataManager) {
                $dataManager.DeleteTask($this._selectedTask.Id)
                $this._RefreshTasks()
            }
        }.GetNewClosure()
        
        $navService.NavigateTo($dialog)
    }
    
    hidden [void] _CompleteTask() {
        if (-not $this._selectedTask) { return }
        
        $dataManager = $this.ServiceContainer?.GetService("DataManager")
        if ($dataManager) {
            $this._selectedTask.Complete()
            $dataManager.UpdateTask($this._selectedTask)
            $this._RefreshTasks()
        }
    }
    
    hidden [void] _ShowTagsDialog() {
        if (-not $this._selectedTask) { return }
        
        # TODO: Implement tags dialog
        Write-Host "Tags dialog coming soon!" -ForegroundColor Yellow
    }
    
    hidden [void] _CycleSortMode() {
        # Cycle through sort modes
        $modes = @("Priority", "Title", "DueDate", "Status")
        $currentIndex = [Array]::IndexOf($modes, $this._sortBy)
        
        if ($currentIndex -eq $modes.Length - 1) {
            # Was at the end, go back to start and toggle order
            $this._sortBy = $modes[0]
            $this._sortDescending = -not $this._sortDescending
        } else {
            # Move to next sort mode
            $this._sortBy = $modes[$currentIndex + 1]
        }
        
        $this._RefreshTasks()
    }
    
    hidden [void] _Exit() {
        $actionService = $this.ServiceContainer?.GetService("ActionService")
        if ($actionService) {
            $actionService.ExecuteAction("app.exit", @{})
        }
    }
    
    #endregion

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($null -eq $keyInfo) { return $false }
        
        # Check if focus is on filter box - let it handle input first
        $focusManager = $this.ServiceContainer?.GetService("FocusManager")
        if ($focusManager -and $focusManager.FocusedComponent -eq $this._filterBox) {
            # Only handle escape to unfocus
            if ($keyInfo.Key -eq [ConsoleKey]::Escape) {
                $focusManager.SetFocus($this._taskListBox)
                return $true
            }
            return $false
        }
        
        # Handle single key commands
        switch ($keyInfo.KeyChar) {
            'n' {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    $this._ShowNewTaskDialog()
                    return $true
                }
            }
            'N' {
                $this._ShowNewTaskDialog()
                return $true
            }
            'e' {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None -and $this._selectedTask) {
                    $this._ShowEditTaskDialog()
                    return $true
                }
            }
            'E' {
                if ($this._selectedTask) {
                    $this._ShowEditTaskDialog()
                    return $true
                }
            }
            'd' {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None -and $this._selectedTask) {
                    $this._DeleteTask()
                    return $true
                }
            }
            'D' {
                if ($this._selectedTask) {
                    $this._DeleteTask()
                    return $true
                }
            }
            'c' {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None -and $this._selectedTask) {
                    $this._CompleteTask()
                    return $true
                }
            }
            'C' {
                if ($this._selectedTask) {
                    $this._CompleteTask()
                    return $true
                }
            }
            't' {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None -and $this._selectedTask) {
                    $this._ShowTagsDialog()
                    return $true
                }
            }
            'T' {
                if ($this._selectedTask) {
                    $this._ShowTagsDialog()
                    return $true
                }
            }
            's' {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    $this._CycleSortMode()
                    return $true
                }
            }
            'S' {
                $this._CycleSortMode()
                return $true
            }
            '/' {
                # Focus on filter box
                if ($focusManager) {
                    $focusManager.SetFocus($this._filterBox)
                }
                return $true
            }
        }
        
        # Handle special keys
        switch ($keyInfo.Key) {
            ([ConsoleKey]::Enter) {
                if ($this._selectedTask) {
                    $this._ShowEditTaskDialog()
                    return $true
                }
            }
            ([ConsoleKey]::Tab) {
                # Cycle focus between components
                $focusManager = $this.ServiceContainer.GetService("FocusManager")
                if ($focusManager) {
                    if ($this._taskListBox.IsFocused) {
                        $focusManager.SetFocus($this._filterBox)
                    } else {
                        $focusManager.SetFocus($this._taskListBox)
                    }
                }
                return $true
            }
            ([ConsoleKey]::Spacebar) {
                if ($this._selectedTask) {
                    # Toggle task progress between 0 and 100
                    $dataManager = $this.ServiceContainer?.GetService("DataManager")
                    if ($dataManager) {
                        if ($this._selectedTask.Progress -eq 100) {
                            $this._selectedTask.SetProgress(0)
                        } else {
                            $this._selectedTask.SetProgress(100)
                        }
                        $dataManager.UpdateTask($this._selectedTask)
                        $this._RefreshTasks()
                    }
                    return $true
                }
            }
            ([ConsoleKey]::F5) {
                # Refresh data
                $this._RefreshTasks()
                return $true
            }
        }
        
        # Handle Ctrl combinations
        if ($keyInfo.Modifiers -eq [ConsoleModifiers]::Control) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::Q) {
                    $this._Exit()
                    return $true
                }
                ([ConsoleKey]::N) {
                    # Create sub-task
                    if ($this._selectedTask) {
                        # TODO: Implement sub-task creation
                        Write-Host "Sub-task feature coming soon!" -ForegroundColor Yellow
                    }
                    return $true
                }
            }
        }
        
        # Let base class handle input routing to focused component
        return ([Screen]$this).HandleInput($keyInfo)
    }
}

#endregion
#<!-- END_PAGE: ASC.002 -->

#region Dialog Screens

class SimpleTaskDialog : Screen {
    hidden [Panel] $_dialogPanel
    hidden [Panel] $_contentPanel
    hidden [TextBoxComponent] $_titleBox
    hidden [TextBoxComponent] $_descriptionBox
    hidden [PmcTask] $_task
    hidden [TaskPriority] $_selectedPriority
    hidden [string] $_selectedProject
    hidden [int] $_focusIndex = 0
    hidden [int] $_maxFocusIndex = 4  # title, desc, priority, project, save/cancel
    
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    hidden [bool] $_isNewTask
    
    SimpleTaskDialog([object]$serviceContainer, [PmcTask]$existingTask) : base("SimpleTaskDialog", $serviceContainer) {
        $this.IsOverlay = $true
        if ($existingTask) {
            $this._task = $existingTask
            $this._selectedPriority = $existingTask.Priority
            $this._selectedProject = $existingTask.ProjectKey
            $this._isNewTask = $false
        } else {
            $this._task = [PmcTask]::new()
            $this._selectedPriority = [TaskPriority]::Medium
            $this._selectedProject = "General"
            $this._isNewTask = $true
        }
    }
    
    [void] Initialize() {
        # Full screen semi-transparent overlay
        $overlayPanel = [Panel]::new("Overlay")
        $overlayPanel.X = 0
        $overlayPanel.Y = 0
        $overlayPanel.Width = $this.Width
        $overlayPanel.Height = $this.Height
        $overlayPanel.HasBorder = $false
        $overlayPanel.BackgroundColor = "#000000"
        $this.AddChild($overlayPanel)
        
        # Create centered dialog
        $dialogWidth = 60
        $dialogHeight = 15
        $dialogX = [Math]::Floor(($this.Width - $dialogWidth) / 2)
        $dialogY = [Math]::Floor(($this.Height - $dialogHeight) / 2)
        
        $this._dialogPanel = [Panel]::new("DialogMain")
        $this._dialogPanel.X = $dialogX
        $this._dialogPanel.Y = $dialogY
        $this._dialogPanel.Width = $dialogWidth
        $this._dialogPanel.Height = $dialogHeight
        $this._dialogPanel.Title = if ($this._isNewTask) { " New Task " } else { " Edit Task " }
        $this._dialogPanel.BorderStyle = "Double"
        $this._dialogPanel.BorderColor = Get-ThemeColor "accent" "#00D4FF"
        $this._dialogPanel.BackgroundColor = Get-ThemeColor "dialog.bg" "#1A1A1A"
        $this.AddChild($this._dialogPanel)
        
        # Content panel
        $this._contentPanel = [Panel]::new("Content")
        $this._contentPanel.X = 2
        $this._contentPanel.Y = 1
        $this._contentPanel.Width = $dialogWidth - 4
        $this._contentPanel.Height = $dialogHeight - 2
        $this._contentPanel.HasBorder = $false
        $this._dialogPanel.AddChild($this._contentPanel)
        
        $y = 1
        
        # Title field
        $titleLabel = [LabelComponent]::new("TitleLabel")
        $titleLabel.X = 0
        $titleLabel.Y = $y
        $titleLabel.Text = "Task Title:"
        $titleLabel.ForegroundColor = Get-ThemeColor "label" "#FFD700"
        $this._contentPanel.AddChild($titleLabel)
        
        $y++
        $this._titleBox = [TextBoxComponent]::new("TitleBox")
        $this._titleBox.X = 0
        $this._titleBox.Y = $y
        $this._titleBox.Width = $this._contentPanel.Width
        $this._titleBox.Height = 1
        $this._titleBox.Text = if ($this._task.Title) { $this._task.Title } else { "" }
        $this._titleBox.Placeholder = "Enter task title..."
        $this._contentPanel.AddChild($this._titleBox)
        
        $y += 2
        
        # Description field
        $descLabel = [LabelComponent]::new("DescLabel")
        $descLabel.X = 0
        $descLabel.Y = $y
        $descLabel.Text = "Description:"
        $descLabel.ForegroundColor = Get-ThemeColor "label" "#00D4FF"
        $this._contentPanel.AddChild($descLabel)
        
        $y++
        $this._descriptionBox = [TextBoxComponent]::new("DescBox")
        $this._descriptionBox.X = 0
        $this._descriptionBox.Y = $y
        $this._descriptionBox.Width = $this._contentPanel.Width
        $this._descriptionBox.Height = 1
        $this._descriptionBox.Text = if ($this._task.Description) { $this._task.Description } else { "" }
        $this._descriptionBox.Placeholder = "Enter description..."
        $this._contentPanel.AddChild($this._descriptionBox)
        
        $y += 2
        
        # Priority and Project row
        $prioLabel = [LabelComponent]::new("PrioLabel")
        $prioLabel.X = 0
        $prioLabel.Y = $y
        $prioLabel.Text = "Priority:"
        $prioLabel.ForegroundColor = Get-ThemeColor "label" "#FF69B4"
        $this._contentPanel.AddChild($prioLabel)
        
        $prioValue = [LabelComponent]::new("PrioValue")
        $prioValue.X = 10
        $prioValue.Y = $y
        $prioValue.Text = "[$($this._selectedPriority)]"
        $priorityColor = switch ($this._selectedPriority) {
            ([TaskPriority]::Low) { "#00FF88" }
            ([TaskPriority]::Medium) { "#FFD700" }
            ([TaskPriority]::High) { "#FF4444" }
        }
        $prioValue.ForegroundColor = $priorityColor
        $this._contentPanel.AddChild($prioValue)
        
        $projLabel = [LabelComponent]::new("ProjLabel")
        $projLabel.X = 25
        $projLabel.Y = $y
        $projLabel.Text = "Project:"
        $projLabel.ForegroundColor = Get-ThemeColor "label" "#8A2BE2"
        $this._contentPanel.AddChild($projLabel)
        
        $projValue = [LabelComponent]::new("ProjValue")
        $projValue.X = 34
        $projValue.Y = $y
        $projValue.Text = "[$($this._selectedProject)]"
        $projValue.ForegroundColor = Get-ThemeColor "project" "#FFD700"
        $this._contentPanel.AddChild($projValue)
        
        $y += 2
        
        # Status message
        $statusLabel = [LabelComponent]::new("Status")
        $statusLabel.X = 0
        $statusLabel.Y = $y
        $statusLabel.Text = if ($this._isNewTask) { "Ready to create task" } else { "Ready to save changes" }
        $statusLabel.ForegroundColor = Get-ThemeColor "muted" "#888888"
        $this._contentPanel.AddChild($statusLabel)
        
        $y += 2
        
        # Buttons
        $saveLabel = [LabelComponent]::new("SaveBtn")
        $saveLabel.X = [Math]::Floor($this._contentPanel.Width / 2) - 15
        $saveLabel.Y = $y
        $saveLabel.Text = "  Save (S)  "
        $saveLabel.BackgroundColor = Get-ThemeColor "button.bg" "#0D47A1"
        $saveLabel.ForegroundColor = Get-ThemeColor "button.fg" "#FFFFFF"
        $this._contentPanel.AddChild($saveLabel)
        
        $cancelLabel = [LabelComponent]::new("CancelBtn")
        $cancelLabel.X = [Math]::Floor($this._contentPanel.Width / 2) + 2
        $cancelLabel.Y = $y
        $cancelLabel.Text = " Cancel (C) "
        $cancelLabel.BackgroundColor = Get-ThemeColor "button.cancel.bg" "#B71C1C"
        $cancelLabel.ForegroundColor = Get-ThemeColor "button.fg" "#FFFFFF"
        $this._contentPanel.AddChild($cancelLabel)
    }
    
    [void] OnEnter() {
        # Set initial focus to title box
        $focusManager = $this.ServiceContainer?.GetService("FocusManager")
        if ($focusManager -and $this._titleBox) {
            $focusManager.SetFocus($this._titleBox)
            $this._focusIndex = 0
        }
        $this.RequestRedraw()
    }
    
    hidden [void] _SaveTask() {
        # Validate
        if ([string]::IsNullOrWhiteSpace($this._titleBox.Text)) {
            # Update status
            $status = $this._contentPanel.Children | Where-Object { $_.Name -eq "Status" }
            if ($status) {
                $status.Text = "Title is required!"
                $status.ForegroundColor = "#FF4444"
                $this.RequestRedraw()
            }
            return
        }
        
        # Update task
        $this._task.Title = $this._titleBox.Text.Trim()
        $this._task.Description = $this._descriptionBox.Text.Trim()
        $this._task.Priority = $this._selectedPriority
        $this._task.ProjectKey = $this._selectedProject
        $this._task.UpdatedAt = [DateTime]::Now
        
        # Execute callback
        if ($this.OnSave) {
            & $this.OnSave $this._task
        }
        
        # Go back
        $navService = $this.ServiceContainer?.GetService("NavigationService")
        if ($navService -and $navService.CanGoBack()) {
            $navService.GoBack()
        }
    }
    
    hidden [void] _Cancel() {
        if ($this.OnCancel) {
            & $this.OnCancel
        }
        
        $navService = $this.ServiceContainer?.GetService("NavigationService")
        if ($navService -and $navService.CanGoBack()) {
            $navService.GoBack()
        }
    }
    
    hidden [void] _CyclePriority() {
        $priorities = @([TaskPriority]::Low, [TaskPriority]::Medium, [TaskPriority]::High)
        $currentIndex = [Array]::IndexOf($priorities, $this._selectedPriority)
        $this._selectedPriority = $priorities[($currentIndex + 1) % $priorities.Length]
        
        # Update display
        $prioValue = $this._contentPanel.Children | Where-Object { $_.Name -eq "PrioValue" }
        if ($prioValue) {
            $prioValue.Text = "[$($this._selectedPriority)]"
            $priorityColor = switch ($this._selectedPriority) {
                ([TaskPriority]::Low) { "#00FF88" }
                ([TaskPriority]::Medium) { "#FFD700" }
                ([TaskPriority]::High) { "#FF4444" }
            }
            $prioValue.ForegroundColor = $priorityColor
            $this.RequestRedraw()
        }
    }
    
    hidden [void] _NextFocus() {
        $focusManager = $this.ServiceContainer?.GetService("FocusManager")
        if (-not $focusManager) { return }
        
        $this._focusIndex = ($this._focusIndex + 1) % 3  # Only 0, 1, 2 (title, desc, buttons)
        
        switch ($this._focusIndex) {
            0 { $focusManager.SetFocus($this._titleBox) }
            1 { $focusManager.SetFocus($this._descriptionBox) }
            2 { $focusManager.SetFocus($this) }  # Focus dialog for button handling
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($null -eq $keyInfo) { return $false }
        
        # Let focused component handle input first
        $focusManager = $this.ServiceContainer?.GetService("FocusManager")
        if ($focusManager) {
            $focused = $focusManager.FocusedComponent
            if ($focused -and $focused -ne $this) {
                # Special handling for Tab to move focus
                if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
                    $this._NextFocus()
                    return $true
                }
                # Let component handle other input
                return $false
            }
        }
        
        # Dialog-level shortcuts
        switch ($keyInfo.KeyChar) {
            's' {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    $this._SaveTask()
                    return $true
                }
            }
            'S' {
                $this._SaveTask()
                return $true
            }
            'c' {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    $this._Cancel()
                    return $true
                }
            }
            'C' {
                $this._Cancel()
                return $true
            }
            'p' {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::None) {
                    $this._CyclePriority()
                    return $true
                }
            }
            'P' {
                $this._CyclePriority()
                return $true
            }
        }
        
        # Handle special keys
        switch ($keyInfo.Key) {
            ([ConsoleKey]::Escape) {
                $this._Cancel()
                return $true
            }
            ([ConsoleKey]::Tab) {
                $this._NextFocus()
                return $true
            }
            ([ConsoleKey]::Enter) {
                if ($this._focusIndex -eq 2) {
                    $this._SaveTask()
                    return $true
                }
            }
        }
        
        # Let base class handle remaining input
        return ([Screen]$this).HandleInput($keyInfo)
    }
}


class ConfirmDialog : Screen {
    hidden [Panel] $_mainPanel
    hidden [LabelComponent] $_messageLabel
    hidden [ButtonComponent] $_yesButton
    hidden [ButtonComponent] $_noButton
    
    [string]$Title = "Confirm"
    [string]$Message = "Are you sure?"
    [scriptblock]$OnConfirm = {}
    [scriptblock]$OnCancel = {}
    
    ConfirmDialog([object]$serviceContainer) : base("ConfirmDialog", $serviceContainer) {
        $this.IsOverlay = $true
    }
    
    [void] Initialize() {
        # Create centered dialog
        $dialogWidth = 50
        $dialogHeight = 10
        $dialogX = [Math]::Floor(($this.Width - $dialogWidth) / 2)
        $dialogY = [Math]::Floor(($this.Height - $dialogHeight) / 2)
        
        $this._mainPanel = [Panel]::new("ConfirmMain")
        $this._mainPanel.X = $dialogX
        $this._mainPanel.Y = $dialogY
        $this._mainPanel.Width = $dialogWidth
        $this._mainPanel.Height = $dialogHeight
        $this._mainPanel.Title = " $($this.Title) "
        $this._mainPanel.BorderStyle = "Double"
        $this._mainPanel.BorderColor = Get-ThemeColor "warning" "#FFA500"
        $this._mainPanel.BackgroundColor = Get-ThemeColor "dialog.bg" "#0A0A0A"
        $this.AddChild($this._mainPanel)
        
        # Message
        $lines = $this.Message -split "`n"
        $y = 2
        foreach ($line in $lines) {
            if ($y -ge $dialogHeight - 3) { break }
            $msgLabel = [LabelComponent]::new("Message$y")
            $msgLabel.X = 2
            $msgLabel.Y = $y
            $msgLabel.Text = $line
            $msgLabel.ForegroundColor = Get-ThemeColor "text" "#E0E0E0"
            $this._mainPanel.AddChild($msgLabel)
            $y++
        }
        
        # Buttons
        $buttonY = $dialogHeight - 2
        $thisDialog = $this
        
        $this._yesButton = [ButtonComponent]::new("YesButton")
        $this._yesButton.Text = "[Y]es"
        $this._yesButton.X = [Math]::Floor($dialogWidth / 2) - 8
        $this._yesButton.Y = $buttonY
        $this._yesButton.Width = 7
        $this._yesButton.Height = 1
        $this._yesButton.OnClick = {
            if ($thisDialog.OnConfirm) {
                & $thisDialog.OnConfirm
            }
            $navService = $thisDialog.ServiceContainer?.GetService("NavigationService")
            if ($navService -and $navService.CanGoBack()) {
                $navService.GoBack()
            }
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._yesButton)
        
        $this._noButton = [ButtonComponent]::new("NoButton")
        $this._noButton.Text = "[N]o"
        $this._noButton.X = [Math]::Floor($dialogWidth / 2) + 2
        $this._noButton.Y = $buttonY
        $this._noButton.Width = 6
        $this._noButton.Height = 1
        $this._noButton.OnClick = {
            if ($thisDialog.OnCancel) {
                & $thisDialog.OnCancel
            }
            $navService = $thisDialog.ServiceContainer?.GetService("NavigationService")
            if ($navService -and $navService.CanGoBack()) {
                $navService.GoBack()
            }
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._noButton)
    }
    
    [void] OnEnter() {
        $focusManager = $this.ServiceContainer?.GetService("FocusManager")
        if ($focusManager) {
            $focusManager.SetFocus($this._noButton)
        }
        $this.RequestRedraw()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($null -eq $keyInfo) { return $false }
        
        switch ($keyInfo.KeyChar) {
            'y' {
                $this._yesButton.OnClick.Invoke()
                return $true
            }
            'Y' {
                $this._yesButton.OnClick.Invoke()
                return $true
            }
            'n' {
                $this._noButton.OnClick.Invoke()
                return $true
            }
            'N' {
                $this._noButton.OnClick.Invoke()
                return $true
            }
        }
        
        if ($keyInfo.Key -eq [ConsoleKey]::Escape) {
            $this._noButton.OnClick.Invoke()
            return $true
        }
        
        return ([Screen]$this).HandleInput($keyInfo)
    }
}

#endregion

class ThemePickerScreen : Screen {
    hidden [ScrollablePanel] $_themePanel
    hidden [Panel] $_mainPanel
    hidden [array] $_themes
    hidden [int] $_selectedIndex = 0
    hidden $_themeManager  # Remove type annotation since ThemeManager is defined later
    hidden [string] $_originalTheme  # Store original theme to restore on cancel
    
    ThemePickerScreen([object]$serviceContainer) : base("ThemePickerScreen", $serviceContainer) {}
    
    [void] Initialize() {
        # Get theme manager
        $this._themeManager = $this.ServiceContainer?.GetService("ThemeManager")
        if (-not $this._themeManager) {
            # Write-Verbose "ThemePickerScreen: ThemeManager not found"
            return
        }
        
        # Get available themes
        $this._themes = $this._themeManager.GetAvailableThemes()
        # Write-Verbose "ThemePickerScreen: Found $($this._themes.Count) themes: $($this._themes -join ', ')"
        
        # Store original theme
        $this._originalTheme = $this._themeManager.ThemeName
        
        # Main panel
        $this._mainPanel = [Panel]::new("Theme Selector")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = "Select Theme"
        $this.AddChild($this._mainPanel)
        
        # Instructions
        $instructionLabel = [LabelComponent]::new("Instructions")
        $instructionLabel.Text = "Use Up/Down to navigate, Enter to select theme, Esc to cancel"
        $instructionLabel.X = 2
        $instructionLabel.Y = 2
        $instructionLabel.Width = [Math]::Min(60, $this.Width - 4)
        $instructionLabel.Height = 1
        $instructionLabel.ForegroundColor = Get-ThemeColor -ColorName "Subtle" -DefaultColor "#808080"
        $this._mainPanel.AddChild($instructionLabel)
        
        # Theme scrollable panel
        $panelWidth = [Math]::Min(60, $this.Width - 10)
        $panelHeight = [Math]::Min(20, $this.Height - 8)
        $panelX = [Math]::Floor(($this.Width - $panelWidth) / 2)
        
        $this._themePanel = [ScrollablePanel]::new("ThemeList")
        $this._themePanel.X = $panelX
        $this._themePanel.Y = 4
        $this._themePanel.Width = $panelWidth
        $this._themePanel.Height = $panelHeight
        $this._themePanel.Title = "Available Themes"
        $this._themePanel.ShowScrollbar = $true
        $this._mainPanel.AddChild($this._themePanel)
        
        # Find current theme index
        $currentTheme = $this._themeManager.ThemeName
        $selectedIdx = 0
        for ($i = 0; $i -lt $this._themes.Count; $i++) {
            if ($this._themes[$i] -eq $currentTheme) {
                $selectedIdx = $i
                break
            }
        }
        $this._selectedIndex = $selectedIdx
        
        # Update display
        $this._UpdateThemeList()
    }
    
    hidden [void] _UpdateThemeList() {
        # Clear the panel
        $this._themePanel.Children.Clear()
        
        # Add theme items
        for ($i = 0; $i -lt $this._themes.Count; $i++) {
            $themeName = $this._themes[$i]
            $isSelected = ($i -eq $this._selectedIndex)
            
            # Create panel for each theme item
            $itemPanel = [Panel]::new("ThemeItem_$i")
            $itemPanel.X = 0
            $itemPanel.Y = $i
            $itemPanel.Width = $this._themePanel.ContentWidth
            $itemPanel.Height = 1
            $itemPanel.HasBorder = $false
            
            # Set background based on selection
            $itemPanel.BackgroundColor = if ($isSelected) { 
                Get-ThemeColor -ColorName "list.item.selected.background" -DefaultColor "#0000FF" 
            } else { 
                Get-ThemeColor -ColorName "Background" -DefaultColor "#000000" 
            }
            
            # Create label for theme name
            $themeLabel = [LabelComponent]::new("ThemeLabel_$i")
            $themeLabel.X = 2
            $themeLabel.Y = 0
            $themeLabel.Width = $itemPanel.Width - 4
            $themeLabel.Height = 1
            
            # Format display text
            $indicator = if ($isSelected) { "> " } else { "  " }
            $currentMarker = if ($themeName -eq $this._originalTheme) { " (current)" } else { "" }
            $themeLabel.Text = "$indicator$themeName$currentMarker"
            
            # Set text color based on selection
            $themeLabel.ForegroundColor = if ($isSelected) { 
                Get-ThemeColor -ColorName "list.item.selected" -DefaultColor "#FFFFFF" 
            } else { 
                Get-ThemeColor -ColorName "list.item.normal" -DefaultColor "#C0C0C0" 
            }
            
            $itemPanel.AddChild($themeLabel)
            $this._themePanel.AddChild($itemPanel)
        }
        
        # Ensure selected item is visible
        if ($this._selectedIndex -lt $this._themePanel.ScrollOffsetY) {
            $this._themePanel.ScrollOffsetY = $this._selectedIndex
        } elseif ($this._selectedIndex -ge ($this._themePanel.ScrollOffsetY + $this._themePanel.ContentHeight)) {
            $this._themePanel.ScrollOffsetY = $this._selectedIndex - $this._themePanel.ContentHeight + 1
        }
        
        $this._themePanel.RequestRedraw()
    }
    
    [void] OnEnter() {
        # Following Rule 2.3: Set initial focus for input to work
        $focusManager = $this.ServiceContainer?.GetService("FocusManager")
        if ($focusManager) {
            $focusManager.SetFocus($this) # Focus the screen itself since it handles input
        }
        $this.RequestRedraw()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this._selectedIndex -gt 0) {
                    $this._selectedIndex--
                    if ($this._selectedIndex -lt $this._themePanel.ScrollOffsetY) {
                        $this._themePanel.ScrollUp()
                    }
                    $this._UpdateThemeList()
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this._selectedIndex -lt $this._themes.Count - 1) {
                    $this._selectedIndex++
                    $visibleEnd = $this._themePanel.ScrollOffsetY + $this._themePanel.ContentHeight - 1
                    if ($this._selectedIndex -gt $visibleEnd) {
                        $this._themePanel.ScrollDown()
                    }
                    $this._UpdateThemeList()
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                # Apply selected theme
                if ($this._selectedIndex -ge 0 -and $this._selectedIndex -lt $this._themes.Count) {
                    $selectedTheme = $this._themes[$this._selectedIndex]
                    $this._themeManager.LoadTheme($selectedTheme)
                    # Write-Verbose "Applied theme: $selectedTheme"
                    
                    # Publish theme change event
                    $eventManager = $this.ServiceContainer?.GetService("EventManager")
                    if ($eventManager) {
                        $eventManager.Publish("Theme.Changed", @{ Theme = $selectedTheme })
                    }
                    
                    # Go back
                    $navService = $this.ServiceContainer?.GetService("NavigationService")
                    if ($navService -and $navService.CanGoBack()) {
                        $navService.GoBack()
                    }
                }
                return $true
            }
            ([ConsoleKey]::Escape) {
                # Restore original theme and cancel
                $this._themeManager.LoadTheme($this._originalTheme)
                
                $navService = $this.ServiceContainer?.GetService("NavigationService")
                if ($navService -and $navService.CanGoBack()) {
                    $navService.GoBack()
                }
                return $true
            }
            ([ConsoleKey]::Home) {
                $this._selectedIndex = 0
                $this._themePanel.ScrollToTop()
                $this._UpdateThemeList()
                return $true
            }
            ([ConsoleKey]::End) {
                $this._selectedIndex = $this._themes.Count - 1
                $this._themePanel.ScrollToBottom()
                $this._UpdateThemeList()
                return $true
            }
            default {
                # Unhandled key
                return $false
            }
        }
        return $false
    }
}



####\Screens\ASC.003_ScreenUtilities.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Screens (Load After Components)
# Application screens that extend Screen base class
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASC.###" to find specific sections.
# Each section ends with "END_PAGE: ASC.###"
# ==============================================================================

using namespace System.Collections.Generic

#region Screen Utilities

# ==============================================================================
# CommandPaletteScreen - Full screen command palette
# ==============================================================================
class CommandPaletteScreen : Screen {
    hidden [Panel] $_mainPanel
    hidden [TextBoxComponent] $_searchBox
    hidden [ListBox] $_listBox
    hidden [List[object]] $_allActions
    hidden [List[object]] $_filteredActions
    
    CommandPaletteScreen([object]$serviceContainer) : base("CommandPaletteScreen", $serviceContainer) {
        $this._allActions = [List[object]]::new()
        $this._filteredActions = [List[object]]::new()
    }
    
    [void] Initialize() {
        if (-not $this.ServiceContainer) { return }
        
        # Main panel
        $this._mainPanel = [Panel]::new("CommandPalettePanel")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.Title = " Command Palette "
        $this.AddChild($this._mainPanel)
        
        # Search box
        $this._searchBox = [TextBoxComponent]::new("SearchBox")
        $this._searchBox.X = 2
        $this._searchBox.Y = 2
        $this._searchBox.Width = $this.Width - 4
        $this._searchBox.Height = 1
        $this._searchBox.Placeholder = "Type to search commands... (Esc to cancel)"
        $this._searchBox.IsFocusable = $true
        $this._searchBox.Enabled = $true
        
        $thisScreen = $this
        $this._searchBox.OnChange = {
            param($sender, $text)
            $thisScreen.FilterActions($text)
        }.GetNewClosure()
        $this._mainPanel.AddChild($this._searchBox)
        
        # List box for results
        $this._listBox = [ListBox]::new("ActionList")
        $this._listBox.X = 2
        $this._listBox.Y = 4
        $this._listBox.Width = $this.Width - 4
        $this._listBox.Height = $this.Height - 7
        $this._mainPanel.AddChild($this._listBox)
        
        # Help text
        $helpText = [LabelComponent]::new("HelpText")
        $helpText.Text = "Enter: Execute | Tab: Toggle Focus | Esc: Cancel"
        $helpText.X = 2
        $helpText.Y = $this.Height - 2
        $helpText.ForegroundColor = Get-ThemeColor -ColorName "Subtle"
        $this._mainPanel.AddChild($helpText)
    }
    
    [void] OnEnter() {
        # Load all actions
        $actionService = $this.ServiceContainer?.GetService("ActionService")
        if ($actionService) {
            $this._allActions.Clear()
            $allActions = $actionService.GetAllActions()
            foreach ($actionEntry in $allActions.GetEnumerator()) {
                $actionData = $actionEntry.Value
                $this._allActions.Add([PSCustomObject]@{
                    Name = $actionEntry.Key
                    Description = $actionData.Description
                    Category = $actionData.Category
                    Hotkey = $actionData.Hotkey
                })
            }
        }
        
        # Show all actions initially
        $this.FilterActions("")
        
        # Set focus to search box
        $focusManager = $this.ServiceContainer?.GetService("FocusManager")
        if ($focusManager -and $this._searchBox) {
            $focusManager.SetFocus($this._searchBox)
        }
        
        $this.RequestRedraw()
    }
    
    [void] FilterActions([string]$searchText) {
        $this._filteredActions.Clear()
        $this._listBox.ClearItems()
        
        $actionsToDisplay = if ([string]::IsNullOrWhiteSpace($searchText)) {
            $this._allActions
        } else {
            $searchLower = $searchText.ToLower()
            @($this._allActions | Where-Object {
                $_.Name.ToLower().Contains($searchLower) -or
                ($_.Description -and $_.Description.ToLower().Contains($searchLower)) -or
                ($_.Category -and $_.Category.ToLower().Contains($searchLower))
            })
        }
        
        foreach ($action in $actionsToDisplay) {
            $this._filteredActions.Add($action)
            $displayText = if ($action.Category) {
                "[$($action.Category)] $($action.Name)"
            } else {
                $action.Name
            }
            if ($action.Description) {
                $displayText += " - $($action.Description)"
            }
            $this._listBox.AddItem($displayText)
        }
        
        if ($this._filteredActions.Count -gt 0) {
            $this._listBox.SelectedIndex = 0
        }
        $this.RequestRedraw()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        $focusManager = $this.ServiceContainer?.GetService("FocusManager")
        $focusedComponent = if ($focusManager) { $focusManager.FocusedComponent } else { $null }
        
        switch ($keyInfo.Key) {
            ([ConsoleKey]::Escape) {
                # Go back
                $navService = $this.ServiceContainer?.GetService("NavigationService")
                if ($navService -and $navService.CanGoBack()) {
                    $navService.GoBack()
                }
                return $true
            }
            ([ConsoleKey]::Tab) {
                # Toggle focus between search and list
                if ($focusManager) {
                    if ($focusedComponent -eq $this._searchBox) {
                        $focusManager.SetFocus($this._listBox)
                    } else {
                        $focusManager.SetFocus($this._searchBox)
                    }
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                # Execute selected action if list has focus
                if ($focusedComponent -eq $this._listBox) {
                    if ($this._listBox.SelectedIndex -ge 0 -and $this._listBox.SelectedIndex -lt $this._filteredActions.Count) {
                        $selectedAction = $this._filteredActions[$this._listBox.SelectedIndex]
                        if ($selectedAction) {
                            $actionService = $this.ServiceContainer?.GetService("ActionService")
                            if ($actionService) {
                                # Go back first
                                $navService = $this.ServiceContainer?.GetService("NavigationService")
                                if ($navService -and $navService.CanGoBack()) {
                                    $navService.GoBack()
                                }
                                # Then execute action
                                $actionService.ExecuteAction($selectedAction.Name, @{})
                            }
                        }
                    }
                    return $true
                }
                return $false
            }
            ([ConsoleKey]::UpArrow) {
                # Move focus to list if on search box
                if ($focusedComponent -eq $this._searchBox -and $this._filteredActions.Count -gt 0) {
                    $focusManager.SetFocus($this._listBox)
                    return $this._listBox.HandleInput($keyInfo)
                }
                return $false
            }
            ([ConsoleKey]::DownArrow) {
                # Move focus to list if on search box
                if ($focusedComponent -eq $this._searchBox -and $this._filteredActions.Count -gt 0) {
                    $focusManager.SetFocus($this._listBox)
                    return $this._listBox.HandleInput($keyInfo)
                }
                return $false
            }
        }
        
        return $false
    }
}

#endregion
#<!-- END_PAGE: ASC.003 -->



####\Screens\ASC.003_ThemeScreen.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Theme Selection Screen - FIXED VERSION
# ==============================================================================

class ThemeScreen : Screen {
    # UI Components
    hidden [Panel]$_mainPanel
    hidden [ListBox]$_themeList
    hidden [Panel]$_previewPanel
    hidden [LabelComponent]$_titleLabel
    hidden [LabelComponent]$_descriptionLabel
    hidden [LabelComponent]$_statusLabel
    hidden [LabelComponent]$_previewTextLabel
    hidden [LabelComponent]$_previewButtonLabel
    hidden [LabelComponent]$_previewListLabel
    
    # Available themes with hex colors
    hidden [hashtable[]]$_themes = @(
        @{
            Name = "Default"
            Description = "Classic terminal colors with blue accents"
            Colors = @{
                "Background" = "#000000"
                "Foreground" = "#C0C0C0"
                "Primary" = "#0000FF"
                "Secondary" = "#000080"
                "Accent" = "#00FFFF"
                "Success" = "#00FF00"
                "Warning" = "#FFFF00"
                "Error" = "#FF0000"
                "Info" = "#00FFFF"
                "component.background" = "#000000"
                "component.border" = "#808080"
                "component.title" = "#00FFFF"
                "button.focused.fg" = "#FFFFFF"
                "button.focused.bg" = "#0000FF"
                "list.item.selected" = "#FFFFFF"
                "list.item.selected.background" = "#000080"
            }
        }
        @{
            Name = "Green Console"
            Description = "Classic green phosphor terminal look"
            Colors = @{
                "Background" = "#000000"
                "Foreground" = "#00FF00"
                "Primary" = "#00FF00"
                "Secondary" = "#008000"
                "Accent" = "#00FF00"
                "Success" = "#00FF00"
                "Warning" = "#FFFF00"
                "Error" = "#FF0000"
                "Info" = "#00FF00"
                "component.background" = "#000000"
                "component.border" = "#008000"
                "component.title" = "#00FF00"
                "button.focused.fg" = "#000000"
                "button.focused.bg" = "#00FF00"
                "list.item.selected" = "#000000"
                "list.item.selected.background" = "#00FF00"
            }
        }
        @{
            Name = "Amber Console"
            Description = "Warm amber monochrome terminal"
            Colors = @{
                "Background" = "#000000"
                "Foreground" = "#FFFF00"
                "Primary" = "#FFFF00"
                "Secondary" = "#808000"
                "Accent" = "#FFFF00"
                "Success" = "#00FF00"
                "Warning" = "#FFFF00"
                "Error" = "#FF0000"
                "Info" = "#FFFF00"
                "component.background" = "#000000"
                "component.border" = "#808000"
                "component.title" = "#FFFF00"
                "button.focused.fg" = "#000000"
                "button.focused.bg" = "#FFFF00"
                "list.item.selected" = "#000000"
                "list.item.selected.background" = "#FFFF00"
            }
        }
        @{
            Name = "Notepad Style"
            Description = "Clean white background with black text"
            Colors = @{
                "Background" = "#FFFFFF"
                "Foreground" = "#000000"
                "Primary" = "#000080"
                "Secondary" = "#C0C0C0"
                "Accent" = "#0000FF"
                "Success" = "#008000"
                "Warning" = "#808000"
                "Error" = "#800000"
                "Info" = "#008080"
                "component.background" = "#FFFFFF"
                "component.border" = "#808080"
                "component.title" = "#000080"
                "button.focused.fg" = "#FFFFFF"
                "button.focused.bg" = "#000080"
                "list.item.selected" = "#FFFFFF"
                "list.item.selected.background" = "#0000FF"
            }
        }
    )
    
    ThemeScreen([ServiceContainer]$container) : base("ThemeScreen", $container) {
    }
    
    [void] Initialize() {
        # Main panel
        $this._mainPanel = [Panel]::new("ThemeScreen_MainPanel")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.HasBorder = $true
        $this._mainPanel.BorderStyle = "Single"
        $this._mainPanel.Title = " Theme Selection "
        $this.AddChild($this._mainPanel)
        
        # Title
        $this._titleLabel = [LabelComponent]::new("ThemeScreen_Title")
        $this._titleLabel.Text = "Select a Theme"
        $this._titleLabel.X = 2
        $this._titleLabel.Y = 1
        $this._titleLabel.ForegroundColor = Get-ThemeColor "Primary"
        $this._mainPanel.AddChild($this._titleLabel)
        
        # Theme list - fixed width
        $this._themeList = [ListBox]::new("ThemeScreen_List")
        $this._themeList.X = 2
        $this._themeList.Y = 3
        $this._themeList.Width = 30  # Fixed width
        $this._themeList.Height = $this._mainPanel.Height - 8
        $this._themeList.HasBorder = $true
        $this._themeList.BorderStyle = "Single"
        $this._themeList.Title = " Themes "
        $this._themeList.IsFocusable = $true
        $this._mainPanel.AddChild($this._themeList)
        
        # Preview panel - rest of the width
        $previewX = $this._themeList.X + $this._themeList.Width + 2
        $this._previewPanel = [Panel]::new("ThemeScreen_Preview")
        $this._previewPanel.X = $previewX
        $this._previewPanel.Y = 3
        $this._previewPanel.Width = $this._mainPanel.Width - $previewX - 2
        $this._previewPanel.Height = $this._mainPanel.Height - 8
        $this._previewPanel.HasBorder = $true
        $this._previewPanel.BorderStyle = "Single"
        $this._previewPanel.Title = " Preview "
        $this._mainPanel.AddChild($this._previewPanel)
        
        # Description in preview
        $this._descriptionLabel = [LabelComponent]::new("ThemeScreen_Description")
        $this._descriptionLabel.X = 2
        $this._descriptionLabel.Y = 1
        $this._descriptionLabel.Width = $this._previewPanel.Width - 4
        $this._descriptionLabel.Text = ""
        $this._previewPanel.AddChild($this._descriptionLabel)
        
        # Preview elements - static labels showing theme colors
        $y = 3
        
        # Text preview
        $this._previewTextLabel = [LabelComponent]::new("Preview_Text")
        $this._previewTextLabel.Text = "Sample Text (Foreground Color)"
        $this._previewTextLabel.X = 2
        $this._previewTextLabel.Y = $y
        $this._previewPanel.AddChild($this._previewTextLabel)
        $y += 2
        
        # Button preview
        $this._previewButtonLabel = [LabelComponent]::new("Preview_Button")
        $this._previewButtonLabel.Text = "[ Sample Button (Focused) ]"
        $this._previewButtonLabel.X = 2
        $this._previewButtonLabel.Y = $y
        $this._previewPanel.AddChild($this._previewButtonLabel)
        $y += 2
        
        # List preview
        $this._previewListLabel = [LabelComponent]::new("Preview_List")
        $this._previewListLabel.Text = "> Selected List Item <"
        $this._previewListLabel.X = 2
        $this._previewListLabel.Y = $y
        $this._previewPanel.AddChild($this._previewListLabel)
        
        # Status label - positioned correctly
        $statusY = $this._mainPanel.Height - 3
        $this._statusLabel = [LabelComponent]::new("ThemeScreen_Status")
        $this._statusLabel.Text = "Use ↑↓ to navigate, Enter to apply theme, Escape to go back"
        $this._statusLabel.X = 2
        $this._statusLabel.Y = $statusY
        $this._statusLabel.ForegroundColor = Get-ThemeColor "Info"
        $this._mainPanel.AddChild($this._statusLabel)
        
        # Populate themes
        $this.PopulateThemeList()
        
        # Selection change handler
        $thisScreen = $this
        $this._themeList.SelectedIndexChanged = {
            param($sender, $index)
            $thisScreen.UpdatePreview()
        }
        
        # Set focus
        $focusManager = $this.ServiceContainer.GetService("FocusManager")
        if ($focusManager) {
            $focusManager.SetFocus($this._themeList)
        }
    }
    
    hidden [void] PopulateThemeList() {
        $this._themeList.ClearItems()
        foreach ($theme in $this._themes) {
            $this._themeList.AddItem($theme.Name)
        }
        $this._themeList.SelectedIndex = 0
        $this.UpdatePreview()
    }
    
    hidden [void] UpdatePreview() {
        if ($this._themeList.SelectedIndex -ge 0 -and $this._themeList.SelectedIndex -lt $this._themes.Count) {
            $selectedTheme = $this._themes[$this._themeList.SelectedIndex]
            
            # Update description
            $this._descriptionLabel.Text = $selectedTheme.Description
            
            # Update preview colors
            $this._previewTextLabel.ForegroundColor = $selectedTheme.Colors["Foreground"]
            $this._previewButtonLabel.ForegroundColor = $selectedTheme.Colors["button.focused.fg"]
            $this._previewButtonLabel.BackgroundColor = $selectedTheme.Colors["button.focused.bg"]
            $this._previewListLabel.ForegroundColor = $selectedTheme.Colors["list.item.selected"]
            $this._previewListLabel.BackgroundColor = $selectedTheme.Colors["list.item.selected.background"]
            
            $this.RequestRedraw()
        }
    }
    
    hidden [void] ApplySelectedTheme() {
        if ($this._themeList.SelectedIndex -ge 0 -and $this._themeList.SelectedIndex -lt $this._themes.Count) {
            $selectedTheme = $this._themes[$this._themeList.SelectedIndex]
            $themeManager = $this.ServiceContainer.GetService("ThemeManager")
            
            if ($themeManager) {
                # Apply all colors
                foreach ($colorKey in $selectedTheme.Colors.Keys) {
                    $themeManager.SetColor($colorKey, $selectedTheme.Colors[$colorKey])
                }
                
                $themeManager.ThemeName = $selectedTheme.Name
                $global:TuiState.IsDirty = $true
                
                # Show confirmation
                $this._statusLabel.Text = "Theme '$($selectedTheme.Name)' applied!"
                $this._statusLabel.ForegroundColor = Get-ThemeColor "Success"
                $this.RequestRedraw()
                
                # Force immediate redraw
                if ($global:TuiState.RenderEngine) {
                    $global:TuiState.RenderEngine.Render()
                }
                
                # Return after delay
                Start-Sleep -Milliseconds 1500
                $navService = $this.ServiceContainer.GetService("NavigationService")
                if ($navService) {
                    $navService.GoBack()
                }
            }
        }
    }
    
    [void] OnEnter() {
        ([Screen]$this).OnEnter()
        $this.UpdatePreview()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        switch ($key.Key) {
            ([ConsoleKey]::Escape) {
                $navService = $this.ServiceContainer.GetService("NavigationService")
                if ($navService) { $navService.GoBack() }
                return $true
            }
            ([ConsoleKey]::Enter) {
                $this.ApplySelectedTheme()
                return $true
            }
        }
        
        return ([Screen]$this).HandleInput($key)
    }
}



####\Screens\ASC.004_NewTaskScreen.ps1
# ===== CLASS: NewTaskScreen =====
# Purpose: Full screen for creating new tasks
class NewTaskScreen : Screen {
    hidden [Panel]$_formPanel
    hidden [TextBoxComponent]$_titleBox
    hidden [TextBoxComponent]$_descriptionBox
    hidden [ListBox]$_priorityList
    hidden [ListBox]$_projectList
    hidden [LabelComponent]$_statusLabel
    
    NewTaskScreen([object]$serviceContainer) : base("NewTaskScreen", $serviceContainer) {}
    
    [void] Initialize() {
        # Main form panel - full screen
        $this._formPanel = [Panel]::new("NewTaskForm")
        $this._formPanel.X = 0
        $this._formPanel.Y = 0
        $this._formPanel.Width = $this.Width
        $this._formPanel.Height = $this.Height
        $this._formPanel.Title = " New Task "
        $this._formPanel.BorderStyle = "Double"
        $this._formPanel.BorderColor = Get-ThemeColor "Primary"
        $this._formPanel.BackgroundColor = Get-ThemeColor "Background"
        $this.AddChild($this._formPanel)
        
        # Use generous spacing - we have the room!
        $leftMargin = 5
        $topMargin = 3
        $componentSpacing = 2  # Space between label and input
        $sectionSpacing = 6    # Space between sections
        $contentWidth = [Math]::Min(100, $this._formPanel.Width - ($leftMargin * 2))
        
        # Title Section
        $y = $topMargin
        $titleLabel = [LabelComponent]::new("TitleLabel")
        $titleLabel.Text = "Task Title:"
        $titleLabel.X = $leftMargin
        $titleLabel.Y = $y
        $titleLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($titleLabel)
        
        $y += $componentSpacing
        $this._titleBox = [TextBoxComponent]::new("TitleInput")
        $this._titleBox.X = $leftMargin
        $this._titleBox.Y = $y
        $this._titleBox.Width = $contentWidth
        $this._titleBox.Height = 3
        $this._titleBox.Placeholder = "Enter task title..."
        $this._titleBox.IsFocusable = $true
        $this._formPanel.AddChild($this._titleBox)
        
        # Description Section - with proper spacing
        $y += $this._titleBox.Height + $sectionSpacing
        $descLabel = [LabelComponent]::new("DescLabel")
        $descLabel.Text = "Description:"
        $descLabel.X = $leftMargin
        $descLabel.Y = $y
        $descLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($descLabel)
        
        $y += $componentSpacing
        $this._descriptionBox = [TextBoxComponent]::new("DescInput")
        $this._descriptionBox.X = $leftMargin
        $this._descriptionBox.Y = $y
        $this._descriptionBox.Width = $contentWidth
        $this._descriptionBox.Height = 3
        $this._descriptionBox.Placeholder = "Enter description..."
        $this._descriptionBox.IsFocusable = $true
        $this._formPanel.AddChild($this._descriptionBox)
        
        # Priority and Project side by side
        $y += $this._descriptionBox.Height + $sectionSpacing
        $halfWidth = [Math]::Floor($contentWidth / 2) - 2
        
        # Priority
        $priorityLabel = [LabelComponent]::new("PriorityLabel")
        $priorityLabel.Text = "Priority:"
        $priorityLabel.X = $leftMargin
        $priorityLabel.Y = $y
        $priorityLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($priorityLabel)
        
        $this._priorityList = [ListBox]::new("PriorityList")
        $this._priorityList.X = $leftMargin
        $this._priorityList.Y = $y + $componentSpacing
        $this._priorityList.Width = $halfWidth
        $this._priorityList.Height = 5
        $this._priorityList.HasBorder = $true
        $this._priorityList.BorderStyle = "Single"
        $this._priorityList.AddItem("Low")
        $this._priorityList.AddItem("Medium")
        $this._priorityList.AddItem("High")
        $this._priorityList.SelectedIndex = 1
        $this._priorityList.IsFocusable = $true
        $this._formPanel.AddChild($this._priorityList)
        
        # Project - with more spacing between columns
        $projectX = $leftMargin + $halfWidth + 8
        $projectLabel = [LabelComponent]::new("ProjectLabel")
        $projectLabel.Text = "Project:"
        $projectLabel.X = $projectX
        $projectLabel.Y = $y
        $projectLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($projectLabel)
        
        $this._projectList = [ListBox]::new("ProjectList")
        $this._projectList.X = $projectX
        $this._projectList.Y = $y + $componentSpacing
        $this._projectList.Width = $halfWidth
        $this._projectList.Height = 5
        $this._projectList.HasBorder = $true
        $this._projectList.BorderStyle = "Single"
        $this._projectList.AddItem("General")
        $this._projectList.SelectedIndex = 0
        $this._projectList.IsFocusable = $true
        $this._formPanel.AddChild($this._projectList)
        
        # Status and instructions at bottom - with proper spacing from form elements
        $bottomMargin = 3
        $y = $this._formPanel.Height - ($bottomMargin + 3)  # 3 lines for status and instructions
        
        $this._statusLabel = [LabelComponent]::new("StatusLabel")
        $this._statusLabel.X = $leftMargin
        $this._statusLabel.Y = $y
        $this._statusLabel.Text = "Ready to create task"
        $this._statusLabel.ForegroundColor = Get-ThemeColor "Info"
        $this._formPanel.AddChild($this._statusLabel)
        
        $instructLabel = [LabelComponent]::new("InstructLabel")
        $instructLabel.X = $leftMargin
        $instructLabel.Y = $y + 2
        $instructLabel.Text = "Tab: Next field | Ctrl+S: Save | ESC: Cancel"
        $instructLabel.ForegroundColor = Get-ThemeColor "Subtle"
        $this._formPanel.AddChild($instructLabel)
    }
    
    [void] OnEnter() {
        # Load projects
        $dataManager = $this.Services.DataManager
        $projects = $dataManager.GetProjects()
        
        $this._projectList.ClearItems()
        $this._projectList.AddItem("General")
        foreach ($project in $projects) {
            $this._projectList.AddItem($project.Name)
        }
        $this._projectList.SelectedIndex = 0
        
        # Set initial focus
        $focusManager = $this.Services.FocusManager
        $focusManager.SetFocus($this._titleBox)
    }
    
    [void] OnExit() {
        # Unregister temporary action
        $actionService = $this.Services.ActionService
        $actionService.UnregisterAction("task.save.current")
    }
    
    [void] SaveTask() {
        # Validate input
        if ([string]::IsNullOrWhiteSpace($this._titleBox.Text)) {
            $this._statusLabel.Text = "Error: Title is required"
            $this._statusLabel.ForegroundColor = Get-ThemeColor "Error"
            return
        }
        
        # Create new task
        $task = [PmcTask]::new()
        $task.Title = $this._titleBox.Text
        $task.Description = $this._descriptionBox.Text
        
        # Set priority
        $priorityMap = @{
            0 = [TaskPriority]::Low
            1 = [TaskPriority]::Medium  
            2 = [TaskPriority]::High
        }
        $task.Priority = $priorityMap[$this._priorityList.SelectedIndex]
        
        # Set project
        if ($this._projectList.SelectedIndex -gt 0) {
            $dataManager = $this.Services.DataManager
            $projects = $dataManager.GetProjects()
            if (($this._projectList.SelectedIndex - 1) -lt $projects.Count) {
                $task.ProjectKey = $projects[$this._projectList.SelectedIndex - 1].Key
            }
        }
        
        # Save task
        try {
            $dataManager = $this.Services.DataManager
            $dataManager.AddTask($task)
            $dataManager.SaveData()  # Force save to disk
            
            $this._statusLabel.Text = "Task created successfully!"
            $this._statusLabel.ForegroundColor = Get-ThemeColor "Success"
            
            # Navigate back after short delay
            Start-Sleep -Milliseconds 500
            $navService = $this.Services.NavigationService
            $navService.GoBack()
        }
        catch {
            $this._statusLabel.Text = "Error: $($_.Exception.Message)"
            $this._statusLabel.ForegroundColor = Get-ThemeColor "Error"
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($null -eq $keyInfo) { return $false }
        
        # Handle ESC to cancel
        if ($keyInfo.Key -eq [ConsoleKey]::Escape) {
            $navService = $this.Services.NavigationService
            $navService.GoBack()
            return $true
        }
        
        # Handle Ctrl+S to save
        if ($keyInfo.Key -eq [ConsoleKey]::S -and ($keyInfo.Modifiers -band [ConsoleModifiers]::Control)) {
            $this.SaveTask()
            return $true
        }
        
        # Let base handle focus navigation
        return ([Screen]$this).HandleInput($keyInfo)
    }
}



####\Screens\ASC.005_EditTaskScreen.ps1
# ===== CLASS: EditTaskScreen =====
# Purpose: Full screen for editing existing tasks
class EditTaskScreen : Screen {
    hidden [Panel]$_formPanel
    hidden [SidebarMenu]$_menu
    hidden [TextBoxComponent]$_titleBox
    hidden [TextBoxComponent]$_descriptionBox
    hidden [ListBox]$_priorityList
    hidden [ListBox]$_statusList
    hidden [ListBox]$_projectList
    hidden [TextBoxComponent]$_progressBox
    hidden [ButtonComponent]$_saveButton
    hidden [ButtonComponent]$_cancelButton
    hidden [LabelComponent]$_statusLabel
    hidden [PmcTask]$_task
    
    EditTaskScreen([object]$serviceContainer, [PmcTask]$task) : base("EditTaskScreen", $serviceContainer) {
        $this._task = $task
    }
    
    [void] Initialize() {
        # Create menu
        $this._menu = [SidebarMenu]::new("MainMenu")
        $this._menu.X = 0
        $this._menu.Y = 0
        $this._menu.Height = $this.Height
        $this._menu.Width = 22
        $this._menu.Title = "Navigation"
        
        $this._menu.AddMenuItem("1", "Dashboard", "navigation.dashboard")
        $this._menu.AddMenuItem("2", "Task List", "navigation.taskList")
        $this._menu.AddMenuItem("-", "", "")
        $this._menu.AddMenuItem("S", "Save Changes", "task.save.current")
        $this._menu.AddMenuItem("C", "Cancel", "navigation.back")
        $this._menu.AddMenuItem("-", "", "")
        $this._menu.AddMenuItem("Q", "Quit", "app.exit")
        
        $this.AddChild($this._menu)
        
        # Create form panel
        $this._formPanel = [Panel]::new("EditTaskForm")
        $this._formPanel.X = 23
        $this._formPanel.Y = 0
        $this._formPanel.Width = $this.Width - 24
        $this._formPanel.Height = $this.Height
        $this._formPanel.Title = "Edit Task"
        $this._formPanel.BorderStyle = "Double"
        $this.AddChild($this._formPanel)
        
        # Title input
        $titleLabel = [LabelComponent]::new("TitleLabel")
        $titleLabel.Text = "Task Title:"
        $titleLabel.X = 2
        $titleLabel.Y = 2
        $this._formPanel.AddChild($titleLabel)
        
        $this._titleBox = [TextBoxComponent]::new("TitleInput")
        $this._titleBox.X = 2
        $this._titleBox.Y = 3
        $this._titleBox.Width = $this._formPanel.Width - 6
        $this._titleBox.Text = $this._task.Title
        $this._titleBox.IsFocusable = $true
        $this._formPanel.AddChild($this._titleBox)
        
        # Description input
        $descLabel = [LabelComponent]::new("DescLabel")
        $descLabel.Text = "Description:"
        $descLabel.X = 2
        $descLabel.Y = 5
        $this._formPanel.AddChild($descLabel)
        
        $this._descriptionBox = [TextBoxComponent]::new("DescInput")
        $this._descriptionBox.X = 2
        $this._descriptionBox.Y = 6
        $this._descriptionBox.Width = $this._formPanel.Width - 6
        $this._descriptionBox.Text = $this._task.Description
        $this._descriptionBox.IsFocusable = $true
        $this._formPanel.AddChild($this._descriptionBox)
        
        # Status selection
        $statusLabel = [LabelComponent]::new("StatusLabel")
        $statusLabel.Text = "Status:"
        $statusLabel.X = 2
        $statusLabel.Y = 8
        $this._formPanel.AddChild($statusLabel)
        
        $this._statusList = [ListBox]::new("StatusList")
        $this._statusList.X = 2
        $this._statusList.Y = 9
        $this._statusList.Width = 15
        $this._statusList.Height = 6
        $this._statusList.AddItem("Pending")
        $this._statusList.AddItem("InProgress")
        $this._statusList.AddItem("Completed")
        $this._statusList.AddItem("Cancelled")
        $this._statusList.SelectedIndex = [int]$this._task.Status
        $this._statusList.IsFocusable = $true
        $this._formPanel.AddChild($this._statusList)
        
        # Priority selection
        $priorityLabel = [LabelComponent]::new("PriorityLabel")
        $priorityLabel.Text = "Priority:"
        $priorityLabel.X = 20
        $priorityLabel.Y = 8
        $this._formPanel.AddChild($priorityLabel)
        
        $this._priorityList = [ListBox]::new("PriorityList")
        $this._priorityList.X = 20
        $this._priorityList.Y = 9
        $this._priorityList.Width = 12
        $this._priorityList.Height = 5
        $this._priorityList.AddItem("Low")
        $this._priorityList.AddItem("Medium")
        $this._priorityList.AddItem("High")
        $this._priorityList.SelectedIndex = [int]$this._task.Priority
        $this._priorityList.IsFocusable = $true
        $this._formPanel.AddChild($this._priorityList)
        
        # Progress input
        $progressLabel = [LabelComponent]::new("ProgressLabel")
        $progressLabel.Text = "Progress (%):"
        $progressLabel.X = 35
        $progressLabel.Y = 8
        $this._formPanel.AddChild($progressLabel)
        
        $this._progressBox = [TextBoxComponent]::new("ProgressInput")
        $this._progressBox.X = 35
        $this._progressBox.Y = 9
        $this._progressBox.Width = 10
        $this._progressBox.Text = $this._task.Progress.ToString()
        $this._progressBox.MaxLength = 3
        $this._progressBox.IsFocusable = $true
        $this._formPanel.AddChild($this._progressBox)
        
        # Project selection
        $projectLabel = [LabelComponent]::new("ProjectLabel")
        $projectLabel.Text = "Project:"
        $projectLabel.X = 2
        $projectLabel.Y = 15
        $this._formPanel.AddChild($projectLabel)
        
        $this._projectList = [ListBox]::new("ProjectList")
        $this._projectList.X = 2
        $this._projectList.Y = 16
        $this._projectList.Width = 30
        $this._projectList.Height = 4
        $this._projectList.AddItem("None")
        $this._projectList.IsFocusable = $true
        $this._formPanel.AddChild($this._projectList)
        
        # Status label
        $this._statusLabel = [LabelComponent]::new("StatusMessageLabel")
        $this._statusLabel.X = 2
        $this._statusLabel.Y = 21
        $this._statusLabel.Text = "Ready to save changes"
        $this._statusLabel.ForegroundColor = (Get-ThemeColor "Info")
        $this._formPanel.AddChild($this._statusLabel)
        
        # Buttons
        $this._saveButton = [ButtonComponent]::new("SaveButton")
        $this._saveButton.Text = "Save (S)"
        $this._saveButton.X = 2
        $this._saveButton.Y = 23
        $this._saveButton.IsFocusable = $true
        $this._saveButton.OnClick = {
            $this.SaveTask()
        }.GetNewClosure()
        $this._formPanel.AddChild($this._saveButton)
        
        $this._cancelButton = [ButtonComponent]::new("CancelButton")
        $this._cancelButton.Text = "Cancel (C)"
        $this._cancelButton.X = 15
        $this._cancelButton.Y = 23
        $this._cancelButton.IsFocusable = $true
        $this._cancelButton.OnClick = {
            $navService = $this.Services.NavigationService
            $navService.GoBack()
        }.GetNewClosure()
        $this._formPanel.AddChild($this._cancelButton)
    }
    
    [void] OnEnter() {
        # Load projects
        $dataManager = $this.Services.DataManager
        $projects = $dataManager.GetProjects()
        
        $this._projectList.ClearItems()
        $this._projectList.AddItem("None")
        $selectedIndex = 0
        $i = 1
        foreach ($project in $projects) {
            $this._projectList.AddItem($project.Name)
            if ($project.Key -eq $this._task.ProjectKey) {
                $selectedIndex = $i
            }
            $i++
        }
        $this._projectList.SelectedIndex = $selectedIndex
        
        # Set initial focus
        $focusManager = $this.Services.FocusManager
        $focusManager.SetFocus($this._titleBox)
        
        # Register save action
        $actionService = $this.Services.ActionService
        $actionService.RegisterAction("task.save.current", {
            $currentScreen = $global:TuiState.CurrentScreen
            if ($currentScreen -is [EditTaskScreen]) {
                $currentScreen.SaveTask()
            }
        }, @{ Category = "Tasks"; Description = "Save current task" })
    }
    
    [void] OnExit() {
        # Unregister temporary action
        $actionService = $this.Services.ActionService
        $actionService.UnregisterAction("task.save.current")
    }
    
    [void] SaveTask() {
        # Validate input
        if ([string]::IsNullOrWhiteSpace($this._titleBox.Text)) {
            $this._statusLabel.Text = "Error: Title is required"
            $this._statusLabel.ForegroundColor = (Get-ThemeColor "Error")
            return
        }
        
        # Validate progress
        $progress = 0
        if (-not [int]::TryParse($this._progressBox.Text, [ref]$progress) -or $progress -lt 0 -or $progress -gt 100) {
            $this._statusLabel.Text = "Error: Progress must be 0-100"
            $this._statusLabel.ForegroundColor = (Get-ThemeColor "Error")
            return
        }
        
        # Update task
        $this._task.Title = $this._titleBox.Text
        $this._task.Description = $this._descriptionBox.Text
        $this._task.Status = [TaskStatus]$this._statusList.SelectedIndex
        $this._task.Priority = [TaskPriority]$this._priorityList.SelectedIndex
        $this._task.SetProgress($progress)
        
        # Set project
        if ($this._projectList.SelectedIndex -eq 0) {
            $this._task.ProjectKey = $null
        } else {
            $dataManager = $this.Services.DataManager
            $projects = $dataManager.GetProjects()
            if ($this._projectList.SelectedIndex -le $projects.Count) {
                $this._task.ProjectKey = $projects[$this._projectList.SelectedIndex - 1].Key
            }
        }
        
        # Save task
        try {
            $dataManager = $this.Services.DataManager
            $dataManager.UpdateTask($this._task)
            
            $this._statusLabel.Text = "Task updated successfully!"
            $this._statusLabel.ForegroundColor = (Get-ThemeColor "Success")
            
            # Navigate back after short delay
            Start-Sleep -Milliseconds 500
            $navService = $this.Services.NavigationService
            $navService.GoBack()
        }
        catch {
            $this._statusLabel.Text = "Error: $($_.Exception.Message)"
            $this._statusLabel.ForegroundColor = (Get-ThemeColor "Error")
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Let menu handle its keys first
        if ($this._menu.HandleKey($keyInfo)) {
            return $true
        }
        
        # Handle form-specific keys
        switch ($keyInfo.Key) {
            ([ConsoleKey]::S) {
                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::Control) {
                    $this.SaveTask()
                    return $true
                }
                break
            }
            ([ConsoleKey]::Escape) {
                $navService = $this.Services.NavigationService
                $navService.GoBack()
                return $true
            }
        }
        
        # Let base handle focus navigation
        return ([Screen]$this).HandleInput($keyInfo)
    }
}



####\Screens\ASC.005_FileCommanderScreen.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - File Commander - Full-Featured Terminal File Browser
# Built on Axiom-Phoenix v4.0 Framework
# ==============================================================================

class FileCommanderScreen : Screen {
    #region UI Components
    hidden [Panel] $_mainPanel
    hidden [Panel] $_leftPanel
    hidden [Panel] $_rightPanel
    hidden [Panel] $_functionBar
    hidden [Panel] $_statusBar
    hidden [Panel] $_quickViewPanel
    hidden [ListBox] $_leftFileList
    hidden [ListBox] $_rightFileList
    hidden [TextBoxComponent] $_commandLine
    hidden [LabelComponent] $_leftPathLabel
    hidden [LabelComponent] $_rightPathLabel
    hidden [LabelComponent] $_statusLabel
    hidden [LabelComponent] $_sizeLabel
    hidden [LabelComponent] $_itemCountLabel
    #endregion

    #region State
    hidden [string] $_leftPath
    hidden [string] $_rightPath
    hidden [bool] $_leftPanelActive = $true
    hidden [System.IO.FileSystemInfo[]] $_leftItems = @()
    hidden [System.IO.FileSystemInfo[]] $_rightItems = @()
    hidden [System.IO.FileSystemInfo] $_selectedItem
    hidden [hashtable] $_fileTypeIcons = @{
        ".ps1" = "🔧"
        ".txt" = "📄"
        ".md" = "📝"
        ".json" = "📊"
        ".xml" = "📋"
        ".exe" = "⚡"
        ".dll" = "📦"
        ".zip" = "🗜️"
        ".7z" = "🗜️"
        ".rar" = "🗜️"
        ".jpg" = "🖼️"
        ".png" = "🖼️"
        ".gif" = "🖼️"
        ".mp3" = "🎵"
        ".mp4" = "🎬"
        ".avi" = "🎬"
        ".mkv" = "🎬"
        ".pdf" = "📕"
        ".doc" = "📘"
        ".docx" = "📘"
        ".xls" = "📗"
        ".xlsx" = "📗"
        "folder" = "📁"
        "folderup" = "📂"
        "default" = "📄"
    }
    hidden [bool] $_showHidden = $false
    hidden [string] $_sortBy = "Name"  # Name, Size, Date, Extension
    hidden [bool] $_sortDescending = $false
    hidden [System.Collections.Generic.List[string]] $_clipboard = [System.Collections.Generic.List[string]]::new()
    hidden [bool] $_cutMode = $false  # false = copy, true = cut
    hidden [string] $_quickFilter = ""
    #endregion

    FileCommanderScreen([ServiceContainer]$container) : base("FileCommanderScreen", $container) {
        # Initialize paths
        $this._leftPath = [Environment]::GetFolderPath([Environment+SpecialFolder]::UserProfile)
        $this._rightPath = [Environment]::GetFolderPath([Environment+SpecialFolder]::MyDocuments)
    }

    [void] Initialize() {
        # Main panel
        $this._mainPanel = [Panel]::new("FileCommanderMain")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.HasBorder = $false
        $this._mainPanel.BackgroundColor = Get-ThemeColor "background" "#0A0A0A"
        $this.AddChild($this._mainPanel)

        # Calculate panel dimensions
        $halfWidth = [Math]::Floor($this.Width / 2)
        $panelHeight = $this.Height - 4  # Leave room for function bar and status bar

        # Left file panel
        $this._leftPanel = [Panel]::new("LeftPanel")
        $this._leftPanel.X = 0
        $this._leftPanel.Y = 0
        $this._leftPanel.Width = $halfWidth
        $this._leftPanel.Height = $panelHeight
        $this._leftPanel.HasBorder = $true
        $this._leftPanel.BorderStyle = "Single"
        $this._leftPanel.BorderColor = Get-ThemeColor "border.active" "#00D4FF"
        $this._mainPanel.AddChild($this._leftPanel)

        # Left path label
        $this._leftPathLabel = [LabelComponent]::new("LeftPath")
        $this._leftPathLabel.X = 1
        $this._leftPathLabel.Y = 0
        $this._leftPathLabel.Width = $halfWidth - 2
        $this._leftPathLabel.Height = 1
        $this._leftPathLabel.ForegroundColor = Get-ThemeColor "path" "#FFD700"
        $this._leftPathLabel.BackgroundColor = Get-ThemeColor "panel.header" "#1A1A1A"
        $this._leftPanel.AddChild($this._leftPathLabel)

        # Left file list
        $this._leftFileList = [ListBox]::new("LeftFiles")
        $this._leftFileList.X = 1
        $this._leftFileList.Y = 1
        $this._leftFileList.Width = $halfWidth - 2
        $this._leftFileList.Height = $panelHeight - 2
        $this._leftFileList.HasBorder = $false
        $this._leftFileList.SelectedBackgroundColor = Get-ThemeColor "selection.active" "#0066CC"
        $this._leftFileList.SelectedForegroundColor = Get-ThemeColor "selection.text" "#FFFFFF"
        $this._leftFileList.ItemForegroundColor = Get-ThemeColor "file.normal" "#E0E0E0"
        $this._leftPanel.AddChild($this._leftFileList)

        # Right file panel
        $this._rightPanel = [Panel]::new("RightPanel")
        $this._rightPanel.X = $halfWidth
        $this._rightPanel.Y = 0
        $this._rightPanel.Width = $this.Width - $halfWidth
        $this._rightPanel.Height = $panelHeight
        $this._rightPanel.HasBorder = $true
        $this._rightPanel.BorderStyle = "Single"
        $this._rightPanel.BorderColor = Get-ThemeColor "border.inactive" "#666666"
        $this._mainPanel.AddChild($this._rightPanel)

        # Right path label
        $this._rightPathLabel = [LabelComponent]::new("RightPath")
        $this._rightPathLabel.X = 1
        $this._rightPathLabel.Y = 0
        $this._rightPathLabel.Width = $this._rightPanel.Width - 2
        $this._rightPathLabel.Height = 1
        $this._rightPathLabel.ForegroundColor = Get-ThemeColor "path" "#FFD700"
        $this._rightPathLabel.BackgroundColor = Get-ThemeColor "panel.header" "#1A1A1A"
        $this._rightPanel.AddChild($this._rightPathLabel)

        # Right file list
        $this._rightFileList = [ListBox]::new("RightFiles")
        $this._rightFileList.X = 1
        $this._rightFileList.Y = 1
        $this._rightFileList.Width = $this._rightPanel.Width - 2
        $this._rightFileList.Height = $panelHeight - 2
        $this._rightFileList.HasBorder = $false
        $this._rightFileList.SelectedBackgroundColor = Get-ThemeColor "selection.inactive" "#404040"
        $this._rightFileList.SelectedForegroundColor = Get-ThemeColor "selection.text" "#FFFFFF"
        $this._rightFileList.ItemForegroundColor = Get-ThemeColor "file.normal" "#E0E0E0"
        $this._rightPanel.AddChild($this._rightFileList)

        # Status bar
        $this._statusBar = [Panel]::new("StatusBar")
        $this._statusBar.X = 0
        $this._statusBar.Y = $panelHeight
        $this._statusBar.Width = $this.Width
        $this._statusBar.Height = 2
        $this._statusBar.HasBorder = $false
        $this._statusBar.BackgroundColor = Get-ThemeColor "statusbar.bg" "#1A1A1A"
        $this._mainPanel.AddChild($this._statusBar)

        # Status label
        $this._statusLabel = [LabelComponent]::new("Status")
        $this._statusLabel.X = 1
        $this._statusLabel.Y = 0
        $this._statusLabel.Width = 60
        $this._statusLabel.Height = 1
        $this._statusLabel.ForegroundColor = Get-ThemeColor "status.text" "#00FF88"
        $this._statusBar.AddChild($this._statusLabel)

        # Size label
        $this._sizeLabel = [LabelComponent]::new("Size")
        $this._sizeLabel.X = 62
        $this._sizeLabel.Y = 0
        $this._sizeLabel.Width = 20
        $this._sizeLabel.Height = 1
        $this._sizeLabel.ForegroundColor = Get-ThemeColor "size.text" "#FFD700"
        $this._statusBar.AddChild($this._sizeLabel)

        # Item count label
        $this._itemCountLabel = [LabelComponent]::new("ItemCount")
        $this._itemCountLabel.X = $this.Width - 25
        $this._itemCountLabel.Y = 0
        $this._itemCountLabel.Width = 24
        $this._itemCountLabel.Height = 1
        $this._itemCountLabel.ForegroundColor = Get-ThemeColor "count.text" "#00D4FF"
        $this._statusBar.AddChild($this._itemCountLabel)

        # Function key bar
        $this._functionBar = [Panel]::new("FunctionBar")
        $this._functionBar.X = 0
        $this._functionBar.Y = $this.Height - 2
        $this._functionBar.Width = $this.Width
        $this._functionBar.Height = 2
        $this._functionBar.HasBorder = $false
        $this._functionBar.BackgroundColor = Get-ThemeColor "function.bg" "#0D47A1"
        $this._mainPanel.AddChild($this._functionBar)

        # Function key labels
        $functions = @(
            @{Key="F1"; Text="Help"; X=0},
            @{Key="F2"; Text="Menu"; X=10},
            @{Key="F3"; Text="View"; X=20},
            @{Key="F4"; Text="Edit"; X=30},
            @{Key="F5"; Text="Copy"; X=40},
            @{Key="F6"; Text="Move"; X=50},
            @{Key="F7"; Text="MkDir"; X=60},
            @{Key="F8"; Text="Delete"; X=70},
            @{Key="F9"; Text="Menu"; X=80},
            @{Key="F10"; Text="Quit"; X=90}
        )

        foreach ($func in $functions) {
            $keyLabel = [LabelComponent]::new("F$($func.Key)")
            $keyLabel.X = $func.X
            $keyLabel.Y = 0
            $keyLabel.Width = 9
            $keyLabel.Height = 1
            $keyLabel.Text = "$($func.Key):$($func.Text)"
            $keyLabel.ForegroundColor = Get-ThemeColor "function.text" "#FFFFFF"
            $keyLabel.BackgroundColor = Get-ThemeColor "function.key.bg" "#1976D2"
            $this._functionBar.AddChild($keyLabel)
        }

        # Set up event handlers
        $this.SetupEventHandlers()
        
        # Initial load
        $this.RefreshPanels()
    }

    hidden [void] SetupEventHandlers() {
        $thisScreen = $this
        
        # Left panel selection change
        $this._leftFileList.SelectedIndexChanged = {
            param($sender, $index)
            if ($thisScreen._leftPanelActive -and $index -ge 0 -and $index -lt $thisScreen._leftItems.Count) {
                $thisScreen._selectedItem = $thisScreen._leftItems[$index]
                $thisScreen.UpdateStatusBar()
            }
        }

        # Right panel selection change
        $this._rightFileList.SelectedIndexChanged = {
            param($sender, $index)
            if (-not $thisScreen._leftPanelActive -and $index -ge 0 -and $index -lt $thisScreen._rightItems.Count) {
                $thisScreen._selectedItem = $thisScreen._rightItems[$index]
                $thisScreen.UpdateStatusBar()
            }
        }
    }

    hidden [void] RefreshPanels() {
        $this.LoadDirectory($this._leftPath, $true)
        $this.LoadDirectory($this._rightPath, $false)
        $this.UpdatePathLabels()
        $this.UpdateStatusBar()
    }

    hidden [void] LoadDirectory([string]$path, [bool]$isLeftPanel) {
        try {
            # Get items
            $items = @()
            
            # Add parent directory if not at root
            $parentDir = Split-Path $path -Parent
            if ($parentDir) {
                $parentItem = [PSCustomObject]@{
                    PSTypeName = 'System.IO.DirectoryInfo'
                    Name = ".."
                    FullName = $parentDir
                    Length = 0
                    LastWriteTime = $null
                    Attributes = [System.IO.FileAttributes]::Directory
                }
                $items += $parentItem
            }

            # Get directories and files
            $getChildParams = @{
                Path = $path
                Force = $this._showHidden
            }
            
            $allItems = Get-ChildItem @getChildParams -ErrorAction SilentlyContinue
            
            # Separate directories and files
            $dirs = @($allItems | Where-Object { $_.PSIsContainer })
            $files = @($allItems | Where-Object { -not $_.PSIsContainer })
            
            # Sort items
            switch ($this._sortBy) {
                "Name" {
                    $dirs = $dirs | Sort-Object Name -Descending:$this._sortDescending
                    $files = $files | Sort-Object Name -Descending:$this._sortDescending
                }
                "Size" {
                    $dirs = $dirs | Sort-Object Name -Descending:$this._sortDescending
                    $files = $files | Sort-Object Length -Descending:$this._sortDescending
                }
                "Date" {
                    $dirs = $dirs | Sort-Object LastWriteTime -Descending:$this._sortDescending
                    $files = $files | Sort-Object LastWriteTime -Descending:$this._sortDescending
                }
                "Extension" {
                    $dirs = $dirs | Sort-Object Name -Descending:$this._sortDescending
                    $files = $files | Sort-Object Extension -Descending:$this._sortDescending
                }
            }
            
            # Combine directories first, then files
            $items += $dirs
            $items += $files
            
            # Apply quick filter if set
            if ($this._quickFilter) {
                $items = $items | Where-Object { $_.Name -like "*$($this._quickFilter)*" }
            }
            
            # Update the appropriate panel
            if ($isLeftPanel) {
                $this._leftItems = $items
                $this._leftFileList.ClearItems()
                foreach ($item in $items) {
                    $this._leftFileList.AddItem($this.FormatFileItem($item))
                }
                if ($items.Count -gt 0) {
                    $this._leftFileList.SelectedIndex = 0
                }
            } else {
                $this._rightItems = $items
                $this._rightFileList.ClearItems()
                foreach ($item in $items) {
                    $this._rightFileList.AddItem($this.FormatFileItem($item))
                }
                if ($items.Count -gt 0) {
                    $this._rightFileList.SelectedIndex = 0
                }
            }
            
        } catch {
            Write-Log -Level Error -Message "Failed to load directory '$path': $_"
        }
    }

    hidden [string] FormatFileItem([System.IO.FileSystemInfo]$item) {
        # Special case for parent directory
        if ($item.Name -eq "..") {
            return "📂 .."
        }
        
        # Get icon
        $icon = ""
        if ($item.PSIsContainer -or $item.Attributes -band [System.IO.FileAttributes]::Directory) {
            $icon = $this._fileTypeIcons["folder"]
        } else {
            $ext = [System.IO.Path]::GetExtension($item.Name).ToLower()
            if ($this._fileTypeIcons.ContainsKey($ext)) {
                $icon = $this._fileTypeIcons[$ext]
            } else {
                $icon = $this._fileTypeIcons["default"]
            }
        }
        
        # Format name with padding
        $maxNameLength = 30
        $name = $item.Name
        if ($name.Length -gt $maxNameLength) {
            $name = $name.Substring(0, $maxNameLength - 3) + "..."
        }
        $name = $name.PadRight($maxNameLength)
        
        # Format size
        $size = ""
        if (-not ($item.PSIsContainer -or $item.Attributes -band [System.IO.FileAttributes]::Directory)) {
            $size = $this.FormatFileSize($item.Length)
        } else {
            $size = "<DIR>".PadLeft(10)
        }
        
        # Format date
        $date = ""
        if ($item.LastWriteTime) {
            $date = $item.LastWriteTime.ToString("yyyy-MM-dd HH:mm")
        }
        
        return "$icon $name $size $date"
    }

    hidden [string] FormatFileSize([long]$bytes) {
        if ($bytes -lt 1024) { return "$bytes B".PadLeft(10) }
        if ($bytes -lt 1048576) { return "$([Math]::Round($bytes/1KB, 2)) KB".PadLeft(10) }
        if ($bytes -lt 1073741824) { return "$([Math]::Round($bytes/1MB, 2)) MB".PadLeft(10) }
        return "$([Math]::Round($bytes/1GB, 2)) GB".PadLeft(10)
    }

    hidden [void] UpdatePathLabels() {
        # Truncate paths if too long
        $maxPathLength = $this._leftPanel.Width - 4
        
        $leftDisplay = $this._leftPath
        if ($leftDisplay.Length -gt $maxPathLength) {
            $leftDisplay = "..." + $leftDisplay.Substring($leftDisplay.Length - $maxPathLength + 3)
        }
        $this._leftPathLabel.Text = " $leftDisplay "
        
        $rightDisplay = $this._rightPath
        if ($rightDisplay.Length -gt $maxPathLength) {
            $rightDisplay = "..." + $rightDisplay.Substring($rightDisplay.Length - $maxPathLength + 3)
        }
        $this._rightPathLabel.Text = " $rightDisplay "
    }

    hidden [void] UpdateStatusBar() {
        if ($this._selectedItem) {
            $name = $this._selectedItem.Name
            if ($this._selectedItem.PSIsContainer -or $this._selectedItem.Attributes -band [System.IO.FileAttributes]::Directory) {
                $this._statusLabel.Text = "Directory: $name"
                $this._sizeLabel.Text = ""
            } else {
                $this._statusLabel.Text = "File: $name"
                $this._sizeLabel.Text = "Size: $($this.FormatFileSize($this._selectedItem.Length))"
            }
        }
        
        # Update item counts
        $leftCount = $this._leftItems.Count
        $rightCount = $this._rightItems.Count
        $this._itemCountLabel.Text = "L: $leftCount | R: $rightCount items"
    }

    hidden [void] NavigateToDirectory([string]$path) {
        if (Test-Path $path -PathType Container) {
            if ($this._leftPanelActive) {
                $this._leftPath = $path
                $this.LoadDirectory($path, $true)
            } else {
                $this._rightPath = $path
                $this.LoadDirectory($path, $false)
            }
            $this.UpdatePathLabels()
            $this.UpdateStatusBar()
        }
    }

    hidden [void] EnterDirectory() {
        $item = $null
        if ($this._leftPanelActive -and $this._leftFileList.SelectedIndex -ge 0) {
            $item = $this._leftItems[$this._leftFileList.SelectedIndex]
        } elseif (-not $this._leftPanelActive -and $this._rightFileList.SelectedIndex -ge 0) {
            $item = $this._rightItems[$this._rightFileList.SelectedIndex]
        }
        
        if ($item -and ($item.PSIsContainer -or $item.Attributes -band [System.IO.FileAttributes]::Directory -or $item.Name -eq "..")) {
            if ($item.Name -eq "..") {
                $this.NavigateToDirectory($item.FullName)
            } else {
                $this.NavigateToDirectory($item.FullName)
            }
        }
    }

    hidden [void] SwitchPanel() {
        $this._leftPanelActive = -not $this._leftPanelActive
        
        if ($this._leftPanelActive) {
            $this._leftPanel.BorderColor = Get-ThemeColor "border.active" "#00D4FF"
            $this._rightPanel.BorderColor = Get-ThemeColor "border.inactive" "#666666"
            $this._leftFileList.SelectedBackgroundColor = Get-ThemeColor "selection.active" "#0066CC"
            $this._rightFileList.SelectedBackgroundColor = Get-ThemeColor "selection.inactive" "#404040"
            
            # Update selected item
            if ($this._leftFileList.SelectedIndex -ge 0 -and $this._leftFileList.SelectedIndex -lt $this._leftItems.Count) {
                $this._selectedItem = $this._leftItems[$this._leftFileList.SelectedIndex]
            }
            
            # Set focus
            $focusManager = $this.ServiceContainer.GetService("FocusManager")
            if ($focusManager) {
                $focusManager.SetFocus($this._leftFileList)
            }
        } else {
            $this._leftPanel.BorderColor = Get-ThemeColor "border.inactive" "#666666"
            $this._rightPanel.BorderColor = Get-ThemeColor "border.active" "#00D4FF"
            $this._leftFileList.SelectedBackgroundColor = Get-ThemeColor "selection.inactive" "#404040"
            $this._rightFileList.SelectedBackgroundColor = Get-ThemeColor "selection.active" "#0066CC"
            
            # Update selected item
            if ($this._rightFileList.SelectedIndex -ge 0 -and $this._rightFileList.SelectedIndex -lt $this._rightItems.Count) {
                $this._selectedItem = $this._rightItems[$this._rightFileList.SelectedIndex]
            }
            
            # Set focus
            $focusManager = $this.ServiceContainer.GetService("FocusManager")
            if ($focusManager) {
                $focusManager.SetFocus($this._rightFileList)
            }
        }
        
        $this.UpdateStatusBar()
        $this.RequestRedraw()
    }

    hidden [void] CopySelectedItems() {
        $this._clipboard.Clear()
        $this._cutMode = $false
        
        if ($this._leftPanelActive -and $this._leftFileList.SelectedIndex -ge 0) {
            $item = $this._leftItems[$this._leftFileList.SelectedIndex]
            if ($item.Name -ne "..") {
                $this._clipboard.Add($item.FullName)
                $this._statusLabel.Text = "Copied: $($item.Name)"
            }
        } elseif (-not $this._leftPanelActive -and $this._rightFileList.SelectedIndex -ge 0) {
            $item = $this._rightItems[$this._rightFileList.SelectedIndex]
            if ($item.Name -ne "..") {
                $this._clipboard.Add($item.FullName)
                $this._statusLabel.Text = "Copied: $($item.Name)"
            }
        }
    }

    hidden [void] ViewFile() {
        $item = $null
        if ($this._leftPanelActive -and $this._leftFileList.SelectedIndex -ge 0) {
            $item = $this._leftItems[$this._leftFileList.SelectedIndex]
        } elseif (-not $this._leftPanelActive -and $this._rightFileList.SelectedIndex -ge 0) {
            $item = $this._rightItems[$this._rightFileList.SelectedIndex]
        }
        
        if ($item -and -not ($item.PSIsContainer -or $item.Attributes -band [System.IO.FileAttributes]::Directory) -and $item.Name -ne "..") {
            # For now, just show file info. In a full implementation, you'd create a file viewer screen
            $this._statusLabel.Text = "View: $($item.Name) (Press any key)"
        }
    }

    hidden [void] DeleteSelectedItem() {
        $item = $null
        if ($this._leftPanelActive -and $this._leftFileList.SelectedIndex -ge 0) {
            $item = $this._leftItems[$this._leftFileList.SelectedIndex]
        } elseif (-not $this._leftPanelActive -and $this._rightFileList.SelectedIndex -ge 0) {
            $item = $this._rightItems[$this._rightFileList.SelectedIndex]
        }
        
        if ($item -and $item.Name -ne "..") {
            # In a real implementation, you'd show a confirmation dialog
            $this._statusLabel.Text = "Delete: $($item.Name)? (Y/N)"
            # For now, just show the message
        }
    }

    hidden [void] CreateDirectory() {
        # In a real implementation, you'd show an input dialog
        $this._statusLabel.Text = "Create directory (not implemented)"
    }

    hidden [void] ShowHelp() {
        # In a real implementation, you'd show a help screen
        $this._statusLabel.Text = "Help: Tab=Switch, Enter=Open, F5=Copy, F8=Delete, F10=Quit"
    }

    [void] OnEnter() {
        ([Screen]$this).OnEnter()
        
        # Set initial focus
        $focusManager = $this.ServiceContainer.GetService("FocusManager")
        if ($focusManager) {
            if ($this._leftPanelActive) {
                $focusManager.SetFocus($this._leftFileList)
            } else {
                $focusManager.SetFocus($this._rightFileList)
            }
        }
    }

    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        $handled = $true
        
        switch ($key.Key) {
            # Navigation
            ([ConsoleKey]::Tab) { 
                $this.SwitchPanel()
            }
            ([ConsoleKey]::Enter) {
                $this.EnterDirectory()
            }
            ([ConsoleKey]::Backspace) {
                # Go to parent directory
                if ($this._leftPanelActive) {
                    $parent = Split-Path $this._leftPath -Parent
                    if ($parent) {
                        $this.NavigateToDirectory($parent)
                    }
                } else {
                    $parent = Split-Path $this._rightPath -Parent
                    if ($parent) {
                        $this.NavigateToDirectory($parent)
                    }
                }
            }
            
            # Function keys
            ([ConsoleKey]::F1) {
                $this.ShowHelp()
            }
            ([ConsoleKey]::F3) {
                $this.ViewFile()
            }
            ([ConsoleKey]::F5) {
                $this.CopySelectedItems()
            }
            ([ConsoleKey]::F7) {
                $this.CreateDirectory()
            }
            ([ConsoleKey]::F8) {
                $this.DeleteSelectedItem()
            }
            ([ConsoleKey]::F10) {
                # Exit
                $navService = $this.ServiceContainer.GetService("NavigationService")
                if ($navService.CanGoBack()) {
                    $navService.GoBack()
                } else {
                    $actionService = $this.ServiceContainer.GetService("ActionService")
                    if ($actionService) {
                        $actionService.ExecuteAction("app.exit", @{})
                    }
                }
            }
            ([ConsoleKey]::Escape) {
                # Go back
                $navService = $this.ServiceContainer.GetService("NavigationService")
                if ($navService.CanGoBack()) {
                    $navService.GoBack()
                }
            }
            
            # Ctrl combinations
            default {
                if ($key.Modifiers -band [ConsoleModifiers]::Control) {
                    switch ($key.Key) {
                        ([ConsoleKey]::H) {
                            # Toggle hidden files
                            $this._showHidden = -not $this._showHidden
                            $this.RefreshPanels()
                            $this._statusLabel.Text = if ($this._showHidden) { "Hidden files: ON" } else { "Hidden files: OFF" }
                        }
                        ([ConsoleKey]::R) {
                            # Refresh
                            $this.RefreshPanels()
                            $this._statusLabel.Text = "Refreshed"
                        }
                        ([ConsoleKey]::L) {
                            # Go to path (would show input dialog)
                            $this._statusLabel.Text = "Go to path (not implemented)"
                        }
                        default {
                            $handled = $false
                        }
                    }
                } else {
                    $handled = $false
                }
            }
        }
        
        # If not handled by specific keys, let focused component handle it
        if (-not $handled) {
            return ([Screen]$this).HandleInput($key)
        }
        
        return $true
    }
}



####\Screens\ASC.006_TextEditorScreen.ps1
# ==============================================================================
# High-Performance Text Editor Screen for Axiom-Phoenix
# Smooth rendering, advanced cursor movement, and incremental search
# ==============================================================================

# Text Editor Screen with optimized rendering
class TextEditorScreen : Screen {
    # Core components
    hidden [TextBuffer]$_buffer
    hidden [SearchEngine]$_searchEngine
    hidden [TextSelection]$_selection
    
    # Cursor and viewport
    hidden [int]$_cursorPosition = 0
    hidden [int]$_cursorLine = 0
    hidden [int]$_cursorColumn = 0
    hidden [int]$_viewportTop = 0
    hidden [int]$_viewportLeft = 0
    hidden [int]$_preferredColumn = 0  # For vertical movement
    
    # UI components
    hidden [Panel]$_editorPanel
    hidden [Panel]$_statusBar
    hidden [Panel]$_searchPanel
    hidden [TextBoxComponent]$_searchBox
    hidden [TextBoxComponent]$_replaceBox
    hidden [LabelComponent]$_statusLabel
    hidden [LabelComponent]$_positionLabel
    hidden [LabelComponent]$_searchStatusLabel
    
    # Rendering optimization
    hidden [hashtable]$_lineRenderCache = @{}
    hidden [int]$_lastRenderVersion = -1
    hidden [bool]$_fullRedrawNeeded = $true
    
    # Editor state
    hidden [bool]$_isSearchMode = $false
    hidden [bool]$_isReplaceMode = $false
    hidden [bool]$_isReadOnly = $false
    hidden [string]$_clipboard = ""
    
    # Undo/Redo stacks
    hidden [Stack[IEditCommand]]$_undoStack
    hidden [Stack[IEditCommand]]$_redoStack
    hidden [int]$_lastCommandGroupId = 0
    hidden [datetime]$_lastEditTime = [datetime]::MinValue
    
    # Settings
    hidden [int]$_tabSize = 4
    hidden [bool]$_showLineNumbers = $true
    hidden [int]$_lineNumberWidth = 5
    
    TextEditorScreen([ServiceContainer]$container) : base("TextEditorScreen", $container) {
        $this._buffer = [TextBuffer]::new()
        $this._searchEngine = [SearchEngine]::new($this._buffer)
        $this._selection = [TextSelection]::new()
        $this._undoStack = [Stack[IEditCommand]]::new()
        $this._redoStack = [Stack[IEditCommand]]::new()
    }
    
    [void] Initialize() {
        # Main editor panel
        $this._editorPanel = [Panel]::new("EditorPanel")
        $this._editorPanel.X = 0
        $this._editorPanel.Y = 0
        $this._editorPanel.Width = $this.Width
        $this._editorPanel.Height = $this.Height - 3  # Leave room for status bar
        $this._editorPanel.HasBorder = $false
        $this._editorPanel.BackgroundColor = Get-ThemeColor "Background"
        $this.AddChild($this._editorPanel)
        
        # Status bar
        $this._statusBar = [Panel]::new("StatusBar")
        $this._statusBar.X = 0
        $this._statusBar.Y = $this.Height - 3
        $this._statusBar.Width = $this.Width
        $this._statusBar.Height = 3
        $this._statusBar.HasBorder = $true
        $this._statusBar.BorderStyle = "Single"
        $this._statusBar.BackgroundColor = Get-ThemeColor "component.background"
        $this.AddChild($this._statusBar)
        
        # Status label
        $this._statusLabel = [LabelComponent]::new("StatusLabel")
        $this._statusLabel.X = 2
        $this._statusLabel.Y = 1
        $this._statusLabel.Text = "Ready"
        $this._statusLabel.ForegroundColor = Get-ThemeColor "Info"
        $this._statusBar.AddChild($this._statusLabel)
        
        # Position label
        $this._positionLabel = [LabelComponent]::new("PositionLabel")
        $this._positionLabel.X = $this.Width - 20
        $this._positionLabel.Y = 1
        $this._positionLabel.Text = "Ln 1, Col 1"
        $this._positionLabel.ForegroundColor = Get-ThemeColor "Subtle"
        $this._statusBar.AddChild($this._positionLabel)
        
        # Search panel (hidden by default)
        $this._searchPanel = [Panel]::new("SearchPanel")
        $this._searchPanel.X = 5
        $this._searchPanel.Y = 2
        $this._searchPanel.Width = [Math]::Min(60, $this.Width - 10)
        $this._searchPanel.Height = 6
        $this._searchPanel.HasBorder = $true
        $this._searchPanel.BorderStyle = "Double"
        $this._searchPanel.Title = " Find & Replace "
        $this._searchPanel.BackgroundColor = Get-ThemeColor "component.background"
        $this._searchPanel.Visible = $false
        $this._searchPanel.IsOverlay = $true
        $this.AddChild($this._searchPanel)
        
        # Search box
        $searchLabel = [LabelComponent]::new("SearchLabel")
        $searchLabel.X = 2
        $searchLabel.Y = 1
        $searchLabel.Text = "Find:"
        $this._searchPanel.AddChild($searchLabel)
        
        $this._searchBox = [TextBoxComponent]::new("SearchBox")
        $this._searchBox.X = 8
        $this._searchBox.Y = 1
        $this._searchBox.Width = $this._searchPanel.Width - 10
        $this._searchBox.IsFocusable = $true
        $thisEditor = $this
        $this._searchBox.OnChange = {
            param($sender, $text)
            $thisEditor.PerformIncrementalSearch()
        }.GetNewClosure()
        $this._searchPanel.AddChild($this._searchBox)
        
        # Replace box
        $replaceLabel = [LabelComponent]::new("ReplaceLabel")
        $replaceLabel.X = 2
        $replaceLabel.Y = 2
        $replaceLabel.Text = "Replace:"
        $this._searchPanel.AddChild($replaceLabel)
        
        $this._replaceBox = [TextBoxComponent]::new("ReplaceBox")
        $this._replaceBox.X = 11
        $this._replaceBox.Y = 2
        $this._replaceBox.Width = $this._searchPanel.Width - 13
        $this._replaceBox.IsFocusable = $true
        $this._searchPanel.AddChild($this._replaceBox)
        
        # Search status
        $this._searchStatusLabel = [LabelComponent]::new("SearchStatus")
        $this._searchStatusLabel.X = 2
        $this._searchStatusLabel.Y = 4
        $this._searchStatusLabel.Text = ""
        $this._searchStatusLabel.ForegroundColor = Get-ThemeColor "Info"
        $this._searchPanel.AddChild($this._searchStatusLabel)
        
        # Load some initial text for demo
        $this.LoadDemoText()
    }
    
    [void] OnEnter() {
        ([Screen]$this).OnEnter()
        $this.RequestRedraw()
        $this._fullRedrawNeeded = $true
    }
    
    # Optimized rendering
    [void] OnRender([TuiBuffer]$buffer) {
        if (-not $buffer) { return }
        
        # Clear if full redraw needed
        if ($this._fullRedrawNeeded) {
            $buffer.Clear()
            $this._lineRenderCache.Clear()
            $this._fullRedrawNeeded = $false
        }
        
        # Calculate viewport dimensions
        $editorWidth = $this._editorPanel.Width
        $editorHeight = $this._editorPanel.Height
        $contentStartX = if ($this._showLineNumbers) { $this._lineNumberWidth + 1 } else { 0 }
        $contentWidth = $editorWidth - $contentStartX
        
        # Ensure viewport is in bounds
        $this.EnsureCursorVisible()
        
        # Get dirty lines
        $dirtyLines = $this._buffer.GetAndClearDirtyLines()
        $versionChanged = $this._buffer._version -ne $this._lastRenderVersion
        
        # Render visible lines
        for ($i = 0; $i -lt $editorHeight; $i++) {
            $lineIndex = $this._viewportTop + $i
            if ($lineIndex -ge $this._buffer.LineCount) { break }
            
            # Check if line needs redraw
            $needsRedraw = $this._fullRedrawNeeded -or 
                          $versionChanged -or 
                          ($lineIndex -in $dirtyLines) -or
                          -not $this._lineRenderCache.ContainsKey($lineIndex)
            
            if ($needsRedraw) {
                $this.RenderLine($buffer, $lineIndex, $i, $contentStartX, $contentWidth)
            }
        }
        
        # Render cursor
        $this.RenderCursor($buffer)
        
        # Update last render version
        $this._lastRenderVersion = $this._buffer._version
        
        # Let base class render children (status bar, search panel)
        ([Screen]$this).OnRender($buffer)
    }
    
    hidden [void] RenderLine([TuiBuffer]$buffer, [int]$lineIndex, [int]$screenY, [int]$startX, [int]$width) {
        # Render line numbers
        if ($this._showLineNumbers) {
            $lineNumStr = ($lineIndex + 1).ToString().PadLeft($this._lineNumberWidth - 1)
            $lineNumColor = Get-ThemeColor "Subtle"
            
            for ($j = 0; $j -lt $lineNumStr.Length; $j++) {
                $buffer.SetCell($j, $screenY, 
                    [TuiCell]::new($lineNumStr[$j], $lineNumColor, Get-ThemeColor "Background"))
            }
            
            # Separator
            $buffer.SetCell($this._lineNumberWidth - 1, $screenY,
                [TuiCell]::new('│', Get-ThemeColor "component.border", Get-ThemeColor "Background"))
        }
        
        # Get line text
        $lineStart = $this._buffer.GetLineStart($lineIndex)
        $lineEnd = $this._buffer.GetLineEnd($lineIndex)
        $lineText = $this._buffer.GetLineText($lineIndex)
        
        # Apply viewport horizontal offset
        if ($this._viewportLeft -gt 0 -and $lineText.Length -gt $this._viewportLeft) {
            $lineText = $lineText.Substring($this._viewportLeft)
        } elseif ($this._viewportLeft -ge $lineText.Length) {
            $lineText = ""
        }
        
        # Render visible part of line
        $visibleLength = [Math]::Min($lineText.Length, $width)
        $normalFg = Get-ThemeColor "Foreground"
        $normalBg = Get-ThemeColor "Background"
        $selectionFg = Get-ThemeColor "list.item.selected"
        $selectionBg = Get-ThemeColor "list.item.selected.background"
        
        for ($j = 0; $j -lt $visibleLength; $j++) {
            $charPos = $lineStart + $this._viewportLeft + $j
            $char = $lineText[$j]
            
            # Handle tabs
            if ($char -eq "`t") {
                $char = ' '
            }
            
            # Check if in selection
            $fg = $normalFg
            $bg = $normalBg
            if ($this._selection.ContainsPosition($charPos)) {
                $fg = $selectionFg
                $bg = $selectionBg
            }
            
            # Check if in search result
            $searchResults = $this._searchEngine._results
            foreach ($result in $searchResults) {
                if ($charPos -ge $result.Start -and $charPos -lt ($result.Start + $result.Length)) {
                    $bg = Get-ThemeColor "Warning"
                    break
                }
            }
            
            $buffer.SetCell($startX + $j, $screenY, [TuiCell]::new($char, $fg, $bg))
        }
        
        # Clear rest of line
        for ($j = $visibleLength; $j -lt $width; $j++) {
            $buffer.SetCell($startX + $j, $screenY, [TuiCell]::new(' ', $normalFg, $normalBg))
        }
        
        # Cache rendered line
        $this._lineRenderCache[$lineIndex] = $true
    }
    
    hidden [void] RenderCursor([TuiBuffer]$buffer) {
        # Calculate cursor screen position
        $cursorScreenX = $this._cursorColumn - $this._viewportLeft
        $cursorScreenY = $this._cursorLine - $this._viewportTop
        
        if ($this._showLineNumbers) {
            $cursorScreenX += $this._lineNumberWidth + 1
        }
        
        # Ensure cursor is visible
        if ($cursorScreenX -ge 0 -and $cursorScreenX -lt $this._editorPanel.Width -and
            $cursorScreenY -ge 0 -and $cursorScreenY -lt $this._editorPanel.Height) {
            
            # Get current cell
            $cell = $buffer.GetCell($cursorScreenX, $cursorScreenY)
            if ($cell) {
                # Invert colors for cursor
                $cursorCell = [TuiCell]::new($cell.Char, 
                    Get-ThemeColor "Background", 
                    Get-ThemeColor "Foreground")
                $buffer.SetCell($cursorScreenX, $cursorScreenY, $cursorCell)
            }
        }
    }
    
    hidden [void] UpdateCursorPosition() {
        $this._cursorPosition = $this._buffer.GetCursorPosition()
        $this._cursorLine = $this._buffer.GetLineFromPosition($this._cursorPosition)
        
        # Calculate column
        $lineStart = $this._buffer.GetLineStart($this._cursorLine)
        $this._cursorColumn = $this._cursorPosition - $lineStart
        
        # Update position label
        $this._positionLabel.Text = "Ln $($this._cursorLine + 1), Col $($this._cursorColumn + 1)"
        
        # Update selection if active
        if ($this._selection.IsActive) {
            $this._selection.UpdateSelection($this._cursorPosition)
        }
    }
    
    hidden [void] EnsureCursorVisible() {
        # Vertical scrolling
        if ($this._cursorLine -lt $this._viewportTop) {
            $this._viewportTop = $this._cursorLine
            $this._fullRedrawNeeded = $true
        } elseif ($this._cursorLine -ge $this._viewportTop + $this._editorPanel.Height) {
            $this._viewportTop = $this._cursorLine - $this._editorPanel.Height + 1
            $this._fullRedrawNeeded = $true
        }
        
        # Horizontal scrolling
        $contentStartX = if ($this._showLineNumbers) { $this._lineNumberWidth + 1 } else { 0 }
        $contentWidth = $this._editorPanel.Width - $contentStartX
        
        if ($this._cursorColumn -lt $this._viewportLeft) {
            $this._viewportLeft = $this._cursorColumn
            $this._fullRedrawNeeded = $true
        } elseif ($this._cursorColumn -ge $this._viewportLeft + $contentWidth) {
            $this._viewportLeft = $this._cursorColumn - $contentWidth + 1
            $this._fullRedrawNeeded = $true
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($null -eq $keyInfo) { return $false }
        
        # Search mode input
        if ($this._isSearchMode) {
            return $this.HandleSearchInput($keyInfo)
        }
        
        # Check for modifiers
        $ctrl = ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) -ne 0
        $shift = ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift) -ne 0
        $alt = ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt) -ne 0
        
        # Handle shortcuts
        if ($ctrl) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::F) { $this.ShowSearchPanel(); return $true }
                ([ConsoleKey]::H) { $this.ShowSearchPanel($true); return $true }
                ([ConsoleKey]::G) { $this.GoToLine(); return $true }
                ([ConsoleKey]::A) { $this.SelectAll(); return $true }
                ([ConsoleKey]::C) { $this.Copy(); return $true }
                ([ConsoleKey]::X) { $this.Cut(); return $true }
                ([ConsoleKey]::V) { $this.Paste(); return $true }
                ([ConsoleKey]::Z) { $this.Undo(); return $true }
                ([ConsoleKey]::Y) { $this.Redo(); return $true }
                ([ConsoleKey]::S) { $this.Save(); return $true }
                ([ConsoleKey]::Q) { $this.Exit(); return $true }
            }
        }
        
        # Movement and selection
        $startSelection = $shift -and -not $this._selection.IsActive
        if ($startSelection) {
            $this._selection.StartSelection($this._cursorPosition)
        }
        
        $handled = $false
        
        switch ($keyInfo.Key) {
            # Basic movement
            ([ConsoleKey]::LeftArrow) {
                if ($ctrl) {
                    $this.MoveCursorToWordBoundary($false)
                } else {
                    $this.MoveCursorLeft()
                }
                $this._preferredColumn = $this._cursorColumn
                $handled = $true
            }
            ([ConsoleKey]::RightArrow) {
                if ($ctrl) {
                    $this.MoveCursorToWordBoundary($true)
                } else {
                    $this.MoveCursorRight()
                }
                $this._preferredColumn = $this._cursorColumn
                $handled = $true
            }
            ([ConsoleKey]::UpArrow) {
                $this.MoveCursorUp()
                $handled = $true
            }
            ([ConsoleKey]::DownArrow) {
                $this.MoveCursorDown()
                $handled = $true
            }
            ([ConsoleKey]::Home) {
                if ($ctrl) {
                    $this.MoveCursorToStart()
                } else {
                    $this.MoveCursorToLineStart()
                }
                $this._preferredColumn = $this._cursorColumn
                $handled = $true
            }
            ([ConsoleKey]::End) {
                if ($ctrl) {
                    $this.MoveCursorToEnd()
                } else {
                    $this.MoveCursorToLineEnd()
                }
                $this._preferredColumn = $this._cursorColumn
                $handled = $true
            }
            ([ConsoleKey]::PageUp) {
                $this.PageUp()
                $handled = $true
            }
            ([ConsoleKey]::PageDown) {
                $this.PageDown()
                $handled = $true
            }
            
            # Editing
            ([ConsoleKey]::Backspace) {
                if (-not $this._isReadOnly) {
                    $this.HandleBackspace()
                }
                $handled = $true
            }
            ([ConsoleKey]::Delete) {
                if (-not $this._isReadOnly) {
                    $this.HandleDelete()
                }
                $handled = $true
            }
            ([ConsoleKey]::Enter) {
                if (-not $this._isReadOnly) {
                    $this.HandleEnter()
                }
                $handled = $true
            }
            ([ConsoleKey]::Tab) {
                if (-not $this._isReadOnly) {
                    $this.HandleTab()
                }
                $handled = $true
            }
            ([ConsoleKey]::Escape) {
                if ($this._selection.IsActive) {
                    $this._selection.ClearSelection()
                    $this.RequestRedraw()
                } else {
                    $this.Exit()
                }
                $handled = $true
            }
            
            # Regular character input
            default {
                if (-not $ctrl -and -not $alt -and $keyInfo.KeyChar -ne 0 -and -not $this._isReadOnly) {
                    $this.InsertChar($keyInfo.KeyChar)
                    $handled = $true
                }
            }
        }
        
        # Update selection after movement
        if ($shift -and $handled) {
            $this._selection.UpdateSelection($this._cursorPosition)
        } elseif (-not $shift -and $this._selection.IsActive -and $handled) {
            $this._selection.ClearSelection()
        }
        
        # Update cursor and redraw
        if ($handled) {
            $this.UpdateCursorPosition()
            $this.RequestRedraw()
        }
        
        return $handled
    }
    
    # Movement methods
    hidden [void] MoveCursorLeft() {
        if ($this._cursorPosition -gt 0) {
            $this._buffer.SetCursorPosition($this._cursorPosition - 1)
        }
    }
    
    hidden [void] MoveCursorRight() {
        if ($this._cursorPosition -lt $this._buffer.Length) {
            $this._buffer.SetCursorPosition($this._cursorPosition + 1)
        }
    }
    
    hidden [void] MoveCursorUp() {
        if ($this._cursorLine -gt 0) {
            $newLine = $this._cursorLine - 1
            $lineStart = $this._buffer.GetLineStart($newLine)
            $lineLength = $this._buffer.GetLineEnd($newLine) - $lineStart
            $newColumn = [Math]::Min($this._preferredColumn, $lineLength)
            $this._buffer.SetCursorPosition($lineStart + $newColumn)
        }
    }
    
    hidden [void] MoveCursorDown() {
        if ($this._cursorLine -lt $this._buffer.LineCount - 1) {
            $newLine = $this._cursorLine + 1
            $lineStart = $this._buffer.GetLineStart($newLine)
            $lineLength = $this._buffer.GetLineEnd($newLine) - $lineStart
            $newColumn = [Math]::Min($this._preferredColumn, $lineLength)
            $this._buffer.SetCursorPosition($lineStart + $newColumn)
        }
    }
    
    hidden [void] MoveCursorToLineStart() {
        $lineStart = $this._buffer.GetLineStart($this._cursorLine)
        $lineText = $this._buffer.GetLineText($this._cursorLine)
        
        # Smart home - toggle between start and first non-whitespace
        $firstNonWhitespace = 0
        for ($i = 0; $i -lt $lineText.Length; $i++) {
            if (-not [char]::IsWhiteSpace($lineText[$i])) {
                $firstNonWhitespace = $i
                break
            }
        }
        
        if ($this._cursorColumn -eq $firstNonWhitespace) {
            $this._buffer.SetCursorPosition($lineStart)
        } else {
            $this._buffer.SetCursorPosition($lineStart + $firstNonWhitespace)
        }
    }
    
    hidden [void] MoveCursorToLineEnd() {
        $lineEnd = $this._buffer.GetLineEnd($this._cursorLine)
        $this._buffer.SetCursorPosition($lineEnd)
    }
    
    hidden [void] MoveCursorToStart() {
        $this._buffer.SetCursorPosition(0)
    }
    
    hidden [void] MoveCursorToEnd() {
        $this._buffer.SetCursorPosition($this._buffer.Length)
    }
    
    hidden [void] MoveCursorToWordBoundary([bool]$forward) {
        $newPos = $this._buffer.FindNextWordBoundary($this._cursorPosition, $forward)
        $this._buffer.SetCursorPosition($newPos)
    }
    
    hidden [void] PageUp() {
        $pageSize = [Math]::Max(1, $this._editorPanel.Height - 2)
        $this._viewportTop = [Math]::Max(0, $this._viewportTop - $pageSize)
        
        if ($this._cursorLine -ge $this._viewportTop + $this._editorPanel.Height) {
            $newLine = $this._viewportTop + $this._editorPanel.Height - 1
            $lineStart = $this._buffer.GetLineStart($newLine)
            $this._buffer.SetCursorPosition($lineStart + [Math]::Min($this._preferredColumn, 
                $this._buffer.GetLineEnd($newLine) - $lineStart))
        }
        
        $this._fullRedrawNeeded = $true
    }
    
    hidden [void] PageDown() {
        $pageSize = [Math]::Max(1, $this._editorPanel.Height - 2)
        $maxViewportTop = [Math]::Max(0, $this._buffer.LineCount - $this._editorPanel.Height)
        $this._viewportTop = [Math]::Min($maxViewportTop, $this._viewportTop + $pageSize)
        
        if ($this._cursorLine -lt $this._viewportTop) {
            $newLine = $this._viewportTop
            $lineStart = $this._buffer.GetLineStart($newLine)
            $this._buffer.SetCursorPosition($lineStart + [Math]::Min($this._preferredColumn, 
                $this._buffer.GetLineEnd($newLine) - $lineStart))
        }
        
        $this._fullRedrawNeeded = $true
    }
    
    # Editing methods
    hidden [void] InsertChar([char]$char) {
        $this.DeleteSelection()
        
        # Group rapid typing into single undo command
        $now = [datetime]::Now
        $timeSinceLastEdit = ($now - $this._lastEditTime).TotalMilliseconds
        
        if ($timeSinceLastEdit -gt 1000) {
            $this._lastCommandGroupId++
        }
        
        $cmd = [InsertCommand]::new($this._cursorPosition, $char.ToString(), $this._cursorPosition)
        $this.ExecuteCommand($cmd)
        
        $this._lastEditTime = $now
    }
    
    hidden [void] HandleBackspace() {
        if ($this._selection.IsActive) {
            $this.DeleteSelection()
        } else {
            if ($this._buffer.DeleteBackward()) {
                $this._redoStack.Clear()
            }
        }
    }
    
    hidden [void] HandleDelete() {
        if ($this._selection.IsActive) {
            $this.DeleteSelection()
        } else {
            if ($this._buffer.DeleteForward()) {
                $this._redoStack.Clear()
            }
        }
    }
    
    hidden [void] HandleEnter() {
        $this.DeleteSelection()
        
        # Get current line indentation
        $lineText = $this._buffer.GetLineText($this._cursorLine)
        $indent = ""
        for ($i = 0; $i -lt $lineText.Length; $i++) {
            if ($lineText[$i] -eq ' ' -or $lineText[$i] -eq "`t") {
                $indent += $lineText[$i]
            } else {
                break
            }
        }
        
        # Insert newline and indent
        $cmd = [InsertCommand]::new($this._cursorPosition, "`n$indent", $this._cursorPosition)
        $this.ExecuteCommand($cmd)
    }
    
    hidden [void] HandleTab() {
        $this.DeleteSelection()
        
        # Insert spaces for tab
        $spaces = " " * $this._tabSize
        $cmd = [InsertCommand]::new($this._cursorPosition, $spaces, $this._cursorPosition)
        $this.ExecuteCommand($cmd)
    }
    
    hidden [bool] DeleteSelection() {
        if (-not $this._selection.IsActive) { return $false }
        
        $start = $this._selection.GetNormalizedStart()
        $length = $this._selection.GetLength()
        
        if ($length -gt 0) {
            $deletedText = $this._buffer.GetText($start, $length)
            $cmd = [DeleteCommand]::new($start, $length, $deletedText, $this._cursorPosition)
            $this.ExecuteCommand($cmd)
            
            $this._buffer.SetCursorPosition($start)
            $this._selection.ClearSelection()
            return $true
        }
        
        return $false
    }
    
    # Command execution
    hidden [void] ExecuteCommand([IEditCommand]$cmd) {
        $cmd.Execute($this._buffer)
        $this._undoStack.Push($cmd)
        $this._redoStack.Clear()
    }
    
    # Clipboard operations
    hidden [void] Copy() {
        if ($this._selection.IsActive) {
            $start = $this._selection.GetNormalizedStart()
            $length = $this._selection.GetLength()
            $this._clipboard = $this._buffer.GetText($start, $length)
            $this._statusLabel.Text = "Copied $length characters"
        }
    }
    
    hidden [void] Cut() {
        if ($this._selection.IsActive -and -not $this._isReadOnly) {
            $this.Copy()
            $this.DeleteSelection()
        }
    }
    
    hidden [void] Paste() {
        if (-not [string]::IsNullOrEmpty($this._clipboard) -and -not $this._isReadOnly) {
            $this.DeleteSelection()
            $cmd = [InsertCommand]::new($this._cursorPosition, $this._clipboard, $this._cursorPosition)
            $this.ExecuteCommand($cmd)
        }
    }
    
    hidden [void] SelectAll() {
        $this._selection.StartSelection(0)
        $this._selection.UpdateSelection($this._buffer.Length)
        $this._buffer.SetCursorPosition($this._buffer.Length)
        $this.UpdateCursorPosition()
        $this.RequestRedraw()
    }
    
    # Undo/Redo
    hidden [void] Undo() {
        if ($this._undoStack.Count -gt 0) {
            $cmd = $this._undoStack.Pop()
            $cmd.Undo($this._buffer)
            $this._redoStack.Push($cmd)
            $this._buffer.SetCursorPosition($cmd.CursorBefore)
            $this.UpdateCursorPosition()
            $this.RequestRedraw()
        }
    }
    
    hidden [void] Redo() {
        if ($this._redoStack.Count -gt 0) {
            $cmd = $this._redoStack.Pop()
            $cmd.Execute($this._buffer)
            $this._undoStack.Push($cmd)
            $this._buffer.SetCursorPosition($cmd.CursorAfter)
            $this.UpdateCursorPosition()
            $this.RequestRedraw()
        }
    }
    
    # Search functionality
    hidden [void] ShowSearchPanel([bool]$replace = $false) {
        $this._isSearchMode = $true
        $this._isReplaceMode = $replace
        $this._searchPanel.Visible = $true
        $this._searchPanel.Title = if ($replace) { " Find & Replace " } else { " Find " }
        
        # Update search panel height
        $this._searchPanel.Height = if ($replace) { 6 } else { 4 }
        $this._replaceBox.Visible = $replace
        
        # Focus search box
        $focusManager = $this.ServiceContainer.GetService("FocusManager")
        if ($focusManager) {
            $focusManager.SetFocus($this._searchBox)
        }
        
        $this.RequestRedraw()
    }
    
    hidden [void] HideSearchPanel() {
        $this._isSearchMode = $false
        $this._isReplaceMode = $false
        $this._searchPanel.Visible = $false
        $this._searchBox.Text = ""
        $this._replaceBox.Text = ""
        $this._searchStatusLabel.Text = ""
        $this.RequestRedraw()
    }
    
    hidden [void] PerformIncrementalSearch() {
        if ([string]::IsNullOrEmpty($this._searchBox.Text)) {
            $this._searchStatusLabel.Text = ""
            return
        }
        
        $results = $this._searchEngine.Search($this._searchBox.Text, $false, $false)
        
        if ($results.Count -gt 0) {
            $this._searchStatusLabel.Text = "$($results.Count) matches found"
            $current = $this._searchEngine.GetCurrentResult()
            if ($current) {
                $this._buffer.SetCursorPosition($current.Start)
                $this.UpdateCursorPosition()
                $this.EnsureCursorVisible()
            }
        } else {
            $this._searchStatusLabel.Text = "No matches found"
        }
        
        $this.RequestRedraw()
    }
    
    hidden [bool] HandleSearchInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([ConsoleKey]::Escape) {
                $this.HideSearchPanel()
                return $true
            }
            ([ConsoleKey]::Enter) {
                if ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift) {
                    # Previous result
                    $result = $this._searchEngine.PreviousResult()
                } else {
                    # Next result
                    $result = $this._searchEngine.NextResult()
                }
                
                if ($result) {
                    $this._buffer.SetCursorPosition($result.Start)
                    $this.UpdateCursorPosition()
                    $this.EnsureCursorVisible()
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::F3) {
                # Find next
                $result = $this._searchEngine.NextResult()
                if ($result) {
                    $this._buffer.SetCursorPosition($result.Start)
                    $this.UpdateCursorPosition()
                    $this.EnsureCursorVisible()
                    $this.RequestRedraw()
                }
                return $true
            }
            ([ConsoleKey]::Tab) {
                if ($this._isReplaceMode) {
                    # Switch focus between search and replace
                    $focusManager = $this.ServiceContainer.GetService("FocusManager")
                    if ($focusManager) {
                        if ($this._searchBox.IsFocused) {
                            $focusManager.SetFocus($this._replaceBox)
                        } else {
                            $focusManager.SetFocus($this._searchBox)
                        }
                    }
                }
                return $true
            }
            ([ConsoleKey]::R) {
                if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
                    # Replace current
                    if ($this._searchEngine.ReplaceCurrent($this._replaceBox.Text)) {
                        $this._searchStatusLabel.Text = "Replaced 1 occurrence"
                        $this.UpdateCursorPosition()
                        $this.RequestRedraw()
                    }
                    return $true
                }
            }
            ([ConsoleKey]::A) {
                if (($keyInfo.Modifiers -band [ConsoleModifiers]::Control) -and $this._isReplaceMode) {
                    # Replace all
                    $count = $this._searchEngine.ReplaceAll($this._replaceBox.Text)
                    $this._searchStatusLabel.Text = "Replaced $count occurrences"
                    $this.UpdateCursorPosition()
                    $this.RequestRedraw()
                    return $true
                }
            }
        }
        
        # Let search/replace boxes handle their input
        return ([Screen]$this).HandleInput($keyInfo)
    }
    
    # Demo content
    hidden [void] LoadDemoText() {
        $demoText = @"
# High-Performance Text Editor Demo

Welcome to the Axiom-Phoenix Text Editor!

This editor features:
- Gap buffer for O(1) insertions at cursor position
- Efficient line indexing for fast navigation
- Viewport-only rendering for smooth scrolling
- Incremental search with highlighting
- Smart cursor movement and selection
- Undo/Redo support
- Syntax-aware indentation

## Key Bindings

### Navigation
- Arrow keys: Move cursor
- Ctrl+Arrow: Move by word
- Home/End: Move to line start/end
- Ctrl+Home/End: Move to document start/end
- PageUp/PageDown: Scroll by page

### Editing
- Ctrl+A: Select all
- Ctrl+C: Copy selection
- Ctrl+X: Cut selection
- Ctrl+V: Paste
- Ctrl+Z: Undo
- Ctrl+Y: Redo

### Search
- Ctrl+F: Find
- Ctrl+H: Find and Replace
- F3: Find next
- Shift+F3: Find previous
- Ctrl+R: Replace current (in replace mode)
- Ctrl+A: Replace all (in replace mode)

### File Operations
- Ctrl+S: Save (placeholder)
- Ctrl+Q: Exit

## Performance Features

The editor uses several optimizations:
1. **Gap Buffer**: Maintains a gap at the cursor position for O(1) insertions
2. **Line Caching**: Tracks line starts for O(1) line access
3. **Dirty Tracking**: Only redraws changed lines
4. **Viewport Rendering**: Only processes visible content

Try editing this text to see the smooth performance!
"@
        
        $this._buffer.Insert($demoText)
        $this._buffer.SetCursorPosition(0)
        $this.UpdateCursorPosition()
        $this._fullRedrawNeeded = $true
    }
    
    # Placeholder methods
    hidden [void] GoToLine() {
        $this._statusLabel.Text = "Go to line (not implemented)"
    }
    
    hidden [void] Save() {
        $this._statusLabel.Text = "Save (no filesystem access)"
    }
    
    hidden [void] Exit() {
        # Return to previous screen
        $navService = $this.ServiceContainer.GetService("NavigationService")
        if ($navService -and $navService.CanGoBack()) {
            $navService.GoBack()
        } else {
            $global:TuiState.Running = $false
        }
    }
}



####\Services\ASE.001_Logger.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

#region Logger Class

# ===== CLASS: Logger =====
# Module: logger (from axiom)
# Dependencies: None
# Purpose: Application-wide logging with multiple outputs
class Logger {
    [string]$LogPath
    [System.Collections.Queue]$LogQueue
    [int]$MaxQueueSize = 1000
    [bool]$EnableFileLogging = $true
    [bool]$EnableConsoleLogging = $false
    [string]$MinimumLevel = "Info"
    [hashtable]$LevelPriority = @{
        'Trace' = 0
        'Debug' = 1
        'Info' = 2
        'Warning' = 3
        'Error' = 4
        'Fatal' = 5
    }
    
    Logger() {
        $this.LogPath = Join-Path $env:APPDATA "AxiomPhoenix\app.log"
        $this._Initialize()
    }
    
    Logger([string]$logPath) {
        $this.LogPath = $logPath
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $this.LogQueue = [System.Collections.Queue]::new()
        
        # Check for environment variable to set log level
        if ($env:AXIOM_LOG_LEVEL) {
            if ($this.LevelPriority.ContainsKey($env:AXIOM_LOG_LEVEL)) {
                $this.MinimumLevel = $env:AXIOM_LOG_LEVEL
            }
        }
        
        # Don't enable console logging for TUI apps - it interferes with display
        # Use file logging instead
        
        $logDir = Split-Path -Parent $this.LogPath
        if (-not (Test-Path $logDir)) {
            New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        }
        
        # Write-Verbose "Logger: Initialized with log path: $($this.LogPath), MinimumLevel: $($this.MinimumLevel)"
    }
    
    [void] Log([string]$message, [string]$level = "Info") {
        # Check if we should log this level
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) {
            return
        }
        
        $logEntry = @{
            Timestamp = [DateTime]::Now
            Level = $level
            Message = $message
            ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        }
        
        # Add to queue
        $this.LogQueue.Enqueue($logEntry)
        
        # Flush if queue is getting large
        if ($this.LogQueue.Count -ge $this.MaxQueueSize) {
            $this.Flush()
        }
        
        # Console logging if enabled
        if ($this.EnableConsoleLogging) {
            $this._WriteToConsole($logEntry)
        }
    }
    
    [void] LogException([Exception]$exception, [string]$message = "") {
        $exceptionDetails = @{
            Message = if ($message) { $message } else { "Exception occurred" }
            ExceptionType = $exception.GetType().FullName
            ExceptionMessage = $exception.Message
            StackTrace = $exception.StackTrace
            InnerException = if ($exception.InnerException) { 
                $exception.InnerException.Message 
            } else { 
                $null 
            }
        }
        
        $detailsJson = $exceptionDetails | ConvertTo-Json -Compress -Depth 10 -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
        if (-not $detailsJson) {
            # If serialization fails, create a simple string representation
            $detailsJson = "ExceptionType: $($exceptionDetails.ExceptionType), Message: $($exceptionDetails.ExceptionMessage)"
        }
        $this.Log($detailsJson, "Error")
    }
    
    [void] Flush() {
        if ($this.LogQueue.Count -eq 0 -or -not $this.EnableFileLogging) {
            return
        }
        
        try {
            $logContent = [System.Text.StringBuilder]::new()
            
            while ($this.LogQueue.Count -gt 0) {
                $entry = $this.LogQueue.Dequeue()
                $logLine = "$($entry.Timestamp.ToString('yyyy-MM-dd HH:mm:ss.fff')) [$($entry.Level.ToUpper().PadRight(7))] [Thread:$($entry.ThreadId)] $($entry.Message)"
                [void]$logContent.AppendLine($logLine)
            }
            
            if ($logContent.Length -gt 0) {
                Add-Content -Path $this.LogPath -Value $logContent.ToString() -NoNewline
            }
        }
        catch {
            Write-Warning "Logger: Failed to flush logs: $_"
        }
    }
    
    hidden [void] _WriteToConsole([hashtable]$logEntry) {
        $color = switch ($logEntry.Level) {
            'Trace' { [ConsoleColor]::DarkGray }
            'Debug' { [ConsoleColor]::Gray }
            'Info' { [ConsoleColor]::White }
            'Warning' { [ConsoleColor]::Yellow }
            'Error' { [ConsoleColor]::Red }
            'Fatal' { [ConsoleColor]::Magenta }
            default { [ConsoleColor]::White }
        }
        
        $timestamp = $logEntry.Timestamp.ToString('HH:mm:ss')
        $prefix = "[$timestamp] [$($logEntry.Level.ToUpper())]"
        
        Write-Host $prefix -ForegroundColor $color -NoNewline
        Write-Host " $($logEntry.Message)" -ForegroundColor White
    }
    
    [void] Cleanup() {
        $this.Flush()
        # Write-Verbose "Logger: Cleanup complete"
    }
}

#endregion
#<!-- END_PAGE: ASE.006 -->



####\Services\ASE.002_EventManager.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

#region EventManager Class

# ===== CLASS: EventManager =====
# Module: event-system (from axiom)
# Dependencies: None
# Purpose: Pub/sub event system for decoupled communication
class EventManager {
    [hashtable]$EventHandlers = @{}
    [int]$NextHandlerId = 1
    [System.Collections.Generic.List[hashtable]]$EventHistory
    [int]$MaxHistorySize = 100
    [bool]$EnableHistory = $true
    
    EventManager() {
        $this.EventHistory = [System.Collections.Generic.List[hashtable]]::new()
        # Write-Verbose "EventManager: Initialized"
    }
    
    [string] Subscribe([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) {
            throw [ArgumentException]::new("Event name cannot be null or empty")
        }
        if (-not $handler) {
            throw [ArgumentNullException]::new("handler")
        }
        
        if (-not $this.EventHandlers.ContainsKey($eventName)) {
            $this.EventHandlers[$eventName] = @{}
        }
        
        $handlerId = "handler_$($this.NextHandlerId)"
        $this.NextHandlerId++
        
        $this.EventHandlers[$eventName][$handlerId] = @{
            Handler = $handler
            SubscribedAt = [DateTime]::Now
            ExecutionCount = 0
        }
        
        # Write-Verbose "EventManager: Subscribed handler '$handlerId' to event '$eventName'"
        return $handlerId
    }
    
    [void] Unsubscribe([string]$eventName, [string]$handlerId) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            if ($this.EventHandlers[$eventName].ContainsKey($handlerId)) {
                $this.EventHandlers[$eventName].Remove($handlerId)
                # Write-Verbose "EventManager: Unsubscribed handler '$handlerId' from event '$eventName'"
                
                # Clean up empty event entries
                if ($this.EventHandlers[$eventName].Count -eq 0) {
                    $this.EventHandlers.Remove($eventName)
                }
            }
        }
    }
    
    [void] UnsubscribeAll([string]$eventName) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlerCount = $this.EventHandlers[$eventName].Count
            $this.EventHandlers.Remove($eventName)
            # Write-Verbose "EventManager: Unsubscribed all $handlerCount handlers from event '$eventName'"
        }
    }
    
    [void] Publish([string]$eventName, [hashtable]$eventData = @{}) {
        # Sanitize event data to prevent circular reference issues
        $sanitizedData = @{}
        foreach ($key in $eventData.Keys) {
            $value = $eventData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [double] -or 
                $value -is [bool] -or $value -is [datetime] -or $value -eq $null) {
                # Simple types are safe
                $sanitizedData[$key] = $value
            }
            elseif ($value -is [UIElement]) {
                # Never store UIElement objects - just store identifying info
                $sanitizedData[$key] = "[UIElement: $($value.Name)]"
            }
            elseif ($value.GetType().Name -match 'Task|Project') {
                # For task/project objects, only store essential data
                try {
                    if ($value.PSObject.Properties['Id']) {
                        $sanitizedData[$key] = @{
                            Type = $value.GetType().Name
                            Id = $value.Id
                            Title = if ($value.PSObject.Properties['Title']) { $value.Title } else { $null }
                        }
                    } else {
                        $sanitizedData[$key] = "[Object: $($value.GetType().Name)]"
                    }
                } catch {
                    $sanitizedData[$key] = "[Object: $($value.GetType().Name)]"
                }
            }
            else {
                # For other complex types, just store the type name
                $sanitizedData[$key] = "[Object: $($value.GetType().Name)]"
            }
        }
        
        # Add to history if enabled (using sanitized data)
        if ($this.EnableHistory) {
            $historyEntry = @{
                EventName = $eventName
                EventData = $sanitizedData
                Timestamp = [DateTime]::Now
                HandlerCount = 0
            }
            
            $this.EventHistory.Add($historyEntry)
            
            if ($this.EventHistory.Count -gt $this.MaxHistorySize) {
                $this.EventHistory.RemoveAt(0)
            }
        }
        
        # Execute handlers with original data
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlers = @($this.EventHandlers[$eventName].GetEnumerator())
            
            if ($this.EnableHistory -and $this.EventHistory.Count -gt 0) {
                $this.EventHistory[-1].HandlerCount = $handlers.Count
            }
            
            foreach ($entry in $handlers) {
                try {
                    $handlerData = $entry.Value
                    $handlerData.ExecutionCount++
                    & $handlerData.Handler $this $eventData
                }
                catch {
                    # Log errors without complex data
                    if ($global:TuiState.Services.Logger) {
                        $global:TuiState.Services.Logger.Log(
                            "EventManager: Error in handler '$($entry.Key)' for event '$eventName': $($_.Exception.Message)", 
                            "Error"
                        )
                    }
                }
            }
        }
    }
    
    [hashtable[]] GetEventHistory([string]$eventName = $null) {
        if ($eventName) {
            return $this.EventHistory | Where-Object { $_.EventName -eq $eventName }
        }
        return $this.EventHistory | ForEach-Object { $_ }
    }
    
    [void] ClearHistory() {
        $this.EventHistory.Clear()
        # Write-Verbose "EventManager: Cleared event history"
    }
    
    [hashtable] GetEventInfo() {
        $info = @{
            RegisteredEvents = @{}
            TotalHandlers = 0
        }
        
        foreach ($eventName in $this.EventHandlers.Keys) {
            $handlers = $this.EventHandlers[$eventName]
            $info.RegisteredEvents[$eventName] = @{
                HandlerCount = $handlers.Count
                Handlers = $handlers.Keys | ForEach-Object { $_ }
            }
            $info.TotalHandlers += $handlers.Count
        }
        
        return $info
    }
}

#endregion
#<!-- END_PAGE: ASE.007 -->



####\Services\ASE.003_ThemeManager.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

#region ThemeManager Class

# ===== CLASS: ThemeManager =====
# Module: theme-manager (from axiom)
# Dependencies: None
# Purpose: Visual theming system with consistent hex color output
class ThemeManager {
    [hashtable]$CurrentTheme = @{}
    [string]$ThemeName = "Synthwave"
    [hashtable]$Themes = @{}
    
    ThemeManager() {
        $this.InitializeThemes()
        $this.LoadTheme($this.ThemeName)
    }
    
    [void] InitializeThemes() {
        # Synthwave Theme - Neon cyberpunk aesthetic
        $this.Themes["Synthwave"] = @{
            # Base colors
            "Background" = "#0a0e27"
            "Foreground" = "#f92aad"
            "Subtle" = "#72f1b8"
            "Primary" = "#ff6ac1"
            "Accent" = "#ffcc00"
            "Secondary" = "#5a189a"
            "Error" = "#ff006e"
            "Warning" = "#ffbe0b"
            "Success" = "#3bf4fb"
            "Info" = "#8338ec"
            
            # Component specific
            "component.background" = "#0a0e27"
            "component.border" = "#f92aad"
            "component.title" = "#ffcc00"
            "component.text" = "#f92aad"  # ADDED
            
            # Input
            "input.background" = "#1a1e3a"
            "input.foreground" = "#f92aad"
            "input.placeholder" = "#72f1b8"
            
            # Button states
            "button.normal.fg" = "#0a0e27"
            "button.normal.bg" = "#f92aad"
            "button.focused.fg" = "#0a0e27"
            "button.focused.bg" = "#ff6ac1"
            "button.pressed.fg" = "#0a0e27"
            "button.pressed.bg" = "#ffcc00"
            "button.disabled.fg" = "#555555"
            "button.disabled.bg" = "#2a2e4a"
            
            # List/Table
            "list.header.fg" = "#ffcc00"
            "list.header.bg" = "#1a1e3a"
            "list.item.normal" = "#f92aad"
            "list.item.selected" = "#0a0e27"
            "list.item.selected.background" = "#ff6ac1"
            "list.scrollbar" = "#72f1b8"
            
            # Overlay
            "overlay.background" = "#0a0e27"  # ADDED
        }
        
        # Aurora Theme - Northern lights inspired
        $this.Themes["Aurora"] = @{
            # Base colors
            "Background" = "#011627"
            "Foreground" = "#d6deeb"
            "Subtle" = "#7fdbca"
            "Primary" = "#82aaff"
            "Accent" = "#21c7a8"
            "Secondary" = "#c792ea"
            "Error" = "#ef5350"
            "Warning" = "#ffeb95"
            "Success" = "#22da6e"
            "Info" = "#82aaff"
            
            # Component specific
            "component.background" = "#011627"
            "component.border" = "#5f7e97"
            "component.title" = "#21c7a8"
            
            # Input
            "input.background" = "#0e293f"
            "input.foreground" = "#d6deeb"
            "input.placeholder" = "#637777"
            
            # Button states
            "button.normal.fg" = "#011627"
            "button.normal.bg" = "#82aaff"
            "button.focused.fg" = "#011627"
            "button.focused.bg" = "#21c7a8"
            "button.pressed.fg" = "#011627"
            "button.pressed.bg" = "#c792ea"
            "button.disabled.fg" = "#444444"
            "button.disabled.bg" = "#1d3b53"
            
            # List/Table
            "list.header.fg" = "#21c7a8"
            "list.header.bg" = "#0e293f"
            "list.item.normal" = "#d6deeb"
            "list.item.selected" = "#011627"
            "list.item.selected.background" = "#82aaff"
            "list.scrollbar" = "#5f7e97"
        }
        
        # Ocean Theme - Deep sea aesthetics
        $this.Themes["Ocean"] = @{
            # Base colors
            "Background" = "#0f111a"
            "Foreground" = "#8f93a2"
            "Subtle" = "#4b526d"
            "Primary" = "#00bcd4"
            "Accent" = "#00e676"
            "Secondary" = "#536dfe"
            "Error" = "#ff5252"
            "Warning" = "#ffb74d"
            "Success" = "#00e676"
            "Info" = "#448aff"
            
            # Component specific
            "component.background" = "#0f111a"
            "component.border" = "#1f2937"
            "component.title" = "#00bcd4"
            
            # Input
            "input.background" = "#1a1f2e"
            "input.foreground" = "#8f93a2"
            "input.placeholder" = "#4b526d"
            
            # Button states
            "button.normal.fg" = "#0f111a"
            "button.normal.bg" = "#00bcd4"
            "button.focused.fg" = "#0f111a"
            "button.focused.bg" = "#00e676"
            "button.pressed.fg" = "#0f111a"
            "button.pressed.bg" = "#536dfe"
            "button.disabled.fg" = "#333333"
            "button.disabled.bg" = "#1a1f2e"
            
            # List/Table
            "list.header.fg" = "#00e676"
            "list.header.bg" = "#1a1f2e"
            "list.item.normal" = "#8f93a2"
            "list.item.selected" = "#0f111a"
            "list.item.selected.background" = "#00bcd4"
            "list.scrollbar" = "#4b526d"
        }
        
        # Forest Theme - Nature inspired
        $this.Themes["Forest"] = @{
            # Base colors
            "Background" = "#0d1117"
            "Foreground" = "#c9d1d9"
            "Subtle" = "#8b949e"
            "Primary" = "#58a6ff"
            "Accent" = "#56d364"
            "Secondary" = "#d29922"
            "Error" = "#f85149"
            "Warning" = "#f0883e"
            "Success" = "#56d364"
            "Info" = "#58a6ff"
            
            # Component specific
            "component.background" = "#0d1117"
            "component.border" = "#30363d"
            "component.title" = "#56d364"
            
            # Input
            "input.background" = "#161b22"
            "input.foreground" = "#c9d1d9"
            "input.placeholder" = "#484f58"
            
            # Button states
            "button.normal.fg" = "#0d1117"
            "button.normal.bg" = "#58a6ff"
            "button.focused.fg" = "#0d1117"
            "button.focused.bg" = "#56d364"
            "button.pressed.fg" = "#0d1117"
            "button.pressed.bg" = "#d29922"
            "button.disabled.fg" = "#484f58"
            "button.disabled.bg" = "#21262d"
            
            # List/Table
            "list.header.fg" = "#56d364"
            "list.header.bg" = "#161b22"
            "list.item.normal" = "#c9d1d9"
            "list.item.selected" = "#0d1117"
            "list.item.selected.background" = "#58a6ff"
            "list.scrollbar" = "#8b949e"
        }
    }
    
    [void] LoadTheme([string]$themeName) {
        if ($this.Themes.ContainsKey($themeName)) {
            $this.CurrentTheme = $this.Themes[$themeName].Clone()
            $this.ThemeName = $themeName
        }
    }
    
    [void] LoadDefaultTheme() {
        $this.LoadTheme("Synthwave")
    }
    
    [string] GetColor([string]$colorName) {
        return $this.GetColor($colorName, "#FFFFFF")
    }
    
    [string] GetColor([string]$colorName, [string]$defaultColor) {
        if ($this.CurrentTheme.ContainsKey($colorName)) {
            return $this.CurrentTheme[$colorName]
        }
        return $defaultColor
    }
    
    [void] SetColor([string]$colorName, $colorValue) {
        # Convert ConsoleColor to hex if needed
        if ($colorValue -is [ConsoleColor]) {
            $consoleColorMap = @{
                [ConsoleColor]::Black = "#000000"
                [ConsoleColor]::DarkBlue = "#000080"
                [ConsoleColor]::DarkGreen = "#008000"
                [ConsoleColor]::DarkCyan = "#008080"
                [ConsoleColor]::DarkRed = "#800000"
                [ConsoleColor]::DarkMagenta = "#800080"
                [ConsoleColor]::DarkYellow = "#808000"
                [ConsoleColor]::Gray = "#C0C0C0"
                [ConsoleColor]::DarkGray = "#808080"
                [ConsoleColor]::Blue = "#0000FF"
                [ConsoleColor]::Green = "#00FF00"
                [ConsoleColor]::Cyan = "#00FFFF"
                [ConsoleColor]::Red = "#FF0000"
                [ConsoleColor]::Magenta = "#FF00FF"
                [ConsoleColor]::Yellow = "#FFFF00"
                [ConsoleColor]::White = "#FFFFFF"
            }
            $colorValue = $consoleColorMap[$colorValue]
        }
        
        $this.CurrentTheme[$colorName] = $colorValue
        # Force redraw when colors change
        if ($global:TuiState) {
            $global:TuiState.IsDirty = $true
        }
    }
    
    [string[]] GetAvailableThemes() {
        return $this.Themes.Keys | Sort-Object
    }
    
    [void] CycleTheme() {
        $availableThemes = $this.GetAvailableThemes()
        $currentIndex = [array]::IndexOf($availableThemes, $this.ThemeName)
        $nextIndex = ($currentIndex + 1) % $availableThemes.Count
        $this.LoadTheme($availableThemes[$nextIndex])
    }
}

#endregion
#<!-- END_PAGE: ASE.005 -->



####\Services\ASE.004_ActionService.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - ActionService
# Central command registry and execution service
# ==============================================================================

class ActionService {
    [hashtable]$ActionRegistry = @{}
    [hashtable]$EventSubscriptions = @{}
    [object]$EventManager = $null
    
    ActionService() {
        # Write-Verbose "ActionService: Initialized with empty registry"
    }
    
    ActionService([object]$eventManager) {
        $this.EventManager = $eventManager
        # Write-Verbose "ActionService: Initialized with EventManager integration"
    }
    
    [void] RegisterAction([string]$actionName, [scriptblock]$action, [hashtable]$metadata = @{}) {
        try {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw "Action name cannot be null or empty"
            }
            if (-not $action) {
                throw "Action scriptblock cannot be null"
            }
            
            $actionData = @{
                Name = $actionName
                Action = $action
                Category = if ($metadata.ContainsKey('Category')) { $metadata.Category } else { "General" }
                Description = if ($metadata.ContainsKey('Description')) { $metadata.Description } else { "" }
                Hotkey = if ($metadata.ContainsKey('Hotkey')) { $metadata.Hotkey } else { "" }
                RegisteredAt = [datetime]::Now
                ExecutionCount = 0
                LastExecuted = $null
                Metadata = $metadata
            }
            
            $this.ActionRegistry[$actionName] = $actionData
            
            # Publish event if EventManager available
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Registered", @{
                    ActionName = $actionName
                    Category = $actionData.Category
                })
            }
            
            # Write-Verbose "ActionService: Registered action '$actionName' in category '$($actionData.Category)'"
        }
        catch {
            Write-Error "Failed to register action '$actionName': $_"
            throw
        }
    }
    
    [void] UnregisterAction([string]$actionName) {
        if ($this.ActionRegistry.ContainsKey($actionName)) {
            $this.ActionRegistry.Remove($actionName)
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Unregistered", @{
                    ActionName = $actionName
                })
            }
            
            # Write-Verbose "ActionService: Unregistered action '$actionName'"
        }
    }
    
    [object] ExecuteAction([string]$actionName, [hashtable]$parameters = @{}) {
        try {
            if (-not $this.ActionRegistry.ContainsKey($actionName)) {
                throw "Action '$actionName' not found in registry"
            }
            
            $actionData = $this.ActionRegistry[$actionName]
            
            # Update execution metadata
            $actionData.ExecutionCount++
            $actionData.LastExecuted = [datetime]::Now
            
            # Write-Verbose "ActionService: Executing action '$actionName' with $($parameters.Count) parameters"
            
            # Execute the action
            $result = & $actionData.Action @parameters
            
            # Publish execution event
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Executed", @{
                    ActionName = $actionName
                    Parameters = $parameters
                    Success = $true
                })
            }
            
            return $result
        }
        catch {
            Write-Error "Failed to execute action '$actionName': $_"
            
            if ($this.EventManager) {
                $this.EventManager.Publish("Action.Executed", @{
                    ActionName = $actionName
                    Parameters = $parameters
                    Success = $false
                    Error = $_.ToString()
                })
            }
            
            throw
        }
    }
    
    [hashtable] GetAction([string]$actionName) {
        return $this.ActionRegistry[$actionName]
    }
    
    [hashtable] GetAllActions() {
        return $this.ActionRegistry
    }
    
    [hashtable[]] GetActionsByCategory([string]$category) {
        return @($this.ActionRegistry.Values | Where-Object { $_.Category -eq $category })
    }
    
    [void] RegisterDefaultActions() {
        # Register built-in actions
        $this.RegisterAction("app.exit", {
            # Write-Verbose "Executing app.exit action"
            $global:TuiState.Running = $false
        }, @{
            Category = "Application"
            Description = "Exit the application"
            Hotkey = "Ctrl+Q"
        })
        
        $this.RegisterAction("app.help", {
            # Write-Verbose "Executing app.help action"
            # Would show help screen
        }, @{
            Category = "Application"
            Description = "Show help"
            Hotkey = "F1"
        })
        
        # Use CommandPalette dialog directly (it inherits from Dialog/Screen)
        $this.RegisterAction("app.commandPalette", {
            Write-Log -Level Debug -Message "app.commandPalette action triggered"
            
            $navService = $global:TuiState.Services.NavigationService
            $container = $global:TuiState.ServiceContainer
            $actionService = $global:TuiState.Services.ActionService
            
            if (-not $navService -or -not $container -or -not $actionService) {
                Write-Log -Level Error -Message "Required services not found"
                return
            }
            
            # Create CommandPalette dialog
            $palette = [CommandPalette]::new("CommandPalette", $container)
            
            # Get all registered actions
            $allActions = @()
            foreach ($actionName in $actionService.ActionRegistry.Keys) {
                $actionData = $actionService.ActionRegistry[$actionName]
                $allActions += @{
                    Name = $actionName
                    Category = $actionData.Category
                    Description = $actionData.Description
                    Hotkey = $actionData.Hotkey
                }
            }
            
            # Set actions and show
            $palette.SetActions($allActions)
            
            # Set callback to execute selected action
            $palette.OnClose = {
                param($result)
                Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] CommandPalette OnClose called!"
                if ($result -and $result.Name) {
                    Write-Log -Level Debug -Message "CommandPalette OnClose: Selected action: $($result.Name)"
                    Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] Selected action: $($result.Name)"
                    
                    # Defer execution to avoid re-entrance issues in window-based model
                    # Actions should execute AFTER the dialog closes and navigation completes
                    $evtMgr = $global:TuiState.Services.EventManager
                    if ($evtMgr) {
                        Write-Log -Level Debug -Message "CommandPalette OnClose: Publishing DeferredAction event for: $($result.Name)"
                        Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] Publishing DeferredAction event..."
                        $evtMgr.Publish("DeferredAction", @{
                            ActionName = $result.Name
                        })
                        Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] DeferredAction event published!"
                    } else {
                        Write-Log -Level Error -Message "CommandPalette OnClose: EventManager not found!"
                        Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] ERROR: EventManager not found!"
                    }
                } else {
                    Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] No action selected (result was null or had no Name)"
                }
            }
            
            # Navigate to the palette (it will handle its own lifecycle)
            $navService.NavigateTo($palette)
        }, @{
            Category = "Application"
            Description = "Show command palette"
            Hotkey = "Ctrl+P"
        })
        
        # Theme picker action
        $this.RegisterAction("ui.themePicker", {
            Write-Log -Level Info -Message "Opening Theme Selection screen"
            $navService = $global:TuiState.Services.NavigationService
            $container = $global:TuiState.ServiceContainer
            if ($navService -and $container) {
                try {
                    $themeScreen = [ThemeScreen]::new($container)
                    $themeScreen.Initialize()
                    $navService.NavigateTo($themeScreen)
                    Write-Log -Level Info -Message "Successfully navigated to ThemeScreen"
                }
                catch {
                    Write-Log -Level Error -Message "Failed to navigate to ThemeScreen: $_"
                }
            }
        }, @{
            Category = "UI"
            Description = "Change Theme"
        })
        
        # Task list action
        $this.RegisterAction("task.list", {
            Write-Log -Level Info -Message "Navigating to Task List screen"
            $navService = $global:TuiState.Services.NavigationService
            $container = $global:TuiState.ServiceContainer
            if ($navService -and $container) {
                try {
                    # Create and navigate to TaskListScreen
                    $taskListScreen = [TaskListScreen]::new($container)
                    $taskListScreen.Initialize()
                    $navService.NavigateTo($taskListScreen)
                    Write-Log -Level Info -Message "Successfully navigated to TaskListScreen"
                }
                catch {
                    Write-Log -Level Error -Message "Failed to navigate to TaskListScreen: $_"
                    Write-Log -Level Error -Message "Stack trace: $($_.ScriptStackTrace)"
                }
            }
        }, @{
            Category = "Tasks"
            Description = "View All Tasks"
        })
        
        # Navigation actions
        $this.RegisterAction("navigation.taskList", {
            Write-Log -Level Info -Message "Navigating to Task List screen"
            $navService = $global:TuiState.Services.NavigationService
            $container = $global:TuiState.ServiceContainer
            if ($navService -and $container) {
                try {
                    # Create and navigate to TaskListScreen
                    $taskListScreen = [TaskListScreen]::new($container)
                    $taskListScreen.Initialize()
                    $navService.NavigateTo($taskListScreen)
                    Write-Log -Level Info -Message "Successfully navigated to TaskListScreen"
                }
                catch {
                    Write-Log -Level Error -Message "Failed to navigate to TaskListScreen: $_"
                    Write-Log -Level Error -Message "Stack trace: $($_.ScriptStackTrace)"
                }
            }
        }, @{
            Category = "Navigation"
            Description = "Go to Task List"
        })
        
        $this.RegisterAction("navigation.dashboard", {
            $navService = $global:TuiState.Services.NavigationService
            $container = $global:TuiState.ServiceContainer
            $dashboardScreen = [DashboardScreen]::new($container)
            $dashboardScreen.Initialize()
            $navService.NavigateTo($dashboardScreen)
        }, @{
            Category = "Navigation"
            Description = "Go to Dashboard"
        })
        
        $this.RegisterAction("navigation.themePicker", {
            Write-Log -Level Info -Message "Navigating to Theme Selection screen"
            $navService = $global:TuiState.Services.NavigationService
            $container = $global:TuiState.ServiceContainer
            if ($navService -and $container) {
                try {
                    $themeScreen = [ThemeScreen]::new($container)
                    $themeScreen.Initialize()
                    $navService.NavigateTo($themeScreen)
                    Write-Log -Level Info -Message "Successfully navigated to ThemeScreen"
                }
                catch {
                    Write-Log -Level Error -Message "Failed to navigate to ThemeScreen: $_"
                }
            }
        }, @{
            Category = "Navigation"
            Description = "Go to Theme Selection"
        })
        
        # Add navigation.commandPalette for menu option
        $this.RegisterAction("navigation.commandPalette", {
            $this.ExecuteAction("app.commandPalette", @{})
        }, @{
            Category = "Navigation"
            Description = "Open Command Palette"
        })
        
        $this.RegisterAction("navigation.back", {
            $navService = $global:TuiState.Services.NavigationService
            if ($navService.CanGoBack()) {
                $navService.GoBack()
            }
        }, @{
            Category = "Navigation"
            Description = "Go Back"
        })
        
        # Task CRUD actions (placeholders for now)
        $this.RegisterAction("task.edit.selected", {
            Write-Log -Level Info -Message "Edit task not implemented yet"
        }, @{
            Category = "Tasks"
            Description = "Edit Selected Task"
        })
        
        $this.RegisterAction("task.delete.selected", {
            Write-Log -Level Info -Message "Delete task not implemented yet"
        }, @{
            Category = "Tasks"
            Description = "Delete Selected Task"
        })
        
        $this.RegisterAction("task.complete.selected", {
            Write-Log -Level Info -Message "Complete task not implemented yet"
        }, @{
            Category = "Tasks"
            Description = "Complete Selected Task"
        })
        
        # Simple test action that returns to dashboard
        $this.RegisterAction("test.simple", {
            Write-Log -Level Info -Message "TEST ACTION EXECUTED: Showing test dialog"
            Add-Content -Path "$PSScriptRoot\..\debug-trace.log" -Value "[$(Get-Date -Format 'HH:mm:ss.fff')] >>> TEST ACTION EXECUTED! <<<"
            
            $dialogManager = $global:TuiState.Services.DialogManager
            if ($dialogManager) {
                # Show a simple message dialog
                $dialogManager.ShowMessage(
                    "Test Action Executed!", 
                    "This confirms that command palette actions are working correctly.`n`nPress any key to continue.", 
                    "Info"
                )
            }
            
            # Navigate back to dashboard
            $navService = $global:TuiState.Services.NavigationService
            $container = $global:TuiState.ServiceContainer
            if ($navService -and $container) {
                $dashboardScreen = [DashboardScreen]::new($container)
                $dashboardScreen.Initialize()
                $navService.NavigateTo($dashboardScreen)
                Write-Log -Level Info -Message "Test complete - navigated to dashboard"
            }
        }, @{
            Category = "Test"
            Description = "Simple test - show dialog and refresh"
        })
        
        # Write-Verbose "ActionService: Registered default actions"
    }
}

#endregion



####\Services\ASE.005_DataManager.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

#region DataManager Class

# ===== CLASS: DataManager =====
# Module: data-manager (from axiom)
# Dependencies: EventManager (optional), PmcTask, PmcProject
# Purpose: High-performance data management with transactions, backups, and robust serialization
class DataManager : System.IDisposable {
    # Private fields for high-performance indexes
    hidden [System.Collections.Generic.Dictionary[string, PmcTask]]$_taskIndex
    hidden [System.Collections.Generic.Dictionary[string, PmcProject]]$_projectIndex
    hidden [string]$_dataFilePath
    hidden [string]$_backupPath
    hidden [datetime]$_lastSaveTime
    hidden [bool]$_dataModified = $false
    hidden [int]$_updateTransactionCount = 0
    
    # Public properties
    [hashtable]$Metadata = @{}
    [bool]$AutoSave = $true
    [int]$BackupCount = 5
    [EventManager]$EventManager = $null
    
    DataManager([string]$dataPath) {
        $this._dataFilePath = $dataPath
        $this._Initialize()
    }
    
    DataManager([string]$dataPath, [EventManager]$eventManager) {
        $this._dataFilePath = $dataPath
        $this.EventManager = $eventManager
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        # Initialize indexes
        $this._taskIndex = [System.Collections.Generic.Dictionary[string, PmcTask]]::new()
        $this._projectIndex = [System.Collections.Generic.Dictionary[string, PmcProject]]::new()
        
        # Set up directories
        $baseDir = Split-Path -Path $this._dataFilePath -Parent
        $this._backupPath = Join-Path $baseDir "backups"
        
        # Ensure directories exist
        if (-not (Test-Path $baseDir)) {
            New-Item -ItemType Directory -Path $baseDir -Force | Out-Null
        }
        if (-not (Test-Path $this._backupPath)) {
            New-Item -ItemType Directory -Path $this._backupPath -Force | Out-Null
        }
        
        # Write-Verbose "DataManager: Initialized with path '$($this._dataFilePath)'"
    }
    
    [void] LoadData() {
        try {
            if (-not (Test-Path $this._dataFilePath)) {
                # Write-Verbose "DataManager: No existing data file found at '$($this._dataFilePath)'"
                return
            }
            
            $jsonContent = Get-Content -Path $this._dataFilePath -Raw -Encoding UTF8
            if ([string]::IsNullOrWhiteSpace($jsonContent)) {
                # Write-Verbose "DataManager: Data file is empty"
                return
            }
            
            $data = $jsonContent | ConvertFrom-Json -AsHashtable
            
            # Clear existing data
            $this._taskIndex.Clear()
            $this._projectIndex.Clear()
            
            # Load tasks using FromLegacyFormat
            if ($data.ContainsKey('Tasks')) {
                foreach ($taskData in $data.Tasks) {
                    try {
                        $task = [PmcTask]::FromLegacyFormat($taskData)
                        $this._taskIndex[$task.Id] = $task
                    }
                    catch {
                        Write-Warning "DataManager: Failed to load task: $($_.Exception.Message)"
                    }
                }
            }
            
            # Load projects using FromLegacyFormat
            if ($data.ContainsKey('Projects')) {
                foreach ($projectData in $data.Projects) {
                    try {
                        $project = [PmcProject]::FromLegacyFormat($projectData)
                        $this._projectIndex[$project.Key] = $project
                    }
                    catch {
                        Write-Warning "DataManager: Failed to load project: $($_.Exception.Message)"
                    }
                }
            }
            
            # Load metadata
            if ($data.ContainsKey('Metadata')) {
                $this.Metadata = $data.Metadata.Clone()
            }
            
            $this._lastSaveTime = [datetime]::Now
            $this._dataModified = $false
            
            # Write-Verbose "DataManager: Loaded $($this._taskIndex.Count) tasks and $($this._projectIndex.Count) projects"
            
            # Publish event
            if ($this.EventManager) {
                $this.EventManager.Publish("Data.Loaded", @{
                    TaskCount = $this._taskIndex.Count
                    ProjectCount = $this._projectIndex.Count
                    Source = $this._dataFilePath
                })
            }
        }
        catch {
            Write-Error "DataManager: Failed to load data from '$($this._dataFilePath)': $($_.Exception.Message)"
            throw
        }
    }
    
    [void] SaveData() {
        if ($this._updateTransactionCount -gt 0) {
            # Write-Verbose "DataManager: SaveData deferred - inside update transaction (level $($this._updateTransactionCount))"
            return
        }
        
        try {
            $this.CreateBackup()
            
            $saveData = @{
                Tasks = @()
                Projects = @()
                Metadata = $this.Metadata.Clone()
                SavedAt = [datetime]::Now
                Version = "4.0"
            }
            
            # Convert tasks to legacy format for serialization
            foreach ($task in $this._taskIndex.Values) {
                $saveData.Tasks += $task.ToLegacyFormat()
            }
            
            # Convert projects to legacy format for serialization
            foreach ($project in $this._projectIndex.Values) {
                $saveData.Projects += $project.ToLegacyFormat()
            }
            
            $saveData | ConvertTo-Json -Depth 10 -WarningAction SilentlyContinue | Set-Content -Path $this._dataFilePath -Encoding UTF8 -Force
            $this._lastSaveTime = [datetime]::Now
            $this._dataModified = $false
            
            # Write-Verbose "DataManager: Data saved to '$($this._dataFilePath)'"
            
            # Publish event
            if ($this.EventManager) {
                $this.EventManager.Publish("Data.Saved", @{
                    TaskCount = $saveData.Tasks.Count
                    ProjectCount = $saveData.Projects.Count
                    Destination = $this._dataFilePath
                })
            }
        }
        catch {
            Write-Error "DataManager: Failed to save data: $($_.Exception.Message)"
            throw
        }
    }
    
    hidden [void] CreateBackup() {
        try {
            if (Test-Path $this._dataFilePath) {
                $timestamp = (Get-Date).ToString("yyyyMMdd-HHmmss")
                $backupFileName = "data-backup-$timestamp.json"
                $backupFilePath = Join-Path $this._backupPath $backupFileName
                
                Copy-Item -Path $this._dataFilePath -Destination $backupFilePath -Force
                
                # Manage backup rotation
                if ($this.BackupCount -gt 0) {
                    $backups = Get-ChildItem -Path $this._backupPath -Filter "data-backup-*.json" | 
                               Sort-Object LastWriteTime -Descending
                    
                    if ($backups.Count -gt $this.BackupCount) {
                        $backupsToDelete = $backups | Select-Object -Skip $this.BackupCount
                        foreach ($backup in $backupsToDelete) {
                            Remove-Item -Path $backup.FullName -Force
                            # Write-Verbose "DataManager: Removed old backup '$($backup.Name)'"
                        }
                    }
                }
                
                # Write-Verbose "DataManager: Created backup '$backupFileName'"
            }
        }
        catch {
            Write-Warning "DataManager: Failed to create backup: $($_.Exception.Message)"
        }
    }
    
    # Transactional update methods
    [void] BeginUpdate() {
        $this._updateTransactionCount++
        # Write-Verbose "DataManager: Began update transaction. Depth: $($this._updateTransactionCount)"
    }
    
    [void] EndUpdate() {
        $this.EndUpdate($false)
    }
    
    [void] EndUpdate([bool]$forceSave) {
        if ($this._updateTransactionCount -gt 0) {
            $this._updateTransactionCount--
        }
        
        # Write-Verbose "DataManager: Ended update transaction. Depth: $($this._updateTransactionCount)"
        
        if ($this._updateTransactionCount -eq 0 -and ($this._dataModified -or $forceSave)) {
            if ($this.AutoSave -or $forceSave) {
                $this.SaveData()
            }
        }
    }
    
    # Task management methods
    [PmcTask[]] GetTasks() {
        return @($this._taskIndex.Values)
    }
    
    [PmcTask] GetTask([string]$taskId) {
        if ($this._taskIndex.ContainsKey($taskId)) {
            return $this._taskIndex[$taskId]
        }
        return $null
    }
    
    [PmcTask[]] GetTasksByProject([string]$projectKey) {
        return @($this._taskIndex.Values | Where-Object { $_.ProjectKey -eq $projectKey })
    }
    
    [PmcTask] AddTask([PmcTask]$task) {
        if ($null -eq $task) {
            throw [System.ArgumentNullException]::new("task", "Task cannot be null")
        }
        
        if ([string]::IsNullOrEmpty($task.Id)) {
            $task.Id = [guid]::NewGuid().ToString()
        }
        
        if ($this._taskIndex.ContainsKey($task.Id)) {
            throw [System.InvalidOperationException]::new("Task with ID '$($task.Id)' already exists")
        }
        
        $this._taskIndex[$task.Id] = $task
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Tasks.Changed", @{ Action = "Created"; Task = $task })
        }
        
        # Write-Verbose "DataManager: Added task '$($task.Title)' with ID '$($task.Id)'"
        return $task
    }
    
    [PmcTask] UpdateTask([PmcTask]$task) {
        if ($null -eq $task) {
            throw [System.ArgumentNullException]::new("task", "Task cannot be null")
        }
        
        if (-not $this._taskIndex.ContainsKey($task.Id)) {
            throw [System.InvalidOperationException]::new("Task with ID '$($task.Id)' not found")
        }
        
        $task.UpdatedAt = [datetime]::Now
        $this._taskIndex[$task.Id] = $task
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Tasks.Changed", @{ Action = "Updated"; Task = $task })
        }
        
        # Write-Verbose "DataManager: Updated task '$($task.Title)' with ID '$($task.Id)'"
        return $task
    }
    
    [bool] DeleteTask([string]$taskId) {
        if (-not $this._taskIndex.ContainsKey($taskId)) {
            # Write-Verbose "DataManager: Task '$taskId' not found for deletion"
            return $false
        }
        
        $task = $this._taskIndex[$taskId]
        $this._taskIndex.Remove($taskId) | Out-Null
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Tasks.Changed", @{ Action = "Deleted"; TaskId = $taskId })
        }
        
        # Write-Verbose "DataManager: Deleted task with ID '$taskId'"
        return $true
    }
    
    # Project management methods
    [PmcProject[]] GetProjects() {
        return @($this._projectIndex.Values)
    }
    
    [PmcProject] GetProject([string]$projectKey) {
        if ($this._projectIndex.ContainsKey($projectKey)) {
            return $this._projectIndex[$projectKey]
        }
        return $null
    }
    
    [PmcProject] AddProject([PmcProject]$project) {
        if ($null -eq $project) {
            throw [System.ArgumentNullException]::new("project", "Project cannot be null")
        }
        
        if ([string]::IsNullOrEmpty($project.Key)) {
            throw [System.ArgumentException]::new("Project Key is required")
        }
        
        if ($this._projectIndex.ContainsKey($project.Key)) {
            throw [System.InvalidOperationException]::new("Project with Key '$($project.Key)' already exists")
        }
        
        $this._projectIndex[$project.Key] = $project
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Projects.Changed", @{ Action = "Created"; Project = $project })
        }
        
        # Write-Verbose "DataManager: Added project '$($project.Name)' with Key '$($project.Key)'"
        return $project
    }
    
    [PmcProject] UpdateProject([PmcProject]$project) {
        if ($null -eq $project) {
            throw [System.ArgumentNullException]::new("project", "Project cannot be null")
        }
        
        if (-not $this._projectIndex.ContainsKey($project.Key)) {
            throw [System.InvalidOperationException]::new("Project with Key '$($project.Key)' not found")
        }
        
        $project.UpdatedAt = [datetime]::Now
        $this._projectIndex[$project.Key] = $project
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Projects.Changed", @{ Action = "Updated"; Project = $project })
        }
        
        # Write-Verbose "DataManager: Updated project '$($project.Name)' with Key '$($project.Key)'"
        return $project
    }
    
    [bool] DeleteProject([string]$projectKey) {
        if (-not $this._projectIndex.ContainsKey($projectKey)) {
            # Write-Verbose "DataManager: Project '$projectKey' not found for deletion"
            return $false
        }
        
        # Delete all tasks associated with this project
        $tasksToDelete = @($this._taskIndex.Values | Where-Object { $_.ProjectKey -eq $projectKey })
        foreach ($task in $tasksToDelete) {
            $this.DeleteTask($task.Id) | Out-Null
        }
        
        $project = $this._projectIndex[$projectKey]
        $this._projectIndex.Remove($projectKey) | Out-Null
        $this._dataModified = $true
        
        if ($this.AutoSave -and $this._updateTransactionCount -eq 0) {
            $this.SaveData()
        }
        
        if ($this.EventManager) {
            $this.EventManager.Publish("Projects.Changed", @{ 
                Action = "Deleted"
                ProjectKey = $projectKey
                DeletedTaskCount = $tasksToDelete.Count
            })
        }
        
        # Write-Verbose "DataManager: Deleted project '$projectKey' and $($tasksToDelete.Count) associated tasks"
        return $true
    }
    
    # Utility methods
    [datetime] GetLastSaveTime() {
        return $this._lastSaveTime
    }
    
    [void] ForceSave() {
        $originalTransactionCount = $this._updateTransactionCount
        $this._updateTransactionCount = 0
        try {
            $this.SaveData()
        }
        finally {
            $this._updateTransactionCount = $originalTransactionCount
        }
    }
    
    # IDisposable implementation
    [void] Dispose() {
        # Write-Verbose "DataManager: Disposing - checking for unsaved data"
        
        if ($this._dataModified) {
            $originalTransactionCount = $this._updateTransactionCount
            $this._updateTransactionCount = 0
            try {
                $this.SaveData()
                # Write-Verbose "DataManager: Performed final save during dispose"
            }
            catch {
                Write-Warning "DataManager: Failed to save data during dispose: $($_.Exception.Message)"
            }
            finally {
                $this._updateTransactionCount = $originalTransactionCount
            }
        }
    }
    
    # Cleanup method (alias for Dispose)
    [void] Cleanup() {
        $this.Dispose()
    }
}

#endregion
#<!-- END_PAGE: ASE.003 -->



####\Services\ASE.006_FocusManager.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

#region Additional Service Classes

# ===== CLASS: FocusManager =====
# Module: focus-manager (new service)
# Dependencies: EventManager (optional)
# Purpose: Centralized focus management for UI components
class FocusManager {
    [UIElement]$FocusedComponent = $null
    [EventManager]$EventManager = $null
    [System.Collections.Generic.Stack[UIElement]]$FocusStack = [System.Collections.Generic.Stack[UIElement]]::new()  # NEW: Focus history stack

    FocusManager([EventManager]$eventManager) {
        $this.EventManager = $eventManager
        # Write-Log -Level Debug -Message "FocusManager: Initialized."
    }

    [void] SetFocus([UIElement]$component) {
        $componentName = if ($null -ne $component) { $component.Name } else { 'null' }
        Write-Log -Level Debug -Message "FocusManager.SetFocus called with: $componentName"
        
        if ($this.FocusedComponent -eq $component) {
            Write-Log -Level Debug -Message "  - Already focused, returning"
            return
        }
        
        if ($null -ne $this.FocusedComponent) {
            Write-Log -Level Debug -Message "  - Removing focus from: $($this.FocusedComponent.Name)"
            $this.FocusedComponent.IsFocused = $false
            $this.FocusedComponent.OnBlur()
            $this.FocusedComponent.RequestRedraw()
        }

        $this.FocusedComponent = $null
        if ($null -ne $component -and $component.IsFocusable -and $component.Enabled -and $component.Visible) {
            Write-Log -Level Debug -Message "  - Setting focus to: $($component.Name)"
            Write-Log -Level Debug -Message "    - IsFocusable: $($component.IsFocusable)"
            Write-Log -Level Debug -Message "    - Enabled: $($component.Enabled)"
            Write-Log -Level Debug -Message "    - Visible: $($component.Visible)"
            $this.FocusedComponent = $component
            $component.IsFocused = $true
            $component.OnFocus()
            $component.RequestRedraw()
            
            # CRITICAL: Only pass simple data types in events
            if ($this.EventManager) {
                $this.EventManager.Publish("Focus.Changed", @{ 
                    ComponentName = if ($component.Name) { $component.Name } else { "Unnamed" }
                    ComponentType = $component.GetType().Name 
                })
            }
            Write-Log -Level Debug -Message "  - Focus set successfully"
        } else {
            Write-Log -Level Debug -Message "  - Focus NOT set. Component check failed:"
            Write-Log -Level Debug -Message "    - Component null: $($null -eq $component)"
            if ($null -ne $component) {
                Write-Log -Level Debug -Message "    - IsFocusable: $($component.IsFocusable)"
                Write-Log -Level Debug -Message "    - Enabled: $($component.Enabled)"
                Write-Log -Level Debug -Message "    - Visible: $($component.Visible)"
            }
        }
        $global:TuiState.IsDirty = $true
    }

    [void] MoveFocus([bool]$reverse = $false) {
        if (-not $global:TuiState.CurrentScreen) { return }

        $focusableComponents = [System.Collections.Generic.List[UIElement]]::new()
        
        # Helper to recursively find all focusable components within the current screen
        function Find-Focusable([UIElement]$comp, [System.Collections.Generic.List[UIElement]]$list) {
            if ($comp -and $comp.IsFocusable -and $comp.Visible -and $comp.Enabled) {
                $list.Add($comp)
            }
            foreach ($child in $comp.Children) { Find-Focusable $child $list }
        }
        
        Find-Focusable $global:TuiState.CurrentScreen $focusableComponents
        
        if ($focusableComponents.Count -eq 0) {
            $this.SetFocus($null) # Clear focus if no focusable components
            return
        }
        
        # Sort components by TabIndex, then Y, then X for consistent order
        $sorted = $focusableComponents | Sort-Object { $_.TabIndex * 10000 + $_.Y * 100 + $_.X }

        $currentIndex = -1
        if ($this.FocusedComponent) {
            for ($i = 0; $i -lt $sorted.Count; $i++) {
                if ($sorted[$i] -eq $this.FocusedComponent) {
                    $currentIndex = $i
                    break
                }
            }
        }
        
        $nextIndex = -1
        if ($reverse) {
            $nextIndex = ($currentIndex - 1 + $sorted.Count) % $sorted.Count
        } else {
            $nextIndex = ($currentIndex + 1) % $sorted.Count
        }

        # If no component was focused or current one not found, default to first/last
        if ($currentIndex -eq -1) {
            $nextIndex = if ($reverse) { $sorted.Count - 1 } else { 0 }
        }

        $this.SetFocus($sorted[$nextIndex])
    }

    [void] ReleaseFocus() {
        $this.SetFocus($null)
        # Write-Log -Level Debug -Message "FocusManager: All focus released."
    }
    
    # NEW: Save current focus state to stack
    [void] PushFocusState() {
        $focusName = if ($null -ne $this.FocusedComponent) { $this.FocusedComponent.Name } else { 'null' }
        Write-Log -Level Debug -Message "FocusManager.PushFocusState: Saving focus on $focusName"
        $this.FocusStack.Push($this.FocusedComponent)  # Can push null
    }
    
    # NEW: Restore focus from stack
    [void] PopFocusState() {
        if ($this.FocusStack.Count -gt 0) {
            $previousFocus = $this.FocusStack.Pop()
            $focusName = if ($null -ne $previousFocus) { $previousFocus.Name } else { 'null' }
            Write-Log -Level Debug -Message "FocusManager.PopFocusState: Restoring focus to $focusName"
            $this.SetFocus($previousFocus)
        } else {
            Write-Log -Level Debug -Message "FocusManager.PopFocusState: No saved focus state to restore"
            $this.SetFocus($null)
        }
    }

    [void] Cleanup() {
        $this.FocusedComponent = $null
        $this.FocusStack.Clear()  # NEW: Clear the focus stack
        # Write-Log -Level Debug -Message "FocusManager: Cleanup complete."
    }
}

# ===== CLASS: DialogManager =====
# Module: dialog-manager (new service)
# Dependencies: NavigationService
# Purpose: Convenience facade for dialog management
class DialogManager {
    [object]$NavigationService = $null  # Using object to avoid type issues
    [object]$ServiceContainer = $null

    DialogManager([object]$serviceContainer) {
        if ($null -eq $serviceContainer) {
            throw [System.ArgumentNullException]::new("serviceContainer")
        }
        $this.ServiceContainer = $serviceContainer
        # NavigationService will be resolved when needed
        # Write-Log -Level Debug -Message "DialogManager: Initialized."
    }

    [void] ShowDialog([object]$dialog) {
        if ($null -eq $dialog) {
            throw [System.ArgumentException]::new("Provided dialog is null.", "dialog")
        }
        
        # Verify it's a Dialog (which is a Screen)
        if (-not ($dialog.PSObject.Properties['IsOverlay'])) {
            throw [System.ArgumentException]::new("Expected Dialog-derived object but got $($dialog.GetType().Name)")
        }
        
        # Ensure dialog is marked as overlay
        $dialog.IsOverlay = $true
        
        # Get NavigationService lazily
        if ($null -eq $this.NavigationService) {
            $this.NavigationService = $this.ServiceContainer.GetService("NavigationService")
        }
        
        # Navigate to the dialog - NavigationService handles focus saving
        if ($this.NavigationService) {
            $this.NavigationService.NavigateTo($dialog)
        } else {
            throw [System.InvalidOperationException]::new("NavigationService not available")
        }
        
        # Write-Log -Level Info -Message "DialogManager: Showing dialog '$($dialog.Name)'."
    }

    [void] HideDialog([object]$dialog) {
        # This method is now just a convenience wrapper
        # Dialogs should call NavigationService.GoBack() themselves via Complete()
        Write-Log -Level Warning -Message "DialogManager.HideDialog is deprecated. Use dialog.Complete() instead."
        
        # For backward compatibility, try to navigate back
        if ($null -eq $this.NavigationService) {
            $this.NavigationService = $this.ServiceContainer.GetService("NavigationService")
        }
        
        if ($this.NavigationService -and $this.NavigationService.CanGoBack()) {
            $this.NavigationService.GoBack()
        }
    }

    [void] Cleanup() {
        # Nothing to clean up - NavigationService manages all windows
        # Write-Log -Level Debug -Message "DialogManager: Cleanup complete."
    }
}

#endregion
#<!-- END_PAGE: ASE.009 -->



####\Services\ASE.007_KeybindingService.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - KeybindingService
# Global keyboard shortcut management
# ==============================================================================

class KeybindingService {
    [hashtable]$KeyMap = @{}
    [hashtable]$GlobalHandlers = @{}
    [System.Collections.Generic.Stack[hashtable]]$ContextStack
    [ActionService]$ActionService
    [bool]$EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.Stack[hashtable]]::new()
        $this._InitializeDefaultBindings()
    }
    
    KeybindingService([ActionService]$actionService) {
        $this.ActionService = $actionService
        $this.ContextStack = [System.Collections.Generic.Stack[hashtable]]::new()
        $this._InitializeDefaultBindings()
    }
    
    hidden [void] _InitializeDefaultBindings() {
        # Global navigation
        $this.SetBinding("Ctrl+Q", "app.exit", "Global")
        $this.SetBinding("F1", "app.help", "Global")
        $this.SetBinding("Ctrl+P", "app.commandPalette", "Global")
        
        # Tab navigation - but DON'T bind number keys globally
        $this.SetBinding("Tab", "navigation.nextComponent", "Global")
        $this.SetBinding("Shift+Tab", "navigation.previousComponent", "Global")
        
        # Arrow keys removed - handled by focused components instead
        
        Write-Log -Level Debug -Message "KeybindingService: Initialized default bindings"
    }
    
    [void] SetBinding([string]$keyPattern, [string]$actionName, [string]$context = "Global") {
        if (-not $this.KeyMap.ContainsKey($context)) {
            $this.KeyMap[$context] = @{}
        }
        
        $this.KeyMap[$context][$keyPattern] = $actionName
        Write-Log -Level Debug -Message "KeybindingService: Bound $keyPattern to $actionName in context $context"
    }
    
    [void] RemoveBinding([string]$keyPattern, [string]$context = "Global") {
        if ($this.KeyMap.ContainsKey($context)) {
            $this.KeyMap[$context].Remove($keyPattern)
            Write-Log -Level Debug -Message "KeybindingService: Removed binding for $keyPattern from context $context"
        }
    }
    
    [bool] IsAction([System.ConsoleKeyInfo]$keyInfo, [string]$actionName) {
        $keyPattern = $this._GetKeyPattern($keyInfo)
        
        # Check current context stack
        foreach ($context in $this.ContextStack) {
            if ($context.ContainsKey($keyPattern) -and $context[$keyPattern] -eq $actionName) {
                return $true
            }
        }
        
        # Check global context
        if ($this.KeyMap.ContainsKey("Global") -and 
            $this.KeyMap["Global"].ContainsKey($keyPattern) -and 
            $this.KeyMap["Global"][$keyPattern] -eq $actionName) {
            return $true
        }
        
        return $false
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        $keyPattern = $this._GetKeyPattern($keyInfo)
        
        # Log key pattern for debugging
        if ($keyPattern -match "Ctrl") {
            Write-Log -Level Debug -Message "KeybindingService: Looking up action for $keyPattern"
        }
        
        # Check current context stack (most recent first)
        foreach ($context in $this.ContextStack) {
            if ($context.ContainsKey($keyPattern)) {
                Write-Log -Level Debug -Message "KeybindingService: Found action in context stack: $($context[$keyPattern])"
                return $context[$keyPattern]
            }
        }
        
        # Check global context
        if ($this.KeyMap.ContainsKey("Global") -and $this.KeyMap["Global"].ContainsKey($keyPattern)) {
            Write-Log -Level Debug -Message "KeybindingService: Found global action: $($this.KeyMap["Global"][$keyPattern])"
            return $this.KeyMap["Global"][$keyPattern]
        }
        
        return $null
    }
    
    [string] GetBindingDescription([System.ConsoleKeyInfo]$keyInfo) {
        $action = $this.GetAction($keyInfo)
        if ($action -and $this.ActionService) {
            $actionData = $this.ActionService.GetAction($action)
            if ($actionData) {
                return $actionData.Description
            }
        }
        return ""
    }
    
    hidden [string] _GetKeyPattern([System.ConsoleKeyInfo]$keyInfo) {
        $parts = @()
        
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
            $parts += "Ctrl"
        }
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt) {
            $parts += "Alt"
        }
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift) {
            $parts += "Shift"
        }
        
        # Use Key enum for special keys, KeyChar for regular characters
        if ($keyInfo.Key -ne [ConsoleKey]::None -and 
            ($keyInfo.Key -lt [ConsoleKey]::D0 -or $keyInfo.Key -gt [ConsoleKey]::Z)) {
            $parts += $keyInfo.Key.ToString()
        }
        elseif ($keyInfo.KeyChar -ne [char]0) {
            $parts += [char]::ToUpper($keyInfo.KeyChar).ToString()
        }
        
        return $parts -join "+"
    }
    
    [void] PushContext([hashtable]$contextBindings) {
        $this.ContextStack.Push($contextBindings)
        Write-Log -Level Debug -Message "KeybindingService: Pushed new context with $($contextBindings.Count) bindings"
    }
    
    [void] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $removed = $this.ContextStack.Pop()
            Write-Log -Level Debug -Message "KeybindingService: Popped context with $($removed.Count) bindings"
        }
    }
    
    [void] RegisterGlobalHandler([string]$handlerId, [scriptblock]$handler) {
        $this.GlobalHandlers[$handlerId] = $handler
        Write-Log -Level Debug -Message "KeybindingService: Registered global handler $handlerId"
    }
    
    [void] UnregisterGlobalHandler([string]$handlerId) {
        $this.GlobalHandlers.Remove($handlerId)
        Write-Log -Level Debug -Message "KeybindingService: Unregistered global handler $handlerId"
    }
    
    [void] SetDefaultBindings() {
        # Application control
        $this.SetBinding("Ctrl+Q", "app.exit", "Global")
        $this.SetBinding("F1", "app.help", "Global")
        $this.SetBinding("Ctrl+P", "app.commandPalette", "Global")
        
        # Component navigation
        $this.SetBinding("Tab", "navigation.nextComponent", "Global")
        $this.SetBinding("Shift+Tab", "navigation.previousComponent", "Global")
        
        # Screen navigation
        $this.SetBinding("Escape", "navigation.back", "Global")
        
        Write-Log -Level Debug -Message "KeybindingService: Set default bindings"
    }
}

#endregion



####\Services\ASE.008_NavigationService.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

using namespace System.Collections.Generic
using namespace System.Collections.Concurrent
using namespace System.Management.Automation
using namespace System.Threading

#region NavigationService Class

# ===== CLASS: NavigationService =====
# Module: navigation-service (from axiom)
# Dependencies: ServiceContainer, EventManager (optional)
# Purpose: Screen navigation and history management
class NavigationService {
    [System.Collections.Generic.Stack[object]]$NavigationStack = [System.Collections.Generic.Stack[object]]::new() # Changed from Stack[Screen] to Stack[object]
    [object]$CurrentScreen # Changed from [Screen] to [object]
    [hashtable]$ScreenRegistry = @{}
    [int]$MaxStackSize = 10
    [object]$ServiceContainer # Store the container as object to avoid type issues

    # Updated constructor that takes ServiceContainer directly (as object to avoid type conversion issues)
    NavigationService([object]$serviceContainer) {
        if ($null -eq $serviceContainer) {
            throw [System.ArgumentNullException]::new("serviceContainer")
        }
        # Verify it's actually a ServiceContainer at runtime
        if ($serviceContainer.GetType().Name -ne 'ServiceContainer') {
            throw [System.ArgumentException]::new("Expected ServiceContainer but got $($serviceContainer.GetType().Name)")
        }
        $this.ServiceContainer = $serviceContainer
        # No need to store EventManager separately - get it when needed
    }

    # NEW: Get the window stack for rendering
    [object[]] GetWindows() {
        # Build array with current screen at the end (top of stack)
        $windows = @()
        
        # Add all screens from navigation stack (bottom to top)
        $stackArray = $this.NavigationStack.ToArray()
        for ($i = $stackArray.Length - 1; $i -ge 0; $i--) {
            $windows += $stackArray[$i]
        }
        
        # Add current screen on top
        if ($this.CurrentScreen) {
            $windows += $this.CurrentScreen
        }
        
        return $windows
    }

    # IMPORTANT: Update NavigateTo method
    [void] NavigateTo([object]$screen) {
        if ($null -eq $screen) { throw [System.ArgumentNullException]::new("screen", "Cannot navigate to a null screen.") }
        
        # Verify it's actually a Screen at runtime
        if (-not ($screen.PSObject.Properties['ServiceContainer'] -and 
                  $screen.PSObject.Methods['Initialize'] -and
                  $screen.PSObject.Methods['OnEnter'])) {
            throw [System.ArgumentException]::new("Expected Screen-derived object but got $($screen.GetType().Name)")
        }
        
        try {
            # NEW: If navigating to an overlay, save focus state
            if ($screen.IsOverlay) {
                $focusManager = $this.ServiceContainer.GetService("FocusManager")
                if ($focusManager) {
                    $focusManager.PushFocusState()
                }
            }
            
            # Exit current screen if one exists
            if ($this.CurrentScreen) {
                # Write-Log -Level Debug -Message "NavigationService: Exiting screen '$($this.CurrentScreen.Name)'"
                $this.CurrentScreen.OnExit()
                $this.NavigationStack.Push($this.CurrentScreen)
                
                # Limit stack size (optional, complex to trim from bottom of Stack)
                # If MaxStackSize is critical, consider switching NavigationStack to List<Screen> and managing explicitly.
            }
            
            # Enter new screen
            $this.CurrentScreen = $screen
            # Write-Log -Level Debug -Message "NavigationService: Entering screen '$($screen.Name)'"
            
            # Initialize if not already (screens passed via registry should be initialized via factory)
            if (-not $screen._isInitialized) {
                # Write-Log -Level Debug -Message "NavigationService: Initializing screen '$($screen.Name)'"
                $screen.Initialize()
                $screen._isInitialized = $true
            }
            
            # Resize screen to match current console dimensions
            $width = [Math]::Max(80, $global:TuiState.BufferWidth)
            $height = [Math]::Max(24, $global:TuiState.BufferHeight)
            $screen.Resize($width, $height)
            
            $screen.OnEnter() # Call lifecycle method
            
            # Publish navigation event
            $eventManager = $this.ServiceContainer.GetService("EventManager")
            if ($eventManager) {
                $eventManager.Publish("Navigation.ScreenChanged", @{
                    Screen = $screen
                    ScreenName = $screen.Name
                    StackDepth = $this.NavigationStack.Count
                })
            }
            
            # Update global TUI state (CRITICAL FIX)
            $global:TuiState.CurrentScreen = $screen
            $global:TuiState.IsDirty = $true # Force redraw
            $global:TuiState.FocusedComponent = $null # Clear focus, screen OnEnter should set new focus

        }
        catch {
            Write-Error "NavigationService: Failed to navigate to screen '$($screen.Name)': $_"
            throw
        }
    }

    [void] NavigateToByName([string]$screenName) {
        if (-not $this.ScreenRegistry.ContainsKey($screenName)) {
            throw [System.ArgumentException]::new("Screen '$screenName' not found in registry. Registered: $($this.ScreenRegistry.Keys -join ', ').", "screenName")
        }
        
        $this.NavigateTo($this.ScreenRegistry[$screenName])
    }
    
    [bool] CanGoBack() {
        return $this.NavigationStack.Count -gt 0
    }
    
    # IMPORTANT: Update GoBack method
    [void] GoBack() {
        if (-not $this.CanGoBack()) {
            # Write-Log -Level Warning -Message "NavigationService: Cannot go back - navigation stack is empty"
            return
        }
        
        try {
            # Exit current screen
            $exitingScreen = $this.CurrentScreen
            if ($exitingScreen) {
                # Write-Log -Level Debug -Message "NavigationService: Exiting screen '$($exitingScreen.Name)' (going back)"
                $exitingScreen.OnExit()
                $exitingScreen.Cleanup() # Clean up the screen being exited/popped
                
                # NEW: If exiting an overlay, restore focus state
                if ($exitingScreen.IsOverlay) {
                    $focusManager = $this.ServiceContainer.GetService("FocusManager")
                    if ($focusManager) {
                        $focusManager.PopFocusState()
                    }
                }
            }
            
            # Pop and resume previous screen
            $previousScreen = $this.NavigationStack.Pop()
            $this.CurrentScreen = $previousScreen
            
            # Write-Log -Level Debug -Message "NavigationService: Resuming screen '$($previousScreen.Name)'"
            
            # Resize screen to match current console dimensions
            $previousScreen.Resize($global:TuiState.BufferWidth, $global:TuiState.BufferHeight)

            $previousScreen.OnResume() # Call lifecycle method
            
            # Publish navigation event
            $eventManager = $this.ServiceContainer.GetService("EventManager")
            if ($eventManager) {
                $eventManager.Publish("Navigation.BackNavigation", @{
                    Screen = $previousScreen
                    ScreenName = $previousScreen.Name
                    StackDepth = $this.NavigationStack.Count
                })
            }
            
            # Update global TUI state (CRITICAL FIX)
            $global:TuiState.CurrentScreen = $previousScreen
            $global:TuiState.IsDirty = $true # Force redraw
            $global:TuiState.FocusedComponent = $null # Clear focus, screen OnResume should set new focus

        }
        catch {
            Write-Error "NavigationService: Failed to go back: $_"
            throw
        }
    }
    
    [void] Reset() {
        # Cleanup all screens in stack and current screen
        while ($this.NavigationStack.Count -gt 0) {
            $screen = $this.NavigationStack.Pop()
            try { $screen.Cleanup() } catch { # Write-Log -Level Warning -Message "NavigationService: Error cleaning up stacked screen '$($screen.Name)': $($_.Exception.Message)" }
            }
        }
        
        if ($this.CurrentScreen) {
            try { 
                $this.CurrentScreen.OnExit()
                $this.CurrentScreen.Cleanup() 
            } catch { # Write-Log -Level Warning -Message "NavigationService: Error cleaning up current screen '$($this.CurrentScreen.Name)': $($_.Exception.Message)" }
            }
            $this.CurrentScreen = $null
        }
        # Write-Log -Level Debug -Message "NavigationService: Reset complete, all screens cleaned up."
    }
}

#endregion
#<!-- END_PAGE: ASE.004 -->



####\Services\ASE.009_DialogManager.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - DialogManager Service
# Manages modal dialogs using the window-based navigation model
# ==============================================================================

# ===== CLASS: DialogManager =====
# Module: dialog-manager
# Dependencies: NavigationService
# Purpose: Helper service for showing dialogs via NavigationService
class DialogManager {
    [object]$NavigationService = $null
    [object]$ServiceContainer = $null

    DialogManager([object]$serviceContainer) {
        $this.ServiceContainer = $serviceContainer
        $this.NavigationService = $serviceContainer.GetService("NavigationService")
        
        Write-Log -Level Debug -Message "DialogManager: Initialized with window-based model."
    }

    [void] ShowDialog([Dialog]$dialog) {
        if ($null -eq $dialog) {
            throw [System.ArgumentException]::new("Dialog cannot be null.", "dialog")
        }
        
        # WINDOW-BASED MODEL: Use NavigationService to show dialog as a window
        if ($this.NavigationService) {
            Write-Log -Level Debug -Message "DialogManager: Showing dialog '$($dialog.Name)' via NavigationService"
            
            # Initialize dialog if needed
            if ($dialog.PSObject.Methods['Initialize'] -and -not $dialog._isInitialized) {
                $dialog.Initialize()
                $dialog._isInitialized = $true
            }
            
            # Navigate to the dialog
            $this.NavigationService.NavigateTo($dialog)
        } else {
            Write-Log -Level Error -Message "DialogManager: NavigationService not available"
        }
    }

    [void] HideDialog([Dialog]$dialog) {
        # WINDOW-BASED MODEL: Dialog handles its own closing via Complete() method
        # which calls NavigationService.GoBack()
        Write-Log -Level Debug -Message "DialogManager: Dialog '$($dialog.Name)' will close itself via GoBack"
    }
    
    [void] ShowAlert([string]$title, [string]$message) {
        $alert = [AlertDialog]::new("Alert", $this.ServiceContainer)
        $alert.Show($title, $message)
        $this.ShowDialog($alert)
    }
    
    [void] ShowConfirm([string]$title, [string]$message, [scriptblock]$onConfirm, [scriptblock]$onCancel) {
        $confirm = [ConfirmDialog]::new("Confirm", $this.ServiceContainer)
        $confirm.Show($title, $message)
        $confirm.OnConfirm = $onConfirm
        $confirm.OnCancel = $onCancel
        $this.ShowDialog($confirm)
    }
    
    [object] ShowInput([string]$title, [string]$prompt, [string]$defaultValue) {
        $input = [InputDialog]::new("Input", $this.ServiceContainer)
        $input.Show($title, $prompt)
        $input.DefaultValue = $defaultValue
        $this.ShowDialog($input)
        return $input.Result
    }

    [void] Cleanup() {
        # Nothing to cleanup in window-based model
        Write-Log -Level Debug -Message "DialogManager: Cleanup complete."
    }
}

#<!-- END_PAGE: ASE.009 -->



####\Services\ASE.010_TuiFrameworkService.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

#region TuiFrameworkService - Framework State Management

# ==============================================================================
# CLASS: TuiFrameworkService
#
# INHERITS: N/A
#
# DEPENDENCIES: None (directly accesses global state)
#
# PURPOSE:
#   Provides a clean service interface for accessing framework state and
#   dimensions instead of components directly accessing $global:TuiState.
#   This encapsulates global state access and provides a more maintainable
#   architecture.
#
# KEY LOGIC:
#   - GetDimensions: Returns current buffer dimensions
#   - GetCurrentScreen: Returns the currently active screen
#   - IsRunning: Returns whether the engine is running
#   - RequestRedraw: Marks the global state as dirty for redraw
#   - GetFrameCount: Returns current frame count for debugging
# ==============================================================================
class TuiFrameworkService {
    [hashtable]$_globalState = $null
    
    TuiFrameworkService() {
        $this._globalState = $global:TuiState
        Write-Log -Level Debug -Message "TuiFrameworkService: Initialized with global state access"
    }
    
    [hashtable] GetDimensions() {
        return @{
            Width = $this._globalState.BufferWidth
            Height = $this._globalState.BufferHeight
        }
    }
    
    [int] GetWidth() {
        return $this._globalState.BufferWidth
    }
    
    [int] GetHeight() {
        return $this._globalState.BufferHeight
    }
    
    [object] GetCurrentScreen() {
        return $this._globalState.CurrentScreen
    }
    
    [bool] IsRunning() {
        return $this._globalState.Running
    }
    
    [void] RequestRedraw() {
        $this._globalState.IsDirty = $true
    }
    
    [int] GetFrameCount() {
        return $this._globalState.FrameCount
    }
    
    [object] GetCompositorBuffer() {
        return $this._globalState.CompositorBuffer
    }
    
    [object] GetFocusedComponent() {
        return $this._globalState.FocusedComponent
    }
    
    [System.Collections.Generic.List[UIElement]] GetOverlayStack() {
        return $this._globalState.OverlayStack
    }
    
    [void] AddOverlay([UIElement]$overlay) {
        $this._globalState.OverlayStack.Add($overlay)
        $this.RequestRedraw()
    }
    
    [bool] RemoveOverlay([UIElement]$overlay) {
        $removed = $this._globalState.OverlayStack.Remove($overlay)
        if ($removed) {
            $this.RequestRedraw()
        }
        return $removed
    }
    
    [void] Cleanup() {
        Write-Log -Level Debug -Message "TuiFrameworkService: Cleanup completed"
        # No cleanup needed - just reports completion
    }
}

#endregion
#<!-- END_PAGE: ASE.010 -->



####\Services\ASE.011_ViewDefinitionService.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

# ===== CLASS: ViewDefinitionService =====  
# Module: view-definition-service
# Dependencies: None
# Purpose: Centralized service for defining how data models are presented in UI components
class ViewDefinitionService {
    hidden [hashtable]$_definitions = @{}
    
    ViewDefinitionService() {
        $this._RegisterDefaultViewDefinitions()
    }
    
    [hashtable] GetViewDefinition([string]$viewName) {
        if (-not $this._definitions.ContainsKey($viewName)) {
            throw "View definition '$viewName' not found. Available definitions: $($this._definitions.Keys -join ', ')"
        }
        return $this._definitions[$viewName]
    }
    
    [void] RegisterViewDefinition([string]$viewName, [hashtable]$definition) {
        if ([string]::IsNullOrWhiteSpace($viewName)) {
            throw "View name cannot be null or empty"
        }
        
        if (-not $definition -or -not $definition.ContainsKey("Columns") -or -not $definition.ContainsKey("Transformer")) {
            throw "View definition must contain 'Columns' and 'Transformer' keys"
        }
        
        $this._definitions[$viewName] = $definition
    }
    
    [string[]] GetAvailableViewNames() {
        return $this._definitions.Keys
    }
    
    hidden [void] _RegisterDefaultViewDefinitions() {
        # Task summary view for lists and grids
        $this.RegisterViewDefinition('task.summary', @{
            Columns = @(
                @{ Name="Status";   Header="S"; Width=3 },
                @{ Name="Priority"; Header="!"; Width=3 },
                @{ Name="Title";    Header="Task Title"; Width=40 },
                @{ Name="Progress"; Header="Progress"; Width=8 }
            )
            Transformer = {
                param($task)
                
                # Status indicator  
                $statusChar = switch ($task.Status) {
                    ([TaskStatus]::Pending) { "o" }
                    ([TaskStatus]::InProgress) { "*" }
                    ([TaskStatus]::Completed) { "✓" }
                    ([TaskStatus]::Cancelled) { "✗" }
                    default { "?" }
                }
                
                # Priority indicator
                $priorityChar = switch ($task.Priority) {
                    ([TaskPriority]::Low) { "↓" }
                    ([TaskPriority]::Medium) { "-" }
                    ([TaskPriority]::High) { "↑" }
                    default { "-" }
                }
                
                # Progress display
                $progressText = "$($task.Progress)%"
                
                return @{
                    Status   = $statusChar
                    Priority = $priorityChar  
                    Title    = $task.Title
                    Progress = $progressText
                }
            }
        })
        
        # Task detail view with more information
        $this.RegisterViewDefinition('task.detailed', @{
            Columns = @(
                @{ Name="Status";     Header="Status"; Width=12 },
                @{ Name="Priority";   Header="Priority"; Width=10 },
                @{ Name="Title";      Header="Task Title"; Width=30 },
                @{ Name="Progress";   Header="Progress"; Width=10 },
                @{ Name="DueDate";    Header="Due Date"; Width=12 },
                @{ Name="Project";    Header="Project"; Width=15 }
            )
            Transformer = {
                param($task)
                
                # Full status name
                $statusText = switch ($task.Status) {
                    ([TaskStatus]::Pending) { "Pending" }
                    ([TaskStatus]::InProgress) { "In Progress" }
                    ([TaskStatus]::Completed) { "Completed" }
                    ([TaskStatus]::Cancelled) { "Cancelled" }
                    default { "Unknown" }
                }
                
                # Full priority name
                $priorityText = switch ($task.Priority) {
                    ([TaskPriority]::Low) { "Low" }
                    ([TaskPriority]::Medium) { "Medium" }
                    ([TaskPriority]::High) { "High" }
                    default { "Unknown" }
                }
                
                # Formatted due date
                $dueDateText = if ($task.DueDate) {
                    $task.DueDate.ToString("MM/dd/yyyy")
                } else {
                    "None"
                }
                
                # Progress with bar
                $progressText = "$($task.Progress)%"
                
                # Project key or default
                $projectText = if ($task.ProjectKey) { $task.ProjectKey } else { "None" }
                
                return @{
                    Status   = $statusText
                    Priority = $priorityText
                    Title    = $task.Title
                    Progress = $progressText
                    DueDate  = $dueDateText
                    Project  = $projectText
                }
            }
        })
        
        # Compact task view for narrow displays
        $this.RegisterViewDefinition('task.compact', @{
            Columns = @(
                @{ Name="Status";   Header="S"; Width=1 },
                @{ Name="Title";    Header="Task"; Width=30 }
            )
            Transformer = {
                param($task)
                
                # Single character status
                $statusChar = switch ($task.Status) {
                    ([TaskStatus]::Pending) { "○" }
                    ([TaskStatus]::InProgress) { "◐" }
                    ([TaskStatus]::Completed) { "●" }
                    ([TaskStatus]::Cancelled) { "✗" }
                    default { "?" }
                }
                
                return @{
                    Status = $statusChar
                    Title  = $task.Title
                }
            }
        })
        
        # Project summary view
        $this.RegisterViewDefinition('project.summary', @{
            Columns = @(
                @{ Name="Key";        Header="Key"; Width=10 },
                @{ Name="Name";       Header="Project Name"; Width=30 },
                @{ Name="Status";     Header="Status"; Width=10 },
                @{ Name="Owner";      Header="Owner"; Width=15 }
            )
            Transformer = {
                param($project)
                
                $statusText = if ($project.IsActive) { "Active" } else { "Inactive" }
                $ownerText = if ($project.Owner) { $project.Owner } else { "Unassigned" }
                
                return @{
                    Key    = $project.Key
                    Name   = $project.Name
                    Status = $statusText
                    Owner  = $ownerText
                }
            }
        })
        
        # Dashboard recent tasks view - compact for overview
        $this.RegisterViewDefinition('dashboard.recent.tasks', @{
            Columns = @(
                @{ Name="Status";   Header="S"; Width=1 },
                @{ Name="Priority"; Header="!"; Width=1 },
                @{ Name="Title";    Header="Recent Tasks"; Width=35 },
                @{ Name="Age";      Header="Age"; Width=8 }
            )
            Transformer = {
                param($task)
                
                # Status indicator with unicode symbols
                $statusChar = switch ($task.Status) {
                    ([TaskStatus]::Pending) { "○" }
                    ([TaskStatus]::InProgress) { "◐" }
                    ([TaskStatus]::Completed) { "●" }
                    ([TaskStatus]::Cancelled) { "✗" }
                    default { "?" }
                }
                
                # Priority indicator
                $priorityChar = switch ($task.Priority) {
                    ([TaskPriority]::Low) { "↓" }
                    ([TaskPriority]::Medium) { "→" }
                    ([TaskPriority]::High) { "↑" }
                    default { "?" }
                }
                
                # Calculate age in days
                $age = [DateTime]::Now - $task.CreatedAt
                $ageText = if ($age.Days -gt 0) {
                    "$($age.Days)d"
                } elseif ($age.Hours -gt 0) {
                    "$($age.Hours)h"
                } else {
                    "$($age.Minutes)m"
                }
                
                return @{
                    Status   = $statusChar
                    Priority = $priorityChar
                    Title    = $task.Title
                    Age      = $ageText
                }
            }
        })
        
        # Dashboard summary statistics view
        $this.RegisterViewDefinition('dashboard.task.stats', @{
            Columns = @(
                @{ Name="Metric";    Header="Task Statistics"; Width=20 },
                @{ Name="Value";     Header="Count"; Width=8 },
                @{ Name="Indicator"; Header=""; Width=5 }
            )
            Transformer = {
                param($statsData)
                
                # This transformer expects a hashtable with metrics
                # Example: @{ Name="Total Tasks"; Count=15; Type="info" }
                
                $indicator = switch ($statsData.Type) {
                    "success" { "✓" }
                    "warning" { "⚠" }
                    "error" { "✗" }
                    "info" { "ⓘ" }
                    default { " " }
                }
                
                return @{
                    Metric    = $statsData.Name
                    Value     = $statsData.Count.ToString()
                    Indicator = $indicator
                }
            }
        })
        
        # Dashboard navigation menu view
        $this.RegisterViewDefinition('dashboard.navigation', @{
            Columns = @(
                @{ Name="Key";         Header="Key"; Width=5 },
                @{ Name="Action";      Header="Quick Actions"; Width=25 },
                @{ Name="Description"; Header="Description"; Width=20 }
            )
            Transformer = {
                param($navItem)
                
                return @{
                    Key         = "[$($navItem.Key)]"
                    Action      = $navItem.Name
                    Description = $navItem.Description
                }
            }
        })
    }
}
#<!-- END_PAGE: ASE.011 -->



####\Services\ASE.012_AsyncJobService.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - All Services (Load After Components)
# Core application services: action, navigation, data, theming, logging, events
# ==============================================================================
#
# TABLE OF CONTENTS DIRECTIVE:
# When modifying this file, ensure page markers remain accurate and update
# TableOfContents.md to reflect any structural changes.
#
# Search for "PAGE: ASE.###" to find specific sections.
# Each section ends with "END_PAGE: ASE.###"
# ==============================================================================

#region AsyncJobService Class

# ===== CLASS: AsyncJobService =====
# Module: async-jobs (from axiom)
# Dependencies: None
# Purpose: Framework utilities and async operations
class AsyncJobService {
    [hashtable]$AsyncJobs = @{}
    [int]$NextJobId = 1
    [bool]$IsRunning = $false
    
    AsyncJobService() {
        # Write-Verbose "AsyncJobService: Initialized"
    }
    
    [hashtable] StartAsync([scriptblock]$work, [string]$name = "") {
        try {
            $jobId = $this.NextJobId++
            $jobName = if ($name) { $name } else { "AsyncJob_$jobId" }
            
            # Use ThreadJob for lightweight async operations
            $job = Start-ThreadJob -ScriptBlock $work -Name $jobName
            
            $jobInfo = @{
                Id = $jobId
                Name = $jobName
                Job = $job
                StartedAt = [DateTime]::Now
                Status = "Running"
            }
            
            $this.AsyncJobs[$jobId] = $jobInfo
            
            # Write-Verbose "AsyncJobService: Started async job '$jobName' with ID $jobId"
            return $jobInfo
        }
        catch {
            Write-Error "Failed to start async job: $_"
            throw
        }
    }
    
    [object] GetAsyncResults([int]$jobId, [bool]$wait = $false) {
        if (-not $this.AsyncJobs.ContainsKey($jobId)) {
            throw "Async job with ID $jobId not found"
        }
        
        $jobInfo = $this.AsyncJobs[$jobId]
        $job = $jobInfo.Job
        
        if ($wait) {
            # Write-Verbose "AsyncJobService: Waiting for job $jobId to complete"
            Wait-Job -Job $job | Out-Null
        }
        
        if ($job.State -eq "Completed") {
            $result = Receive-Job -Job $job -Keep
            $jobInfo.Status = "Completed"
            return $result
        }
        elseif ($job.State -eq "Failed") {
            $jobInfo.Status = "Failed"
            $error = Receive-Job -Job $job -Keep
            throw "Async job $jobId failed: $error"
        }
        else {
            return $null
        }
    }
    
    [void] StopAllAsyncJobs() {
        # Write-Verbose "AsyncJobService: Stopping all async jobs"
        
        foreach ($jobInfo in $this.AsyncJobs.Values) {
            try {
                if ($jobInfo.Job.State -eq "Running") {
                    Stop-Job -Job $jobInfo.Job
                    Remove-Job -Job $jobInfo.Job -Force
                }
            }
            catch {
                Write-Warning "Failed to stop job $($jobInfo.Id): $_"
            }
        }
        
        $this.AsyncJobs.Clear()
    }
    
    [hashtable] GetState() {
        return @{
            IsRunning = $this.IsRunning
            AsyncJobCount = $this.AsyncJobs.Count
            ActiveJobs = $this.AsyncJobs.Values | Where-Object { $_.Status -eq "Running" } | Measure-Object | Select-Object -ExpandProperty Count
        }
    }
    
    [bool] IsRunning() {
        return $this.IsRunning
    }
    
    [void] Start() {
        $this.IsRunning = $true
        # Write-Verbose "AsyncJobService: Started"
    }
    
    [void] Stop() {
        $this.StopAllAsyncJobs()
        $this.IsRunning = $false
        # Write-Verbose "AsyncJobService: Stopped"
    }
    
    [void] Cleanup() {
        $this.Stop()
    }
}

#endregion
#<!-- END_PAGE: ASE.008 -->



####\APPLY_ALL_FIXES.ps1
# COMPLETE FIXES FOR AXIOM-PHOENIX v4.0
# Applying all fixes from REAL_FIX.ps1 plus additional syntax fixes

Write-Host "Applying ALL fixes to Axiom-Phoenix v4.0..." -ForegroundColor Yellow

# FIX 1: Fix syntax errors in TaskListScreen first
Write-Host "`nFixing TaskListScreen syntax errors..." -ForegroundColor Cyan
$taskListPath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AxiomPhoenix_v4_Split\Screens\ASC.002_TaskListScreen.ps1"
$content = Get-Content $taskListPath -Raw

# Fix all HandleInput method signatures missing closing parenthesis
$content = $content -replace '\[bool\]\s+HandleInput\(\[System\.ConsoleKeyInfo\]\$keyInfo\s*$', '[bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {'

# Save fixed content
Set-Content -Path $taskListPath -Value $content -Force
Write-Host "  - Fixed HandleInput method signatures" -ForegroundColor Green

# FIX 2: Apply the Theme Screen from REAL_FIX.ps1
Write-Host "`nApplying Theme Screen fix..." -ForegroundColor Cyan
$themeScreenPath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AxiomPhoenix_v4_Split\Screens\ASC.003_ThemeScreen.ps1"
$themeScreenContent = @'
# ==============================================================================
# Axiom-Phoenix v4.0 - Theme Selection Screen - FIXED VERSION
# ==============================================================================

class ThemeScreen : Screen {
    # UI Components
    hidden [Panel]$_mainPanel
    hidden [ListBox]$_themeList
    hidden [Panel]$_previewPanel
    hidden [LabelComponent]$_titleLabel
    hidden [LabelComponent]$_descriptionLabel
    hidden [LabelComponent]$_statusLabel
    hidden [LabelComponent]$_previewTextLabel
    hidden [LabelComponent]$_previewButtonLabel
    hidden [LabelComponent]$_previewListLabel
    
    # Available themes with hex colors
    hidden [hashtable[]]$_themes = @(
        @{
            Name = "Default"
            Description = "Classic terminal colors with blue accents"
            Colors = @{
                "Background" = "#000000"
                "Foreground" = "#C0C0C0"
                "Primary" = "#0000FF"
                "Secondary" = "#000080"
                "Accent" = "#00FFFF"
                "Success" = "#00FF00"
                "Warning" = "#FFFF00"
                "Error" = "#FF0000"
                "Info" = "#00FFFF"
                "component.background" = "#000000"
                "component.border" = "#808080"
                "component.title" = "#00FFFF"
                "button.focused.fg" = "#FFFFFF"
                "button.focused.bg" = "#0000FF"
                "list.item.selected" = "#FFFFFF"
                "list.item.selected.background" = "#000080"
            }
        }
        @{
            Name = "Green Console"
            Description = "Classic green phosphor terminal look"
            Colors = @{
                "Background" = "#000000"
                "Foreground" = "#00FF00"
                "Primary" = "#00FF00"
                "Secondary" = "#008000"
                "Accent" = "#00FF00"
                "Success" = "#00FF00"
                "Warning" = "#FFFF00"
                "Error" = "#FF0000"
                "Info" = "#00FF00"
                "component.background" = "#000000"
                "component.border" = "#008000"
                "component.title" = "#00FF00"
                "button.focused.fg" = "#000000"
                "button.focused.bg" = "#00FF00"
                "list.item.selected" = "#000000"
                "list.item.selected.background" = "#00FF00"
            }
        }
        @{
            Name = "Amber Console"
            Description = "Warm amber monochrome terminal"
            Colors = @{
                "Background" = "#000000"
                "Foreground" = "#FFFF00"
                "Primary" = "#FFFF00"
                "Secondary" = "#808000"
                "Accent" = "#FFFF00"
                "Success" = "#00FF00"
                "Warning" = "#FFFF00"
                "Error" = "#FF0000"
                "Info" = "#FFFF00"
                "component.background" = "#000000"
                "component.border" = "#808000"
                "component.title" = "#FFFF00"
                "button.focused.fg" = "#000000"
                "button.focused.bg" = "#FFFF00"
                "list.item.selected" = "#000000"
                "list.item.selected.background" = "#FFFF00"
            }
        }
        @{
            Name = "Notepad Style"
            Description = "Clean white background with black text"
            Colors = @{
                "Background" = "#FFFFFF"
                "Foreground" = "#000000"
                "Primary" = "#000080"
                "Secondary" = "#C0C0C0"
                "Accent" = "#0000FF"
                "Success" = "#008000"
                "Warning" = "#808000"
                "Error" = "#800000"
                "Info" = "#008080"
                "component.background" = "#FFFFFF"
                "component.border" = "#808080"
                "component.title" = "#000080"
                "button.focused.fg" = "#FFFFFF"
                "button.focused.bg" = "#000080"
                "list.item.selected" = "#FFFFFF"
                "list.item.selected.background" = "#0000FF"
            }
        }
    )
    
    ThemeScreen([ServiceContainer]$container) : base("ThemeScreen", $container) {
    }
    
    [void] Initialize() {
        # Main panel
        $this._mainPanel = [Panel]::new("ThemeScreen_MainPanel")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.HasBorder = $true
        $this._mainPanel.BorderStyle = "Single"
        $this._mainPanel.Title = " Theme Selection "
        $this.AddChild($this._mainPanel)
        
        # Title
        $this._titleLabel = [LabelComponent]::new("ThemeScreen_Title")
        $this._titleLabel.Text = "Select a Theme"
        $this._titleLabel.X = 2
        $this._titleLabel.Y = 1
        $this._titleLabel.ForegroundColor = Get-ThemeColor "Primary"
        $this._mainPanel.AddChild($this._titleLabel)
        
        # Theme list - fixed width
        $this._themeList = [ListBox]::new("ThemeScreen_List")
        $this._themeList.X = 2
        $this._themeList.Y = 3
        $this._themeList.Width = 30  # Fixed width
        $this._themeList.Height = $this._mainPanel.Height - 8
        $this._themeList.HasBorder = $true
        $this._themeList.BorderStyle = "Single"
        $this._themeList.Title = " Themes "
        $this._themeList.IsFocusable = $true
        $this._mainPanel.AddChild($this._themeList)
        
        # Preview panel - rest of the width
        $previewX = $this._themeList.X + $this._themeList.Width + 2
        $this._previewPanel = [Panel]::new("ThemeScreen_Preview")
        $this._previewPanel.X = $previewX
        $this._previewPanel.Y = 3
        $this._previewPanel.Width = $this._mainPanel.Width - $previewX - 2
        $this._previewPanel.Height = $this._mainPanel.Height - 8
        $this._previewPanel.HasBorder = $true
        $this._previewPanel.BorderStyle = "Single"
        $this._previewPanel.Title = " Preview "
        $this._mainPanel.AddChild($this._previewPanel)
        
        # Description in preview
        $this._descriptionLabel = [LabelComponent]::new("ThemeScreen_Description")
        $this._descriptionLabel.X = 2
        $this._descriptionLabel.Y = 1
        $this._descriptionLabel.Width = $this._previewPanel.Width - 4
        $this._descriptionLabel.Text = ""
        $this._previewPanel.AddChild($this._descriptionLabel)
        
        # Preview elements - static labels showing theme colors
        $y = 3
        
        # Text preview
        $this._previewTextLabel = [LabelComponent]::new("Preview_Text")
        $this._previewTextLabel.Text = "Sample Text (Foreground Color)"
        $this._previewTextLabel.X = 2
        $this._previewTextLabel.Y = $y
        $this._previewPanel.AddChild($this._previewTextLabel)
        $y += 2
        
        # Button preview
        $this._previewButtonLabel = [LabelComponent]::new("Preview_Button")
        $this._previewButtonLabel.Text = "[ Sample Button (Focused) ]"
        $this._previewButtonLabel.X = 2
        $this._previewButtonLabel.Y = $y
        $this._previewPanel.AddChild($this._previewButtonLabel)
        $y += 2
        
        # List preview
        $this._previewListLabel = [LabelComponent]::new("Preview_List")
        $this._previewListLabel.Text = "> Selected List Item <"
        $this._previewListLabel.X = 2
        $this._previewListLabel.Y = $y
        $this._previewPanel.AddChild($this._previewListLabel)
        
        # Status label - positioned correctly
        $statusY = $this._mainPanel.Height - 3
        $this._statusLabel = [LabelComponent]::new("ThemeScreen_Status")
        $this._statusLabel.Text = "Use ↑↓ to navigate, Enter to apply theme, Escape to go back"
        $this._statusLabel.X = 2
        $this._statusLabel.Y = $statusY
        $this._statusLabel.ForegroundColor = Get-ThemeColor "Info"
        $this._mainPanel.AddChild($this._statusLabel)
        
        # Populate themes
        $this.PopulateThemeList()
        
        # Selection change handler
        $thisScreen = $this
        $this._themeList.SelectedIndexChanged = {
            param($sender, $index)
            $thisScreen.UpdatePreview()
        }
        
        # Set focus
        $focusManager = $this.ServiceContainer.GetService("FocusManager")
        if ($focusManager) {
            $focusManager.SetFocus($this._themeList)
        }
    }
    
    hidden [void] PopulateThemeList() {
        $this._themeList.ClearItems()
        foreach ($theme in $this._themes) {
            $this._themeList.AddItem($theme.Name)
        }
        $this._themeList.SelectedIndex = 0
        $this.UpdatePreview()
    }
    
    hidden [void] UpdatePreview() {
        if ($this._themeList.SelectedIndex -ge 0 -and $this._themeList.SelectedIndex -lt $this._themes.Count) {
            $selectedTheme = $this._themes[$this._themeList.SelectedIndex]
            
            # Update description
            $this._descriptionLabel.Text = $selectedTheme.Description
            
            # Update preview colors
            $this._previewTextLabel.ForegroundColor = $selectedTheme.Colors["Foreground"]
            $this._previewButtonLabel.ForegroundColor = $selectedTheme.Colors["button.focused.fg"]
            $this._previewButtonLabel.BackgroundColor = $selectedTheme.Colors["button.focused.bg"]
            $this._previewListLabel.ForegroundColor = $selectedTheme.Colors["list.item.selected"]
            $this._previewListLabel.BackgroundColor = $selectedTheme.Colors["list.item.selected.background"]
            
            $this.RequestRedraw()
        }
    }
    
    hidden [void] ApplySelectedTheme() {
        if ($this._themeList.SelectedIndex -ge 0 -and $this._themeList.SelectedIndex -lt $this._themes.Count) {
            $selectedTheme = $this._themes[$this._themeList.SelectedIndex]
            $themeManager = $this.ServiceContainer.GetService("ThemeManager")
            
            if ($themeManager) {
                # Apply all colors
                foreach ($colorKey in $selectedTheme.Colors.Keys) {
                    $themeManager.SetColor($colorKey, $selectedTheme.Colors[$colorKey])
                }
                
                $themeManager.ThemeName = $selectedTheme.Name
                $global:TuiState.IsDirty = $true
                
                # Show confirmation
                $this._statusLabel.Text = "Theme '$($selectedTheme.Name)' applied!"
                $this._statusLabel.ForegroundColor = Get-ThemeColor "Success"
                $this.RequestRedraw()
                
                # Force immediate redraw
                if ($global:TuiState.RenderEngine) {
                    $global:TuiState.RenderEngine.Render()
                }
                
                # Return after delay
                Start-Sleep -Milliseconds 1500
                $navService = $this.ServiceContainer.GetService("NavigationService")
                if ($navService) {
                    $navService.GoBack()
                }
            }
        }
    }
    
    [void] OnEnter() {
        ([Screen]$this).OnEnter()
        $this.UpdatePreview()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        switch ($key.Key) {
            ([ConsoleKey]::Escape) {
                $navService = $this.ServiceContainer.GetService("NavigationService")
                if ($navService) { $navService.GoBack() }
                return $true
            }
            ([ConsoleKey]::Enter) {
                $this.ApplySelectedTheme()
                return $true
            }
        }
        
        return ([Screen]$this).HandleInput($key)
    }
}
'@

Set-Content -Path $themeScreenPath -Value $themeScreenContent -Force
Write-Host "  - Theme Screen completely replaced with FIXED VERSION" -ForegroundColor Green

# FIX 3: Add Tab navigation to TaskListScreen if missing
Write-Host "`nAdding Tab navigation to TaskListScreen..." -ForegroundColor Cyan
$content = Get-Content $taskListPath -Raw

# Find the main TaskListScreen HandleInput method
$pattern = '(class TaskListScreen : Screen[\s\S]+?)\[bool\]\s+HandleInput\(\[System\.ConsoleKeyInfo\]\$keyInfo\)\s*\{([^}]+switch\s*\(\$keyInfo\.Key\)\s*\{[^}]+)(\}\s*return\s+\(\[Screen\]\$this\)\.HandleInput)'

if ($content -match $pattern) {
    $beforeMethod = $matches[1]
    $methodContent = $matches[2]
    $afterMethod = $matches[3]
    
    # Check if Tab handling already exists
    if ($methodContent -notmatch 'ConsoleKey.*Tab') {
        # Add Tab handling before the closing brace
        $tabHandling = @'
            ([ConsoleKey]::Tab) {
                # Cycle focus between components
                $focusManager = $this.ServiceContainer.GetService("FocusManager")
                if ($focusManager) {
                    if ($this._taskListBox.IsFocused) {
                        $focusManager.SetFocus($this._filterBox)
                    } else {
                        $focusManager.SetFocus($this._taskListBox)
                    }
                }
                return $true
            }
'@
        $newMethodContent = $methodContent + "`n" + $tabHandling + "`n        }"
        $newContent = $beforeMethod + "[bool] HandleInput([System.ConsoleKeyInfo]`$keyInfo) {" + $newMethodContent + "`n" + $afterMethod
        Set-Content -Path $taskListPath -Value $newContent -Force
        Write-Host "  - Tab navigation added to TaskListScreen" -ForegroundColor Green
    } else {
        Write-Host "  - Tab navigation already exists in TaskListScreen" -ForegroundColor Yellow
    }
}

# FIX 4: Apply New Task Screen spacing fix from REAL_FIX.ps1
Write-Host "`nApplying New Task Screen spacing fix..." -ForegroundColor Cyan
$newTaskPath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AxiomPhoenix_v4_Split\Screens\ASC.004_NewTaskScreen.ps1"
$newTaskContent = Get-Content $newTaskPath -Raw

# Replace the Initialize method
$initPattern = '(\[void\]\s+Initialize\(\)\s*\{)([^}]+\})'
$newInitializeBody = @'
        # Main form panel - full screen
        $this._formPanel = [Panel]::new("NewTaskForm")
        $this._formPanel.X = 0
        $this._formPanel.Y = 0
        $this._formPanel.Width = $this.Width
        $this._formPanel.Height = $this.Height
        $this._formPanel.Title = " New Task "
        $this._formPanel.BorderStyle = "Double"
        $this._formPanel.BorderColor = Get-ThemeColor "Primary"
        $this._formPanel.BackgroundColor = Get-ThemeColor "Background"
        $this.AddChild($this._formPanel)
        
        # Layout with generous spacing
        $leftMargin = 5
        $topMargin = 3
        $labelHeight = 1
        $inputHeight = 3
        $sectionGap = 3  # Gap between sections
        $contentWidth = [Math]::Min(100, $this._formPanel.Width - ($leftMargin * 2))
        
        $currentY = $topMargin
        
        # Title Section
        $titleLabel = [LabelComponent]::new("TitleLabel")
        $titleLabel.Text = "Task Title:"
        $titleLabel.X = $leftMargin
        $titleLabel.Y = $currentY
        $titleLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($titleLabel)
        
        $currentY += $labelHeight + 1
        
        $this._titleBox = [TextBoxComponent]::new("TitleInput")
        $this._titleBox.X = $leftMargin
        $this._titleBox.Y = $currentY
        $this._titleBox.Width = $contentWidth
        $this._titleBox.Height = $inputHeight
        $this._titleBox.Placeholder = "Enter task title..."
        $this._titleBox.IsFocusable = $true
        $this._formPanel.AddChild($this._titleBox)
        
        $currentY += $inputHeight + $sectionGap
        
        # Description Section
        $descLabel = [LabelComponent]::new("DescLabel")
        $descLabel.Text = "Description:"
        $descLabel.X = $leftMargin
        $descLabel.Y = $currentY
        $descLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($descLabel)
        
        $currentY += $labelHeight + 1
        
        $this._descriptionBox = [TextBoxComponent]::new("DescInput")
        $this._descriptionBox.X = $leftMargin
        $this._descriptionBox.Y = $currentY
        $this._descriptionBox.Width = $contentWidth
        $this._descriptionBox.Height = $inputHeight
        $this._descriptionBox.Placeholder = "Enter description..."
        $this._descriptionBox.IsFocusable = $true
        $this._formPanel.AddChild($this._descriptionBox)
        
        $currentY += $inputHeight + $sectionGap
        
        # Priority and Project side by side
        $halfWidth = [Math]::Floor(($contentWidth - 10) / 2)
        
        # Priority
        $priorityLabel = [LabelComponent]::new("PriorityLabel")
        $priorityLabel.Text = "Priority:"
        $priorityLabel.X = $leftMargin
        $priorityLabel.Y = $currentY
        $priorityLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($priorityLabel)
        
        $this._priorityList = [ListBox]::new("PriorityList")
        $this._priorityList.X = $leftMargin
        $this._priorityList.Y = $currentY + $labelHeight + 1
        $this._priorityList.Width = $halfWidth
        $this._priorityList.Height = 5
        $this._priorityList.HasBorder = $true
        $this._priorityList.BorderStyle = "Single"
        $this._priorityList.AddItem("Low")
        $this._priorityList.AddItem("Medium")
        $this._priorityList.AddItem("High")
        $this._priorityList.SelectedIndex = 1
        $this._priorityList.IsFocusable = $true
        $this._formPanel.AddChild($this._priorityList)
        
        # Project
        $projectX = $leftMargin + $halfWidth + 10
        $projectLabel = [LabelComponent]::new("ProjectLabel")
        $projectLabel.Text = "Project:"
        $projectLabel.X = $projectX
        $projectLabel.Y = $currentY
        $projectLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($projectLabel)
        
        $this._projectList = [ListBox]::new("ProjectList")
        $this._projectList.X = $projectX
        $this._projectList.Y = $currentY + $labelHeight + 1
        $this._projectList.Width = $halfWidth
        $this._projectList.Height = 5
        $this._projectList.HasBorder = $true
        $this._projectList.BorderStyle = "Single"
        $this._projectList.AddItem("General")
        $this._projectList.SelectedIndex = 0
        $this._projectList.IsFocusable = $true
        $this._formPanel.AddChild($this._projectList)
        
        # Status at bottom
        $bottomY = $this._formPanel.Height - 5
        
        $this._statusLabel = [LabelComponent]::new("StatusLabel")
        $this._statusLabel.X = $leftMargin
        $this._statusLabel.Y = $bottomY
        $this._statusLabel.Text = "Ready to create task"
        $this._statusLabel.ForegroundColor = Get-ThemeColor "Info"
        $this._formPanel.AddChild($this._statusLabel)
        
        $instructLabel = [LabelComponent]::new("InstructLabel")
        $instructLabel.X = $leftMargin
        $instructLabel.Y = $bottomY + 2
        $instructLabel.Text = "Tab: Next field | Ctrl+S: Save | ESC: Cancel"
        $instructLabel.ForegroundColor = Get-ThemeColor "Subtle"
        $this._formPanel.AddChild($instructLabel)
    }
'@

$newTaskContent = $newTaskContent -replace $initPattern, "`$1`n$newInitializeBody"
Set-Content -Path $newTaskPath -Value $newTaskContent -Force
Write-Host "  - New Task Screen spacing completely fixed" -ForegroundColor Green

Write-Host "`nAll fixes have been applied!" -ForegroundColor Green
Write-Host "`nNext steps:" -ForegroundColor Yellow
Write-Host "1. Run .\Start.ps1 to test the application" -ForegroundColor White
Write-Host "2. Test Theme Selection (should apply immediately)" -ForegroundColor White
Write-Host "3. Test New Task screen (all fields should be visible)" -ForegroundColor White
Write-Host "4. Test Tab navigation in Task List screen" -ForegroundColor White



####\Debug-Navigation.ps1
# Debug Navigation Issues
# This script helps diagnose navigation problems

param(
    [switch]$Verbose
)

$ErrorActionPreference = 'Stop'
if ($Verbose) {
    $VerbosePreference = 'Continue'
}

Write-Host "Navigation Debug Script" -ForegroundColor Cyan
Write-Host "=====================" -ForegroundColor Cyan
Write-Host ""

# Load just the framework without starting the UI
Write-Host "Loading framework files..." -ForegroundColor Yellow

$scriptDir = $PSScriptRoot
$loadOrder = @(
    "Base",
    "Models", 
    "Functions",
    "Components",
    "Screens",
    "Services",
    "Runtime"
)

foreach ($folder in $loadOrder) {
    $folderPath = Join-Path $scriptDir $folder
    if (-not (Test-Path $folderPath)) { 
        Write-Warning "Folder not found: $folder"
        continue 
    }

    Write-Host "Loading $folder..." -ForegroundColor Gray
    $files = Get-ChildItem -Path $folderPath -Filter "*.ps1" | Sort-Object Name
    foreach ($file in $files) {
        Write-Verbose "  - Loading $($file.Name)"
        try {
            . $file.FullName
        } catch {
            Write-Error "Failed to load $($file.Name): $($_.Exception.Message)"
            throw
        }
    }
}

Write-Host "`nFramework loaded!" -ForegroundColor Green

# Create service container
Write-Host "`nSetting up services..." -ForegroundColor Yellow
$container = [ServiceContainer]::new()

# Register services
$container.Register("Logger", [Logger]::new((Join-Path $env:TEMP "axiom-debug.log")))
$container.Register("EventManager", [EventManager]::new())
$container.Register("ThemeManager", [ThemeManager]::new())
$container.Register("DataManager", [DataManager]::new((Join-Path $env:TEMP "axiom-data.json"), $container.GetService("EventManager")))
$container.Register("ActionService", [ActionService]::new($container.GetService("EventManager")))
$container.Register("KeybindingService", [KeybindingService]::new($container.GetService("ActionService")))
$container.Register("NavigationService", [NavigationService]::new($container))
$container.Register("FocusManager", [FocusManager]::new($container.GetService("EventManager")))
$container.Register("DialogManager", [DialogManager]::new($container))
$container.Register("ViewDefinitionService", [ViewDefinitionService]::new())

# Initialize global state
$global:TuiState = @{
    Running = $false
    BufferWidth = 120
    BufferHeight = 30
    CompositorBuffer = $null
    PreviousCompositorBuffer = $null
    ScreenStack = [System.Collections.Stack]::new()
    CurrentScreen = $null
    IsDirty = $true
    FocusedComponent = $null
    CommandPalette = $null
    Services = @{}
    ServiceContainer = $container
}

$global:TuiState.Services = @{
    Logger = $container.GetService("Logger")
    EventManager = $container.GetService("EventManager") 
    ThemeManager = $container.GetService("ThemeManager")
    DataManager = $container.GetService("DataManager")
    ActionService = $container.GetService("ActionService")
    KeybindingService = $container.GetService("KeybindingService")
    NavigationService = $container.GetService("NavigationService")
    FocusManager = $container.GetService("FocusManager")
    DialogManager = $container.GetService("DialogManager")
    ViewDefinitionService = $container.GetService("ViewDefinitionService")
}

# Register default actions
$actionService = $container.GetService("ActionService")
$actionService.RegisterDefaultActions()

Write-Host "Services initialized!" -ForegroundColor Green

# Test navigation functions
Write-Host "`nTesting Navigation..." -ForegroundColor Cyan
Write-Host "===================" -ForegroundColor Cyan

# Check if classes exist
Write-Host "`nChecking screen classes:" -ForegroundColor Yellow
$screenClasses = @(
    "DashboardScreen",
    "TaskListScreen", 
    "ThemeScreen"
)

foreach ($className in $screenClasses) {
    try {
        $type = [Type]::GetType($className)
        if ($null -ne $type -or (Get-Command -Name "[$className]" -ErrorAction SilentlyContinue)) {
            Write-Host "  ✓ $className found" -ForegroundColor Green
        } else {
            # Try alternative check
            $testObj = New-Object -TypeName $className -ArgumentList $container -ErrorAction Stop
            Write-Host "  ✓ $className found (instantiation test)" -ForegroundColor Green
        }
    } catch {
        Write-Host "  ✗ $className NOT FOUND or cannot instantiate" -ForegroundColor Red
        Write-Host "    Error: $_" -ForegroundColor Yellow
    }
}

# Check registered actions
Write-Host "`nChecking registered actions:" -ForegroundColor Yellow
$navActions = @(
    "navigation.dashboard",
    "navigation.taskList",
    "navigation.newTask",
    "navigation.themeScreen",
    "task.list",
    "task.new",
    "ui.theme.picker"
)

foreach ($actionName in $navActions) {
    $action = $actionService.GetAction($actionName)
    if ($action) {
        Write-Host "  ✓ $actionName - $($action.Description)" -ForegroundColor Green
    } else {
        Write-Host "  ✗ $actionName NOT REGISTERED" -ForegroundColor Red
    }
}

# Test navigation to each screen
Write-Host "`nTesting screen navigation:" -ForegroundColor Yellow
$navService = $container.GetService("NavigationService")

# Test Dashboard
Write-Host "`n1. Testing DashboardScreen..." -ForegroundColor Cyan
try {
    $dashboard = [DashboardScreen]::new($container)
    $dashboard.Initialize()
    Write-Host "  ✓ DashboardScreen created and initialized" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Failed to create DashboardScreen: $_" -ForegroundColor Red
}

# Test TaskListScreen
Write-Host "`n2. Testing TaskListScreen..." -ForegroundColor Cyan
try {
    $taskList = [TaskListScreen]::new($container)
    $taskList.Initialize()
    Write-Host "  ✓ TaskListScreen created and initialized" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Failed to create TaskListScreen: $_" -ForegroundColor Red
    Write-Host "  Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Yellow
}

# Test ThemeScreen
Write-Host "`n3. Testing ThemeScreen..." -ForegroundColor Cyan
try {
    $themeScreen = [ThemeScreen]::new($container)
    $themeScreen.Initialize()
    Write-Host "  ✓ ThemeScreen created and initialized" -ForegroundColor Green
} catch {
    Write-Host "  ✗ Failed to create ThemeScreen: $_" -ForegroundColor Red
}

# Test action execution
Write-Host "`nTesting action execution:" -ForegroundColor Yellow

Write-Host "`n1. Testing navigation.taskList action..." -ForegroundColor Cyan
try {
    # Reset navigation state
    $global:TuiState.ScreenStack.Clear()
    $global:TuiState.CurrentScreen = $null
    
    # Execute action
    $actionService.ExecuteAction("navigation.taskList", @{})
    
    # Check result
    if ($navService.CurrentScreen -is [TaskListScreen]) {
        Write-Host "  ✓ Successfully navigated to TaskListScreen" -ForegroundColor Green
    } else {
        Write-Host "  ✗ Navigation failed - current screen is: $($navService.CurrentScreen.GetType().Name)" -ForegroundColor Red
    }
} catch {
    Write-Host "  ✗ Action execution failed: $_" -ForegroundColor Red
    Write-Host "  Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Yellow
}

Write-Host "`n2. Testing ui.theme.picker action..." -ForegroundColor Cyan
try {
    # Reset navigation state
    $global:TuiState.ScreenStack.Clear()
    $global:TuiState.CurrentScreen = $null
    
    # Execute action
    $actionService.ExecuteAction("ui.theme.picker", @{})
    
    # Check result
    if ($navService.CurrentScreen -is [ThemeScreen]) {
        Write-Host "  ✓ Successfully navigated to ThemeScreen" -ForegroundColor Green
    } else {
        Write-Host "  ✗ Navigation failed - current screen is: $($navService.CurrentScreen?.GetType().Name)" -ForegroundColor Red
    }
} catch {
    Write-Host "  ✗ Action execution failed: $_" -ForegroundColor Red
}

# Summary
Write-Host "`n===================" -ForegroundColor Cyan
Write-Host "Debug Summary" -ForegroundColor Cyan
Write-Host "===================" -ForegroundColor Cyan

$issues = @()

# Check for common issues
if (-not (Get-Command -Name "[TaskListScreen]" -ErrorAction SilentlyContinue)) {
    $issues += "TaskListScreen class may not be properly loaded"
}

if (-not $actionService.GetAction("navigation.taskList")) {
    $issues += "navigation.taskList action not registered"
}

if ($issues.Count -eq 0) {
    Write-Host "`n✓ All navigation components appear to be working correctly!" -ForegroundColor Green
    Write-Host "`nIf navigation still fails in the running app, the issue may be:" -ForegroundColor Yellow
    Write-Host "  - Input handling in the command palette" -ForegroundColor White
    Write-Host "  - Event timing issues" -ForegroundColor White
    Write-Host "  - Focus management conflicts" -ForegroundColor White
} else {
    Write-Host "`n✗ Found $($issues.Count) potential issue(s):" -ForegroundColor Red
    foreach ($issue in $issues) {
        Write-Host "  - $issue" -ForegroundColor Yellow
    }
}

Write-Host "`nPress any key to exit..." -ForegroundColor Cyan
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")



####\fc2.ps1
#------------------------------------------------------------------------------------------
# SCRIPT:      filecopy-and-concatenate.ps1
#
# DESCRIPTION: Finds specified file types in a given path and its subdirectories.
#              For each file, it can create a .txt copy and/or concatenate all
#              file contents into a single output file.
#
# FEATURES:
#   - Full parameter support for path, file types, and output name.
#   - Safety features: Supports -WhatIf and -Confirm for all file operations.
#   - Verbose output: Use the -Verbose switch to see detailed progress.
#   - Performance: Uses an efficient single-write operation for the concatenated file.
#   - Robustness: Uses idiomatic PowerShell for path manipulation and error handling.
#   - Compatibility: Works on Windows PowerShell 5.1 and newer.
#   - NEW: Can create individual .txt copies of each source file.
#
# USAGE:
#   # Basic run in the current folder for PowerShell files
#   .\filecopy-and-concatenate.ps1 -Verbose
#
#   # Run on a different project, for C# files, with a different output name
#   .\filecopy-and-concatenate.ps1 -Path "C:\Projects\MyWebApp" -Include "*.cs" -OutputFileName "SourceCode.txt"
#
#   # To also create individual .txt copies of each file:
#   .\filecopy-and-concatenate.ps1 -CreateIndividualCopies -Verbose
#
#   # Perform a "dry run" to see what would happen without making any changes
#   .\filecopy-and-concatenate.ps1 -Path "C:\SomethingImportant" -CreateIndividualCopies -WhatIf
#
#------------------------------------------------------------------------------------------

# Enable support for -WhatIf, -Confirm, and advanced parameter binding
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    # The starting directory to search in. Defaults to the current directory.
    [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "The root path to search for files.")]
    [string]
    $Path = (Get-Location).Path,

    # An array of file patterns to include. Defaults to PowerShell script files.
    [Parameter(Mandatory = $false, HelpMessage = "File patterns to include, e.g., '*.ps1', '*.psm1'.")]
    [string[]]
    $Include = @("*.ps1", "*.psm1"),

    # The name of the final concatenated output file.
    [Parameter(Mandatory = $false, HelpMessage = "Name of the concatenated output file.")]
    [string]
    $OutputFileName = "all.txt",

    # Switch to create a .txt copy of each individual file found.
    [Parameter(Mandatory = $false, HelpMessage = "If specified, creates a .txt copy of each found file.")]
    [switch]
    $CreateIndividualCopies
)

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Resolve-Path returns a PathInfo object. We use it for robustness.
    $resolvedPathObject = Resolve-Path -Path $Path
    $basePathString = $resolvedPathObject.Path # Store the string path for reuse
    $outputFilePath = Join-Path -Path $basePathString -ChildPath $OutputFileName

    Write-Verbose "Starting operations in: $basePathString"
    Write-Verbose "Searching for file types: $($Include -join ', ')"
    Write-Verbose "Output file will be: $outputFilePath"
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Individual .txt copies will be created."
    }

    # --- Step 1: Find all specified files recursively ---
    $filesToProcess = Get-ChildItem -Path $basePathString -Recurse -Include $Include -File

    if ($null -eq $filesToProcess) {
        Write-Warning "No files found matching the specified criteria."
        return # Exit gracefully if no files are found
    }

    Write-Verbose "Found $($filesToProcess.Count) files to process."

    # --- Step 2: Clear the existing output file if it exists ---
    # This is part of the concatenation process, so it's good to do it early.
    if ((Test-Path $outputFilePath) -and $PSCmdlet.ShouldProcess($outputFilePath, "Remove existing output file")) {
        Remove-Item $outputFilePath -Force
    }

    # --- Step 3: Process each file for individual copies (if requested) ---
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Processing files to create individual .txt copies..."
        foreach ($file in $filesToProcess) {
            # Create a new filename by changing the extension to .txt
            $txtCopyPath = [System.IO.Path]::ChangeExtension($file.FullName, ".txt")

            # Use ShouldProcess for -WhatIf and -Confirm support
            if ($PSCmdlet.ShouldProcess($txtCopyPath, "Copy from '$($file.Name)'")) {
                Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force
                Write-Verbose "Created copy: '$txtCopyPath'"
            }
        }
    }

    # --- Step 4: Concatenate all files into the output file (Efficiently) ---
    Write-Verbose "Starting concatenation of all files into '$OutputFileName'..."
    if ($PSCmdlet.ShouldProcess($outputFilePath, "Concatenate $($filesToProcess.Count) files")) {
        # Using a subexpression `$(...)` to gather all output before writing to the file once.
        Set-Content -Path $outputFilePath -Encoding UTF8 -Value $(
            foreach ($file in $filesToProcess) {
                # Calculate the relative path for the header
                $relativePath = $file.FullName.Substring($basePathString.Length)
                # Ensure consistent format like '\subdir\file.ps1'
                $relativePath = '\' + $relativePath.TrimStart('\/')

                # Output the header for this file
                "####$relativePath"

                # Output the file's content
                Get-Content -Path $file.FullName -Raw -Encoding Default

                # Output two blank lines for separation
                ""
                ""
            }
        )
        Write-Host "All operations complete. Concatenated content saved to '$outputFilePath'."
    }
}
catch {
    # A global catch block for any unexpected, terminating errors.
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    Write-Error "Script execution halted at line $($_.InvocationInfo.ScriptLineNumber): $($_.InvocationInfo.Line)"
}


####\fix_all_issues.ps1
# Fix 1: Update NewTaskScreen to handle ESC properly and fix text input visibility
$newTaskScreenContent = @'
# ===== CLASS: NewTaskScreen =====
# Purpose: Full screen for creating new tasks
class NewTaskScreen : Screen {
    hidden [Panel]$_formPanel
    hidden [SidebarMenu]$_menu
    hidden [TextBoxComponent]$_titleBox
    hidden [TextBoxComponent]$_descriptionBox
    hidden [ListBox]$_priorityList
    hidden [ListBox]$_projectList
    hidden [ButtonComponent]$_saveButton
    hidden [ButtonComponent]$_cancelButton
    hidden [LabelComponent]$_statusLabel
    
    NewTaskScreen([object]$serviceContainer) : base("NewTaskScreen", $serviceContainer) {}
    
    [void] Initialize() {
        # Create menu
        $this._menu = [SidebarMenu]::new("MainMenu")
        $this._menu.X = 0
        $this._menu.Y = 0
        $this._menu.Height = $this.Height
        $this._menu.Width = 22
        $this._menu.Title = "Navigation"
        
        $this._menu.AddMenuItem("1", "Dashboard", "navigation.dashboard")
        $this._menu.AddMenuItem("2", "Task List", "navigation.taskList")
        $this._menu.AddMenuItem("-", "", "")
        $this._menu.AddMenuItem("S", "Save Task", "task.save.current")
        $this._menu.AddMenuItem("C", "Cancel", "navigation.back")
        $this._menu.AddMenuItem("-", "", "")
        $this._menu.AddMenuItem("Q", "Quit", "app.exit")
        
        $this.AddChild($this._menu)
        
        # Create form panel
        $this._formPanel = [Panel]::new("NewTaskForm")
        $this._formPanel.X = 23
        $this._formPanel.Y = 0
        $this._formPanel.Width = $this.Width - 24
        $this._formPanel.Height = $this.Height
        $this._formPanel.Title = "Create New Task"
        $this._formPanel.BorderStyle = "Double"
        $this._formPanel.BorderColor = Get-ThemeColor "Primary"
        $this._formPanel.BackgroundColor = Get-ThemeColor "Background" 
        $this.AddChild($this._formPanel)
        
        # Title input
        $titleLabel = [LabelComponent]::new("TitleLabel")
        $titleLabel.Text = "Task Title:"
        $titleLabel.X = 2
        $titleLabel.Y = 2
        $this._formPanel.AddChild($titleLabel)
        
        $this._titleBox = [TextBoxComponent]::new("TitleInput")
        $this._titleBox.X = 2
        $this._titleBox.Y = 3
        $this._titleBox.Width = [Math]::Min(50, $this._formPanel.Width - 6)
        $this._titleBox.Height = 3
        $this._titleBox.Placeholder = "Enter task title..."
        $this._titleBox.IsFocusable = $true
        $this._titleBox.BackgroundColor = Get-ThemeColor "Background"
        $this._titleBox.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($this._titleBox)
        
        # Description input
        $descLabel = [LabelComponent]::new("DescLabel")
        $descLabel.Text = "Description:"
        $descLabel.X = 2
        $descLabel.Y = 7
        $this._formPanel.AddChild($descLabel)
        
        $this._descriptionBox = [TextBoxComponent]::new("DescInput")
        $this._descriptionBox.X = 2
        $this._descriptionBox.Y = 8
        $this._descriptionBox.Width = [Math]::Min(50, $this._formPanel.Width - 6)
        $this._descriptionBox.Height = 3
        $this._descriptionBox.Placeholder = "Enter description..."
        $this._descriptionBox.IsFocusable = $true
        $this._descriptionBox.BackgroundColor = Get-ThemeColor "Background"
        $this._descriptionBox.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($this._descriptionBox)
        
        # Priority selection
        $priorityLabel = [LabelComponent]::new("PriorityLabel")
        $priorityLabel.Text = "Priority: [Low/Medium/High]"
        $priorityLabel.X = 2
        $priorityLabel.Y = 12
        $this._formPanel.AddChild($priorityLabel)
        
        $this._priorityList = [ListBox]::new("PriorityList")
        $this._priorityList.X = 2
        $this._priorityList.Y = 13
        $this._priorityList.Width = 20
        $this._priorityList.Height = 5
        $this._priorityList.AddItem("Low")
        $this._priorityList.AddItem("Medium")
        $this._priorityList.AddItem("High")
        $this._priorityList.SelectedIndex = 1  # Default to Medium
        $this._priorityList.IsFocusable = $true
        $this._priorityList.SelectedBackgroundColor = Get-ThemeColor "Primary"
        $this._priorityList.SelectedForegroundColor = Get-ThemeColor "Background"
        $this._formPanel.AddChild($this._priorityList)
        
        # Project selection
        $projectLabel = [LabelComponent]::new("ProjectLabel")
        $projectLabel.Text = "Project: [General]"
        $projectLabel.X = 25
        $projectLabel.Y = 12
        $this._formPanel.AddChild($projectLabel)
        
        $this._projectList = [ListBox]::new("ProjectList")
        $this._projectList.X = 25
        $this._projectList.Y = 13
        $this._projectList.Width = 20
        $this._projectList.Height = 5
        $this._projectList.AddItem("General")
        $this._projectList.SelectedIndex = 0
        $this._projectList.IsFocusable = $true
        $this._projectList.SelectedBackgroundColor = Get-ThemeColor "Primary"
        $this._projectList.SelectedForegroundColor = Get-ThemeColor "Background"
        $this._formPanel.AddChild($this._projectList)
        
        # Status label
        $this._statusLabel = [LabelComponent]::new("StatusLabel")
        $this._statusLabel.X = 2
        $this._statusLabel.Y = 19
        $this._statusLabel.Text = "Ready to create task"
        $this._statusLabel.ForegroundColor = (Get-ThemeColor "Info")
        $this._formPanel.AddChild($this._statusLabel)
        
        # Instruction label
        $instructLabel = [LabelComponent]::new("InstructLabel")
        $instructLabel.X = 2
        $instructLabel.Y = 21
        $instructLabel.Text = "Tab: Next field | S: Save | ESC: Cancel"
        $instructLabel.ForegroundColor = Get-ThemeColor "Subtle"
        $this._formPanel.AddChild($instructLabel)
    }
    
    [void] OnEnter() {
        # Load projects
        $dataManager = $this.Services.DataManager
        $projects = $dataManager.GetProjects()
        
        $this._projectList.ClearItems()
        $this._projectList.AddItem("General")
        foreach ($project in $projects) {
            $this._projectList.AddItem($project.Name)
        }
        $this._projectList.SelectedIndex = 0
        
        # Set initial focus
        $focusManager = $this.Services.FocusManager
        $focusManager.SetFocus($this._titleBox)
        
        # Register save action
        $actionService = $this.Services.ActionService
        $actionService.RegisterAction("task.save.current", {
            $currentScreen = $global:TuiState.CurrentScreen
            if ($currentScreen -is [NewTaskScreen]) {
                $currentScreen.SaveTask()
            }
        }, @{ Category = "Tasks"; Description = "Save current task" })
    }
    
    [void] OnExit() {
        # Unregister temporary action
        $actionService = $this.Services.ActionService
        $actionService.UnregisterAction("task.save.current")
    }
    
    [void] SaveTask() {
        # Validate input
        if ([string]::IsNullOrWhiteSpace($this._titleBox.Text)) {
            $this._statusLabel.Text = "Error: Title is required"
            $this._statusLabel.ForegroundColor = (Get-ThemeColor "Error")
            return
        }
        
        # Create new task
        $task = [PmcTask]::new()
        $task.Title = $this._titleBox.Text
        $task.Description = $this._descriptionBox.Text
        
        # Set priority
        $priorityMap = @{
            0 = [TaskPriority]::Low
            1 = [TaskPriority]::Medium  
            2 = [TaskPriority]::High
        }
        $task.Priority = $priorityMap[$this._priorityList.SelectedIndex]
        
        # Set project
        if ($this._projectList.SelectedIndex -gt 0) {
            $dataManager = $this.Services.DataManager
            $projects = $dataManager.GetProjects()
            if ($this._projectList.SelectedIndex -le $projects.Count) {
                $task.ProjectKey = $projects[$this._projectList.SelectedIndex - 1].Key
            }
        }
        
        # Save task
        try {
            $dataManager = $this.Services.DataManager
            $dataManager.AddTask($task)
            
            # Force save to disk
            $dataManager.SaveData()
            
            $this._statusLabel.Text = "Task created successfully!"
            $this._statusLabel.ForegroundColor = (Get-ThemeColor "Success")
            
            # Clear form
            $this._titleBox.Text = ""
            $this._descriptionBox.Text = ""
            $this._priorityList.SelectedIndex = 1
            $this._projectList.SelectedIndex = 0
            
            # Navigate back after short delay
            Start-Sleep -Milliseconds 500
            $navService = $this.Services.NavigationService
            $navService.GoBack()
        }
        catch {
            $this._statusLabel.Text = "Error: $($_.Exception.Message)"
            $this._statusLabel.ForegroundColor = (Get-ThemeColor "Error")
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Handle ESC first - before menu gets it
        if ($keyInfo.Key -eq [ConsoleKey]::Escape) {
            $navService = $this.Services.NavigationService
            $navService.GoBack()
            return $true
        }
        
        # Handle save shortcut
        if ($keyInfo.Key -eq [ConsoleKey]::S -and -not ($keyInfo.Modifiers -band [ConsoleModifiers]::Control)) {
            $this.SaveTask()
            return $true
        }
        
        # Let menu handle its keys
        if ($this._menu.HandleKey($keyInfo)) {
            return $true
        }
        
        # Let base handle focus navigation
        return ([Screen]$this).HandleInput($keyInfo)
    }
}
'@

# Fix 2: Update TextBoxComponent for better visibility
$textBoxComponentContent = @'
# ===== CLASS: TextBoxComponent =====
# Module: tui-components
# Dependencies: UIElement, TuiCell
# Purpose: Text input with viewport scrolling, non-destructive cursor
class TextBoxComponent : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [ValidateRange(1, [int]::MaxValue)][int]$MaxLength = 100
    [int]$CursorPosition = 0
    [scriptblock]$OnChange
    hidden [int]$_scrollOffset = 0
    [string


####\REAL_FIX.ps1
# REAL FIXES FOR AXIOM-PHOENIX v4.0
# This time, actually testing and fixing the issues

Write-Host "Applying REAL fixes to Axiom-Phoenix..." -ForegroundColor Yellow

# FIX 1: Theme Screen - Complete rewrite of preview functionality
Write-Host "`nFixing Theme Screen..." -ForegroundColor Cyan

$themeScreenPath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AxiomPhoenix_v4_Split\Screens\ASC.003_ThemeScreen.ps1"
$themeScreenContent = @'
# ==============================================================================
# Axiom-Phoenix v4.0 - Theme Selection Screen - FIXED VERSION
# ==============================================================================

class ThemeScreen : Screen {
    # UI Components
    hidden [Panel]$_mainPanel
    hidden [ListBox]$_themeList
    hidden [Panel]$_previewPanel
    hidden [LabelComponent]$_titleLabel
    hidden [LabelComponent]$_descriptionLabel
    hidden [LabelComponent]$_statusLabel
    hidden [LabelComponent]$_previewTextLabel
    hidden [LabelComponent]$_previewButtonLabel
    hidden [LabelComponent]$_previewListLabel
    
    # Available themes with hex colors
    hidden [hashtable[]]$_themes = @(
        @{
            Name = "Default"
            Description = "Classic terminal colors with blue accents"
            Colors = @{
                "Background" = "#000000"
                "Foreground" = "#C0C0C0"
                "Primary" = "#0000FF"
                "Secondary" = "#000080"
                "Accent" = "#00FFFF"
                "Success" = "#00FF00"
                "Warning" = "#FFFF00"
                "Error" = "#FF0000"
                "Info" = "#00FFFF"
                "component.background" = "#000000"
                "component.border" = "#808080"
                "component.title" = "#00FFFF"
                "button.focused.fg" = "#FFFFFF"
                "button.focused.bg" = "#0000FF"
                "list.item.selected" = "#FFFFFF"
                "list.item.selected.background" = "#000080"
            }
        }
        @{
            Name = "Green Console"
            Description = "Classic green phosphor terminal look"
            Colors = @{
                "Background" = "#000000"
                "Foreground" = "#00FF00"
                "Primary" = "#00FF00"
                "Secondary" = "#008000"
                "Accent" = "#00FF00"
                "Success" = "#00FF00"
                "Warning" = "#FFFF00"
                "Error" = "#FF0000"
                "Info" = "#00FF00"
                "component.background" = "#000000"
                "component.border" = "#008000"
                "component.title" = "#00FF00"
                "button.focused.fg" = "#000000"
                "button.focused.bg" = "#00FF00"
                "list.item.selected" = "#000000"
                "list.item.selected.background" = "#00FF00"
            }
        }
        @{
            Name = "Amber Console"
            Description = "Warm amber monochrome terminal"
            Colors = @{
                "Background" = "#000000"
                "Foreground" = "#FFFF00"
                "Primary" = "#FFFF00"
                "Secondary" = "#808000"
                "Accent" = "#FFFF00"
                "Success" = "#00FF00"
                "Warning" = "#FFFF00"
                "Error" = "#FF0000"
                "Info" = "#FFFF00"
                "component.background" = "#000000"
                "component.border" = "#808000"
                "component.title" = "#FFFF00"
                "button.focused.fg" = "#000000"
                "button.focused.bg" = "#FFFF00"
                "list.item.selected" = "#000000"
                "list.item.selected.background" = "#FFFF00"
            }
        }
        @{
            Name = "Notepad Style"
            Description = "Clean white background with black text"
            Colors = @{
                "Background" = "#FFFFFF"
                "Foreground" = "#000000"
                "Primary" = "#000080"
                "Secondary" = "#C0C0C0"
                "Accent" = "#0000FF"
                "Success" = "#008000"
                "Warning" = "#808000"
                "Error" = "#800000"
                "Info" = "#008080"
                "component.background" = "#FFFFFF"
                "component.border" = "#808080"
                "component.title" = "#000080"
                "button.focused.fg" = "#FFFFFF"
                "button.focused.bg" = "#000080"
                "list.item.selected" = "#FFFFFF"
                "list.item.selected.background" = "#0000FF"
            }
        }
    )
    
    ThemeScreen([ServiceContainer]$container) : base("ThemeScreen", $container) {
    }
    
    [void] Initialize() {
        # Main panel
        $this._mainPanel = [Panel]::new("ThemeScreen_MainPanel")
        $this._mainPanel.X = 0
        $this._mainPanel.Y = 0
        $this._mainPanel.Width = $this.Width
        $this._mainPanel.Height = $this.Height
        $this._mainPanel.HasBorder = $true
        $this._mainPanel.BorderStyle = "Single"
        $this._mainPanel.Title = " Theme Selection "
        $this.AddChild($this._mainPanel)
        
        # Title
        $this._titleLabel = [LabelComponent]::new("ThemeScreen_Title")
        $this._titleLabel.Text = "Select a Theme"
        $this._titleLabel.X = 2
        $this._titleLabel.Y = 1
        $this._titleLabel.ForegroundColor = Get-ThemeColor "Primary"
        $this._mainPanel.AddChild($this._titleLabel)
        
        # Theme list - fixed width
        $this._themeList = [ListBox]::new("ThemeScreen_List")
        $this._themeList.X = 2
        $this._themeList.Y = 3
        $this._themeList.Width = 30  # Fixed width
        $this._themeList.Height = $this._mainPanel.Height - 8
        $this._themeList.HasBorder = $true
        $this._themeList.BorderStyle = "Single"
        $this._themeList.Title = " Themes "
        $this._themeList.IsFocusable = $true
        $this._mainPanel.AddChild($this._themeList)
        
        # Preview panel - rest of the width
        $previewX = $this._themeList.X + $this._themeList.Width + 2
        $this._previewPanel = [Panel]::new("ThemeScreen_Preview")
        $this._previewPanel.X = $previewX
        $this._previewPanel.Y = 3
        $this._previewPanel.Width = $this._mainPanel.Width - $previewX - 2
        $this._previewPanel.Height = $this._mainPanel.Height - 8
        $this._previewPanel.HasBorder = $true
        $this._previewPanel.BorderStyle = "Single"
        $this._previewPanel.Title = " Preview "
        $this._mainPanel.AddChild($this._previewPanel)
        
        # Description in preview
        $this._descriptionLabel = [LabelComponent]::new("ThemeScreen_Description")
        $this._descriptionLabel.X = 2
        $this._descriptionLabel.Y = 1
        $this._descriptionLabel.Width = $this._previewPanel.Width - 4
        $this._descriptionLabel.Text = ""
        $this._previewPanel.AddChild($this._descriptionLabel)
        
        # Preview elements - static labels showing theme colors
        $y = 3
        
        # Text preview
        $this._previewTextLabel = [LabelComponent]::new("Preview_Text")
        $this._previewTextLabel.Text = "Sample Text (Foreground Color)"
        $this._previewTextLabel.X = 2
        $this._previewTextLabel.Y = $y
        $this._previewPanel.AddChild($this._previewTextLabel)
        $y += 2
        
        # Button preview
        $this._previewButtonLabel = [LabelComponent]::new("Preview_Button")
        $this._previewButtonLabel.Text = "[ Sample Button (Focused) ]"
        $this._previewButtonLabel.X = 2
        $this._previewButtonLabel.Y = $y
        $this._previewPanel.AddChild($this._previewButtonLabel)
        $y += 2
        
        # List preview
        $this._previewListLabel = [LabelComponent]::new("Preview_List")
        $this._previewListLabel.Text = "> Selected List Item <"
        $this._previewListLabel.X = 2
        $this._previewListLabel.Y = $y
        $this._previewPanel.AddChild($this._previewListLabel)
        
        # Status label - positioned correctly
        $statusY = $this._mainPanel.Height - 3
        $this._statusLabel = [LabelComponent]::new("ThemeScreen_Status")
        $this._statusLabel.Text = "Use ↑↓ to navigate, Enter to apply theme, Escape to go back"
        $this._statusLabel.X = 2
        $this._statusLabel.Y = $statusY
        $this._statusLabel.ForegroundColor = Get-ThemeColor "Info"
        $this._mainPanel.AddChild($this._statusLabel)
        
        # Populate themes
        $this.PopulateThemeList()
        
        # Selection change handler
        $thisScreen = $this
        $this._themeList.SelectedIndexChanged = {
            param($sender, $index)
            $thisScreen.UpdatePreview()
        }
        
        # Set focus
        $focusManager = $this.ServiceContainer.GetService("FocusManager")
        if ($focusManager) {
            $focusManager.SetFocus($this._themeList)
        }
    }
    
    hidden [void] PopulateThemeList() {
        $this._themeList.ClearItems()
        foreach ($theme in $this._themes) {
            $this._themeList.AddItem($theme.Name)
        }
        $this._themeList.SelectedIndex = 0
        $this.UpdatePreview()
    }
    
    hidden [void] UpdatePreview() {
        if ($this._themeList.SelectedIndex -ge 0 -and $this._themeList.SelectedIndex -lt $this._themes.Count) {
            $selectedTheme = $this._themes[$this._themeList.SelectedIndex]
            
            # Update description
            $this._descriptionLabel.Text = $selectedTheme.Description
            
            # Update preview colors
            $this._previewTextLabel.ForegroundColor = $selectedTheme.Colors["Foreground"]
            $this._previewButtonLabel.ForegroundColor = $selectedTheme.Colors["button.focused.fg"]
            $this._previewButtonLabel.BackgroundColor = $selectedTheme.Colors["button.focused.bg"]
            $this._previewListLabel.ForegroundColor = $selectedTheme.Colors["list.item.selected"]
            $this._previewListLabel.BackgroundColor = $selectedTheme.Colors["list.item.selected.background"]
            
            $this.RequestRedraw()
        }
    }
    
    hidden [void] ApplySelectedTheme() {
        if ($this._themeList.SelectedIndex -ge 0 -and $this._themeList.SelectedIndex -lt $this._themes.Count) {
            $selectedTheme = $this._themes[$this._themeList.SelectedIndex]
            $themeManager = $this.ServiceContainer.GetService("ThemeManager")
            
            if ($themeManager) {
                # Apply all colors
                foreach ($colorKey in $selectedTheme.Colors.Keys) {
                    $themeManager.SetColor($colorKey, $selectedTheme.Colors[$colorKey])
                }
                
                $themeManager.ThemeName = $selectedTheme.Name
                $global:TuiState.IsDirty = $true
                
                # Show confirmation
                $this._statusLabel.Text = "Theme '$($selectedTheme.Name)' applied!"
                $this._statusLabel.ForegroundColor = Get-ThemeColor "Success"
                $this.RequestRedraw()
                
                # Force immediate redraw
                if ($global:TuiState.RenderEngine) {
                    $global:TuiState.RenderEngine.Render()
                }
                
                # Return after delay
                Start-Sleep -Milliseconds 1500
                $navService = $this.ServiceContainer.GetService("NavigationService")
                if ($navService) {
                    $navService.GoBack()
                }
            }
        }
    }
    
    [void] OnEnter() {
        ([Screen]$this).OnEnter()
        $this.UpdatePreview()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($null -eq $key) { return $false }
        
        switch ($key.Key) {
            ([ConsoleKey]::Escape) {
                $navService = $this.ServiceContainer.GetService("NavigationService")
                if ($navService) { $navService.GoBack() }
                return $true
            }
            ([ConsoleKey]::Enter) {
                $this.ApplySelectedTheme()
                return $true
            }
        }
        
        return ([Screen]$this).HandleInput($key)
    }
}
'@

Set-Content -Path $themeScreenPath -Value $themeScreenContent -Force

# FIX 2: Task List Screen - Fix tab navigation
Write-Host "`nFixing Task List tab navigation..." -ForegroundColor Cyan

$taskListPath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AxiomPhoenix_v4_Split\Screens\ASC.002_TaskListScreen.ps1"
$content = Get-Content $taskListPath -Raw

# Make sure HandleInput includes Tab handling
if ($content -notmatch 'ConsoleKey.*Tab') {
    $handleInputPattern = '(\[bool\]\s+HandleInput\([^\)]+\)\s*\{[^}]+)(return\s+\([^\)]+\)\.HandleInput)'
    $replacement = @'
$1            ([ConsoleKey]::Tab) {
                # Cycle focus between components
                $focusManager = $this.ServiceContainer.GetService("FocusManager")
                if ($focusManager) {
                    if ($this._taskListBox.IsFocused) {
                        $focusManager.SetFocus($this._filterBox)
                    } else {
                        $focusManager.SetFocus($this._taskListBox)
                    }
                }
                return $true
            }
        }
        
        $2
'@
    $content = $content -replace $handleInputPattern, $replacement
    Set-Content -Path $taskListPath -Value $content -Force
}

# FIX 3: New Task Screen - Complete spacing overhaul
Write-Host "`nFixing New Task Screen spacing..." -ForegroundColor Cyan

$newTaskPath = "C:\Users\jhnhe\Documents\GitHub\_XP\_mono\AxiomPhoenix_v4_Split\Screens\ASC.004_NewTaskScreen.ps1"
$newTaskContent = Get-Content $newTaskPath -Raw

# Replace the entire Initialize method with properly spaced version
$initializePattern = '(\[void\]\s+Initialize\(\)\s*\{[^}]+\})'
$newInitialize = @'
    [void] Initialize() {
        # Main form panel - full screen
        $this._formPanel = [Panel]::new("NewTaskForm")
        $this._formPanel.X = 0
        $this._formPanel.Y = 0
        $this._formPanel.Width = $this.Width
        $this._formPanel.Height = $this.Height
        $this._formPanel.Title = " New Task "
        $this._formPanel.BorderStyle = "Double"
        $this._formPanel.BorderColor = Get-ThemeColor "Primary"
        $this._formPanel.BackgroundColor = Get-ThemeColor "Background"
        $this.AddChild($this._formPanel)
        
        # Layout with generous spacing
        $leftMargin = 5
        $topMargin = 3
        $labelHeight = 1
        $inputHeight = 3
        $sectionGap = 3  # Gap between sections
        $contentWidth = [Math]::Min(100, $this._formPanel.Width - ($leftMargin * 2))
        
        $currentY = $topMargin
        
        # Title Section
        $titleLabel = [LabelComponent]::new("TitleLabel")
        $titleLabel.Text = "Task Title:"
        $titleLabel.X = $leftMargin
        $titleLabel.Y = $currentY
        $titleLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($titleLabel)
        
        $currentY += $labelHeight + 1
        
        $this._titleBox = [TextBoxComponent]::new("TitleInput")
        $this._titleBox.X = $leftMargin
        $this._titleBox.Y = $currentY
        $this._titleBox.Width = $contentWidth
        $this._titleBox.Height = $inputHeight
        $this._titleBox.Placeholder = "Enter task title..."
        $this._titleBox.IsFocusable = $true
        $this._formPanel.AddChild($this._titleBox)
        
        $currentY += $inputHeight + $sectionGap
        
        # Description Section
        $descLabel = [LabelComponent]::new("DescLabel")
        $descLabel.Text = "Description:"
        $descLabel.X = $leftMargin
        $descLabel.Y = $currentY
        $descLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($descLabel)
        
        $currentY += $labelHeight + 1
        
        $this._descriptionBox = [TextBoxComponent]::new("DescInput")
        $this._descriptionBox.X = $leftMargin
        $this._descriptionBox.Y = $currentY
        $this._descriptionBox.Width = $contentWidth
        $this._descriptionBox.Height = $inputHeight
        $this._descriptionBox.Placeholder = "Enter description..."
        $this._descriptionBox.IsFocusable = $true
        $this._formPanel.AddChild($this._descriptionBox)
        
        $currentY += $inputHeight + $sectionGap
        
        # Priority and Project side by side
        $halfWidth = [Math]::Floor(($contentWidth - 10) / 2)
        
        # Priority
        $priorityLabel = [LabelComponent]::new("PriorityLabel")
        $priorityLabel.Text = "Priority:"
        $priorityLabel.X = $leftMargin
        $priorityLabel.Y = $currentY
        $priorityLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($priorityLabel)
        
        $this._priorityList = [ListBox]::new("PriorityList")
        $this._priorityList.X = $leftMargin
        $this._priorityList.Y = $currentY + $labelHeight + 1
        $this._priorityList.Width = $halfWidth
        $this._priorityList.Height = 5
        $this._priorityList.HasBorder = $true
        $this._priorityList.BorderStyle = "Single"
        $this._priorityList.AddItem("Low")
        $this._priorityList.AddItem("Medium")
        $this._priorityList.AddItem("High")
        $this._priorityList.SelectedIndex = 1
        $this._priorityList.IsFocusable = $true
        $this._formPanel.AddChild($this._priorityList)
        
        # Project
        $projectX = $leftMargin + $halfWidth + 10
        $projectLabel = [LabelComponent]::new("ProjectLabel")
        $projectLabel.Text = "Project:"
        $projectLabel.X = $projectX
        $projectLabel.Y = $currentY
        $projectLabel.ForegroundColor = Get-ThemeColor "Foreground"
        $this._formPanel.AddChild($projectLabel)
        
        $this._projectList = [ListBox]::new("ProjectList")
        $this._projectList.X = $projectX
        $this._projectList.Y = $currentY + $labelHeight + 1
        $this._projectList.Width = $halfWidth
        $this._projectList.Height = 5
        $this._projectList.HasBorder = $true
        $this._projectList.BorderStyle = "Single"
        $this._projectList.AddItem("General")
        $this._projectList.SelectedIndex = 0
        $this._projectList.IsFocusable = $true
        $this._formPanel.AddChild($this._projectList)
        
        # Status at bottom
        $bottomY = $this._formPanel.Height - 5
        
        $this._statusLabel = [LabelComponent]::new("StatusLabel")
        $this._statusLabel.X = $leftMargin
        $this._statusLabel.Y = $bottomY
        $this._statusLabel.Text = "Ready to create task"
        $this._statusLabel.ForegroundColor = Get-ThemeColor "Info"
        $this._formPanel.AddChild($this._statusLabel)
        
        $instructLabel = [LabelComponent]::new("InstructLabel")
        $instructLabel.X = $leftMargin
        $instructLabel.Y = $bottomY + 2
        $instructLabel.Text = "Tab: Next field | Ctrl+S: Save | ESC: Cancel"
        $instructLabel.ForegroundColor = Get-ThemeColor "Subtle"
        $this._formPanel.AddChild($instructLabel)
    }
'@

$newTaskContent = $newTaskContent -replace $initializePattern, $newInitialize
Set-Content -Path $newTaskPath -Value $newTaskContent -Force

Write-Host "`nAll fixes applied!" -ForegroundColor Green
Write-Host "Run .\Start.ps1 to test the fixes" -ForegroundColor Yellow



####\Start.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Application Startup (Generated from Split Structure)
# This script loads the framework from its organized file structure.
# ==============================================================================

param(
    [string]$Theme = "Synthwave",
    [switch]$Debug
)

# Set error action preference
$ErrorActionPreference = 'Stop'
$VerbosePreference = if ($env:AXIOM_VERBOSE -eq '1') { 'Continue' } else { 'SilentlyContinue' }
$WarningPreference = $VerbosePreference

try {
    Write-Host "Loading Axiom-Phoenix v4.0 (Split Architecture)..." -ForegroundColor Cyan
    
    $scriptDir = $PSScriptRoot
    if ([string]::IsNullOrEmpty($scriptDir)) {
        $scriptDir = Get-Location
    }

    # Define the correct loading order for the framework directories
    $loadOrder = @(
        "Base",
        "Models", 
        "Functions",
        "Components",
        "Screens",
        "Services",
        "Runtime"
    )

    # Load all framework files in the correct order
    foreach ($folder in $loadOrder) {
        $folderPath = Join-Path $scriptDir $folder
        if (-not (Test-Path $folderPath)) { 
            Write-Warning "Folder not found: $folder"
            continue 
        }

        Write-Host "Loading $folder..." -ForegroundColor Gray
        $files = Get-ChildItem -Path $folderPath -Filter "*.ps1" | Sort-Object Name
        foreach ($file in $files) {
            Write-Verbose "  - Dot-sourcing $($file.Name)"
            try {
                . $file.FullName
            } catch {
                Write-Error "Failed to load $($file.Name): $($_.Exception.Message)"
                throw
            }
        }
    }

    Write-Host "`nFramework loaded successfully!`n" -ForegroundColor Green

    # Service container setup and application startup
    Write-Host "Initializing services..." -ForegroundColor Cyan
    $container = [ServiceContainer]::new()
    
    # Register core services
    Write-Host "  • Registering Logger..." -ForegroundColor Gray
    $container.Register("Logger", [Logger]::new((Join-Path $env:TEMP "axiom-phoenix.log")))
    
    Write-Host "  • Registering EventManager..." -ForegroundColor Gray  
    $container.Register("EventManager", [EventManager]::new())
    
    Write-Host "  • Registering ThemeManager..." -ForegroundColor Gray
    $container.Register("ThemeManager", [ThemeManager]::new())
    
    Write-Host "  • Registering DataManager..." -ForegroundColor Gray
    $container.Register("DataManager", [DataManager]::new((Join-Path $env:TEMP "axiom-data.json"), $container.GetService("EventManager")))
    
    Write-Host "  • Registering ActionService..." -ForegroundColor Gray
    $container.Register("ActionService", [ActionService]::new($container.GetService("EventManager")))
    
    Write-Host "  • Registering KeybindingService..." -ForegroundColor Gray
    $container.Register("KeybindingService", [KeybindingService]::new($container.GetService("ActionService")))
    
    Write-Host "  • Registering NavigationService..." -ForegroundColor Gray
    $container.Register("NavigationService", [NavigationService]::new($container))
    
    Write-Host "  • Registering FocusManager..." -ForegroundColor Gray
    $container.Register("FocusManager", [FocusManager]::new($container.GetService("EventManager")))
    
    Write-Host "  • Registering DialogManager..." -ForegroundColor Gray
    $container.Register("DialogManager", [DialogManager]::new($container))
    
    Write-Host "  • Registering ViewDefinitionService..." -ForegroundColor Gray
    $container.Register("ViewDefinitionService", [ViewDefinitionService]::new())
    
    Write-Host "Services initialized successfully!" -ForegroundColor Green

    # Initialize global state
    $global:TuiState.ServiceContainer = $container
    $global:TuiState.Services = @{
        Logger = $container.GetService("Logger")
        EventManager = $container.GetService("EventManager") 
        ThemeManager = $container.GetService("ThemeManager")
        DataManager = $container.GetService("DataManager")
        ActionService = $container.GetService("ActionService")
        KeybindingService = $container.GetService("KeybindingService")
        NavigationService = $container.GetService("NavigationService")
        FocusManager = $container.GetService("FocusManager")
        DialogManager = $container.GetService("DialogManager")
        ViewDefinitionService = $container.GetService("ViewDefinitionService")
    }
    $global:TuiState.ServiceContainer = $container

    # Apply theme and register default actions
    $themeManager = $container.GetService("ThemeManager")
    if ($themeManager -and $Theme) { 
        $themeManager.LoadTheme($Theme)
        Write-Host "Theme '$Theme' activated!" -ForegroundColor Magenta 
    }
    
    $actionService = $container.GetService("ActionService")
    if ($actionService) { 
        $actionService.RegisterDefaultActions()
        Write-Host "Default actions registered!" -ForegroundColor Green 
    }

    # Create sample data
    Write-Host "Generating sample data..." -ForegroundColor Cyan
    $dataManager = $container.GetService("DataManager")
    
    # Create sample tasks
    $sampleTasks = @()
    
    $task1 = [PmcTask]::new("Review project requirements")
    $task1.Status = [TaskStatus]::Pending
    $task1.Priority = [TaskPriority]::High
    $sampleTasks += $task1
    
    $task2 = [PmcTask]::new("Design system architecture")
    $task2.Status = [TaskStatus]::InProgress
    $task2.Priority = [TaskPriority]::High
    $task2.SetProgress(30)
    $sampleTasks += $task2
    
    $task3 = [PmcTask]::new("Implement core features")
    $task3.Status = [TaskStatus]::InProgress
    $task3.Priority = [TaskPriority]::Medium
    $task3.SetProgress(60)
    $sampleTasks += $task3
    
    $task4 = [PmcTask]::new("Write unit tests")
    $task4.Status = [TaskStatus]::Pending
    $task4.Priority = [TaskPriority]::Medium
    $sampleTasks += $task4
    
    $task5 = [PmcTask]::new("Deploy to staging")
    $task5.Status = [TaskStatus]::Pending
    $task5.Priority = [TaskPriority]::Low
    $sampleTasks += $task5
    
    foreach ($task in $sampleTasks) {
        $dataManager.AddTask($task)
    }
    
    Write-Host "Sample data created!" -ForegroundColor Green

    # Launch the application
    Write-Host "`nStarting Axiom-Phoenix v4.0..." -ForegroundColor Cyan
    Write-Host "Press Ctrl+P to open command palette, Ctrl+Q to quit" -ForegroundColor Yellow
    Start-Sleep -Seconds 1
    
    $dashboardScreen = [DashboardScreen]::new($container)
    Write-Host "Initializing Dashboard screen..." -ForegroundColor Yellow
    $dashboardScreen.Initialize()
    Write-Host "Dashboard initialized. Starting engine..." -ForegroundColor Yellow
    Clear-Host
    Start-AxiomPhoenix -ServiceContainer $container -InitialScreen $dashboardScreen

} catch {
    Write-Host "`nCRITICAL ERROR! Failed to start framework." -ForegroundColor Red
    Write-Host "$($_.Exception.Message)" -ForegroundColor Yellow
    Write-Host "$($_.ScriptStackTrace)" -ForegroundColor Red
    exit 1
}



####\Test-BasicNav.ps1
# Simple test to verify navigation works

$ErrorActionPreference = 'Stop'

Write-Host "Testing Navigation Keys..." -ForegroundColor Cyan

# Add current directory to path
$env:PSModulePath = "$PSScriptRoot;$env:PSModulePath"

# Load just the ActionService to test
Write-Host "Loading framework..." -ForegroundColor Yellow

# Load files
. "$PSScriptRoot\Base\ABC.001_CoreTypes.ps1"
. "$PSScriptRoot\Base\ABC.002_TuiAnsiHelper.ps1"
. "$PSScriptRoot\Base\ABC.003_TuiCell.ps1"
. "$PSScriptRoot\Base\ABC.004_TuiBuffer.ps1"
. "$PSScriptRoot\Base\ABC.005_UIElement.ps1"
. "$PSScriptRoot\Base\ABC.006_BaseClasses.ps1"
. "$PSScriptRoot\Base\ABC.007_ServiceContainer.ps1"
. "$PSScriptRoot\Models\AMO.001_Enums.ps1"
. "$PSScriptRoot\Models\AMO.002_Tasks.ps1"
. "$PSScriptRoot\Functions\AFN.001_TuiDrawing.ps1"
. "$PSScriptRoot\Functions\AFN.002_FactoryFunctions.ps1"
. "$PSScriptRoot\Functions\AFN.003_UtilityFunctions.ps1"

# Create minimal services
$container = [ServiceContainer]::new()

# Create logger
$logger = [Logger]::new((Join-Path $env:TEMP "test-nav.log"))
$container.Register("Logger", $logger)

# Create EventManager  
$eventManager = [EventManager]::new()
$container.Register("EventManager", $eventManager)

# Create ActionService
$actionService = [ActionService]::new($eventManager)
$container.Register("ActionService", $actionService)

# Register actions
$actionService.RegisterDefaultActions()

Write-Host "`nRegistered Actions:" -ForegroundColor Green
$actions = $actionService.GetAllActions()
foreach ($key in $actions.Keys | Sort-Object) {
    $action = $actions[$key]
    Write-Host "  $key - $($action.Description)" -ForegroundColor White
}

Write-Host "`nTesting action execution..." -ForegroundColor Yellow

# Test navigation.taskList
Write-Host "`nTesting navigation.taskList..." -ForegroundColor Cyan
try {
    $actionService.ExecuteAction("navigation.taskList", @{})
    Write-Host "  ERROR: Should have failed without NavigationService!" -ForegroundColor Red
}
catch {
    Write-Host "  ✓ Correctly failed without NavigationService" -ForegroundColor Green
}

# Test simple actions
Write-Host "`nTesting app.exit..." -ForegroundColor Cyan
$global:TuiState = @{ Running = $true }
$actionService.ExecuteAction("app.exit", @{})
if (-not $global:TuiState.Running) {
    Write-Host "  ✓ app.exit worked correctly" -ForegroundColor Green
} else {
    Write-Host "  ✗ app.exit failed" -ForegroundColor Red
}

Write-Host "`nAll basic tests passed!" -ForegroundColor Green
Write-Host "The issue appears to be elsewhere in the navigation stack." -ForegroundColor Yellow

Write-Host "`nPress any key to exit..." -ForegroundColor Cyan
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")



####\Test-ConsoleInput.ps1
# ==============================================================================
# Axiom-Phoenix v4.0 - Minimal Test Application
# Tests basic navigation without full framework overhead
# ==============================================================================

param(
    [switch]$Debug
)

$ErrorActionPreference = 'Stop'

Write-Host "Axiom-Phoenix v4.0 - Minimal Navigation Test" -ForegroundColor Cyan
Write-Host "============================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Instructions:" -ForegroundColor Yellow
Write-Host "  Press 1-4 to test navigation" -ForegroundColor White
Write-Host "  Press Q to quit" -ForegroundColor White
Write-Host "  Press any other key to see it logged" -ForegroundColor White
Write-Host ""

# Create a minimal console app to test input
$running = $true

while ($running) {
    if ([Console]::KeyAvailable) {
        $key = [Console]::ReadKey($true)
        
        Write-Host "`nKey pressed: Key='$($key.Key)', KeyChar='$($key.KeyChar)', Modifiers='$($key.Modifiers)'" -ForegroundColor Cyan
        
        switch ($key.KeyChar) {
            '1' { Write-Host "  → Would navigate to: Dashboard" -ForegroundColor Green }
            '2' { Write-Host "  → Would navigate to: Task List" -ForegroundColor Green }
            '3' { Write-Host "  → Would navigate to: Theme Picker" -ForegroundColor Green }
            '4' { Write-Host "  → Would open: Command Palette" -ForegroundColor Green }
            'q' { 
                Write-Host "  → Exiting..." -ForegroundColor Yellow
                $running = $false
            }
            'Q' { 
                Write-Host "  → Exiting..." -ForegroundColor Yellow
                $running = $false
            }
            default {
                Write-Host "  → No action for this key" -ForegroundColor Gray
            }
        }
    }
    
    Start-Sleep -Milliseconds 50
}

Write-Host "`nConsole input test completed." -ForegroundColor Green
Write-Host "If keys were detected correctly, the issue is in the framework." -ForegroundColor Yellow
Write-Host "If keys were NOT detected, the issue is with your terminal." -ForegroundColor Yellow



####\Test-DirectNav.ps1
# Direct navigation test - bypass all UI and test navigation directly

$ErrorActionPreference = 'Stop'

Write-Host "Direct Navigation Test" -ForegroundColor Cyan
Write-Host "=====================" -ForegroundColor Cyan

# Load framework
Write-Host "`nLoading framework..." -ForegroundColor Yellow

$scriptDir = $PSScriptRoot
$loadOrder = @(
    "Base",
    "Models", 
    "Functions",
    "Components",
    "Screens",
    "Services",
    "Runtime"
)

foreach ($folder in $loadOrder) {
    $folderPath = Join-Path $scriptDir $folder
    if (-not (Test-Path $folderPath)) { 
        Write-Warning "Folder not found: $folder"
        continue 
    }

    $files = Get-ChildItem -Path $folderPath -Filter "*.ps1" | Sort-Object Name
    foreach ($file in $files) {
        try {
            . $file.FullName
        } catch {
            Write-Error "Failed to load $($file.Name): $($_.Exception.Message)"
            throw
        }
    }
}

Write-Host "Framework loaded!" -ForegroundColor Green

# Create service container
Write-Host "`nCreating services..." -ForegroundColor Yellow
$container = [ServiceContainer]::new()

# Register essential services only
$container.Register("Logger", [Logger]::new((Join-Path $env:TEMP "test-nav.log")))
$container.Register("EventManager", [EventManager]::new())
$container.Register("ThemeManager", [ThemeManager]::new())
$container.Register("NavigationService", [NavigationService]::new($container))
$container.Register("FocusManager", [FocusManager]::new($container.GetService("EventManager")))

# Get services
$navService = $container.GetService("NavigationService")
$themeManager = $container.GetService("ThemeManager")

Write-Host "Services created!" -ForegroundColor Green

# Test 1: Create and navigate to Dashboard
Write-Host "`nTest 1: Creating DashboardScreen..." -ForegroundColor Cyan
try {
    $dashboard = [DashboardScreen]::new($container)
    Write-Host "  ✓ Created DashboardScreen" -ForegroundColor Green
    
    $dashboard.Initialize()
    Write-Host "  ✓ Initialized DashboardScreen" -ForegroundColor Green
    
    $navService.NavigateTo($dashboard)
    Write-Host "  ✓ Navigated to DashboardScreen" -ForegroundColor Green
    Write-Host "  Current Screen: $($navService.CurrentScreen.Name)" -ForegroundColor White
}
catch {
    Write-Host "  ✗ FAILED: $_" -ForegroundColor Red
    Write-Host "  Stack: $($_.ScriptStackTrace)" -ForegroundColor Yellow
}

# Test 2: Create and navigate to TaskListScreen
Write-Host "`nTest 2: Creating TaskListScreen..." -ForegroundColor Cyan
try {
    $taskList = [TaskListScreen]::new($container)
    Write-Host "  ✓ Created TaskListScreen" -ForegroundColor Green
    
    $taskList.Initialize()
    Write-Host "  ✓ Initialized TaskListScreen" -ForegroundColor Green
    
    $navService.NavigateTo($taskList)
    Write-Host "  ✓ Navigated to TaskListScreen" -ForegroundColor Green
    Write-Host "  Current Screen: $($navService.CurrentScreen.Name)" -ForegroundColor White
    Write-Host "  Stack Size: $($navService.NavigationStack.Count)" -ForegroundColor White
}
catch {
    Write-Host "  ✗ FAILED: $_" -ForegroundColor Red
    Write-Host "  Stack: $($_.ScriptStackTrace)" -ForegroundColor Yellow
}

# Test 3: Create and navigate to ThemeScreen
Write-Host "`nTest 3: Creating ThemeScreen..." -ForegroundColor Cyan
try {
    $themeScreen = [ThemeScreen]::new($container)
    Write-Host "  ✓ Created ThemeScreen" -ForegroundColor Green
    
    $themeScreen.Initialize()
    Write-Host "  ✓ Initialized ThemeScreen" -ForegroundColor Green
    
    $navService.NavigateTo($themeScreen)
    Write-Host "  ✓ Navigated to ThemeScreen" -ForegroundColor Green
    Write-Host "  Current Screen: $($navService.CurrentScreen.Name)" -ForegroundColor White
    Write-Host "  Stack Size: $($navService.NavigationStack.Count)" -ForegroundColor White
}
catch {
    Write-Host "  ✗ FAILED: $_" -ForegroundColor Red
    Write-Host "  Stack: $($_.ScriptStackTrace)" -ForegroundColor Yellow
}

# Test 4: Test GoBack
Write-Host "`nTest 4: Testing GoBack..." -ForegroundColor Cyan
try {
    if ($navService.CanGoBack()) {
        $navService.GoBack()
        Write-Host "  ✓ Went back successfully" -ForegroundColor Green
        Write-Host "  Current Screen: $($navService.CurrentScreen.Name)" -ForegroundColor White
        Write-Host "  Stack Size: $($navService.NavigationStack.Count)" -ForegroundColor White
    }
    else {
        Write-Host "  ! Cannot go back (no screens in stack)" -ForegroundColor Yellow
    }
}
catch {
    Write-Host "  ✗ FAILED: $_" -ForegroundColor Red
}

# Summary
Write-Host "`n===================" -ForegroundColor Cyan
Write-Host "Test Summary" -ForegroundColor Cyan
Write-Host "===================" -ForegroundColor Cyan

if ($navService.CurrentScreen) {
    Write-Host "✓ Navigation system is working" -ForegroundColor Green
    Write-Host "✓ All screens can be created and navigated to" -ForegroundColor Green
    Write-Host "`nThe issue must be in:" -ForegroundColor Yellow
    Write-Host "  - ActionService execution" -ForegroundColor White
    Write-Host "  - Input handling in DashboardScreen" -ForegroundColor White
    Write-Host "  - Global keybinding interference" -ForegroundColor White
}
else {
    Write-Host "✗ Navigation system has issues" -ForegroundColor Red
}

Write-Host "`nPress any key to exit..." -ForegroundColor Cyan
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")



####\Test-Navigation.ps1
# Test Navigation functionality
# This script tests that all navigation actions work correctly

$ErrorActionPreference = 'Stop'

# Load the framework
Write-Host "Loading framework..." -ForegroundColor Cyan
& "$PSScriptRoot\Start.ps1"

# Wait for framework to load
Start-Sleep -Seconds 2

Write-Host "`nTesting navigation actions..." -ForegroundColor Yellow

# Get services
$actionService = $global:TuiState.Services.ActionService
$navService = $global:TuiState.Services.NavigationService

if (-not $actionService -or -not $navService) {
    Write-Host "ERROR: Required services not found!" -ForegroundColor Red
    exit 1
}

Write-Host "`nRegistered actions:" -ForegroundColor Cyan
$actions = $actionService.GetAllActions()
$navigationActions = @{}
$taskActions = @{}
$uiActions = @{}

foreach ($actionName in $actions.Keys) {
    $action = $actions[$actionName]
    if ($actionName -like "navigation.*") {
        $navigationActions[$actionName] = $action
    }
    elseif ($actionName -like "task.*") {
        $taskActions[$actionName] = $action
    }
    elseif ($actionName -like "ui.*") {
        $uiActions[$actionName] = $action
    }
}

Write-Host "`nNavigation Actions:" -ForegroundColor Green
foreach ($actionName in $navigationActions.Keys | Sort-Object) {
    $action = $navigationActions[$actionName]
    Write-Host "  - $actionName : $($action.Description)" -ForegroundColor White
}

Write-Host "`nTask Actions:" -ForegroundColor Green
foreach ($actionName in $taskActions.Keys | Sort-Object) {
    $action = $taskActions[$actionName]
    Write-Host "  - $actionName : $($action.Description)" -ForegroundColor White
}

Write-Host "`nUI Actions:" -ForegroundColor Green
foreach ($actionName in $uiActions.Keys | Sort-Object) {
    $action = $uiActions[$actionName]
    Write-Host "  - $actionName : $($action.Description)" -ForegroundColor White
}

Write-Host "`nKey navigation actions to test:" -ForegroundColor Yellow
Write-Host "  1. navigation.taskList - should open Task List screen" -ForegroundColor White
Write-Host "  2. task.list - should also open Task List screen" -ForegroundColor White
Write-Host "  3. navigation.newTask - should open Theme Picker (redirected)" -ForegroundColor White
Write-Host "  4. task.new - should open Theme Picker (redirected)" -ForegroundColor White
Write-Host "  5. ui.theme.picker - should open Theme Picker directly" -ForegroundColor White

Write-Host "`nPress any key to exit..." -ForegroundColor Cyan
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

# Clean exit
Stop-TuiEngine



####\Test-QuickNav.ps1
# Quick Navigation Test
# Run this to test if navigation is working

$ErrorActionPreference = 'Stop'

Write-Host "Starting Quick Navigation Test..." -ForegroundColor Cyan

# Run the debug script
& "$PSScriptRoot\Debug-Navigation.ps1"



####\Test-WithLogging.ps1
# Test application startup and key handling

$ErrorActionPreference = 'Stop'

Write-Host "Starting Axiom-Phoenix with debugging..." -ForegroundColor Cyan

# Clear log file
$logPath = Join-Path $env:TEMP "axiom-phoenix.log"
if (Test-Path $logPath) {
    Remove-Item $logPath -Force
}

# Set verbose logging
$env:AXIOM_VERBOSE = '1'

try {
    # Start the application
    & "$PSScriptRoot\Start.ps1"
}
catch {
    Write-Host "`nERROR: $_" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Yellow
}
finally {
    # Check the log
    if (Test-Path $logPath) {
        Write-Host "`nRecent log entries:" -ForegroundColor Yellow
        Get-Content $logPath -Tail 50 | ForEach-Object {
            if ($_ -match "ERROR") {
                Write-Host $_ -ForegroundColor Red
            }
            elseif ($_ -match "WARNING") {
                Write-Host $_ -ForegroundColor Yellow
            }
            elseif ($_ -match "HandleInput|Process-TuiInput|ExecuteAction") {
                Write-Host $_ -ForegroundColor Cyan
            }
            else {
                Write-Host $_ -ForegroundColor Gray
            }
        }
    }
    
    # Reset environment
    Remove-Item env:AXIOM_VERBOSE -ErrorAction SilentlyContinue
}



