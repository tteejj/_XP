Axiom-Phoenix v4.1 - Official UI Development Guide

Document Status: Final | Effective: Immediately
Subject: The Hybrid Window Manager & Input Handling Model
Owner: Framework Architecture Team

1. Overview & Philosophy

This document outlines the correct and only supported model for input handling and focus management in the Axiom-Phoenix v4.1 framework. The previous FocusManager service is deprecated and must be removed from all screens.

Our architecture is a Hybrid Window Manager Model, mirroring mature desktop GUI frameworks. The principles are:

Each Screen is a Window Manager: It is responsible for its child components. It manages which component has focus and handles navigation between them.

Components are Self-Sufficient: When focused, a component is responsible for processing its own input (e.g., a TextBoxComponent handles typing, a ListBox handles scrolling).

Navigation is Automatic: The base Screen class provides automatic, ordered Tab / Shift+Tab navigation. You do not need to implement this.

Global Shortcuts are Centralized: The Screen handles application-wide shortcuts (Escape, F-Keys, Ctrl+ combos), providing consistent behavior across the application.

2. The Canonical Input Flow

All input follows this precise, predictable flow. Understanding this is essential.

Generated mermaid
graph TD
    A[TUI Engine sends key] --> B(Screen.HandleInput);

    subgraph Screen.HandleInput
        B --> C{Is key Tab or Shift+Tab?};
        C -->|Yes| D[Base Screen logic changes focus];
        D --> Z([END] Input Handled);
        C -->|No| E[Route key to _focusedChild.HandleInput];
    end

    E --> F(Component.HandleInput);
    subgraph Component.HandleInput
        F --> G{Is this a component-specific key?};
        G -->|Yes| H[Component performs action];
        H --> Z;
        G -->|No| I[Component returns false];
    end

    I --> J(Screen.HandleInput Fallback);
    subgraph Screen.HandleInput Fallback
        J --> K{Is this a global shortcut like Esc or F5?};
        K -->|Yes| L[Screen performs global action];
        L --> Z;
        K -->|No| M[Screen returns false];
    end
    M --> Y([END] Input Not Handled);

3. Implementing a Screen: The Window Manager

A Screen's role is orchestration, not micromanagement. It sets up its components, defines the focus order, and handles global actions.

Correct Screen Implementation

This is the blueprint for all new screens. It demonstrates proper initialization and input handling.

Generated powershell
class YourScreen : Screen {
    hidden [TextBoxComponent] $_searchBox
    hidden [ListBox] $_itemList
    hidden [ButtonComponent] $_saveButton
    
    [void] Initialize() {
        # 1. Instantiate components.
        $this._searchBox = [TextBoxComponent]::new("SearchBox")
        $this._itemList = [ListBox]::new("ItemList")
        $this._saveButton = [ButtonComponent]::new("SaveButton")
        
        # 2. Set IsFocusable on ALL interactive components.
        $this._searchBox.IsFocusable = $true
        $this._itemList.IsFocusable = $true
        $this._saveButton.IsFocusable = $true
        
        # 3. Define the navigation order with TabIndex.
        $this._searchBox.TabIndex = 0
        $this._itemList.TabIndex = 1
        $this._saveButton.TabIndex = 2
        
        # 4. Add children to the screen.
        $this.AddChild($this._searchBox)
        $this.AddChild($this._itemList)
        $this.AddChild($this._saveButton)
        
        # 5. Decorative elements MUST NOT be focusable.
        $titleLabel = [LabelComponent]::new("Title")
        $titleLabel.IsFocusable = $false
        $this.AddChild($titleLabel)
    }
    
    [void] OnEnter() {
        # The base Screen class automatically focuses the first focusable child
        # based on TabIndex. You typically do not need to set focus manually.
        
        # CRITICAL: Always call the base implementation.
        ([Screen]$this).OnEnter()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($null -eq $keyInfo) { return $false }
        
        # STEP 1: Let the base class handle Tab navigation and routing to the focused child.
        # This is the most important line in this method.
        if (([Screen]$this).HandleInput($keyInfo)) {
            return $true
        }
        
        # STEP 2: Handle screen-level global shortcuts. This code only runs if the
        # focused component did NOT handle the key.
        switch ($keyInfo.Key) {
            ([ConsoleKey]::Escape) {
                # Go back to the previous screen.
                $navService = $this.ServiceContainer.GetService("NavigationService")
                if ($navService.CanGoBack()) { $navService.GoBack() }
                return $true
            }
            ([ConsoleKey]::F5) {
                # Refresh data for the whole screen.
                $this.RefreshData()
                return $true
            }
        }
        
        # STEP 3: Handle global modifier shortcuts.
        if ($keyInfo.Modifiers -eq [ConsoleModifiers]::Control) {
            if ($keyInfo.Key -eq [ConsoleKey]::S) {
                $this.SaveData()
                return $true
            }
        }
        
        return $false // We did not handle this key.
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Powershell
IGNORE_WHEN_COPYING_END
4. Implementing a Component: The Input Handler

A component is a focused specialist. It provides visual feedback for focus and handles only the keys relevant to its function.

Correct Component Implementation
Generated powershell
class TextBoxComponent : UIElement {
    # --- Visual Feedback for Focus ---
    
    [void] OnFocus() {
        # Called by the Screen when this component gets focus.
        # Use direct property assignment for colors.
        $this.BorderColor = Get-ThemeColor "Input.FocusedBorder"
        $this.ShowCursor = $true
        $this.RequestRedraw()
    }
    
    [void] OnBlur() {
        # Called by the Screen when this component loses focus.
        $this.BorderColor = Get-ThemeColor "Input.Border"
        $this.ShowCursor = $false
        $this.RequestRedraw()
    }

    # --- Input Handling ---

    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # CRITICAL: A component MUST check if it has focus before processing input.
        if (-not $this.IsFocused) {
            return $false
        }
        
        # Handle only the keys this component cares about.
        switch ($keyInfo.Key) {
            ([ConsoleKey]::Backspace) {
                if ($this.Text.Length -gt 0) {
                    $this.Text = $this.Text.Substring(0, $this.Text.Length - 1)
                    $this.RequestRedraw()
                }
                return $true // Input handled.
            }
            ([ConsoleKey]::Enter) {
                # A component can react to Enter, e.g., by invoking an event.
                if ($this.OnEnter) { & $this.OnEnter $this }
                return $true // Input handled.
            }
            default {
                # Add character if it's printable.
                if (-not [char]::IsControl($keyInfo.KeyChar)) {
                    $this.Text += $keyInfo.KeyChar
                    $this.RequestRedraw()
                    return $true // Input handled.
                }
            }
        }
        
        # For any other key (Tab, Escape, F5, etc.), return false.
        # This allows the key to "bubble up" to the Screen for global handling.
        return $false
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Powershell
IGNORE_WHEN_COPYING_END
5. The Anti-Pattern Graveyard: What You MUST AVOID

To ensure framework stability, the following patterns are strictly forbidden.

DO NOT USE FocusManager: The FocusManager service (Services\ASE.006_FocusManager.ps1) is deprecated and must be removed from the project. All calls to it must be refactored.

DO NOT HANDLE Tab IN COMPONENTS: The Screen base class handles Tab and Shift+Tab. Any component-level tab handling will break the focus order. For complex components with internal focusable areas (like a command palette), use other keys like UpArrow/DownArrow to manage internal focus, but let Tab exit the component.

DO NOT FORGET THE BASE CALL: In a screen's HandleInput, ([Screen]$this).HandleInput($keyInfo) must be the first call. Omitting it disables all automatic focus management and input routing.

DO NOT USE Set...Color() METHODS: The UIElement class exposes public string properties ($ForegroundColor, $BackgroundColor, $BorderColor). Use direct assignment: $this.BorderColor = Get-ThemeColor "...". The old setter methods have been removed to prevent ambiguity errors.

6. Migration Checklist for Existing Screens

Use this checklist to update any screen (e.g., TaskListScreen, FileCommanderScreen) from the old model to the correct hybrid model.

Remove FocusManager: Delete all code that references the FocusManager service.

Remove Manual Focus Tracking: Delete any state variables like $_activeComponent or $_focusedIndex.

Remove Manual Tab Handling: Delete any switch cases for [ConsoleKey]::Tab.

Set IsFocusable: Go through every UI component. If it's interactive, set $component.IsFocusable = $true. If it's static/decorative, set $component.IsFocusable = $false.

Set TabIndex: Assign a unique, sequential TabIndex (0, 1, 2...) to every focusable component to define the navigation order.

Refactor HandleInput:

Make if (([Screen]$this).HandleInput($keyInfo)) { return $true } the very first line.

Move component-specific key handling (e.g., arrow keys for a list) into that component's HandleInput method.

Keep only global shortcuts (Escape, F-Keys) in the screen's HandleInput fallback section.

Implement OnFocus/OnBlur: Add these methods to your custom components to provide clear visual feedback when they become active or inactive.

Standardize Color Setting: Replace all $component.SetBackgroundColor(...) calls with $component.BackgroundColor = ....

By adhering to this guide, you will ensure that every part of the Axiom-Phoenix UI is robust, predictable, and easy to maintain.