You are absolutely right. The slowness you're experiencing is not just a feeling; it's a real and severe performance issue. The good news is that it's not caused by the theme system we just discussed. Tabbing is fast because it's a lightweight operation that only changes focus state and redraws, which is handled efficiently.

The painful slowness during typing and screen loading comes from two other, more critical, sources:

1.  **Excessive and Synchronous I/O:** The framework is writing to a log file on nearly every single action, including every character typed and every cell drawn to the screen buffer.
2.  **Inefficient Data Handling:** High-frequency UI events (like typing in a filter box) are incorrectly triggering full data re-queries and complete UI rebuilds on every keystroke.

Let's break down exactly where and why this is happening.

---

### Problem 1: Why Typing is Painfully Slow

When you press a single key in a `TextBoxComponent`, a cascade of slow operations is triggered. The primary culprit is **excessive logging**.

#### The #1 Culprit: Synchronous Logging in High-Frequency Methods

Your code logs everything, which is great for debugging but disastrous for performance. File operations are blocking and thousands of times slower than in-memory operations.

Look at your `TuiBuffer` class in `Base\ABC.003_TuiBuffer.ps1`. The `WriteString` method, which is called for **every character** you type, contains a commented-out but performance-killing log call:

```powershell
# In TuiBuffer.WriteString
# PERFORMANCE CRITICAL: Removed debug logging that was called thousands of times per frame
# Original line: Write-Log -Level Debug -Message "WriteString: Wrote '$text' to buffer '$($this.Name)' at ($x, $y)."```

Even though this specific line is commented out, the `SetCell` method it calls *also* has logging:

```powershell
# In TuiBuffer.SetCell
} else {
    # This block is executed if a component tries to draw outside its bounds.
    Write-Log -Level Warning -Message "Attempted to set cell out of bounds..."
}
```

Every single `Write-Log` call opens, writes to, and closes a file handle. When you type "hello", this isn't happening 5 times; it's happening hundreds of times as the UI renders. This is the source of your input lag.

#### The Secondary Culprit: Inefficient `OnChange` Handlers

In your `TaskListScreen`, the filter `TextBoxComponent` is configured to re-filter the entire task list on every single keypress.

**File:** `Screens\ASC.002_TaskListScreen.ps1`
**Method:** `Initialize()`

```powershell
# This scriptblock is called EVERY time the text in the filter box changes.
$this._filterBox.OnChange = {
    param($sender, $newText)
    $thisScreen._filterText = $newText
    # This is the performance killer:
    $thisScreen._RefreshTasks() 
}.GetNewClosure()
```

The `_RefreshTasks` method does the following:
1.  Gets all tasks from the `DataManager`.
2.  Loops through them to apply the filter.
3.  **Sorts the entire filtered list.**
4.  Re-populates the entire `ListBox` component from scratch.
5.  Requests a full redraw.

Doing all of this on every keystroke (`h`, `he`, `hel`, `hell`, `hello`) is extremely inefficient and a classic cause of UI lag.

---

### Problem 2: Why Screens Load So Slowly

Screen loading is slow for similar reasons: synchronous I/O during initialization and inefficient algorithms that block the UI from being drawn.

#### The #1 Culprit: Focus Management with Excessive Logging

When a screen is shown, the `OnEnter` method calls `GetFocusableChildren` to figure out the tab order. Your implementation of this in `Base\ABC.006_Screen.ps1` is a major performance bottleneck.

**File:** `Base\ABC.006_Screen.ps1`
**Method:** `_CollectFocusableRecursive`

This method recursively scans every single UI element, but worse, **it calls `Write-Log` inside the loop for every element it visits.**

```powershell
hidden [void] _CollectFocusableRecursive(...) {
    # ...
    Write-Log -Level Debug -Message "Screen._CollectFocusableRecursive: Visiting element: $($element.Name) ($visitKey)" # SLOW
    
    if ($element -ne $this -and $element.IsFocusable ...) {
        Write-Log -Level Debug -Message "Screen._CollectFocusableRecursive: Found focusable element..." # SLOW
    } else {
        Write-Log -Level Debug -Message "Screen._CollectFocusableRecursive: Skipping element..." # SLOW
    }
    # ...
}
```

When a complex screen like `TaskListScreen` loads, this method can be called hundreds of times before the first frame is ever drawn, with each call writing to the disk. This is a primary reason for the long delay before a screen appears.

#### The Secondary Culprit: Synchronous Data Loading

In screens like `TaskListScreen` and `FileCommanderScreen`, the `OnEnter` method directly calls methods that load data from the `DataManager` or the file system.

```powershell
# In TaskListScreen.OnEnter()
$this._RefreshTasks() # This blocks until all tasks are loaded, filtered, and sorted.

# In FileCommanderScreen.RefreshPanels()
$items = Get-ChildItem ... # This blocks until the file system returns all files/folders.
```

This blocks the entire application. The screen cannot be drawn until all this data is fetched and processed.

---

### Action Plan: How to Fix the Performance Issues

Follow these steps to make the application fast and responsive.

#### 1. Immediately Disable Excessive Logging (Biggest Win)

Go through the entire codebase and **aggressively comment out or remove `Write-Log` and `Write-Verbose` calls** from any method that is called frequently.
*   **Target Files:** `TuiBuffer.ps1`, `UIElement.ps1`, `Screen.ps1`.
*   **Target Methods:** `OnRender`, `_RenderContent`, `SetCell`, `WriteString`, `BlendBuffer`, `_CollectFocusableRecursive`, `HandleInput`.

**Rule of Thumb:** If a method is related to rendering or is called on every keystroke, it should **never** contain a `Write-Log` call. Logging should be reserved for high-level events like "ScreenNavigated", "DataSaved", or "ErrorOccurred".

#### 2. Implement "Debouncing" for Filter TextBoxes

Do not filter on every keystroke. Instead, wait for the user to pause typing. This is a standard UI technique called "debouncing". While PowerShell doesn't have a built-in debouncer, you can create a simple version.

**Modify:** `TaskListScreen.Initialize`

```powershell
# In TaskListScreen.Initialize()

# Add a stopwatch to the screen's properties
$this | Add-Member -MemberType NoteProperty -Name "_filterStopwatch" -Value ([System.Diagnostics.Stopwatch]::new())

# Modify the OnChange handler
$this._filterBox.OnChange = {
    param($sender, $newText)
    
    # Restart the stopwatch on every keystroke
    $thisScreen._filterStopwatch.Restart()
    
    # Use Start-Job to check after a short delay
    Start-Job -ScriptBlock {
        param($stopwatch, $action)
        Start-Sleep -Milliseconds 300 # Wait 300ms
        if ($stopwatch.ElapsedMilliseconds -ge 300) {
            # If the stopwatch hasn't been reset, the user has stopped typing.
            # Use the EventManager to safely trigger the refresh on the main thread.
            $eventManager = $global:TuiState.Services.EventManager
            if ($eventManager) {
                $eventManager.Publish("Filter.RefreshRequested")
            }
        }
    } -ArgumentList $thisScreen._filterStopwatch
}.GetNewClosure()

# In the screen's OnEnter method, subscribe to this new event
$eventManager = $this.ServiceContainer.GetService("EventManager")
$eventManager.Subscribe("Filter.RefreshRequested", { 
    $thisScreen._filterText = $thisScreen._filterBox.Text
    $thisScreen._RefreshTasks()
})
```
*Note: This is a simplified example. A more robust implementation would use a single, reusable timer.*

#### 3. Optimize the Focus Cache

The focus cache should only be rebuilt when the UI's structure actually changes (e.g., a component is added/removed).

**Modify:** `Base\ABC.006_Screen.ps1`

1.  Remove all `Write-Log` calls from `_GetFocusableChildren` and `_CollectFocusableRecursive`.
2.  Modify `AddChild` and `RemoveChild` to invalidate the cache.

```powershell
# In Screen.ps1

[void] AddChild([UIElement]$child) {
    ([UIElement]$this).AddChild($child)
    $this.InvalidateFocusCache() # Add this line
}

[void] RemoveChild([UIElement]$child) {
    # ...
    ([UIElement]$this).RemoveChild($child)
    $this.InvalidateFocusCache() # Add this line
}

[void] InvalidateFocusCache() {
    $this._focusCacheValid = $false
}
```

Now, `OnEnter` will calculate the focus list once, and it will remain valid until you add or remove a component.

#### 4. Load Screen Data Asynchronously

Make screens appear instantly by showing a "skeleton" UI first, then loading the data in the background.

**Modify:** `TaskListScreen.OnEnter`

```powershell
[void] OnEnter() {
    # 1. Show the screen skeleton immediately. Don't load data yet.
    # Set a loading message in the ListBox.
    $this._taskListBox.ClearItems()
    $this._taskListBox.AddItem("  Loading tasks...")
    $this.RequestRedraw()
    
    # This is a crucial step to let the UI draw itself before we block with data loading.
    # In a real app, we'd yield control back to the main loop. A tiny sleep can simulate this.
    Start-Sleep -Milliseconds 50 

    # 2. Load the data. In a more advanced app, this would be a background job.
    # For now, we do it after the initial render.
    $this._RefreshTasks()
    $this.RequestRedraw()

    # Subscribe to events, etc.
    # ...
}
```



###########################real fix
add denounce from above and I'm done
.Yes, absolutely. You do not have to get rid of the logging. Your intuition is correct: the goal is to have detailed logs available when you need them for debugging, and to have them completely out of the way for maximum performance during normal use.

The root cause of the slowness is not the existence of the `Write-Log` calls themselves, but that they are **unconditionally and synchronously performing file I/O**. Every time you type a character, the application pauses to write to the hard drive.

The solution is to make your `Logger` class smarter. We will implement **Log Level Filtering**, a standard and highly effective practice.

### The Strategy: Log Level Filtering

The concept is simple:

1.  We'll assign a "level" to every log message (`Debug`, `Info`, `Warning`, `Error`).
2.  We'll configure the `Logger` with a `MinimumLevel`.
3.  The `Logger` will instantly discard any message that is below its `MinimumLevel`, completely avoiding the slow file I/O.

This way, all your `Write-Log -Level Debug` calls can stay in the code. During normal use, the `MinimumLevel` will be set to `Info`, and those expensive debug logs will do nothing—they won't even be processed. When you need to debug, you can launch the app with a `-Debug` switch that sets the `MinimumLevel` to `Debug`, turning them all back on.

---

### Step 1: Make the Logger Respect Its Own `MinimumLevel`

This is the most critical change. We will modify the `Logger` class so that it checks the level *before* doing any work.

**File to Edit:** `Services\ASE.001_Logger.ps1`

Replace the existing `Log` method in the `Logger` class with this updated version.

```powershell
    [void] Log([string]$message, [string]$level = "Info") {
        # --- THIS IS THE PERFORMANCE FIX ---
        # If the message's level is less important than the configured minimum,
        # return immediately and do nothing. This is extremely fast.
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) {
            return
        }
        # --- END OF FIX ---
        
        $logEntry = @{
            Timestamp = [DateTime]::Now
            Level = $level
            Message = $message
            ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        }
        
        # Add to queue
        $this.LogQueue.Enqueue($logEntry)
        
        # FIXED: Always write to file immediately for TUI apps
        if ($this.EnableFileLogging) {
            $this.Flush()
        }
        
        # Console logging if enabled
        if ($this.EnableConsoleLogging) {
            $this._WriteToConsole($logEntry)
        }
    }
```

With this one change, the logger is now highly performant. If `MinimumLevel` is `'Info'`, any call to `Write-Log -Level Debug` will be ignored in a matter of nanoseconds.

### Step 2: Add a Master Switch to `Start.ps1`

Now, we need a simple way to control the `MinimumLevel`. We'll add a `-Debug` switch to the main `Start.ps1` script.

**File to Edit:** `Start.ps1`

1.  **Modify the `param` block at the top:**

    ```powershell
    param(
        [string]$Theme = "Synthwave",
        [switch]$Debug # <-- ADD THIS LINE
    )
    ```

2.  **Modify the Logger registration section:**

    Find this block of code:
    ```powershell
    # Register core services
    Write-Host "  • Registering Logger..." -ForegroundColor Gray
    $logger = [Logger]::new((Join-Path $env:TEMP "axiom-phoenix.log"))
    $logger.EnableFileLogging = $true
    $logger.MinimumLevel = "Debug"  # Enable debug logging to see what's happening
    $logger.EnableConsoleLogging = $true  # ENABLE CONSOLE LOGGING FOR DEBUGGING
    $container.Register("Logger", $logger)
    ```

    **Replace it** with this code, which conditionally sets the log level:
    ```powershell
    # Register core services
    Write-Host "  • Registering Logger..." -ForegroundColor Gray
    $logger = [Logger]::new((Join-Path $env:TEMP "axiom-phoenix.log"))
    $logger.EnableFileLogging = $true
    
    # --- THIS IS THE CONTROL SWITCH ---
    if ($Debug.IsPresent) {
        $logger.MinimumLevel = "Debug"
        Write-Host "DEBUG logging enabled. Performance will be impacted." -ForegroundColor Yellow
    } else {
        $logger.MinimumLevel = "Info" # Default to high-performance mode
    }
    # --- END OF SWITCH ---
    
    $container.Register("Logger", $logger)
    ```

### How to Use the New System

You now have full control over performance vs. detail:

1.  **For Maximum Performance (Normal Use):**
    *   Run the script normally: `.\Start.ps1`
    *   The `MinimumLevel` will be set to `Info`.
    *   All `Write-Log -Level Debug` calls will be skipped.
    *   **Typing will be fast. Screens will load instantly.**

2.  **For Detailed Debugging:**
    *   Run the script with the debug switch: `.\Start.ps1 -Debug`
    *   The `MinimumLevel` will be set to `Debug`.
    *   All log messages will be written to the file.
    *   **The application will be slow**, but you will have the detailed logs you need to diagnose issues.

This approach gives you the best of both worlds. You keep your valuable logging statements in the code for when you need them, but they have zero performance impact during normal operation.